diff --git a/src-testing/src/materials/nodes/manager/NodeMaterialObserver.ts b/src-testing/src/materials/nodes/manager/NodeMaterialObserver.ts
index 4c5e4c7db..4f710ccca 100644
--- a/src-testing/src/materials/nodes/manager/NodeMaterialObserver.ts
+++ b/src-testing/src/materials/nodes/manager/NodeMaterialObserver.ts
@@ -1,3 +1,14 @@
+import NodeBuilder from '../../../nodes/core/NodeBuilder.js';
+import RenderObject from '../../../renderers/common/RenderObject.js';
+import { Matrix4 } from '../../../math/Matrix4.js';
+import { Material } from '../../Material.js';
+import NodeFrame from '../../../nodes/core/NodeFrame.js';
+import { BufferAttribute } from '../../../core/BufferAttribute.js';
+import Renderer from '../../../renderers/common/Renderer.js';
+import { Light } from '../../../lights/Light.js';
+import { SpotLight } from '../../../lights/SpotLight.js';
+import LightsNode from '../../../nodes/lighting/LightsNode.js';
+
 const refreshUniforms = [
     'alphaMap',
     'alphaTest',
@@ -53,7 +64,38 @@ const refreshUniforms = [
     'thickness',
     'transmission',
     'transmissionMap',
-];
+] as const;
+
+type RefreshUniform = (typeof refreshUniforms)[number];
+
+type MaterialData = {
+    [K in RefreshUniform]?: unknown;
+};
+
+interface AttributesData {
+    [name: string]: { version: number };
+}
+
+interface RenderObjectData {
+    material: MaterialData;
+    geometry: {
+        id: number;
+        attributes: AttributesData;
+        indexVersion: number | null;
+        drawRange: { start: number; count: number };
+    };
+    worldMatrix: Matrix4;
+    version?: number;
+}
+
+interface LightData {
+    map: number;
+}
+
+interface LightsCacheData {
+    renderId: number;
+    lightsData: LightData[];
+}
 
 /**
  * A WeakMap to cache lights data for node materials.
@@ -62,7 +104,7 @@ const refreshUniforms = [
  * @private
  * @type {WeakMap<LightsNode,Object>}
  */
-const _lightsCache = new WeakMap();
+const _lightsCache = new WeakMap<LightsNode, LightsCacheData>();
 
 /**
  * This class is used by {@link WebGPURenderer} as management component.
@@ -70,12 +112,18 @@ const _lightsCache = new WeakMap();
  * refresh right before they are going to be rendered or not.
  */
 class NodeMaterialObserver {
+    renderObjects: WeakMap<RenderObject, RenderObjectData>;
+    hasNode: boolean;
+    hasAnimation: boolean;
+    refreshUniforms: readonly RefreshUniform[];
+    renderId: number;
+
     /**
      * Constructs a new node material observer.
      *
      * @param {NodeBuilder} builder - The node builder.
      */
-    constructor(builder) {
+    constructor(builder: NodeBuilder) {
         /**
          * A node material can be used by more than one render object so the
          * monitor must maintain a list of render objects.
@@ -120,7 +168,7 @@ class NodeMaterialObserver {
      * @param {RenderObject} renderObject - The render object.
      * @return {boolean} Whether the given render object is verified for the first time of this observer.
      */
-    firstInitialization(renderObject) {
+    firstInitialization(renderObject: RenderObject) {
         const hasInitialized = this.renderObjects.has(renderObject);
 
         if (hasInitialized === false) {
@@ -138,7 +186,7 @@ class NodeMaterialObserver {
      * @param {Renderer} renderer - The renderer.
      * @return {boolean} Whether the current rendering produces motion vectors or not.
      */
-    needsVelocity(renderer) {
+    needsVelocity(renderer: Renderer) {
         const mrt = renderer.getMRT();
 
         return mrt !== null && mrt.has('velocity');
@@ -150,7 +198,7 @@ class NodeMaterialObserver {
      * @param {RenderObject} renderObject - The render object.
      * @return {Object} The monitoring data.
      */
-    getRenderObjectData(renderObject) {
+    getRenderObjectData(renderObject: RenderObject) {
         let data = this.renderObjects.get(renderObject);
 
         if (data === undefined) {
@@ -201,8 +249,8 @@ class NodeMaterialObserver {
      * @param {Object} attributes - The geometry attributes.
      * @return {Object} An object for monitoring the versions of attributes.
      */
-    getAttributesData(attributes) {
-        const attributesData = {};
+    getAttributesData(attributes: Record<string, BufferAttribute>) {
+        const attributesData: AttributesData = {};
 
         for (const name in attributes) {
             const attribute = attributes[name];
@@ -222,7 +270,7 @@ class NodeMaterialObserver {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {boolean} Whether the node builder's material uses node properties or not.
      */
-    containsNode(builder) {
+    containsNode(builder: NodeBuilder) {
         const material = builder.material;
 
         for (const property in material) {
@@ -247,8 +295,8 @@ class NodeMaterialObserver {
      * @param {Material} material - The material.
      * @return {Object} An object for monitoring material properties.
      */
-    getMaterialData(material) {
-        const data = {};
+    getMaterialData(material: Material) {
+        const data: MaterialData = {};
 
         for (const property of this.refreshUniforms) {
             const value = material[property];
@@ -276,7 +324,7 @@ class NodeMaterialObserver {
      * @param {Array<Light>} lightsData - The current material lights.
      * @return {boolean} Whether the given render object has changed its state or not.
      */
-    equals(renderObject, lightsData) {
+    equals(renderObject: RenderObject, lightsData: Light[]) {
         const { object, material, geometry } = renderObject;
 
         const renderObjectData = this.getRenderObjectData(renderObject);
@@ -437,14 +485,14 @@ class NodeMaterialObserver {
      * @param {Array<Light>} materialLights - The material lights.
      * @return {Array<Object>} The lights data for the given material lights.
      */
-    getLightsData(materialLights) {
-        const lights = [];
+    getLightsData(materialLights: Light[]) {
+        const lights: LightData[] = [];
 
         for (const light of materialLights) {
-            if (light.isSpotLight === true && light.map !== null) {
+            if ((light as SpotLight).isSpotLight === true && (light as SpotLight).map !== null) {
                 // only add lights that have a map
 
-                lights.push({ map: light.map.version });
+                lights.push({ map: (light as SpotLight).map!.version });
             }
         }
 
@@ -458,9 +506,9 @@ class NodeMaterialObserver {
      * @param {number} renderId - The render ID.
      * @return {Array<Object>} The lights for the given lights node and render ID.
      */
-    getLights(lightsNode, renderId) {
+    getLights(lightsNode: LightsNode, renderId: number) {
         if (_lightsCache.has(lightsNode)) {
-            const cached = _lightsCache.get(lightsNode);
+            const cached = _lightsCache.get(lightsNode)!;
 
             if (cached.renderId === renderId) {
                 return cached.lightsData;
@@ -481,7 +529,7 @@ class NodeMaterialObserver {
      * @param {NodeFrame} nodeFrame - The current node frame.
      * @return {boolean} Whether the given render object requires a refresh or not.
      */
-    needsRefresh(renderObject, nodeFrame) {
+    needsRefresh(renderObject: RenderObject, nodeFrame: NodeFrame) {
         if (
             this.hasNode ||
             this.hasAnimation ||
diff --git a/src-testing/src/nodes/accessors/BufferAttributeNode.ts b/src-testing/src/nodes/accessors/BufferAttributeNode.ts
index 6ed843b11..62cfb6646 100644
--- a/src-testing/src/nodes/accessors/BufferAttributeNode.ts
+++ b/src-testing/src/nodes/accessors/BufferAttributeNode.ts
@@ -4,7 +4,12 @@ import { varying } from '../core/VaryingNode.js';
 
 import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
 import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
-import { StaticDrawUsage, DynamicDrawUsage } from '../../constants.js';
+import { StaticDrawUsage, DynamicDrawUsage, Usage } from '../../constants.js';
+import { BufferAttribute, TypedArray } from '../../core/BufferAttribute.js';
+import { InstancedBufferAttribute } from '../../core/InstancedBufferAttribute.js';
+import NodeBuilder from '../core/NodeBuilder.js';
+import BufferNode from './BufferNode.js';
+import Node from '../core/Node.js';
 
 /**
  * Internal buffer attribute library.
@@ -12,7 +17,7 @@ import { StaticDrawUsage, DynamicDrawUsage } from '../../constants.js';
  * @private
  * @type {WeakMap<TypedArray, InterleavedBuffer>}
  */
-const _bufferLib = new WeakMap();
+const _bufferLib = new WeakMap<TypedArray, InterleavedBuffer>();
 
 /**
  * Internal method for retrieving or creating interleaved buffers.
@@ -22,7 +27,7 @@ const _bufferLib = new WeakMap();
  * @param {number} itemSize - The attribute item size.
  * @returns {InterleavedBuffer} The interleaved buffer.
  */
-function _getBufferAttribute(value, itemSize) {
+function _getBufferAttribute(value: TypedArray, itemSize: number) {
     let buffer = _bufferLib.get(value);
 
     if (buffer === undefined) {
@@ -54,13 +59,23 @@ function _getBufferAttribute(value, itemSize) {
  * ```js
  * material.positionNode = positionBuffer.toAttribute();
  * ```
- * @augments InputNode
  */
-class BufferAttributeNode extends InputNode {
+class BufferAttributeNodeClass extends InputNode<unknown, TypedArray | InterleavedBuffer | BufferAttribute> {
     static get type() {
         return 'BufferAttributeNode';
     }
 
+    readonly isBufferNode: true;
+
+    bufferType: string | null;
+    bufferStride: number;
+    bufferOffset: number;
+
+    usage: Usage;
+    instanced: boolean;
+
+    attribute: BufferAttribute | InterleavedBufferAttribute | null;
+
     /**
      * Constructs a new buffer attribute node.
      *
@@ -69,7 +84,12 @@ class BufferAttributeNode extends InputNode {
      * @param {number} [bufferStride=0] - The buffer stride.
      * @param {number} [bufferOffset=0] - The buffer offset.
      */
-    constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
+    constructor(
+        value: TypedArray | InterleavedBuffer | BufferAttribute,
+        bufferType: string | null = null,
+        bufferStride = 0,
+        bufferOffset = 0,
+    ) {
         super(value, bufferType);
 
         /**
@@ -138,10 +158,10 @@ class BufferAttributeNode extends InputNode {
          */
         this.global = true;
 
-        if (value && value.isBufferAttribute === true && value.itemSize <= 4) {
-            this.attribute = value;
-            this.usage = value.usage;
-            this.instanced = value.isInstancedBufferAttribute;
+        if (value && (value as BufferAttribute).isBufferAttribute === true && value.itemSize <= 4) {
+            this.attribute = value as BufferAttribute;
+            this.usage = (value as BufferAttribute).usage;
+            this.instanced = (value as InstancedBufferAttribute).isInstancedBufferAttribute;
         }
     }
 
@@ -152,7 +172,7 @@ class BufferAttributeNode extends InputNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The hash.
      */
-    getHash(builder) {
+    getHash(builder: NodeBuilder) {
         if (this.bufferStride === 0 && this.bufferOffset === 0) {
             let bufferData = builder.globalCache.getData(this.value);
 
@@ -177,7 +197,7 @@ class BufferAttributeNode extends InputNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The node type.
      */
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         if (this.bufferType === null) {
             this.bufferType = builder.getTypeFromAttribute(this.attribute);
         }
@@ -192,7 +212,7 @@ class BufferAttributeNode extends InputNode {
      *
      * @param {NodeBuilder} builder - The current node builder.
      */
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         if (this.attribute !== null) return;
 
         //
@@ -203,14 +223,14 @@ class BufferAttributeNode extends InputNode {
         const stride = this.bufferStride || itemSize;
         const offset = this.bufferOffset;
 
-        let buffer;
+        let buffer: InterleavedBuffer;
 
-        if (value.isInterleavedBuffer === true) {
-            buffer = value;
-        } else if (value.isBufferAttribute === true) {
-            buffer = _getBufferAttribute(value.array, stride);
+        if ((value as InterleavedBuffer).isInterleavedBuffer === true) {
+            buffer = value as InterleavedBuffer;
+        } else if ((value as BufferAttribute).isBufferAttribute === true) {
+            buffer = _getBufferAttribute((value as BufferAttribute).array, stride);
         } else {
-            buffer = _getBufferAttribute(value, stride);
+            buffer = _getBufferAttribute(value as TypedArray, stride);
         }
 
         const bufferAttribute = new InterleavedBufferAttribute(buffer, itemSize, offset);
@@ -227,13 +247,13 @@ class BufferAttributeNode extends InputNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The generated code snippet.
      */
-    generate(builder) {
+    generate(builder: NodeBuilder) {
         const nodeType = this.getNodeType(builder);
 
         const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);
         const propertyName = builder.getPropertyName(nodeAttribute);
 
-        let output = null;
+        let output: string | null | undefined = null;
 
         if (builder.shaderStage === 'vertex' || builder.shaderStage === 'compute') {
             this.name = propertyName;
@@ -264,11 +284,11 @@ class BufferAttributeNode extends InputNode {
      * @param {number} value - The usage to set.
      * @return {BufferAttributeNode} A reference to this node.
      */
-    setUsage(value) {
+    setUsage(value: Usage) {
         this.usage = value;
 
-        if (this.attribute && this.attribute.isBufferAttribute === true) {
-            this.attribute.usage = value;
+        if (this.attribute && (this.attribute as BufferAttribute).isBufferAttribute === true) {
+            (this.attribute as BufferAttribute).usage = value;
         }
 
         return this;
@@ -280,12 +300,31 @@ class BufferAttributeNode extends InputNode {
      * @param {boolean} value - The value to set.
      * @return {BufferAttributeNode} A reference to this node.
      */
-    setInstanced(value) {
+    setInstanced(value: boolean) {
         this.instanced = value;
 
         return this;
     }
 }
+declare const BufferAttributeNode: {
+    /**
+     * Constructs a new buffer attribute node.
+     *
+     * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.
+     * @param {?string} [bufferType=null] - The buffer type (e.g. `'vec3'`).
+     * @param {number} [bufferStride=0] - The buffer stride.
+     * @param {number} [bufferOffset=0] - The buffer offset.
+     */
+    new <TNodeType>(
+        value: TypedArray | InterleavedBuffer | BufferAttribute,
+        bufferType?: string | null,
+        bufferStride?: number,
+        bufferOffset?: number,
+    ): BufferAttributeNode<TNodeType>;
+};
+
+type BufferAttributeNode<TNodeType> = InputNode<TNodeType, TypedArray | InterleavedBuffer | BufferAttribute> &
+    BufferAttributeNodeClass;
 
 export default BufferAttributeNode;
 
@@ -301,7 +340,14 @@ export default BufferAttributeNode;
  * @param {boolean} [instanced=false] - Whether the buffer is instanced.
  * @returns {BufferAttributeNode|Node} The buffer attribute node.
  */
-function createBufferAttribute(array, type = null, stride = 0, offset = 0, usage = StaticDrawUsage, instanced = false) {
+function createBufferAttribute<TNodeType>(
+    array: BufferAttribute | InterleavedBuffer | TypedArray,
+    type: TNodeType | null = null,
+    stride: number = 0,
+    offset: number = 0,
+    usage: Usage = StaticDrawUsage,
+    instanced = false,
+): Node<TNodeType> {
     if (type === 'mat3' || (type === null && array.itemSize === 9)) {
         return mat3(
             new BufferAttributeNode(array, 'vec3', 9, 0).setUsage(usage).setInstanced(instanced),
@@ -323,7 +369,6 @@ function createBufferAttribute(array, type = null, stride = 0, offset = 0, usage
 /**
  * TSL function for creating a buffer attribute node.
  *
- * @tsl
  * @function
  * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.
  * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).
@@ -331,14 +376,17 @@ function createBufferAttribute(array, type = null, stride = 0, offset = 0, usage
  * @param {number} [offset=0] - The buffer offset.
  * @returns {BufferAttributeNode|Node}
  */
-export const bufferAttribute = (array, type = null, stride = 0, offset = 0) =>
-    createBufferAttribute(array, type, stride, offset);
+export const bufferAttribute = <TNodeType>(
+    array: BufferAttribute | InterleavedBuffer | TypedArray,
+    type: TNodeType | null = null,
+    stride: number = 0,
+    offset: number = 0,
+): Node<TNodeType> => createBufferAttribute(array, type, stride, offset);
 
 /**
  * TSL function for creating a buffer attribute node but with dynamic draw usage.
  * Use this function if attribute data are updated per frame.
  *
- * @tsl
  * @function
  * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.
  * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).
@@ -346,13 +394,16 @@ export const bufferAttribute = (array, type = null, stride = 0, offset = 0) =>
  * @param {number} [offset=0] - The buffer offset.
  * @returns {BufferAttributeNode|Node}
  */
-export const dynamicBufferAttribute = (array, type = null, stride = 0, offset = 0) =>
-    createBufferAttribute(array, type, stride, offset, DynamicDrawUsage);
+export const dynamicBufferAttribute = <TNodeType>(
+    array: BufferAttribute | InterleavedBuffer | TypedArray,
+    type: TNodeType | null = null,
+    stride: number = 0,
+    offset: number = 0,
+): Node<TNodeType> => createBufferAttribute(array, type, stride, offset, DynamicDrawUsage);
 
 /**
  * TSL function for creating a buffer attribute node but with enabled instancing
  *
- * @tsl
  * @function
  * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.
  * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).
@@ -360,13 +411,16 @@ export const dynamicBufferAttribute = (array, type = null, stride = 0, offset =
  * @param {number} [offset=0] - The buffer offset.
  * @returns {BufferAttributeNode|Node}
  */
-export const instancedBufferAttribute = (array, type = null, stride = 0, offset = 0) =>
-    createBufferAttribute(array, type, stride, offset, StaticDrawUsage, true);
+export const instancedBufferAttribute = <TNodeType>(
+    array: BufferAttribute | InterleavedBuffer | TypedArray,
+    type: TNodeType | null = null,
+    stride: number = 0,
+    offset: number = 0,
+): Node<TNodeType> => createBufferAttribute(array, type, stride, offset, StaticDrawUsage, true);
 
 /**
  * TSL function for creating a buffer attribute node but with dynamic draw usage and enabled instancing
  *
- * @tsl
  * @function
  * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.
  * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).
@@ -374,7 +428,19 @@ export const instancedBufferAttribute = (array, type = null, stride = 0, offset
  * @param {number} [offset=0] - The buffer offset.
  * @returns {BufferAttributeNode|Node}
  */
-export const instancedDynamicBufferAttribute = (array, type = null, stride = 0, offset = 0) =>
-    createBufferAttribute(array, type, stride, offset, DynamicDrawUsage, true);
-
-addMethodChaining('toAttribute', bufferNode => bufferAttribute(bufferNode.value));
+export const instancedDynamicBufferAttribute = <TNodeType>(
+    array: BufferAttribute | InterleavedBuffer | TypedArray,
+    type: TNodeType | null = null,
+    stride: number = 0,
+    offset: number = 0,
+): Node<TNodeType> => createBufferAttribute(array, type, stride, offset, DynamicDrawUsage, true);
+
+addMethodChaining('toAttribute', <TNodeType, TValue>(bufferNode: BufferNode<TNodeType, TValue>) =>
+    bufferAttribute(bufferNode.value),
+);
+
+declare module './BufferNode.js' {
+    interface BufferNodeExtensions<TNodeType, TValue> {
+        toAttribute: () => BufferAttributeNode<TNodeType>;
+    }
+}
diff --git a/src-testing/src/nodes/accessors/TextureNode.ts b/src-testing/src/nodes/accessors/TextureNode.ts
index a1d19b0ab..6c63e6053 100644
--- a/src-testing/src/nodes/accessors/TextureNode.ts
+++ b/src-testing/src/nodes/accessors/TextureNode.ts
@@ -12,6 +12,10 @@ import { Compatibility, IntType, LessCompare, NearestFilter, UnsignedIntType } f
 
 import { Texture } from '../../textures/Texture.js';
 import { warn, warnOnce } from '../../utils.js';
+import Node from '../core/Node.js';
+import { DepthTexture } from '../../textures/DepthTexture.js';
+import NodeBuilder from '../core/NodeBuilder.js';
+import { Matrix3 } from '../../math/Matrix3.js';
 
 const EmptyTexture = /*@__PURE__*/ new Texture();
 
@@ -20,11 +24,28 @@ const EmptyTexture = /*@__PURE__*/ new Texture();
  *
  * @augments UniformNode
  */
-class TextureNode extends UniformNode {
+class TextureNode extends UniformNode<Texture> {
     static get type() {
         return 'TextureNode';
     }
 
+    readonly isTextureNode: true;
+
+    uvNode: Node | null;
+    levelNode: Node | null;
+    biasNode: Node | null;
+    compareNode: Node | null;
+    depthNode: Node | null;
+    gradNode: Node | null;
+
+    sampler: boolean;
+    updateMatrix: boolean;
+
+    referenceNode: this | null;
+
+    _value: Texture;
+    _matrixUniform: UniformNode<Matrix3> | null;
+
     /**
      * Constructs a new texture node.
      *
@@ -33,7 +54,12 @@ class TextureNode extends UniformNode {
      * @param {?Node<int>} [levelNode=null] - The level node.
      * @param {?Node<float>} [biasNode=null] - The bias node.
      */
-    constructor(value = EmptyTexture, uvNode = null, levelNode = null, biasNode = null) {
+    constructor(
+        value: Texture = EmptyTexture,
+        uvNode: Node | null = null,
+        levelNode: Node | null = null,
+        biasNode: Node | null = null,
+    ) {
         super(value);
 
         /**
@@ -167,7 +193,7 @@ class TextureNode extends UniformNode {
         this.setUpdateMatrix(uvNode === null);
     }
 
-    set value(value) {
+    set value(value: Texture) {
         if (this.referenceNode) {
             this.referenceNode.value = value;
         } else {
@@ -201,7 +227,7 @@ class TextureNode extends UniformNode {
      * @return {string} The node type.
      */
     getNodeType(/*builder*/) {
-        if (this.value.isDepthTexture === true) return 'float';
+        if ((this.value as DepthTexture).isDepthTexture === true) return 'float';
 
         if (this.value.type === UnsignedIntType) {
             return 'uvec4';
@@ -259,7 +285,7 @@ class TextureNode extends UniformNode {
      * @param {boolean} value - The update toggle.
      * @return {TextureNode} A reference to this node.
      */
-    setUpdateMatrix(value) {
+    setUpdateMatrix(value: boolean) {
         this.updateMatrix = value;
 
         return this;
@@ -273,7 +299,7 @@ class TextureNode extends UniformNode {
      * @param {Node} uvNode - The uv node to setup.
      * @return {Node} The updated uv node.
      */
-    setupUV(builder, uvNode) {
+    setupUV(builder: NodeBuilder, uvNode) {
         if (builder.isFlipY()) {
             if (this._flipYUniform === null) this._flipYUniform = uniform(false);
 
@@ -297,7 +323,7 @@ class TextureNode extends UniformNode {
      *
      * @param {NodeBuilder} builder - The current node builder.
      */
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         const properties = builder.getNodeProperties(this);
         properties.referenceNode = this.referenceNode;
 
@@ -380,7 +406,7 @@ class TextureNode extends UniformNode {
      * @param {Node} uvNode - The uv node to generate code for.
      * @return {string} The generated code snippet.
      */
-    generateUV(builder, uvNode) {
+    generateUV(builder: NodeBuilder, uvNode: Node) {
         return uvNode.build(builder, this.sampler === true ? 'vec2' : 'ivec2');
     }
 
@@ -410,14 +436,14 @@ class TextureNode extends UniformNode {
      * @return {string} The generated code snippet.
      */
     generateSnippet(
-        builder,
-        textureProperty,
-        uvSnippet,
-        levelSnippet,
-        biasSnippet,
-        depthSnippet,
-        compareSnippet,
-        gradSnippet,
+        builder: NodeBuilder,
+        textureProperty: string,
+        uvSnippet: string | null,
+        levelSnippet: string | null,
+        biasSnippet: string | null,
+        depthSnippet: string | null,
+        compareSnippet: string | null,
+        gradSnippet: [string, string] | null,
         offsetSnippet,
     ) {
         const texture = this.value;
@@ -483,9 +509,8 @@ class TextureNode extends UniformNode {
      * @param {string} output - The current output.
      * @return {string} The generated code snippet.
      */
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output) {
         const texture = this.value;
-
         const properties = builder.getNodeProperties(this);
         const textureProperty = super.generate(builder, 'property');
 
@@ -562,7 +587,7 @@ class TextureNode extends UniformNode {
      * @param {boolean} value - The sampler value to set.
      * @return {TextureNode} A reference to this texture node.
      */
-    setSampler(value) {
+    setSampler(value: boolean) {
         this.sampler = value;
 
         return this;
@@ -609,7 +634,7 @@ class TextureNode extends UniformNode {
      * @param {Node<float>} amountNode - How blurred the texture should be.
      * @return {TextureNode} A texture node representing the texture sample.
      */
-    blur(amountNode) {
+    blur(amountNode: Node) {
         const textureNode = this.clone();
         textureNode.biasNode = nodeObject(amountNode).mul(maxMipLevel(textureNode));
         textureNode.referenceNode = this.getBase();
@@ -638,7 +663,7 @@ class TextureNode extends UniformNode {
      * @param {Node<int>} levelNode - The mip level to sample.
      * @return {TextureNode} A texture node representing the texture sample.
      */
-    level(levelNode) {
+    level(levelNode: Node | null) {
         const textureNode = this.clone();
         textureNode.levelNode = nodeObject(levelNode);
         textureNode.referenceNode = this.getBase();
diff --git a/src-testing/src/nodes/code/CodeNode.ts b/src-testing/src/nodes/code/CodeNode.ts
index 382d5107e..efe92e0c1 100644
--- a/src-testing/src/nodes/code/CodeNode.ts
+++ b/src-testing/src/nodes/code/CodeNode.ts
@@ -1,5 +1,6 @@
 import Node from '../core/Node.js';
 import { nodeProxy } from '../tsl/TSLBase.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 /**
  * This class represents native code sections. It is the base
@@ -13,6 +14,11 @@ class CodeNode extends Node {
         return 'CodeNode';
     }
 
+    readonly isCodeNode: true;
+
+    code: string;
+    language: string;
+
     /**
      * Constructs a new code node.
      *
@@ -83,11 +89,11 @@ class CodeNode extends Node {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {Array<Node>} The includes.
      */
-    getIncludes(/*builder*/) {
+    getIncludes(builder: NodeBuilder) {
         return this.includes;
     }
 
-    generate(builder) {
+    generate(builder: NodeBuilder) {
         const includes = this.getIncludes(builder);
 
         for (const include of includes) {
diff --git a/src-testing/src/nodes/code/FunctionNode.ts b/src-testing/src/nodes/code/FunctionNode.ts
index 20a55d367..b80523388 100644
--- a/src-testing/src/nodes/code/FunctionNode.ts
+++ b/src-testing/src/nodes/code/FunctionNode.ts
@@ -1,4 +1,5 @@
 import CodeNode from './CodeNode.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 /**
  * This class represents a native shader function. It can be used to implement
@@ -48,7 +49,7 @@ class FunctionNode extends CodeNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The type.
      */
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.getNodeFunction(builder).type;
     }
 
@@ -73,7 +74,7 @@ class FunctionNode extends CodeNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {Array<NodeFunctionInput>} The inputs.
      */
-    getInputs(builder) {
+    getInputs(builder: NodeBuilder) {
         return this.getNodeFunction(builder).inputs;
     }
 
@@ -83,7 +84,7 @@ class FunctionNode extends CodeNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {NodeFunction} The node function.
      */
-    getNodeFunction(builder) {
+    getNodeFunction(builder: NodeBuilder) {
         const nodeData = builder.getDataFromNode(this);
 
         let nodeFunction = nodeData.nodeFunction;
@@ -97,7 +98,7 @@ class FunctionNode extends CodeNode {
         return nodeFunction;
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null) {
         super.generate(builder);
 
         const nodeFunction = this.getNodeFunction(builder);
@@ -129,7 +130,7 @@ class FunctionNode extends CodeNode {
 
 export default FunctionNode;
 
-const nativeFn = (code, includes = [], language = '') => {
+const nativeFn = (code: string, includes = [], language = '') => {
     for (let i = 0; i < includes.length; i++) {
         const include = includes[i];
 
@@ -148,5 +149,5 @@ const nativeFn = (code, includes = [], language = '') => {
     return fn;
 };
 
-export const glslFn = (code, includes) => nativeFn(code, includes, 'glsl');
-export const wgslFn = (code, includes) => nativeFn(code, includes, 'wgsl');
+export const glslFn = (code: string, includes) => nativeFn(code, includes, 'glsl');
+export const wgslFn = (code: string, includes) => nativeFn(code, includes, 'wgsl');
diff --git a/src-testing/src/nodes/core/ContextNode.ts b/src-testing/src/nodes/core/ContextNode.ts
index f2cedcd34..ea2c2c89c 100644
--- a/src-testing/src/nodes/core/ContextNode.ts
+++ b/src-testing/src/nodes/core/ContextNode.ts
@@ -1,6 +1,7 @@
 import Node from './Node.js';
 import { addMethodChaining } from '../tsl/TSLCore.js';
 import { warn } from '../../utils.js';
+import NodeBuilder from './NodeBuilder.js';
 
 /**
  * This node can be used as a context management component for another node.
@@ -18,18 +19,23 @@ import { warn } from '../../utils.js';
  *```
  * @augments Node
  */
-class ContextNode extends Node {
+class ContextNode<TContext> extends Node {
     static get type() {
         return 'ContextNode';
     }
 
+    readonly isContextNode: true;
+
+    node: Node | null;
+    value: TContext;
+
     /**
      * Constructs a new context node.
      *
      * @param {Node} node - The node whose context should be modified.
      * @param {Object} [value={}] - The modified context data.
      */
-    constructor(node = null, value = {}) {
+    constructor(node: Node | null = null, value: TContext = {} as TContext) {
         super();
 
         /**
@@ -72,7 +78,7 @@ class ContextNode extends Node {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The node type.
      */
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.node.getNodeType(builder);
     }
 
@@ -104,15 +110,14 @@ class ContextNode extends Node {
         return this.node.getMemberType(builder, name);
     }
 
-    analyze(builder) {
+    analyze(builder: NodeBuilder) {
         const previousContext = builder.addContext(this.value);
-
         this.node.build(builder);
 
         builder.setContext(previousContext);
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         const previousContext = builder.addContext(this.value);
 
         this.node.build(builder);
@@ -120,7 +125,7 @@ class ContextNode extends Node {
         builder.setContext(previousContext);
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null) {
         const previousContext = builder.addContext(this.value);
 
         const snippet = this.node.build(builder, output);
@@ -225,7 +230,7 @@ export function builtinAOContext(aoNode, node = null) {
  * @param {string} name - The name/label to set.
  * @returns {ContextNode}
  */
-export function label(node, name) {
+export function label(node: Node, name: string) {
     warn('TSL: "label()" has been deprecated. Use "setName()" instead.'); // @deprecated r179
 
     return setName(node, name);
diff --git a/src-testing/src/nodes/core/InputNode.ts b/src-testing/src/nodes/core/InputNode.ts
index ffb7734e8..2dc76d1c9 100644
--- a/src-testing/src/nodes/core/InputNode.ts
+++ b/src-testing/src/nodes/core/InputNode.ts
@@ -1,24 +1,30 @@
 import Node from './Node.js';
 import { getValueType, getValueFromType, arrayBufferToBase64 } from './NodeUtils.js';
 import { warn } from '../../utils.js';
+import NodeBuilder from './NodeBuilder.js';
 
 /**
  * Base class for representing data input nodes.
  *
  * @augments Node
  */
-class InputNode extends Node {
+class InputNodeClass<TValue> extends Node {
     static get type() {
         return 'InputNode';
     }
 
+    readonly isInputNode: true;
+
+    value: TValue;
+    precision: 'low' | 'medium' | 'high' | null;
+
     /**
      * Constructs a new input node.
      *
      * @param {any} value - The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
      * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
      */
-    constructor(value, nodeType = null) {
+    constructor(value: TValue, nodeType: string | null = null) {
         super(nodeType);
 
         /**
@@ -46,7 +52,7 @@ class InputNode extends Node {
         this.precision = null;
     }
 
-    getNodeType(/*builder*/) {
+    getNodeType(builder: NodeBuilder) {
         if (this.nodeType === null) {
             return getValueType(this.value);
         }
@@ -64,7 +70,7 @@ class InputNode extends Node {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The input type.
      */
-    getInputType(builder) {
+    getInputType(builder: NodeBuilder) {
         return this.getNodeType(builder);
     }
 
@@ -76,7 +82,7 @@ class InputNode extends Node {
      * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.
      * @return {InputNode} A reference to this node.
      */
-    setPrecision(precision) {
+    setPrecision(precision: 'low' | 'medium' | 'high' | null) {
         this.precision = precision;
 
         return this;
@@ -107,10 +113,12 @@ class InputNode extends Node {
 
         if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);
     }
-
-    generate(/*builder, output*/) {
-        warn('Abstract function.');
-    }
 }
 
+declare const InputNode: {
+    new <TNodeType, TValue>(value: TValue, nodeType?: string | null): InputNode<TNodeType, TValue>;
+};
+
+type InputNode<TNodeType, TValue> = Node<TNodeType> & InputNodeClass<TValue>;
+
 export default InputNode;
diff --git a/src-testing/src/nodes/core/Node.ts b/src-testing/src/nodes/core/Node.ts
index 74ebc61fc..e56b4524d 100644
--- a/src-testing/src/nodes/core/Node.ts
+++ b/src-testing/src/nodes/core/Node.ts
@@ -4,6 +4,8 @@ import { hash, hashArray, hashString } from './NodeUtils.js';
 import { EventDispatcher } from '../../core/EventDispatcher.js';
 import { MathUtils } from '../../math/MathUtils.js';
 import { warn, error } from '../../utils.js';
+import NodeFrame from './NodeFrame.js';
+import NodeBuilder from './NodeBuilder.js';
 
 const _parentBuildStage = {
     analyze: 'setup',
@@ -12,22 +14,106 @@ const _parentBuildStage = {
 
 let _nodeId = 0;
 
+interface NodeConstructor {
+    type?: string;
+}
+
+interface NodeJSONMeta {
+    textures: { [key: string]: unknown };
+    images: { [key: string]: unknown };
+    nodes: { [key: string]: NodeJSONIntermediateOutputData };
+}
+
+interface NodeJSONMetadata {
+    version: number;
+    type: 'Node';
+    generator: 'Node.toJSON';
+}
+
+interface NodeJSONInputNodes {
+    [property: string]:
+        | string[]
+        | {
+              [index: string]: string | undefined;
+          }
+        | string
+        | undefined;
+}
+
+export interface NodeJSONInputData {
+    inputNodes?: NodeJSONInputNodes | undefined;
+    meta: {
+        textures: { [key: string]: unknown };
+        nodes: { [key: string]: Node };
+    };
+}
+
+export interface NodeJSONIntermediateOutputData {
+    uuid: string;
+    type: string | undefined;
+    meta?: NodeJSONMeta | undefined;
+    metadata?: NodeJSONMetadata;
+    inputNodes?: NodeJSONInputNodes | undefined;
+    textures?: unknown[];
+    images?: unknown[];
+    nodes?: NodeJSONIntermediateOutputData[];
+}
+
+interface NodeJSONOutputData {
+    uuid: string;
+    type: string | undefined;
+    metadata?: NodeJSONMetadata;
+    inputNodes?: NodeJSONInputNodes | undefined;
+    textures?: unknown[];
+    images?: unknown[];
+    nodes?: NodeJSONOutputData[];
+}
+
+export interface NodeChild {
+    property: string;
+    index?: number | string;
+    childNode: Node;
+}
+
 /**
  * Base class for all nodes.
- *
- * @augments EventDispatcher
  */
-class Node extends EventDispatcher {
+class NodeClass extends EventDispatcher<{ dispose: {} }> {
     static get type() {
         return 'Node';
     }
 
+    nodeType: string | null;
+
+    updateType: NodeUpdateType;
+    updateBeforeType: NodeUpdateType;
+    updateAfterType: NodeUpdateType;
+
+    uuid: string;
+
+    version: number;
+
+    name: string | null;
+
+    _cacheKey: number | null;
+    _cacheKeyVersion: number;
+
+    global: boolean;
+
+    parents: boolean;
+
+    readonly isNode: true;
+
+    readonly id!: number;
+
+    self?: this;
+
     /**
      * Constructs a new node.
      *
      * @param {?string} nodeType - The node type.
      */
-    constructor(nodeType = null) {
+    constructor(nodeType: string | null = null) {
         super();
 
         /**
@@ -142,11 +228,10 @@ class Node extends EventDispatcher {
     /**
      * Set this property to `true` when the node should be regenerated.
      *
-     * @type {boolean}
      * @default false
      * @param {boolean} value
      */
-    set needsUpdate(value) {
+    set needsUpdate(value: boolean) {
         if (value === true) {
             this.version++;
         }
@@ -154,12 +239,9 @@ class Node extends EventDispatcher {
 
     /**
      * The type of the class. The value is usually the constructor name.
-     *
-     * @type {string}
-     * @readonly
      */
     get type() {
-        return this.constructor.type;
+        return (this.constructor as NodeConstructor).type;
     }
 
     /**
@@ -169,7 +251,7 @@ class Node extends EventDispatcher {
      * @param {string} updateType - The update type.
      * @return {Node} A reference to this node.
      */
-    onUpdate(callback, updateType) {
+    onUpdate(callback: (this: this, frame: NodeFrame) => unknown, updateType: NodeUpdateType) {
         this.updateType = updateType;
         this.update = callback.bind(this);
 
@@ -183,7 +265,7 @@ class Node extends EventDispatcher {
      * @param {Function} callback - The update method.
      * @return {Node} A reference to this node.
      */
-    onFrameUpdate(callback) {
+    onFrameUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.FRAME);
     }
 
@@ -194,7 +276,7 @@ class Node extends EventDispatcher {
      * @param {Function} callback - The update method.
      * @return {Node} A reference to this node.
      */
-    onRenderUpdate(callback) {
+    onRenderUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.RENDER);
     }
 
@@ -205,7 +287,7 @@ class Node extends EventDispatcher {
      * @param {Function} callback - The update method.
      * @return {Node} A reference to this node.
      */
-    onObjectUpdate(callback) {
+    onObjectUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.OBJECT);
     }
 
@@ -215,7 +297,7 @@ class Node extends EventDispatcher {
      * @param {Function} callback - The update method.
      * @return {Node} A reference to this node.
      */
-    onReference(callback) {
+    onReference(callback: (this: this, frame: NodeBuilder | NodeFrame) => unknown) {
         this.updateReference = callback.bind(this);
 
         return this;
@@ -228,7 +310,7 @@ class Node extends EventDispatcher {
      * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
      * @return {any} The updated reference.
      */
-    updateReference(/*state*/) {
+    updateReference(state: NodeBuilder | NodeFrame): unknown {
         return this;
     }
 
@@ -240,7 +322,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {boolean} Whether this node is global or not.
      */
-    isGlobal(/*builder*/) {
+    isGlobal(builder: NodeBuilder) {
         return this.global;
     }
 
@@ -264,19 +346,12 @@ class Node extends EventDispatcher {
         this.dispatchEvent({ type: 'dispose' });
     }
 
-    /**
-     * Callback for {@link Node#traverse}.
-     *
-     * @callback traverseCallback
-     * @param {Node} node - The current node.
-     */
-
     /**
      * Can be used to traverse through the node's hierarchy.
      *
-     * @param {traverseCallback} callback - A callback that is executed per node.
+     * @param {callback} callback - A callback that is executed per node.
      */
-    traverse(callback) {
+    traverse(callback: (node: Node) => void) {
         callback(this);
 
         for (const childNode of this.getChildren()) {
@@ -287,11 +362,10 @@ class Node extends EventDispatcher {
     /**
      * Returns the child nodes of this node.
      *
-     * @private
      * @param {Set<Node>} [ignores=new Set()] - A set of nodes to ignore during the search to avoid circular references.
      * @returns {Array<Object>} An array of objects describing the child nodes.
      */
-    _getChildren(ignores = new Set()) {
+    private _getChildren(ignores: Set<Node> = new Set()): NodeChild[] {
         const children = [];
 
         // avoid circular references
@@ -339,7 +413,7 @@ class Node extends EventDispatcher {
      * @param {Set<Node>} [ignores=null] - A set of nodes to ignore during the computation of the cache key.
      * @return {number} The cache key of the node.
      */
-    getCacheKey(force = false, ignores = null) {
+    getCacheKey(force = false, ignores: Set<Node> | null = null) {
         force = force || this.version !== this._cacheKeyVersion;
 
         if (force === true || this._cacheKey === null) {
@@ -388,7 +462,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The hash.
      */
-    getHash(/*builder*/) {
+    getHash(builder: NodeBuilder) {
         return this.uuid;
     }
 
@@ -427,7 +501,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The type of the node.
      */
-    getElementType(builder) {
+    getElementType(builder: NodeBuilder) {
         const type = this.getNodeType(builder);
         const elementType = builder.getElementType(type);
 
@@ -441,7 +515,7 @@ class Node extends EventDispatcher {
      * @param {string} name - The name of the member.
      * @return {string} The type of the node.
      */
-    getMemberType(/*builder, name*/) {
+    getMemberType(builder: NodeBuilder, name: string) {
         return 'void';
     }
 
@@ -451,7 +525,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The type of the node.
      */
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder): string | null {
         const nodeProperties = builder.getNodeProperties(this);
 
         if (nodeProperties.outputNode) {
@@ -470,7 +544,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {Node} The shared node if possible. Otherwise `this` is returned.
      */
-    getShared(builder) {
+    getShared(builder: NodeBuilder) {
         const hash = this.getHash(builder);
         const nodeFromHash = builder.getNodeFromHash(hash);
 
@@ -483,7 +557,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {?number} The number of elements in the node array.
      */
-    getArrayCount(/*builder*/) {
+    getArrayCount(builder: NodeBuilder): number | null {
         return null;
     }
 
@@ -495,13 +569,13 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {?Node} The output node.
      */
-    setup(builder) {
+    setup(builder: NodeBuilder): unknown {
         const nodeProperties = builder.getNodeProperties(this);
 
         let index = 0;
 
         for (const childNode of this.getChildren()) {
-            nodeProperties['node' + index++] = childNode;
+            nodeProperties[`node${index++}`] = childNode;
         }
 
         // return a outputNode if exists or null
@@ -516,7 +590,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @param {?Node} output - The target output node.
      */
-    analyze(builder, output = null) {
+    analyze(builder: NodeBuilder, output: Node | null = null) {
         const usageCount = builder.increaseUsage(this);
 
         if (this.parents === true) {
@@ -532,8 +606,8 @@ class Node extends EventDispatcher {
             const nodeProperties = builder.getNodeProperties(this);
 
             for (const childNode of Object.values(nodeProperties)) {
-                if (childNode && childNode.isNode === true) {
-                    childNode.build(builder, this);
+                if (childNode && (childNode as Node).isNode === true) {
+                    (childNode as Node).build(builder, this);
                 }
             }
         }
@@ -547,7 +621,7 @@ class Node extends EventDispatcher {
      * @param {?string} [output] - Can be used to define the output type.
      * @return {?string} The generated shader string.
      */
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null): string | null | undefined {
         const { outputNode } = builder.getNodeProperties(this);
 
         if (outputNode && outputNode.isNode === true) {
@@ -563,7 +637,7 @@ class Node extends EventDispatcher {
      * @param {NodeFrame} frame - A reference to the current node frame.
      * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
      */
-    updateBefore(/*frame*/) {
+    updateBefore(frame: NodeFrame) {
         warn('Abstract function.');
     }
 
@@ -575,7 +649,7 @@ class Node extends EventDispatcher {
      * @param {NodeFrame} frame - A reference to the current node frame.
      * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
      */
-    updateAfter(/*frame*/) {
+    updateAfter(frame: NodeFrame) {
         warn('Abstract function.');
     }
 
@@ -587,11 +661,11 @@ class Node extends EventDispatcher {
      * @param {NodeFrame} frame - A reference to the current node frame.
      * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
      */
-    update(/*frame*/) {
+    update(frame: NodeFrame) {
         warn('Abstract function.');
     }
 
-    before(node) {
+    before(node: Node) {
         if (this._beforeNodes === null) this._beforeNodes = [];
 
         this._beforeNodes.push(node);
@@ -609,7 +683,7 @@ class Node extends EventDispatcher {
      * @param {?(string|Node)} [output=null] - Can be used to define the output type.
      * @return {?(Node|string)} The result of the build process, depending on the build stage.
      */
-    build(builder, output = null) {
+    build(builder: NodeBuilder, output: string | Node | null = null): Node | string | null {
         const refNode = this.getShared(builder);
 
         if (this !== refNode) {
@@ -683,14 +757,14 @@ class Node extends EventDispatcher {
 				}*/
 
                 for (const childNode of Object.values(properties)) {
-                    if (childNode && childNode.isNode === true) {
-                        if (childNode.parents === true) {
-                            const childProperties = builder.getNodeProperties(childNode);
+                    if (childNode && (childNode as Node).isNode === true) {
+                        if ((childNode as Node).parents === true) {
+                            const childProperties = builder.getNodeProperties(childNode as Node);
                             childProperties.parents = childProperties.parents || [];
                             childProperties.parents.push(this);
                         }
 
-                        childNode.build(builder);
+                        (childNode as Node).build(builder);
                     }
                 }
             }
@@ -762,10 +836,10 @@ class Node extends EventDispatcher {
      *
      * @param {Object} json - The output JSON object.
      */
-    serialize(json) {
+    serialize(json: NodeJSONIntermediateOutputData) {
         const nodeChildren = this.getSerializeChildren();
 
-        const inputNodes = {};
+        const inputNodes: NodeJSONInputNodes = {};
 
         for (const { property, index, childNode } of nodeChildren) {
             if (index !== undefined) {
@@ -773,7 +847,9 @@ class Node extends EventDispatcher {
                     inputNodes[property] = Number.isInteger(index) ? [] : {};
                 }
 
-                inputNodes[property][index] = childNode.toJSON(json.meta).uuid;
+                (inputNodes[property]! as { [index: number | string]: string })[index] = childNode.toJSON(
+                    json.meta,
+                ).uuid;
             } else {
                 inputNodes[property] = childNode.toJSON(json.meta).uuid;
             }
@@ -789,33 +865,33 @@ class Node extends EventDispatcher {
      *
      * @param {Object} json - The JSON object.
      */
-    deserialize(json) {
+    deserialize(json: NodeJSONInputData) {
         if (json.inputNodes !== undefined) {
             const nodes = json.meta.nodes;
 
             for (const property in json.inputNodes) {
                 if (Array.isArray(json.inputNodes[property])) {
-                    const inputArray = [];
+                    const inputArray: Node[] = [];
 
-                    for (const uuid of json.inputNodes[property]) {
+                    for (const uuid of json.inputNodes[property] as string[]) {
                         inputArray.push(nodes[uuid]);
                     }
 
-                    this[property] = inputArray;
+                    (this[property as keyof typeof this] as Node[]) = inputArray;
                 } else if (typeof json.inputNodes[property] === 'object') {
-                    const inputObject = {};
+                    const inputObject: { [subProperty: string]: Node } = {};
 
-                    for (const subProperty in json.inputNodes[property]) {
-                        const uuid = json.inputNodes[property][subProperty];
+                    for (const subProperty in json.inputNodes[property] as { [subProperty: string]: string }) {
+                        const uuid = (json.inputNodes[property] as { [subProperty: string]: string })[subProperty];
 
                         inputObject[subProperty] = nodes[uuid];
                     }
 
-                    this[property] = inputObject;
+                    (this[property as keyof typeof this] as { [subProperty: string]: Node }) = inputObject;
                 } else {
-                    const uuid = json.inputNodes[property];
+                    const uuid = json.inputNodes[property] as string;
 
-                    this[property] = nodes[uuid];
+                    (this[property as keyof typeof this] as Node) = nodes[uuid];
                 }
             }
         }
@@ -827,7 +903,7 @@ class Node extends EventDispatcher {
      * @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.
      * @return {Object} The serialized node.
      */
-    toJSON(meta) {
+    toJSON(meta?: NodeJSONMeta | string): NodeJSONOutputData {
         const { uuid, type } = this;
         const isRoot = meta === undefined || typeof meta === 'string';
 
@@ -836,18 +912,18 @@ class Node extends EventDispatcher {
                 textures: {},
                 images: {},
                 nodes: {},
-            };
+            } satisfies NodeJSONMeta;
         }
 
         // serialize
 
-        let data = meta.nodes[uuid];
+        let data = (meta as NodeJSONMeta).nodes[uuid];
 
         if (data === undefined) {
             data = {
                 uuid,
                 type,
-                meta,
+                meta: meta as NodeJSONMeta,
                 metadata: {
                     version: 4.7,
                     type: 'Node',
@@ -855,7 +931,7 @@ class Node extends EventDispatcher {
                 },
             };
 
-            if (isRoot !== true) meta.nodes[data.uuid] = data;
+            if (isRoot !== true) (meta as NodeJSONMeta).nodes[data.uuid] = data;
 
             this.serialize(data);
 
@@ -864,12 +940,12 @@ class Node extends EventDispatcher {
 
         // TODO: Copied from Object3D.toJSON
 
-        function extractFromCache(cache) {
+        function extractFromCache<T>(cache: { [key: string]: T }) {
             const values = [];
 
             for (const key in cache) {
                 const data = cache[key];
-                delete data.metadata;
+                delete (data as NodeJSONIntermediateOutputData).metadata;
                 values.push(data);
             }
 
@@ -877,9 +953,9 @@ class Node extends EventDispatcher {
         }
 
         if (isRoot) {
-            const textures = extractFromCache(meta.textures);
-            const images = extractFromCache(meta.images);
-            const nodes = extractFromCache(meta.nodes);
+            const textures = extractFromCache((meta as NodeJSONMeta).textures);
+            const images = extractFromCache((meta as NodeJSONMeta).images);
+            const nodes = extractFromCache((meta as NodeJSONMeta).nodes);
 
             if (textures.length > 0) data.textures = textures;
             if (images.length > 0) data.images = images;
@@ -890,4 +966,106 @@ class Node extends EventDispatcher {
     }
 }
 
+declare const Node: {
+    new <TNodeType>(nodeType?: TNodeType | null): Node<TNodeType>;
+    new (nodeType?: string | null): Node;
+};
+
+export interface NodeElements {}
+export interface NodeExtensions<TNodeType> {}
+
+export type NumType = 'float' | 'int' | 'uint';
+export type IntegerType = 'int' | 'uint';
+export type NumOrBoolType = NumType | 'bool';
+export type FloatVecType = 'vec2' | 'vec3' | 'vec4';
+export type MatType = 'mat2' | 'mat3' | 'mat4';
+
+export interface FloatExtensions {}
+export interface IntExtensions {}
+export interface UintExtensions {}
+export interface BoolExtensions {}
+
+export interface NumExtensions<TNum extends NumType> {}
+export interface IntegerExtensions<TInteger extends IntegerType> {}
+export interface NumOrBoolExtensions<TNumOrBool extends NumOrBoolType> {}
+
+export interface NumVec2Extensions<TNum extends NumType> {}
+export interface NumVec3Extensions<TNum extends NumType> {}
+export interface NumVec4Extensions<TNum extends NumType> {}
+
+export interface NumOrBoolVec2Extensions<TNumOrBool extends NumOrBoolType> {}
+export interface NumOrBoolVec3Extensions<TNumOrBool extends NumOrBoolType> {}
+export interface NumOrBoolVec4Extensions<TNumOrBool extends NumOrBoolType> {}
+
+export interface Vec2Extensions {}
+export interface Vec3Extensions {}
+export interface Vec4Extensions {}
+
+export interface ColorExtensions {}
+
+export interface FloatVecExtensions<TVec extends FloatVecType> {}
+
+export interface Mat2Extensions {}
+export interface Mat3Extensions {}
+export interface Mat4Extensions {}
+export interface MatExtensions<TMat extends MatType> {}
+
+type Node<TNodeType = unknown> = NodeClass &
+    NodeElements &
+    (unknown extends TNodeType ? {} : NodeExtensions<TNodeType>) &
+    (TNodeType extends 'float'
+        ? NumOrBoolExtensions<'float'> & FloatExtensions & NumExtensions<'float'>
+        : TNodeType extends 'int'
+          ? NumOrBoolExtensions<'int'> & IntExtensions & NumExtensions<'int'> & IntegerExtensions<'int'>
+          : TNodeType extends 'uint'
+            ? NumOrBoolExtensions<'uint'> & UintExtensions & NumExtensions<'uint'> & IntegerExtensions<'uint'>
+            : TNodeType extends 'bool'
+              ? NumOrBoolExtensions<'bool'> & BoolExtensions
+              : TNodeType extends 'vec2'
+                ? NumOrBoolVec2Extensions<'float'> &
+                      Vec2Extensions &
+                      NumVec2Extensions<'float'> &
+                      FloatVecExtensions<'vec2'>
+                : TNodeType extends 'ivec2'
+                  ? NumOrBoolVec2Extensions<'int'> & NumVec2Extensions<'int'>
+                  : TNodeType extends 'uvec2'
+                    ? NumOrBoolVec2Extensions<'uint'> & NumVec2Extensions<'uint'>
+                    : TNodeType extends 'bvec2'
+                      ? NumOrBoolVec2Extensions<'bool'>
+                      : TNodeType extends 'vec3'
+                        ? NumOrBoolVec3Extensions<'float'> &
+                              Vec3Extensions &
+                              NumVec3Extensions<'float'> &
+                              FloatVecExtensions<'vec3'>
+                        : TNodeType extends 'ivec3'
+                          ? NumOrBoolVec3Extensions<'int'> & NumVec3Extensions<'int'>
+                          : TNodeType extends 'uvec3'
+                            ? NumOrBoolVec3Extensions<'uint'> & NumVec3Extensions<'uint'>
+                            : TNodeType extends 'bvec3'
+                              ? NumOrBoolVec3Extensions<'bool'>
+                              : TNodeType extends 'vec4'
+                                ? NumOrBoolVec4Extensions<'float'> &
+                                      Vec4Extensions &
+                                      NumVec4Extensions<'float'> &
+                                      FloatVecExtensions<'vec4'>
+                                : TNodeType extends 'ivec4'
+                                  ? NumOrBoolVec4Extensions<'int'> & NumVec4Extensions<'int'>
+                                  : TNodeType extends 'uvec4'
+                                    ? NumOrBoolVec4Extensions<'uint'> & NumVec4Extensions<'uint'>
+                                    : TNodeType extends 'bvec4'
+                                      ? NumOrBoolVec4Extensions<'bool'>
+                                      : TNodeType extends 'color'
+                                        ? ColorExtensions
+                                        : TNodeType extends 'mat2'
+                                          ? Mat2Extensions & MatExtensions<'mat2'>
+                                          : TNodeType extends 'mat3'
+                                            ? Mat3Extensions & MatExtensions<'mat3'>
+                                            : TNodeType extends 'mat4'
+                                              ? Mat4Extensions & MatExtensions<'mat4'>
+                                              : {}) & {
+        __TypeScript_NODE_TYPE__: TNodeType;
+    };
+
 export default Node;
+
+export {};
diff --git a/src-testing/src/nodes/core/NodeAttribute.ts b/src-testing/src/nodes/core/NodeAttribute.ts
index 393325c38..5daf10951 100644
--- a/src-testing/src/nodes/core/NodeAttribute.ts
+++ b/src-testing/src/nodes/core/NodeAttribute.ts
@@ -1,3 +1,5 @@
+import Node from './Node.js';
+
 /**
  * {@link NodeBuilder} is going to create instances of this class during the build process
  * of nodes. They represent the final shader attributes that are going to be generated
@@ -5,6 +7,12 @@
  * and {@link NodeBuilder#bufferAttributes} for this purpose.
  */
 class NodeAttribute {
+    readonly isNodeAttribute: true;
+
+    name: string;
+    type: string | null;
+    node: Node | null;
+
     /**
      * Constructs a new node attribute.
      *
@@ -12,7 +20,7 @@ class NodeAttribute {
      * @param {string} type - The type of the attribute.
      * @param {?Node} node - An optional reference to the node.
      */
-    constructor(name, type, node = null) {
+    constructor(name: string, type: string | null, node: Node | null = null) {
         /**
          * This flag can be used for type testing.
          *
diff --git a/src-testing/src/nodes/core/NodeBuilder.ts b/src-testing/src/nodes/core/NodeBuilder.ts
index 61fc3f406..fbc4540f6 100644
--- a/src-testing/src/nodes/core/NodeBuilder.ts
+++ b/src-testing/src/nodes/core/NodeBuilder.ts
@@ -9,7 +9,7 @@ import StructType from './StructType.js';
 import FunctionNode from '../code/FunctionNode.js';
 import NodeMaterial from '../../materials/nodes/NodeMaterial.js';
 import { getDataFromObject, getTypeFromLength } from './NodeUtils.js';
-import { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';
+import { NodeUpdateType, defaultBuildStages, shaderStages, NodeShaderStage } from './constants.js';
 
 import {
     NumberNodeUniform,
@@ -22,8 +22,8 @@ import {
     Matrix4NodeUniform,
 } from '../../renderers/common/nodes/NodeUniform.js';
 
-import { stack } from './StackNode.js';
-import { getCurrentStack, setCurrentStack } from '../tsl/TSLBase.js';
+import StackNode, { stack } from './StackNode.js';
+import { getCurrentStack, setCurrentStack, ShaderNodeInternal } from '../tsl/TSLBase.js';
 
 import CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';
 import ChainMap from '../../renderers/common/ChainMap.js';
@@ -39,8 +39,10 @@ import {
     NearestMipmapLinearFilter,
     LinearMipmapLinearFilter,
     NormalBlending,
+    InterpolationSamplingType,
+    InterpolationSamplingMode,
 } from '../../constants.js';
-import { RenderTarget } from '../../core/RenderTarget.js';
+import { RenderTarget, RenderTargetOptions } from '../../core/RenderTarget.js';
 import { Color } from '../../math/Color.js';
 import { Vector2 } from '../../math/Vector2.js';
 import { Vector3 } from '../../math/Vector3.js';
@@ -48,13 +50,46 @@ import { Vector4 } from '../../math/Vector4.js';
 import { Float16BufferAttribute } from '../../core/BufferAttribute.js';
 import { warn, error } from '../../utils.js';
 
+import Renderer from '../../renderers/common/Renderer.js';
+import UniformNode from './UniformNode.js';
+import NodeUniformsGroup from '../../renderers/common/nodes/NodeUniformsGroup.js';
+import { Material } from '../../materials/Material.js';
+import { Object3D } from '../../core/Object3D.js';
+import { BufferGeometry } from '../../core/BufferGeometry.js';
+import NodeParser from './NodeParser.js';
+import { Scene } from '../../scenes/Scene.js';
+import { Camera } from '../../cameras/Camera.js';
+import Node from './Node.js';
+import ClippingContext from '../../renderers/common/ClippingContext.js';
+import { Mesh } from '../../objects/Mesh.js';
+import { Texture } from '../../textures/Texture.js';
+import { Matrix3 } from '../../math/Matrix3.js';
+import { Matrix4 } from '../../math/Matrix4.js';
+import { DataTexture } from '../../textures/DataTexture.js';
+import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
+import LightsNode from '../lighting/LightsNode.js';
+import StructTypeNode, { MemberLayout } from './StructTypeNode.js';
+import NodeMaterialObserver from '../../materials/nodes/manager/NodeMaterialObserver.js';
+
 let _id = 0;
 
 const sharedNodeData = new WeakMap();
 
-const rendererCache = new WeakMap();
-
-const typeFromArray = new Map([
+const rendererCache = new WeakMap<
+    Renderer,
+    ChainMap<UniformNode<unknown>[] | NodeUniformsGroup[], NodeUniformsGroup | BindGroup>
+>();
+
+type TypedArrayConstructor =
+    | typeof Int8Array
+    | typeof Int16Array
+    | typeof Int32Array
+    | typeof Uint8Array
+    | typeof Uint16Array
+    | typeof Uint32Array
+    | typeof Float32Array;
+
+const typeFromArray = new Map<TypedArrayConstructor, string>([
     [Int8Array, 'int'],
     [Int16Array, 'int'],
     [Int32Array, 'int'],
@@ -64,21 +99,98 @@ const typeFromArray = new Map([
     [Float32Array, 'float'],
 ]);
 
-const toFloat = value => {
+const toFloat = (value: unknown) => {
     if (/e/g.test(value)) {
         return String(value).replace(/\+/g, '');
     } else {
         value = Number(value);
 
-        return value + (value % 1 ? '' : '.0');
+        return value + ((value as number) % 1 ? '' : '.0');
     }
 };
 
+interface Flow {
+    code: string;
+    result?: string | null | undefined;
+    vars?: string | undefined;
+}
+
+interface Context {
+    material: Material | Material[] | null;
+    tempRead?: boolean;
+}
+
 /**
  * Base class for builders which generate a shader program based
  * on a 3D object and its node material definition.
  */
-class NodeBuilder {
+abstract class NodeBuilder {
+    object: Object3D | null;
+    material: Material | Material[] | null;
+    geometry: BufferGeometry | null;
+    renderer: Renderer;
+    parser: NodeParser;
+    scene: Scene | null;
+    camera: Camera | null;
+
+    nodes: Node[];
+    sequentialNodes: Node[];
+    updateNodes: Node[];
+    updateBeforeNodes: Node[];
+    updateAfterNodes: Node[];
+    hashNodes: { [hash: string]: Node };
+
+    observer: NodeMaterialObserver | null;
+
+    lightsNode: LightsNode | null;
+    environmentNode: Node | null;
+    fogNode: Node | null;
+
+    clippingContext: ClippingContext | null;
+
+    vertexShader: string | null;
+    fragmentShader: string | null;
+    computeShader: string | null;
+
+    flowNodes: { vertex: Node[]; fragment: Node[]; compute: Node[] };
+    flowCode: { vertex: string; fragment: string; compute: string };
+    uniforms: {
+        vertex: NodeUniform<unknown>[];
+        fragment: NodeUniform<unknown>[];
+        compute: NodeUniform<unknown>[];
+        index: number;
+    };
+    structs: { vertex: StructType[]; fragment: StructType[]; compute: StructType[]; index: number };
+    bindings: {
+        vertex: { [groupName: string]: NodeUniformsGroup[] | undefined };
+        fragment: { [groupName: string]: NodeUniformsGroup[] | undefined };
+        compute: { [groupName: string]: NodeUniformsGroup[] | undefined };
+    };
+    bindingsIndexes: { [groupName: string]: { binding: number; group: number } | undefined };
+    bindGroups: BindGroup[] | null;
+    attributes: NodeAttribute[];
+    bufferAttributes: NodeAttribute[];
+    varyings: NodeVarying[];
+    codes: { vertex?: NodeCode[] | undefined; fragment?: NodeCode[] | undefined; compute?: NodeCode[] | undefined };
+    vars: { vertex?: NodeVar[] | undefined; fragment?: NodeVar[] | undefined; compute?: NodeVar[] | undefined };
+    flow: Flow;
+    chaining: Node[];
+    stack: StackNode;
+    stacks: StackNode[];
+    tab: string;
+
+    currentFunctionNode: FunctionNode | null;
+
+    context: Context;
+
+    cache: NodeCache;
+    globalCache: NodeCache;
+
+    flowsData: WeakMap<Node, Flow>;
+
+    shaderStage: NodeShaderStage | null;
+    buildStage: string | null;
+
     /**
      * Constructs a new node builder.
      *
@@ -86,7 +198,7 @@ class NodeBuilder {
      * @param {Renderer} renderer - The current renderer.
      * @param {NodeParser} parser - A reference to a node parser.
      */
-    constructor(object, renderer, parser) {
+    constructor(object: Object3D | null, renderer: Renderer, parser: NodeParser) {
         /**
          * The 3D object.
          *
@@ -99,14 +211,14 @@ class NodeBuilder {
          *
          * @type {?Material}
          */
-        this.material = (object && object.material) || null;
+        this.material = (object && (object as Mesh).material) || null;
 
         /**
          * The geometry of the 3D object.
          *
          * @type {?BufferGeometry}
          */
-        this.geometry = (object && object.geometry) || null;
+        this.geometry = (object && (object as Mesh).geometry) || null;
 
         /**
          * The current renderer.
@@ -422,7 +534,7 @@ class NodeBuilder {
          */
         this.globalCache = this.cache;
 
-        this.flowsData = new WeakMap();
+        this.flowsData = new WeakMap<Node, Flow>();
 
         /**
          * The current shader stage.
@@ -511,7 +623,7 @@ class NodeBuilder {
      * @param {Object} options - The options of the render target.
      * @return {RenderTarget} The render target.
      */
-    createRenderTarget(width, height, options) {
+    createRenderTarget(width?: number, height?: number, options?: RenderTargetOptions) {
         return new RenderTarget(width, height, options);
     }
 
@@ -523,7 +635,7 @@ class NodeBuilder {
      * @param {Object} options - The options of the cube render target.
      * @return {CubeRenderTarget} The cube render target.
      */
-    createCubeRenderTarget(size, options) {
+    createCubeRenderTarget(size?: number, options?: RenderTargetOptions) {
         return new CubeRenderTarget(size, options);
     }
 
@@ -533,7 +645,7 @@ class NodeBuilder {
      * @param {Node} node - The node to test.
      * @return {boolean} Whether the given node is included in the internal array of nodes or not.
      */
-    includes(node) {
+    includes(node: Node) {
         return this.nodes.includes(node);
     }
 
@@ -554,12 +666,12 @@ class NodeBuilder {
      * @param {Array<NodeUniformsGroup>} bindings - List of bindings.
      * @return {BindGroup} The bind group
      */
-    _getBindGroup(groupName, bindings) {
+    _getBindGroup(groupName: string, bindings: NodeUniformsGroup[]) {
         const bindGroupsCache = this.getBindGroupsCache();
 
         //
 
-        const bindingsArray = [];
+        const bindingsArray: NodeUniformsGroup[] = [];
 
         let sharedGroup = true;
 
@@ -574,20 +686,20 @@ class NodeBuilder {
         let bindGroup;
 
         if (sharedGroup) {
-            bindGroup = bindGroupsCache.get(bindingsArray);
+            bindGroup = bindGroupsCache.get(bindingsArray) as BindGroup | undefined;
 
             if (bindGroup === undefined) {
                 bindGroup = new BindGroup(
                     groupName,
                     bindingsArray,
-                    this.bindingsIndexes[groupName].group,
+                    this.bindingsIndexes[groupName]!.group,
                     bindingsArray,
                 );
 
                 bindGroupsCache.set(bindingsArray, bindGroup);
             }
         } else {
-            bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);
+            bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName]!.group, bindingsArray);
         }
 
         return bindGroup;
@@ -600,7 +712,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {Array<NodeUniformsGroup>} The array of node uniform groups.
      */
-    getBindGroupArray(groupName, shaderStage) {
+    getBindGroupArray(groupName: string, shaderStage: NodeShaderStage) {
         const bindings = this.bindings[shaderStage];
 
         let bindGroup = bindings[groupName];
@@ -625,12 +737,12 @@ class NodeBuilder {
         let bindingsGroups = this.bindGroups;
 
         if (bindingsGroups === null) {
-            const groups = {};
+            const groups: { [groupName: string]: NodeUniformsGroup[] | undefined } = {};
             const bindings = this.bindings;
 
             for (const shaderStage of shaderStages) {
                 for (const groupName in bindings[shaderStage]) {
-                    const uniforms = bindings[shaderStage][groupName];
+                    const uniforms = bindings[shaderStage][groupName]!;
 
                     const groupUniforms = groups[groupName] || (groups[groupName] = []);
 
@@ -645,7 +757,7 @@ class NodeBuilder {
             bindingsGroups = [];
 
             for (const groupName in groups) {
-                const group = groups[groupName];
+                const group = groups[groupName]!;
 
                 const bindingsGroup = this._getBindGroup(groupName, group);
 
@@ -681,7 +793,7 @@ class NodeBuilder {
      * @param {Node} node - The node to add.
      * @param {number} hash - The hash of the node.
      */
-    setHashNode(node, hash) {
+    setHashNode(node: Node, hash: string) {
         this.hashNodes[hash] = node;
     }
 
@@ -690,7 +802,7 @@ class NodeBuilder {
      *
      * @param {Node} node - The node to add.
      */
-    addNode(node) {
+    addNode(node: Node) {
         if (this.nodes.includes(node) === false) {
             this.nodes.push(node);
 
@@ -753,7 +865,7 @@ class NodeBuilder {
      * @param {Texture} texture - The texture to check.
      * @return {boolean} Whether the given texture is filtered or not.
      */
-    isFilteredTexture(texture) {
+    isFilteredTexture(texture: Texture) {
         return (
             texture.magFilter === LinearFilter ||
             texture.magFilter === LinearMipmapNearestFilter ||
@@ -772,7 +884,7 @@ class NodeBuilder {
      *
      * @param {Node} node - The node to add.
      */
-    addChain(node) {
+    addChain(node: Node) {
         /*
 		if ( this.chaining.indexOf( node ) !== - 1 ) {
 
@@ -789,7 +901,7 @@ class NodeBuilder {
      *
      * @param {Node} node - The node to remove.
      */
-    removeChain(node) {
+    removeChain(node: Node) {
         const lastChain = this.chaining.pop();
 
         if (lastChain !== node) {
@@ -806,7 +918,7 @@ class NodeBuilder {
      * @param {string} method - The method name to resolve.
      * @return {string} The resolved method name.
      */
-    getMethod(method) {
+    getMethod(method: string) {
         return method;
     }
 
@@ -830,7 +942,7 @@ class NodeBuilder {
      * @param {number} hash - The hash of the node.
      * @return {Node} The found node.
      */
-    getNodeFromHash(hash) {
+    getNodeFromHash(hash: string) {
         return this.hashNodes[hash];
     }
 
@@ -841,7 +953,7 @@ class NodeBuilder {
      * @param {Node} node - The node to add.
      * @return {Node} The node.
      */
-    addFlow(shaderStage, node) {
+    addFlow(shaderStage: NodeShaderStage, node: Node) {
         this.flowNodes[shaderStage].push(node);
 
         return node;
@@ -852,7 +964,7 @@ class NodeBuilder {
      *
      * @param {Object} context - The context to set.
      */
-    setContext(context) {
+    setContext(context: Context) {
         this.context = context;
     }
 
@@ -903,7 +1015,7 @@ class NodeBuilder {
      *
      * @param {NodeCache} cache - The cache to set.
      */
-    setCache(cache) {
+    setCache(cache: NodeCache) {
         this.cache = cache;
     }
 
@@ -923,7 +1035,7 @@ class NodeBuilder {
      * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
      * @return {NodeCache} The cache.
      */
-    getCacheFromNode(node, parent = true) {
+    getCacheFromNode(node: Node, parent = true) {
         const data = this.getDataFromNode(node);
         if (data.cache === undefined) data.cache = new NodeCache(parent ? this.getCache() : null);
 
@@ -937,7 +1049,7 @@ class NodeBuilder {
      * @param {string} name - The requested feature.
      * @return {boolean} Whether the requested feature is supported or not.
      */
-    isAvailable(/*name*/) {
+    isAvailable(name: string) {
         return false;
     }
 
@@ -1026,9 +1138,12 @@ class NodeBuilder {
      * @param {string} uvSnippet - Snippet defining the texture coordinates.
      * @return {string} The generated shader string.
      */
-    generateTexture(/* texture, textureProperty, uvSnippet */) {
-        warn('Abstract function.');
-    }
+    abstract generateTexture(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        depthSnippet: string | null,
+    ): string;
 
     /**
      * Generates a texture LOD shader string for the given texture data.
@@ -1041,9 +1156,29 @@ class NodeBuilder {
      * @param {string} levelSnippet - Snippet defining the mip level.
      * @return {string} The generated shader string.
      */
-    generateTextureLod(/* texture, textureProperty, uvSnippet, depthSnippet, levelSnippet */) {
-        warn('Abstract function.');
-    }
+    abstract generateTextureLod(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        depthSnippet: string | null,
+        levelSnippet: string | null,
+    ): string;
+
+    abstract generateTextureGrad(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        gradSnippet: [string, string] | null,
+        depthSnippet: string | null,
+    ): string;
+
+    abstract generateTextureCompare(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        compareSnippet: string | null,
+        depthSnippet: string | null,
+    ): string;
 
     /**
      * Generates the array declaration string.
@@ -1115,7 +1250,7 @@ class NodeBuilder {
      * @param {?any} [value=null] - The value.
      * @return {string} The generated value as a shader string.
      */
-    generateConst(type, value = null) {
+    generateConst(type: string | null, value: unknown = null): string {
         if (value === null) {
             if (type === 'float' || type === 'int' || type === 'uint') value = 0;
             else if (type === 'bool') value = false;
@@ -1126,20 +1261,20 @@ class NodeBuilder {
         }
 
         if (type === 'float') return toFloat(value);
-        if (type === 'int') return `${Math.round(value)}`;
-        if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';
+        if (type === 'int') return `${Math.round(value as number)}`;
+        if (type === 'uint') return (value as number) >= 0 ? `${Math.round(value as number)}u` : '0u';
         if (type === 'bool') return value ? 'true' : 'false';
         if (type === 'color')
-            return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
+            return `${this.getType('vec3')}( ${toFloat((value as Color).r)}, ${toFloat((value as Color).g)}, ${toFloat((value as Color).b)} )`;
 
         const typeLength = this.getTypeLength(type);
 
         const componentType = this.getComponentType(type);
 
-        const generateConst = value => this.generateConst(componentType, value);
+        const generateConst = (value: unknown) => this.generateConst(componentType, value);
 
         if (typeLength === 2) {
-            return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;
+            return `${this.getType(type)}( ${generateConst((value as Vector2).x)}, ${generateConst((value as Vector2).y)} )`;
         } else if (typeLength === 3) {
             return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;
         } else if (typeLength === 4 && type !== 'mat2') {
@@ -1160,7 +1295,7 @@ class NodeBuilder {
      * @param {string} type - The type.
      * @return {string} The updated type.
      */
-    getType(type) {
+    getType(type: string | null) {
         if (type === 'color') return 'vec3';
 
         return type;
@@ -1172,7 +1307,7 @@ class NodeBuilder {
      * @param {string} name - The attribute name.
      * @return {boolean} Whether the given attribute name is defined in the geometry.
      */
-    hasGeometryAttribute(name) {
+    hasGeometryAttribute(name: string) {
         return this.geometry && this.geometry.getAttribute(name) !== undefined;
     }
 
@@ -1183,7 +1318,7 @@ class NodeBuilder {
      * @param {string} type - The attribute's type.
      * @return {NodeAttribute} The node attribute.
      */
-    getAttribute(name, type) {
+    getAttribute(name: string, type: string | null) {
         const attributes = this.attributes;
 
         // find attribute
@@ -1212,8 +1347,8 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The property name.
      */
-    getPropertyName(node /*, shaderStage*/) {
-        return node.name;
+    getPropertyName(node: unknown, shaderStage?: NodeShaderStage) {
+        return (node as { name?: string }).name;
     }
 
     /**
@@ -1222,8 +1357,8 @@ class NodeBuilder {
      * @param {string} type - The type to check.
      * @return {boolean} Whether the given type is a vector type or not.
      */
-    isVector(type) {
-        return /vec\d/.test(type);
+    isVector(type: string | null) {
+        return /vec\d/.test(type!);
     }
 
     /**
@@ -1232,8 +1367,8 @@ class NodeBuilder {
      * @param {string} type - The type to check.
      * @return {boolean} Whether the given type is a matrix type or not.
      */
-    isMatrix(type) {
-        return /mat\d/.test(type);
+    isMatrix(type: string | null) {
+        return /mat\d/.test(type!);
     }
 
     /**
@@ -1242,7 +1377,7 @@ class NodeBuilder {
      * @param {string} type - The type to check.
      * @return {boolean} Whether the given type is a reference type or not.
      */
-    isReference(type) {
+    isReference(type: string | null) {
         return (
             type === 'void' ||
             type === 'property' ||
@@ -1273,10 +1408,10 @@ class NodeBuilder {
      * @param {Texture} texture - The texture.
      * @return {string} The component type.
      */
-    getComponentTypeFromTexture(texture) {
+    getComponentTypeFromTexture(texture: Texture) {
         const type = texture.type;
 
-        if (texture.isDataTexture) {
+        if ((texture as DataTexture).isDataTexture) {
             if (type === IntType) return 'int';
             if (type === UnsignedIntType) return 'uint';
         }
@@ -1290,7 +1425,7 @@ class NodeBuilder {
      * @param {string} type - The type.
      * @return {string} The element type.
      */
-    getElementType(type) {
+    getElementType(type: string | null) {
         if (type === 'mat2') return 'vec2';
         if (type === 'mat3') return 'vec3';
         if (type === 'mat4') return 'vec4';
@@ -1304,7 +1439,7 @@ class NodeBuilder {
      * @param {string} type - The type.
      * @return {string} The component type.
      */
-    getComponentType(type) {
+    getComponentType(type: string | null) {
         type = this.getVectorType(type);
 
         if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;
@@ -1326,7 +1461,7 @@ class NodeBuilder {
      * @param {string} type - The type.
      * @return {string} The vector type.
      */
-    getVectorType(type) {
+    getVectorType(type: string | null) {
         if (type === 'color') return 'vec3';
         if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D')
             return 'vec4';
@@ -1341,11 +1476,11 @@ class NodeBuilder {
      * @param {string} [componentType='float'] - The component type.
      * @return {string} The type.
      */
-    getTypeFromLength(length, componentType = 'float') {
+    getTypeFromLength(length: number, componentType: string | null = 'float') {
         if (length === 1) return componentType;
 
         let baseType = getTypeFromLength(length);
-        const prefix = componentType === 'float' ? '' : componentType[0];
+        const prefix = componentType === 'float' ? '' : componentType![0];
 
         // fix edge case for mat2x2 being same size as vec4
         if (/mat2/.test(componentType) === true) {
@@ -1361,7 +1496,7 @@ class NodeBuilder {
      * @param {TypedArray} array - The typed array.
      * @return {string} The type.
      */
-    getTypeFromArray(array) {
+    getTypeFromArray(array: TypedArray) {
         return typeFromArray.get(array.constructor);
     }
 
@@ -1381,10 +1516,10 @@ class NodeBuilder {
      * @param {BufferAttribute} attribute - The buffer attribute.
      * @return {string} The type.
      */
-    getTypeFromAttribute(attribute) {
-        let dataAttribute = attribute;
-
-        if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;
+    getTypeFromAttribute(attribute: BufferAttribute | InterleavedBufferAttribute) {
+        const dataAttribute = (attribute as InterleavedBufferAttribute).isInterleavedBufferAttribute
+            ? (attribute as InterleavedBufferAttribute).data
+            : attribute;
 
         const array = dataAttribute.array;
         const itemSize = attribute.itemSize;
@@ -1405,15 +1540,15 @@ class NodeBuilder {
      * @param {string} type - The data type.
      * @return {number} The length.
      */
-    getTypeLength(type) {
+    getTypeLength(type: string | null) {
         const vecType = this.getVectorType(type);
-        const vecNum = /vec([2-4])/.exec(vecType);
+        const vecNum = /vec([2-4])/.exec(vecType!);
 
         if (vecNum !== null) return Number(vecNum[1]);
         if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;
-        if (/mat2/.test(type) === true) return 4;
-        if (/mat3/.test(type) === true) return 9;
-        if (/mat4/.test(type) === true) return 16;
+        if (/mat2/.test(type!) === true) return 4;
+        if (/mat3/.test(type!) === true) return 9;
+        if (/mat4/.test(type!) === true) return 16;
 
         return 0;
     }
@@ -1424,7 +1559,7 @@ class NodeBuilder {
      * @param {string} type - The matrix type.
      * @return {string} The vector type.
      */
-    getVectorFromMatrix(type) {
+    getVectorFromMatrix(type: string) {
         return type.replace('mat', 'vec');
     }
 
@@ -1437,7 +1572,7 @@ class NodeBuilder {
      * @param {string} newComponentType - The new component type.
      * @return {string} The new type.
      */
-    changeComponentType(type, newComponentType) {
+    changeComponentType(type: string, newComponentType: string) {
         return this.getTypeFromLength(this.getTypeLength(type), newComponentType);
     }
 
@@ -1447,7 +1582,7 @@ class NodeBuilder {
      * @param {string} type - The type.
      * @return {string} The integer type.
      */
-    getIntegerType(type) {
+    getIntegerType(type: string) {
         const componentType = this.getComponentType(type);
 
         if (componentType === 'int' || componentType === 'uint') return type;
@@ -1540,7 +1675,11 @@ class NodeBuilder {
      * @param {?NodeCache} cache - An optional cache.
      * @return {Object} The node data.
      */
-    getDataFromNode(node, shaderStage = this.shaderStage, cache = null) {
+    getDataFromNode(
+        node: Node,
+        shaderStage: NodeShaderStage | 'any' = this.shaderStage!,
+        cache: NodeCache | null = null,
+    ) {
         cache = cache === null ? (node.isGlobal(this) ? this.globalCache : this.cache) : cache;
 
         let nodeData = cache.getData(node);
@@ -1555,7 +1694,7 @@ class NodeBuilder {
 
         //
 
-        let data = nodeData[shaderStage];
+        let data = nodeData[shaderStage]!;
 
         const subBuilds = nodeData.any ? nodeData.any.subBuilds : null;
         const subBuild = this.getClosestSubBuild(subBuilds);
@@ -1582,7 +1721,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.
      * @return {Object} The node properties.
      */
-    getNodeProperties(node, shaderStage = 'any') {
+    getNodeProperties(node: Node, shaderStage: NodeShaderStage | 'any' = 'any') {
         const nodeData = this.getDataFromNode(node, shaderStage);
 
         return nodeData.properties || (nodeData.properties = { outputNode: null });
@@ -1595,7 +1734,7 @@ class NodeBuilder {
      * @param {string} type - The node type.
      * @return {NodeAttribute} The node attribute.
      */
-    getBufferAttributeFromNode(node, type) {
+    getBufferAttributeFromNode(node: Node, type: string | null) {
         const nodeData = this.getDataFromNode(node, 'vertex');
 
         let bufferAttribute = nodeData.bufferAttribute;
@@ -1634,7 +1773,12 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
      * @return {StructType} The struct type attribute.
      */
-    getStructTypeFromNode(node, membersLayout, name = null, shaderStage = this.shaderStage) {
+    getStructTypeFromNode(
+        node: StructTypeNode,
+        membersLayout: MemberLayout[],
+        name: string | null = null,
+        shaderStage = this.shaderStage!,
+    ) {
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
         let structType = nodeData.structType;
@@ -1678,7 +1822,12 @@ class NodeBuilder {
      * @param {?string} name - The name of the uniform.
      * @return {NodeUniform} The node uniform.
      */
-    getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {
+    getUniformFromNode(
+        node: UniformNode<unknown>,
+        type: string | null,
+        shaderStage = this.shaderStage!,
+        name: string | null = null,
+    ) {
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
         let nodeUniform = nodeData.uniform;
@@ -1709,7 +1858,13 @@ class NodeBuilder {
      *
      * @return {NodeVar} The node variable.
      */
-    getVarFromNode(node, name = null, type = node.getNodeType(this), shaderStage = this.shaderStage, readOnly = false) {
+    getVarFromNode(
+        node: Node,
+        name: string | null = null,
+        type = node.getNodeType(this),
+        shaderStage = this.shaderStage!,
+        readOnly = false,
+    ) {
         const nodeData = this.getDataFromNode(node, shaderStage);
         const subBuildVariable = this.getSubBuildProperty('variable', nodeData.subBuilds);
 
@@ -1794,11 +1949,11 @@ class NodeBuilder {
      * @return {NodeVar} The node varying.
      */
     getVaryingFromNode(
-        node,
-        name = null,
+        node: Node,
+        name: string | null = null,
         type = node.getNodeType(this),
-        interpolationType = null,
-        interpolationSampling = null,
+        interpolationType: InterpolationSamplingType | null = null,
+        interpolationSampling: InterpolationSamplingMode | null = null,
     ) {
         const nodeData = this.getDataFromNode(node, 'any');
         const subBuildVarying = this.getSubBuildProperty('varying', nodeData.subBuilds);
@@ -1868,7 +2023,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
      * @return {NodeCode} The node code.
      */
-    getCodeFromNode(node, type, shaderStage = this.shaderStage) {
+    getCodeFromNode(node: Node, type: string | null, shaderStage = this.shaderStage!) {
         const nodeData = this.getDataFromNode(node);
 
         let nodeCode = nodeData.code;
@@ -1941,7 +2096,7 @@ class NodeBuilder {
      * @param {?Node} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.
      * @return {NodeBuilder} A reference to this node builder.
      */
-    addLineFlowCode(code, node = null) {
+    addLineFlowCode(code: string, node = null) {
         if (code === '') return this;
 
         if (node !== null && this.context.nodeBlock) {
@@ -1965,7 +2120,7 @@ class NodeBuilder {
      * @param {string} code - Shader code.
      * @return {NodeBuilder} A reference to this node builder.
      */
-    addFlowCode(code) {
+    addFlowCode(code: string) {
         this.flow.code += code;
 
         return this;
@@ -2001,7 +2156,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {Object} The flow data.
      */
-    getFlowData(node /*, shaderStage*/) {
+    getFlowData(node: Node /*, shaderStage*/) {
         return this.flowsData.get(node);
     }
 
@@ -2011,7 +2166,7 @@ class NodeBuilder {
      * @param {Node} node - The node to execute.
      * @return {Object} The code flow.
      */
-    flowNode(node) {
+    flowNode(node: Node) {
         const output = node.getNodeType(this);
 
         const flowData = this.flowChildNode(node, output);
@@ -2027,12 +2182,14 @@ class NodeBuilder {
      * @param {Node} node - The node to include.
      * @returns {void}
      */
-    addInclude(node) {
+    addInclude(node: Node) {
         if (this.currentFunctionNode !== null) {
             this.currentFunctionNode.includes.push(node);
         }
     }
 
+    abstract buildFunctionCode(shaderNode: ShaderNodeInternal): string;
+
     /**
      * Returns the native shader operator name for a given generic name.
      * It is a similar type of method like {@link NodeBuilder#getMethod}.
@@ -2040,7 +2197,7 @@ class NodeBuilder {
      * @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.
      * @return {FunctionNode} The build function node.
      */
-    buildFunctionNode(shaderNode) {
+    buildFunctionNode(shaderNode: ShaderNodeInternal) {
         const fn = new FunctionNode();
 
         const previous = this.currentFunctionNode;
@@ -2060,7 +2217,7 @@ class NodeBuilder {
      * @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.
      * @return {Object}
      */
-    flowShaderNode(shaderNode) {
+    flowShaderNode(shaderNode: ShaderNodeInternal) {
         const layout = shaderNode.layout;
 
         const inputs = {
@@ -2076,7 +2233,7 @@ class NodeBuilder {
             },
         };
 
-        for (const input of layout.inputs) {
+        for (const input of layout!.inputs) {
             inputs[input.name] = new ParameterNode(input.type, input.name);
         }
 
@@ -2125,7 +2282,7 @@ class NodeBuilder {
      * @param {?string} output - Expected output type. For example 'vec3'.
      * @return {Object}
      */
-    flowStagesNode(node, output = null) {
+    flowStagesNode(node: Node, output: string | null = null) {
         const previousFlow = this.flow;
         const previousVars = this.vars;
         const previousDeclarations = this.declarations;
@@ -2133,7 +2290,7 @@ class NodeBuilder {
         const previousBuildStage = this.buildStage;
         const previousStack = this.stack;
 
-        const flow = {
+        const flow: Flow = {
             code: '',
         };
 
@@ -2149,7 +2306,7 @@ class NodeBuilder {
             flow.result = node.build(this, output);
         }
 
-        flow.vars = this.getVars(this.shaderStage);
+        flow.vars = this.getVars(this.shaderStage!);
 
         this.flow = previousFlow;
         this.vars = previousVars;
@@ -2192,10 +2349,10 @@ class NodeBuilder {
      * @param {?string} output - Expected output type. For example 'vec3'.
      * @return {Object} The code flow.
      */
-    flowChildNode(node, output = null) {
+    flowChildNode(node: Node, output: string | null = null) {
         const previousFlow = this.flow;
 
-        const flow = {
+        const flow: Flow = {
             code: '',
         };
 
@@ -2220,7 +2377,12 @@ class NodeBuilder {
      * @param {?string} propertyName - The property name to assign the result.
      * @return {?(Object|Node)} The code flow or node.build() result.
      */
-    flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {
+    flowNodeFromShaderStage(
+        shaderStage: 'vertex' | 'fragment' | 'compute',
+        node: Node,
+        output: string | null = null,
+        propertyName: string | null = null,
+    ) {
         const previousTab = this.tab;
         const previousCache = this.cache;
         const previousShaderStage = this.shaderStage;
@@ -2276,9 +2438,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The attribute code section.
      */
-    getAttributes(/*shaderStage*/) {
-        warn('Abstract function.');
-    }
+    abstract getAttributes(shaderStage: NodeShaderStage): string;
 
     /**
      * Returns the varying definitions as a shader string for the given shader stage.
@@ -2287,9 +2447,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The varying code section.
      */
-    getVaryings(/*shaderStage*/) {
-        warn('Abstract function.');
-    }
+    abstract getVaryings(shaderStage: NodeShaderStage): string;
 
     /**
      * Returns a single variable definition as a shader string for the given variable type and name.
@@ -2299,7 +2457,7 @@ class NodeBuilder {
      * @param {?number} [count=null] - The array length.
      * @return {string} The shader string.
      */
-    getVar(type, name, count = null) {
+    getVar(type: string, name: string, count: number | null = null) {
         return `${count !== null ? this.generateArrayDeclaration(type, count) : this.getType(type)} ${name}`;
     }
 
@@ -2309,7 +2467,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The variable code section.
      */
-    getVars(shaderStage) {
+    getVars(shaderStage: 'vertex' | 'fragment' | 'compute') {
         let snippet = '';
 
         const vars = this.vars[shaderStage];
@@ -2330,9 +2488,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The uniform code section.
      */
-    getUniforms(/*shaderStage*/) {
-        warn('Abstract function.');
-    }
+    abstract getUniforms(shaderStage: NodeShaderStage): string;
 
     /**
      * Returns the native code definitions as a shader string for the given shader stage.
@@ -2340,7 +2496,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The native code section.
      */
-    getCodes(shaderStage) {
+    getCodes(shaderStage: 'vertex' | 'fragment' | 'compute') {
         const codes = this.codes[shaderStage];
 
         let code = '';
@@ -2360,7 +2516,7 @@ class NodeBuilder {
      * @return {string} The hash.
      */
     getHash() {
-        return this.vertexShader + this.fragmentShader + this.computeShader;
+        return this.vertexShader! + this.fragmentShader + this.computeShader;
     }
 
     /**
@@ -2368,7 +2524,7 @@ class NodeBuilder {
      *
      * @param {?('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage to set.
      */
-    setShaderStage(shaderStage) {
+    setShaderStage(shaderStage: NodeShaderStage | null) {
         this.shaderStage = shaderStage;
     }
 
@@ -2386,7 +2542,7 @@ class NodeBuilder {
      *
      * @param {?('setup'|'analyze'|'generate')} buildStage - The build stage to set.
      */
-    setBuildStage(buildStage) {
+    setBuildStage(buildStage: string | null) {
         this.buildStage = buildStage;
     }
 
@@ -2592,7 +2748,7 @@ class NodeBuilder {
      * @param {string} type - The requested type.
      * @return {Uniform} The uniform.
      */
-    getNodeUniform(uniformNode, type) {
+    getNodeUniform(uniformNode: NodeUniform<unknown>, type: string | null) {
         const nodeData = this.getSharedDataFromNode(uniformNode);
 
         let node = nodeData.cache;
@@ -2629,7 +2785,7 @@ class NodeBuilder {
      * @param {string} toType - The target type.
      * @return {string} The updated shader string.
      */
-    format(snippet, fromType, toType) {
+    format(snippet: string, fromType: string | null, toType: string | null): string {
         fromType = this.getVectorType(fromType);
         toType = this.getVectorType(toType);
 
diff --git a/src-testing/src/nodes/core/NodeCache.ts b/src-testing/src/nodes/core/NodeCache.ts
index 60ca00391..cbbfb7c82 100644
--- a/src-testing/src/nodes/core/NodeCache.ts
+++ b/src-testing/src/nodes/core/NodeCache.ts
@@ -1,16 +1,64 @@
+import NodeAttribute from './NodeAttribute.js';
+import NodeUniform from './NodeUniform.js';
+import NodeVar from './NodeVar.js';
+import NodeVarying from './NodeVarying.js';
+import NodeCode from './NodeCode.js';
+import Node from './Node.js';
+import BufferAttributeNode from '../accessors/BufferAttributeNode.js';
+import { BufferAttribute, TypedArray } from '../../core/BufferAttribute.js';
+import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
+import StructType from './StructType.js';
+
 let _id = 0;
 
+export interface ShaderStageNodeData {
+    properties?:
+        | ({
+              outputNode: Node | null;
+              initialized?: boolean | undefined;
+          } & {
+              [K in `node${string}`]?: Node | undefined;
+          })
+        | undefined;
+    bufferAttribute?: NodeAttribute | undefined;
+    structType?: StructType | undefined;
+    uniform?: NodeUniform<unknown, unknown> | undefined;
+    variable?: NodeVar | undefined;
+    varying?: NodeVarying | undefined;
+    code?: NodeCode | undefined;
+    usageCount?: number | undefined;
+    snippet?: string | undefined;
+    propertyName?: string | undefined;
+    propertySizeName?: string | undefined;
+}
+
+interface NodeData {
+    vertex?: ShaderStageNodeData | undefined;
+    fragment?: ShaderStageNodeData | undefined;
+    compute?: ShaderStageNodeData | undefined;
+    any?: ShaderStageNodeData | undefined;
+}
+
+interface BufferAttributeData {
+    node: BufferAttributeNode<unknown>;
+}
+
 /**
  * This utility class is used in {@link NodeBuilder} as an internal
  * cache data structure for node data.
  */
 class NodeCache {
+    id: number;
+    nodesData: WeakMap<Node | TypedArray | InterleavedBuffer | BufferAttribute, NodeData | BufferAttributeData>;
+
+    parent: NodeCache | null;
+
     /**
      * Constructs a new node cache.
      *
      * @param {?NodeCache} parent - A reference to a parent cache.
      */
-    constructor(parent = null) {
+    constructor(parent: NodeCache | null = null) {
         /**
          * The id of the cache.
          *
@@ -41,11 +89,13 @@ class NodeCache {
      * @param {Node} node - The node.
      * @return {?Object} The data for the node.
      */
-    getData(node) {
+    getData(node: Node): NodeData | undefined;
+    getData(node: TypedArray | InterleavedBuffer | BufferAttribute): BufferAttributeData | undefined;
+    getData(node: Node | TypedArray | InterleavedBuffer | BufferAttribute): NodeData | BufferAttributeData | undefined {
         let data = this.nodesData.get(node);
 
         if (data === undefined && this.parent !== null) {
-            data = this.parent.getData(node);
+            data = this.parent.getData(node as Node);
         }
 
         return data;
@@ -57,7 +107,9 @@ class NodeCache {
      * @param {Node} node - The node.
      * @param {Object} data - The data that should be cached.
      */
-    setData(node, data) {
+    setData(node: Node, data: NodeData): void;
+    setData(node: TypedArray | InterleavedBuffer | BufferAttribute, data: BufferAttributeData): void;
+    setData(node: Node | TypedArray | InterleavedBuffer | BufferAttribute, data: NodeData | BufferAttributeData) {
         this.nodesData.set(node, data);
     }
 }
diff --git a/src-testing/src/nodes/core/NodeCode.ts b/src-testing/src/nodes/core/NodeCode.ts
index 7cf21cda9..08eb89d0e 100644
--- a/src-testing/src/nodes/core/NodeCode.ts
+++ b/src-testing/src/nodes/core/NodeCode.ts
@@ -5,6 +5,10 @@
  * for this purpose.
  */
 class NodeCode {
+    name: string;
+    type: string | null;
+    code: string;
+
     /**
      * Constructs a new code node.
      *
@@ -12,7 +16,7 @@ class NodeCode {
      * @param {string} type - The node type.
      * @param {string} [code=''] - The native shader code.
      */
-    constructor(name, type, code = '') {
+    constructor(name: string, type: string | null, code = '') {
         /**
          * The name of the code.
          *
diff --git a/src-testing/src/nodes/core/NodeFrame.ts b/src-testing/src/nodes/core/NodeFrame.ts
index 43f9bde29..1be6c1e4c 100644
--- a/src-testing/src/nodes/core/NodeFrame.ts
+++ b/src-testing/src/nodes/core/NodeFrame.ts
@@ -1,4 +1,7 @@
 import { NodeUpdateType } from './constants.js';
+import Node from './Node.js';
+import Renderer from '../../renderers/common/Renderer.js';
+import { Camera, Material, Object3D, Scene } from 'three';
 
 /**
  * Management class for updating nodes. The module tracks metrics like
@@ -7,6 +10,23 @@ import { NodeUpdateType } from './constants.js';
  * and {@link Node#updateAfter} depending on the node's configuration.
  */
 class NodeFrame {
+    time: number;
+    deltaTime: number;
+
+    frameId: number;
+    renderId: number;
+
+    // TODO startTime
+
+    // TODO updateMap
+    // TODO updateBeforeMap
+
+    renderer: Renderer | null;
+    material: Material | null;
+    camera: Camera | null;
+    object: Object3D | null;
+    scene: Scene | null;
+
     /**
      * Constructs a new node fame.
      */
@@ -137,7 +157,7 @@ class NodeFrame {
      *
      * @param {Node} node - The node that should be updated.
      */
-    updateBeforeNode(node) {
+    updateBeforeNode(node: Node) {
         const updateType = node.getUpdateBeforeType();
         const reference = node.updateReference(this);
 
@@ -211,7 +231,7 @@ class NodeFrame {
      *
      * @param {Node} node - The node that should be updated.
      */
-    updateNode(node) {
+    updateNode(node: Node) {
         const updateType = node.getUpdateType();
         const reference = node.updateReference(this);
 
diff --git a/src-testing/src/nodes/core/NodeParser.ts b/src-testing/src/nodes/core/NodeParser.ts
index ae664a236..65e57edd1 100644
--- a/src-testing/src/nodes/core/NodeParser.ts
+++ b/src-testing/src/nodes/core/NodeParser.ts
@@ -1,9 +1,10 @@
-import { warn } from '../../utils.js';
+import NodeFunction from './NodeFunction.js';
+
 /**
  * Base class for node parsers. A derived parser must be implemented
  * for each supported native shader language.
  */
-class NodeParser {
+abstract class NodeParser {
     /**
      * The method parses the given native code an returns a node function.
      *
@@ -11,9 +12,7 @@ class NodeParser {
      * @param {string} source - The native shader code.
      * @return {NodeFunction} A node function.
      */
-    parseFunction(/*source*/) {
-        warn('Abstract function.');
-    }
+    abstract parseFunction(source: string): NodeFunction;
 }
 
 export default NodeParser;
diff --git a/src-testing/src/nodes/core/NodeUniform.ts b/src-testing/src/nodes/core/NodeUniform.ts
index 09ff8b517..2c2d65ded 100644
--- a/src-testing/src/nodes/core/NodeUniform.ts
+++ b/src-testing/src/nodes/core/NodeUniform.ts
@@ -1,10 +1,19 @@
+import UniformNode from './UniformNode.js';
+
 /**
  * {@link NodeBuilder} is going to create instances of this class during the build process
  * of nodes. They represent the final shader uniforms that are going to be generated
  * by the builder. A dictionary of node uniforms is maintained in {@link NodeBuilder#uniforms}
  * for this purpose.
  */
-class NodeUniform {
+class NodeUniform<TNodeType, TValue> {
+    readonly isNodeUniform: true;
+
+    name: string;
+    type: string | null;
+    node: UniformNode<TNodeType, TValue>;
+    needsUpdate: boolean | undefined;
+
     /**
      * Constructs a new node uniform.
      *
@@ -12,7 +21,7 @@ class NodeUniform {
      * @param {string} type - The type of the uniform.
      * @param {UniformNode} node - An reference to the node.
      */
-    constructor(name, type, node) {
+    constructor(name: string, type: string | null, node: UniformNode<TNodeType, TValue>) {
         /**
          * This flag can be used for type testing.
          *
@@ -46,8 +55,6 @@ class NodeUniform {
 
     /**
      * The value of the uniform node.
-     *
-     * @type {any}
      */
     get value() {
         return this.node.value;
@@ -59,8 +66,6 @@ class NodeUniform {
 
     /**
      * The id of the uniform node.
-     *
-     * @type {number}
      */
     get id() {
         return this.node.id;
@@ -68,8 +73,6 @@ class NodeUniform {
 
     /**
      * The uniform node's group.
-     *
-     * @type {UniformGroupNode}
      */
     get groupNode() {
         return this.node.groupNode;
diff --git a/src-testing/src/nodes/core/NodeUtils.ts b/src-testing/src/nodes/core/NodeUtils.ts
index 626b5c11a..ab3e2435b 100644
--- a/src-testing/src/nodes/core/NodeUtils.ts
+++ b/src-testing/src/nodes/core/NodeUtils.ts
@@ -6,13 +6,14 @@ import { Vector2 } from '../../math/Vector2.js';
 import { Vector3 } from '../../math/Vector3.js';
 import { Vector4 } from '../../math/Vector4.js';
 import { error } from '../../utils.js';
+import Node from './Node.js';
 
 // cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.
 // A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.
 // Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.
 // See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480
 // https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js
-function cyrb53(value, seed = 0) {
+function cyrb53(value: number[] | string, seed = 0) {
     let h1 = 0xdeadbeef ^ seed,
         h2 = 0x41c6ce57 ^ seed;
 
@@ -46,7 +47,7 @@ function cyrb53(value, seed = 0) {
  * @param {string} str - The string to be hashed.
  * @return {number} The hash.
  */
-export const hashString = str => cyrb53(str);
+export const hashString = (str: string) => cyrb53(str);
 
 /**
  * Computes a hash for the given array.
@@ -56,7 +57,7 @@ export const hashString = str => cyrb53(str);
  * @param {Array<number>} array - The array to be hashed.
  * @return {number} The hash.
  */
-export const hashArray = array => cyrb53(array);
+export const hashArray = (array: number[]) => cyrb53(array);
 
 /**
  * Computes a hash for the given list of parameters.
@@ -66,7 +67,7 @@ export const hashArray = array => cyrb53(array);
  * @param {...number} params - A list of parameters.
  * @return {number} The hash.
  */
-export const hash = (...params) => cyrb53(params);
+export const hash = (...params: number[]) => cyrb53(params);
 
 const typeFromLength = /*@__PURE__*/ new Map([
     [1, 'float'],
@@ -189,7 +190,7 @@ export function getAlignmentFromType(type) {
  * @param {any} value - The value.
  * @return {?string} The data type.
  */
-export function getValueType(value) {
+export function getValueType(value: unknown) {
     if (value === undefined || value === null) return null;
 
     const typeOf = typeof value;
diff --git a/src-testing/src/nodes/core/NodeVar.ts b/src-testing/src/nodes/core/NodeVar.ts
index 1bc2f6d12..076242711 100644
--- a/src-testing/src/nodes/core/NodeVar.ts
+++ b/src-testing/src/nodes/core/NodeVar.ts
@@ -5,6 +5,16 @@
  * this purpose.
  */
 class NodeVar {
+    readonly isNodeVar: true;
+
+    name: string;
+
+    type: string;
+
+    readOnly: boolean;
+
+    count: number | null;
+
     /**
      * Constructs a new node variable.
      *
@@ -13,7 +23,7 @@ class NodeVar {
      * @param {boolean} [readOnly=false] - The read-only flag.
      * @param {?number} [count=null] - The size.
      */
-    constructor(name, type, readOnly = false, count = null) {
+    constructor(name: string, type: string, readOnly = false, count: number | null = null) {
         /**
          * This flag can be used for type testing.
          *
diff --git a/src-testing/src/nodes/core/NodeVarying.ts b/src-testing/src/nodes/core/NodeVarying.ts
index d434bea5f..10b0462ee 100644
--- a/src-testing/src/nodes/core/NodeVarying.ts
+++ b/src-testing/src/nodes/core/NodeVarying.ts
@@ -1,14 +1,20 @@
 import NodeVar from './NodeVar.js';
+import { InterpolationSamplingMode, InterpolationSamplingType } from '../../constants.js';
 
 /**
  * {@link NodeBuilder} is going to create instances of this class during the build process
  * of nodes. They represent the final shader varyings that are going to be generated
  * by the builder. An array of node varyings is maintained in {@link NodeBuilder#varyings} for
  * this purpose.
- *
- * @augments NodeVar
  */
 class NodeVarying extends NodeVar {
+    needsInterpolation: boolean;
+
+    readonly isNodeVarying: true;
+
+    interpolationType: InterpolationSamplingType | null;
+    interpolationSampling: InterpolationSamplingMode | null;
+
     /**
      * Constructs a new node varying.
      *
@@ -17,7 +23,12 @@ class NodeVarying extends NodeVar {
      * @param {?string} interpolationType - The interpolation type of the varying.
      * @param {?string} interpolationSampling - The interpolation sampling type of the varying.
      */
-    constructor(name, type, interpolationType = null, interpolationSampling = null) {
+    constructor(
+        name: string,
+        type: string,
+        interpolationType: InterpolationSamplingType | null = null,
+        interpolationSampling: InterpolationSamplingMode | null = null,
+    ) {
         super(name, type);
 
         /**
diff --git a/src-testing/src/nodes/core/StackNode.ts b/src-testing/src/nodes/core/StackNode.ts
index 6d0ca271b..6137aa6f8 100644
--- a/src-testing/src/nodes/core/StackNode.ts
+++ b/src-testing/src/nodes/core/StackNode.ts
@@ -2,6 +2,7 @@ import Node from './Node.js';
 import { select } from '../math/ConditionalNode.js';
 import { ShaderNode, nodeProxy, getCurrentStack, setCurrentStack, nodeObject } from '../tsl/TSLBase.js';
 import { error } from '../../utils.js';
+import NodeBuilder from './NodeBuilder.js';
 
 /**
  * Stack is a helper for Nodes that need to produce stack-based code instead of continuous flow.
@@ -14,6 +15,16 @@ class StackNode extends Node {
         return 'StackNode';
     }
 
+    nodes: Node[];
+    outputNode: Node | null;
+
+    parent: StackNode | null;
+
+    _currentCond: Node | null;
+    _expressionNode: Node | null;
+
+    readonly isStackNode: true;
+
     /**
      * Constructs a new stack node.
      *
@@ -87,7 +98,7 @@ class StackNode extends Node {
         return this.hasOutput(builder) ? this.outputNode.getElementType(builder) : 'void';
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.hasOutput(builder) ? this.outputNode.getNodeType(builder) : 'void';
     }
 
@@ -102,7 +113,7 @@ class StackNode extends Node {
      * @param {number} [index=this.nodes.length] - The index where the node should be added.
      * @return {StackNode} A reference to this stack node.
      */
-    addToStack(node, index = this.nodes.length) {
+    addToStack(node: Node, index = this.nodes.length) {
         if (node.isNode !== true) {
             error('TSL: Invalid node added to stack.');
             return this;
@@ -119,7 +130,7 @@ class StackNode extends Node {
      * @param {Node} node - The node to add.
      * @return {StackNode} A reference to this stack node.
      */
-    addToStackBefore(node) {
+    addToStackBefore(node: Node) {
         const index = this._currentNode ? this.nodes.indexOf(this._currentNode) : 0;
 
         return this.addToStack(node, index);
@@ -132,7 +143,7 @@ class StackNode extends Node {
      * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
      * @return {StackNode} A reference to this stack node.
      */
-    If(boolNode, method) {
+    If(boolNode: Node, method: () => void) {
         const methodNode = new ShaderNode(method);
         this._currentCond = select(boolNode, methodNode);
 
@@ -146,7 +157,7 @@ class StackNode extends Node {
      * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
      * @return {StackNode} A reference to this stack node.
      */
-    ElseIf(boolNode, method) {
+    ElseIf(boolNode: Node, method: () => void) {
         const methodNode = new ShaderNode(method);
         const ifNode = select(boolNode, methodNode);
 
@@ -162,7 +173,7 @@ class StackNode extends Node {
      * @param {Function} method - TSL code which is executed in the `else` case.
      * @return {StackNode} A reference to this stack node.
      */
-    Else(method) {
+    Else(method: () => void) {
         this._currentCond.elseNode = new ShaderNode(method);
 
         return this;
@@ -266,7 +277,7 @@ class StackNode extends Node {
         return this.outputNode && this.outputNode.isNode && this.outputNode.getNodeType(builder) !== 'void';
     }
 
-    build(builder, ...params) {
+    build(builder: NodeBuilder, ...params) {
         const previousStack = getCurrentStack();
 
         const buildStage = builder.buildStage;
diff --git a/src-testing/src/nodes/core/StructType.ts b/src-testing/src/nodes/core/StructType.ts
index b06830b48..27e703306 100644
--- a/src-testing/src/nodes/core/StructType.ts
+++ b/src-testing/src/nodes/core/StructType.ts
@@ -1,5 +1,11 @@
+import { MemberLayout } from './StructTypeNode.js';
+
 class StructType {
-    constructor(name, members) {
+    name: string;
+    members: MemberLayout[];
+    output: boolean;
+
+    constructor(name: string, members: MemberLayout[]) {
         this.name = name;
         this.members = members;
         this.output = false;
diff --git a/src-testing/src/nodes/core/StructTypeNode.ts b/src-testing/src/nodes/core/StructTypeNode.ts
index 370ecb82f..74c14d7f8 100644
--- a/src-testing/src/nodes/core/StructTypeNode.ts
+++ b/src-testing/src/nodes/core/StructTypeNode.ts
@@ -1,5 +1,16 @@
 import Node from './Node.js';
 import { getAlignmentFromType, getMemoryLengthFromType } from './NodeUtils.js';
+import NodeBuilder from './NodeBuilder.js';
+
+export interface MembersLayout {
+    [name: string]: string | { type: string; atomic?: boolean };
+}
+
+export interface MemberLayout {
+    name: string;
+    type: string;
+    atomic: boolean;
+}
 
 /**
  * Generates a layout for struct members.
@@ -9,7 +20,7 @@ import { getAlignmentFromType, getMemoryLengthFromType } from './NodeUtils.js';
  * @param {Object.<string, string|Object>} members - An object where keys are member names and values are either types (as strings) or objects with type and atomic properties.
  * @returns {Array.<{name: string, type: string, atomic: boolean}>} An array of member layouts.
  */
-function getMembersLayout(members) {
+function getMembersLayout(members: MembersLayout) {
     return Object.entries(members).map(([name, value]) => {
         if (typeof value === 'string') {
             return { name, type: value, atomic: false };
@@ -24,21 +35,24 @@ function getMembersLayout(members) {
  * This class is used to define and manage the layout and types of struct members.
  * It extends the base Node class and provides methods to get the length of the struct,
  * retrieve member types, and generate the struct type for a builder.
- *
- * @augments Node
  */
 class StructTypeNode extends Node {
     static get type() {
         return 'StructTypeNode';
     }
 
+    membersLayout: MemberLayout[];
+    name: string | null;
+
+    readonly isStructLayoutNode: true;
+
     /**
      * Creates an instance of StructTypeNode.
      *
      * @param {Object} membersLayout - The layout of the members for the struct.
      * @param {?string} [name=null] - The optional name of the struct.
      */
-    constructor(membersLayout, name = null) {
+    constructor(membersLayout: MembersLayout, name: string | null = null) {
         super('struct');
 
         /**
@@ -80,8 +94,8 @@ class StructTypeNode extends Node {
         for (const member of this.membersLayout) {
             const type = member.type;
 
-            const itemSize = getMemoryLengthFromType(type);
-            const alignment = getAlignmentFromType(type) / BYTES_PER_ELEMENT;
+            const itemSize = getMemoryLengthFromType(type)!;
+            const alignment = getAlignmentFromType(type)! / BYTES_PER_ELEMENT;
             maxAlignment = Math.max(maxAlignment, alignment);
 
             const chunkOffset = offset % maxAlignment; // offset in the current chunk of maxAlignment elements
@@ -96,24 +110,24 @@ class StructTypeNode extends Node {
         return Math.ceil(offset / maxAlignment) * maxAlignment; // ensure length is a multiple of maxAlignment
     }
 
-    getMemberType(builder, name) {
+    getMemberType(builder: NodeBuilder, name: string) {
         const member = this.membersLayout.find(m => m.name === name);
 
         return member ? member.type : 'void';
     }
 
-    getNodeType(builder) {
-        const structType = builder.getStructTypeFromNode(this, this.membersLayout, this.name);
+    getNodeType(builder: NodeBuilder) {
+        const structType = builder.getStructTypeFromNode(this, this.membersLayout, this.name)!;
 
         return structType.name;
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         builder.getStructTypeFromNode(this, this.membersLayout, this.name);
         builder.addInclude(this);
     }
 
-    generate(builder) {
+    generate(builder: NodeBuilder) {
         return this.getNodeType(builder);
     }
 }
diff --git a/src-testing/src/nodes/core/UniformGroupNode.ts b/src-testing/src/nodes/core/UniformGroupNode.ts
index 94299fca9..125e9ad42 100644
--- a/src-testing/src/nodes/core/UniformGroupNode.ts
+++ b/src-testing/src/nodes/core/UniformGroupNode.ts
@@ -1,4 +1,4 @@
-import Node from './Node.js';
+import Node, { NodeJSONInputData, NodeJSONIntermediateOutputData } from './Node.js';
 
 /**
  * This node can be used to group single instances of {@link UniformNode}
@@ -18,6 +18,10 @@ class UniformGroupNode extends Node {
         return 'UniformGroupNode';
     }
 
+    shared: boolean;
+    order: number;
+    readonly isUniformGroup: true;
+
     /**
      * Constructs a new uniform group node.
      *
@@ -62,7 +66,7 @@ class UniformGroupNode extends Node {
         this.isUniformGroup = true;
     }
 
-    serialize(data) {
+    serialize(data: NodeJSONIntermediateOutputData) {
         super.serialize(data);
 
         data.name = this.name;
@@ -70,7 +74,7 @@ class UniformGroupNode extends Node {
         data.shared = this.shared;
     }
 
-    deserialize(data) {
+    deserialize(data: NodeJSONInputData) {
         super.deserialize(data);
 
         this.name = data.name;
diff --git a/src-testing/src/nodes/core/UniformNode.ts b/src-testing/src/nodes/core/UniformNode.ts
index f9fc07e20..9fe38be3b 100644
--- a/src-testing/src/nodes/core/UniformNode.ts
+++ b/src-testing/src/nodes/core/UniformNode.ts
@@ -1,26 +1,41 @@
 import InputNode from './InputNode.js';
-import { objectGroup } from './UniformGroupNode.js';
+import UniformGroupNode, { objectGroup } from './UniformGroupNode.js';
 import { getConstNodeType } from '../tsl/TSLCore.js';
 import { getValueFromType } from './NodeUtils.js';
 import { warn } from '../../utils.js';
+import Node from './Node.js';
+import NodeBuilder from './NodeBuilder.js';
+import NodeFrame from './NodeFrame.js';
+import { NodeUpdateType } from './constants.js';
+import ConstNode from './ConstNode.js';
+import { Vector2 } from '../../math/Vector2.js';
+import { Vector3 } from '../../math/Vector3.js';
+import { Vector4 } from '../../math/Vector4.js';
+import { Matrix2 } from '../../math/Matrix2.js';
+import { Matrix3 } from '../../math/Matrix3.js';
+import { Matrix4 } from '../../math/Matrix4.js';
+import { Color } from '../../math/Color.js';
 
 /**
  * Class for representing a uniform.
- *
- * @augments InputNode
  */
-class UniformNode extends InputNode {
+class UniformNodeClass<TValue> extends InputNode<unknown, TValue> {
     static get type() {
         return 'UniformNode';
     }
 
+    readonly isUniformNode: true;
+
+    name: string;
+    groupNode: UniformGroupNode;
+
     /**
      * Constructs a new uniform node.
      *
      * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
      * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
      */
-    constructor(value, nodeType = null) {
+    constructor(value: TValue, nodeType: string | null = null) {
         super(value, nodeType);
 
         /**
@@ -56,11 +71,11 @@ class UniformNode extends InputNode {
      * @param {string} name - The name of the uniform.
      * @return {UniformNode} A reference to this node.
      */
-    setName(name) {
+    setName = (name: string) => {
         this.name = name;
 
         return this;
-    }
+    };
 
     /**
      * Sets the {@link UniformNode#name} property.
@@ -69,11 +84,11 @@ class UniformNode extends InputNode {
      * @param {string} name - The name of the uniform.
      * @return {UniformNode} A reference to this node.
      */
-    label(name) {
+    label = (name: string) => {
         warn('TSL: "label()" has been deprecated. Use "setName()" instead.'); // @deprecated r179
 
         return this.setName(name);
-    }
+    };
 
     /**
      * Sets the {@link UniformNode#groupNode} property.
@@ -81,7 +96,7 @@ class UniformNode extends InputNode {
      * @param {UniformGroupNode} group - The uniform group.
      * @return {UniformNode} A reference to this node.
      */
-    setGroup(group) {
+    setGroup(group: UniformGroupNode) {
         this.groupNode = group;
 
         return this;
@@ -103,11 +118,11 @@ class UniformNode extends InputNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The uniform hash.
      */
-    getUniformHash(builder) {
+    getUniformHash(builder: NodeBuilder) {
         return this.getHash(builder);
     }
 
-    onUpdate(callback, updateType) {
+    onUpdate(callback: (frame: NodeFrame, self: this) => TValue | undefined, updateType: NodeUpdateType) {
         callback = callback.bind(this);
 
         return super.onUpdate(frame => {
@@ -119,7 +134,7 @@ class UniformNode extends InputNode {
         }, updateType);
     }
 
-    getInputType(builder) {
+    getInputType(builder: NodeBuilder) {
         let type = super.getInputType(builder);
 
         if (type === 'bool') {
@@ -129,12 +144,12 @@ class UniformNode extends InputNode {
         return type;
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output: string | null) {
         const type = this.getNodeType(builder);
 
         const hash = this.getUniformHash(builder);
 
-        let sharedNode = builder.getNodeFromHash(hash);
+        let sharedNode = builder.getNodeFromHash(hash) as this;
 
         if (sharedNode === undefined) {
             builder.setHashNode(this, hash);
@@ -147,7 +162,7 @@ class UniformNode extends InputNode {
         const nodeUniform = builder.getUniformFromNode(
             sharedNode,
             sharedNodeType,
-            builder.shaderStage,
+            builder.shaderStage!,
             this.name || builder.context.nodeName,
         );
         const uniformName = builder.getPropertyName(nodeUniform);
@@ -183,18 +198,44 @@ class UniformNode extends InputNode {
     }
 }
 
+declare const UniformNode: {
+    /**
+     * Constructs a new uniform node.
+     *
+     * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
+     * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
+     */
+    new <TNodeType, TValue>(value: TValue, nodeType?: string | null): UniformNode<TNodeType, TValue>;
+};
+type UniformNode<TNodeType, TValue> = UniformNodeClass<TValue> & InputNode<TNodeType, TValue>;
+
 export default UniformNode;
 
+interface Uniform {
+    (value: number, type?: 'float'): UniformNode<'float', number>;
+    (value: boolean): UniformNode<'bool', boolean>;
+    (value: Vector2): UniformNode<'vec2', Vector2>;
+    (value: Vector3): UniformNode<'vec3', Vector3>;
+    (value: Vector4): UniformNode<'vec4', Vector4>;
+    (value: Matrix2): UniformNode<'mat2', Matrix2>;
+    (value: Matrix3): UniformNode<'mat3', Matrix3>;
+    (value: Matrix4): UniformNode<'mat4', Matrix4>;
+    (value: Color): UniformNode<'color', Color>;
+    <TNodeType, TValue>(value: InputNode<TNodeType, TValue>): UniformNode<TNodeType, TValue>;
+}
+
 /**
  * TSL function for creating a uniform node.
  *
- * @tsl
  * @function
  * @param {any|string} value - The value of this uniform or your type. Usually a JS primitive or three.js object (vector, matrix, color, texture).
  * @param {string} [type] - The node type. If no explicit type is defined, the node tries to derive the type from its value.
  * @returns {UniformNode}
  */
-export const uniform = (value, type) => {
+export const uniform: Uniform = <TNodeType, TValue>(
+    value: InputNode<TNodeType, TValue> | TValue,
+    type?: TNodeType | string,
+): UniformNode<TNodeType, TValue> => {
     const nodeType = getConstNodeType(type || value);
 
     if (nodeType === value) {
@@ -203,17 +244,17 @@ export const uniform = (value, type) => {
         value = getValueFromType(nodeType);
     }
 
-    if (value && value.isNode === true) {
-        let v = value.value;
+    if (value && (value as Node).isNode === true) {
+        let v = (value as Node).value;
 
-        value.traverse(n => {
-            if (n.isConstNode === true) {
-                v = n.value;
+        (value as Node).traverse(n => {
+            if ((n as ConstNode<unknown>).isConstNode === true) {
+                v = (n as ConstNode<unknown>).value;
             }
         });
 
         value = v;
     }
 
-    return new UniformNode(value, nodeType);
+    return new UniformNode(value as TValue, nodeType);
 };
diff --git a/src-testing/src/nodes/core/constants.ts b/src-testing/src/nodes/core/constants.ts
index 1fe2dbbd0..a431897fa 100644
--- a/src-testing/src/nodes/core/constants.ts
+++ b/src-testing/src/nodes/core/constants.ts
@@ -7,7 +7,7 @@
 export const NodeShaderStage = {
     VERTEX: 'vertex',
     FRAGMENT: 'fragment',
-};
+} as const;
 
 /**
  * Update types of a node.
@@ -22,7 +22,7 @@ export const NodeUpdateType = {
     FRAME: 'frame',
     RENDER: 'render',
     OBJECT: 'object',
-};
+} as const;
 
 /**
  * Data types of a node.
@@ -47,7 +47,7 @@ export const NodeType = {
     MATRIX2: 'mat2',
     MATRIX3: 'mat3',
     MATRIX4: 'mat4',
-};
+} as const;
 
 /**
  * Access types of a node. These are relevant for compute and storage usage.
@@ -60,9 +60,13 @@ export const NodeAccess = {
     READ_ONLY: 'readOnly',
     WRITE_ONLY: 'writeOnly',
     READ_WRITE: 'readWrite',
-};
+} as const;
 
-export const defaultShaderStages = ['fragment', 'vertex'];
+export type NodeShaderStage = 'vertex' | 'fragment' | 'compute';
+export type NodeUpdateType = 'none' | 'frame' | 'render' | 'object';
+export type NodeAccess = 'readOnly' | 'writeOnly' | 'readWrite';
+
+export const defaultShaderStages: NodeShaderStage[] = ['fragment', 'vertex'];
 export const defaultBuildStages = ['setup', 'analyze', 'generate'];
-export const shaderStages = [...defaultShaderStages, 'compute'];
+export const shaderStages: NodeShaderStage[] = [...defaultShaderStages, 'compute'];
 export const vectorComponents = ['x', 'y', 'z', 'w'];
diff --git a/src-testing/src/nodes/lighting/LightingContextNode.ts b/src-testing/src/nodes/lighting/LightingContextNode.ts
index ee5cf92a6..7240bb88d 100644
--- a/src-testing/src/nodes/lighting/LightingContextNode.ts
+++ b/src-testing/src/nodes/lighting/LightingContextNode.ts
@@ -1,5 +1,23 @@
 import ContextNode from '../core/ContextNode.js';
 import { nodeProxy, float, vec3 } from '../tsl/TSLBase.js';
+import Node from '../core/Node.js';
+import NodeBuilder from '../core/NodeBuilder.js';
+import LightingModel from '../core/LightingModel.js';
+
+interface LightingContext {
+    radiance: Node;
+    irradiance: Node;
+    iblIrradiance: Node;
+    ambientOcclusion: Node;
+    reflectedLight: {
+        directDiffuse: Node;
+        directSpecular: Node;
+        indirectDiffuse: Node;
+        indirectSpecular: Node;
+    };
+    backdrop: Node | null;
+    backdropAlpha: Node | null;
+}
 
 /**
  * `LightingContextNode` represents an extension of the {@link ContextNode} module
@@ -8,11 +26,17 @@ import { nodeProxy, float, vec3 } from '../tsl/TSLBase.js';
  *
  * @augments ContextNode
  */
-class LightingContextNode extends ContextNode {
+class LightingContextNode extends ContextNode<LightingContext> {
     static get type() {
         return 'LightingContextNode';
     }
 
+    lightingModel: LightingModel | null;
+    backdropNode: Node | null;
+    backdropAlphaNode: Node | null;
+
+    _value: LightingContext | null;
+
     /**
      * Constructs a new lighting context node.
      *
@@ -21,8 +45,13 @@ class LightingContextNode extends ContextNode {
      * @param {?Node<vec3>} [backdropNode=null] - A backdrop node.
      * @param {?Node<float>} [backdropAlphaNode=null] - A backdrop alpha node.
      */
-    constructor(lightsNode, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
-        super(lightsNode);
+    constructor(
+        lightsNode: Node,
+        lightingModel: LightingModel | null = null,
+        backdropNode: Node | null = null,
+        backdropAlphaNode: Node | null = null,
+    ) {
+        super(node);
 
         /**
          * The current lighting model.
@@ -79,7 +108,7 @@ class LightingContextNode extends ContextNode {
             indirectSpecular,
         };
 
-        const context = {
+        const context: LightingContext = {
             radiance: vec3().toVar('radiance'),
             irradiance: vec3().toVar('irradiance'),
             iblIrradiance: vec3().toVar('iblIrradiance'),
@@ -92,7 +121,7 @@ class LightingContextNode extends ContextNode {
         return context;
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         this.value = this._value || (this._value = this.getContext());
         this.value.lightingModel = this.lightingModel || builder.context.lightingModel;
 
diff --git a/src-testing/src/nodes/tsl/TSLCore.ts b/src-testing/src/nodes/tsl/TSLCore.ts
index ff0c9e668..3ba9da9f5 100644
--- a/src-testing/src/nodes/tsl/TSLCore.ts
+++ b/src-testing/src/nodes/tsl/TSLCore.ts
@@ -9,9 +9,38 @@ import ConstNode from '../core/ConstNode.js';
 import MemberNode from '../utils/MemberNode.js';
 import { getValueFromType, getValueType } from '../core/NodeUtils.js';
 import { warn, error } from '../../utils.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 let currentStack = null;
 
+export interface NodeElements {
+    append: typeof append;
+
+    toColor: typeof color;
+    toFloat: typeof float;
+    toInt: typeof int;
+    toUint: typeof uint;
+    toBool: typeof bool;
+    toVec2: typeof vec2;
+    toIvec2: typeof ivec2;
+    toUvec2: typeof uvec2;
+    toBvec2: typeof bvec2;
+    toVec3: typeof vec3;
+    toIvec3: typeof ivec3;
+    toUvec3: typeof uvec3;
+    toBvec3: typeof bvec3;
+    toVec4: typeof vec4;
+    toIvec4: typeof ivec4;
+    toUvec4: typeof uvec4;
+    toBvec4: typeof bvec4;
+    toMat2: typeof mat2;
+    toMat3: typeof mat3;
+    toMat4: typeof mat4;
+
+    element: typeof element;
+    convert: typeof convert;
+}
+
 const NodeElements = new Map();
 
 // Extend Node Class for TSL using prototype
@@ -45,6 +74,144 @@ export function addMethodChaining(name, nodeElement) {
     }
 }
 
+type XYZWCharacter = 'x' | 'y' | 'z' | 'w';
+type RGBACharacter = 'r' | 'g' | 'b' | 'a';
+type STPQCharacter = 's' | 't' | 'p' | 'q';
+
+type XYZWSwizzle =
+    | `${XYZWCharacter}`
+    | `${XYZWCharacter}${XYZWCharacter}`
+    | `${XYZWCharacter}${XYZWCharacter}${XYZWCharacter}`
+    | `${XYZWCharacter}${XYZWCharacter}${XYZWCharacter}${XYZWCharacter}`;
+
+type RGBASwizzle =
+    | `${RGBACharacter}`
+    | `${RGBACharacter}${RGBACharacter}`
+    | `${RGBACharacter}${RGBACharacter}${RGBACharacter}`
+    | `${RGBACharacter}${RGBACharacter}${RGBACharacter}${RGBACharacter}`;
+
+type STPQSwizzle =
+    | `${STPQCharacter}`
+    | `${STPQCharacter}${STPQCharacter}`
+    | `${STPQCharacter}${STPQCharacter}${STPQCharacter}`
+    | `${STPQCharacter}${STPQCharacter}${STPQCharacter}${STPQCharacter}`;
+
+export type SwizzleOption = XYZWSwizzle | RGBASwizzle | STPQSwizzle;
+
+export type Swizzable = {
+    [Key in SwizzleOption | number]: Node;
+} & {
+    [Key in SwizzleOption as `set${Uppercase<Key>}`]: (value: Node) => Node;
+} & {
+    [Key in SwizzleOption as `flip${Uppercase<Key>}`]: () => Node;
+};
+
+declare module '../Nodes.js' {
+    interface Node extends Swizzable {
+        assign: (sourceNode: Node | number) => Node;
+    }
+}
+
+/** anything that can be passed to {@link nodeObject} */
+export type NodeObjectOption = Node | number | string;
+
+// same logic as in ShaderNodeObject: number,boolean,node->node, otherwise do nothing
+export type NodeObject<T> = T extends Node ? T : T extends number | boolean ? ConstNode<number | boolean> : T;
+
+// opposite of NodeObject: node -> node|boolean|number, otherwise do nothing
+type Proxied<T> = T extends Node | number ? Node | number : T;
+// https://github.com/microsoft/TypeScript/issues/42435#issuecomment-765557874
+export type ProxiedTuple<T extends readonly [...unknown[]]> = [...{ [index in keyof T]: Proxied<T[index]> }];
+export type ProxiedObject<T> = { [index in keyof T]: Proxied<T[index]> };
+type RemoveTail<T extends readonly [...unknown[]]> = T extends [unknown, ...infer X] ? X : [];
+type RemoveHeadAndTail<T extends readonly [...unknown[]]> = T extends [unknown, ...infer X, unknown] ? X : [];
+
+/**
+ * Temporary type to save signatures of 4 constructors. Each element may be tuple or undefined.
+ *
+ * We use an object instead of tuple or union as it makes stuff easier, especially in Typescript 4.0.
+ */
+interface Construtors<
+    A extends undefined | [...unknown[]],
+    B extends undefined | [...unknown[]],
+    C extends undefined | [...unknown[]],
+    D extends undefined | [...unknown[]],
+> {
+    a: A;
+    b: B;
+    c: C;
+    d: D;
+}
+
+/**
+ * Returns all constructors
+ *
+ * <https://github.com/microsoft/TypeScript/issues/37079>
+ * <https://stackoverflow.com/a/52761156/1623826>
+ */
+type OverloadedConstructorsOf<T> = T extends {
+    new (...args: infer A1): unknown;
+    new (...args: infer A2): unknown;
+    new (...args: infer A3): unknown;
+    new (...args: infer A4): unknown;
+}
+    ? Construtors<A1, A2, A3, A4>
+    : T extends {
+            new (...args: infer A1): unknown;
+            new (...args: infer A2): unknown;
+            new (...args: infer A3): unknown;
+        }
+      ? Construtors<A1, A2, A3, undefined>
+      : T extends {
+              new (...args: infer A1): unknown;
+              new (...args: infer A2): unknown;
+          }
+        ? Construtors<A1, A2, undefined, undefined>
+        : T extends new (...args: infer A) => unknown
+          ? Construtors<A, undefined, undefined, undefined>
+          : Construtors<undefined, undefined, undefined, undefined>;
+
+type AnyConstructors = Construtors<any, any, any, any>;
+
+/**
+ * Returns all constructors where the first parameter is assignable to given "scope"
+ */
+// eslint-disable-next-line @typescript-eslint/consistent-type-definitions
+type FilterConstructorsByScope<T extends AnyConstructors, S> = {
+    a: S extends T['a'][0] ? T['a'] : undefined;
+    b: S extends T['b'][0] ? T['b'] : undefined;
+    c: S extends T['c'][0] ? T['c'] : undefined;
+    d: S extends T['d'][0] ? T['d'] : undefined;
+};
+/**
+ * "flattens" the tuple into an union type
+ */
+type ConstructorUnion<T extends AnyConstructors> =
+    | Exclude<T['a'], undefined>
+    | Exclude<T['b'], undefined>
+    | Exclude<T['c'], undefined>
+    | Exclude<T['d'], undefined>;
+
+/**
+ * Extract list of possible scopes - union of the first parameter
+ * of all constructors, should it be string
+ */
+type ExtractScopes<T extends AnyConstructors> =
+    | (T['a'][0] extends string ? T['a'][0] : never)
+    | (T['b'][0] extends string ? T['b'][0] : never)
+    | (T['c'][0] extends string ? T['c'][0] : never)
+    | (T['d'][0] extends string ? T['d'][0] : never);
+
+type GetConstructorsByScope<T, S> = ConstructorUnion<FilterConstructorsByScope<OverloadedConstructorsOf<T>, S>>;
+type GetConstructors<T> = ConstructorUnion<OverloadedConstructorsOf<T>>;
+type GetPossibleScopes<T> = ExtractScopes<OverloadedConstructorsOf<T>>;
+
+export type ConvertType = (...params: unknown[]) => Node;
+
+type NodeArray<T extends NodeObjectOption[]> = { [index in keyof T]: NodeObject<T[index]> };
+type NodeObjects<T> = { [key in keyof T]: T[key] extends NodeObjectOption ? NodeObject<T[key]> : T[key] };
+type ConstructedNode<T> = T extends new (...args: any[]) => infer R ? (R extends Node ? R : never) : never;
+
 const parseSwizzle = props => props.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');
 const parseSwizzleAndSort = props => parseSwizzle(props).split('').sort().join('');
 
@@ -245,7 +412,7 @@ Object.defineProperties(Node.prototype, proto);
 
 const nodeBuilderFunctionsCacheMap = new WeakMap();
 
-const ShaderNodeObject = function (obj, altType = null) {
+const ShaderNodeObject = function <T extends NodeObjectOption>(obj: T, altType: string | null = null) {
     const type = getValueType(obj);
 
     if (type === 'node') {
@@ -356,7 +523,9 @@ const ShaderNodeImmutable = function (NodeClass, ...params) {
 };
 
 class ShaderCallNodeInternal extends Node {
-    constructor(shaderNode, rawInputs) {
+    shaderNode: ShaderNodeInternal;
+
+    constructor(shaderNode: ShaderNodeInternal, rawInputs) {
         super();
 
         this.shaderNode = shaderNode;
@@ -365,7 +534,7 @@ class ShaderCallNodeInternal extends Node {
         this.isShaderCallNodeInternal = true;
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.shaderNode.nodeType || this.getOutputNode(builder).getNodeType(builder);
     }
 
@@ -377,7 +546,7 @@ class ShaderCallNodeInternal extends Node {
         return this.getOutputNode(builder).getMemberType(builder, name);
     }
 
-    call(builder) {
+    call(builder: NodeBuilder) {
         const { shaderNode, rawInputs } = this;
 
         const properties = builder.getNodeProperties(shaderNode);
@@ -599,7 +768,15 @@ function getProxyParameters(params) {
     });
 }
 
+interface Layout {
+    name: string;
+    type: string;
+    inputs: { name: string; type: string }[];
+}
+
 class ShaderNodeInternal extends Node {
+    layout: Layout | null;
+
     constructor(jsFunc, nodeType) {
         super(nodeType);
 
@@ -611,7 +788,7 @@ class ShaderNodeInternal extends Node {
         this.once = false;
     }
 
-    setLayout(layout) {
+    setLayout(layout: Layout | null) {
         this.layout = layout;
 
         return this;
@@ -630,6 +807,8 @@ class ShaderNodeInternal extends Node {
     }
 }
 
+export type { ShaderNodeInternal };
+
 const bools = [false, true];
 const uints = [0, 1, 2, 3];
 const ints = [-1, -2];
@@ -728,11 +907,26 @@ export function ShaderNode(jsFunc, nodeType) {
     return new ShaderNodeInternal(jsFunc, nodeType);
 }
 
-export const nodeObject = (val, altType = null) => /* new */ ShaderNodeObject(val, altType);
+export const nodeObject = <T extends NodeObjectOption>(val: T, altType: string | null = null): NodeObject<T> =>
+    /* new */ ShaderNodeObject(val, altType);
 export const nodeObjectIntent = (val, altType = null) => /* new */ nodeObject(val, altType).toVarIntent();
 export const nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);
 export const nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
-export const nodeProxy = (NodeClass, scope = null, factor = null, settings = null) =>
+
+interface NodeProxy {
+    <T>(nodeClass: T): (...params: ProxiedTuple<GetConstructors<T>>) => ConstructedNode<T>;
+    <T, S extends GetPossibleScopes<T>>(
+        nodeClass: T,
+        scope: S,
+    ): (...params: ProxiedTuple<RemoveTail<GetConstructorsByScope<T, S>>>) => ConstructedNode<T>;
+    <T, S extends GetPossibleScopes<T>>(
+        nodeClass: T,
+        scope: S,
+        factor: NodeObjectOption,
+    ): (...params: ProxiedTuple<RemoveHeadAndTail<GetConstructorsByScope<T, S>>>) => ConstructedNode<T>;
+}
+
+export const nodeProxy: NodeProxy = (NodeClass, scope = null, factor = null, settings = null) =>
     new ShaderNodeProxy(NodeClass, scope, factor, settings);
 export const nodeImmutable = (NodeClass, ...params) => new ShaderNodeImmutable(NodeClass, ...params);
 export const nodeProxyIntent = (NodeClass, scope = null, factor = null, settings = {}) =>
diff --git a/src-testing/src/renderers/common/Animation.ts b/src-testing/src/renderers/common/Animation.ts
index 28092a923..043cbaeac 100644
--- a/src-testing/src/renderers/common/Animation.ts
+++ b/src-testing/src/renderers/common/Animation.ts
@@ -1,9 +1,24 @@
+import NodeManager from './nodes/NodeManager.js';
+import Info from './Info.js';
+import Renderer from './Renderer.js';
+
+export interface AnimationContext {
+    requestAnimationFrame(callback: FrameRequestCallback, xrFrame?: XRFrame): number;
+    cancelAnimationFrame(handle: number): void;
+}
+
 /**
  * This module manages the internal animation loop of the renderer.
- *
- * @private
  */
 class Animation {
+    renderer: Renderer;
+    nodes: NodeManager;
+    info: Info;
+
+    _context: AnimationContext | null;
+    _animationLoop: ((time: DOMHighResTimeStamp, xrFrame?: XRFrame) => void) | null;
+    _requestId: number | null;
+
     /**
      * Constructs a new animation loop management component.
      *
@@ -11,14 +26,13 @@ class Animation {
      * @param {Nodes} nodes - Renderer component for managing nodes related logic.
      * @param {Info} info - Renderer component for managing metrics and monitoring data.
      */
-    constructor(renderer, nodes, info) {
+    constructor(renderer: Renderer, nodes: NodeManager, info: Info) {
         /**
          * A reference to the main renderer.
          *
          * @type {Renderer}
          */
         this.renderer = renderer;
-
         /**
          * Renderer component for managing nodes related logic.
          *
@@ -63,8 +77,8 @@ class Animation {
      * Starts the internal animation loop.
      */
     start() {
-        const update = (time, xrFrame) => {
-            this._requestId = this._context.requestAnimationFrame(update);
+        const update = (time?: DOMHighResTimeStamp, xrFrame?: XRFrame) => {
+            this._requestId = this._context!.requestAnimationFrame(update);
 
             if (this.info.autoReset === true) this.info.reset();
 
@@ -74,7 +88,7 @@ class Animation {
 
             this.renderer._inspector.begin();
 
-            if (this._animationLoop !== null) this._animationLoop(time, xrFrame);
+            if (this._animationLoop !== null) this._animationLoop(time!, xrFrame);
 
             this.renderer._inspector.finish();
         };
@@ -86,7 +100,7 @@ class Animation {
      * Stops the internal animation loop.
      */
     stop() {
-        this._context.cancelAnimationFrame(this._requestId);
+        this._context!.cancelAnimationFrame(this._requestId!);
 
         this._requestId = null;
     }
@@ -105,7 +119,7 @@ class Animation {
      *
      * @param {?Function} callback - The animation loop.
      */
-    setAnimationLoop(callback) {
+    setAnimationLoop(callback: ((time: DOMHighResTimeStamp, xrFrame?: XRFrame) => void) | null) {
         this._animationLoop = callback;
     }
 
@@ -123,7 +137,7 @@ class Animation {
      *
      * @param {Window|XRSession} context - The context to set.
      */
-    setContext(context) {
+    setContext(context: AnimationContext) {
         this._context = context;
     }
 
diff --git a/src-testing/src/renderers/common/Attributes.ts b/src-testing/src/renderers/common/Attributes.ts
index 59ca2d5a8..12607c7e0 100644
--- a/src-testing/src/renderers/common/Attributes.ts
+++ b/src-testing/src/renderers/common/Attributes.ts
@@ -2,20 +2,27 @@ import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
 
 import { DynamicDrawUsage } from '../../constants.js';
+import { BufferAttribute } from '../../core/BufferAttribute.js';
+import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
+import Backend from './Backend.js';
+import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
+
+interface Data {
+    version?: number | undefined;
+}
 
 /**
  * This renderer module manages geometry attributes.
- *
- * @private
- * @augments DataMap
  */
-class Attributes extends DataMap {
+class Attributes extends DataMap<{ attribute: { key: BufferAttribute | InterleavedBufferAttribute; value: Data } }> {
+    backend: Backend;
+
     /**
      * Constructs a new attribute management component.
      *
      * @param {Backend} backend - The renderer's backend.
      */
-    constructor(backend) {
+    constructor(backend: Backend) {
         super();
 
         /**
@@ -32,7 +39,7 @@ class Attributes extends DataMap {
      * @param {BufferAttribute} attribute - The attribute.
      * @return {?Object} The deleted attribute data.
      */
-    delete(attribute) {
+    delete(attribute: BufferAttribute | InterleavedBufferAttribute) {
         const attributeData = super.delete(attribute);
 
         if (attributeData !== null) {
@@ -49,7 +56,7 @@ class Attributes extends DataMap {
      * @param {BufferAttribute} attribute - The attribute to update.
      * @param {number} type - The attribute type.
      */
-    update(attribute, type) {
+    update(attribute: BufferAttribute | InterleavedBufferAttribute, type: AttributeType) {
         const data = this.get(attribute);
 
         if (data.version === undefined) {
@@ -82,10 +89,11 @@ class Attributes extends DataMap {
      * @param {BufferAttribute} attribute - The attribute.
      * @return {BufferAttribute|InterleavedBuffer}
      */
-    _getBufferAttribute(attribute) {
-        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
+    _getBufferAttribute(attribute: BufferAttribute | InterleavedBufferAttribute) {
+        if ((attribute as InterleavedBufferAttribute).isInterleavedBufferAttribute)
+            (attribute as BufferAttribute | InterleavedBuffer) = (attribute as InterleavedBufferAttribute).data;
 
-        return attribute;
+        return attribute as BufferAttribute | InterleavedBuffer;
     }
 }
 
diff --git a/src-testing/src/renderers/common/Backend.ts b/src-testing/src/renderers/common/Backend.ts
index 41eb12825..a1e2855d7 100644
--- a/src-testing/src/renderers/common/Backend.ts
+++ b/src-testing/src/renderers/common/Backend.ts
@@ -1,10 +1,38 @@
-let _vector2 = null;
-let _color4 = null;
-
 import Color4 from './Color4.js';
 import { Vector2 } from '../../math/Vector2.js';
 import { createCanvasElement, warnOnce } from '../../utils.js';
-import { REVISION, TimestampQuery } from '../../constants.js';
+import { CoordinateSystem, REVISION, TimestampQuery } from '../../constants.js';
+import RenderObject from './RenderObject.js';
+import RenderContext from './RenderContext.js';
+import RenderBundle from './RenderBundle.js';
+import { Texture } from '../../textures/Texture.js';
+import Renderer from './Renderer.js';
+import { BufferAttribute, TypedArray } from '../../core/BufferAttribute.js';
+import { Object3D } from '../../core/Object3D.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import { Scene } from '../../scenes/Scene.js';
+import NodeBuilder from '../../nodes/core/NodeBuilder.js';
+import TimestampQueryPool from './TimestampQueryPool.js';
+
+let _vector2: Vector2 | null = null;
+let _color4: Color4 | null = null;
+
+export interface BackendParameters {
+    canvas?: HTMLCanvasElement | OffscreenCanvas | undefined;
+    antialias?: boolean;
+}
+
+interface RenderContextData {
+    renderObjects?: RenderObject[];
+}
+
+interface RenderBundleData {
+    renderContexts?: Set<RenderContext>;
+}
+
+interface RenderObjectData {}
+
+interface TextureData {}
 
 /**
  * Most of the rendering related logic is implemented in the
@@ -18,13 +46,25 @@ import { REVISION, TimestampQuery } from '../../constants.js';
  * @abstract
  * @private
  */
-class Backend {
+abstract class Backend {
+    parameters: BackendParameters;
+    data: WeakMap<
+        RenderContext | RenderBundle | RenderObject | Texture,
+        RenderContextData | RenderBundleData | RenderObjectData | TextureData
+    >;
+    renderer: Renderer | null;
+    domElement: HTMLCanvasElement | OffscreenCanvas | null;
+    timestampQueryPool: {
+        render: TimestampQueryPool | null;
+        compute: TimestampQueryPool | null;
+    };
+
     /**
      * Constructs a new backend.
      *
      * @param {Object} parameters - An object holding parameters for the backend.
      */
-    constructor(parameters = {}) {
+    constructor(parameters: BackendParameters = {}) {
         /**
          * The parameters of the backend.
          *
@@ -38,7 +78,10 @@ class Backend {
          *
          * @type {WeakMap<Object, Object>}
          */
-        this.data = new WeakMap();
+        this.data = new WeakMap<
+            RenderContext | RenderBundle | RenderObject | Texture,
+            RenderContextData | RenderBundleData | RenderObjectData | TextureData
+        >();
 
         /**
          * A reference to the renderer.
@@ -84,7 +127,7 @@ class Backend {
      * @param {Renderer} renderer - The renderer.
      * @return {Promise} A Promise that resolves when the backend has been initialized.
      */
-    async init(renderer) {
+    async init(renderer: Renderer) {
         this.renderer = renderer;
     }
 
@@ -95,7 +138,9 @@ class Backend {
      * @type {number}
      * @readonly
      */
-    get coordinateSystem() {}
+    abstract get coordinateSystem(): CoordinateSystem;
+
+    abstract getArrayBufferAsync(attribute: BufferAttribute): Promise<ArrayBuffer>;
 
     // render context
 
@@ -263,7 +308,11 @@ class Backend {
      * @param {Renderer} renderer - The renderer.
      * @return {NodeBuilder} The node builder.
      */
-    createNodeBuilder(/*renderObject, renderer*/) {}
+    abstract createNodeBuilder(
+        renderObject: Object3D | ComputeNode,
+        renderer: Renderer,
+        scene?: Scene | null,
+    ): NodeBuilder;
 
     // textures
 
@@ -333,7 +382,14 @@ class Backend {
      * @param {number} faceIndex - The face index.
      * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
      */
-    async copyTextureToBuffer(/*texture, x, y, width, height, faceIndex*/) {}
+    abstract copyTextureToBuffer(
+        texture: Texture,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+        faceIndex: number,
+    ): Promise<TypedArray>;
 
     /**
      * Copies data of the given source texture to the given destination texture.
@@ -519,7 +575,7 @@ class Backend {
      * @param {Object3D} object - The 3D object to test.
      * @return {boolean} Whether the 3D object is fully occluded or not.
      */
-    isOccluded(/*renderContext, object*/) {}
+    abstract isOccluded(/*renderContext, object*/): boolean;
 
     /**
      * Resolves the time stamp for the given render context and type.
@@ -529,7 +585,7 @@ class Backend {
      * @param {string} [type='render'] - The type of the time stamp.
      * @return {Promise<number>} A Promise that resolves with the time stamp.
      */
-    async resolveTimestampsAsync(type = 'render') {
+    async resolveTimestampsAsync(type: TimestampQuery = 'render') {
         if (!this.trackTimestamp) {
             warnOnce('WebGPURenderer: Timestamp tracking is disabled.');
             return;
@@ -543,7 +599,7 @@ class Backend {
 
         const duration = await queryPool.resolveQueriesAsync();
 
-        this.renderer.info[type].timestamp = duration;
+        this.renderer!.info[type].timestamp = duration;
 
         return duration;
     }
@@ -583,7 +639,7 @@ class Backend {
      * @abstract
      * @return {number} The maximum anisotropy texture filtering value.
      */
-    getMaxAnisotropy() {}
+    abstract getMaxAnisotropy(): number;
 
     /**
      * Returns the drawing buffer size.
@@ -593,7 +649,7 @@ class Backend {
     getDrawingBufferSize() {
         _vector2 = _vector2 || new Vector2();
 
-        return this.renderer.getDrawingBufferSize(_vector2);
+        return this.renderer!.getDrawingBufferSize(_vector2);
     }
 
     /**
@@ -615,7 +671,7 @@ class Backend {
 
         _color4 = _color4 || new Color4();
 
-        renderer.getClearColor(_color4);
+        renderer!.getClearColor(_color4);
 
         _color4.getRGB(_color4);
 
@@ -650,7 +706,7 @@ class Backend {
      * @param {string} name - The compatibility.
      * @return {boolean} Whether the backend has the given compatibility or not.
      */
-    hasCompatibility(/*name*/) {
+    hasCompatibility(name: string) {
         return false;
     }
 
@@ -671,7 +727,11 @@ class Backend {
      * @param {Object} object - The object.
      * @return {Object} The object's dictionary.
      */
-    get(object) {
+    get(object: RenderContext): RenderContextData;
+    get(object: RenderBundle): RenderBundleData;
+    get(object: RenderObject): RenderObjectData;
+    get(object: Texture): TextureData;
+    get(object: RenderContext | RenderBundle | RenderObject | Texture) {
         let map = this.data.get(object);
 
         if (map === undefined) {
@@ -689,7 +749,7 @@ class Backend {
      * @param {Object} object - The object.
      * @return {boolean} Whether a dictionary for the given object as been defined or not.
      */
-    has(object) {
+    has(object: RenderContext) {
         return this.data.has(object);
     }
 
@@ -698,7 +758,7 @@ class Backend {
      *
      * @param {Object} object - The object to delete.
      */
-    delete(object) {
+    delete(object: RenderContext) {
         this.data.delete(object);
     }
 
diff --git a/src-testing/src/renderers/common/Background.ts b/src-testing/src/renderers/common/Background.ts
index 3b277649c..71c630c50 100644
--- a/src-testing/src/renderers/common/Background.ts
+++ b/src-testing/src/renderers/common/Background.ts
@@ -17,23 +17,35 @@ import { Mesh } from '../../objects/Mesh.js';
 import { SphereGeometry } from '../../geometries/SphereGeometry.js';
 import { BackSide } from '../../constants.js';
 import { error } from '../../utils.js';
+import { Scene } from '../../scenes/Scene.js';
+import Renderer from './Renderer.js';
+import NodeManager from './nodes/NodeManager.js';
+import RenderList from './RenderList.js';
+import RenderContext from './RenderContext.js';
 
 const _clearColor = /*@__PURE__*/ new Color4();
 
+interface SceneData {
+    backgroundMesh?: Mesh;
+    // TODO
+    // backgroundMeshNode?: Node;
+    backgroundCacheKey: string;
+}
+
 /**
  * This renderer module manages the background.
- *
- * @private
- * @augments DataMap
  */
-class Background extends DataMap {
+class Background extends DataMap<{ scene: { key: Scene; value: SceneData } }> {
+    renderer: Renderer;
+    nodes: NodeManager;
+
     /**
      * Constructs a new background management component.
      *
      * @param {Renderer} renderer - The renderer.
      * @param {Nodes} nodes - Renderer component for managing nodes related logic.
      */
-    constructor(renderer, nodes) {
+    constructor(renderer: Renderer, nodes: NodeManager) {
         super();
 
         /**
@@ -61,7 +73,7 @@ class Background extends DataMap {
      * @param {RenderList} renderList - The current render list.
      * @param {RenderContext} renderContext - The current render context.
      */
-    update(scene, renderList, renderContext) {
+    update(scene: Scene, renderList: RenderList, renderContext: RenderContext) {
         const renderer = this.renderer;
         const background = this.nodes.getBackgroundNode(scene) || scene.background;
 
diff --git a/src-testing/src/renderers/common/BindGroup.ts b/src-testing/src/renderers/common/BindGroup.ts
index 50e578f0c..b7d76cea7 100644
--- a/src-testing/src/renderers/common/BindGroup.ts
+++ b/src-testing/src/renderers/common/BindGroup.ts
@@ -1,13 +1,21 @@
+import NodeUniformsGroup from './nodes/NodeUniformsGroup.js';
+import Binding from './Binding.js';
+
 let _id = 0;
 
 /**
  * A bind group represents a collection of bindings and thus a collection
  * or resources. Bind groups are assigned to pipelines to provide them
  * with the required resources (like uniform buffers or textures).
- *
- * @private
  */
 class BindGroup {
+    name: string;
+    bindings: NodeUniformsGroup[] | Binding[];
+    index: number;
+    bindingsReference: NodeUniformsGroup[] | BindGroup;
+
+    id: number;
+
     /**
      * Constructs a new bind group.
      *
@@ -16,7 +24,12 @@ class BindGroup {
      * @param {number} index - The group index.
      * @param {Array<Binding>} bindingsReference - An array of reference bindings.
      */
-    constructor(name = '', bindings = [], index = 0, bindingsReference = []) {
+    constructor(
+        name = '',
+        bindings: NodeUniformsGroup[] = [],
+        index = 0,
+        bindingsReference: NodeUniformsGroup[] | BindGroup = [],
+    ) {
         /**
          * The bind group's name.
          *
diff --git a/src-testing/src/renderers/common/Binding.ts b/src-testing/src/renderers/common/Binding.ts
index 6b5da502c..a333412cb 100644
--- a/src-testing/src/renderers/common/Binding.ts
+++ b/src-testing/src/renderers/common/Binding.ts
@@ -5,9 +5,12 @@
  * This module is an abstract base class for all concrete bindings types.
  *
  * @abstract
- * @private
  */
 class Binding {
+    name: string;
+
+    visibility: number;
+
     /**
      * Constructs a new binding.
      *
@@ -35,7 +38,7 @@ class Binding {
      *
      * @param {number} visibility - The shader stage.
      */
-    setVisibility(visibility) {
+    setVisibility(visibility: number) {
         this.visibility |= visibility;
     }
 
@@ -54,7 +57,7 @@ class Binding {
      * @return {Binding} The cloned binding.
      */
     clone() {
-        return Object.assign(new this.constructor(), this);
+        return Object.assign(new (this.constructor as typeof Binding)(), this);
     }
 }
 
diff --git a/src-testing/src/renderers/common/Bindings.ts b/src-testing/src/renderers/common/Bindings.ts
index aa5c5f4c0..26122e1d5 100644
--- a/src-testing/src/renderers/common/Bindings.ts
+++ b/src-testing/src/renderers/common/Bindings.ts
@@ -1,13 +1,27 @@
 import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
+import Backend from './Backend.js';
+import NodeManager from './nodes/NodeManager.js';
+import Textures from './Textures.js';
+import Attributes from './Attributes.js';
+import Pipelines from './Pipelines.js';
+import Info from './Info.js';
+import RenderObject from './RenderObject.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import { SampledTexture } from './SampledTexture.js';
+import StorageBuffer from './StorageBuffer.js';
+import UniformBuffer from './UniformBuffer.js';
+import Sampler from './Sampler.js';
+import BindGroup from './BindGroup.js';
+
+interface BindGroupData {
+    bindGroup?: BindGroup | undefined;
+}
 
 /**
  * This renderer module manages the bindings of the renderer.
- *
- * @private
- * @augments DataMap
  */
-class Bindings extends DataMap {
+class Bindings extends DataMap<{
     /**
      * Constructs a new bindings management component.
      *
@@ -18,7 +32,23 @@ class Bindings extends DataMap {
      * @param {Pipelines} pipelines - Renderer component for managing pipelines.
      * @param {Info} info - Renderer component for managing metrics and monitoring data.
      */
-    constructor(backend, nodes, textures, attributes, pipelines, info) {
+    bindGroup: { key: BindGroup; value: BindGroupData };
+}> {
+    backend: Backend;
+    textures: Textures;
+    pipelines: Pipelines;
+    attributes: Attributes;
+    nodes: NodeManager;
+    info: Info;
+
+    constructor(
+        backend: Backend,
+        nodes: NodeManager,
+        textures: Textures,
+        attributes: Attributes,
+        pipelines: Pipelines,
+        info: Info,
+    ) {
         super();
 
         /**
@@ -72,7 +102,7 @@ class Bindings extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {Array<BindGroup>} The bind groups.
      */
-    getForRender(renderObject) {
+    getForRender(renderObject: RenderObject) {
         const bindings = renderObject.getBindings();
 
         for (const bindGroup of bindings) {
@@ -98,7 +128,7 @@ class Bindings extends DataMap {
      * @param {Node} computeNode - The compute node.
      * @return {Array<BindGroup>} The bind groups.
      */
-    getForCompute(computeNode) {
+    getForCompute(computeNode: ComputeNode) {
         const bindings = this.nodes.getForCompute(computeNode).bindings;
 
         for (const bindGroup of bindings) {
@@ -121,7 +151,7 @@ class Bindings extends DataMap {
      *
      * @param {Node} computeNode - The compute node.
      */
-    updateForCompute(computeNode) {
+    updateForCompute(computeNode: ComputeNode) {
         this._updateBindings(this.getForCompute(computeNode));
     }
 
@@ -130,7 +160,7 @@ class Bindings extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         this._updateBindings(this.getForRender(renderObject));
     }
 
@@ -139,7 +169,7 @@ class Bindings extends DataMap {
      *
      * @param {Node} computeNode - The compute node.
      */
-    deleteForCompute(computeNode) {
+    deleteForCompute(computeNode: ComputeNode) {
         const bindings = this.nodes.getForCompute(computeNode).bindings;
 
         for (const bindGroup of bindings) {
@@ -153,7 +183,7 @@ class Bindings extends DataMap {
      *
      * @param {RenderObject} renderObject - The renderObject.
      */
-    deleteForRender(renderObject) {
+    deleteForRender(renderObject: RenderObject) {
         const bindings = renderObject.getBindings();
 
         for (const bindGroup of bindings) {
@@ -167,7 +197,7 @@ class Bindings extends DataMap {
      *
      * @param {Array<BindGroup>} bindings - The bind groups.
      */
-    _updateBindings(bindings) {
+    _updateBindings(bindings: BindGroup[]) {
         for (const bindGroup of bindings) {
             this._update(bindGroup, bindings);
         }
@@ -178,14 +208,14 @@ class Bindings extends DataMap {
      *
      * @param {BindGroup} bindGroup - The bind group to initialize.
      */
-    _init(bindGroup) {
+    _init(bindGroup: BindGroup) {
         for (const binding of bindGroup.bindings) {
-            if (binding.isSampledTexture) {
-                this.textures.updateTexture(binding.texture);
-            } else if (binding.isSampler) {
-                this.textures.updateSampler(binding.texture);
-            } else if (binding.isStorageBuffer) {
-                const attribute = binding.attribute;
+            if ((binding as SampledTexture).isSampledTexture) {
+                this.textures.updateTexture((binding as SampledTexture).texture);
+            } else if ((binding as Sampler).isSampler) {
+                this.textures.updateSampler((binding as Sampler).texture);
+            } else if ((binding as StorageBuffer).isStorageBuffer) {
+                const attribute = (binding as StorageBuffer).attribute;
                 const attributeType = attribute.isIndirectStorageBufferAttribute
                     ? AttributeType.INDIRECT
                     : AttributeType.STORAGE;
@@ -201,7 +231,7 @@ class Bindings extends DataMap {
      * @param {BindGroup} bindGroup - The bind group to update.
      * @param {Array<BindGroup>} bindings - The bind groups.
      */
-    _update(bindGroup, bindings) {
+    _update(bindGroup: BindGroup, bindings: BindGroup[]) {
         const { backend } = this;
 
         let needsBindingsUpdate = false;
@@ -230,18 +260,18 @@ class Bindings extends DataMap {
                 this.attributes.update(attribute, attributeType);
             }
 
-            if (binding.isUniformBuffer) {
-                const updated = binding.update();
+            if ((binding as UniformBuffer).isUniformBuffer) {
+                const updated = (binding as UniformBuffer).update();
 
                 if (updated) {
-                    backend.updateBinding(binding);
+                    backend.updateBinding(binding as UniformBuffer);
                 }
-            } else if (binding.isSampledTexture) {
-                const updated = binding.update();
+            } else if ((binding as SampledTexture).isSampledTexture) {
+                const updated = (binding as SampledTexture).update();
 
                 // get the texture data after the update, to sync the texture reference from node
 
-                const texture = binding.texture;
+                const texture = (binding as SampledTexture).texture;
                 const texturesTextureData = this.textures.get(texture);
 
                 if (updated) {
@@ -272,7 +302,7 @@ class Bindings extends DataMap {
                 if (texture.isStorageTexture === true && texture.mipmapsAutoUpdate === true) {
                     const textureData = this.get(texture);
 
-                    if (binding.store === true) {
+                    if ((binding as SampledTexture).store === true) {
                         textureData.needsMipmap = true;
                     } else if (this.textures.needsMipmaps(texture) && textureData.needsMipmap === true) {
                         this.backend.generateMipmaps(texture);
diff --git a/src-testing/src/renderers/common/Buffer.ts b/src-testing/src/renderers/common/Buffer.ts
index 9b33a9f01..79602ed6f 100644
--- a/src-testing/src/renderers/common/Buffer.ts
+++ b/src-testing/src/renderers/common/Buffer.ts
@@ -4,18 +4,24 @@ import { getFloatLength } from './BufferUtils.js';
 /**
  * Represents a buffer binding type.
  *
- * @private
  * @abstract
- * @augments Binding
  */
 class Buffer extends Binding {
+    readonly isBuffer: true;
+
+    bytesPerElement: number;
+
+    _buffer: Float32Array | null;
+
+    _updateRanges: { start: number; count: number }[];
+
     /**
      * Constructs a new buffer.
      *
      * @param {string} name - The buffer's name.
      * @param {TypedArray} [buffer=null] - The buffer.
      */
-    constructor(name, buffer = null) {
+    constructor(name?: string, buffer: Float32Array | null = null) {
         super(name);
 
         /**
@@ -53,8 +59,6 @@ class Buffer extends Binding {
 
     /**
      * The array of update ranges.
-     *
-     * @type {Array<{start: number, count: number}>}
      */
     get updateRanges() {
         return this._updateRanges;
@@ -66,7 +70,7 @@ class Buffer extends Binding {
      * @param {number} start - The start index.
      * @param {number} count - The number of elements.
      */
-    addUpdateRange(start, count) {
+    addUpdateRange(start: number, count: number) {
         this.updateRanges.push({ start, count });
     }
 
@@ -79,21 +83,15 @@ class Buffer extends Binding {
 
     /**
      * The buffer's byte length.
-     *
-     * @type {number}
-     * @readonly
      */
     get byteLength() {
-        return getFloatLength(this._buffer.byteLength);
+        return getFloatLength(this._buffer!.byteLength);
     }
 
     /**
      * A reference to the internal buffer.
-     *
-     * @type {Float32Array}
-     * @readonly
      */
-    get buffer() {
+    get buffer(): Float32Array | null {
         return this._buffer;
     }
 
diff --git a/src-testing/src/renderers/common/BufferUtils.ts b/src-testing/src/renderers/common/BufferUtils.ts
index 80f441efa..244f30b2f 100644
--- a/src-testing/src/renderers/common/BufferUtils.ts
+++ b/src-testing/src/renderers/common/BufferUtils.ts
@@ -8,7 +8,7 @@ import { GPU_CHUNK_BYTES } from './Constants.js';
  * @param {number} floatLength - The buffer length.
  * @return {number} The padded length.
  */
-function getFloatLength(floatLength) {
+function getFloatLength(floatLength: number) {
     // ensure chunk size alignment (STD140 layout)
 
     return floatLength + ((GPU_CHUNK_BYTES - (floatLength % GPU_CHUNK_BYTES)) % GPU_CHUNK_BYTES);
@@ -23,7 +23,7 @@ function getFloatLength(floatLength) {
  * @param {number} [vectorLength=4] - The vector length.
  * @return {number} The padded length.
  */
-function getVectorLength(count, vectorLength = 4) {
+function getVectorLength(count: number, vectorLength = 4) {
     const strideLength = getStrideLength(vectorLength);
 
     const floatLength = strideLength * count;
@@ -39,7 +39,7 @@ function getVectorLength(count, vectorLength = 4) {
  * @param {number} vectorLength - The vector length.
  * @return {number} The padded length.
  */
-function getStrideLength(vectorLength) {
+function getStrideLength(vectorLength: number) {
     const strideLength = 4;
 
     return vectorLength + ((strideLength - (vectorLength % strideLength)) % strideLength);
diff --git a/src-testing/src/renderers/common/BundleGroup.ts b/src-testing/src/renderers/common/BundleGroup.ts
index aeceeefe5..a527e4f80 100644
--- a/src-testing/src/renderers/common/BundleGroup.ts
+++ b/src-testing/src/renderers/common/BundleGroup.ts
@@ -9,10 +9,15 @@ import { Group } from '../../objects/Group.js';
  * This module is only fully supported by `WebGPURenderer` with a WebGPU backend.
  * With a WebGL backend, the group can technically be rendered but without
  * any performance improvements.
- *
- * @augments Group
  */
 class BundleGroup extends Group {
+    readonly isBundleGroup: true;
+
+    readonly type: string;
+
+    static: boolean;
+    version: number;
+
     /**
      * Constructs a new bundle group.
      */
@@ -65,11 +70,10 @@ class BundleGroup extends Group {
     /**
      * Set this property to `true` when the bundle group has changed.
      *
-     * @type {boolean}
      * @default false
      * @param {boolean} value
      */
-    set needsUpdate(value) {
+    set needsUpdate(value: boolean) {
         if (value === true) this.version++;
     }
 }
diff --git a/src-testing/src/renderers/common/CanvasTarget.ts b/src-testing/src/renderers/common/CanvasTarget.ts
index 8d9495cdb..a8bebcefd 100644
--- a/src-testing/src/renderers/common/CanvasTarget.ts
+++ b/src-testing/src/renderers/common/CanvasTarget.ts
@@ -2,19 +2,35 @@ import { EventDispatcher } from '../../core/EventDispatcher.js';
 import { Vector4 } from '../../math/Vector4.js';
 import { FramebufferTexture } from '../../textures/FramebufferTexture.js';
 import { DepthTexture } from '../../textures/DepthTexture.js';
+import { Vector2 } from '../../math/Vector2.js';
+
+export interface CanvasTargetEventMap {
+    resize: {};
+    dispose: {};
+}
 
 /**
  * CanvasTarget is a class that represents the final output destination of the renderer.
- *
- * @augments EventDispatcher
  */
-class CanvasTarget extends EventDispatcher {
+class CanvasTarget extends EventDispatcher<CanvasTargetEventMap> {
+    domElement: HTMLCanvasElement;
+
+    _pixelRatio: number;
+    _width: number;
+    _height: number;
+    _viewport: Vector4;
+    _scissor: Vector4;
+    _scissorTest: boolean;
+
+    colorTexture: FramebufferTexture;
+    depthTexture: DepthTexture;
+
     /**
      * Constructs a new CanvasTarget.
      *
      * @param {HTMLCanvasElement|OffscreenCanvas} domElement - The canvas element to render to.
      */
-    constructor(domElement) {
+    constructor(domElement: HTMLCanvasElement) {
         super();
 
         /**
@@ -105,7 +121,7 @@ class CanvasTarget extends EventDispatcher {
      * @param {Vector2} target - The method writes the result in this target object.
      * @return {Vector2} The drawing buffer size.
      */
-    getDrawingBufferSize(target) {
+    getDrawingBufferSize(target: Vector2) {
         return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
     }
 
@@ -115,7 +131,7 @@ class CanvasTarget extends EventDispatcher {
      * @param {Vector2} target - The method writes the result in this target object.
      * @return {Vector2} The renderer's size in logical pixels.
      */
-    getSize(target) {
+    getSize(target: Vector2) {
         return target.set(this._width, this._height);
     }
 
@@ -145,7 +161,7 @@ class CanvasTarget extends EventDispatcher {
      * @param {number} height - The height in logical pixels.
      * @param {number} pixelRatio - The pixel ratio.
      */
-    setDrawingBufferSize(width, height, pixelRatio) {
+    setDrawingBufferSize(width: number, height: number, pixelRatio: number) {
         // Renderer can't be resized while presenting in XR.
         if (this.xr && this.xr.isPresenting) return;
 
@@ -169,7 +185,7 @@ class CanvasTarget extends EventDispatcher {
      * @param {number} height - The height in logical pixels.
      * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
      */
-    setSize(width, height, updateStyle = true) {
+    setSize(width: number, height: number, updateStyle = true) {
         // Renderer can't be resized while presenting in XR.
         if (this.xr && this.xr.isPresenting) return;
 
@@ -195,7 +211,7 @@ class CanvasTarget extends EventDispatcher {
      * @param {Vector4} target - The method writes the result in this target object.
      * @return {Vector4} The scissor rectangle.
      */
-    getScissor(target) {
+    getScissor(target: Vector4) {
         const scissor = this._scissor;
 
         target.x = scissor.x;
@@ -215,13 +231,15 @@ class CanvasTarget extends EventDispatcher {
      * @param {number} width - The width of the scissor box in logical pixel unit.
      * @param {number} height - The height of the scissor box in logical pixel unit.
      */
-    setScissor(x, y, width, height) {
+    setScissor(x: Vector4): void;
+    setScissor(x: number, y: number, width: number, height: number): void;
+    setScissor(x: number | Vector4, y?: number, width?: number, height?: number) {
         const scissor = this._scissor;
 
-        if (x.isVector4) {
-            scissor.copy(x);
+        if ((x as Vector4).isVector4) {
+            scissor.copy(x as Vector4);
         } else {
-            scissor.set(x, y, width, height);
+            scissor.set(x as number, y!, width!, height!);
         }
     }
 
@@ -239,7 +257,7 @@ class CanvasTarget extends EventDispatcher {
      *
      * @param {boolean} boolean - Whether the scissor test should be enabled or not.
      */
-    setScissorTest(boolean) {
+    setScissorTest(boolean: boolean) {
         this._scissorTest = boolean;
     }
 
@@ -249,7 +267,7 @@ class CanvasTarget extends EventDispatcher {
      * @param {Vector4} target - The method writes the result in this target object.
      * @return {Vector4} The viewport definition.
      */
-    getViewport(target) {
+    getViewport(target: Vector4) {
         return target.copy(this._viewport);
     }
 
@@ -263,13 +281,15 @@ class CanvasTarget extends EventDispatcher {
      * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.
      * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.
      */
-    setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {
+    setViewport(x: Vector4): void;
+    setViewport(x: number, y: number, width: number, height: number, minDepth?: number, maxDepth?: number): void;
+    setViewport(x: number | Vector4, y?: number, width?: number, height?: number, minDepth = 0, maxDepth = 1) {
         const viewport = this._viewport;
 
-        if (x.isVector4) {
-            viewport.copy(x);
+        if ((x as Vector4).isVector4) {
+            viewport.copy(x as Vector4);
         } else {
-            viewport.set(x, y, width, height);
+            viewport.set(x as number, y!, width!, height!);
         }
 
         viewport.minDepth = minDepth;
@@ -278,10 +298,8 @@ class CanvasTarget extends EventDispatcher {
 
     /**
      * Dispatches the resize event.
-     *
-     * @private
      */
-    _dispatchResize() {
+    private _dispatchResize() {
         this.dispatchEvent({ type: 'resize' });
     }
 
diff --git a/src-testing/src/renderers/common/ChainMap.ts b/src-testing/src/renderers/common/ChainMap.ts
index c41a56bfd..0e61f1e42 100644
--- a/src-testing/src/renderers/common/ChainMap.ts
+++ b/src-testing/src/renderers/common/ChainMap.ts
@@ -1,12 +1,13 @@
+type RecursiveWeakMap<K extends readonly object[], V> = WeakMap<K[number], V | RecursiveWeakMap<K, V>>;
+
 /**
  * Data structure for the renderer. It allows defining values
  * with chained, hierarchical keys. Keys are meant to be
  * objects since the module internally works with Weak Maps
  * for performance reasons.
- *
- * @private
  */
-class ChainMap {
+class ChainMap<K extends readonly object[], V> {
+    weakMaps: Record<number, RecursiveWeakMap<K, V>>;
     /**
      * Constructs a new Chain Map.
      */
@@ -25,13 +26,13 @@ class ChainMap {
      * @param {Array<Object>} keys - List of keys.
      * @return {WeakMap} The weak map.
      */
-    _getWeakMap(keys) {
+    _getWeakMap(keys: K) {
         const length = keys.length;
 
         let weakMap = this.weakMaps[length];
 
         if (weakMap === undefined) {
-            weakMap = new WeakMap();
+            weakMap = new WeakMap<K[number], V | RecursiveWeakMap<K, V>>();
             this.weakMaps[length] = weakMap;
         }
 
@@ -44,16 +45,16 @@ class ChainMap {
      * @param {Array<Object>} keys - List of keys.
      * @return {any} The value. Returns `undefined` if no value was found.
      */
-    get(keys) {
-        let map = this._getWeakMap(keys);
+    get(keys: K): V | undefined {
+        let map: RecursiveWeakMap<K, V> | undefined = this._getWeakMap(keys);
 
         for (let i = 0; i < keys.length - 1; i++) {
-            map = map.get(keys[i]);
+            map = map.get(keys[i]) as RecursiveWeakMap<K, V> | undefined;
 
             if (map === undefined) return undefined;
         }
 
-        return map.get(keys[keys.length - 1]);
+        return map.get(keys[keys.length - 1]) as V | undefined;
     }
 
     /**
@@ -63,18 +64,18 @@ class ChainMap {
      * @param {any} value - The value to set.
      * @return {ChainMap} A reference to this Chain Map.
      */
-    set(keys, value) {
-        let map = this._getWeakMap(keys);
+    set(keys: K, value: V) {
+        let map: RecursiveWeakMap<K, V> = this._getWeakMap(keys);
 
         for (let i = 0; i < keys.length - 1; i++) {
             const key = keys[i];
 
-            if (map.has(key) === false) map.set(key, new WeakMap());
+            if (map.has(key) === false) map.set(key, new WeakMap<K[number], V | RecursiveWeakMap<K, V>>());
 
-            map = map.get(key);
+            map = map.get(key) as RecursiveWeakMap<K, V>;
         }
 
-        map.set(keys[keys.length - 1], value);
+        map.set(keys[keys.length - 1], value) as V;
 
         return this;
     }
@@ -85,11 +86,11 @@ class ChainMap {
      * @param {Array<Object>} keys - The keys.
      * @return {boolean} Returns `true` if the value has been removed successfully and `false` if the value has not be found.
      */
-    delete(keys) {
-        let map = this._getWeakMap(keys);
+    delete(keys: K) {
+        let map: RecursiveWeakMap<K, V> | undefined = this._getWeakMap(keys);
 
         for (let i = 0; i < keys.length - 1; i++) {
-            map = map.get(keys[i]);
+            map = map.get(keys[i]) as RecursiveWeakMap<K, V> | undefined;
 
             if (map === undefined) return false;
         }
diff --git a/src-testing/src/renderers/common/ClippingContext.ts b/src-testing/src/renderers/common/ClippingContext.ts
index 41243208e..60717b73e 100644
--- a/src-testing/src/renderers/common/ClippingContext.ts
+++ b/src-testing/src/renderers/common/ClippingContext.ts
@@ -1,6 +1,10 @@
 import { Matrix3 } from '../../math/Matrix3.js';
 import { Plane } from '../../math/Plane.js';
 import { Vector4 } from '../../math/Vector4.js';
+import { Matrix4 } from '../../math/Matrix4.js';
+import { Camera } from '../../cameras/Camera.js';
+import { Scene } from '../../scenes/Scene.js';
+import { ClippingGroup } from '../../objects/ClippingGroup.js';
 
 const _plane = /*@__PURE__*/ new Plane();
 
@@ -9,16 +13,31 @@ const _plane = /*@__PURE__*/ new Plane();
  * There is a default clipping context for each render context. When the
  * scene holds instances of `ClippingGroup`, there will be a context for each
  * group.
- *
- * @private
  */
 class ClippingContext {
+    version: number;
+
+    clipIntersection: boolean | null;
+    cacheKey: string;
+
+    intersectionPlanes?: Plane[];
+    unionPlanes?: Plane[];
+
+    viewNormalMatrix: Matrix3;
+    clippingGroupContexts: WeakMap<ClippingGroup, ClippingContext>;
+
+    shadowPass: boolean;
+
+    viewMatrix?: Matrix4;
+
+    parentVersion: number | null;
+
     /**
      * Constructs a new clipping context.
      *
      * @param {?ClippingContext} [parentContext=null] - A reference to the parent clipping context.
      */
-    constructor(parentContext = null) {
+    constructor(parentContext: ClippingContext | null = null) {
         /**
          * The clipping context's version.
          *
@@ -103,11 +122,11 @@ class ClippingContext {
      * @param {Array<Vector4>} destination - The destination.
      * @param {number} offset - The offset.
      */
-    projectPlanes(source, destination, offset) {
+    projectPlanes(source: readonly Plane[], destination: readonly Vector4[], offset: number) {
         const l = source.length;
 
         for (let i = 0; i < l; i++) {
-            _plane.copy(source[i]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
+            _plane.copy(source[i]).applyMatrix4(this.viewMatrix!, this.viewNormalMatrix);
 
             const v = destination[offset + i];
             const normal = _plane.normal;
@@ -125,7 +144,7 @@ class ClippingContext {
      * @param {Scene} scene - The scene.
      * @param {Camera} camera - The camera that is used to render the scene.
      */
-    updateGlobal(scene, camera) {
+    updateGlobal(scene: Scene, camera: Camera) {
         this.shadowPass = scene.overrideMaterial !== null && scene.overrideMaterial.isShadowPassMaterial;
         this.viewMatrix = camera.matrixWorldInverse;
 
@@ -138,12 +157,12 @@ class ClippingContext {
      * @param {ClippingContext} parentContext - The parent context.
      * @param {ClippingGroup} clippingGroup - The clipping group this context belongs to.
      */
-    update(parentContext, clippingGroup) {
+    update(parentContext: ClippingContext, clippingGroup: ClippingGroup) {
         let update = false;
 
         if (parentContext.version !== this.parentVersion) {
-            this.intersectionPlanes = Array.from(parentContext.intersectionPlanes);
-            this.unionPlanes = Array.from(parentContext.unionPlanes);
+            this.intersectionPlanes = Array.from(parentContext.intersectionPlanes!);
+            this.unionPlanes = Array.from(parentContext.unionPlanes!);
             this.parentVersion = parentContext.version;
         }
 
@@ -151,24 +170,24 @@ class ClippingContext {
             this.clipIntersection = clippingGroup.clipIntersection;
 
             if (this.clipIntersection) {
-                this.unionPlanes.length = parentContext.unionPlanes.length;
+                this.unionPlanes!.length = parentContext.unionPlanes!.length;
             } else {
-                this.intersectionPlanes.length = parentContext.intersectionPlanes.length;
+                this.intersectionPlanes!.length = parentContext.intersectionPlanes!.length;
             }
         }
 
         const srcClippingPlanes = clippingGroup.clippingPlanes;
         const l = srcClippingPlanes.length;
 
-        let dstClippingPlanes;
+        let dstClippingPlanes: (Plane | Vector4)[];
         let offset;
 
         if (this.clipIntersection) {
-            dstClippingPlanes = this.intersectionPlanes;
-            offset = parentContext.intersectionPlanes.length;
+            dstClippingPlanes = this.intersectionPlanes!;
+            offset = parentContext.intersectionPlanes!.length;
         } else {
-            dstClippingPlanes = this.unionPlanes;
-            offset = parentContext.unionPlanes.length;
+            dstClippingPlanes = this.unionPlanes!;
+            offset = parentContext.unionPlanes!.length;
         }
 
         if (dstClippingPlanes.length !== offset + l) {
@@ -181,11 +200,11 @@ class ClippingContext {
             update = true;
         }
 
-        this.projectPlanes(srcClippingPlanes, dstClippingPlanes, offset);
+        this.projectPlanes(srcClippingPlanes, dstClippingPlanes as Vector4[], offset);
 
         if (update) {
             this.version++;
-            this.cacheKey = `${this.intersectionPlanes.length}:${this.unionPlanes.length}`;
+            this.cacheKey = `${this.intersectionPlanes!.length}:${this.unionPlanes!.length}`;
         }
     }
 
@@ -195,7 +214,7 @@ class ClippingContext {
      * @param {ClippingGroup} clippingGroup - The clipping group.
      * @return {ClippingContext} The clipping context.
      */
-    getGroupContext(clippingGroup) {
+    getGroupContext(clippingGroup: ClippingGroup) {
         if (this.shadowPass && !clippingGroup.clipShadows) return this;
 
         let context = this.clippingGroupContexts.get(clippingGroup);
@@ -212,12 +231,9 @@ class ClippingContext {
 
     /**
      * The count of union clipping planes.
-     *
-     * @type {number}
-     * @readonly
      */
     get unionClippingCount() {
-        return this.unionPlanes.length;
+        return this.unionPlanes!.length;
     }
 }
 
diff --git a/src-testing/src/renderers/common/Color4.ts b/src-testing/src/renderers/common/Color4.ts
index 6bb6739d6..3a0a8cef6 100644
--- a/src-testing/src/renderers/common/Color4.ts
+++ b/src-testing/src/renderers/common/Color4.ts
@@ -1,14 +1,13 @@
-import { Color } from '../../math/Color.js';
+import { Color, ColorRepresentation } from '../../math/Color.js';
 
 /**
  * A four-component version of {@link Color} which is internally
  * used by the renderer to represents clear color with alpha as
  * one object.
- *
- * @private
- * @augments Color
  */
 class Color4 extends Color {
+    a: number;
+
     /**
      * Constructs a new four-component color.
      * You can also pass a single THREE.Color, hex or
@@ -19,8 +18,10 @@ class Color4 extends Color {
      * @param {number} [b=1] - The blue value.
      * @param {number} [a=1] - The alpha value.
      */
-    constructor(r, g, b, a = 1) {
-        super(r, g, b);
+    constructor(color?: ColorRepresentation);
+    constructor(r: number, g: number, b: number, a?: number);
+    constructor(r?: number, g?: number, b?: number, a = 1) {
+        super(r as number, g!, b!);
 
         this.a = a;
     }
@@ -36,7 +37,8 @@ class Color4 extends Color {
      * @param {number} [a=1] - The alpha value.
      * @return {Color4} A reference to this object.
      */
-    set(r, g, b, a = 1) {
+    set(...args: [color: ColorRepresentation] | [r: number, g: number, b: number, a?: number]): this;
+    set(r: number, g: number, b: number, a = 1) {
         this.a = a;
 
         return super.set(r, g, b);
@@ -48,8 +50,8 @@ class Color4 extends Color {
      * @param {Color4} color - The color to copy.
      * @return {Color4} A reference to this object.
      */
-    copy(color) {
-        if (color.a !== undefined) this.a = color.a;
+    copy(color: Color) {
+        if ((color as Color4).a !== undefined) this.a = (color as Color4).a;
 
         return super.copy(color);
     }
@@ -59,8 +61,8 @@ class Color4 extends Color {
      *
      * @return {Color4} The cloned color.
      */
-    clone() {
-        return new this.constructor(this.r, this.g, this.b, this.a);
+    clone(): this {
+        return new (this.constructor as typeof Color4)(this.r, this.g, this.b, this.a) as this;
     }
 }
 
diff --git a/src-testing/src/renderers/common/ComputePipeline.ts b/src-testing/src/renderers/common/ComputePipeline.ts
index f48a81f6b..7e75ce301 100644
--- a/src-testing/src/renderers/common/ComputePipeline.ts
+++ b/src-testing/src/renderers/common/ComputePipeline.ts
@@ -1,19 +1,21 @@
 import Pipeline from './Pipeline.js';
+import ProgrammableStage from './ProgrammableStage.js';
 
 /**
  * Class for representing compute pipelines.
- *
- * @private
- * @augments Pipeline
  */
 class ComputePipeline extends Pipeline {
+    computeProgram: ProgrammableStage;
+
+    readonly isComputePipeline: true;
+
     /**
      * Constructs a new render pipeline.
      *
      * @param {string} cacheKey - The pipeline's cache key.
      * @param {ProgrammableStage} computeProgram - The pipeline's compute shader.
      */
-    constructor(cacheKey, computeProgram) {
+    constructor(cacheKey: string, computeProgram: ProgrammableStage) {
         super(cacheKey);
 
         /**
diff --git a/src-testing/src/renderers/common/Constants.ts b/src-testing/src/renderers/common/Constants.ts
index c2dfad4c4..023309473 100644
--- a/src-testing/src/renderers/common/Constants.ts
+++ b/src-testing/src/renderers/common/Constants.ts
@@ -3,7 +3,9 @@ export const AttributeType = {
     INDEX: 2,
     STORAGE: 3,
     INDIRECT: 4,
-};
+} as const;
+
+export type AttributeType = (typeof AttributeType)[keyof typeof AttributeType];
 
 // size of a chunk in bytes (STD140 layout)
 
diff --git a/src-testing/src/renderers/common/CubeRenderTarget.ts b/src-testing/src/renderers/common/CubeRenderTarget.ts
index 21bea83bf..883eadb82 100644
--- a/src-testing/src/renderers/common/CubeRenderTarget.ts
+++ b/src-testing/src/renderers/common/CubeRenderTarget.ts
@@ -9,6 +9,9 @@ import { CubeCamera } from '../../cameras/CubeCamera.js';
 import { BoxGeometry } from '../../geometries/BoxGeometry.js';
 import { Mesh } from '../../objects/Mesh.js';
 import { BackSide, NoBlending, LinearFilter, LinearMipmapLinearFilter } from '../../constants.js';
+import { RenderTargetOptions } from '../../core/RenderTarget.js';
+import { WebGLRenderer } from '../WebGLRenderer.js';
+import { Texture } from '../../textures/Texture.js';
 
 // @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget
 
@@ -19,13 +22,15 @@ import { BackSide, NoBlending, LinearFilter, LinearMipmapLinearFilter } from '..
  * @augments WebGLCubeRenderTarget
  */
 class CubeRenderTarget extends WebGLCubeRenderTarget {
+    readonly isCubeRenderTarget: true;
+
     /**
      * Constructs a new cube render target.
      *
      * @param {number} [size=1] - The size of the render target.
      * @param {RenderTarget~Options} [options] - The configuration object.
      */
-    constructor(size = 1, options = {}) {
+    constructor(size = 1, options: RenderTargetOptions = {}) {
         super(size, options);
 
         /**
@@ -45,7 +50,7 @@ class CubeRenderTarget extends WebGLCubeRenderTarget {
      * @param {Texture} texture - The equirectangular texture.
      * @return {CubeRenderTarget} A reference to this cube render target.
      */
-    fromEquirectangularTexture(renderer, texture) {
+    fromEquirectangularTexture(renderer: WebGLRenderer, texture: Texture) {
         const currentMinFilter = texture.minFilter;
         const currentGenerateMipmaps = texture.generateMipmaps;
 
diff --git a/src-testing/src/renderers/common/DataMap.ts b/src-testing/src/renderers/common/DataMap.ts
index b751ce9c5..82de35c06 100644
--- a/src-testing/src/renderers/common/DataMap.ts
+++ b/src-testing/src/renderers/common/DataMap.ts
@@ -1,10 +1,10 @@
 /**
  * Data structure for the renderer. It is intended to manage
  * data of objects in dictionaries.
- *
- * @private
  */
-class DataMap {
+class DataMap<M extends { [key: string]: { key: object; value: unknown } }> {
+    data: WeakMap<M[keyof M]['key'], M[keyof M]['value']>;
+
     /**
      * Constructs a new data map.
      */
@@ -15,7 +15,7 @@ class DataMap {
          *
          * @type {WeakMap<Object, Object>}
          */
-        this.data = new WeakMap();
+        this.data = new WeakMap<M[keyof M]['key'], M[keyof M]['value']>();
     }
 
     /**
@@ -24,7 +24,7 @@ class DataMap {
      * @param {Object} object - The object.
      * @return {Object} The dictionary.
      */
-    get(object) {
+    get<K extends M[keyof M]['key']>(object: K): Extract<M[keyof M], { key: K }>['value'] {
         let map = this.data.get(object);
 
         if (map === undefined) {
@@ -41,7 +41,7 @@ class DataMap {
      * @param {Object} object - The object.
      * @return {?Object} The deleted dictionary.
      */
-    delete(object) {
+    delete<K extends M[keyof M]['key']>(object: K): Extract<M[keyof M], { key: K }>['value'] {
         let map = null;
 
         if (this.data.has(object)) {
@@ -59,7 +59,7 @@ class DataMap {
      * @param {Object} object - The object to test.
      * @return {boolean} Whether a dictionary is defined or not.
      */
-    has(object) {
+    has(object: M[keyof M]['key']) {
         return this.data.has(object);
     }
 
diff --git a/src-testing/src/renderers/common/Geometries.ts b/src-testing/src/renderers/common/Geometries.ts
index 05106e8cf..bfe246611 100644
--- a/src-testing/src/renderers/common/Geometries.ts
+++ b/src-testing/src/renderers/common/Geometries.ts
@@ -2,7 +2,13 @@ import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
 import { arrayNeedsUint32 } from '../../utils.js';
 
-import { Uint16BufferAttribute, Uint32BufferAttribute } from '../../core/BufferAttribute.js';
+import { BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from '../../core/BufferAttribute.js';
+import { BufferGeometry } from '../../core/BufferGeometry.js';
+import Attributes from './Attributes.js';
+import Info from './Info.js';
+import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
+import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
+import RenderObject from './RenderObject.js';
 
 /**
  * Returns the wireframe version for the given geometry.
@@ -12,8 +18,8 @@ import { Uint16BufferAttribute, Uint32BufferAttribute } from '../../core/BufferA
  * @param {BufferGeometry} geometry - The geometry.
  * @return {number} The version.
  */
-function getWireframeVersion(geometry) {
-    return geometry.index !== null ? geometry.index.version : geometry.attributes.position.version;
+function getWireframeVersion(geometry: BufferGeometry) {
+    return geometry.index !== null ? geometry.index.version : (geometry.attributes.position as BufferAttribute).version;
 }
 
 /**
@@ -24,7 +30,7 @@ function getWireframeVersion(geometry) {
  * @param {BufferGeometry} geometry - The geometry.
  * @return {BufferAttribute} The wireframe index attribute.
  */
-function getWireframeIndex(geometry) {
+function getWireframeIndex(geometry: BufferGeometry) {
     const indices = [];
 
     const geometryIndex = geometry.index;
@@ -58,20 +64,27 @@ function getWireframeIndex(geometry) {
     return attribute;
 }
 
+interface GeometryData {
+    initialized?: boolean | undefined;
+}
+
 /**
  * This renderer module manages geometries.
- *
- * @private
- * @augments DataMap
  */
-class Geometries extends DataMap {
+class Geometries extends DataMap<{ geometry: { key: BufferGeometry; value: GeometryData } }> {
+    attributes: Attributes;
+    info: Info;
+
+    wireframes: WeakMap<BufferGeometry, BufferAttribute>;
+    attributeCall: WeakMap<BufferAttribute | InterleavedBufferAttribute | InterleavedBuffer, number>;
+
     /**
      * Constructs a new geometry management component.
      *
      * @param {Attributes} attributes - Renderer component for managing attributes.
      * @param {Info} info - Renderer component for managing metrics and monitoring data.
      */
-    constructor(attributes, info) {
+    constructor(attributes: Attributes, info: Info) {
         super();
 
         /**
@@ -93,7 +106,7 @@ class Geometries extends DataMap {
          *
          * @type {WeakMap<BufferGeometry,BufferAttribute>}
          */
-        this.wireframes = new WeakMap();
+        this.wireframes = new WeakMap<BufferGeometry, BufferAttribute>();
 
         /**
          * This Weak Map is used to make sure buffer attributes are
@@ -101,7 +114,7 @@ class Geometries extends DataMap {
          *
          * @type {WeakMap<BufferAttribute,number>}
          */
-        this.attributeCall = new WeakMap();
+        this.attributeCall = new WeakMap<BufferAttribute | InterleavedBufferAttribute, number>();
 
         /**
          * Stores the event listeners attached to geometries.
@@ -118,8 +131,8 @@ class Geometries extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {boolean} Whether if the given render object has an initialized geometry or not.
      */
-    has(renderObject) {
-        const geometry = renderObject.geometry;
+    has(renderObject: RenderObject | BufferGeometry) {
+        const geometry = (renderObject as RenderObject).geometry;
 
         return super.has(geometry) && this.get(geometry).initialized === true;
     }
@@ -129,7 +142,7 @@ class Geometries extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         if (this.has(renderObject) === false) this.initGeometry(renderObject);
 
         this.updateAttributes(renderObject);
@@ -140,7 +153,7 @@ class Geometries extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    initGeometry(renderObject) {
+    initGeometry(renderObject: RenderObject) {
         const geometry = renderObject.geometry;
         const geometryData = this.get(geometry);
 
@@ -185,9 +198,8 @@ class Geometries extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateAttributes(renderObject) {
+    updateAttributes(renderObject: RenderObject) {
         // attributes
-
         const attributes = renderObject.getAttributes();
 
         for (const attribute of attributes) {
@@ -221,10 +233,10 @@ class Geometries extends DataMap {
      * @param {BufferAttribute} attribute - The attribute to update.
      * @param {number} type - The attribute type.
      */
-    updateAttribute(attribute, type) {
+    updateAttribute(attribute: BufferAttribute | InterleavedBufferAttribute, type: AttributeType) {
         const callId = this.info.render.calls;
 
-        if (!attribute.isInterleavedBufferAttribute) {
+        if (!(attribute as InterleavedBufferAttribute).isInterleavedBufferAttribute) {
             if (this.attributeCall.get(attribute) !== callId) {
                 this.attributes.update(attribute, type);
 
@@ -235,10 +247,10 @@ class Geometries extends DataMap {
                 this.attributes.update(attribute, type);
 
                 this.attributeCall.set(attribute, callId);
-            } else if (this.attributeCall.get(attribute.data) !== callId) {
+            } else if (this.attributeCall.get((attribute as InterleavedBufferAttribute).data) !== callId) {
                 this.attributes.update(attribute, type);
 
-                this.attributeCall.set(attribute.data, callId);
+                this.attributeCall.set((attribute as InterleavedBufferAttribute).data, callId);
 
                 this.attributeCall.set(attribute, callId);
             }
@@ -251,7 +263,7 @@ class Geometries extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
      */
-    getIndirect(renderObject) {
+    getIndirect(renderObject: RenderObject) {
         return renderObject.geometry.indirect;
     }
 
@@ -261,7 +273,7 @@ class Geometries extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {number} The byte offset into the indirect attribute buffer.
      */
-    getIndirectOffset(renderObject) {
+    getIndirectOffset(renderObject: RenderObject) {
         return renderObject.geometry.indirectOffset;
     }
 
@@ -272,7 +284,7 @@ class Geometries extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
      */
-    getIndex(renderObject) {
+    getIndex(renderObject: RenderObject) {
         const { geometry, material } = renderObject;
 
         let index = geometry.index;
diff --git a/src-testing/src/renderers/common/Info.ts b/src-testing/src/renderers/common/Info.ts
index 17e7f8723..b22127bda 100644
--- a/src-testing/src/renderers/common/Info.ts
+++ b/src-testing/src/renderers/common/Info.ts
@@ -1,4 +1,10 @@
 import { error } from '../../utils.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Mesh } from '../../objects/Mesh.js';
+import { Sprite } from '../../objects/Sprite.js';
+import { Points } from '../../objects/Points.js';
+import { LineSegments } from '../../objects/LineSegments.js';
+import { Line } from '../../objects/Line.js';
 
 /**
  * This renderer module provides a series of statistical information
@@ -6,6 +12,32 @@ import { error } from '../../utils.js';
  * and monitoring.
  */
 class Info {
+    autoReset: boolean;
+
+    frame: number;
+    calls: number;
+
+    render: {
+        calls: number;
+        frameCalls: number;
+        drawCalls: number;
+        triangles: number;
+        points: number;
+        lines: number;
+        timestamp: number;
+    };
+
+    compute: {
+        calls: number;
+        frameCalls: number;
+        timestamp: number;
+    };
+
+    memory: {
+        geometries: number;
+        textures: number;
+    };
+
     /**
      * Constructs a new info component.
      */
@@ -100,16 +132,16 @@ class Info {
      * @param {number} count - The vertex or index count.
      * @param {number} instanceCount - The instance count.
      */
-    update(object, count, instanceCount) {
+    update(object: Object3D, count: number, instanceCount: number) {
         this.render.drawCalls++;
 
-        if (object.isMesh || object.isSprite) {
+        if ((object as Mesh).isMesh || (object as Sprite).isSprite) {
             this.render.triangles += instanceCount * (count / 3);
-        } else if (object.isPoints) {
+        } else if ((object as Points).isPoints) {
             this.render.points += instanceCount * count;
-        } else if (object.isLineSegments) {
+        } else if ((object as LineSegments).isLineSegments) {
             this.render.lines += instanceCount * (count / 2);
-        } else if (object.isLine) {
+        } else if ((object as Line).isLine) {
             this.render.lines += instanceCount * (count - 1);
         } else {
             error('WebGPUInfo: Unknown object type.');
diff --git a/src-testing/src/renderers/common/InspectorBase.ts b/src-testing/src/renderers/common/InspectorBase.ts
index 5219fa00a..d3770a64d 100644
--- a/src-testing/src/renderers/common/InspectorBase.ts
+++ b/src-testing/src/renderers/common/InspectorBase.ts
@@ -1,9 +1,16 @@
+import Renderer from './Renderer.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import { Scene } from '../../scenes/Scene.js';
+import { Camera } from '../../cameras/Camera.js';
+import { RenderTarget } from '../../core/RenderTarget.js';
+import { Texture } from '../../textures/Texture.js';
+
 /**
  * InspectorBase is the base class for all inspectors.
- *
- * @class InspectorBase
  */
 class InspectorBase {
+    _renderer: Renderer | null;
+
     /**
      * Creates a new InspectorBase.
      */
@@ -30,7 +37,7 @@ class InspectorBase {
      * @return {Object} The node frame.
      */
     get nodeFrame() {
-        return this._renderer._nodes.nodeFrame;
+        return this._renderer!._nodes!.nodeFrame;
     }
 
     /**
@@ -39,7 +46,7 @@ class InspectorBase {
      * @param {WebGLRenderer} renderer - The renderer to associate with this inspector.
      * @return {InspectorBase} This inspector instance.
      */
-    setRenderer(renderer) {
+    setRenderer(renderer: Renderer | null) {
         this._renderer = renderer;
 
         return this;
@@ -82,7 +89,7 @@ class InspectorBase {
      * @param {ComputeNode} computeNode - The compute node being executed.
      * @param {number|Array<number>} dispatchSizeOrCount - The dispatch size or count.
      */
-    computeAsync(/*computeNode, dispatchSizeOrCount*/) {}
+    computeAsync(computeNode: ComputeNode, dispatchSizeOrCount: number | number[]) {}
 
     /**
      * Called when a compute operation begins.
@@ -90,7 +97,7 @@ class InspectorBase {
      * @param {string} uid - A unique identifier for the render context.
      * @param {ComputeNode} computeNode - The compute node being executed.
      */
-    beginCompute(/*uid, computeNode*/) {}
+    beginCompute(uid: string, computeNode: ComputeNode) {}
 
     /**
      * Called when a compute operation ends.
@@ -98,7 +105,7 @@ class InspectorBase {
      * @param {string} uid - A unique identifier for the render context.
      * @param {ComputeNode} computeNode - The compute node being executed.
      */
-    finishCompute(/*uid*/) {}
+    finishCompute(uid: string) {}
 
     /**
      * Called when a render operation begins.
@@ -108,14 +115,14 @@ class InspectorBase {
      * @param {Camera} camera - The camera being used for rendering.
      * @param {?WebGLRenderTarget} renderTarget - The render target, if any.
      */
-    beginRender(/*uid, scene, camera, renderTarget*/) {}
+    beginRender(uid: string, scene: Scene, camera: Camera, renderTarget: RenderTarget) {}
 
     /**
      * Called when an animation loop ends.
      *
      * @param {string} uid - A unique identifier for the render context.
      */
-    finishRender(/*uid*/) {}
+    finishRender(uid: string) {}
 
     /**
      * Called when a texture copy operation is performed.
@@ -123,14 +130,14 @@ class InspectorBase {
      * @param {Texture} srcTexture - The source texture.
      * @param {Texture} dstTexture - The destination texture.
      */
-    copyTextureToTexture(/*srcTexture, dstTexture*/) {}
+    copyTextureToTexture(srcTexture: Texture, dstTexture: Texture) {}
 
     /**
      * Called when a framebuffer copy operation is performed.
      *
      * @param {Texture} framebufferTexture - The texture associated with the framebuffer.
      */
-    copyFramebufferToTexture(/*framebufferTexture*/) {}
+    copyFramebufferToTexture(framebufferTexture: Texture) {}
 }
 
 export default InspectorBase;
diff --git a/src-testing/src/renderers/common/Pipeline.ts b/src-testing/src/renderers/common/Pipeline.ts
index ea931b7e7..9197c320c 100644
--- a/src-testing/src/renderers/common/Pipeline.ts
+++ b/src-testing/src/renderers/common/Pipeline.ts
@@ -1,16 +1,19 @@
 /**
  * Abstract class for representing pipelines.
  *
- * @private
  * @abstract
  */
 class Pipeline {
+    cacheKey: string;
+
+    usedTimes: number;
+
     /**
      * Constructs a new pipeline.
      *
      * @param {string} cacheKey - The pipeline's cache key.
      */
-    constructor(cacheKey) {
+    constructor(cacheKey: string) {
         /**
          * The pipeline's cache key.
          *
diff --git a/src-testing/src/renderers/common/Pipelines.ts b/src-testing/src/renderers/common/Pipelines.ts
index 756a4098d..7e31937c6 100644
--- a/src-testing/src/renderers/common/Pipelines.ts
+++ b/src-testing/src/renderers/common/Pipelines.ts
@@ -2,21 +2,49 @@ import DataMap from './DataMap.js';
 import RenderObjectPipeline from './RenderObjectPipeline.js';
 import ComputePipeline from './ComputePipeline.js';
 import ProgrammableStage from './ProgrammableStage.js';
+import Backend from './Backend.js';
+import NodeManager from './nodes/NodeManager.js';
+import Bindings from './Bindings.js';
+import RenderObject from './RenderObject.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import Binding from './Binding.js';
+import Pipeline from './Pipeline.js';
+
+interface ComputeNodeData {
+    version: number;
+    pipeline: ComputePipeline;
+}
+
+interface RenderObjectData {
+    pipeline: RenderObjectPipeline;
+}
 
 /**
  * This renderer module manages the pipelines of the renderer.
- *
- * @private
- * @augments DataMap
  */
-class Pipelines extends DataMap {
+class Pipelines extends DataMap<{
+    computeNode: { key: ComputeNode; value: ComputeNodeData };
+    renderObject: { key: RenderObject; value: RenderObjectData };
+}> {
+    backend: Backend;
+    nodes: NodeManager;
+
+    bindings: Bindings | null;
+
+    caches: Map<string, Pipeline>;
+    programs: {
+        vertex: Map<string, ProgrammableStage>;
+        fragment: Map<string, ProgrammableStage>;
+        compute: Map<string, ProgrammableStage>;
+    };
+
     /**
      * Constructs a new pipeline management component.
      *
      * @param {Backend} backend - The renderer's backend.
      * @param {Nodes} nodes - Renderer component for managing nodes related logic.
      */
-    constructor(backend, nodes) {
+    constructor(backend: Backend, nodes: NodeManager) {
         super();
 
         /**
@@ -49,7 +77,7 @@ class Pipelines extends DataMap {
          *
          * @type {Map<string,Pipeline>}
          */
-        this.caches = new Map();
+        this.caches = new Map<string, Pipeline>();
 
         /**
          * This dictionary maintains for each shader stage type (vertex,
@@ -59,9 +87,9 @@ class Pipelines extends DataMap {
          * @type {Object<string,Map<string, ProgrammableStage>>}
          */
         this.programs = {
-            vertex: new Map(),
-            fragment: new Map(),
-            compute: new Map(),
+            vertex: new Map<string, ProgrammableStage>(),
+            fragment: new Map<string, ProgrammableStage>(),
+            compute: new Map<string, ProgrammableStage>(),
         };
     }
 
@@ -72,7 +100,7 @@ class Pipelines extends DataMap {
      * @param {Array<BindGroup>} bindings - The bindings.
      * @return {ComputePipeline} The compute pipeline.
      */
-    getForCompute(computeNode, bindings) {
+    getForCompute(computeNode: ComputeNode, bindings: Binding[]) {
         const { backend } = this;
 
         const data = this.get(computeNode);
@@ -91,20 +119,20 @@ class Pipelines extends DataMap {
 
             // programmable stage
 
-            let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader);
+            let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader!);
 
             if (stageCompute === undefined) {
                 if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0)
                     this._releaseProgram(previousPipeline.computeProgram);
 
                 stageCompute = new ProgrammableStage(
-                    nodeBuilderState.computeShader,
+                    nodeBuilderState.computeShader!,
                     'compute',
                     computeNode.name,
                     nodeBuilderState.transforms,
                     nodeBuilderState.nodeAttributes,
                 );
-                this.programs.compute.set(nodeBuilderState.computeShader, stageCompute);
+                this.programs.compute.set(nodeBuilderState.computeShader!, stageCompute);
 
                 backend.createProgram(stageCompute);
             }
@@ -113,7 +141,7 @@ class Pipelines extends DataMap {
 
             const cacheKey = this._getComputeCacheKey(computeNode, stageCompute);
 
-            let pipeline = this.caches.get(cacheKey);
+            let pipeline = this.caches.get(cacheKey) as ComputePipeline | undefined;
 
             if (pipeline === undefined) {
                 if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
@@ -142,7 +170,7 @@ class Pipelines extends DataMap {
      * @param {?Array<Promise>} [promises=null] - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
      * @return {RenderObjectPipeline} The render pipeline.
      */
-    getForRender(renderObject, promises = null) {
+    getForRender(renderObject: RenderObject, promises: Promise<void>[] | null = null) {
         const { backend } = this;
 
         const data = this.get(renderObject);
@@ -164,26 +192,26 @@ class Pipelines extends DataMap {
 
             // programmable stages
 
-            let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);
+            let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader!);
 
             if (stageVertex === undefined) {
                 if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0)
                     this._releaseProgram(previousPipeline.vertexProgram);
 
-                stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader, 'vertex', name);
-                this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);
+                stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader!, 'vertex', name);
+                this.programs.vertex.set(nodeBuilderState.vertexShader!, stageVertex);
 
                 backend.createProgram(stageVertex);
             }
 
-            let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader);
+            let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader!);
 
             if (stageFragment === undefined) {
                 if (previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0)
                     this._releaseProgram(previousPipeline.fragmentProgram);
 
-                stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader, 'fragment', name);
-                this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);
+                stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader!, 'fragment', name);
+                this.programs.fragment.set(nodeBuilderState.fragmentShader!, stageFragment);
 
                 backend.createProgram(stageFragment);
             }
@@ -192,7 +220,7 @@ class Pipelines extends DataMap {
 
             const cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
 
-            let pipeline = this.caches.get(cacheKey);
+            let pipeline = this.caches.get(cacheKey) as RenderObjectPipeline | undefined;
 
             if (pipeline === undefined) {
                 if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
@@ -222,7 +250,7 @@ class Pipelines extends DataMap {
      * @param {RenderObject} object - The render object.
      * @return {?Object} The deleted dictionary.
      */
-    delete(object) {
+    delete(object: ComputeNode | RenderObject): never {
         const pipeline = this.get(object).pipeline;
 
         if (pipeline) {
@@ -234,20 +262,23 @@ class Pipelines extends DataMap {
 
             // programs
 
-            if (pipeline.isComputePipeline) {
-                pipeline.computeProgram.usedTimes--;
+            if ((pipeline as ComputePipeline).isComputePipeline) {
+                (pipeline as ComputePipeline).computeProgram.usedTimes--;
 
-                if (pipeline.computeProgram.usedTimes === 0) this._releaseProgram(pipeline.computeProgram);
+                if ((pipeline as ComputePipeline).computeProgram.usedTimes === 0)
+                    this._releaseProgram((pipeline as ComputePipeline).computeProgram);
             } else {
-                pipeline.fragmentProgram.usedTimes--;
-                pipeline.vertexProgram.usedTimes--;
+                (pipeline as RenderObjectPipeline).fragmentProgram.usedTimes--;
+                (pipeline as RenderObjectPipeline).vertexProgram.usedTimes--;
 
-                if (pipeline.vertexProgram.usedTimes === 0) this._releaseProgram(pipeline.vertexProgram);
-                if (pipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(pipeline.fragmentProgram);
+                if ((pipeline as RenderObjectPipeline).vertexProgram.usedTimes === 0)
+                    this._releaseProgram((pipeline as RenderObjectPipeline).vertexProgram);
+                if ((pipeline as RenderObjectPipeline).fragmentProgram.usedTimes === 0)
+                    this._releaseProgram((pipeline as RenderObjectPipeline).fragmentProgram);
             }
         }
 
-        return super.delete(object);
+        return super.delete(object) as never;
     }
 
     /**
@@ -269,26 +300,30 @@ class Pipelines extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         this.getForRender(renderObject);
     }
 
     /**
      * Returns a compute pipeline for the given parameters.
      *
-     * @private
      * @param {Node} computeNode - The compute node.
      * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
      * @param {string} cacheKey - The cache key.
      * @param {Array<BindGroup>} bindings - The bindings.
      * @return {ComputePipeline} The compute pipeline.
      */
-    _getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {
+    private _getComputePipeline(
+        computeNode: ComputeNode,
+        stageCompute: ProgrammableStage,
+        cacheKey: string,
+        bindings: Binding[],
+    ) {
         // check for existing pipeline
 
         cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);
 
-        let pipeline = this.caches.get(cacheKey);
+        let pipeline = this.caches.get(cacheKey) as ComputePipeline | undefined;
 
         if (pipeline === undefined) {
             pipeline = new ComputePipeline(cacheKey, stageCompute);
@@ -304,7 +339,6 @@ class Pipelines extends DataMap {
     /**
      * Returns a render pipeline for the given parameters.
      *
-     * @private
      * @param {RenderObject} renderObject - The render object.
      * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
      * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
@@ -312,12 +346,18 @@ class Pipelines extends DataMap {
      * @param {?Array<Promise>} promises - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
      * @return {RenderObjectPipeline} The render pipeline.
      */
-    _getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises) {
+    private _getRenderPipeline(
+        renderObject: RenderObject,
+        stageVertex: ProgrammableStage,
+        stageFragment: ProgrammableStage,
+        cacheKey: string,
+        promises: Promise<void>[] | null,
+    ) {
         // check for existing pipeline
 
         cacheKey = cacheKey || this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
 
-        let pipeline = this.caches.get(cacheKey);
+        let pipeline = this.caches.get(cacheKey) as RenderObjectPipeline | undefined;
 
         if (pipeline === undefined) {
             pipeline = new RenderObjectPipeline(cacheKey, stageVertex, stageFragment);
@@ -339,45 +379,45 @@ class Pipelines extends DataMap {
     /**
      * Computes a cache key representing a compute pipeline.
      *
-     * @private
      * @param {Node} computeNode - The compute node.
      * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
      * @return {string} The cache key.
      */
-    _getComputeCacheKey(computeNode, stageCompute) {
+    private _getComputeCacheKey(computeNode: ComputeNode, stageCompute: ProgrammableStage) {
         return computeNode.id + ',' + stageCompute.id;
     }
 
     /**
      * Computes a cache key representing a render pipeline.
      *
-     * @private
      * @param {RenderObject} renderObject - The render object.
      * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
      * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
      * @return {string} The cache key.
      */
-    _getRenderCacheKey(renderObject, stageVertex, stageFragment) {
+    private _getRenderCacheKey(
+        renderObject: RenderObject,
+        stageVertex: ProgrammableStage,
+        stageFragment: ProgrammableStage,
+    ) {
         return stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey(renderObject);
     }
 
     /**
      * Releases the given pipeline.
      *
-     * @private
      * @param {Pipeline} pipeline - The pipeline to release.
      */
-    _releasePipeline(pipeline) {
+    private _releasePipeline(pipeline: Pipeline) {
         this.caches.delete(pipeline.cacheKey);
     }
 
     /**
      * Releases the shader program.
      *
-     * @private
      * @param {Object} program - The shader program to release.
      */
-    _releaseProgram(program) {
+    private _releaseProgram(program: ProgrammableStage) {
         const code = program.code;
         const stage = program.stage;
 
@@ -387,11 +427,10 @@ class Pipelines extends DataMap {
     /**
      * Returns `true` if the compute pipeline for the given compute node requires an update.
      *
-     * @private
      * @param {Node} computeNode - The compute node.
      * @return {boolean} Whether the compute pipeline for the given compute node requires an update or not.
      */
-    _needsComputeUpdate(computeNode) {
+    private _needsComputeUpdate(computeNode: ComputeNode) {
         const data = this.get(computeNode);
 
         return data.pipeline === undefined || data.version !== computeNode.version;
@@ -400,11 +439,10 @@ class Pipelines extends DataMap {
     /**
      * Returns `true` if the render pipeline for the given render object requires an update.
      *
-     * @private
      * @param {RenderObject} renderObject - The render object.
      * @return {boolean} Whether the render object for the given render object requires an update or not.
      */
-    _needsRenderUpdate(renderObject) {
+    private _needsRenderUpdate(renderObject: RenderObject) {
         const data = this.get(renderObject);
 
         return data.pipeline === undefined || this.backend.needsRenderUpdate(renderObject);
diff --git a/src-testing/src/renderers/common/ProgrammableStage.ts b/src-testing/src/renderers/common/ProgrammableStage.ts
index 0dc5923ea..7be41276a 100644
--- a/src-testing/src/renderers/common/ProgrammableStage.ts
+++ b/src-testing/src/renderers/common/ProgrammableStage.ts
@@ -1,13 +1,24 @@
+import NodeAttribute from '../../nodes/core/NodeAttribute.js';
+
 let _id = 0;
 
 /**
  * Class for representing programmable stages which are vertex,
  * fragment or compute shaders. Unlike fixed-function states (like blending),
  * they represent the programmable part of a pipeline.
- *
- * @private
  */
 class ProgrammableStage {
+    id: number;
+
+    code: string;
+    stage: 'compute' | 'vertex' | 'fragment';
+    name: string;
+    // TODO
+    // transforms
+    attributes: NodeAttribute[] | null;
+
+    usedTimes: number;
+
     /**
      * Constructs a new programmable stage.
      *
@@ -17,7 +28,13 @@ class ProgrammableStage {
      * @param {?Array<Object>} [transforms=null] - The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
      * @param {?Array<Object>} [attributes=null] - The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
      */
-    constructor(code, stage, name, transforms = null, attributes = null) {
+    constructor(
+        code: string,
+        stage: 'compute' | 'vertex' | 'fragment',
+        name: string,
+        transforms = null,
+        attributes: NodeAttribute[] | null = null,
+    ) {
         /**
          * The id of the programmable stage.
          *
diff --git a/src-testing/src/renderers/common/RenderBundle.ts b/src-testing/src/renderers/common/RenderBundle.ts
index ffa289967..199e863bf 100644
--- a/src-testing/src/renderers/common/RenderBundle.ts
+++ b/src-testing/src/renderers/common/RenderBundle.ts
@@ -1,17 +1,21 @@
+import { Camera } from '../../cameras/Camera.js';
+import BundleGroup from './BundleGroup.js';
+
 /**
  * This module is used to represent render bundles inside the renderer
  * for further processing.
- *
- * @private
  */
 class RenderBundle {
+    bundleGroup: BundleGroup;
+    camera: Camera;
+
     /**
      * Constructs a new bundle group.
      *
      * @param {BundleGroup} bundleGroup - The bundle group.
      * @param {Camera} camera - The camera the bundle group is rendered with.
      */
-    constructor(bundleGroup, camera) {
+    constructor(bundleGroup: BundleGroup, camera: Camera) {
         this.bundleGroup = bundleGroup;
         this.camera = camera;
     }
diff --git a/src-testing/src/renderers/common/RenderBundles.ts b/src-testing/src/renderers/common/RenderBundles.ts
index d6c726961..4efaaf244 100644
--- a/src-testing/src/renderers/common/RenderBundles.ts
+++ b/src-testing/src/renderers/common/RenderBundles.ts
@@ -1,14 +1,16 @@
 import ChainMap from './ChainMap.js';
 import RenderBundle from './RenderBundle.js';
+import { Camera } from '../../cameras/Camera.js';
+import BundleGroup from './BundleGroup.js';
 
-const _chainKeys = [];
+const _chainKeys = [] as unknown as [BundleGroup, Camera];
 
 /**
  * This renderer module manages render bundles.
- *
- * @private
  */
 class RenderBundles {
+    bundles: ChainMap<readonly [BundleGroup, Camera], RenderBundle>;
+
     /**
      * Constructs a new render bundle management component.
      */
@@ -28,7 +30,7 @@ class RenderBundles {
      * @param {Camera} camera - The camera the bundle group is rendered with.
      * @return {RenderBundle} The render bundle.
      */
-    get(bundleGroup, camera) {
+    get(bundleGroup: BundleGroup, camera: Camera) {
         const bundles = this.bundles;
 
         _chainKeys[0] = bundleGroup;
diff --git a/src-testing/src/renderers/common/RenderContext.ts b/src-testing/src/renderers/common/RenderContext.ts
index 4bfd28c1b..0a48f2612 100644
--- a/src-testing/src/renderers/common/RenderContext.ts
+++ b/src-testing/src/renderers/common/RenderContext.ts
@@ -1,5 +1,11 @@
 import { Vector4 } from '../../math/Vector4.js';
 import { hashArray } from '../../nodes/core/NodeUtils.js';
+import { Texture } from '../../textures/Texture.js';
+import { DepthTexture } from '../../textures/DepthTexture.js';
+import ClippingContext from './ClippingContext.js';
+import { RenderTarget } from '../../core/RenderTarget.js';
+import MRTNode from '../../nodes/core/MRTNode.js';
+import { Camera } from '../../cameras/Camera.js';
 
 let _id = 0;
 
@@ -8,10 +14,48 @@ let _id = 0;
  * the state of the renderer and its backend. Typical examples for such context
  * data are the current clear values or data from the active framebuffer. This
  * module is used to represent these contexts as objects.
- *
- * @private
  */
 class RenderContext {
+    id: number;
+
+    mrt: MRTNode | null;
+
+    color: boolean;
+    clearColor: boolean;
+    clearColorValue: { r: number; g: number; b: number; a: number };
+
+    depth: boolean;
+    clearDepth: boolean;
+    clearDepthValue: number;
+
+    stencil: boolean;
+    clearStencil: boolean;
+    clearStencilValue: number;
+
+    viewport: boolean;
+    viewportValue: Vector4;
+    scissor: boolean;
+    scissorValue: Vector4;
+    renderTarget: RenderTarget | null;
+
+    textures: Texture[] | null;
+    depthTexture: DepthTexture | null;
+    activeCubeFace: number;
+    sampleCount: number;
+
+    width: number;
+    height: number;
+    occlusionQueryCount: number;
+    clippingContext: ClippingContext | null;
+    camera: Camera | null;
+
+    readonly isRenderContext: true;
+
+    depthClearValue?: number | undefined;
+    stencilClearValue?: number | undefined;
+
+    activeMipmapLevel?: number | undefined;
+
     /**
      * Constructs a new render context.
      */
@@ -256,12 +300,12 @@ class RenderContext {
  * @param {RenderContext} renderContext - The render context.
  * @return {number} The cache key.
  */
-export function getCacheKey(renderContext) {
+export function getCacheKey(renderContext: RenderContext) {
     const { textures, activeCubeFace, activeMipmapLevel } = renderContext;
 
     const values = [activeCubeFace, activeMipmapLevel];
 
-    for (const texture of textures) {
+    for (const texture of textures!) {
         values.push(texture.id);
     }
 
diff --git a/src-testing/src/renderers/common/RenderContexts.ts b/src-testing/src/renderers/common/RenderContexts.ts
index 1efdf8b1a..d50780c7f 100644
--- a/src-testing/src/renderers/common/RenderContexts.ts
+++ b/src-testing/src/renderers/common/RenderContexts.ts
@@ -1,11 +1,15 @@
 import RenderContext from './RenderContext.js';
+import { RenderTarget } from '../../core/RenderTarget.js';
+import MRTNode from '../../nodes/core/MRTNode.js';
 
 /**
  * This module manages the render contexts of the renderer.
- *
- * @private
  */
 class RenderContexts {
+    _renderContexts: {
+        [renderStateKey: string]: RenderContext | undefined;
+    };
+
     /**
      * Constructs a new render context management component.
      */
@@ -26,7 +30,7 @@ class RenderContexts {
      * @param {?number} [callDepth=0] - The call depth of the renderer.
      * @return {RenderContext} The render context.
      */
-    get(renderTarget = null, mrt = null, callDepth = 0) {
+    get(renderTarget: RenderTarget | null = null, mrt: MRTNode | null = null, callDepth = 0) {
         //
 
         let attachmentState;
diff --git a/src-testing/src/renderers/common/RenderList.ts b/src-testing/src/renderers/common/RenderList.ts
index a4cfe35ff..d45daa28d 100644
--- a/src-testing/src/renderers/common/RenderList.ts
+++ b/src-testing/src/renderers/common/RenderList.ts
@@ -1,4 +1,13 @@
 import { DoubleSide } from '../../constants.js';
+import { LightsNode } from '../../nodes/Nodes.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Camera } from '../../cameras/Camera.js';
+import { BufferGeometry, GeometryGroup } from '../../core/BufferGeometry.js';
+import { Material } from '../../materials/Material.js';
+import { Light } from '../../lights/Light.js';
+import BundleGroup from './BundleGroup.js';
+import Lighting from './Lighting.js';
+import ClippingContext from './ClippingContext.js';
 
 /**
  * Default sorting function for opaque render items.
@@ -9,15 +18,15 @@ import { DoubleSide } from '../../constants.js';
  * @param {Object} b - The second render item.
  * @return {number} A numeric value which defines the sort order.
  */
-function painterSortStable(a, b) {
+function painterSortStable(a: RenderItem, b: RenderItem) {
     if (a.groupOrder !== b.groupOrder) {
-        return a.groupOrder - b.groupOrder;
+        return a.groupOrder! - b.groupOrder!;
     } else if (a.renderOrder !== b.renderOrder) {
-        return a.renderOrder - b.renderOrder;
+        return a.renderOrder! - b.renderOrder!;
     } else if (a.z !== b.z) {
-        return a.z - b.z;
+        return a.z! - b.z!;
     } else {
-        return a.id - b.id;
+        return a.id! - b.id!;
     }
 }
 
@@ -30,18 +39,36 @@ function painterSortStable(a, b) {
  * @param {Object} b - The second render item.
  * @return {number} A numeric value which defines the sort order.
  */
-function reversePainterSortStable(a, b) {
+function reversePainterSortStable(a: RenderItem, b: RenderItem) {
     if (a.groupOrder !== b.groupOrder) {
-        return a.groupOrder - b.groupOrder;
+        return a.groupOrder! - b.groupOrder!;
     } else if (a.renderOrder !== b.renderOrder) {
-        return a.renderOrder - b.renderOrder;
+        return a.renderOrder! - b.renderOrder!;
     } else if (a.z !== b.z) {
-        return b.z - a.z;
+        return b.z! - a.z!;
     } else {
-        return a.id - b.id;
+        return a.id! - b.id!;
     }
 }
 
+export interface Bundle {
+    bundleGroup: BundleGroup;
+    camera: Camera;
+    renderList: RenderList;
+}
+
+export interface RenderItem {
+    id: number | null;
+    object: Object3D | null;
+    geometry: BufferGeometry | null;
+    material: Material | null;
+    groupOrder: number | null;
+    renderOrder: number | null;
+    z: number | null;
+    group: GeometryGroup | null;
+    clippingContext: ClippingContext | null;
+}
+
 /**
  * Returns `true` if the given transparent material requires a double pass.
  *
@@ -50,7 +77,7 @@ function reversePainterSortStable(a, b) {
  * @param {Material} material - The transparent material.
  * @return {boolean} Whether the given material requires a double pass or not.
  */
-function needsDoublePass(material) {
+function needsDoublePass(material: Material) {
     const hasTransmission =
         material.transmission > 0 || (material.transmissionNode && material.transmissionNode.isNode);
 
@@ -64,11 +91,24 @@ function needsDoublePass(material) {
  * objects are maintained in ordered lists for the actual rendering.
  *
  * Render lists are unique per scene and camera combination.
- *
- * @private
- * @augments Pipeline
  */
 class RenderList {
+    renderItems: RenderItem[];
+    renderItemsIndex: number;
+
+    opaque: RenderItem[];
+    transparentDoublePass: RenderItem[];
+    transparent: RenderItem[];
+    bundles: Bundle[];
+
+    lightsNode: LightsNode;
+    lightsArray: Light[];
+
+    scene: Object3D;
+    camera: Camera;
+
+    occlusionQueryCount: number;
+
     /**
      * Constructs a render list.
      *
@@ -76,7 +116,7 @@ class RenderList {
      * @param {Scene} scene - The scene.
      * @param {Camera} camera - The camera the scene is rendered with.
      */
-    constructor(lighting, scene, camera) {
+    constructor(lighting: Lighting, scene: Object3D, camera: Camera) {
         /**
          * 3D objects are transformed into render items and stored in this array.
          *
@@ -199,7 +239,15 @@ class RenderList {
      * @param {ClippingContext} clippingContext - The current clipping context.
      * @return {Object} The render item.
      */
-    getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext) {
+    getNextRenderItem(
+        object: Object3D,
+        geometry: BufferGeometry,
+        material: Material,
+        groupOrder: number,
+        z: number,
+        group: GeometryGroup | null,
+        clippingContext: ClippingContext | null,
+    ) {
         let renderItem = this.renderItems[this.renderItemsIndex];
 
         if (renderItem === undefined) {
@@ -245,7 +293,15 @@ class RenderList {
      * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
      * @param {ClippingContext} clippingContext - The current clipping context.
      */
-    push(object, geometry, material, groupOrder, z, group, clippingContext) {
+    push(
+        object: Object3D,
+        geometry: BufferGeometry,
+        material: Material,
+        groupOrder: number,
+        z: number,
+        group: GeometryGroup | null,
+        clippingContext: ClippingContext | null,
+    ) {
         const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);
 
         if (object.occlusionTest === true) this.occlusionQueryCount++;
@@ -276,7 +332,15 @@ class RenderList {
      * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
      * @param {ClippingContext} clippingContext - The current clipping context.
      */
-    unshift(object, geometry, material, groupOrder, z, group, clippingContext) {
+    unshift(
+        object: Object3D,
+        geometry: BufferGeometry,
+        material: Material,
+        groupOrder: number,
+        z: number,
+        group: GeometryGroup | null,
+        clippingContext: ClippingContext | null,
+    ) {
         const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);
 
         if (
@@ -298,7 +362,7 @@ class RenderList {
      *
      * @param {Object} group - Bundle group data.
      */
-    pushBundle(group) {
+    pushBundle(group: Bundle) {
         this.bundles.push(group);
     }
 
@@ -307,7 +371,7 @@ class RenderList {
      *
      * @param {Light} light - The light.
      */
-    pushLight(light) {
+    pushLight(light: Light) {
         this.lightsArray.push(light);
     }
 
@@ -317,7 +381,10 @@ class RenderList {
      * @param {?function(any, any): number} customOpaqueSort - A custom sort function for opaque objects.
      * @param {?function(any, any): number} customTransparentSort -  A custom sort function for transparent objects.
      */
-    sort(customOpaqueSort, customTransparentSort) {
+    sort(
+        customOpaqueSort: ((a: RenderItem, b: RenderItem) => number) | null,
+        customTransparentSort: ((a: RenderItem, b: RenderItem) => number) | null,
+    ) {
         if (this.opaque.length > 1) this.opaque.sort(customOpaqueSort || painterSortStable);
         if (this.transparentDoublePass.length > 1)
             this.transparentDoublePass.sort(customTransparentSort || reversePainterSortStable);
diff --git a/src-testing/src/renderers/common/RenderLists.ts b/src-testing/src/renderers/common/RenderLists.ts
index d12ad5833..c8025d380 100644
--- a/src-testing/src/renderers/common/RenderLists.ts
+++ b/src-testing/src/renderers/common/RenderLists.ts
@@ -1,21 +1,26 @@
 import ChainMap from './ChainMap.js';
 import RenderList from './RenderList.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Camera } from '../../cameras/Camera.js';
+import Lighting from './Lighting.js';
 
-const _chainKeys = [];
+const _chainKeys = [] as unknown as [Object3D, Camera];
 
 /**
  * This renderer module manages the render lists which are unique
  * per scene and camera combination.
- *
- * @private
  */
 class RenderLists {
+    lighting: Lighting;
+
+    lists: ChainMap<readonly [Object3D, Camera], RenderList>;
+
     /**
      * Constructs a render lists management component.
      *
      * @param {Lighting} lighting - The lighting management component.
      */
-    constructor(lighting) {
+    constructor(lighting: Lighting) {
         /**
          * The lighting management component.
          *
@@ -28,7 +33,7 @@ class RenderLists {
          *
          * @type {ChainMap}
          */
-        this.lists = new ChainMap();
+        this.lists = new ChainMap<readonly [Object3D, Camera], RenderList>();
     }
 
     /**
@@ -38,7 +43,7 @@ class RenderLists {
      * @param {Camera} camera - The camera.
      * @return {RenderList} The render list.
      */
-    get(scene, camera) {
+    get(scene: Object3D, camera: Camera) {
         const lists = this.lists;
 
         _chainKeys[0] = scene;
@@ -60,7 +65,7 @@ class RenderLists {
      * Frees all internal resources.
      */
     dispose() {
-        this.lists = new ChainMap();
+        this.lists = new ChainMap<readonly [Object3D, Camera], RenderList>();
     }
 }
 
diff --git a/src-testing/src/renderers/common/RenderObject.ts b/src-testing/src/renderers/common/RenderObject.ts
index 32b74ce25..fbfa523d4 100644
--- a/src-testing/src/renderers/common/RenderObject.ts
+++ b/src-testing/src/renderers/common/RenderObject.ts
@@ -1,8 +1,27 @@
 import { hash, hashString } from '../../nodes/core/NodeUtils.js';
+import ClippingContext from './ClippingContext.js';
+import { Material } from '../../materials/Material.js';
+import NodeManager from './nodes/NodeManager.js';
+import Geometries from './Geometries.js';
+import Renderer from './Renderer.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Scene } from '../../scenes/Scene.js';
+import { Camera } from '../../cameras/Camera.js';
+import { LightsNode } from '../../nodes/Nodes.js';
+import RenderContext from './RenderContext.js';
+import { BufferGeometry } from '../../core/BufferGeometry.js';
+import { BufferAttribute } from '../../core/BufferAttribute.js';
+import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
+import RenderObjectPipeline from './RenderObjectPipeline.js';
+import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
+import NodeBuilderState from './nodes/NodeBuilderState.js';
+import BindGroup from './BindGroup.js';
+import NodeMaterialObserver from '../../materials/nodes/manager/NodeMaterialObserver.js';
+import BundleGroup from './BundleGroup.js';
 
 let _id = 0;
 
-function getKeys(obj) {
+function getKeys(obj: Material) {
     const keys = Object.keys(obj);
 
     let proto = Object.getPrototypeOf(obj);
@@ -41,10 +60,53 @@ function getKeys(obj) {
  * The module provides an interface to get data required for the draw command like the actual
  * draw parameters or vertex buffers. It also holds a series of caching related methods since
  * creating render objects should only be done when necessary.
- *
- * @private
  */
 class RenderObject {
+    _nodes: NodeManager;
+    _geometries: Geometries;
+
+    id: number;
+
+    renderer: Renderer;
+    object: Object3D;
+    material: Material;
+    scene: Scene;
+    camera: Camera;
+    lightsNode: LightsNode;
+    context: RenderContext;
+
+    geometry: BufferGeometry;
+    version: number;
+
+    drawRange: { start: number; count: number } | null;
+
+    attributes: Array<BufferAttribute | InterleavedBufferAttribute> | null;
+    attributesId: { [attributeName: string]: number } | null;
+    pipeline: RenderObjectPipeline | null;
+    group: { start: number; count: number } | null;
+    vertexBuffers: Array<BufferAttribute | InterleavedBuffer> | null;
+    drawParams: { vertexCount: number; firstVertex: number; instanceCount: number; firstInstance: number } | null;
+
+    bundle: BundleGroup | null;
+
+    clippingContext: ClippingContext | null;
+
+    clippingContextCacheKey: string;
+
+    initialNodesCacheKey: number;
+    initialCacheKey: number;
+
+    _nodeBuilderState: NodeBuilderState | null;
+    _bindings: BindGroup[] | null;
+    _monitor: NodeMaterialObserver | null;
+
+    onDispose: (() => void) | null;
+
+    readonly isRenderObject: true;
+
+    onMaterialDispose: () => void;
+    onGeometryDispose: () => void;
+
     /**
      * Constructs a new render object.
      *
@@ -60,16 +122,16 @@ class RenderObject {
      * @param {ClippingContext} clippingContext - The clipping context.
      */
     constructor(
-        nodes,
-        geometries,
-        renderer,
-        object,
-        material,
-        scene,
-        camera,
-        lightsNode,
-        renderContext,
-        clippingContext,
+        nodes: NodeManager,
+        geometries: Geometries,
+        renderer: Renderer,
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+        clippingContext: ClippingContext | null,
     ) {
         this.id = _id++;
 
@@ -329,33 +391,27 @@ class RenderObject {
      *
      * @param {ClippingContext} context - The clipping context to set.
      */
-    updateClipping(context) {
+    updateClipping(context: ClippingContext) {
         this.clippingContext = context;
     }
 
     /**
      * Whether the clipping requires an update or not.
-     *
-     * @type {boolean}
-     * @readonly
      */
     get clippingNeedsUpdate() {
         if (this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey)
             return false;
 
-        this.clippingContextCacheKey = this.clippingContext.cacheKey;
+        this.clippingContextCacheKey = this.clippingContext!.cacheKey;
 
         return true;
     }
 
     /**
      * The number of clipping planes defined in context of hardware clipping.
-     *
-     * @type {number}
-     * @readonly
      */
     get hardwareClippingPlanes() {
-        return this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;
+        return this.material.hardwareClipping === true ? this.clippingContext!.unionClippingCount : 0;
     }
 
     /**
@@ -391,7 +447,7 @@ class RenderObject {
      * @param {string} name - The name of the binding group.
      * @return {?BindGroup} The bindings.
      */
-    getBindingGroup(name) {
+    getBindingGroup(name: string) {
         for (const bindingGroup of this.getBindings()) {
             if (bindingGroup.name === name) {
                 return bindingGroup;
@@ -432,7 +488,7 @@ class RenderObject {
      * @return {Array<Object>} An array with object references.
      */
     getChainArray() {
-        return [this.object, this.material, this.context, this.lightsNode];
+        return [this.object, this.material, this.context, this.lightsNode] as const;
     }
 
     /**
@@ -441,7 +497,7 @@ class RenderObject {
      *
      * @param {BufferGeometry} geometry - The geometry to set.
      */
-    setGeometry(geometry) {
+    setGeometry(geometry: BufferGeometry) {
         this.geometry = geometry;
         this.attributes = null;
         this.attributesId = null;
@@ -459,8 +515,8 @@ class RenderObject {
         const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
         const geometry = this.geometry;
 
-        const attributes = [];
-        const vertexBuffers = new Set();
+        const attributes: Array<BufferAttribute | InterleavedBufferAttribute> = [];
+        const vertexBuffers = new Set<BufferAttribute | InterleavedBuffer>();
 
         const attributesId = {};
 
@@ -711,9 +767,6 @@ class RenderObject {
 
     /**
      * Whether the geometry requires an update or not.
-     *
-     * @type {boolean}
-     * @readonly
      */
     get needsGeometryUpdate() {
         if (this.geometry.id !== this.object.geometry.id) return true;
@@ -746,9 +799,6 @@ class RenderObject {
      *
      * TODO: Investigate if it's possible to merge both steps so there is only a single place
      * that performs the 'needsUpdate' check.
-     *
-     * @type {boolean}
-     * @readonly
      */
     get needsUpdate() {
         return (
@@ -801,7 +851,7 @@ class RenderObject {
         this.material.removeEventListener('dispose', this.onMaterialDispose);
         this.geometry.removeEventListener('dispose', this.onGeometryDispose);
 
-        this.onDispose();
+        this.onDispose!();
     }
 }
 
diff --git a/src-testing/src/renderers/common/RenderObjectPipeline.ts b/src-testing/src/renderers/common/RenderObjectPipeline.ts
index b4b8edc04..07b77bbe5 100644
--- a/src-testing/src/renderers/common/RenderObjectPipeline.ts
+++ b/src-testing/src/renderers/common/RenderObjectPipeline.ts
@@ -1,12 +1,13 @@
 import Pipeline from './Pipeline.js';
+import ProgrammableStage from './ProgrammableStage.js';
 
 /**
  * Class for representing render pipelines.
- *
- * @private
- * @augments Pipeline
  */
 class RenderObjectPipeline extends Pipeline {
+    vertexProgram: ProgrammableStage;
+    fragmentProgram: ProgrammableStage;
+
     /**
      * Constructs a new render object pipeline.
      *
@@ -14,7 +15,7 @@ class RenderObjectPipeline extends Pipeline {
      * @param {ProgrammableStage} vertexProgram - The pipeline's vertex shader.
      * @param {ProgrammableStage} fragmentProgram - The pipeline's fragment shader.
      */
-    constructor(cacheKey, vertexProgram, fragmentProgram) {
+    constructor(cacheKey: string, vertexProgram: ProgrammableStage, fragmentProgram: ProgrammableStage) {
         super(cacheKey);
 
         /**
diff --git a/src-testing/src/renderers/common/RenderObjects.ts b/src-testing/src/renderers/common/RenderObjects.ts
index 985fee476..4b68c4443 100644
--- a/src-testing/src/renderers/common/RenderObjects.ts
+++ b/src-testing/src/renderers/common/RenderObjects.ts
@@ -1,14 +1,34 @@
 import ChainMap from './ChainMap.js';
 import RenderObject from './RenderObject.js';
-
-const _chainKeys = [];
+import Renderer from './Renderer.js';
+import NodeManager from './nodes/NodeManager.js';
+import Geometries from './Geometries.js';
+import Pipelines from './Pipelines.js';
+import Bindings from './Bindings.js';
+import Info from './Info.js';
+import LightsNode from '../../nodes/lighting/LightsNode.js';
+import RenderContext from './RenderContext.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Material } from '../../materials/Material.js';
+import { Scene } from '../../scenes/Scene.js';
+import { Camera } from '../../cameras/Camera.js';
+import ClippingContext from './ClippingContext.js';
+
+const _chainKeys = [] as unknown as [Object3D, Material, RenderContext, LightsNode];
 
 /**
  * This module manages the render objects of the renderer.
- *
- * @private
  */
 class RenderObjects {
+    renderer: Renderer;
+    nodes: NodeManager;
+    geometries: Geometries;
+    pipelines: Pipelines;
+    bindings: Bindings;
+    info: Info;
+
+    chainMaps: { [passId: string]: ChainMap<readonly [Object3D, Material, RenderContext, LightsNode], RenderObject> };
+
     /**
      * Constructs a new render object management component.
      *
@@ -19,7 +39,14 @@ class RenderObjects {
      * @param {Bindings} bindings - Renderer component for managing bindings.
      * @param {Info} info - Renderer component for managing metrics and monitoring data.
      */
-    constructor(renderer, nodes, geometries, pipelines, bindings, info) {
+    constructor(
+        renderer: Renderer,
+        nodes: NodeManager,
+        geometries: Geometries,
+        pipelines: Pipelines,
+        bindings: Bindings,
+        info: Info,
+    ) {
         /**
          * The renderer.
          *
@@ -84,7 +111,16 @@ class RenderObjects {
      * @param {string} [passId] - An optional ID for identifying the pass.
      * @return {RenderObject} The render object.
      */
-    get(object, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {
+    get(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+        clippingContext: ClippingContext | null,
+        passId?: string,
+    ): RenderObject {
         const chainMap = this.getChainMap(passId);
 
         // set chain keys
@@ -121,7 +157,7 @@ class RenderObjects {
 
             //
 
-            renderObject.updateClipping(clippingContext);
+            renderObject.updateClipping(clippingContext!);
 
             if (renderObject.needsGeometryUpdate) {
                 renderObject.setGeometry(object.geometry);
@@ -166,7 +202,13 @@ class RenderObjects {
      * @return {ChainMap} The chain map.
      */
     getChainMap(passId = 'default') {
-        return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());
+        return (
+            this.chainMaps[passId] ||
+            (this.chainMaps[passId] = new ChainMap<
+                readonly [Object3D, Material, RenderContext, LightsNode],
+                RenderObject
+            >())
+        );
     }
 
     /**
@@ -193,17 +235,17 @@ class RenderObjects {
      * @return {RenderObject} The render object.
      */
     createRenderObject(
-        nodes,
-        geometries,
-        renderer,
-        object,
-        material,
-        scene,
-        camera,
-        lightsNode,
-        renderContext,
-        clippingContext,
-        passId,
+        nodes: NodeManager,
+        geometries: Geometries,
+        renderer: Renderer,
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+        clippingContext: ClippingContext | null,
+        passId: string | undefined,
     ) {
         const chainMap = this.getChainMap(passId);
 
diff --git a/src-testing/src/renderers/common/RenderPipeline.ts b/src-testing/src/renderers/common/RenderPipeline.ts
index 5e6575e85..96ef81775 100644
--- a/src-testing/src/renderers/common/RenderPipeline.ts
+++ b/src-testing/src/renderers/common/RenderPipeline.ts
@@ -1,5 +1,5 @@
-import { Node } from "../../nodes/Nodes.js";
-import Renderer from "./Renderer.js";
+import { Node } from '../../nodes/Nodes.js';
+import Renderer from './Renderer.js';
 
 declare class RenderPipeline {
     renderer: Renderer;
diff --git a/src-testing/src/renderers/common/Renderer.ts b/src-testing/src/renderers/common/Renderer.ts
index e260c451c..4abc3aea4 100644
--- a/src-testing/src/renderers/common/Renderer.ts
+++ b/src-testing/src/renderers/common/Renderer.ts
@@ -28,6 +28,7 @@ import { Frustum } from '../../math/Frustum.js';
 import { FrustumArray } from '../../math/FrustumArray.js';
 import { Matrix4 } from '../../math/Matrix4.js';
 import { Vector2 } from '../../math/Vector2.js';
+import { Vector3 } from '../../math/Vector3.js';
 import { Vector4 } from '../../math/Vector4.js';
 import { RenderTarget } from '../../core/RenderTarget.js';
 import {
@@ -41,13 +42,44 @@ import {
     RGBAFormat,
     PCFShadowMap,
     VSMShadowMap,
+    ToneMapping,
+    ShadowMapType,
+    TimestampQuery,
+    TextureDataType,
 } from '../../constants.js';
+import Backend from './Backend.js';
+import RenderContext from './RenderContext.js';
+import RenderList, { Bundle, RenderItem } from './RenderList.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Camera } from '../../cameras/Camera.js';
+import { BufferGeometry, GeometryGroup } from '../../core/BufferGeometry.js';
+import { Material } from '../../materials/Material.js';
+import RenderBundle from './RenderBundle.js';
+import { Light } from '../../lights/Light.js';
+import { BufferAttribute } from '../../core/BufferAttribute.js';
+import { Texture } from '../../textures/Texture.js';
+import { FramebufferTexture } from '../../textures/FramebufferTexture.js';
+import { Box2 } from '../../math/Box2.js';
+import { Box3 } from '../../math/Box3.js';
+import { ColorRepresentation } from '../../math/Color.js';
+import { Group } from '../../objects/Group.js';
+import { LOD } from '../../objects/LOD.js';
+import { Sprite } from '../../objects/Sprite.js';
+import { LineLoop } from '../../objects/LineLoop.js';
+import { Mesh } from '../../objects/Mesh.js';
+import { Line } from '../../objects/Line.js';
+import { Points } from '../../objects/Points.js';
+import MRTNode from '../../nodes/core/MRTNode.js';
+import LightsNode from '../../nodes/lighting/LightsNode.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import { ArrayCamera } from '../../cameras/ArrayCamera.js';
 
 import { float, vec3, vec4, Fn } from '../../nodes/tsl/TSLCore.js';
 import { reference } from '../../nodes/accessors/ReferenceNode.js';
 import { highpModelNormalViewMatrix, highpModelViewMatrix } from '../../nodes/accessors/ModelNode.js';
 import { context } from '../../nodes/core/ContextNode.js';
 import { error, warn, warnOnce } from '../../utils.js';
+import IndirectStorageBufferAttribute from './IndirectStorageBufferAttribute.js';
 
 const _scene = /*@__PURE__*/ new Scene();
 const _drawingBufferSize = /*@__PURE__*/ new Vector2();
@@ -60,26 +92,179 @@ const _vector4 = /*@__PURE__*/ new Vector4();
 
 const _shadowSide = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide };
 
+interface Rectangle {
+    x: number;
+    y: number;
+    z: number;
+    w: number;
+}
+
+interface DeviceLostInfo {
+    api: 'WebGL' | 'WebGPU';
+    message: string;
+    reason: string | null;
+    originalEvent: unknown;
+}
+
+export interface RendererParameters {
+    logarithmicDepthBuffer?: boolean | undefined;
+    alpha?: boolean | undefined;
+    depth?: boolean | undefined;
+    stencil?: boolean | undefined;
+    antialias?: boolean | undefined;
+    samples?: number | undefined;
+    getFallback?: ((error: unknown) => Backend) | null | undefined;
+    outputBufferType?: TextureDataType | undefined;
+    multiview?: boolean | undefined;
+}
+
 /**
  * Base class for renderers.
  */
 class Renderer {
-    /**
-     * Renderer options.
-     *
-     * @typedef {Object} Renderer~Options
-     * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
-     * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
-     * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
-     * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
-     * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
-     * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0
-     * to overwrite the default.
-     * @property {?Function} [getFallback=null] - This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.
-     * @property {number} [outputBufferType=HalfFloatType] - Defines the type of output buffers. The default `HalfFloatType` is recommend for best
-     * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.
-     * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.
-     */
+    readonly isRenderer: true;
+
+    backend: Backend;
+
+    autoClear: boolean;
+    autoClearColor: boolean;
+    autoClearDepth: boolean;
+    autoClearStencil: boolean;
+
+    alpha: boolean;
+
+    logarithmicDepthBuffer: boolean;
+
+    outputColorSpace: string;
+
+    toneMapping: ToneMapping;
+    toneMappingExposure: number;
+
+    sortObjects: boolean;
+
+    depth: boolean;
+    stencil: boolean;
+
+    info: Info;
+
+    library: NodeLibrary;
+    lighting: Lighting;
+
+    _samples: number;
+
+    _canvasTarget: CanvasTarget;
+
+    _inspector: InspectorBase;
+
+    _getFallback: ((error: unknown) => Backend) | null;
+
+    _attributes: Attributes | null;
+    _geometries: Geometries | null;
+    _nodes: NodeManager | null;
+    _animation: Animation | null;
+    _bindings: Bindings | null;
+    _objects: RenderObjects | null;
+    _pipelines: Pipelines | null;
+    _bundles: RenderBundles | null;
+    _renderLists: RenderLists | null;
+    _renderContexts: RenderContexts | null;
+    _textures: Textures | null;
+    _background: Background | null;
+
+    _quad: QuadMesh;
+
+    _currentRenderContext: RenderContext | null;
+
+    _opaqueSort: ((a: RenderItem, b: RenderItem) => number) | null;
+    _transparentSort: ((a: RenderItem, b: RenderItem) => number) | null;
+
+    _frameBufferTarget: RenderTarget | null;
+
+    _clearColor: Color4;
+    _clearDepth: number;
+    _clearStencil: number;
+
+    _renderTarget: RenderTarget | null;
+    _activeCubeFace: number;
+    _activeMipmapLevel: number;
+    _outputRenderTarget: RenderTarget | null;
+
+    _mrt: MRTNode | null;
+
+    _renderObjectFunction:
+        | ((
+              object: Object3D,
+              scene: Scene,
+              camera: Camera,
+              geometry: BufferGeometry,
+              material: Material,
+              group: GeometryGroup,
+              lightsNode: LightsNode,
+              clippingContext: ClippingContext | null,
+              passId: string | null,
+          ) => void)
+        | null;
+    _currentRenderObjectFunction:
+        | ((
+              object: Object3D,
+              scene: Scene,
+              camera: Camera,
+              geometry: BufferGeometry,
+              material: Material,
+              group: GeometryGroup,
+              lightsNode: LightsNode,
+              clippingContext: ClippingContext | null,
+              passId: string | null,
+          ) => void)
+        | null;
+    _currentRenderBundle: RenderBundle | null;
+
+    _handleObjectFunction: (
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: GeometryGroup,
+        clippingContext: ClippingContext | null,
+        passId?: string,
+    ) => void;
+
+    _isDeviceLost: boolean;
+    onDeviceLost: (info: DeviceLostInfo) => void;
+
+    _outputBufferType: TextureDataType;
+
+    _initialized: boolean;
+    _initPromise: Promise<this> | null;
+
+    _compilationPromises: Promise<void>[] | null;
+
+    transparent: boolean;
+    opaque: boolean;
+
+    shadowMap: { enabled: boolean; transmitted: boolean; type: ShadowMapType | null };
+
+    xr: XRManager;
+
+    debug: {
+        checkShaderErrors: boolean;
+        onShaderError:
+            | ((
+                  gl: WebGL2RenderingContext,
+                  programGPU: WebGLProgram,
+                  glVertexShader: WebGLShader,
+                  glFragmentShader: WebGLShader,
+              ) => void)
+            | null;
+        getShaderAsync: (
+            scene: Scene,
+            camera: Camera,
+            object: Object3D,
+        ) => Promise<{ fragmentShader: string | null; vertexShader: string | null }>;
+    };
+
+    localClippingEnabled?: boolean | undefined;
 
     /**
 	 * Constructs a new renderer.
@@ -88,7 +273,7 @@ class Renderer {
 	 * @param {Renderer~Options} [parameters] - The configuration parameter.
 
 	 */
-    constructor(backend, parameters = {}) {
+    constructor(backend: Backend, parameters: RendererParameters = {}) {
         /**
          * This flag can be used for type testing.
          *
@@ -716,12 +901,12 @@ class Renderer {
             getShaderAsync: async (scene, camera, object) => {
                 await this.compileAsync(scene, camera);
 
-                const renderList = this._renderLists.get(scene, camera);
-                const renderContext = this._renderContexts.get(this._renderTarget, this._mrt);
+                const renderList = this._renderLists!.get(scene, camera);
+                const renderContext = this._renderContexts!.get(this._renderTarget, this._mrt);
 
-                const material = scene.overrideMaterial || object.material;
+                const material = scene.overrideMaterial || (object as Mesh<BufferGeometry, Material>).material;
 
-                const renderObject = this._objects.get(
+                const renderObject = this._objects!.get(
                     object,
                     material,
                     scene,
@@ -749,7 +934,7 @@ class Renderer {
             return this._initPromise;
         }
 
-        this._initPromise = new Promise(async (resolve, reject) => {
+        this._initPromise = new Promise<this>(async (resolve, reject) => {
             let backend = this.backend;
 
             try {
@@ -819,8 +1004,6 @@ class Renderer {
      * A reference to the canvas element the renderer is drawing to.
      * This value of this property will automatically be created by
      * the renderer.
-     *
-     * @type {HTMLCanvasElement|OffscreenCanvas}
      */
     get domElement() {
         return this._canvasTarget.domElement;
@@ -830,9 +1013,6 @@ class Renderer {
      * The coordinate system of the renderer. The value of this property
      * depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or
      * `THREE.WebGPUCoordinateSystem`.
-     *
-     * @readonly
-     * @type {number}
      */
     get coordinateSystem() {
         return this.backend.coordinateSystem;
@@ -853,14 +1033,14 @@ class Renderer {
      * @param {?Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
      * @return {Promise} A Promise that resolves when the compile has been finished.
      */
-    async compileAsync(scene, camera, targetScene = null) {
+    async compileAsync(scene: Object3D, camera: Camera, targetScene: Scene | null = null) {
         if (this._isDeviceLost === true) return;
 
         if (this._initialized === false) await this.init();
 
         // preserve render tree
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
         const previousRenderContext = this._currentRenderContext;
@@ -870,15 +1050,15 @@ class Renderer {
 
         //
 
-        const sceneRef = scene.isScene === true ? scene : _scene;
+        const sceneRef = (scene as Scene).isScene === true ? (scene as Scene) : _scene;
 
         if (targetScene === null) targetScene = scene;
 
         const renderTarget = this._renderTarget;
-        const renderContext = this._renderContexts.get(renderTarget, this._mrt);
+        const renderContext = this._renderContexts!.get(renderTarget, this._mrt);
         const activeMipmapLevel = this._activeMipmapLevel;
 
-        const compilationPromises = [];
+        const compilationPromises: Promise<void>[] = [];
 
         this._currentRenderContext = renderContext;
         this._currentRenderObjectFunction = this.renderObject;
@@ -907,7 +1087,7 @@ class Renderer {
 
         //
 
-        const renderList = this._renderLists.get(scene, camera);
+        const renderList = this._renderLists!.get(scene, camera);
         renderList.begin();
 
         this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);
@@ -915,8 +1095,8 @@ class Renderer {
         // include lights from target scene
         if (targetScene !== scene) {
             targetScene.traverseVisible(function (object) {
-                if (object.isLight && object.layers.test(camera.layers)) {
-                    renderList.pushLight(object);
+                if ((object as Light).isLight && object.layers.test(camera.layers)) {
+                    renderList.pushLight(object as Light);
                 }
             });
         }
@@ -926,12 +1106,12 @@ class Renderer {
         //
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
+            this._textures!.updateRenderTarget(renderTarget, activeMipmapLevel);
 
-            const renderTargetData = this._textures.get(renderTarget);
+            const renderTargetData = this._textures!.get(renderTarget);
 
-            renderContext.textures = renderTargetData.textures;
-            renderContext.depthTexture = renderTargetData.depthTexture;
+            renderContext.textures = renderTargetData.textures!;
+            renderContext.depthTexture = renderTargetData.depthTexture!;
         } else {
             renderContext.textures = null;
             renderContext.depthTexture = null;
@@ -940,9 +1120,9 @@ class Renderer {
         //
 
         if (targetScene !== scene) {
-            this._background.update(targetScene, renderList, renderContext);
+            this._background!.update(targetScene, renderList, renderContext);
         } else {
-            this._background.update(sceneRef, renderList, renderContext);
+            this._background!.update(sceneRef, renderList, renderContext);
         }
 
         // process render lists
@@ -980,7 +1160,7 @@ class Renderer {
      * @param {Camera} camera - The camera.
      * @return {Promise} A Promise that resolves when the render has been finished.
      */
-    async renderAsync(scene, camera) {
+    async renderAsync(scene: Object3D, camera: Camera) {
         warnOnce(
             'Renderer: "renderAsync()" has been deprecated. Use "render()" and "await renderer.init();" when creating the renderer.',
         ); // @deprecated r181
@@ -1006,7 +1186,7 @@ class Renderer {
 
     //
 
-    set inspector(value) {
+    set inspector(value: InspectorBase) {
         if (this._inspector !== null) {
             this._inspector.setRenderer(null);
         }
@@ -1017,8 +1197,6 @@ class Renderer {
 
     /**
      * The inspector instance. The inspector can be any class that extends from `InspectorBase`.
-     *
-     * @type {InspectorBase}
      */
     get inspector() {
         return this._inspector;
@@ -1031,11 +1209,9 @@ class Renderer {
      * NOTE: 64-bit precision is not compatible with `InstancedMesh` and `SkinnedMesh`.
      *
      * @param {boolean} value - Whether to enable or disable high precision.
-     * @type {boolean}
      */
-    set highPrecision(value) {
+    set highPrecision(value: boolean) {
         const contextNodeData = this.contextNode.value;
-
         if (value === true) {
             contextNodeData.modelViewMatrix = highpModelViewMatrix;
             contextNodeData.modelNormalViewMatrix = highpModelNormalViewMatrix;
@@ -1049,7 +1225,6 @@ class Renderer {
      * Returns whether high precision is enabled or not.
      *
      * @return {boolean} Whether high precision is enabled or not.
-     * @type {boolean}
      */
     get highPrecision() {
         const contextNodeData = this.contextNode.value;
@@ -1066,7 +1241,7 @@ class Renderer {
      * @param {MRTNode} mrt - The MRT node to set.
      * @return {Renderer} A reference to this renderer.
      */
-    setMRT(mrt) {
+    setMRT(mrt: MRTNode | null) {
         this._mrt = mrt;
 
         return this;
@@ -1107,10 +1282,9 @@ class Renderer {
     /**
      * Default implementation of the device lost callback.
      *
-     * @private
      * @param {Object} info - Information about the context lost.
      */
-    _onDeviceLost(info) {
+    private _onDeviceLost(info: DeviceLostInfo) {
         let errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\n\nMessage: ${info.message}`;
 
         if (info.reason) {
@@ -1125,19 +1299,18 @@ class Renderer {
     /**
      * Renders the given render bundle.
      *
-     * @private
      * @param {Object} bundle - Render bundle data.
      * @param {Scene} sceneRef - The scene the render bundle belongs to.
      * @param {LightsNode} lightsNode - The lights node.
      */
-    _renderBundle(bundle, sceneRef, lightsNode) {
+    private _renderBundle(bundle: Bundle, sceneRef: Scene, lightsNode: LightsNode) {
         const { bundleGroup, camera, renderList } = bundle;
 
-        const renderContext = this._currentRenderContext;
+        const renderContext = this._currentRenderContext!;
 
         //
 
-        const renderBundle = this._bundles.get(bundleGroup, camera);
+        const renderBundle = this._bundles!.get(bundleGroup, camera);
         const renderBundleData = this.backend.get(renderBundle);
 
         if (renderBundleData.renderContexts === undefined) renderBundleData.renderContexts = new Set();
@@ -1188,13 +1361,13 @@ class Renderer {
             for (let i = 0, l = renderObjects.length; i < l; i++) {
                 const renderObject = renderObjects[i];
 
-                if (this._nodes.needsRefresh(renderObject)) {
-                    this._nodes.updateBefore(renderObject);
+                if (this._nodes!.needsRefresh(renderObject)) {
+                    this._nodes!.updateBefore(renderObject);
 
-                    this._nodes.updateForRender(renderObject);
-                    this._bindings.updateForRender(renderObject);
+                    this._nodes!.updateForRender(renderObject);
+                    this._bindings!.updateForRender(renderObject);
 
-                    this._nodes.updateAfter(renderObject);
+                    this._nodes!.updateAfter(renderObject);
                 }
             }
         }
@@ -1217,7 +1390,7 @@ class Renderer {
      * @param {Object3D} scene - The scene or 3D object to render.
      * @param {Camera} camera - The camera to render the scene with.
      */
-    render(scene, camera) {
+    render(scene: Object3D, camera: Camera) {
         if (this._initialized === false) {
             throw new Error(
                 'Renderer: .render() called before the backend is initialized. Use "await renderer.init();" before rendering.',
@@ -1230,7 +1403,6 @@ class Renderer {
     /**
      * Returns whether the renderer has been initialized or not.
      *
-     * @readonly
      * @return {boolean} Whether the renderer has been initialized or not.
      */
     get initialized() {
@@ -1242,10 +1414,9 @@ class Renderer {
      * and color space conversion. Unlike in `WebGLRenderer`, this is done in a separate render
      * pass and not inline to achieve more correct results.
      *
-     * @private
      * @return {?RenderTarget} The render target. The method returns `null` if no output conversion should be applied.
      */
-    _getFrameBufferTarget() {
+    private _getFrameBufferTarget() {
         const { currentToneMapping, currentColorSpace } = this;
 
         const useToneMapping = currentToneMapping !== NoToneMapping;
@@ -1305,13 +1476,12 @@ class Renderer {
     /**
      * Renders the scene or 3D object with the given camera.
      *
-     * @private
      * @param {Object3D} scene - The scene or 3D object to render.
      * @param {Camera} camera - The camera to render the scene with.
      * @param {boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.
      * @return {RenderContext} The current render context.
      */
-    _renderScene(scene, camera, useFrameBufferTarget = true) {
+    private _renderScene(scene: Object3D, camera: Camera, useFrameBufferTarget = true) {
         if (this._isDeviceLost === true) return;
 
         //
@@ -1320,7 +1490,7 @@ class Renderer {
 
         // preserve render tree
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
         const previousRenderContext = this._currentRenderContext;
@@ -1352,7 +1522,7 @@ class Renderer {
 
         //
 
-        const renderContext = this._renderContexts.get(renderTarget, this._mrt, this._callDepth);
+        const renderContext = this._renderContexts!.get(renderTarget, this._mrt, this._callDepth);
 
         this._currentRenderContext = renderContext;
         this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;
@@ -1449,7 +1619,7 @@ class Renderer {
             frustum.setFromProjectionMatrix(_projScreenMatrix, camera.coordinateSystem, camera.reversedDepth);
         }
 
-        const renderList = this._renderLists.get(scene, camera);
+        const renderList = this._renderLists!.get(scene, camera);
         renderList.begin();
 
         this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);
@@ -1463,14 +1633,14 @@ class Renderer {
         //
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
+            this._textures!.updateRenderTarget(renderTarget, activeMipmapLevel);
 
-            const renderTargetData = this._textures.get(renderTarget);
+            const renderTargetData = this._textures!.get(renderTarget);
 
-            renderContext.textures = renderTargetData.textures;
-            renderContext.depthTexture = renderTargetData.depthTexture;
-            renderContext.width = renderTargetData.width;
-            renderContext.height = renderTargetData.height;
+            renderContext.textures = renderTargetData.textures!;
+            renderContext.depthTexture = renderTargetData.depthTexture!;
+            renderContext.width = renderTargetData.width!;
+            renderContext.height = renderTargetData.height!;
             renderContext.renderTarget = renderTarget;
             renderContext.depth = renderTarget.depthBuffer;
             renderContext.stencil = renderTarget.stencilBuffer;
@@ -1503,7 +1673,7 @@ class Renderer {
 
         //
 
-        this._background.update(sceneRef, renderList, renderContext);
+        this._background!.update(sceneRef, renderList, renderContext);
 
         //
 
@@ -1561,7 +1731,7 @@ class Renderer {
         return renderContext;
     }
 
-    _setXRLayerSize(width, height) {
+    _setXRLayerSize(width: number, height: number) {
         // TODO: Find a better solution to resize the canvas when in XR.
 
         this._canvasTarget._width = width;
@@ -1573,14 +1743,13 @@ class Renderer {
     /**
      * The output pass performs tone mapping and color space conversion.
      *
-     * @private
      * @param {RenderTarget} renderTarget - The current render target.
      */
-    _renderOutput(renderTarget) {
+    private _renderOutput(renderTarget: RenderTarget) {
         const quad = this._quad;
 
-        if (this._nodes.hasOutputChange(renderTarget.texture)) {
-            quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);
+        if (this._nodes!.hasOutputChange(renderTarget!.texture)) {
+            quad.material.fragmentNode = this._nodes!.getOutputNode(renderTarget!.texture);
             quad.material.needsUpdate = true;
         }
 
@@ -1634,10 +1803,10 @@ class Renderer {
      * @param {?onAnimationCallback} callback - The application's animation loop.
      * @return {Promise} A Promise that resolves when the set has been executed.
      */
-    async setAnimationLoop(callback) {
+    async setAnimationLoop(callback: ((time: DOMHighResTimeStamp, frame?: XRFrame) => void) | null) {
         if (this._initialized === false) await this.init();
 
-        this._animation.setAnimationLoop(callback);
+        this._animation!.setAnimationLoop(callback);
     }
 
     /**
@@ -1657,7 +1826,7 @@ class Renderer {
      * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
      * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
      */
-    async getArrayBufferAsync(attribute) {
+    async getArrayBufferAsync(attribute: BufferAttribute) {
         return await this.backend.getArrayBufferAsync(attribute);
     }
 
@@ -1685,7 +1854,7 @@ class Renderer {
      * @param {Vector2} target - The method writes the result in this target object.
      * @return {Vector2} The drawing buffer size.
      */
-    getDrawingBufferSize(target) {
+    getDrawingBufferSize(target: Vector2) {
         return this._canvasTarget.getDrawingBufferSize(target);
     }
 
@@ -1695,7 +1864,7 @@ class Renderer {
      * @param {Vector2} target - The method writes the result in this target object.
      * @return {Vector2} The renderer's size in logical pixels.
      */
-    getSize(target) {
+    getSize(target: Vector2) {
         return this._canvasTarget.getSize(target);
     }
 
@@ -1721,7 +1890,7 @@ class Renderer {
      * @param {number} height - The height in logical pixels.
      * @param {number} pixelRatio - The pixel ratio.
      */
-    setDrawingBufferSize(width, height, pixelRatio) {
+    setDrawingBufferSize(width: number, height: number, pixelRatio: number) {
         // Renderer can't be resized while presenting in XR.
         if (this.xr && this.xr.isPresenting) return;
 
@@ -1735,7 +1904,7 @@ class Renderer {
      * @param {number} height - The height in logical pixels.
      * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
      */
-    setSize(width, height, updateStyle = true) {
+    setSize(width: number, height: number, updateStyle = true) {
         // Renderer can't be resized while presenting in XR.
         if (this.xr && this.xr.isPresenting) return;
 
@@ -1748,7 +1917,7 @@ class Renderer {
      *
      * @param {Function} method - The sort function.
      */
-    setOpaqueSort(method) {
+    setOpaqueSort(method: ((a: RenderItem, b: RenderItem) => number) | null) {
         this._opaqueSort = method;
     }
 
@@ -1758,7 +1927,7 @@ class Renderer {
      *
      * @param {Function} method - The sort function.
      */
-    setTransparentSort(method) {
+    setTransparentSort(method: ((a: RenderItem, b: RenderItem) => number) | null) {
         this._transparentSort = method;
     }
 
@@ -1768,7 +1937,7 @@ class Renderer {
      * @param {Vector4} target - The method writes the result in this target object.
      * @return {Vector4} The scissor rectangle.
      */
-    getScissor(target) {
+    getScissor(target: Vector4) {
         return this._canvasTarget.getScissor(target);
     }
 
@@ -1781,8 +1950,10 @@ class Renderer {
      * @param {number} width - The width of the scissor box in logical pixel unit.
      * @param {number} height - The height of the scissor box in logical pixel unit.
      */
-    setScissor(x, y, width, height) {
-        this._canvasTarget.setScissor(x, y, width, height);
+    setScissor(x: Vector4): void;
+    setScissor(x: number, y: number, width: number, height: number): void;
+    setScissor(x: Vector4 | number, y?: number, width?: number, height?: number) {
+        this._canvasTarget.setScissor(x as number, y!, width!, height!);
     }
 
     /**
@@ -1799,7 +1970,7 @@ class Renderer {
      *
      * @param {boolean} boolean - Whether the scissor test should be enabled or not.
      */
-    setScissorTest(boolean) {
+    setScissorTest(boolean: boolean) {
         this._canvasTarget.setScissorTest(boolean);
 
         // TODO: Move it to CanvasTarget event listener.
@@ -1813,7 +1984,7 @@ class Renderer {
      * @param {Vector4} target - The method writes the result in this target object.
      * @return {Vector4} The viewport definition.
      */
-    getViewport(target) {
+    getViewport(target: Vector4) {
         return this._canvasTarget.getViewport(target);
     }
 
@@ -1827,8 +1998,10 @@ class Renderer {
      * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.
      * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.
      */
-    setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {
-        this._canvasTarget.setViewport(x, y, width, height, minDepth, maxDepth);
+    setViewport(x: Vector4): void;
+    setViewport(x: number, y: number, width: number, height: number, minDepth?: number, maxDepth?: number): void;
+    setViewport(x: Vector4 | number, y?: number, width?: number, height?: number, minDepth = 0, maxDepth = 1) {
+        this._canvasTarget.setViewport(x as number, y!, width!, height!, minDepth, maxDepth);
     }
 
     /**
@@ -1837,7 +2010,7 @@ class Renderer {
      * @param {Color} target - The method writes the result in this target object.
      * @return {Color} The clear color.
      */
-    getClearColor(target) {
+    getClearColor(target: Color4) {
         return target.copy(this._clearColor);
     }
 
@@ -1847,7 +2020,7 @@ class Renderer {
      * @param {Color} color - The clear color.
      * @param {number} [alpha=1] - The clear alpha.
      */
-    setClearColor(color, alpha = 1) {
+    setClearColor(color: ColorRepresentation, alpha = 1) {
         this._clearColor.set(color);
         this._clearColor.a = alpha;
     }
@@ -1866,7 +2039,7 @@ class Renderer {
      *
      * @param {number} alpha - The clear alpha.
      */
-    setClearAlpha(alpha) {
+    setClearAlpha(alpha: number) {
         this._clearColor.a = alpha;
     }
 
@@ -1884,7 +2057,7 @@ class Renderer {
      *
      * @param {number} depth - The clear depth.
      */
-    setClearDepth(depth) {
+    setClearDepth(depth: number) {
         this._clearDepth = depth;
     }
 
@@ -1902,7 +2075,7 @@ class Renderer {
      *
      * @param {number} stencil - The clear stencil.
      */
-    setClearStencil(stencil) {
+    setClearStencil(stencil: number) {
         this._clearStencil = stencil;
     }
 
@@ -1914,7 +2087,7 @@ class Renderer {
      * @param {Object3D} object - The 3D object to test.
      * @return {boolean} Whether the 3D object is fully occluded or not.
      */
-    isOccluded(object) {
+    isOccluded(object: Object3D) {
         const renderContext = this._currentRenderContext;
 
         return renderContext && this.backend.isOccluded(renderContext, object);
@@ -1939,9 +2112,9 @@ class Renderer {
         let renderContext = null;
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget);
+            this._textures!.updateRenderTarget(renderTarget);
 
-            const renderTargetData = this._textures.get(renderTarget);
+            const renderTargetData = this._textures!.get(renderTarget);
 
             renderContext = this._renderContexts.get(renderTarget);
             renderContext.textures = renderTargetData.textures;
@@ -2069,7 +2242,6 @@ class Renderer {
     /**
      * The number of samples used for multi-sample anti-aliasing (MSAA).
      *
-     * @type {number}
      * @default 0
      */
     get samples() {
@@ -2082,8 +2254,6 @@ class Renderer {
      * When rendering to a custom render target, the number of samples of that render target is used.
      * If the renderer needs an internal framebuffer target for tone mapping or color space conversion,
      * the number of samples is set to 0.
-     *
-     * @type {number}
      */
     get currentSamples() {
         let samples = this._samples;
@@ -2100,8 +2270,6 @@ class Renderer {
     /**
      * The current tone mapping of the renderer. When not producing screen output,
      * the tone mapping is always `NoToneMapping`.
-     *
-     * @type {number}
      */
     get currentToneMapping() {
         return this.isOutputTarget ? this.toneMapping : NoToneMapping;
@@ -2110,8 +2278,6 @@ class Renderer {
     /**
      * The current color space of the renderer. When not producing screen output,
      * the color space is always the working color space.
-     *
-     * @type {string}
      */
     get currentColorSpace() {
         return this.isOutputTarget ? this.outputColorSpace : ColorManagement.workingColorSpace;
@@ -2135,15 +2301,15 @@ class Renderer {
             this.info.dispose();
             this.backend.dispose();
 
-            this._animation.dispose();
-            this._objects.dispose();
+            this._animation!.dispose();
+            this._objects!.dispose();
             this._geometries.dispose();
-            this._pipelines.dispose();
-            this._nodes.dispose();
-            this._bindings.dispose();
-            this._renderLists.dispose();
-            this._renderContexts.dispose();
-            this._textures.dispose();
+            this._pipelines!.dispose();
+            this._nodes!.dispose();
+            this._bindings!.dispose();
+            this._renderLists!.dispose();
+            this._renderContexts!.dispose();
+            this._textures!.dispose();
 
             if (this._frameBufferTarget !== null) this._frameBufferTarget.dispose();
 
@@ -2165,7 +2331,7 @@ class Renderer {
      * @param {number} [activeCubeFace=0] - The active cube face.
      * @param {number} [activeMipmapLevel=0] - The active mipmap level.
      */
-    setRenderTarget(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
+    setRenderTarget(renderTarget: RenderTarget | null, activeCubeFace = 0, activeMipmapLevel = 0) {
         this._renderTarget = renderTarget;
         this._activeCubeFace = activeCubeFace;
         this._activeMipmapLevel = activeMipmapLevel;
@@ -2185,7 +2351,7 @@ class Renderer {
      *
      * @param {Object} renderTarget - The render target to set as the output target.
      */
-    setOutputRenderTarget(renderTarget) {
+    setOutputRenderTarget(renderTarget: RenderTarget | null) {
         this._outputRenderTarget = renderTarget;
     }
 
@@ -2204,7 +2370,7 @@ class Renderer {
      *
      * @param {CanvasTarget} canvasTarget - The canvas target.
      */
-    setCanvasTarget(canvasTarget) {
+    setCanvasTarget(canvasTarget: CanvasTarget) {
         this._canvasTarget.removeEventListener('resize', this._onCanvasTargetResize);
 
         this._canvasTarget = canvasTarget;
@@ -2222,10 +2388,8 @@ class Renderer {
 
     /**
      * Resets the renderer to the initial state before WebXR started.
-     *
-     * @private
      */
-    _resetXRState() {
+    private _resetXRState() {
         this.backend.setXRTarget(null);
         this.setOutputRenderTarget(null);
         this.setRenderTarget(null);
@@ -2234,21 +2398,6 @@ class Renderer {
         this._frameBufferTarget = null;
     }
 
-    /**
-     * Callback for {@link Renderer#setRenderObjectFunction}.
-     *
-     * @callback renderObjectFunction
-     * @param {Object3D} object - The 3D object.
-     * @param {Scene} scene - The scene the 3D object belongs to.
-     * @param {Camera} camera - The camera the object should be rendered with.
-     * @param {BufferGeometry} geometry - The object's geometry.
-     * @param {Material} material - The object's material.
-     * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
-     * @param {LightsNode} lightsNode - The current lights node.
-     * @param {ClippingContext} clippingContext - The clipping context.
-     * @param {?string} [passId=null] - An optional ID for identifying the pass.
-     */
-
     /**
      * Sets the given render object function. Calling this method overwrites the default implementation
      * which is {@link Renderer#renderObject}. Defining a custom function can be useful
@@ -2260,7 +2409,19 @@ class Renderer {
      *
      * @param {?renderObjectFunction} renderObjectFunction - The render object function.
      */
-    setRenderObjectFunction(renderObjectFunction) {
+    setRenderObjectFunction(
+        renderObjectFunction:
+            | ((
+                  object: Object3D,
+                  scene: Scene,
+                  camera: Camera,
+                  geometry: BufferGeometry,
+                  material: Material,
+                  group: GeometryGroup,
+                  lightsNode: LightsNode,
+              ) => void)
+            | null,
+    ) {
         this._renderObjectFunction = renderObjectFunction;
     }
 
@@ -2284,7 +2445,10 @@ class Renderer {
      * - A IndirectStorageBufferAttribute for indirect dispatch size.
      * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
      */
-    compute(computeNodes, dispatchSize = null) {
+    compute(
+        computeNodes: ComputeNode | ComputeNode[],
+        dispatchSize: number[] | number | IndirectStorageBufferAttribute | null = null,
+    ) {
         if (this._isDeviceLost === true) return;
 
         if (this._initialized === false) {
@@ -2295,7 +2459,7 @@ class Renderer {
 
         //
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
 
@@ -2316,9 +2480,9 @@ class Renderer {
         //
 
         const backend = this.backend;
-        const pipelines = this._pipelines;
-        const bindings = this._bindings;
-        const nodes = this._nodes;
+        const pipelines = this._pipelines!;
+        const bindings = this._bindings!;
+        const nodes = this._nodes!;
 
         const computeList = Array.isArray(computeNodes) ? computeNodes : [computeNodes];
 
@@ -2382,7 +2546,10 @@ class Renderer {
      * - A IndirectStorageBufferAttribute for indirect dispatch size.
      * @return {Promise} A Promise that resolve when the compute has finished.
      */
-    async computeAsync(computeNodes, dispatchSize = null) {
+    async computeAsync(
+        computeNodes: ComputeNode | ComputeNode[],
+        dispatchSize: number[] | number | IndirectStorageBufferAttribute | null = null,
+    ) {
         if (this._initialized === false) await this.init();
 
         this.compute(computeNodes, dispatchSize);
@@ -2396,7 +2563,7 @@ class Renderer {
      * @param {string} name - The feature's name.
      * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
      */
-    async hasFeatureAsync(name) {
+    async hasFeatureAsync(name: string) {
         warnOnce(
             'Renderer: "hasFeatureAsync()" has been deprecated. Use "hasFeature()" and "await renderer.init();" when creating the renderer.',
         ); // @deprecated r181
@@ -2406,7 +2573,7 @@ class Renderer {
         return this.hasFeature(name);
     }
 
-    async resolveTimestampsAsync(type = 'render') {
+    async resolveTimestampsAsync(type: TimestampQuery = 'render') {
         if (this._initialized === false) await this.init();
 
         return this.backend.resolveTimestampsAsync(type);
@@ -2419,7 +2586,7 @@ class Renderer {
      * @param {string} name - The feature's name.
      * @return {boolean} Whether the feature is supported or not.
      */
-    hasFeature(name) {
+    hasFeature(name: string) {
         if (this._initialized === false) {
             throw new Error(
                 'Renderer: .hasFeature() called before the backend is initialized. Use "await renderer.init();" before before using this method.',
@@ -2447,7 +2614,7 @@ class Renderer {
      * @param {Texture} texture - The texture.
      * @return {Promise} A Promise that resolves when the texture has been initialized.
      */
-    async initTextureAsync(texture) {
+    async initTextureAsync(texture: Texture) {
         warnOnce(
             'Renderer: "initTextureAsync()" has been deprecated. Use "initTexture()" and "await renderer.init();" when creating the renderer.',
         ); // @deprecated r181
@@ -2465,14 +2632,14 @@ class Renderer {
      *
      * @param {Texture} texture - The texture.
      */
-    initTexture(texture) {
+    initTexture(texture: Texture) {
         if (this._initialized === false) {
             throw new Error(
                 'Renderer: .initTexture() called before the backend is initialized. Use "await renderer.init();" before before using this method.',
             );
         }
 
-        this._textures.updateTexture(texture);
+        this._textures!.updateTexture(texture);
     }
 
     /**
@@ -2481,7 +2648,7 @@ class Renderer {
      * @param {FramebufferTexture} framebufferTexture - The texture.
      * @param {?(Vector2|Vector4)} [rectangle=null] - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.
      */
-    copyFramebufferToTexture(framebufferTexture, rectangle = null) {
+    copyFramebufferToTexture(framebufferTexture: FramebufferTexture, rectangle: Rectangle | null = null) {
         if (rectangle !== null) {
             if (rectangle.isVector2) {
                 rectangle = _vector4
@@ -2534,7 +2701,14 @@ class Renderer {
      * @param {number} [srcLevel=0] - The source mip level to copy from.
      * @param {number} [dstLevel=0] - The destination mip level to copy to.
      */
-    copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
+    copyTextureToTexture(
+        srcTexture: Texture,
+        dstTexture: Texture,
+        srcRegion: Box2 | Box3 | null = null,
+        dstPosition: Vector2 | Vector3 | null = null,
+        srcLevel = 0,
+        dstLevel = 0,
+    ) {
         this._textures.updateTexture(srcTexture);
         this._textures.updateTexture(dstTexture);
 
@@ -2556,7 +2730,15 @@ class Renderer {
      * @param {number} [faceIndex=0] - The active cube face index.
      * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
      */
-    async readRenderTargetPixelsAsync(renderTarget, x, y, width, height, textureIndex = 0, faceIndex = 0) {
+    async readRenderTargetPixelsAsync(
+        renderTarget: RenderTarget,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+        textureIndex = 0,
+        faceIndex = 0,
+    ) {
         return this.backend.copyTextureToBuffer(renderTarget.textures[textureIndex], x, y, width, height, faceIndex);
     }
 
@@ -2564,56 +2746,69 @@ class Renderer {
      * Analyzes the given 3D object's hierarchy and builds render lists from the
      * processed hierarchy.
      *
-     * @private
      * @param {Object3D} object - The 3D object to process (usually a scene).
      * @param {Camera} camera - The camera the object is rendered with.
      * @param {number} groupOrder - The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups.
      * @param {RenderList} renderList - The current render list.
      * @param {ClippingContext} clippingContext - The current clipping context.
      */
-    _projectObject(object, camera, groupOrder, renderList, clippingContext) {
+    private _projectObject(
+        object: Object3D,
+        camera: Camera,
+        groupOrder: number,
+        renderList: RenderList,
+        clippingContext: ClippingContext | null,
+    ) {
         if (object.visible === false) return;
 
         const visible = object.layers.test(camera.layers);
 
         if (visible) {
-            if (object.isGroup) {
-                groupOrder = object.renderOrder;
+            if ((object as Group).isGroup) {
+                groupOrder = (object as Group).renderOrder;
 
                 if (object.isClippingGroup && object.enabled) clippingContext = clippingContext.getGroupContext(object);
-            } else if (object.isLOD) {
-                if (object.autoUpdate === true) object.update(camera);
-            } else if (object.isLight) {
-                renderList.pushLight(object);
-            } else if (object.isSprite) {
-                const frustum = camera.isArrayCamera ? _frustumArray : _frustum;
-
-                if (!object.frustumCulled || frustum.intersectsSprite(object, camera)) {
+            } else if ((object as LOD).isLOD) {
+                if ((object as LOD).autoUpdate === true) (object as LOD).update(camera);
+            } else if ((object as Light).isLight) {
+                renderList.pushLight(object as Light);
+            } else if ((object as Sprite).isSprite) {
+                const frustum = (camera as ArrayCamera).isArrayCamera ? _frustumArray : _frustum;
+
+                if (!object.frustumCulled || frustum.intersectsSprite(object as Sprite, camera)) {
                     if (this.sortObjects === true) {
                         _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                     }
 
-                    const { geometry, material } = object;
+                    const { geometry, material } = object as Sprite;
 
                     if (material.visible) {
-                        renderList.push(object, geometry, material, groupOrder, _vector4.z, null, clippingContext);
+                        renderList.push(
+                            object as Sprite,
+                            geometry,
+                            material,
+                            groupOrder,
+                            _vector4.z,
+                            null,
+                            clippingContext,
+                        );
                     }
                 }
-            } else if (object.isLineLoop) {
+            } else if ((object as LineLoop).isLineLoop) {
                 error(
                     'Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.',
                 );
-            } else if (object.isMesh || object.isLine || object.isPoints) {
+            } else if ((object as Mesh).isMesh || (object as Line).isLine || (object as Points).isPoints) {
                 const frustum = camera.isArrayCamera ? _frustumArray : _frustum;
 
                 if (!object.frustumCulled || frustum.intersectsObject(object, camera)) {
-                    const { geometry, material } = object;
+                    const { geometry, material } = object as Mesh | Line | Points;
 
                     if (this.sortObjects === true) {
                         if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
 
                         _vector4
-                            .copy(geometry.boundingSphere.center)
+                            .copy(geometry.boundingSphere!.center)
                             .applyMatrix4(object.matrixWorld)
                             .applyMatrix4(_projScreenMatrix);
                     }
@@ -2623,7 +2818,7 @@ class Renderer {
 
                         for (let i = 0, l = groups.length; i < l; i++) {
                             const group = groups[i];
-                            const groupMaterial = material[group.materialIndex];
+                            const groupMaterial = material[group.materialIndex!];
 
                             if (groupMaterial && groupMaterial.visible) {
                                 renderList.push(
@@ -2648,7 +2843,7 @@ class Renderer {
             const baseRenderList = renderList;
 
             // replace render list
-            renderList = this._renderLists.get(object, camera);
+            renderList = this._renderLists!.get(object, camera);
 
             renderList.begin();
 
@@ -2671,12 +2866,11 @@ class Renderer {
     /**
      * Renders the given render bundles.
      *
-     * @private
      * @param {Array<Object>} bundles - Array with render bundle data.
      * @param {Scene} sceneRef - The scene the render bundles belong to.
      * @param {LightsNode} lightsNode - The current lights node.
      */
-    _renderBundles(bundles, sceneRef, lightsNode) {
+    private _renderBundles(bundles: Bundle[], sceneRef: Scene, lightsNode: LightsNode) {
         for (const bundle of bundles) {
             this._renderBundle(bundle, sceneRef, lightsNode);
         }
@@ -2685,14 +2879,19 @@ class Renderer {
     /**
      * Renders the transparent objects from the given render lists.
      *
-     * @private
      * @param {Array<Object>} renderList - The transparent render list.
      * @param {Array<Object>} doublePassList - The list of transparent objects which require a double pass (e.g. because of transmission).
      * @param {Camera} camera - The camera the render list should be rendered with.
      * @param {Scene} scene - The scene the render list belongs to.
      * @param {LightsNode} lightsNode - The current lights node.
      */
-    _renderTransparents(renderList, doublePassList, camera, scene, lightsNode) {
+    private _renderTransparents(
+        renderList: RenderItem[],
+        doublePassList: RenderItem[],
+        camera: Camera,
+        scene: Scene,
+        lightsNode: LightsNode,
+    ) {
         if (doublePassList.length > 0) {
             // render back side
 
@@ -2723,24 +2922,29 @@ class Renderer {
     /**
      * Renders the objects from the given render list.
      *
-     * @private
      * @param {Array<Object>} renderList - The render list.
      * @param {Camera} camera - The camera the render list should be rendered with.
      * @param {Scene} scene - The scene the render list belongs to.
      * @param {LightsNode} lightsNode - The current lights node.
      * @param {?string} [passId=null] - An optional ID for identifying the pass.
      */
-    _renderObjects(renderList, camera, scene, lightsNode, passId = null) {
+    private _renderObjects(
+        renderList: RenderItem[],
+        camera: Camera,
+        scene: Scene,
+        lightsNode: LightsNode,
+        passId: string | null = null,
+    ) {
         for (let i = 0, il = renderList.length; i < il; i++) {
             const { object, geometry, material, group, clippingContext } = renderList[i];
 
-            this._currentRenderObjectFunction(
-                object,
+            this._currentRenderObjectFunction!(
+                object!,
                 scene,
                 camera,
-                geometry,
-                material,
-                group,
+                geometry!,
+                material!,
+                group!,
                 lightsNode,
                 clippingContext,
                 passId,
@@ -2752,11 +2956,10 @@ class Renderer {
      * Retrieves shadow nodes for the given material. This is used to setup shadow passes.
      * The result is cached per material and updated when the material's version changes.
      *
-     * @private
      * @param {Material} material
      * @returns {Object} - The shadow nodes for the material.
      */
-    _getShadowNodes(material) {
+    private _getShadowNodes(material: Material) {
         const version = material.version;
 
         let cache = this._cacheShadowNodes.get(material);
@@ -2849,7 +3052,17 @@ class Renderer {
      * @param {?ClippingContext} clippingContext - The clipping context.
      * @param {?string} [passId=null] - An optional ID for identifying the pass.
      */
-    renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null) {
+    renderObject(
+        object: Object3D,
+        scene: Scene,
+        camera: Camera,
+        geometry: BufferGeometry,
+        material: Material,
+        group: GeometryGroup,
+        lightsNode: LightsNode,
+        clippingContext: ClippingContext | null = null,
+        passId: string | null = null,
+    ) {
         let materialOverride = false;
         let materialColorNode;
         let materialDepthNode;
@@ -2938,7 +3151,7 @@ class Renderer {
      * @param {string} name - The compatibility's name.
      * @return {boolean} Whether the compatibility is supported or not.
      */
-    hasCompatibility(name) {
+    hasCompatibility(name: string) {
         return this.backend.hasCompatibility(name);
     }
 
@@ -2946,7 +3159,6 @@ class Renderer {
      * This method represents the default `_handleObjectFunction` implementation which creates
      * a render object from the given data and performs the draw command with the selected backend.
      *
-     * @private
      * @param {Object3D} object - The 3D object.
      * @param {Material} material - The object's material.
      * @param {Scene} scene - The scene the 3D object belongs to.
@@ -2956,14 +3168,23 @@ class Renderer {
      * @param {ClippingContext} clippingContext - The clipping context.
      * @param {string} [passId] - An optional ID for identifying the pass.
      */
-    _renderObjectDirect(object, material, scene, camera, lightsNode, group, clippingContext, passId) {
-        const renderObject = this._objects.get(
+    private _renderObjectDirect(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: GeometryGroup,
+        clippingContext: ClippingContext | null,
+        passId?: string,
+    ) {
+        const renderObject = this._objects!.get(
             object,
             material,
             scene,
             camera,
             lightsNode,
-            this._currentRenderContext,
+            this._currentRenderContext!,
             clippingContext,
             passId,
         );
@@ -2972,18 +3193,18 @@ class Renderer {
 
         //
 
-        const needsRefresh = this._nodes.needsRefresh(renderObject);
+        const needsRefresh = this._nodes!.needsRefresh(renderObject);
 
         if (needsRefresh) {
-            this._nodes.updateBefore(renderObject);
+            this._nodes!.updateBefore(renderObject);
 
-            this._geometries.updateForRender(renderObject);
+            this._geometries!.updateForRender(renderObject);
 
-            this._nodes.updateForRender(renderObject);
-            this._bindings.updateForRender(renderObject);
+            this._nodes!.updateForRender(renderObject);
+            this._bindings!.updateForRender(renderObject);
         }
 
-        this._pipelines.updateForRender(renderObject);
+        this._pipelines!.updateForRender(renderObject);
 
         //
 
@@ -2997,14 +3218,13 @@ class Renderer {
 
         this.backend.draw(renderObject, this.info);
 
-        if (needsRefresh) this._nodes.updateAfter(renderObject);
+        if (needsRefresh) this._nodes!.updateAfter(renderObject);
     }
 
     /**
      * A different implementation for `_handleObjectFunction` which only makes sure the object is ready for rendering.
      * Used in `compileAsync()`.
      *
-     * @private
      * @param {Object3D} object - The 3D object.
      * @param {Material} material - The object's material.
      * @param {Scene} scene - The scene the 3D object belongs to.
@@ -3014,14 +3234,23 @@ class Renderer {
      * @param {ClippingContext} clippingContext - The clipping context.
      * @param {string} [passId] - An optional ID for identifying the pass.
      */
-    _createObjectPipeline(object, material, scene, camera, lightsNode, group, clippingContext, passId) {
-        const renderObject = this._objects.get(
+    private _createObjectPipeline(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: Group,
+        clippingContext: ClippingContext | null,
+        passId?: string,
+    ) {
+        const renderObject = this._objects!.get(
             object,
             material,
             scene,
             camera,
             lightsNode,
-            this._currentRenderContext,
+            this._currentRenderContext!,
             clippingContext,
             passId,
         );
@@ -3030,24 +3259,22 @@ class Renderer {
 
         //
 
-        this._nodes.updateBefore(renderObject);
+        this._nodes!.updateBefore(renderObject);
 
-        this._geometries.updateForRender(renderObject);
+        this._geometries!.updateForRender(renderObject);
 
-        this._nodes.updateForRender(renderObject);
-        this._bindings.updateForRender(renderObject);
+        this._nodes!.updateForRender(renderObject);
+        this._bindings!.updateForRender(renderObject);
 
-        this._pipelines.getForRender(renderObject, this._compilationPromises);
+        this._pipelines!.getForRender(renderObject, this._compilationPromises);
 
-        this._nodes.updateAfter(renderObject);
+        this._nodes!.updateAfter(renderObject);
     }
 
     /**
      * Callback when the canvas has been resized.
-     *
-     * @private
      */
-    _onCanvasTargetResize() {
+    private _onCanvasTargetResize() {
         if (this._initialized) this.backend.updateSize();
     }
 
@@ -3065,12 +3292,4 @@ class Renderer {
     }
 }
 
-/**
- * Animation loop parameter of `renderer.setAnimationLoop()`.
- *
- * @callback onAnimationCallback
- * @param {DOMHighResTimeStamp} time - A timestamp indicating the end time of the previous frame's rendering.
- * @param {XRFrame} [frame] - A reference to the current XR frame. Only relevant when using XR rendering.
- */
-
 export default Renderer;
diff --git a/src-testing/src/renderers/common/SampledTexture.ts b/src-testing/src/renderers/common/SampledTexture.ts
index 70282d046..fd7dc5a1f 100644
--- a/src-testing/src/renderers/common/SampledTexture.ts
+++ b/src-testing/src/renderers/common/SampledTexture.ts
@@ -1,4 +1,5 @@
 import Sampler from './Sampler.js';
+import { Texture } from '../../textures/Texture.js';
 
 let _id = 0;
 
@@ -9,13 +10,19 @@ let _id = 0;
  * @augments Sampler
  */
 class SampledTexture extends Sampler {
+    id: number;
+
+    store: boolean;
+
+    readonly isSampledTexture: true;
+
     /**
      * Constructs a new sampled texture.
      *
      * @param {string} name - The sampled texture's name.
      * @param {?Texture} texture - The texture this binding is referring to.
      */
-    constructor(name, texture) {
+    constructor(name: string, texture: Texture) {
         super(name, texture);
 
         /**
@@ -59,13 +66,15 @@ class SampledTexture extends Sampler {
  * @augments SampledTexture
  */
 class SampledArrayTexture extends SampledTexture {
+    readonly isSampledArrayTexture: true;
+
     /**
      * Constructs a new sampled array texture.
      *
      * @param {string} name - The sampled array texture's name.
      * @param {?(DataArrayTexture|CompressedArrayTexture)} texture - The texture this binding is referring to.
      */
-    constructor(name, texture) {
+    constructor(name: string, texture) {
         super(name, texture);
 
         /**
@@ -86,13 +95,15 @@ class SampledArrayTexture extends SampledTexture {
  * @augments SampledTexture
  */
 class Sampled3DTexture extends SampledTexture {
+    readonly isSampled3DTexture: true;
+
     /**
      * Constructs a new sampled 3D texture.
      *
      * @param {string} name - The sampled 3D texture's name.
      * @param {?Data3DTexture} texture - The texture this binding is referring to.
      */
-    constructor(name, texture) {
+    constructor(name: string, texture) {
         super(name, texture);
 
         /**
@@ -113,13 +124,15 @@ class Sampled3DTexture extends SampledTexture {
  * @augments SampledTexture
  */
 class SampledCubeTexture extends SampledTexture {
+    readonly isSampledCubeTexture: true;
+
     /**
      * Constructs a new sampled cube texture.
      *
      * @param {string} name - The sampled cube texture's name.
      * @param {?(CubeTexture|CompressedCubeTexture)} texture - The texture this binding is referring to.
      */
-    constructor(name, texture) {
+    constructor(name: string, texture) {
         super(name, texture);
 
         /**
diff --git a/src-testing/src/renderers/common/Sampler.ts b/src-testing/src/renderers/common/Sampler.ts
index 7c12c5087..9fb4858d7 100644
--- a/src-testing/src/renderers/common/Sampler.ts
+++ b/src-testing/src/renderers/common/Sampler.ts
@@ -7,13 +7,19 @@ import Binding from './Binding.js';
  * @augments Binding
  */
 class Sampler extends Binding {
+    // TODO
+    // texture
+    version: number;
+
+    readonly isSampler: true;
+
     /**
      * Constructs a new sampler.
      *
      * @param {string} name - The samplers's name.
      * @param {?Texture} texture - The texture this binding is referring to.
      */
-    constructor(name, texture) {
+    constructor(name: string, texture) {
         super(name);
 
         /**
diff --git a/src-testing/src/renderers/common/StorageBuffer.ts b/src-testing/src/renderers/common/StorageBuffer.ts
index 4b7c259dd..96cda7efc 100644
--- a/src-testing/src/renderers/common/StorageBuffer.ts
+++ b/src-testing/src/renderers/common/StorageBuffer.ts
@@ -7,13 +7,18 @@ import Buffer from './Buffer.js';
  * @augments Buffer
  */
 class StorageBuffer extends Buffer {
+    // TODO
+    // attribute
+
+    readonly isStorageBuffer: true;
+
     /**
      * Constructs a new uniform buffer.
      *
      * @param {string} name - The buffer's name.
      * @param {BufferAttribute} attribute - The buffer attribute.
      */
-    constructor(name, attribute) {
+    constructor(name: string, attribute) {
         super(name, attribute ? attribute.array : null);
 
         /**
diff --git a/src-testing/src/renderers/common/Textures.ts b/src-testing/src/renderers/common/Textures.ts
index 4f52f62c9..9d2541b45 100644
--- a/src-testing/src/renderers/common/Textures.ts
+++ b/src-testing/src/renderers/common/Textures.ts
@@ -12,16 +12,58 @@ import {
 } from '../../constants.js';
 import { ColorManagement } from '../../math/ColorManagement.js';
 import { warn } from '../../utils.js';
+import { Texture } from '../../textures/Texture.js';
+import { RenderTarget } from '../../core/RenderTarget.js';
+import Renderer from './Renderer.js';
+import Backend from './Backend.js';
+import Info from './Info.js';
+import { CubeTexture } from '../../textures/CubeTexture.js';
+import { CompressedTexture } from '../../textures/CompressedTexture.js';
+
+type SizeVector3Uninitialized = Vector3 & { width?: number; height?: number; depth?: number };
+type SizeVector3 = Vector3 & { width: number; height: number; depth: number };
+
+const _size: SizeVector3Uninitialized = /*@__PURE__*/ new Vector3();
+
+interface RenderTargetData {
+    depthTextureMips?: { [activeMipmapLevel: number]: DepthTexture };
+    width?: number;
+    height?: number;
+    textures?: Texture[];
+    depthTexture?: DepthTexture;
+    depth?: boolean;
+    stencil?: boolean;
+    renderTarget?: RenderTarget;
+    sampleCount?: number;
+    initialized?: boolean;
+}
 
-const _size = /*@__PURE__*/ new Vector3();
+interface TextureData {
+    initialized?: boolean;
+    version?: number;
+    isDefaultTexture?: boolean;
+    generation?: number;
+}
+
+interface TextureOptions {
+    width?: number;
+    height?: number;
+    depth?: number;
+    needsMipmaps?: boolean;
+    levels?: number;
+}
 
 /**
  * This module manages the textures of the renderer.
- *
- * @private
- * @augments DataMap
  */
-class Textures extends DataMap {
+class Textures extends DataMap<{
+    renderTarget: { key: RenderTarget; value: RenderTargetData };
+    texture: { key: Texture; value: TextureData };
+}> {
+    renderer: Renderer;
+    backend: Backend;
+    info: Info;
+
     /**
      * Constructs a new texture management component.
      *
@@ -29,7 +71,7 @@ class Textures extends DataMap {
      * @param {Backend} backend - The renderer's backend.
      * @param {Info} info - Renderer component for managing metrics and monitoring data.
      */
-    constructor(renderer, backend, info) {
+    constructor(renderer: Renderer, backend: Backend, info: Info) {
         super();
 
         /**
@@ -61,7 +103,7 @@ class Textures extends DataMap {
      * @param {RenderTarget} renderTarget - The render target to update.
      * @param {number} [activeMipmapLevel=0] - The active mipmap level.
      */
-    updateRenderTarget(renderTarget, activeMipmapLevel = 0) {
+    updateRenderTarget(renderTarget: RenderTarget, activeMipmapLevel = 0) {
         const renderTargetData = this.get(renderTarget);
 
         const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
@@ -165,7 +207,7 @@ class Textures extends DataMap {
      * @param {Texture} texture - The texture to update.
      * @param {Object} [options={}] - The options.
      */
-    updateTexture(texture, options = {}) {
+    updateTexture(texture: Texture, options: TextureOptions = {}) {
         const textureData = this.get(texture);
         if (textureData.initialized === true && textureData.version === texture.version) return;
 
@@ -308,7 +350,7 @@ class Textures extends DataMap {
      * @param {Texture} texture - The texture to update the sampler for.
      * @return {string} The current sampler key.
      */
-    updateSampler(texture) {
+    updateSampler(texture: Texture) {
         return this.backend.updateSampler(texture);
     }
 
@@ -324,7 +366,7 @@ class Textures extends DataMap {
      * @param {Vector3} target - The target vector.
      * @return {Vector3} The target vector.
      */
-    getSize(texture, target = _size) {
+    getSize(texture: Texture, target = _size) {
         let image = texture.images ? texture.images[0] : texture.image;
 
         if (image) {
@@ -341,13 +383,13 @@ class Textures extends DataMap {
             } else {
                 target.width = image.width || 1;
                 target.height = image.height || 1;
-                target.depth = texture.isCubeTexture ? 6 : image.depth || 1;
+                target.depth = (texture as CubeTexture).isCubeTexture ? 6 : image.depth || 1;
             }
         } else {
             target.width = target.height = target.depth = 1;
         }
 
-        return target;
+        return target as SizeVector3;
     }
 
     /**
@@ -358,13 +400,13 @@ class Textures extends DataMap {
      * @param {number} height - The texture's height.
      * @return {number} The number of mipmap levels.
      */
-    getMipLevels(texture, width, height) {
+    getMipLevels(texture: Texture, width: number, height: number) {
         let mipLevelCount;
 
-        if (texture.mipmaps.length > 0) {
-            mipLevelCount = texture.mipmaps.length;
+        if (texture.mipmaps!.length > 0) {
+            mipLevelCount = texture.mipmaps!.length;
         } else {
-            if (texture.isCompressedTexture === true) {
+            if ((texture as CompressedTexture).isCompressedTexture === true) {
                 // it is not possible to compute mipmaps for compressed textures. So
                 // when no mipmaps are defined in "texture.mipmaps", force a texture
                 // level of 1
@@ -384,8 +426,8 @@ class Textures extends DataMap {
      * @param {Texture} texture - The texture.
      * @return {boolean} Whether mipmaps are required or not.
      */
-    needsMipmaps(texture) {
-        return texture.generateMipmaps === true || texture.mipmaps.length > 0;
+    needsMipmaps(texture: Texture) {
+        return texture.generateMipmaps === true || texture.mipmaps!.length > 0;
     }
 
     /**
@@ -394,7 +436,7 @@ class Textures extends DataMap {
      *
      * @param {RenderTarget} renderTarget - The render target to destroy.
      */
-    _destroyRenderTarget(renderTarget) {
+    _destroyRenderTarget(renderTarget: RenderTarget) {
         if (this.has(renderTarget) === true) {
             const renderTargetData = this.get(renderTarget);
 
@@ -426,7 +468,7 @@ class Textures extends DataMap {
      *
      * @param {Texture} texture - The texture to destroy.
      */
-    _destroyTexture(texture) {
+    _destroyTexture(texture: Texture) {
         if (this.has(texture) === true) {
             const textureData = this.get(texture);
 
diff --git a/src-testing/src/renderers/common/TimestampQueryPool.ts b/src-testing/src/renderers/common/TimestampQueryPool.ts
index a2e65be3f..e32dd7931 100644
--- a/src-testing/src/renderers/common/TimestampQueryPool.ts
+++ b/src-testing/src/renderers/common/TimestampQueryPool.ts
@@ -5,7 +5,17 @@ import { warn } from '../../utils.js';
  *
  * @abstract
  */
-class TimestampQueryPool {
+abstract class TimestampQueryPool {
+    trackTimestamp: boolean;
+    maxQueries: number;
+    currentQueryIndex: number;
+    queryOffsets: Map<number, number>;
+    isDisposed: boolean;
+    lastValue: number;
+    frames: number[];
+    pendingResolve: boolean;
+    timestamps: Map<string, number>;
+
     /**
      * Creates a new timestamp query pool.
      *
@@ -97,7 +107,7 @@ class TimestampQueryPool {
      * @param {string} uid - A unique identifier for the render context.
      * @return {?number} The timestamp, or undefined if not available.
      */
-    getTimestamp(uid) {
+    getTimestamp(uid: string) {
         let timestamp = this.timestamps.get(uid);
 
         if (timestamp === undefined) {
@@ -115,7 +125,7 @@ class TimestampQueryPool {
      * @param {string} uid - A unique identifier for the render context.
      * @return {boolean} True if a timestamp is available, false otherwise.
      */
-    hasTimestamp(uid) {
+    hasTimestamp(uid: string) {
         return this.timestamps.has(uid);
     }
 
@@ -127,7 +137,7 @@ class TimestampQueryPool {
      * @param {number} frameId - The current frame identifier.
      * @returns {?number}
      */
-    allocateQueriesForContext(/* uid, frameId */) {}
+    abstract allocateQueriesForContext(uid: string, frameId: number): number | null;
 
     /**
      * Resolve all timestamps and return data (or process them).
@@ -136,14 +146,14 @@ class TimestampQueryPool {
      * @async
      * @returns {Promise<number>|number} The resolved timestamp value.
      */
-    async resolveQueriesAsync() {}
+    abstract resolveQueriesAsync(): Promise<number>;
 
     /**
      * Dispose of the query pool.
      *
      * @abstract
      */
-    dispose() {}
+    abstract dispose(): void;
 }
 
 export default TimestampQueryPool;
diff --git a/src-testing/src/renderers/common/Uniform.ts b/src-testing/src/renderers/common/Uniform.ts
index fa6d7a0ed..e45d5b6fa 100644
--- a/src-testing/src/renderers/common/Uniform.ts
+++ b/src-testing/src/renderers/common/Uniform.ts
@@ -8,18 +8,25 @@ import { Vector4 } from '../../math/Vector4.js';
 
 /**
  * Abstract base class for uniforms.
- *
- * @abstract
- * @private
  */
-class Uniform {
+class Uniform<TValue> {
+    name: string;
+    value: TValue;
+
+    boundary: number;
+    itemSize: number;
+
+    offset: number;
+
+    index: number;
+
     /**
      * Constructs a new uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {any} value - The uniform's value.
      */
-    constructor(name, value) {
+    constructor(name: string, value: TValue) {
         /**
          * The uniform's name.
          *
@@ -73,7 +80,7 @@ class Uniform {
      *
      * @param {any} value - The value to set.
      */
-    setValue(value) {
+    setValue(value: TValue) {
         this.value = value;
     }
 
@@ -89,18 +96,17 @@ class Uniform {
 
 /**
  * Represents a Number uniform.
- *
- * @private
- * @augments Uniform
  */
-class NumberUniform extends Uniform {
+class NumberUniform extends Uniform<number> {
+    readonly isNumberUniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {number} value - The uniform's value.
      */
-    constructor(name, value = 0) {
+    constructor(name: string, value = 0) {
         super(name, value);
 
         /**
@@ -119,18 +125,17 @@ class NumberUniform extends Uniform {
 
 /**
  * Represents a Vector2 uniform.
- *
- * @private
- * @augments Uniform
  */
-class Vector2Uniform extends Uniform {
+class Vector2Uniform extends Uniform<Vector2> {
+    readonly isVector2Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Vector2} value - The uniform's value.
      */
-    constructor(name, value = new Vector2()) {
+    constructor(name: string, value = new Vector2()) {
         super(name, value);
 
         /**
@@ -149,18 +154,17 @@ class Vector2Uniform extends Uniform {
 
 /**
  * Represents a Vector3 uniform.
- *
- * @private
- * @augments Uniform
  */
-class Vector3Uniform extends Uniform {
+class Vector3Uniform extends Uniform<Vector3> {
+    readonly isVector3Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Vector3} value - The uniform's value.
      */
-    constructor(name, value = new Vector3()) {
+    constructor(name: string, value = new Vector3()) {
         super(name, value);
 
         /**
@@ -179,18 +183,17 @@ class Vector3Uniform extends Uniform {
 
 /**
  * Represents a Vector4 uniform.
- *
- * @private
- * @augments Uniform
  */
-class Vector4Uniform extends Uniform {
+class Vector4Uniform extends Uniform<Vector4> {
+    readonly isVector4Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Vector4} value - The uniform's value.
      */
-    constructor(name, value = new Vector4()) {
+    constructor(name: string, value = new Vector4()) {
         super(name, value);
 
         /**
@@ -209,18 +212,17 @@ class Vector4Uniform extends Uniform {
 
 /**
  * Represents a Color uniform.
- *
- * @private
- * @augments Uniform
  */
-class ColorUniform extends Uniform {
+class ColorUniform extends Uniform<Color> {
+    readonly isColorUniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Color} value - The uniform's value.
      */
-    constructor(name, value = new Color()) {
+    constructor(name: string, value = new Color()) {
         super(name, value);
 
         /**
@@ -239,18 +241,17 @@ class ColorUniform extends Uniform {
 
 /**
  * Represents a Matrix2 uniform.
- *
- * @private
- * @augments Uniform
  */
-class Matrix2Uniform extends Uniform {
+class Matrix2Uniform extends Uniform<Matrix2> {
+    readonly isMatrix2Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Matrix2} value - The uniform's value.
      */
-    constructor(name, value = new Matrix2()) {
+    constructor(name: string, value = new Matrix2()) {
         super(name, value);
 
         /**
@@ -269,18 +270,17 @@ class Matrix2Uniform extends Uniform {
 
 /**
  * Represents a Matrix3 uniform.
- *
- * @private
- * @augments Uniform
  */
-class Matrix3Uniform extends Uniform {
+class Matrix3Uniform extends Uniform<Matrix3> {
+    readonly isMatrix3Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Matrix3} value - The uniform's value.
      */
-    constructor(name, value = new Matrix3()) {
+    constructor(name: string, value = new Matrix3()) {
         super(name, value);
 
         /**
@@ -299,18 +299,17 @@ class Matrix3Uniform extends Uniform {
 
 /**
  * Represents a Matrix4 uniform.
- *
- * @private
- * @augments Uniform
  */
-class Matrix4Uniform extends Uniform {
+class Matrix4Uniform extends Uniform<Matrix4> {
+    readonly isMatrix4Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Matrix4} value - The uniform's value.
      */
-    constructor(name, value = new Matrix4()) {
+    constructor(name: string, value = new Matrix4()) {
         super(name, value);
 
         /**
@@ -337,3 +336,4 @@ export {
     Matrix3Uniform,
     Matrix4Uniform,
 };
+export type { Uniform };
diff --git a/src-testing/src/renderers/common/UniformBuffer.ts b/src-testing/src/renderers/common/UniformBuffer.ts
index 93c9419f8..364feb71c 100644
--- a/src-testing/src/renderers/common/UniformBuffer.ts
+++ b/src-testing/src/renderers/common/UniformBuffer.ts
@@ -2,18 +2,17 @@ import Buffer from './Buffer.js';
 
 /**
  * Represents a uniform buffer binding type.
- *
- * @private
- * @augments Buffer
  */
 class UniformBuffer extends Buffer {
+    readonly isUniformBuffer: true;
+
     /**
      * Constructs a new uniform buffer.
      *
      * @param {string} name - The buffer's name.
      * @param {TypedArray} [buffer=null] - The buffer.
      */
-    constructor(name, buffer = null) {
+    constructor(name?: string, buffer = null) {
         super(name, buffer);
 
         /**
diff --git a/src-testing/src/renderers/common/UniformsGroup.ts b/src-testing/src/renderers/common/UniformsGroup.ts
index de688d551..b23c40100 100644
--- a/src-testing/src/renderers/common/UniformsGroup.ts
+++ b/src-testing/src/renderers/common/UniformsGroup.ts
@@ -1,21 +1,37 @@
 import UniformBuffer from './UniformBuffer.js';
 import { GPU_CHUNK_BYTES } from './Constants.js';
 import { error } from '../../utils.js';
+import {
+    ColorNodeUniform,
+    Matrix3NodeUniform,
+    Matrix4NodeUniform,
+    NodeUniformGPU,
+    NumberNodeUniform,
+    Vector2NodeUniform,
+    Vector3NodeUniform,
+    Vector4NodeUniform,
+} from './nodes/NodeUniform.js';
+import { Uniform } from './Uniform.js';
 
 /**
  * This class represents a uniform buffer binding but with
  * an API that allows to maintain individual uniform objects.
- *
- * @private
- * @augments UniformBuffer
  */
 class UniformsGroup extends UniformBuffer {
+    readonly isUniformsGroup: true;
+
+    _values: number[] | null;
+
+    uniforms: NodeUniformGPU[];
+
+    _updateRangeCache: Map<number, { start: number; count: number }>;
+
     /**
      * Constructs a new uniforms group.
      *
      * @param {string} name - The group's name.
      */
-    constructor(name) {
+    constructor(name?: string) {
         super(name);
 
         /**
@@ -59,7 +75,7 @@ class UniformsGroup extends UniformBuffer {
      *
      * @param {Uniform} uniform - The uniform.
      */
-    addUniformUpdateRange(uniform) {
+    addUniformUpdateRange(uniform: Uniform<unknown>) {
         const index = uniform.index;
 
         if (this._updateRangeCache.has(index) !== true) {
@@ -91,7 +107,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Uniform} uniform - The uniform to add.
      * @return {UniformsGroup} A reference to this group.
      */
-    addUniform(uniform) {
+    addUniform(uniform: NodeUniformGPU) {
         this.uniforms.push(uniform);
 
         return this;
@@ -103,7 +119,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Uniform} uniform - The uniform to remove.
      * @return {UniformsGroup} A reference to this group.
      */
-    removeUniform(uniform) {
+    removeUniform(uniform: NodeUniformGPU) {
         const index = this.uniforms.indexOf(uniform);
 
         if (index !== -1) {
@@ -115,8 +131,6 @@ class UniformsGroup extends UniformBuffer {
 
     /**
      * An array with the raw uniform values.
-     *
-     * @type {Array<number>}
      */
     get values() {
         if (this._values === null) {
@@ -128,10 +142,8 @@ class UniformsGroup extends UniformBuffer {
 
     /**
      * A Float32 array buffer with the uniform values.
-     *
-     * @type {Float32Array}
      */
-    get buffer() {
+    get buffer(): Float32Array {
         let buffer = this._buffer;
 
         if (buffer === null) {
@@ -147,8 +159,6 @@ class UniformsGroup extends UniformBuffer {
 
     /**
      * The byte length of the buffer with correct buffer alignment.
-     *
-     * @type {number}
      */
     get byteLength() {
         const bytesPerElement = this.bytesPerElement;
@@ -210,14 +220,14 @@ class UniformsGroup extends UniformBuffer {
      * @param {Uniform} uniform - The uniform to update.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateByType(uniform) {
-        if (uniform.isNumberUniform) return this.updateNumber(uniform);
-        if (uniform.isVector2Uniform) return this.updateVector2(uniform);
-        if (uniform.isVector3Uniform) return this.updateVector3(uniform);
-        if (uniform.isVector4Uniform) return this.updateVector4(uniform);
-        if (uniform.isColorUniform) return this.updateColor(uniform);
-        if (uniform.isMatrix3Uniform) return this.updateMatrix3(uniform);
-        if (uniform.isMatrix4Uniform) return this.updateMatrix4(uniform);
+    updateByType(uniform: NodeUniformGPU) {
+        if ((uniform as NumberNodeUniform).isNumberUniform) return this.updateNumber(uniform as NumberNodeUniform);
+        if ((uniform as Vector2NodeUniform).isVector2Uniform) return this.updateVector2(uniform as Vector2NodeUniform);
+        if ((uniform as Vector3NodeUniform).isVector3Uniform) return this.updateVector3(uniform as Vector3NodeUniform);
+        if ((uniform as Vector4NodeUniform).isVector4Uniform) return this.updateVector4(uniform as Vector4NodeUniform);
+        if ((uniform as ColorNodeUniform).isColorUniform) return this.updateColor(uniform as ColorNodeUniform);
+        if ((uniform as Matrix3NodeUniform).isMatrix3Uniform) return this.updateMatrix3(uniform as Matrix3NodeUniform);
+        if ((uniform as Matrix4NodeUniform).isMatrix4Uniform) return this.updateMatrix4(uniform as Matrix4NodeUniform);
 
         error('WebGPUUniformsGroup: Unsupported uniform type.', uniform);
     }
@@ -228,7 +238,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {NumberUniform} uniform - The Number uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateNumber(uniform) {
+    updateNumber(uniform: NumberNodeUniform<unknown>) {
         let updated = false;
 
         const a = this.values;
@@ -254,7 +264,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Vector2Uniform} uniform - The Vector2 uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateVector2(uniform) {
+    updateVector2(uniform: Vector2NodeUniform<unknown>) {
         let updated = false;
 
         const a = this.values;
@@ -282,7 +292,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Vector3Uniform} uniform - The Vector3 uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateVector3(uniform) {
+    updateVector3(uniform: Vector3NodeUniform<unknown>) {
         let updated = false;
 
         const a = this.values;
@@ -311,7 +321,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Vector4Uniform} uniform - The Vector4 uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateVector4(uniform) {
+    updateVector4(uniform: Vector4NodeUniform<unknown>) {
         let updated = false;
 
         const a = this.values;
@@ -341,7 +351,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {ColorUniform} uniform - The Color uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateColor(uniform) {
+    updateColor(uniform: ColorNodeUniform<unknown>) {
         let updated = false;
 
         const a = this.values;
@@ -369,7 +379,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Matrix3Uniform} uniform - The Matrix3 uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateMatrix3(uniform) {
+    updateMatrix3(uniform: Matrix3NodeUniform<unknown>) {
         let updated = false;
 
         const a = this.values;
@@ -413,7 +423,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Matrix4Uniform} uniform - The Matrix4 uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateMatrix4(uniform) {
+    updateMatrix4(uniform: Matrix4NodeUniform<unknown>) {
         let updated = false;
 
         const a = this.values;
@@ -435,11 +445,10 @@ class UniformsGroup extends UniformBuffer {
     /**
      * Returns a typed array that matches the given data type.
      *
-     * @private
      * @param {string} type - The data type.
      * @return {TypedArray} The typed array.
      */
-    _getBufferForType(type) {
+    private _getBufferForType(type: string | null): Int32Array | Uint32Array | Float32Array {
         if (type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4')
             return new Int32Array(this.buffer.buffer);
         if (type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4')
@@ -456,7 +465,7 @@ class UniformsGroup extends UniformBuffer {
  * @param {TypedArray} b - The second array.
  * @param {number} offset - An index offset for the first array.
  */
-function setArray(a, b, offset) {
+function setArray(a: number[], b: number[], offset: number) {
     for (let i = 0, l = b.length; i < l; i++) {
         a[offset + i] = b[i];
     }
@@ -471,7 +480,7 @@ function setArray(a, b, offset) {
  * @param {number} offset - An index offset for the first array.
  * @return {boolean} Whether the given arrays are equal or not.
  */
-function arraysEqual(a, b, offset) {
+function arraysEqual(a: number[], b: number[], offset: number) {
     for (let i = 0, l = b.length; i < l; i++) {
         if (a[offset + i] !== b[i]) return false;
     }
diff --git a/src-testing/src/renderers/common/XRManager.ts b/src-testing/src/renderers/common/XRManager.ts
index fb95b9612..649d06f9c 100644
--- a/src-testing/src/renderers/common/XRManager.ts
+++ b/src-testing/src/renderers/common/XRManager.ts
@@ -29,26 +29,157 @@ import { PlaneGeometry } from '../../geometries/PlaneGeometry.js';
 import { MeshBasicMaterial } from '../../materials/MeshBasicMaterial.js';
 import { Mesh } from '../../objects/Mesh.js';
 import { warn } from '../../utils.js';
+import Renderer from './Renderer.js';
+import { AnimationContext } from './Animation.js';
+import { Camera } from '../../cameras/Camera.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Material } from '../../materials/Material.js';
+import { RenderTarget } from '../../core/RenderTarget.js';
 
 const _cameraLPos = /*@__PURE__*/ new Vector3();
 const _cameraRPos = /*@__PURE__*/ new Vector3();
 
+export interface XRManagerEventMap {
+    sessionstart: {};
+    sessionend: {};
+    planesdetected: { data: XRFrame };
+}
+
+export interface XRQuadLayerObject {
+    type: 'quad';
+    width: number;
+    height: number;
+    translation: Vector3;
+    quaternion: Quaternion;
+    pixelwidth: number;
+    pixelheight: number;
+    plane: Mesh;
+    material: Material;
+    rendercall: () => void;
+    renderTarget: XRRenderTarget;
+
+    xrlayer?: XRLayer;
+}
+
+export interface XRCylinderLayerObject {
+    type: 'cylinder';
+    radius: number;
+    centralAngle: number;
+    aspectratio: number;
+    translation: Vector3;
+    quaternion: Quaternion;
+    pixelwidth: number;
+    pixelheight: number;
+    plane: Mesh;
+    material: Material;
+    rendercall: () => void;
+    renderTarget: XRRenderTarget;
+
+    xrlayer?: XRLayer;
+}
+
+export type XRLayerObject = XRQuadLayerObject | XRCylinderLayerObject;
+
+export interface LayerAttributes {
+    stencil?: boolean | undefined;
+}
+
 /**
  * The XR manager is built on top of the WebXR Device API to
  * manage XR sessions with `WebGPURenderer`.
  *
  * XR is currently only supported with a WebGL 2 backend.
- *
- * @augments EventDispatcher
  */
-class XRManager extends EventDispatcher {
+class XRManager extends EventDispatcher<XRManagerEventMap> {
+    enabled: boolean;
+
+    isPresenting: boolean;
+
+    cameraAutoUpdate: boolean;
+
+    _renderer: Renderer;
+
+    _cameraL: PerspectiveCamera;
+
+    _cameraR: PerspectiveCamera;
+
+    _cameras: PerspectiveCamera[];
+
+    _cameraXR: ArrayCamera;
+
+    _currentDepthNear: number | null;
+
+    _currentDepthFar: number | null;
+
+    _controllers: WebXRController[];
+
+    _controllerInputSources: (XRInputSource | null)[];
+
+    _xrRenderTarget: XRRenderTarget | null;
+
+    _layers: XRLayerObject[];
+
+    _sessionUsesLayers: boolean;
+
+    _supportsLayers: boolean;
+
+    _supportsGlBinding: boolean;
+
+    _frameBufferTargets: WeakMap<XRRenderTarget, { frameBufferTarget: RenderTarget | null; quad: QuadMesh }> | null;
+
+    _createXRLayer: (layer: XRLayerObject) => XRLayer;
+
+    _gl: WebGL2RenderingContext | null;
+
+    _currentAnimationContext: AnimationContext | null;
+
+    _currentAnimationLoop: ((time: DOMHighResTimeStamp, frame?: XRFrame) => void) | null;
+
+    _currentPixelRatio: number | null;
+
+    _currentSize: Vector2;
+
+    _onSessionEvent: (event: XRInputSourceEvent) => void;
+
+    _onSessionEnd: () => void;
+
+    _onInputSourcesChange: (event: XRInputSourcesChangeEvent) => void;
+
+    _onAnimationFrame: (time: DOMHighResTimeStamp, frame?: XRFrame) => void;
+
+    _referenceSpace: XRReferenceSpace | null;
+
+    _referenceSpaceType: XRReferenceSpaceType;
+
+    _customReferenceSpace: XRReferenceSpace | null;
+
+    _framebufferScaleFactor: number;
+
+    _foveation: number;
+
+    _session: XRSession | null;
+
+    _glBaseLayer: XRWebGLLayer | null;
+
+    _glBinding: XRWebGLBinding | null;
+
+    _glProjLayer: XRProjectionLayer | null;
+
+    _xrFrame: XRFrame | null;
+
+    _useLayers: boolean;
+
+    _useMultiviewIfPossible: boolean;
+
+    _useMultiview: boolean;
+
     /**
      * Constructs a new XR manager.
      *
      * @param {Renderer} renderer - The renderer.
      * @param {boolean} [multiview=false] - Enables multiview if the device supports it.
      */
-    constructor(renderer, multiview = false) {
+    constructor(renderer: Renderer, multiview = false) {
         super();
 
         /**
@@ -412,7 +543,7 @@ class XRManager extends EventDispatcher {
      * @param {number} index - The index of the XR controller.
      * @return {Group} A group that represents the controller's transformation.
      */
-    getController(index) {
+    getController(index: number) {
         const controller = this._getController(index);
 
         return controller.getTargetRaySpace();
@@ -426,7 +557,7 @@ class XRManager extends EventDispatcher {
      * @param {number} index - The index of the XR controller.
      * @return {Group} A group that represents the controller's transformation.
      */
-    getControllerGrip(index) {
+    getControllerGrip(index: number) {
         const controller = this._getController(index);
 
         return controller.getGripSpace();
@@ -440,7 +571,7 @@ class XRManager extends EventDispatcher {
      * @param {number} index - The index of the XR controller.
      * @return {Group} A group that represents the controller's transformation.
      */
-    getHand(index) {
+    getHand(index: number) {
         const controller = this._getController(index);
 
         return controller.getHandSpace();
@@ -465,7 +596,7 @@ class XRManager extends EventDispatcher {
      * @param {number} foveation - A number in the range `[0,1]` where `0` means no foveation (full resolution)
      * and `1` means maximum foveation (the edges render at lower resolution).
      */
-    setFoveation(foveation) {
+    setFoveation(foveation: number) {
         this._foveation = foveation;
 
         if (this._glProjLayer !== null) {
@@ -493,7 +624,7 @@ class XRManager extends EventDispatcher {
      *
      * @param {number} factor - The framebuffer scale factor.
      */
-    setFramebufferScaleFactor(factor) {
+    setFramebufferScaleFactor(factor: number) {
         this._framebufferScaleFactor = factor;
 
         if (this.isPresenting === true) {
@@ -517,7 +648,7 @@ class XRManager extends EventDispatcher {
      *
      * @param {XRReferenceSpaceType} type - The reference space type.
      */
-    setReferenceSpaceType(type) {
+    setReferenceSpaceType(type: XRReferenceSpaceType) {
         this._referenceSpaceType = type;
 
         if (this.isPresenting === true) {
@@ -539,7 +670,7 @@ class XRManager extends EventDispatcher {
      *
      * @param {XRReferenceSpace} space - The XR reference space.
      */
-    setReferenceSpace(space) {
+    setReferenceSpace(space: XRReferenceSpace) {
         this._customReferenceSpace = space;
     }
 
@@ -573,7 +704,7 @@ class XRManager extends EventDispatcher {
      */
     getBinding() {
         if (this._glBinding === null && this._supportsGlBinding) {
-            this._glBinding = new XRWebGLBinding(this._session, this._gl);
+            this._glBinding = new XRWebGLBinding(this._session!, this._gl);
         }
 
         return this._glBinding;
@@ -612,7 +743,16 @@ class XRManager extends EventDispatcher {
      * @param {Object} [attributes={}] - Allows to configure the layer's render target.
      * @return {Mesh} A mesh representing the quadratic XR layer. This mesh should be added to the XR scene.
      */
-    createQuadLayer(width, height, translation, quaternion, pixelwidth, pixelheight, rendercall, attributes = {}) {
+    createQuadLayer(
+        width: number,
+        height: number,
+        translation: Vector3,
+        quaternion: Quaternion,
+        pixelwidth: number,
+        pixelheight: number,
+        rendercall: () => void,
+        attributes: LayerAttributes = {},
+    ) {
         const geometry = new PlaneGeometry(width, height);
         const renderTarget = new XRRenderTarget(pixelwidth, pixelheight, {
             format: RGBAFormat,
@@ -644,7 +784,7 @@ class XRManager extends EventDispatcher {
         plane.position.copy(translation);
         plane.quaternion.copy(quaternion);
 
-        const layer = {
+        const layer: XRQuadLayerObject = {
             type: 'quad',
             width: width,
             height: height,
@@ -669,7 +809,7 @@ class XRManager extends EventDispatcher {
 
             layer.xrlayer = this._createXRLayer(layer);
 
-            const xrlayers = this._session.renderState.layers;
+            const xrlayers = this._session.renderState.layers!;
             xrlayers.unshift(layer.xrlayer);
             this._session.updateRenderState({ layers: xrlayers });
         } else {
@@ -696,15 +836,15 @@ class XRManager extends EventDispatcher {
      * @return {Mesh} A mesh representing the cylindrical XR layer. This mesh should be added to the XR scene.
      */
     createCylinderLayer(
-        radius,
-        centralAngle,
-        aspectratio,
-        translation,
-        quaternion,
-        pixelwidth,
-        pixelheight,
-        rendercall,
-        attributes = {},
+        radius: number,
+        centralAngle: number,
+        aspectratio: number,
+        translation: Vector3,
+        quaternion: Quaternion,
+        pixelwidth: number,
+        pixelheight: number,
+        rendercall: () => void,
+        attributes: LayerAttributes = {},
     ) {
         const geometry = new CylinderGeometry(
             radius,
@@ -746,7 +886,7 @@ class XRManager extends EventDispatcher {
         plane.position.copy(translation);
         plane.quaternion.copy(quaternion);
 
-        const layer = {
+        const layer: XRCylinderLayerObject = {
             type: 'cylinder',
             radius: radius,
             centralAngle: centralAngle,
@@ -772,7 +912,7 @@ class XRManager extends EventDispatcher {
 
             layer.xrlayer = this._createXRLayer(layer);
 
-            const xrlayers = this._session.renderState.layers;
+            const xrlayers = this._session.renderState.layers!;
             xrlayers.unshift(layer.xrlayer);
             this._session.updateRenderState({ layers: xrlayers });
         } else {
@@ -807,12 +947,12 @@ class XRManager extends EventDispatcher {
             layer.renderTarget._hasExternalTextures = layer.renderTarget.isXRRenderTarget;
 
             if (layer.renderTarget.isXRRenderTarget && this._sessionUsesLayers) {
-                layer.xrlayer.transform = new XRRigidTransform(
+                layer.xrlayer!.transform = new XRRigidTransform(
                     layer.plane.getWorldPosition(translationObject),
                     layer.plane.getWorldQuaternion(quaternionObject),
                 );
 
-                const glSubImage = this._glBinding.getSubImage(layer.xrlayer, this._xrFrame);
+                const glSubImage = this._glBinding!.getSubImage(layer.xrlayer, this._xrFrame);
                 renderer.backend.setXRRenderTargetTextures(layer.renderTarget, glSubImage.colorTexture, undefined);
 
                 renderer._setXRLayerSize(layer.renderTarget.width, layer.renderTarget.height);
@@ -871,7 +1011,7 @@ class XRManager extends EventDispatcher {
      * @param {XRSession} session - The XR session to set.
      * @return {Promise} A Promise that resolves when the session has been set.
      */
-    async setSession(session) {
+    async setSession(session: XRSession) {
         const renderer = this._renderer;
         const backend = renderer.backend;
 
@@ -901,9 +1041,9 @@ class XRManager extends EventDispatcher {
             this._currentPixelRatio = renderer.getPixelRatio();
             renderer.getSize(this._currentSize);
 
-            this._currentAnimationContext = renderer._animation.getContext();
-            this._currentAnimationLoop = renderer._animation.getAnimationLoop();
-            renderer._animation.stop();
+            this._currentAnimationContext = renderer._animation!.getContext();
+            this._currentAnimationLoop = renderer._animation!.getAnimationLoop();
+            renderer._animation!.stop();
 
             //
 
@@ -1030,11 +1170,11 @@ class XRManager extends EventDispatcher {
 
             //
 
-            this.setFoveation(this.getFoveation());
+            this.setFoveation(this.getFoveation()!);
 
-            renderer._animation.setAnimationLoop(this._onAnimationFrame);
-            renderer._animation.setContext(session);
-            renderer._animation.start();
+            renderer._animation!.setAnimationLoop(this._onAnimationFrame);
+            renderer._animation!.setContext(session);
+            renderer._animation!.start();
 
             this.isPresenting = true;
 
@@ -1049,7 +1189,7 @@ class XRManager extends EventDispatcher {
      *
      * @param {PerspectiveCamera} camera - The camera.
      */
-    updateCamera(camera) {
+    updateCamera(camera: PerspectiveCamera) {
         const session = this._session;
 
         if (session === null) return;
@@ -1082,7 +1222,7 @@ class XRManager extends EventDispatcher {
         cameraL.layers.mask = cameraXR.layers.mask & ~0b100;
         cameraR.layers.mask = cameraXR.layers.mask & ~0b010;
 
-        const parent = camera.parent;
+        const parent = camera.parent!;
         const cameras = cameraXR.cameras;
 
         updateCamera(cameraXR, parent);
@@ -1109,11 +1249,10 @@ class XRManager extends EventDispatcher {
     /**
      * Returns a WebXR controller for the given controller index.
      *
-     * @private
      * @param {number} index - The controller index.
      * @return {WebXRController} The XR controller.
      */
-    _getController(index) {
+    private _getController(index: number) {
         let controller = this._controllers[index];
 
         if (controller === undefined) {
@@ -1135,7 +1274,7 @@ class XRManager extends EventDispatcher {
  * @param {PerspectiveCamera} cameraL - The left camera.
  * @param {PerspectiveCamera} cameraR - The right camera.
  */
-function setProjectionFromUnion(camera, cameraL, cameraR) {
+function setProjectionFromUnion(camera: ArrayCamera, cameraL: PerspectiveCamera, cameraR: PerspectiveCamera) {
     _cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
     _cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
 
@@ -1199,7 +1338,7 @@ function setProjectionFromUnion(camera, cameraL, cameraR) {
  * @param {Camera} camera - The camera to update.
  * @param {Object3D} parent - The parent 3D object.
  */
-function updateCamera(camera, parent) {
+function updateCamera(camera: Camera, parent: Object3D) {
     if (parent === null) {
         camera.matrixWorld.copy(camera.matrix);
     } else {
@@ -1217,7 +1356,7 @@ function updateCamera(camera, parent) {
  * @param {ArrayCamera} cameraXR - The XR camera.
  * @param {Object3D} parent - The parent 3D object.
  */
-function updateUserCamera(camera, cameraXR, parent) {
+function updateUserCamera(camera: Camera, cameraXR: ArrayCamera, parent: Object3D) {
     if (parent === null) {
         camera.matrix.copy(cameraXR.matrixWorld);
     } else {
@@ -1232,13 +1371,14 @@ function updateUserCamera(camera, cameraXR, parent) {
     camera.projectionMatrix.copy(cameraXR.projectionMatrix);
     camera.projectionMatrixInverse.copy(cameraXR.projectionMatrixInverse);
 
-    if (camera.isPerspectiveCamera) {
-        camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
-        camera.zoom = 1;
+    if ((camera as PerspectiveCamera).isPerspectiveCamera) {
+        (camera as PerspectiveCamera).fov =
+            RAD2DEG * 2 * Math.atan(1 / (camera as PerspectiveCamera).projectionMatrix.elements[5]);
+        (camera as PerspectiveCamera).zoom = 1;
     }
 }
 
-function onSessionEvent(event) {
+function onSessionEvent(this: XRManager, event: XRInputSourceEvent) {
     const controllerIndex = this._controllerInputSources.indexOf(event.inputSource);
 
     if (controllerIndex === -1) {
@@ -1248,15 +1388,15 @@ function onSessionEvent(event) {
     const controller = this._controllers[controllerIndex];
 
     if (controller !== undefined) {
-        const referenceSpace = this.getReferenceSpace();
+        const referenceSpace = this.getReferenceSpace()!;
 
         controller.update(event.inputSource, event.frame, referenceSpace);
         controller.dispatchEvent({ type: event.type, data: event.inputSource });
     }
 }
 
-function onSessionEnd() {
-    const session = this._session;
+function onSessionEnd(this: XRManager) {
+    const session = this._session!;
     const renderer = this._renderer;
 
     session.removeEventListener('select', this._onSessionEvent);
@@ -1330,18 +1470,18 @@ function onSessionEnd() {
     this.isPresenting = false;
     this._useMultiview = false;
 
-    renderer._animation.stop();
-    renderer._animation.setAnimationLoop(this._currentAnimationLoop);
-    renderer._animation.setContext(this._currentAnimationContext);
-    renderer._animation.start();
+    renderer._animation!.stop();
+    renderer._animation!.setAnimationLoop(this._currentAnimationLoop);
+    renderer._animation!.setContext(this._currentAnimationContext!);
+    renderer._animation!.start();
 
-    renderer.setPixelRatio(this._currentPixelRatio);
+    renderer.setPixelRatio(this._currentPixelRatio!);
     renderer.setSize(this._currentSize.width, this._currentSize.height, false);
 
     this.dispatchEvent({ type: 'sessionend' });
 }
 
-function onInputSourcesChange(event) {
+function onInputSourcesChange(this: XRManager, event: XRInputSourcesChangeEvent) {
     const controllers = this._controllers;
     const controllerInputSources = this._controllerInputSources;
 
@@ -1393,24 +1533,24 @@ function onInputSourcesChange(event) {
 }
 
 // Creation method for native WebXR layers
-function createXRLayer(layer) {
+function createXRLayer(this: XRManager, layer: XRLayerObject) {
     if (layer.type === 'quad') {
-        return this._glBinding.createQuadLayer({
+        return this._glBinding!.createQuadLayer({
             transform: new XRRigidTransform(layer.translation, layer.quaternion),
             width: layer.width / 2,
             height: layer.height / 2,
-            space: this._referenceSpace,
+            space: this._referenceSpace!,
             viewPixelWidth: layer.pixelwidth,
             viewPixelHeight: layer.pixelheight,
             clearOnAccess: false,
         });
     } else {
-        return this._glBinding.createCylinderLayer({
+        return this._glBinding!.createCylinderLayer({
             transform: new XRRigidTransform(layer.translation, layer.quaternion),
             radius: layer.radius,
             centralAngle: layer.centralAngle,
             aspectRatio: layer.aspectRatio,
-            space: this._referenceSpace,
+            space: this._referenceSpace!,
             viewPixelWidth: layer.pixelwidth,
             viewPixelHeight: layer.pixelheight,
             clearOnAccess: false,
@@ -1420,7 +1560,7 @@ function createXRLayer(layer) {
 
 // Animation Loop
 
-function onAnimationFrame(time, frame) {
+function onAnimationFrame(this: XRManager, time: DOMHighResTimeStamp, frame?: XRFrame) {
     if (frame === undefined) return;
 
     const cameraXR = this._cameraXR;
@@ -1429,16 +1569,16 @@ function onAnimationFrame(time, frame) {
 
     const glBaseLayer = this._glBaseLayer;
 
-    const referenceSpace = this.getReferenceSpace();
+    const referenceSpace = this.getReferenceSpace()!;
     const pose = frame.getViewerPose(referenceSpace);
 
     this._xrFrame = frame;
 
     if (pose !== null) {
-        const views = pose.views;
+        const views = pose!.views;
 
         if (this._glBaseLayer !== null) {
-            backend.setXRTarget(glBaseLayer.framebuffer);
+            backend.setXRTarget(glBaseLayer!.framebuffer);
         }
 
         let cameraXRNeedsUpdate = false;
@@ -1456,7 +1596,7 @@ function onAnimationFrame(time, frame) {
             let viewport;
 
             if (this._supportsLayers === true) {
-                const glSubImage = this._glBinding.getViewSubImage(this._glProjLayer, view);
+                const glSubImage = this._glBinding!.getViewSubImage(this._glProjLayer!, view);
                 viewport = glSubImage.viewport;
 
                 // For side-by-side projection, we only produce a single texture for both eyes.
@@ -1464,13 +1604,13 @@ function onAnimationFrame(time, frame) {
                     backend.setXRRenderTargetTextures(
                         this._xrRenderTarget,
                         glSubImage.colorTexture,
-                        this._glProjLayer.ignoreDepthValues && !this._useMultiview
+                        this._glProjLayer!.ignoreDepthValues && !this._useMultiview
                             ? undefined
                             : glSubImage.depthStencilTexture,
                     );
                 }
             } else {
-                viewport = glBaseLayer.getViewport(view);
+                viewport = glBaseLayer!.getViewport(view)!;
             }
 
             let camera = this._cameras[i];
@@ -1486,7 +1626,7 @@ function onAnimationFrame(time, frame) {
             camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
             camera.projectionMatrix.fromArray(view.projectionMatrix);
             camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
-            camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
+            camera.viewport!.set(viewport.x, viewport.y, viewport.width, viewport.height);
 
             if (i === 0) {
                 cameraXR.matrix.copy(camera.matrix);
diff --git a/src-testing/src/renderers/common/XRRenderTarget.ts b/src-testing/src/renderers/common/XRRenderTarget.ts
index c10c98502..02975b2fa 100644
--- a/src-testing/src/renderers/common/XRRenderTarget.ts
+++ b/src-testing/src/renderers/common/XRRenderTarget.ts
@@ -1,13 +1,18 @@
-import { RenderTarget } from '../../core/RenderTarget.js';
+import { RenderTarget, RenderTargetOptions } from '../../core/RenderTarget.js';
 
 /**
  * A special type of render target that is used when rendering
  * with the WebXR Device API.
- *
- * @private
- * @augments RenderTarget
  */
 class XRRenderTarget extends RenderTarget {
+    readonly isXRRenderTarget: true;
+
+    _hasExternalTextures: boolean;
+
+    _autoAllocateDepthBuffer: boolean;
+
+    _isOpaqueFramebuffer: boolean;
+
     /**
      * Constructs a new XR render target.
      *
@@ -15,7 +20,7 @@ class XRRenderTarget extends RenderTarget {
      * @param {number} [height=1] - The height of the render target.
      * @param {Object} [options={}] - The configuration options.
      */
-    constructor(width = 1, height = 1, options = {}) {
+    constructor(width = 1, height = 1, options: RenderTargetOptions = {}) {
         super(width, height, options);
 
         /**
@@ -70,7 +75,7 @@ class XRRenderTarget extends RenderTarget {
         this._isOpaqueFramebuffer = false;
     }
 
-    copy(source) {
+    copy(source: XRRenderTarget) {
         super.copy(source);
 
         this._hasExternalTextures = source._hasExternalTextures;
diff --git a/src-testing/src/renderers/common/nodes/NodeBuilderState.ts b/src-testing/src/renderers/common/nodes/NodeBuilderState.ts
index 5fe2b322e..c00eb37d7 100644
--- a/src-testing/src/renderers/common/nodes/NodeBuilderState.ts
+++ b/src-testing/src/renderers/common/nodes/NodeBuilderState.ts
@@ -1,4 +1,8 @@
 import BindGroup from '../BindGroup.js';
+import NodeAttribute from '../../../nodes/core/NodeAttribute.js';
+import Node from '../../../nodes/core/Node.js';
+import NodeUniformsGroup from './NodeUniformsGroup.js';
+import NodeMaterialObserver from '../../../materials/nodes/manager/NodeMaterialObserver.js';
 
 /**
  * This module represents the state of a node builder after it was
@@ -6,10 +10,24 @@ import BindGroup from '../BindGroup.js';
  * results of the build for further processing in the renderer.
  *
  * Render objects with identical cache keys share the same node builder state.
- *
- * @private
  */
 class NodeBuilderState {
+    vertexShader: string | null;
+    fragmentShader: string | null;
+    computeShader: string | null;
+    transforms: never[];
+
+    nodeAttributes: NodeAttribute[];
+    bindings: BindGroup[];
+
+    updateNodes: Node[];
+    updateBeforeNodes: Node[];
+    updateAfterNodes: Node[];
+
+    observer: NodeMaterialObserver;
+
+    usedTimes: number;
+
     /**
      * Constructs a new node builder state.
      *
@@ -25,16 +43,16 @@ class NodeBuilderState {
      * @param {Array<Object>} transforms - An array with transform attribute objects. Only relevant when using compute shaders with WebGL 2.
      */
     constructor(
-        vertexShader,
-        fragmentShader,
-        computeShader,
-        nodeAttributes,
-        bindings,
-        updateNodes,
-        updateBeforeNodes,
-        updateAfterNodes,
-        observer,
-        transforms = [],
+        vertexShader: string | null,
+        fragmentShader: string | null,
+        computeShader: string | null,
+        nodeAttributes: NodeAttribute[],
+        bindings: BindGroup[],
+        updateNodes: Node[],
+        updateBeforeNodes: Node[],
+        updateAfterNodes: Node[],
+        observer: NodeMaterialObserver,
+        transforms: never[] = [],
     ) {
         /**
          * The native vertex shader code.
@@ -128,7 +146,7 @@ class NodeBuilderState {
         const bindings = [];
 
         for (const instanceGroup of this.bindings) {
-            const shared = instanceGroup.bindings[0].groupNode.shared; // All bindings in the group must have the same groupNode.
+            const shared = (instanceGroup.bindings[0] as NodeUniformsGroup).groupNode.shared; // All bindings in the group must have the same groupNode.
 
             if (shared !== true) {
                 const bindingsGroup = new BindGroup(
@@ -140,7 +158,7 @@ class NodeBuilderState {
                 bindings.push(bindingsGroup);
 
                 for (const instanceBinding of instanceGroup.bindings) {
-                    bindingsGroup.bindings.push(instanceBinding.clone());
+                    bindingsGroup.bindings.push((instanceBinding as NodeUniformsGroup).clone());
                 }
             } else {
                 bindings.push(instanceGroup);
diff --git a/src-testing/src/renderers/common/nodes/NodeLibrary.ts b/src-testing/src/renderers/common/nodes/NodeLibrary.ts
index 7c61c35c5..0f728fe49 100644
--- a/src-testing/src/renderers/common/nodes/NodeLibrary.ts
+++ b/src-testing/src/renderers/common/nodes/NodeLibrary.ts
@@ -1,14 +1,22 @@
 import { warn } from '../../../utils.js';
+import { Material } from '../../../materials/Material.js';
+import NodeMaterial from '../../../materials/nodes/NodeMaterial.js';
+import { ToneMapping } from '../../../constants.js';
+import Node from '../../../nodes/core/Node.js';
+import { Light } from '../../../lights/Light.js';
+import AnalyticLightNode from '../../../nodes/lighting/AnalyticLightNode.js';
 
 /**
  * The purpose of a node library is to assign node implementations
  * to existing library features. In `WebGPURenderer` lights, materials
  * which are not based on `NodeMaterial` as well as tone mapping techniques
  * are implemented with node-based modules.
- *
- * @private
  */
 class NodeLibrary {
+    lightNodes: WeakMap<{ new (): Light }, { new (light: Light): AnalyticLightNode<Light> }>;
+    materialNodes: Map<string, { new (): NodeMaterial }>;
+    toneMappingNodes: Map<ToneMapping, (color: Node, exposure: Node) => Node>;
+
     /**
      * Constructs a new node library.
      */
@@ -46,8 +54,8 @@ class NodeLibrary {
      * @param {Material} material - A material.
      * @return {NodeMaterial} The corresponding node material.
      */
-    fromMaterial(material) {
-        if (material.isNodeMaterial) return material;
+    fromMaterial(material: Material) {
+        if ((material as NodeMaterial).isNodeMaterial) return material;
 
         let nodeMaterial = null;
 
@@ -70,7 +78,7 @@ class NodeLibrary {
      * @param {Function} toneMappingNode - The tone mapping node function.
      * @param {number} toneMapping - The tone mapping.
      */
-    addToneMapping(toneMappingNode, toneMapping) {
+    addToneMapping(toneMappingNode: (color: Node, exposure: Node) => Node, toneMapping: ToneMapping) {
         this.addType(toneMappingNode, toneMapping, this.toneMappingNodes);
     }
 
@@ -80,7 +88,7 @@ class NodeLibrary {
      * @param {number} toneMapping - The tone mapping.
      * @return {?Function} The tone mapping node function. Returns `null` if no node function is found.
      */
-    getToneMappingFunction(toneMapping) {
+    getToneMappingFunction(toneMapping: ToneMapping) {
         return this.toneMappingNodes.get(toneMapping) || null;
     }
 
@@ -90,7 +98,7 @@ class NodeLibrary {
      * @param {string} materialType - The material type.
      * @return {?NodeMaterial.constructor} The node material class definition. Returns `null` if no node material is found.
      */
-    getMaterialNodeClass(materialType) {
+    getMaterialNodeClass(materialType: string) {
         return this.materialNodes.get(materialType) || null;
     }
 
@@ -100,7 +108,7 @@ class NodeLibrary {
      * @param {NodeMaterial.constructor} materialNodeClass - The node material class definition.
      * @param {string} materialClassType - The material type.
      */
-    addMaterial(materialNodeClass, materialClassType) {
+    addMaterial(materialNodeClass: { new (): NodeMaterial }, materialClassType: string) {
         this.addType(materialNodeClass, materialClassType, this.materialNodes);
     }
 
@@ -110,7 +118,7 @@ class NodeLibrary {
      * @param {Light.constructor} light - The light class definition.
      * @return {?AnalyticLightNode.constructor} The light node class definition. Returns `null` if no light node is found.
      */
-    getLightNodeClass(light) {
+    getLightNodeClass(light: Light) {
         return this.lightNodes.get(light) || null;
     }
 
@@ -120,8 +128,18 @@ class NodeLibrary {
      * @param {AnalyticLightNode.constructor} lightNodeClass - The light node class definition.
      * @param {Light.constructor} lightClass - The light class definition.
      */
-    addLight(lightNodeClass, lightClass) {
-        this.addClass(lightNodeClass, lightClass, this.lightNodes);
+    addLight<TLight extends Light>(
+        lightNodeClass: { new (light: TLight): AnalyticLightNode<TLight> },
+        lightClass: { new (): TLight },
+    ) {
+        this.addClass(
+            lightNodeClass,
+            lightClass,
+            this.lightNodes as unknown as WeakMap<
+                { new (): TLight },
+                { new (light: TLight): AnalyticLightNode<TLight> }
+            >,
+        );
     }
 
     /**
@@ -131,7 +149,7 @@ class NodeLibrary {
      * @param {number|string} type - The object type.
      * @param {Map<number|string,Node.constructor>} library - The type library.
      */
-    addType(nodeClass, type, library) {
+    addType<TNodeClass, TType>(nodeClass: TNodeClass, type: TType, library: Map<TType, TNodeClass>) {
         if (library.has(type)) {
             warn(`Redefinition of node ${type}`);
             return;
@@ -151,7 +169,11 @@ class NodeLibrary {
      * @param {Node.constructor} baseClass - The class definition.
      * @param {WeakMap<Node.constructor, Node.constructor>} library - The type library.
      */
-    addClass(nodeClass, baseClass, library) {
+    addClass<TNodeClass, TBaseClass extends object>(
+        nodeClass: TNodeClass,
+        baseClass: TBaseClass,
+        library: WeakMap<TBaseClass, TNodeClass>,
+    ) {
         if (library.has(baseClass)) {
             warn(`Redefinition of node ${baseClass.name}`);
             return;
diff --git a/src-testing/src/renderers/common/nodes/NodeManager.ts b/src-testing/src/renderers/common/nodes/NodeManager.ts
index 66dc57246..b1c62803a 100644
--- a/src-testing/src/renderers/common/nodes/NodeManager.ts
+++ b/src-testing/src/renderers/common/nodes/NodeManager.ts
@@ -28,26 +28,89 @@ import {
 } from '../../../constants.js';
 import { hashArray } from '../../../nodes/core/NodeUtils.js';
 import { error } from '../../../utils.js';
+import { Color } from '../../../math/Color.js';
+import { Texture } from '../../../textures/Texture.js';
+import { CubeTexture } from '../../../textures/CubeTexture.js';
+import { Fog } from '../../../scenes/Fog.js';
+import { FogExp2 } from '../../../scenes/FogExp2.js';
+import NodeUniformsGroup from './NodeUniformsGroup.js';
+import RenderObject from '../RenderObject.js';
+import { Scene } from '../../../scenes/Scene.js';
+import Renderer from '../Renderer.js';
+import Backend from '../Backend.js';
+import { Object3D } from '../../../core/Object3D.js';
+import { Camera } from '../../../cameras/Camera.js';
+import { Material } from '../../../materials/Material.js';
+import Node from '../../../nodes/core/Node.js';
+import ComputeNode from '../../../nodes/gpgpu/ComputeNode.js';
+import LightsNode from '../../../nodes/lighting/LightsNode.js';
+import UniformGroupNode from '../../../nodes/core/UniformGroupNode.js';
+import NodeBuilder from '../../../nodes/core/NodeBuilder.js';
+
+interface NodeUniformsGroupData {
+    renderId?: number | undefined;
+    frameId?: number | undefined;
+}
+
+interface RenderObjectData {
+    nodeBuilderState?: NodeBuilderState | undefined;
+}
+
+interface ComputeNodeData {
+    nodeBuilderState?: NodeBuilderState | undefined;
+}
+
+interface SceneData {
+    background?: Color | Texture | CubeTexture | undefined;
+    backgroundNode?: Node | undefined;
+    fog?: Fog | FogExp2 | undefined;
+    fogNode?: Node | undefined;
+    environment?: Texture | undefined;
+    environmentNode?: Node | undefined;
+}
+
+interface CacheKeyData {
+    callId: number;
+    cacheKey: number;
+}
+
+declare module '../../../scenes/Scene.js' {
+    interface Scene {
+        environmentNode?: Node<'vec3'> | null | undefined;
+        backgroundNode?: Node | null | undefined;
+        fogNode?: Node | null | undefined;
+    }
+}
 
 const _outputNodeMap = new WeakMap();
-const _chainKeys = [];
-const _cacheKeyValues = [];
+const _chainKeys = [] as unknown as [UniformGroupNode, NodeUniformsGroup] | [Scene, LightsNode];
+const _cacheKeyValues: number[] = [];
 
 /**
  * This renderer module manages node-related objects and is the
  * primary interface between the renderer and the node system.
- *
- * @private
- * @augments DataMap
  */
-class NodeManager extends DataMap {
+class Nodes extends DataMap<{
+    nodeUniformsGroup: { key: NodeUniformsGroup; value: NodeUniformsGroupData };
+    renderObject: { key: RenderObject; value: RenderObjectData };
+    computeNode: { key: ComputeNode; value: ComputeNodeData };
+    scene: { key: Scene; value: SceneData };
+}> {
+    renderer: Renderer;
+    backend: Backend;
+    nodeFrame: NodeFrame;
+    nodeBuilderCache: Map<string, NodeBuilderState>;
+    callHashCache: ChainMap<readonly [Scene, LightsNode], CacheKeyData>;
+    groupsData: ChainMap<readonly [UniformGroupNode, NodeUniformsGroup], { version?: number }>;
+    cacheLib: { [type: string]: WeakMap<object, Node | undefined> };
+
     /**
      * Constructs a new nodes management component.
      *
      * @param {Renderer} renderer - The renderer.
      * @param {Backend} backend - The renderer's backend.
      */
-    constructor(renderer, backend) {
+    constructor(renderer: Renderer, backend: Backend) {
         super();
 
         /**
@@ -107,7 +170,7 @@ class NodeManager extends DataMap {
      * @param {NodeUniformsGroup} nodeUniformsGroup - The node uniforms group.
      * @return {boolean} Whether the node uniforms group requires an update or not.
      */
-    updateGroup(nodeUniformsGroup) {
+    updateGroup(nodeUniformsGroup: NodeUniformsGroup) {
         const groupNode = nodeUniformsGroup.groupNode;
         const name = groupNode.name;
 
@@ -170,7 +233,7 @@ class NodeManager extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {number} The cache key.
      */
-    getForRenderCacheKey(renderObject) {
+    getForRenderCacheKey(renderObject: RenderObject) {
         return renderObject.initialCacheKey;
     }
 
@@ -180,7 +243,7 @@ class NodeManager extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {NodeBuilderState} The node builder state.
      */
-    getForRender(renderObject) {
+    getForRender(renderObject: RenderObject) {
         const renderObjectData = this.get(renderObject);
 
         let nodeBuilderState = renderObjectData.nodeBuilderState;
@@ -242,13 +305,13 @@ class NodeManager extends DataMap {
      * @param {any} object - The object to delete.
      * @return {?Object} The deleted dictionary.
      */
-    delete(object) {
-        if (object.isRenderObject) {
-            const nodeBuilderState = this.get(object).nodeBuilderState;
+    delete(object: NodeUniformsGroup | RenderObject | ComputeNode | Scene) {
+        if ((object as RenderObject).isRenderObject) {
+            const nodeBuilderState = this.get(object as RenderObject).nodeBuilderState!;
             nodeBuilderState.usedTimes--;
 
             if (nodeBuilderState.usedTimes === 0) {
-                this.nodeBuilderCache.delete(this.getForRenderCacheKey(object));
+                this.nodeBuilderCache.delete(this.getForRenderCacheKey(object as RenderObject));
             }
         }
 
@@ -261,7 +324,7 @@ class NodeManager extends DataMap {
      * @param {Node} computeNode - The compute node.
      * @return {NodeBuilderState} The node builder state.
      */
-    getForCompute(computeNode) {
+    getForCompute(computeNode: ComputeNode) {
         const computeData = this.get(computeNode);
 
         let nodeBuilderState = computeData.nodeBuilderState;
@@ -281,11 +344,10 @@ class NodeManager extends DataMap {
     /**
      * Creates a node builder state for the given node builder.
      *
-     * @private
      * @param {NodeBuilder} nodeBuilder - The node builder.
      * @return {NodeBuilderState} The node builder state.
      */
-    _createNodeBuilderState(nodeBuilder) {
+    private _createNodeBuilderState(nodeBuilder: NodeBuilder) {
         return new NodeBuilderState(
             nodeBuilder.vertexShader,
             nodeBuilder.fragmentShader,
@@ -307,9 +369,8 @@ class NodeManager extends DataMap {
      * @param {Scene} scene - The scene.
      * @return {Node} A node representing the current scene environment.
      */
-    getEnvironmentNode(scene) {
+    getEnvironmentNode(scene: Scene) {
         this.updateEnvironment(scene);
-
         let environmentNode = null;
 
         if (scene.environmentNode && scene.environmentNode.isNode) {
@@ -332,9 +393,8 @@ class NodeManager extends DataMap {
      * @param {Scene} scene - The scene.
      * @return {Node} A node representing the current scene background.
      */
-    getBackgroundNode(scene) {
+    getBackgroundNode(scene: Scene) {
         this.updateBackground(scene);
-
         let backgroundNode = null;
 
         if (scene.backgroundNode && scene.backgroundNode.isNode) {
@@ -356,9 +416,8 @@ class NodeManager extends DataMap {
      * @param {Scene} scene - The scene.
      * @return {Node} A node representing the current scene fog.
      */
-    getFogNode(scene) {
+    getFogNode(scene: Scene) {
         this.updateFog(scene);
-
         return scene.fogNode || this.get(scene).fogNode || null;
     }
 
@@ -372,13 +431,13 @@ class NodeManager extends DataMap {
      * @param {LightsNode} lightsNode - The lights node.
      * @return {number} The cache key.
      */
-    getCacheKey(scene, lightsNode) {
+    getCacheKey(scene: Scene, lightsNode: LightsNode) {
         _chainKeys[0] = scene;
         _chainKeys[1] = lightsNode;
 
         const callId = this.renderer.info.calls;
 
-        const cacheKeyData = this.callHashCache.get(_chainKeys) || {};
+        const cacheKeyData = this.callHashCache.get(_chainKeys as readonly [Scene, LightsNode]) || ({} as CacheKeyData);
 
         if (cacheKeyData.callId !== callId) {
             const environmentNode = this.getEnvironmentNode(scene);
@@ -397,7 +456,7 @@ class NodeManager extends DataMap {
             cacheKeyData.callId = callId;
             cacheKeyData.cacheKey = hashArray(_cacheKeyValues);
 
-            this.callHashCache.set(_chainKeys, cacheKeyData);
+            this.callHashCache.set(_chainKeys as readonly [Scene, LightsNode], cacheKeyData);
 
             _cacheKeyValues.length = 0;
         }
@@ -410,8 +469,6 @@ class NodeManager extends DataMap {
     /**
      * A boolean that indicates whether tone mapping should be enabled
      * or not.
-     *
-     * @type {boolean}
      */
     get isToneMappingState() {
         return this.renderer.getRenderTarget() ? false : true;
@@ -423,7 +480,7 @@ class NodeManager extends DataMap {
      *
      * @param {Scene} scene - The scene.
      */
-    updateBackground(scene) {
+    updateBackground(scene: Scene) {
         const sceneData = this.get(scene);
         const background = scene.background;
 
@@ -438,7 +495,7 @@ class NodeManager extends DataMap {
                     background,
                     () => {
                         if (
-                            background.isCubeTexture === true ||
+                            (background as CubeTexture).isCubeTexture === true ||
                             background.mapping === EquirectangularReflectionMapping ||
                             background.mapping === EquirectangularRefractionMapping ||
                             background.mapping === CubeUVReflectionMapping
@@ -448,18 +505,18 @@ class NodeManager extends DataMap {
                             } else {
                                 let envMap;
 
-                                if (background.isCubeTexture === true) {
-                                    envMap = cubeTexture(background);
+                                if ((background as CubeTexture).isCubeTexture === true) {
+                                    envMap = cubeTexture(background as CubeTexture);
                                 } else {
                                     envMap = texture(background);
                                 }
 
                                 return cubeMapNode(envMap);
                             }
-                        } else if (background.isTexture === true) {
-                            return texture(background, screenUV.flipY()).setUpdateMatrix(true);
-                        } else if (background.isColor !== true) {
-                            error('WebGPUNodes: Unsupported background configuration.', background);
+                        } else if ((background as Texture).isTexture === true) {
+                            return texture(background as Texture, screenUV.flipY()).setUpdateMatrix(true);
+                        } else if ((background as Color).isColor !== true) {
+                            error('WebGPUNodes: Unsupported background configuration.', background as Color);
                         }
                     },
                     forceUpdate,
@@ -485,7 +542,7 @@ class NodeManager extends DataMap {
      * @param {boolean} [forceUpdate=false] - Whether an update should be enforced or not.
      * @return {Node} The node representation.
      */
-    getCacheNode(type, object, callback, forceUpdate = false) {
+    getCacheNode(type: string, object: object, callback: () => Node | undefined, forceUpdate = false) {
         const nodeCache = this.cacheLib[type] || (this.cacheLib[type] = new WeakMap());
 
         let node = nodeCache.get(object);
@@ -504,22 +561,22 @@ class NodeManager extends DataMap {
      *
      * @param {Scene} scene - The scene.
      */
-    updateFog(scene) {
+    updateFog(scene: Scene) {
         const sceneData = this.get(scene);
         const sceneFog = scene.fog;
 
         if (sceneFog) {
             if (sceneData.fog !== sceneFog) {
                 const fogNode = this.getCacheNode('fog', sceneFog, () => {
-                    if (sceneFog.isFogExp2) {
-                        const color = reference('color', 'color', sceneFog).setGroup(renderGroup);
-                        const density = reference('density', 'float', sceneFog).setGroup(renderGroup);
+                    if ((sceneFog as FogExp2).isFogExp2) {
+                        const color = reference('color', 'color', sceneFog as FogExp2).setGroup(renderGroup);
+                        const density = reference('density', 'float', sceneFog as FogExp2).setGroup(renderGroup);
 
                         return fog(color, densityFogFactor(density));
-                    } else if (sceneFog.isFog) {
-                        const color = reference('color', 'color', sceneFog).setGroup(renderGroup);
-                        const near = reference('near', 'float', sceneFog).setGroup(renderGroup);
-                        const far = reference('far', 'float', sceneFog).setGroup(renderGroup);
+                    } else if ((sceneFog as Fog).isFog) {
+                        const color = reference('color', 'color', sceneFog as Fog).setGroup(renderGroup);
+                        const near = reference('near', 'float', sceneFog as Fog).setGroup(renderGroup);
+                        const far = reference('far', 'float', sceneFog as Fog).setGroup(renderGroup);
 
                         return fog(color, rangeFogFactor(near, far));
                     } else {
@@ -542,14 +599,14 @@ class NodeManager extends DataMap {
      *
      * @param {Scene} scene - The scene.
      */
-    updateEnvironment(scene) {
+    updateEnvironment(scene: Scene) {
         const sceneData = this.get(scene);
         const environment = scene.environment;
 
         if (environment) {
             if (sceneData.environment !== environment) {
                 const environmentNode = this.getCacheNode('environment', environment, () => {
-                    if (environment.isCubeTexture === true) {
+                    if ((environment as CubeTexture).isCubeTexture === true) {
                         return cubeTexture(environment);
                     } else if (environment.isTexture === true) {
                         return texture(environment);
@@ -567,7 +624,13 @@ class NodeManager extends DataMap {
         }
     }
 
-    getNodeFrame(renderer = this.renderer, scene = null, object = null, camera = null, material = null) {
+    getNodeFrame(
+        renderer = this.renderer,
+        scene: Scene | null = null,
+        object: Object3D | null = null,
+        camera: Camera | null = null,
+        material: Material | null = null,
+    ) {
         const nodeFrame = this.nodeFrame;
         nodeFrame.renderer = renderer;
         nodeFrame.scene = scene;
@@ -578,7 +641,7 @@ class NodeManager extends DataMap {
         return nodeFrame;
     }
 
-    getNodeFrameForRender(renderObject) {
+    getNodeFrameForRender(renderObject: RenderObject) {
         return this.getNodeFrame(
             renderObject.renderer,
             renderObject.scene,
@@ -606,7 +669,7 @@ class NodeManager extends DataMap {
      * @param {Texture} outputTarget - The output target.
      * @return {boolean} Whether the output configuration has changed or not.
      */
-    hasOutputChange(outputTarget) {
+    hasOutputChange(outputTarget: Texture) {
         const cacheKey = _outputNodeMap.get(outputTarget);
 
         return cacheKey !== this.getOutputCacheKey();
@@ -619,11 +682,11 @@ class NodeManager extends DataMap {
      * @param {Texture} outputTarget - The output target.
      * @return {Node} The output node.
      */
-    getOutputNode(outputTarget) {
+    getOutputNode(outputTarget: Texture) {
         const renderer = this.renderer;
         const cacheKey = this.getOutputCacheKey();
 
-        const output = outputTarget.isArrayTexture
+        const output: Node = outputTarget.isArrayTexture
             ? texture3D(outputTarget, vec3(screenUV, builtin('gl_ViewID_OVR'))).renderOutput(
                   renderer.toneMapping,
                   renderer.currentColorSpace,
@@ -641,7 +704,7 @@ class NodeManager extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateBefore(renderObject) {
+    updateBefore(renderObject: RenderObject) {
         const nodeBuilder = renderObject.getNodeBuilderState();
 
         for (const node of nodeBuilder.updateBeforeNodes) {
@@ -657,7 +720,7 @@ class NodeManager extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateAfter(renderObject) {
+    updateAfter(renderObject: RenderObject) {
         const nodeBuilder = renderObject.getNodeBuilderState();
 
         for (const node of nodeBuilder.updateAfterNodes) {
@@ -673,7 +736,7 @@ class NodeManager extends DataMap {
      *
      * @param {Node} computeNode - The compute node.
      */
-    updateForCompute(computeNode) {
+    updateForCompute(computeNode: ComputeNode) {
         const nodeFrame = this.getNodeFrame();
         const nodeBuilder = this.getForCompute(computeNode);
 
@@ -688,7 +751,7 @@ class NodeManager extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         const nodeFrame = this.getNodeFrameForRender(renderObject);
         const nodeBuilder = renderObject.getNodeBuilderState();
 
@@ -703,7 +766,7 @@ class NodeManager extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {boolean} Whether the given render object requires a refresh or not.
      */
-    needsRefresh(renderObject) {
+    needsRefresh(renderObject: RenderObject) {
         const nodeFrame = this.getNodeFrameForRender(renderObject);
         const monitor = renderObject.getMonitor();
 
@@ -722,4 +785,4 @@ class NodeManager extends DataMap {
     }
 }
 
-export default NodeManager;
+export default Nodes;
diff --git a/src-testing/src/renderers/common/nodes/NodeUniform.ts b/src-testing/src/renderers/common/nodes/NodeUniform.ts
index 81d9f2ce3..d9d3f0941 100644
--- a/src-testing/src/renderers/common/nodes/NodeUniform.ts
+++ b/src-testing/src/renderers/common/nodes/NodeUniform.ts
@@ -8,21 +8,28 @@ import {
     Matrix3Uniform,
     Matrix4Uniform,
 } from '../Uniform.js';
+import NodeUniform from '../../../nodes/core/NodeUniform.js';
+import { Vector2 } from '../../../math/Vector2.js';
+import { Vector3 } from '../../../math/Vector3.js';
+import { Vector4 } from '../../../math/Vector4.js';
+import { Color } from '../../../math/Color.js';
+import { Matrix2 } from '../../../math/Matrix2.js';
+import { Matrix3 } from '../../../math/Matrix3.js';
+import { Matrix4 } from '../../../math/Matrix4.js';
 
 /**
  * A special form of Number uniform binding type.
  * It's value is managed by a node object.
- *
- * @private
- * @augments NumberUniform
  */
-class NumberNodeUniform extends NumberUniform {
+class NumberNodeUniform<TNodeType> extends NumberUniform {
+    nodeUniform: NodeUniform<TNodeType, number>;
+
     /**
      * Constructs a new node-based Number uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<TNodeType, number>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -55,17 +62,16 @@ class NumberNodeUniform extends NumberUniform {
 /**
  * A special form of Vector2 uniform binding type.
  * It's value is managed by a node object.
- *
- * @private
- * @augments Vector2Uniform
  */
-class Vector2NodeUniform extends Vector2Uniform {
+class Vector2NodeUniform<TNodeType> extends Vector2Uniform {
+    nodeUniform: NodeUniform<TNodeType, Vector2>;
+
     /**
      * Constructs a new node-based Vector2 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<TNodeType, Vector2>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -98,17 +104,16 @@ class Vector2NodeUniform extends Vector2Uniform {
 /**
  * A special form of Vector3 uniform binding type.
  * It's value is managed by a node object.
- *
- * @private
- * @augments Vector3Uniform
  */
-class Vector3NodeUniform extends Vector3Uniform {
+class Vector3NodeUniform<TNodeType> extends Vector3Uniform {
+    nodeUniform: NodeUniform<TNodeType, Vector3>;
+
     /**
      * Constructs a new node-based Vector3 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<TNodeType, Vector3>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -141,17 +146,16 @@ class Vector3NodeUniform extends Vector3Uniform {
 /**
  * A special form of Vector4 uniform binding type.
  * It's value is managed by a node object.
- *
- * @private
- * @augments Vector4Uniform
  */
-class Vector4NodeUniform extends Vector4Uniform {
+class Vector4NodeUniform<TNodeType> extends Vector4Uniform {
+    nodeUniform: NodeUniform<TNodeType, Vector4>;
+
     /**
      * Constructs a new node-based Vector4 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<TNodeType, Vector4>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -184,17 +188,16 @@ class Vector4NodeUniform extends Vector4Uniform {
 /**
  * A special form of Color uniform binding type.
  * It's value is managed by a node object.
- *
- * @private
- * @augments ColorUniform
  */
-class ColorNodeUniform extends ColorUniform {
+class ColorNodeUniform<TNodeType> extends ColorUniform {
+    nodeUniform: NodeUniform<TNodeType, Color>;
+
     /**
      * Constructs a new node-based Color uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<TNodeType, Color>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -227,17 +230,16 @@ class ColorNodeUniform extends ColorUniform {
 /**
  * A special form of Matrix2 uniform binding type.
  * It's value is managed by a node object.
- *
- * @private
- * @augments Matrix2Uniform
  */
-class Matrix2NodeUniform extends Matrix2Uniform {
+class Matrix2NodeUniform<TNodeType> extends Matrix2Uniform {
+    nodeUniform: NodeUniform<TNodeType, Matrix2>;
+
     /**
      * Constructs a new node-based Matrix2 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<TNodeType, Matrix2>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -270,17 +272,16 @@ class Matrix2NodeUniform extends Matrix2Uniform {
 /**
  * A special form of Matrix3 uniform binding type.
  * It's value is managed by a node object.
- *
- * @private
- * @augments Matrix3Uniform
  */
-class Matrix3NodeUniform extends Matrix3Uniform {
+class Matrix3NodeUniform<TNodeType> extends Matrix3Uniform {
+    nodeUniform: NodeUniform<TNodeType, Matrix3>;
+
     /**
      * Constructs a new node-based Matrix3 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<TNodeType, Matrix3>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -313,17 +314,16 @@ class Matrix3NodeUniform extends Matrix3Uniform {
 /**
  * A special form of Matrix4 uniform binding type.
  * It's value is managed by a node object.
- *
- * @private
- * @augments Matrix4Uniform
  */
-class Matrix4NodeUniform extends Matrix4Uniform {
+class Matrix4NodeUniform<TNodeType> extends Matrix4Uniform {
+    nodeUniform: NodeUniform<TNodeType, Matrix4>;
+
     /**
      * Constructs a new node-based Matrix4 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<TNodeType, Matrix4>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -363,3 +363,11 @@ export {
     Matrix3NodeUniform,
     Matrix4NodeUniform,
 };
+export type NodeUniformGPU =
+    | NumberNodeUniform<unknown>
+    | Vector2NodeUniform<unknown>
+    | Vector3NodeUniform<unknown>
+    | Vector4NodeUniform<unknown>
+    | ColorNodeUniform<unknown>
+    | Matrix3NodeUniform<unknown>
+    | Matrix4NodeUniform<unknown>;
diff --git a/src-testing/src/renderers/common/nodes/NodeUniformsGroup.ts b/src-testing/src/renderers/common/nodes/NodeUniformsGroup.ts
index 19a8dd2ae..eac230ab2 100644
--- a/src-testing/src/renderers/common/nodes/NodeUniformsGroup.ts
+++ b/src-testing/src/renderers/common/nodes/NodeUniformsGroup.ts
@@ -1,22 +1,25 @@
 import UniformsGroup from '../UniformsGroup.js';
+import { UniformGroupNode } from '../../../nodes/Nodes.js';
 
 let _id = 0;
 
 /**
  * A special form of uniforms group that represents
  * the individual uniforms as node-based uniforms.
- *
- * @private
- * @augments UniformsGroup
  */
 class NodeUniformsGroup extends UniformsGroup {
+    id: number;
+    groupNode: UniformGroupNode;
+
+    readonly isNodeUniformsGroup: true;
+
     /**
      * Constructs a new node-based uniforms group.
      *
      * @param {string} name - The group's name.
      * @param {UniformGroupNode} groupNode - The uniform group node.
      */
-    constructor(name, groupNode) {
+    constructor(name: string, groupNode: UniformGroupNode) {
         super(name);
 
         /**
diff --git a/src-testing/src/renderers/webgl-fallback/WebGLBackend.ts b/src-testing/src/renderers/webgl-fallback/WebGLBackend.ts
index 796e7b954..c08b91b0d 100644
--- a/src-testing/src/renderers/webgl-fallback/WebGLBackend.ts
+++ b/src-testing/src/renderers/webgl-fallback/WebGLBackend.ts
@@ -14,6 +14,7 @@ import { WebGLBufferRenderer } from './WebGLBufferRenderer.js';
 import { isTypedArray, warnOnce, warn, error } from '../../utils.js';
 import { WebGLCoordinateSystem, TimestampQuery, Compatibility } from '../../constants.js';
 import WebGLTimestampQueryPool from './utils/WebGLTimestampQueryPool.js';
+import { Texture } from '../../textures/Texture.js';
 
 /**
  * A backend implementation targeting WebGL 2.
@@ -1129,7 +1130,14 @@ class WebGLBackend extends Backend {
      * @param {number} faceIndex - The face index.
      * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
      */
-    async copyTextureToBuffer(texture, x, y, width, height, faceIndex) {
+    async copyTextureToBuffer(
+        texture: Texture,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+        faceIndex: number,
+    ) {
         return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);
     }
 
diff --git a/src-testing/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.ts b/src-testing/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.ts
index a37c89a20..70d6ce093 100644
--- a/src-testing/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.ts
+++ b/src-testing/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.ts
@@ -1,4 +1,11 @@
-import { GLSLNodeParser, NodeBuilder, TextureNode, vectorComponents, CodeNode } from '../../../nodes/Nodes.js';
+import {
+    GLSLNodeParser,
+    NodeBuilder,
+    NodeShaderStage,
+    TextureNode,
+    vectorComponents,
+    CodeNode,
+} from '../../../nodes/Nodes.js';
 
 import NodeUniformBuffer from '../../common/nodes/NodeUniformBuffer.js';
 import NodeUniformsGroup from '../../common/nodes/NodeUniformsGroup.js';
@@ -29,6 +36,17 @@ import {
 } from '../../../constants.js';
 import { DataTexture } from '../../../textures/DataTexture.js';
 import { error } from '../../../utils.js';
+import Renderer from '../../common/Renderer.js';
+import StructTypeNode from '../../../nodes/core/StructTypeNode.js';
+import BufferAttributeNode from '../../../nodes/accessors/BufferAttributeNode.js';
+import UniformNode from '../../../nodes/core/UniformNode.js';
+import { Object3D } from '../../../core/Object3D.js';
+import { Texture } from '../../../textures/Texture.js';
+import { BufferAttribute } from '../../../core/BufferAttribute.js';
+import { InterleavedBufferAttribute } from '../../../core/InterleavedBufferAttribute.js';
+import { ShaderNodeInternal } from '../../../nodes/tsl/TSLCore.js';
+import StorageBufferNode from '../../../nodes/accessors/StorageBufferNode.js';
+import StorageArrayElementNode from '../../../nodes/utils/StorageArrayElementNode.js';
 
 const glslPolyfills = {
     bitcast_int_uint: new CodeNode(
@@ -39,7 +57,7 @@ const glslPolyfills = {
     ),
 };
 
-const glslMethods = {
+const glslMethods: { [method: string]: string } = {
     textureDimensions: 'textureSize',
     equals: 'equal',
     bitcast_float_int: 'floatBitsToInt',
@@ -99,6 +117,23 @@ precision highp sampler2DArrayShadow;
 precision highp samplerCubeShadow;
 `;
 
+export interface Transform {
+    varyingName: string | null | undefined;
+    attributeNode: BufferAttributeNode;
+}
+
+interface StageData {
+    extensions?: string | undefined;
+    uniforms?: string | undefined;
+    attributes?: string | undefined;
+    varyings?: string | undefined;
+    vars?: string | undefined;
+    structs?: string | undefined;
+    codes?: string | undefined;
+    transforms?: string | undefined;
+    flow?: string | undefined;
+}
+
 /**
  * A node builder targeting GLSL.
  *
@@ -110,13 +145,25 @@ precision highp samplerCubeShadow;
  * @augments NodeBuilder
  */
 class GLSLNodeBuilder extends NodeBuilder {
+    uniformGroups: {
+        vertex?: { [groupName: string]: NodeUniformsGroup | undefined };
+        fragment?: { [groupName: string]: NodeUniformsGroup | undefined };
+        compute?: { [groupName: string]: NodeUniformsGroup | undefined };
+    };
+    transforms: Transform[];
+    extensions: {
+        vertex?: Map<string, string>;
+        fragment?: Map<string, string>;
+        compute?: Map<string, string>;
+    };
+
     /**
      * Constructs a new GLSL node builder renderer.
      *
      * @param {Object3D} object - The 3D object.
      * @param {Renderer} renderer - The renderer.
      */
-    constructor(object, renderer) {
+    constructor(object: Object3D, renderer: Renderer) {
         super(object, renderer, new GLSLNodeParser());
 
         /**
@@ -183,11 +230,10 @@ class GLSLNodeBuilder extends NodeBuilder {
      * @param {string} method - The method name to resolve.
      * @return {string} The resolved GLSL method name.
      */
-    getMethod(method) {
+    getMethod(method: string) {
         if (glslPolyfills[method] !== undefined) {
             this._include(method);
         }
-
         return glslMethods[method] || method;
     }
 
@@ -249,7 +295,7 @@ class GLSLNodeBuilder extends NodeBuilder {
      * @param {ShaderNodeInternal} shaderNode - The shader node.
      * @return {string} The GLSL function code.
      */
-    buildFunctionCode(shaderNode) {
+    buildFunctionCode(shaderNode: ShaderNodeInternal) {
         const layout = shaderNode.layout;
         const flowData = this.flowShaderNode(shaderNode);
 
@@ -281,7 +327,7 @@ ${flowData.code}
      *
      * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
      */
-    setupPBO(storageBufferNode) {
+    setupPBO(storageBufferNode: StorageBufferNode) {
         const attribute = storageBufferNode.value;
 
         if (attribute.pbo === undefined) {
@@ -352,7 +398,7 @@ ${flowData.code}
      * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
      * @return {string} The property name.
      */
-    getPropertyName(node, shaderStage = this.shaderStage) {
+    getPropertyName(node: unknown, shaderStage = this.shaderStage) {
         if (node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true) {
             return node.name;
         }
@@ -367,7 +413,7 @@ ${flowData.code}
      * @param {StorageArrayElementNode} storageArrayElementNode - The storage array element node.
      * @return {string} The property name.
      */
-    generatePBO(storageArrayElementNode) {
+    generatePBO(storageArrayElementNode: StorageArrayElementNode) {
         const { node, indexNode } = storageArrayElementNode;
         const attribute = node.value;
 
@@ -455,7 +501,14 @@ ${flowData.code}
      * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
      * @return {string} The GLSL snippet.
      */
-    generateTextureLoad(texture, textureProperty, uvIndexSnippet, levelSnippet, depthSnippet, offsetSnippet) {
+    generateTextureLoad(
+        texture: Texture | null,
+        textureProperty: string | undefined,
+        uvIndexSnippet: string,
+        depthSnippet: string | null,
+        offsetSnippet: string,
+        levelSnippet = '0',
+    ) {
         if (levelSnippet === null) levelSnippet = '0';
 
         let snippet;
@@ -491,9 +544,14 @@ ${flowData.code}
      * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
      * @return {string} The GLSL snippet.
      */
-    generateTexture(texture, textureProperty, uvSnippet, depthSnippet, offsetSnippet) {
+    generateTexture(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string,
+        depthSnippet: string | null,
+        offsetSnippet: string | null,
+    ) {
         if (depthSnippet) uvSnippet = `vec3( ${uvSnippet}, ${depthSnippet} )`;
-
         if (texture.isDepthTexture) {
             if (offsetSnippet) return `textureOffset( ${textureProperty}, ${uvSnippet}, ${offsetSnippet} ).x`;
 
@@ -515,7 +573,13 @@ ${flowData.code}
      * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
      * @return {string} The GLSL snippet.
      */
-    generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, offsetSnippet) {
+    generateTextureLevel(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string,
+        levelSnippet: string,
+        offsetSnippet: string | null,
+    ) {
         if (offsetSnippet) {
             return `textureLodOffset( ${textureProperty}, ${uvSnippet}, ${levelSnippet}, ${offsetSnippet} )`;
         }
@@ -533,7 +597,13 @@ ${flowData.code}
      * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
      * @return {string} The GLSL snippet.
      */
-    generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet, offsetSnippet) {
+    generateTextureBias(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string,
+        biasSnippet: string,
+        offsetSnippet: string | null,
+    ) {
         if (offsetSnippet) {
             return `textureOffset( ${textureProperty}, ${uvSnippet}, ${offsetSnippet}, ${biasSnippet} )`;
         }
@@ -551,7 +621,13 @@ ${flowData.code}
      * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
      * @return {string} The GLSL snippet.
      */
-    generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, offsetSnippet) {
+    generateTextureGrad(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string,
+        gradSnippet: [string, string] | null,
+        offsetSnippet: string | null,
+    ) {
         if (offsetSnippet) {
             return `textureGradOffset( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]}, ${offsetSnippet} )`;
         }
@@ -573,11 +649,11 @@ ${flowData.code}
      * @return {string} The GLSL snippet.
      */
     generateTextureCompare(
-        texture,
-        textureProperty,
-        uvSnippet,
-        compareSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        compareSnippet: string | null,
+        depthSnippet: string | null,
         offsetSnippet,
         shaderStage = this.shaderStage,
     ) {
@@ -602,6 +678,7 @@ ${flowData.code}
             return `texture( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ) )`;
         } else {
             error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);
+            return undefined as unknown as string;
         }
     }
 
@@ -611,8 +688,8 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the variables.
      */
-    getVars(shaderStage) {
-        const snippets = [];
+    getVars(shaderStage: 'vertex' | 'fragment' | 'compute') {
+        const snippets: string[] = [];
 
         const vars = this.vars[shaderStage];
 
@@ -631,7 +708,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the uniforms.
      */
-    getUniforms(shaderStage) {
+    getUniforms(shaderStage: 'vertex' | 'fragment' | 'compute') {
         const uniforms = this.uniforms[shaderStage];
 
         const bindingSnippets = [];
@@ -747,7 +824,7 @@ ${flowData.code}
      * @param {BufferAttribute} attribute - The buffer attribute.
      * @return {string} The type.
      */
-    getTypeFromAttribute(attribute) {
+    getTypeFromAttribute(attribute: BufferAttribute | InterleavedBufferAttribute) {
         let nodeType = super.getTypeFromAttribute(attribute);
 
         if (/^[iu]/.test(nodeType) && attribute.gpuType !== IntType) {
@@ -771,7 +848,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the shader attributes.
      */
-    getAttributes(shaderStage) {
+    getAttributes(shaderStage: NodeShaderStage) {
         let snippet = '';
 
         if (shaderStage === 'vertex' || shaderStage === 'compute') {
@@ -793,8 +870,8 @@ ${flowData.code}
      * @param {StructTypeNode} struct - The struct type node.
      * @return {string} The GLSL snippet that defines the struct members.
      */
-    getStructMembers(struct) {
-        const snippets = [];
+    getStructMembers(struct: StructTypeNode) {
+        const snippets: string[] = [];
 
         for (const member of struct.members) {
             snippets.push(`\t${member.type} ${member.name};`);
@@ -809,7 +886,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the structs.
      */
-    getStructs(shaderStage) {
+    getStructs(shaderStage: NodeShaderStage) {
         const snippets = [];
         const structs = this.structs[shaderStage];
 
@@ -842,7 +919,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the varyings.
      */
-    getVaryings(shaderStage) {
+    getVaryings(shaderStage: NodeShaderStage) {
         let snippet = '';
 
         const varyings = this.varyings;
@@ -998,7 +1075,7 @@ ${flowData.code}
      * @param {string} behavior - The extension behavior.
      * @param {string} [shaderStage=this.shaderStage] - The shader stage.
      */
-    enableExtension(name, behavior, shaderStage = this.shaderStage) {
+    enableExtension(name: string, behavior: string, shaderStage = this.shaderStage!) {
         const map = this.extensions[shaderStage] || (this.extensions[shaderStage] = new Map());
 
         if (map.has(name) === false) {
@@ -1015,7 +1092,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the enabled extensions.
      */
-    getExtensions(shaderStage) {
+    getExtensions(shaderStage: NodeShaderStage) {
         const snippets = [];
 
         if (shaderStage === 'vertex') {
@@ -1053,7 +1130,7 @@ ${flowData.code}
      * @param {string} name - The requested feature.
      * @return {boolean} Whether the requested feature is supported or not.
      */
-    isAvailable(name) {
+    isAvailable(name: string) {
         let result = supports[name];
 
         if (result === undefined) {
@@ -1122,7 +1199,7 @@ ${flowData.code}
      * @param {string} varyingName - The varying name.
      * @param {AttributeNode} attributeNode - The attribute node.
      */
-    registerTransform(varyingName, attributeNode) {
+    registerTransform(varyingName: string | null | undefined, attributeNode: BufferAttributeNode) {
         this.transforms.push({ varyingName, attributeNode });
     }
 
@@ -1132,7 +1209,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the transforms.
      */
-    getTransforms(/* shaderStage  */) {
+    getTransforms(shaderStage: NodeShaderStage) {
         const transforms = this.transforms;
 
         let snippet = '';
@@ -1155,7 +1232,7 @@ ${flowData.code}
      * @param {string} vars - The struct variables.
      * @return {string} The GLSL snippet representing a struct.
      */
-    _getGLSLUniformStruct(name, vars) {
+    _getGLSLUniformStruct(name: string, vars: string) {
         return `
 layout( std140 ) uniform ${name} {
 ${vars}
@@ -1169,7 +1246,7 @@ ${vars}
      * @param {Object} shaderData - The shader data.
      * @return {string} The vertex shader.
      */
-    _getGLSLVertexCode(shaderData) {
+    _getGLSLVertexCode(shaderData: StageData) {
         return `#version 300 es
 
 ${this.getSignature()}
@@ -1216,7 +1293,7 @@ void main() {
      * @param {Object} shaderData - The shader data.
      * @return {string} The vertex shader.
      */
-    _getGLSLFragmentCode(shaderData) {
+    _getGLSLFragmentCode(shaderData: StageData) {
         return `#version 300 es
 
 ${this.getSignature()}
@@ -1255,19 +1332,20 @@ void main() {
      * Controls the code build of the shader stages.
      */
     buildCode() {
-        const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
+        const shadersData: { fragment?: StageData; vertex?: StageData; compute?: StageData } =
+            this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
 
         this.sortBindingGroups();
 
         for (const shaderStage in shadersData) {
             let flow = '// code\n\n';
-            flow += this.flowCode[shaderStage];
+            flow += this.flowCode[shaderStage as NodeShaderStage];
 
-            const flowNodes = this.flowNodes[shaderStage];
+            const flowNodes = this.flowNodes[shaderStage as NodeShaderStage];
             const mainNode = flowNodes[flowNodes.length - 1];
 
             for (const node of flowNodes) {
-                const flowSlotData = this.getFlowData(node /*, shaderStage*/);
+                const flowSlotData = this.getFlowData(node /*, shaderStage*/)!;
                 const slotName = node.name;
 
                 if (slotName) {
@@ -1293,24 +1371,24 @@ void main() {
                 }
             }
 
-            const stageData = shadersData[shaderStage];
+            const stageData = shadersData[shaderStage as NodeShaderStage]!;
 
-            stageData.extensions = this.getExtensions(shaderStage);
-            stageData.uniforms = this.getUniforms(shaderStage);
-            stageData.attributes = this.getAttributes(shaderStage);
-            stageData.varyings = this.getVaryings(shaderStage);
-            stageData.vars = this.getVars(shaderStage);
-            stageData.structs = this.getStructs(shaderStage);
-            stageData.codes = this.getCodes(shaderStage);
-            stageData.transforms = this.getTransforms(shaderStage);
+            stageData.extensions = this.getExtensions(shaderStage as NodeShaderStage);
+            stageData.uniforms = this.getUniforms(shaderStage as NodeShaderStage);
+            stageData.attributes = this.getAttributes(shaderStage as NodeShaderStage);
+            stageData.varyings = this.getVaryings(shaderStage as NodeShaderStage);
+            stageData.vars = this.getVars(shaderStage as NodeShaderStage);
+            stageData.structs = this.getStructs(shaderStage as NodeShaderStage);
+            stageData.codes = this.getCodes(shaderStage as NodeShaderStage);
+            stageData.transforms = this.getTransforms(shaderStage as NodeShaderStage);
             stageData.flow = flow;
         }
 
         if (this.material !== null) {
-            this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);
-            this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);
+            this.vertexShader = this._getGLSLVertexCode(shadersData.vertex!);
+            this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment!);
         } else {
-            this.computeShader = this._getGLSLVertexCode(shadersData.compute);
+            this.computeShader = this._getGLSLVertexCode(shadersData.compute!);
         }
     }
 
@@ -1327,7 +1405,12 @@ void main() {
      * @param {?string} [name=null] - An optional uniform name.
      * @return {NodeUniform} The node uniform object.
      */
-    getUniformFromNode(node, type, shaderStage, name = null) {
+    getUniformFromNode(
+        node: UniformNode<unknown>,
+        type: string | null,
+        shaderStage: 'vertex' | 'fragment' | 'compute',
+        name: string | null = null,
+    ) {
         const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
diff --git a/src-testing/src/renderers/webgpu/WebGPUBackend.ts b/src-testing/src/renderers/webgpu/WebGPUBackend.ts
index d9c4bd9dd..42d317c37 100644
--- a/src-testing/src/renderers/webgpu/WebGPUBackend.ts
+++ b/src-testing/src/renderers/webgpu/WebGPUBackend.ts
@@ -1696,7 +1696,14 @@ class WebGPUBackend extends Backend {
      * @param {number} faceIndex - The face index.
      * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
      */
-    async copyTextureToBuffer(texture, x, y, width, height, faceIndex) {
+    async copyTextureToBuffer(
+        texture: Texture,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+        faceIndex: number,
+    ) {
         return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);
     }
 
diff --git a/src-testing/src/renderers/webgpu/nodes/StandardNodeLibrary.ts b/src-testing/src/renderers/webgpu/nodes/StandardNodeLibrary.ts
index 37784a05b..7b08961ad 100644
--- a/src-testing/src/renderers/webgpu/nodes/StandardNodeLibrary.ts
+++ b/src-testing/src/renderers/webgpu/nodes/StandardNodeLibrary.ts
@@ -59,6 +59,20 @@ import {
     neutralToneMapping,
 } from '../../../nodes/display/ToneMappingFunctions.js';
 
+import { MeshPhongNodeMaterialNodeProperties } from '../../../materials/nodes/MeshPhongNodeMaterial.js';
+import { MeshStandardNodeMaterialNodeProperties } from '../../../materials/nodes/MeshStandardNodeMaterial.js';
+import { MeshPhysicalNodeMaterialNodeProperties } from '../../../materials/nodes/MeshPhysicalNodeMaterial.js';
+import { MeshToonNodeMaterialNodeProperties } from '../../../materials/nodes/MeshToonNodeMaterial.js';
+import { MeshBasicNodeMaterialNodeProperties } from '../../../materials/nodes/MeshBasicNodeMaterial.js';
+import { MeshLambertNodeMaterialNodeProperties } from '../../../materials/nodes/MeshLambertNodeMaterial.js';
+import { MeshNormalNodeMaterialNodeProperties } from '../../../materials/nodes/MeshNormalNodeMaterial.js';
+import { MeshMatcapNodeMaterialNodeProperties } from '../../../materials/nodes/MeshMatcapNodeMaterial.js';
+import { LineBasicNodeMaterialNodeProperties } from '../../../materials/nodes/LineBasicNodeMaterial.js';
+import { LineDashedNodeMaterialNodeProperties } from '../../../materials/nodes/LineDashedNodeMaterial.js';
+import { PointsNodeMaterialNodeProperties } from '../../../materials/nodes/PointsNodeMaterial.js';
+import { SpriteNodeMaterialNodeProperties } from '../../../materials/nodes/SpriteNodeMaterial.js';
+import { ShadowNodeMaterialNodeProperties } from '../../../materials/nodes/ShadowNodeMaterial.js';
+
 /**
  * This version of a node library represents the standard version
  * used in {@link WebGPURenderer}. It maps lights, tone mapping
@@ -107,4 +121,56 @@ class StandardNodeLibrary extends NodeLibrary {
     }
 }
 
+declare module '../../../materials/MeshPhongMaterial.js' {
+    export interface MeshPhongMaterialProperties extends MeshPhongNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/MeshStandardMaterial.js' {
+    export interface MeshStandardMaterialProperties extends MeshStandardNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/MeshPhysicalMaterial.js' {
+    export interface MeshPhysicalMaterialProperties extends MeshPhysicalNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/MeshToonMaterial.js' {
+    export interface MeshToonMaterialProperties extends MeshToonNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/MeshBasicMaterial.js' {
+    export interface MeshBasicMaterialProperties extends MeshBasicNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/MeshLambertMaterial.js' {
+    export interface MeshLambertMaterialProperties extends MeshLambertNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/MeshNormalMaterial.js' {
+    export interface MeshNormalMaterialProperties extends MeshNormalNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/MeshMatcapMaterial.js' {
+    export interface MeshMatcapMaterialProperties extends MeshMatcapNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/LineBasicMaterial.js' {
+    export interface LineBasicMaterialProperties extends LineBasicNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/LineDashedMaterial.js' {
+    export interface LineDashedMaterialProperties extends LineDashedNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/PointsMaterial.js' {
+    export interface PointsMaterialProperties extends PointsNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/SpriteMaterial.js' {
+    export interface SpriteMaterialProperties extends SpriteNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/ShadowMaterial.js' {
+    export interface ShadowMaterialProperties extends ShadowNodeMaterialNodeProperties {}
+}
+
 export default StandardNodeLibrary;
diff --git a/src-testing/src/renderers/webgpu/nodes/WGSLNodeBuilder.ts b/src-testing/src/renderers/webgpu/nodes/WGSLNodeBuilder.ts
index 1e3d6c572..5d77f3cd1 100644
--- a/src-testing/src/renderers/webgpu/nodes/WGSLNodeBuilder.ts
+++ b/src-testing/src/renderers/webgpu/nodes/WGSLNodeBuilder.ts
@@ -10,7 +10,7 @@ import {
 import NodeUniformBuffer from '../../common/nodes/NodeUniformBuffer.js';
 import NodeStorageBuffer from '../../common/nodes/NodeStorageBuffer.js';
 
-import { NodeBuilder, CodeNode } from '../../../nodes/Nodes.js';
+import { NodeBuilder, CodeNode, NodeShaderStage, ShaderNodeInternal } from '../../../nodes/Nodes.js';
 
 import { getFormat } from '../utils/WebGPUTextureUtils.js';
 
@@ -31,6 +31,8 @@ import {
 import { warn, error } from '../../../utils.js';
 
 import { GPUShaderStage } from '../utils/WebGPUConstants.js';
+import { Texture } from '../../../textures/Texture.js';
+import UniformNode from '../../../nodes/core/UniformNode.js';
 
 const accessNames = {
     [NodeAccess.READ_ONLY]: 'read',
@@ -238,11 +240,11 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @return {string} The WGSL snippet.
      */
     _generateTextureSample(
-        texture,
-        textureProperty,
-        uvSnippet,
-        depthSnippet,
-        offsetSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string,
+        depthSnippet: string | null,
+        offsetSnippet: string | null,
         shaderStage = this.shaderStage,
     ) {
         if (shaderStage === 'fragment') {
@@ -466,7 +468,14 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
      * @return {string} The WGSL snippet.
      */
-    generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, offsetSnippet, levelSnippet = '0u') {
+    generateTextureLod(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string,
+        depthSnippet: string | null,
+        offsetSnippet: string | null,
+        levelSnippet: string = '0u',
+    ) {
         // Cube textures cannot use textureLoad in WGSL, must use textureSampleLevel
         if (texture.isCubeTexture === true) {
             if (offsetSnippet) {
@@ -504,7 +513,14 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
      * @return {string} The WGSL snippet.
      */
-    generateTextureLoad(texture, textureProperty, uvIndexSnippet, levelSnippet, depthSnippet, offsetSnippet) {
+    generateTextureLoad(
+        texture: Texture,
+        textureProperty: string,
+        uvIndexSnippet: string,
+        depthSnippet: string | null,
+        offsetSnippet: string | null,
+        levelSnippet: string = '0u',
+    ) {
         if (levelSnippet === null) levelSnippet = '0u';
 
         if (offsetSnippet) {
@@ -630,11 +646,11 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @return {string} The WGSL snippet.
      */
     generateTextureGrad(
-        texture,
-        textureProperty,
-        uvSnippet,
-        gradSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        gradSnippet: [string, string] | null,
+        depthSnippet: string | null,
         offsetSnippet,
         shaderStage = this.shaderStage,
     ) {
@@ -664,11 +680,11 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @return {string} The WGSL snippet.
      */
     generateTextureCompare(
-        texture,
-        textureProperty,
-        uvSnippet,
-        compareSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        compareSnippet: string | null,
+        depthSnippet: string | null,
         offsetSnippet,
         shaderStage = this.shaderStage,
     ) {
@@ -703,7 +719,14 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
      * @return {string} The WGSL snippet.
      */
-    generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet) {
+    generateTextureLevel(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string,
+        levelSnippet: string,
+        depthSnippet: string | null,
+        offsetSnippet: string | null,
+    ) {
         if (this.isUnfilterable(texture) === false) {
             if (offsetSnippet) {
                 return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet}, ${offsetSnippet} )`;
@@ -737,11 +760,11 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @return {string} The WGSL snippet.
      */
     generateTextureBias(
-        texture,
-        textureProperty,
-        uvSnippet,
-        biasSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        biasSnippet: string | null,
+        depthSnippet: string | null,
         offsetSnippet,
         shaderStage = this.shaderStage,
     ) {
@@ -763,7 +786,7 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
      * @return {string} The property name.
      */
-    getPropertyName(node, shaderStage = this.shaderStage) {
+    getPropertyName(node: unknown, shaderStage = this.shaderStage) {
         if (node.isNodeVarying === true && node.needsInterpolation === true) {
             if (shaderStage === 'vertex') {
                 return `varyings.${node.name}`;
@@ -866,7 +889,12 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {?string} [name=null] - An optional uniform name.
      * @return {NodeUniform} The node uniform object.
      */
-    getUniformFromNode(node, type, shaderStage, name = null) {
+    getUniformFromNode(
+        node: UniformNode<unknown>,
+        type: string | null,
+        shaderStage: NodeShaderStage,
+        name: string | null = null,
+    ) {
         const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
@@ -1034,7 +1062,7 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {ShaderNodeInternal} shaderNode - The shader node.
      * @return {string} The WGSL function code.
      */
-    buildFunctionCode(shaderNode) {
+    buildFunctionCode(shaderNode: ShaderNodeInternal) {
         const layout = shaderNode.layout;
         const flowData = this.flowShaderNode(shaderNode);
 
@@ -1319,8 +1347,8 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The WGSL snippet that defines the shader attributes.
      */
-    getAttributes(shaderStage) {
-        const snippets = [];
+    getAttributes(shaderStage: NodeShaderStage) {
+        const snippets: string[] = [];
 
         if (shaderStage === 'compute') {
             this.getBuiltin('global_invocation_id', 'globalId', 'vec3<u32>', 'attribute');
@@ -1454,8 +1482,8 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The WGSL snippet that defines the varyings.
      */
-    getVaryings(shaderStage) {
-        const snippets = [];
+    getVaryings(shaderStage: NodeShaderStage) {
+        const snippets: string[] = [];
 
         if (shaderStage === 'vertex') {
             this.getBuiltin('position', 'builtinClipSpace', 'vec4<f32>', 'vertex');
@@ -1520,7 +1548,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The WGSL snippet that defines the uniforms.
      */
-    getUniforms(shaderStage) {
+    getUniforms(shaderStage: NodeShaderStage) {
         const uniforms = this.uniforms[shaderStage];
 
         const bindingSnippets = [];
diff --git a/src-testing/src/renderers/webgpu/nodes/WGSLNodeFunction.ts b/src-testing/src/renderers/webgpu/nodes/WGSLNodeFunction.ts
index 34a933558..6e5e4a86e 100644
--- a/src-testing/src/renderers/webgpu/nodes/WGSLNodeFunction.ts
+++ b/src-testing/src/renderers/webgpu/nodes/WGSLNodeFunction.ts
@@ -138,7 +138,7 @@ class WGSLNodeFunction extends NodeFunction {
      *
      * @param {string} source - The WGSL source.
      */
-    constructor(source) {
+    constructor(source: string) {
         const { type, inputs, name, inputsCode, blockCode, outputType } = parse(source);
 
         super(type, inputs, name);
diff --git a/src-testing/src/renderers/webgpu/nodes/WGSLNodeParser.ts b/src-testing/src/renderers/webgpu/nodes/WGSLNodeParser.ts
index d52f7500d..97fbffe0d 100644
--- a/src-testing/src/renderers/webgpu/nodes/WGSLNodeParser.ts
+++ b/src-testing/src/renderers/webgpu/nodes/WGSLNodeParser.ts
@@ -13,7 +13,7 @@ class WGSLNodeParser extends NodeParser {
      * @param {string} source - The WGSL code.
      * @return {WGSLNodeFunction} A node function.
      */
-    parseFunction(source) {
+    parseFunction(source: string) {
         return new WGSLNodeFunction(source);
     }
 }
