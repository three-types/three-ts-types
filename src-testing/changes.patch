diff --git a/src-testing/src/materials/nodes/manager/NodeMaterialObserver.ts b/src-testing/src/materials/nodes/manager/NodeMaterialObserver.ts
index 5ea42f16..1e92d923 100644
--- a/src-testing/src/materials/nodes/manager/NodeMaterialObserver.ts
+++ b/src-testing/src/materials/nodes/manager/NodeMaterialObserver.ts
@@ -1,3 +1,11 @@
+import NodeBuilder from '../../../nodes/core/NodeBuilder.js';
+import RenderObject from '../../../renderers/common/RenderObject.js';
+import { Matrix4 } from '../../../math/Matrix4.js';
+import { Material } from '../../Material.js';
+import NodeFrame from '../../../nodes/core/NodeFrame.js';
+import { BufferAttribute } from '../../../core/BufferAttribute.js';
+import Renderer from '../../../renderers/common/Renderer.js';
+
 const refreshUniforms = [
     'alphaMap',
     'alphaTest',
@@ -49,7 +57,29 @@ const refreshUniforms = [
     'thickness',
     'transmission',
     'transmissionMap',
-];
+] as const;
+
+type RefreshUniform = (typeof refreshUniforms)[number];
+
+type MaterialData = {
+    [K in RefreshUniform]?: unknown;
+};
+
+interface AttributesData {
+    [name: string]: { version: number };
+}
+
+interface RenderObjectData {
+    material: MaterialData;
+    geometry: {
+        id: number;
+        attributes: AttributesData;
+        indexVersion: number | null;
+        drawRange: { start: number; count: number };
+    };
+    worldMatrix: Matrix4;
+    version?: number;
+}
 
 /**
  * This class is used by {@link WebGPURenderer} as management component.
@@ -57,12 +87,18 @@ const refreshUniforms = [
  * refresh right before they are going to be rendered or not.
  */
 class NodeMaterialObserver {
+    renderObjects: WeakMap<RenderObject, RenderObjectData>;
+    hasNode: boolean;
+    hasAnimation: boolean;
+    refreshUniforms: readonly RefreshUniform[];
+    renderId: number;
+
     /**
      * Constructs a new node material observer.
      *
      * @param {NodeBuilder} builder - The node builder.
      */
-    constructor(builder) {
+    constructor(builder: NodeBuilder) {
         /**
          * A node material can be used by more than one render object so the
          * monitor must maintain a list of render objects.
@@ -107,7 +143,7 @@ class NodeMaterialObserver {
      * @param {RenderObject} renderObject - The render object.
      * @return {boolean} Whether the given render object is verified for the first time of this observer.
      */
-    firstInitialization(renderObject) {
+    firstInitialization(renderObject: RenderObject) {
         const hasInitialized = this.renderObjects.has(renderObject);
 
         if (hasInitialized === false) {
@@ -125,7 +161,7 @@ class NodeMaterialObserver {
      * @param {Renderer} renderer - The renderer.
      * @return {boolean} Whether the current rendering produces motion vectors or not.
      */
-    needsVelocity(renderer) {
+    needsVelocity(renderer: Renderer) {
         const mrt = renderer.getMRT();
 
         return mrt !== null && mrt.has('velocity');
@@ -137,7 +173,7 @@ class NodeMaterialObserver {
      * @param {RenderObject} renderObject - The render object.
      * @return {Object} The monitoring data.
      */
-    getRenderObjectData(renderObject) {
+    getRenderObjectData(renderObject: RenderObject) {
         let data = this.renderObjects.get(renderObject);
 
         if (data === undefined) {
@@ -186,8 +222,8 @@ class NodeMaterialObserver {
      * @param {Object} attributes - The geometry attributes.
      * @return {Object} An object for monitoring the versions of attributes.
      */
-    getAttributesData(attributes) {
-        const attributesData = {};
+    getAttributesData(attributes: Record<string, BufferAttribute>) {
+        const attributesData: AttributesData = {};
 
         for (const name in attributes) {
             const attribute = attributes[name];
@@ -207,7 +243,7 @@ class NodeMaterialObserver {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {boolean} Whether the node builder's material uses node properties or not.
      */
-    containsNode(builder) {
+    containsNode(builder: NodeBuilder) {
         const material = builder.material;
 
         for (const property in material) {
@@ -227,8 +263,8 @@ class NodeMaterialObserver {
      * @param {Material} material - The material.
      * @return {Object} An object for monitoring material properties.
      */
-    getMaterialData(material) {
-        const data = {};
+    getMaterialData(material: Material) {
+        const data: MaterialData = {};
 
         for (const property of this.refreshUniforms) {
             const value = material[property];
@@ -255,7 +291,7 @@ class NodeMaterialObserver {
      * @param {RenderObject} renderObject - The render object.
      * @return {boolean} Whether the given render object has changed its state or not.
      */
-    equals(renderObject) {
+    equals(renderObject: RenderObject) {
         const { object, material, geometry } = renderObject;
 
         const renderObjectData = this.getRenderObjectData(renderObject);
@@ -406,7 +442,7 @@ class NodeMaterialObserver {
      * @param {NodeFrame} nodeFrame - The current node frame.
      * @return {boolean} Whether the given render object requires a refresh or not.
      */
-    needsRefresh(renderObject, nodeFrame) {
+    needsRefresh(renderObject: RenderObject, nodeFrame: NodeFrame) {
         if (
             this.hasNode ||
             this.hasAnimation ||
diff --git a/src-testing/src/nodes/accessors/BufferAttributeNode.ts b/src-testing/src/nodes/accessors/BufferAttributeNode.ts
index d207da78..9c25d5cc 100644
--- a/src-testing/src/nodes/accessors/BufferAttributeNode.ts
+++ b/src-testing/src/nodes/accessors/BufferAttributeNode.ts
@@ -1,10 +1,15 @@
 import InputNode from '../core/InputNode.js';
-import { nodeObject, addMethodChaining } from '../tsl/TSLCore.js';
+import { nodeObject, addMethodChaining, ShaderNodeObject } from '../tsl/TSLCore.js';
 import { varying } from '../core/VaryingNode.js';
 
 import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
 import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
-import { StaticDrawUsage, DynamicDrawUsage } from '../../constants.js';
+import { StaticDrawUsage, DynamicDrawUsage, Usage } from '../../constants.js';
+import { BufferAttribute, TypedArray } from '../../core/BufferAttribute.js';
+import { InstancedBufferAttribute } from '../../core/InstancedBufferAttribute.js';
+import NodeBuilder from '../core/NodeBuilder.js';
+import { array } from '@types/three/src/nodes/core/ArrayNode.js';
+import BufferNode from './BufferNode.js';
 
 /**
  * In earlier `three.js` versions it was only possible to define attribute data
@@ -28,11 +33,22 @@ import { StaticDrawUsage, DynamicDrawUsage } from '../../constants.js';
  * ```
  * @augments InputNode
  */
-class BufferAttributeNode extends InputNode {
+class BufferAttributeNode extends InputNode<TypedArray | InterleavedBuffer | BufferAttribute> {
     static get type() {
         return 'BufferAttributeNode';
     }
 
+    readonly isBufferNode: true;
+
+    bufferType: string | null;
+    bufferStride: number;
+    bufferOffset: number;
+
+    usage: Usage;
+    instanced: boolean;
+
+    attribute: BufferAttribute | InterleavedBufferAttribute | null;
+
     /**
      * Constructs a new buffer attribute node.
      *
@@ -41,7 +57,12 @@ class BufferAttributeNode extends InputNode {
      * @param {number} [bufferStride=0] - The buffer stride.
      * @param {number} [bufferOffset=0] - The buffer offset.
      */
-    constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
+    constructor(
+        value: TypedArray | InterleavedBuffer | BufferAttribute,
+        bufferType: string | null = null,
+        bufferStride = 0,
+        bufferOffset = 0,
+    ) {
         super(value, bufferType);
 
         /**
@@ -110,10 +131,10 @@ class BufferAttributeNode extends InputNode {
          */
         this.global = true;
 
-        if (value && value.isBufferAttribute === true) {
-            this.attribute = value;
-            this.usage = value.usage;
-            this.instanced = value.isInstancedBufferAttribute;
+        if (value && (value as BufferAttribute).isBufferAttribute === true) {
+            this.attribute = value as BufferAttribute;
+            this.usage = (value as BufferAttribute).usage;
+            this.instanced = (value as InstancedBufferAttribute).isInstancedBufferAttribute;
         }
     }
 
@@ -124,7 +145,7 @@ class BufferAttributeNode extends InputNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The hash.
      */
-    getHash(builder) {
+    getHash(builder: NodeBuilder) {
         if (this.bufferStride === 0 && this.bufferOffset === 0) {
             let bufferData = builder.globalCache.getData(this.value);
 
@@ -149,7 +170,7 @@ class BufferAttributeNode extends InputNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The node type.
      */
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         if (this.bufferType === null) {
             this.bufferType = builder.getTypeFromAttribute(this.attribute);
         }
@@ -164,16 +185,19 @@ class BufferAttributeNode extends InputNode {
      *
      * @param {NodeBuilder} builder - The current node builder.
      */
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         if (this.attribute !== null) return;
 
         const type = this.getNodeType(builder);
-        const array = this.value;
+        const array = this.value as TypedArray | InterleavedBuffer;
         const itemSize = builder.getTypeLength(type);
         const stride = this.bufferStride || itemSize;
         const offset = this.bufferOffset;
 
-        const buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer(array, stride);
+        const buffer =
+            (array as InterleavedBuffer).isInterleavedBuffer === true
+                ? (array as InterleavedBuffer)
+                : new InterleavedBuffer(array as TypedArray, stride);
         const bufferAttribute = new InterleavedBufferAttribute(buffer, itemSize, offset);
 
         buffer.setUsage(this.usage);
@@ -188,13 +212,13 @@ class BufferAttributeNode extends InputNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The generated code snippet.
      */
-    generate(builder) {
+    generate(builder: NodeBuilder) {
         const nodeType = this.getNodeType(builder);
 
         const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);
         const propertyName = builder.getPropertyName(nodeAttribute);
 
-        let output = null;
+        let output: string | null | undefined = null;
 
         if (builder.shaderStage === 'vertex' || builder.shaderStage === 'compute') {
             this.name = propertyName;
@@ -225,11 +249,11 @@ class BufferAttributeNode extends InputNode {
      * @param {number} value - The usage to set.
      * @return {BufferAttributeNode} A reference to this node.
      */
-    setUsage(value) {
+    setUsage(value: Usage) {
         this.usage = value;
 
-        if (this.attribute && this.attribute.isBufferAttribute === true) {
-            this.attribute.usage = value;
+        if (this.attribute && (this.attribute as BufferAttribute).isBufferAttribute === true) {
+            (this.attribute as BufferAttribute).usage = value;
         }
 
         return this;
@@ -241,7 +265,7 @@ class BufferAttributeNode extends InputNode {
      * @param {boolean} value - The value to set.
      * @return {BufferAttributeNode} A reference to this node.
      */
-    setInstanced(value) {
+    setInstanced(value: boolean) {
         this.instanced = value;
 
         return this;
@@ -261,8 +285,12 @@ export default BufferAttributeNode;
  * @param {number} [offset=0] - The buffer offset.
  * @returns {BufferAttributeNode}
  */
-export const bufferAttribute = (array, type = null, stride = 0, offset = 0) =>
-    nodeObject(new BufferAttributeNode(array, type, stride, offset));
+export const bufferAttribute = (
+    array: TypedArray | InterleavedBuffer | BufferAttribute,
+    type: string | null = null,
+    stride: number = 0,
+    offset: number = 0,
+) => nodeObject(new BufferAttributeNode(array, type, stride, offset));
 
 /**
  * TSL function for creating a buffer attribute node but with dynamic draw usage.
@@ -276,8 +304,12 @@ export const bufferAttribute = (array, type = null, stride = 0, offset = 0) =>
  * @param {number} [offset=0] - The buffer offset.
  * @returns {BufferAttributeNode}
  */
-export const dynamicBufferAttribute = (array, type = null, stride = 0, offset = 0) =>
-    bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);
+export const dynamicBufferAttribute = (
+    array: TypedArray | InterleavedBuffer | BufferAttribute,
+    type: string | null = null,
+    stride: number = 0,
+    offset: number = 0,
+) => bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);
 
 /**
  * TSL function for creating a buffer attribute node but with enabled instancing
@@ -290,8 +322,12 @@ export const dynamicBufferAttribute = (array, type = null, stride = 0, offset =
  * @param {number} [offset=0] - The buffer offset.
  * @returns {BufferAttributeNode}
  */
-export const instancedBufferAttribute = (array, type = null, stride = 0, offset = 0) =>
-    bufferAttribute(array, type, stride, offset).setInstanced(true);
+export const instancedBufferAttribute = (
+    array: TypedArray | InterleavedBuffer | BufferAttribute,
+    type: string | null = null,
+    stride: number = 0,
+    offset: number = 0,
+) => bufferAttribute(array, type, stride, offset).setInstanced(true);
 
 /**
  * TSL function for creating a buffer attribute node but with dynamic draw usage and enabled instancing
@@ -304,7 +340,17 @@ export const instancedBufferAttribute = (array, type = null, stride = 0, offset
  * @param {number} [offset=0] - The buffer offset.
  * @returns {BufferAttributeNode}
  */
-export const instancedDynamicBufferAttribute = (array, type = null, stride = 0, offset = 0) =>
-    dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);
-
-addMethodChaining('toAttribute', bufferNode => bufferAttribute(bufferNode.value));
+export const instancedDynamicBufferAttribute = (
+    array: TypedArray | InterleavedBuffer | BufferAttribute,
+    type: string | null = null,
+    stride: number = 0,
+    offset: number = 0,
+) => dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);
+
+addMethodChaining('toAttribute', <TValue>(bufferNode: BufferNode<TValue>) => bufferAttribute(bufferNode.value));
+
+declare module '../tsl/TSLCore.js' {
+    interface NodeElements {
+        toAttribute: <TValue>(bufferNode: BufferNode<TValue>) => ShaderNodeObject<BufferAttributeNode>;
+    }
+}
diff --git a/src-testing/src/nodes/accessors/TextureNode.ts b/src-testing/src/nodes/accessors/TextureNode.ts
index facf5957..a1841ec4 100644
--- a/src-testing/src/nodes/accessors/TextureNode.ts
+++ b/src-testing/src/nodes/accessors/TextureNode.ts
@@ -4,21 +4,43 @@ import { textureSize } from './TextureSizeNode.js';
 import { colorSpaceToWorking } from '../display/ColorSpaceNode.js';
 import { expression } from '../code/ExpressionNode.js';
 import { maxMipLevel } from '../utils/MaxMipLevelNode.js';
-import { nodeProxy, vec3, nodeObject, int } from '../tsl/TSLBase.js';
+import { nodeProxy, vec3, nodeObject, int, ShaderNodeObject } from '../tsl/TSLBase.js';
 import { NodeUpdateType } from '../core/constants.js';
 
 import { IntType, NearestFilter, UnsignedIntType } from '../../constants.js';
+import Node from '../core/Node.js';
+import { Texture } from '../../textures/Texture.js';
+import { DepthTexture } from '../../textures/DepthTexture.js';
+import NodeBuilder from '../core/NodeBuilder.js';
+import { Matrix3 } from '../../math/Matrix3.js';
 
 /**
  * This type of uniform node represents a 2D texture.
  *
  * @augments UniformNode
  */
-class TextureNode extends UniformNode {
+class TextureNode extends UniformNode<Texture> {
     static get type() {
         return 'TextureNode';
     }
 
+    readonly isTextureNode: true;
+
+    uvNode: ShaderNodeObject<Node> | null;
+    levelNode: ShaderNodeObject<Node> | null;
+    biasNode: ShaderNodeObject<Node> | null;
+    compareNode: Node | null;
+    depthNode: Node | null;
+    gradNode: Node | null;
+
+    sampler: boolean;
+    updateMatrix: boolean;
+
+    referenceNode: this | null;
+
+    _value: Texture;
+    _matrixUniform: ShaderNodeObject<UniformNode<Matrix3>> | null;
+
     /**
      * Constructs a new texture node.
      *
@@ -27,7 +49,12 @@ class TextureNode extends UniformNode {
      * @param {?Node<int>} [levelNode=null] - The level node.
      * @param {?Node<float>} [biasNode=null] - The bias node.
      */
-    constructor(value, uvNode = null, levelNode = null, biasNode = null) {
+    constructor(
+        value: Texture,
+        uvNode: ShaderNodeObject<Node> | null = null,
+        levelNode: ShaderNodeObject<Node> | null = null,
+        biasNode: ShaderNodeObject<Node> | null = null,
+    ) {
         super(value);
 
         /**
@@ -142,7 +169,7 @@ class TextureNode extends UniformNode {
         this.setUpdateMatrix(uvNode === null);
     }
 
-    set value(value) {
+    set value(value: Texture) {
         if (this.referenceNode) {
             this.referenceNode.value = value;
         } else {
@@ -176,7 +203,7 @@ class TextureNode extends UniformNode {
      * @return {string} The node type.
      */
     getNodeType(/*builder*/) {
-        if (this.value.isDepthTexture === true) return 'float';
+        if ((this.value as DepthTexture).isDepthTexture === true) return 'float';
 
         if (this.value.type === UnsignedIntType) {
             return 'uvec4';
@@ -234,7 +261,7 @@ class TextureNode extends UniformNode {
      * @param {boolean} value - The update toggle.
      * @return {TextureNode} A reference to this node.
      */
-    setUpdateMatrix(value) {
+    setUpdateMatrix(value: boolean) {
         this.updateMatrix = value;
         this.updateType = value ? NodeUpdateType.OBJECT : NodeUpdateType.NONE;
 
@@ -249,7 +276,7 @@ class TextureNode extends UniformNode {
      * @param {Node} uvNode - The uv node to setup.
      * @return {Node} The updated uv node.
      */
-    setupUV(builder, uvNode) {
+    setupUV(builder: NodeBuilder, uvNode) {
         const texture = this.value;
 
         if (
@@ -274,7 +301,7 @@ class TextureNode extends UniformNode {
      *
      * @param {NodeBuilder} builder - The current node builder.
      */
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         const properties = builder.getNodeProperties(this);
         properties.referenceNode = this.referenceNode;
 
@@ -327,7 +354,7 @@ class TextureNode extends UniformNode {
      * @param {Node} uvNode - The uv node to generate code for.
      * @return {string} The generated code snippet.
      */
-    generateUV(builder, uvNode) {
+    generateUV(builder: NodeBuilder, uvNode: Node) {
         return uvNode.build(builder, this.sampler === true ? 'vec2' : 'ivec2');
     }
 
@@ -345,14 +372,14 @@ class TextureNode extends UniformNode {
      * @return {string} The generated code snippet.
      */
     generateSnippet(
-        builder,
-        textureProperty,
-        uvSnippet,
-        levelSnippet,
-        biasSnippet,
-        depthSnippet,
-        compareSnippet,
-        gradSnippet,
+        builder: NodeBuilder,
+        textureProperty: string,
+        uvSnippet: string | null,
+        levelSnippet: string | null,
+        biasSnippet: string | null,
+        depthSnippet: string | null,
+        compareSnippet: string | null,
+        gradSnippet: [string, string] | null,
     ) {
         const texture = this.value;
 
@@ -382,9 +409,8 @@ class TextureNode extends UniformNode {
      * @param {string} output - The current output.
      * @return {string} The generated code snippet.
      */
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output) {
         const texture = this.value;
-
         const properties = builder.getNodeProperties(this);
         const textureProperty = super.generate(builder, 'property');
 
@@ -449,7 +475,7 @@ class TextureNode extends UniformNode {
      * @param {boolean} value - The sampler value to set.
      * @return {TextureNode} A reference to this texture node.
      */
-    setSampler(value) {
+    setSampler(value: boolean) {
         this.sampler = value;
 
         return this;
@@ -473,7 +499,7 @@ class TextureNode extends UniformNode {
      * @param {Node} uvNode - The uv node.
      * @return {TextureNode} A texture node representing the texture sample.
      */
-    uv(uvNode) {
+    uv(uvNode: ShaderNodeObject<Node> | null) {
         // @deprecated, r172
 
         console.warn('THREE.TextureNode: .uv() has been renamed. Use .sample() instead.');
@@ -501,7 +527,7 @@ class TextureNode extends UniformNode {
      * @param {Node<float>} amountNode - How blurred the texture should be.
      * @return {TextureNode} A texture node representing the texture sample.
      */
-    blur(amountNode) {
+    blur(amountNode: ShaderNodeObject<Node>) {
         const textureNode = this.clone();
         textureNode.biasNode = nodeObject(amountNode).mul(maxMipLevel(textureNode));
         textureNode.referenceNode = this.getSelf();
@@ -530,7 +556,7 @@ class TextureNode extends UniformNode {
      * @param {Node<int>} levelNode - The mip level to sample.
      * @return {TextureNode} A texture node representing the texture sample.
      */
-    level(levelNode) {
+    level(levelNode: ShaderNodeObject<Node> | null) {
         const textureNode = this.clone();
         textureNode.levelNode = nodeObject(levelNode);
         textureNode.referenceNode = this.getSelf();
diff --git a/src-testing/src/nodes/code/CodeNode.ts b/src-testing/src/nodes/code/CodeNode.ts
index 61fa9fc7..29f35ae4 100644
--- a/src-testing/src/nodes/code/CodeNode.ts
+++ b/src-testing/src/nodes/code/CodeNode.ts
@@ -1,5 +1,6 @@
 import Node from '../core/Node.js';
 import { nodeProxy } from '../tsl/TSLBase.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 /**
  * This class represents native code sections. It is the base
@@ -13,6 +14,11 @@ class CodeNode extends Node {
         return 'CodeNode';
     }
 
+    readonly isCodeNode: true;
+
+    code: string;
+    language: string;
+
     /**
      * Constructs a new code node.
      *
@@ -84,11 +90,11 @@ class CodeNode extends Node {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {Array<Node>} The includes.
      */
-    getIncludes(/*builder*/) {
+    getIncludes(builder: NodeBuilder) {
         return this.includes;
     }
 
-    generate(builder) {
+    generate(builder: NodeBuilder) {
         const includes = this.getIncludes(builder);
 
         for (const include of includes) {
diff --git a/src-testing/src/nodes/code/FunctionNode.ts b/src-testing/src/nodes/code/FunctionNode.ts
index 7cfff69f..99c39c40 100644
--- a/src-testing/src/nodes/code/FunctionNode.ts
+++ b/src-testing/src/nodes/code/FunctionNode.ts
@@ -1,5 +1,6 @@
 import CodeNode from './CodeNode.js';
 import { nodeObject } from '../tsl/TSLBase.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 /**
  * This class represents a native shader function. It can be used to implement
@@ -43,7 +44,7 @@ class FunctionNode extends CodeNode {
         super(code, includes, language);
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.getNodeFunction(builder).type;
     }
 
@@ -53,7 +54,7 @@ class FunctionNode extends CodeNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {Array<NodeFunctionInput>} The inputs.
      */
-    getInputs(builder) {
+    getInputs(builder: NodeBuilder) {
         return this.getNodeFunction(builder).inputs;
     }
 
@@ -63,7 +64,7 @@ class FunctionNode extends CodeNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {NodeFunction} The node function.
      */
-    getNodeFunction(builder) {
+    getNodeFunction(builder: NodeBuilder) {
         const nodeData = builder.getDataFromNode(this);
 
         let nodeFunction = nodeData.nodeFunction;
@@ -77,7 +78,7 @@ class FunctionNode extends CodeNode {
         return nodeFunction;
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null) {
         super.generate(builder);
 
         const nodeFunction = this.getNodeFunction(builder);
@@ -109,7 +110,7 @@ class FunctionNode extends CodeNode {
 
 export default FunctionNode;
 
-const nativeFn = (code, includes = [], language = '') => {
+const nativeFn = (code: string, includes = [], language = '') => {
     for (let i = 0; i < includes.length; i++) {
         const include = includes[i];
 
@@ -128,5 +129,5 @@ const nativeFn = (code, includes = [], language = '') => {
     return fn;
 };
 
-export const glslFn = (code, includes) => nativeFn(code, includes, 'glsl');
-export const wgslFn = (code, includes) => nativeFn(code, includes, 'wgsl');
+export const glslFn = (code: string, includes) => nativeFn(code, includes, 'glsl');
+export const wgslFn = (code: string, includes) => nativeFn(code, includes, 'wgsl');
diff --git a/src-testing/src/nodes/core/ContextNode.ts b/src-testing/src/nodes/core/ContextNode.ts
index 3b93bec0..68acdeb1 100644
--- a/src-testing/src/nodes/core/ContextNode.ts
+++ b/src-testing/src/nodes/core/ContextNode.ts
@@ -1,5 +1,6 @@
 import Node from './Node.js';
-import { addMethodChaining, nodeProxy } from '../tsl/TSLCore.js';
+import { addMethodChaining, nodeProxy, NodeRepresentation } from '../tsl/TSLCore.js';
+import NodeBuilder from './NodeBuilder.js';
 
 /**
  * This node can be used as a context management component for another node.
@@ -11,18 +12,23 @@ import { addMethodChaining, nodeProxy } from '../tsl/TSLCore.js';
  *```
  * @augments Node
  */
-class ContextNode extends Node {
+class ContextNode<TContext> extends Node {
     static get type() {
         return 'ContextNode';
     }
 
+    readonly isContextNode: true;
+
+    node: Node;
+    value: TContext;
+
     /**
      * Constructs a new context node.
      *
      * @param {Node} node - The node whose context should be modified.
      * @param {Object} [value={}] - The modified context data.
      */
-    constructor(node, value = {}) {
+    constructor(node: Node, value: TContext = {} as TContext) {
         super();
 
         /**
@@ -65,15 +71,15 @@ class ContextNode extends Node {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The node type.
      */
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.node.getNodeType(builder);
     }
 
-    analyze(builder) {
+    analyze(builder: NodeBuilder) {
         this.node.build(builder);
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         const previousContext = builder.getContext();
 
         builder.setContext({ ...builder.context, ...this.value });
@@ -85,7 +91,7 @@ class ContextNode extends Node {
         return node;
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null) {
         const previousContext = builder.getContext();
 
         builder.setContext({ ...builder.context, ...this.value });
@@ -120,7 +126,7 @@ export const context = /*@__PURE__*/ nodeProxy(ContextNode).setParameterLength(1
  * @param {string} name - The name/label to set.
  * @returns {ContextNode}
  */
-export const label = (node, name) => context(node, { label: name });
+export const label = (node: NodeRepresentation, name: string) => context(node, { label: name });
 
 addMethodChaining('context', context);
 addMethodChaining('label', label);
diff --git a/src-testing/src/nodes/core/InputNode.ts b/src-testing/src/nodes/core/InputNode.ts
index bf369c8a..fc36b429 100644
--- a/src-testing/src/nodes/core/InputNode.ts
+++ b/src-testing/src/nodes/core/InputNode.ts
@@ -1,23 +1,29 @@
 import Node from './Node.js';
 import { getValueType, getValueFromType, arrayBufferToBase64 } from './NodeUtils.js';
+import NodeBuilder from './NodeBuilder.js';
 
 /**
  * Base class for representing data input nodes.
  *
  * @augments Node
  */
-class InputNode extends Node {
+class InputNode<TValue> extends Node {
     static get type() {
         return 'InputNode';
     }
 
+    readonly isInputNode: true;
+
+    value: TValue;
+    precision: 'low' | 'medium' | 'high' | null;
+
     /**
      * Constructs a new input node.
      *
      * @param {any} value - The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
      * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
      */
-    constructor(value, nodeType = null) {
+    constructor(value: TValue, nodeType: string | null = null) {
         super(nodeType);
 
         /**
@@ -45,7 +51,7 @@ class InputNode extends Node {
         this.precision = null;
     }
 
-    getNodeType(/*builder*/) {
+    getNodeType(builder: NodeBuilder) {
         if (this.nodeType === null) {
             return getValueType(this.value);
         }
@@ -63,7 +69,7 @@ class InputNode extends Node {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The input type.
      */
-    getInputType(builder) {
+    getInputType(builder: NodeBuilder) {
         return this.getNodeType(builder);
     }
 
@@ -75,7 +81,7 @@ class InputNode extends Node {
      * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.
      * @return {InputNode} A reference to this node.
      */
-    setPrecision(precision) {
+    setPrecision(precision: 'low' | 'medium' | 'high' | null) {
         this.precision = precision;
 
         return this;
@@ -106,10 +112,6 @@ class InputNode extends Node {
 
         if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);
     }
-
-    generate(/*builder, output*/) {
-        console.warn('Abstract function.');
-    }
 }
 
 export default InputNode;
diff --git a/src-testing/src/nodes/core/Node.ts b/src-testing/src/nodes/core/Node.ts
index c06143fd..66928648 100644
--- a/src-testing/src/nodes/core/Node.ts
+++ b/src-testing/src/nodes/core/Node.ts
@@ -3,25 +3,103 @@ import { getNodeChildren, getCacheKey, hash } from './NodeUtils.js';
 
 import { EventDispatcher } from '../../core/EventDispatcher.js';
 import { MathUtils } from '../../math/MathUtils.js';
+import NodeFrame from './NodeFrame.js';
+import NodeBuilder from './NodeBuilder.js';
 
 let _nodeId = 0;
 
+interface NodeConstructor {
+    type?: string;
+}
+
+interface NodeJSONMeta {
+    textures: { [key: string]: unknown };
+    images: { [key: string]: unknown };
+    nodes: { [key: string]: NodeJSONIntermediateOutputData };
+}
+
+interface NodeJSONMetadata {
+    version: number;
+    type: 'Node';
+    generator: 'Node.toJSON';
+}
+
+interface NodeJSONInputNodes {
+    [property: string]:
+        | string[]
+        | {
+              [index: string]: string | undefined;
+          }
+        | string
+        | undefined;
+}
+
+export interface NodeJSONInputData {
+    inputNodes?: NodeJSONInputNodes | undefined;
+    meta: {
+        textures: { [key: string]: unknown };
+        nodes: { [key: string]: Node };
+    };
+}
+
+export interface NodeJSONIntermediateOutputData {
+    uuid: string;
+    type: string | undefined;
+    meta?: NodeJSONMeta | undefined;
+    metadata?: NodeJSONMetadata;
+    inputNodes?: NodeJSONInputNodes | undefined;
+    textures?: unknown[];
+    images?: unknown[];
+    nodes?: NodeJSONIntermediateOutputData[];
+}
+
+interface NodeJSONOutputData {
+    uuid: string;
+    type: string | undefined;
+    metadata?: NodeJSONMetadata;
+    inputNodes?: NodeJSONInputNodes | undefined;
+    textures?: unknown[];
+    images?: unknown[];
+    nodes?: NodeJSONOutputData[];
+}
+
 /**
  * Base class for all nodes.
  *
  * @augments EventDispatcher
  */
-class Node extends EventDispatcher {
+class Node extends EventDispatcher<{ dispose: {} }> {
     static get type() {
         return 'Node';
     }
 
+    nodeType: string | null;
+
+    updateType: NodeUpdateType;
+    updateBeforeType: NodeUpdateType;
+    updateAfterType: NodeUpdateType;
+
+    uuid: string;
+
+    version: number;
+
+    _cacheKey: number | null;
+    _cacheKeyVersion: number;
+
+    global: boolean;
+
+    readonly isNode: true;
+
+    readonly id!: number;
+
+    self?: this;
+
     /**
      * Constructs a new node.
      *
      * @param {?string} nodeType - The node type.
      */
-    constructor(nodeType = null) {
+    constructor(nodeType: string | null = null) {
         super();
 
         /**
@@ -122,7 +200,7 @@ class Node extends EventDispatcher {
      * @default false
      * @param {boolean} value
      */
-    set needsUpdate(value) {
+    set needsUpdate(value: boolean) {
         if (value === true) {
             this.version++;
         }
@@ -135,7 +213,7 @@ class Node extends EventDispatcher {
      * @readonly
      */
     get type() {
-        return this.constructor.type;
+        return (this.constructor as NodeConstructor).type;
     }
 
     /**
@@ -145,7 +223,7 @@ class Node extends EventDispatcher {
      * @param {string} updateType - The update type.
      * @return {Node} A reference to this node.
      */
-    onUpdate(callback, updateType) {
+    onUpdate(callback: (this: this, frame: NodeFrame) => unknown, updateType: NodeUpdateType) {
         this.updateType = updateType;
         this.update = callback.bind(this.getSelf());
 
@@ -159,7 +237,7 @@ class Node extends EventDispatcher {
      * @param {Function} callback - The update method.
      * @return {Node} A reference to this node.
      */
-    onFrameUpdate(callback) {
+    onFrameUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.FRAME);
     }
 
@@ -170,7 +248,7 @@ class Node extends EventDispatcher {
      * @param {Function} callback - The update method.
      * @return {Node} A reference to this node.
      */
-    onRenderUpdate(callback) {
+    onRenderUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.RENDER);
     }
 
@@ -181,7 +259,7 @@ class Node extends EventDispatcher {
      * @param {Function} callback - The update method.
      * @return {Node} A reference to this node.
      */
-    onObjectUpdate(callback) {
+    onObjectUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.OBJECT);
     }
 
@@ -191,7 +269,7 @@ class Node extends EventDispatcher {
      * @param {Function} callback - The update method.
      * @return {Node} A reference to this node.
      */
-    onReference(callback) {
+    onReference(callback: (this: this, frame: NodeBuilder | NodeFrame) => unknown) {
         this.updateReference = callback.bind(this.getSelf());
 
         return this;
@@ -216,7 +294,7 @@ class Node extends EventDispatcher {
      * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
      * @return {any} The updated reference.
      */
-    updateReference(/*state*/) {
+    updateReference(state: NodeBuilder | NodeFrame): unknown {
         return this;
     }
 
@@ -228,7 +306,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {boolean} Whether this node is global or not.
      */
-    isGlobal(/*builder*/) {
+    isGlobal(builder: NodeBuilder) {
         return this.global;
     }
 
@@ -264,7 +342,7 @@ class Node extends EventDispatcher {
      *
      * @param {traverseCallback} callback - A callback that is executed per node.
      */
-    traverse(callback) {
+    traverse(callback: (node: Node) => void) {
         callback(this);
 
         for (const childNode of this.getChildren()) {
@@ -315,7 +393,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The hash.
      */
-    getHash(/*builder*/) {
+    getHash(builder: NodeBuilder) {
         return this.uuid;
     }
 
@@ -354,7 +432,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The type of the node.
      */
-    getElementType(builder) {
+    getElementType(builder: NodeBuilder) {
         const type = this.getNodeType(builder);
         const elementType = builder.getElementType(type);
 
@@ -368,7 +446,7 @@ class Node extends EventDispatcher {
      * @param {string} name - The name of the member.
      * @return {string} The type of the node.
      */
-    getMemberType(/*builder, name*/) {
+    getMemberType(builder: NodeBuilder, name: string) {
         return 'void';
     }
 
@@ -378,7 +456,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The type of the node.
      */
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder): string | null {
         const nodeProperties = builder.getNodeProperties(this);
 
         if (nodeProperties.outputNode) {
@@ -397,7 +475,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {Node} The shared node if possible. Otherwise `this` is returned.
      */
-    getShared(builder) {
+    getShared(builder: NodeBuilder) {
         const hash = this.getHash(builder);
         const nodeFromHash = builder.getNodeFromHash(hash);
 
@@ -412,13 +490,13 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {?Node} The output node.
      */
-    setup(builder) {
+    setup(builder: NodeBuilder): unknown {
         const nodeProperties = builder.getNodeProperties(this);
 
         let index = 0;
 
         for (const childNode of this.getChildren()) {
-            nodeProperties['node' + index++] = childNode;
+            nodeProperties[`node${index++}`] = childNode;
         }
 
         // return a outputNode if exists or null
@@ -432,7 +510,7 @@ class Node extends EventDispatcher {
      *
      * @param {NodeBuilder} builder - The current node builder.
      */
-    analyze(builder) {
+    analyze(builder: NodeBuilder) {
         const usageCount = builder.increaseUsage(this);
 
         if (usageCount === 1) {
@@ -441,8 +519,8 @@ class Node extends EventDispatcher {
             const nodeProperties = builder.getNodeProperties(this);
 
             for (const childNode of Object.values(nodeProperties)) {
-                if (childNode && childNode.isNode === true) {
-                    childNode.build(builder);
+                if (childNode && (childNode as Node).isNode === true) {
+                    (childNode as Node).build(builder);
                 }
             }
         }
@@ -456,7 +534,7 @@ class Node extends EventDispatcher {
      * @param {?string} output - Can be used to define the output type.
      * @return {?string} The generated shader string.
      */
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null): string | null | undefined {
         const { outputNode } = builder.getNodeProperties(this);
 
         if (outputNode && outputNode.isNode === true) {
@@ -472,7 +550,7 @@ class Node extends EventDispatcher {
      * @param {NodeFrame} frame - A reference to the current node frame.
      * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
      */
-    updateBefore(/*frame*/) {
+    updateBefore(frame: NodeFrame) {
         console.warn('Abstract function.');
     }
 
@@ -484,7 +562,7 @@ class Node extends EventDispatcher {
      * @param {NodeFrame} frame - A reference to the current node frame.
      * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
      */
-    updateAfter(/*frame*/) {
+    updateAfter(frame: NodeFrame) {
         console.warn('Abstract function.');
     }
 
@@ -496,7 +574,7 @@ class Node extends EventDispatcher {
      * @param {NodeFrame} frame - A reference to the current node frame.
      * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
      */
-    update(/*frame*/) {
+    update(frame: NodeFrame) {
         console.warn('Abstract function.');
     }
 
@@ -508,7 +586,7 @@ class Node extends EventDispatcher {
      * @param {?string} output - Can be used to define the output type.
      * @return {?string} When this method is executed in the setup or analyze stage, `null` is returned. In the generate stage, the generated shader string.
      */
-    build(builder, output = null) {
+    build(builder: NodeBuilder, output: string | null = null): string | null {
         const refNode = this.getShared(builder);
 
         if (this !== refNode) {
@@ -548,8 +626,8 @@ class Node extends EventDispatcher {
 				}*/
 
                 for (const childNode of Object.values(properties)) {
-                    if (childNode && childNode.isNode === true) {
-                        childNode.build(builder);
+                    if (childNode && (childNode as Node).isNode === true) {
+                        (childNode as Node).build(builder);
                     }
                 }
 
@@ -612,10 +690,10 @@ class Node extends EventDispatcher {
      *
      * @param {Object} json - The output JSON object.
      */
-    serialize(json) {
+    serialize(json: NodeJSONIntermediateOutputData) {
         const nodeChildren = this.getSerializeChildren();
 
-        const inputNodes = {};
+        const inputNodes: NodeJSONInputNodes = {};
 
         for (const { property, index, childNode } of nodeChildren) {
             if (index !== undefined) {
@@ -623,7 +701,9 @@ class Node extends EventDispatcher {
                     inputNodes[property] = Number.isInteger(index) ? [] : {};
                 }
 
-                inputNodes[property][index] = childNode.toJSON(json.meta).uuid;
+                (inputNodes[property]! as { [index: number | string]: string })[index] = childNode.toJSON(
+                    json.meta,
+                ).uuid;
             } else {
                 inputNodes[property] = childNode.toJSON(json.meta).uuid;
             }
@@ -639,33 +719,33 @@ class Node extends EventDispatcher {
      *
      * @param {Object} json - The JSON object.
      */
-    deserialize(json) {
+    deserialize(json: NodeJSONInputData) {
         if (json.inputNodes !== undefined) {
             const nodes = json.meta.nodes;
 
             for (const property in json.inputNodes) {
                 if (Array.isArray(json.inputNodes[property])) {
-                    const inputArray = [];
+                    const inputArray: Node[] = [];
 
-                    for (const uuid of json.inputNodes[property]) {
+                    for (const uuid of json.inputNodes[property] as string[]) {
                         inputArray.push(nodes[uuid]);
                     }
 
-                    this[property] = inputArray;
+                    (this[property as keyof typeof this] as Node[]) = inputArray;
                 } else if (typeof json.inputNodes[property] === 'object') {
-                    const inputObject = {};
+                    const inputObject: { [subProperty: string]: Node } = {};
 
-                    for (const subProperty in json.inputNodes[property]) {
-                        const uuid = json.inputNodes[property][subProperty];
+                    for (const subProperty in json.inputNodes[property] as { [subProperty: string]: string }) {
+                        const uuid = (json.inputNodes[property] as { [subProperty: string]: string })[subProperty];
 
                         inputObject[subProperty] = nodes[uuid];
                     }
 
-                    this[property] = inputObject;
+                    (this[property as keyof typeof this] as { [subProperty: string]: Node }) = inputObject;
                 } else {
-                    const uuid = json.inputNodes[property];
+                    const uuid = json.inputNodes[property] as string;
 
-                    this[property] = nodes[uuid];
+                    (this[property as keyof typeof this] as Node) = nodes[uuid];
                 }
             }
         }
@@ -677,7 +757,7 @@ class Node extends EventDispatcher {
      * @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.
      * @return {Object} The serialized node.
      */
-    toJSON(meta) {
+    toJSON(meta?: NodeJSONMeta | string): NodeJSONOutputData {
         const { uuid, type } = this;
         const isRoot = meta === undefined || typeof meta === 'string';
 
@@ -686,18 +766,18 @@ class Node extends EventDispatcher {
                 textures: {},
                 images: {},
                 nodes: {},
-            };
+            } satisfies NodeJSONMeta;
         }
 
         // serialize
 
-        let data = meta.nodes[uuid];
+        let data = (meta as NodeJSONMeta).nodes[uuid];
 
         if (data === undefined) {
             data = {
                 uuid,
                 type,
-                meta,
+                meta: meta as NodeJSONMeta,
                 metadata: {
                     version: 4.6,
                     type: 'Node',
@@ -705,7 +785,7 @@ class Node extends EventDispatcher {
                 },
             };
 
-            if (isRoot !== true) meta.nodes[data.uuid] = data;
+            if (isRoot !== true) (meta as NodeJSONMeta).nodes[data.uuid] = data;
 
             this.serialize(data);
 
@@ -714,12 +794,12 @@ class Node extends EventDispatcher {
 
         // TODO: Copied from Object3D.toJSON
 
-        function extractFromCache(cache) {
+        function extractFromCache<T>(cache: { [key: string]: T }) {
             const values = [];
 
             for (const key in cache) {
                 const data = cache[key];
-                delete data.metadata;
+                delete (data as NodeJSONIntermediateOutputData).metadata;
                 values.push(data);
             }
 
@@ -727,9 +807,9 @@ class Node extends EventDispatcher {
         }
 
         if (isRoot) {
-            const textures = extractFromCache(meta.textures);
-            const images = extractFromCache(meta.images);
-            const nodes = extractFromCache(meta.nodes);
+            const textures = extractFromCache((meta as NodeJSONMeta).textures);
+            const images = extractFromCache((meta as NodeJSONMeta).images);
+            const nodes = extractFromCache((meta as NodeJSONMeta).nodes);
 
             if (textures.length > 0) data.textures = textures;
             if (images.length > 0) data.images = images;
diff --git a/src-testing/src/nodes/core/NodeAttribute.ts b/src-testing/src/nodes/core/NodeAttribute.ts
index 393325c3..5daf1095 100644
--- a/src-testing/src/nodes/core/NodeAttribute.ts
+++ b/src-testing/src/nodes/core/NodeAttribute.ts
@@ -1,3 +1,5 @@
+import Node from './Node.js';
+
 /**
  * {@link NodeBuilder} is going to create instances of this class during the build process
  * of nodes. They represent the final shader attributes that are going to be generated
@@ -5,6 +7,12 @@
  * and {@link NodeBuilder#bufferAttributes} for this purpose.
  */
 class NodeAttribute {
+    readonly isNodeAttribute: true;
+
+    name: string;
+    type: string | null;
+    node: Node | null;
+
     /**
      * Constructs a new node attribute.
      *
@@ -12,7 +20,7 @@ class NodeAttribute {
      * @param {string} type - The type of the attribute.
      * @param {?Node} node - An optional reference to the node.
      */
-    constructor(name, type, node = null) {
+    constructor(name: string, type: string | null, node: Node | null = null) {
         /**
          * This flag can be used for type testing.
          *
diff --git a/src-testing/src/nodes/core/NodeBuilder.ts b/src-testing/src/nodes/core/NodeBuilder.ts
index a4f93f03..9c59b0a9 100644
--- a/src-testing/src/nodes/core/NodeBuilder.ts
+++ b/src-testing/src/nodes/core/NodeBuilder.ts
@@ -9,7 +9,7 @@ import StructType from './StructType.js';
 import FunctionNode from '../code/FunctionNode.js';
 import NodeMaterial from '../../materials/nodes/NodeMaterial.js';
 import { getTypeFromLength } from './NodeUtils.js';
-import { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';
+import { NodeUpdateType, defaultBuildStages, shaderStages, NodeShaderStage } from './constants.js';
 
 import {
     NumberNodeUniform,
@@ -22,8 +22,8 @@ import {
     Matrix4NodeUniform,
 } from '../../renderers/common/nodes/NodeUniform.js';
 
-import { stack } from './StackNode.js';
-import { getCurrentStack, setCurrentStack } from '../tsl/TSLBase.js';
+import StackNode, { stack } from './StackNode.js';
+import { getCurrentStack, setCurrentStack, ShaderNodeInternal, ShaderNodeObject } from '../tsl/TSLBase.js';
 
 import CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';
 import ChainMap from '../../renderers/common/ChainMap.js';
@@ -38,18 +38,52 @@ import {
     LinearMipmapNearestFilter,
     NearestMipmapLinearFilter,
     LinearMipmapLinearFilter,
+    InterpolationSamplingType,
+    InterpolationSamplingMode,
 } from '../../constants.js';
-import { RenderTarget } from '../../core/RenderTarget.js';
+import { RenderTarget, RenderTargetOptions } from '../../core/RenderTarget.js';
 import { RenderTargetArray } from '../../core/RenderTargetArray.js';
 import { Color } from '../../math/Color.js';
 import { Vector2 } from '../../math/Vector2.js';
 import { Vector3 } from '../../math/Vector3.js';
 import { Vector4 } from '../../math/Vector4.js';
 import { Float16BufferAttribute } from '../../core/BufferAttribute.js';
-
-const rendererCache = new WeakMap();
-
-const typeFromArray = new Map([
+import Renderer from '../../renderers/common/Renderer.js';
+import UniformNode from './UniformNode.js';
+import NodeUniformsGroup from '../../renderers/common/nodes/NodeUniformsGroup.js';
+import { Material } from '../../materials/Material.js';
+import { Object3D } from '../../core/Object3D.js';
+import { BufferGeometry } from '../../core/BufferGeometry.js';
+import NodeParser from './NodeParser.js';
+import { Scene } from '../../scenes/Scene.js';
+import { Camera } from '../../cameras/Camera.js';
+import Node from './Node.js';
+import ClippingContext from '../../renderers/common/ClippingContext.js';
+import { Mesh } from '../../objects/Mesh.js';
+import { Texture } from '../../textures/Texture.js';
+import { Matrix3 } from '../../math/Matrix3.js';
+import { Matrix4 } from '../../math/Matrix4.js';
+import { DataTexture } from '../../textures/DataTexture.js';
+import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
+import LightsNode from '../lighting/LightsNode.js';
+import StructTypeNode, { MemberLayout } from './StructTypeNode.js';
+import NodeMaterialObserver from '../../materials/nodes/manager/NodeMaterialObserver.js';
+
+const rendererCache = new WeakMap<
+    Renderer,
+    ChainMap<UniformNode<unknown>[] | NodeUniformsGroup[], NodeUniformsGroup | BindGroup>
+>();
+
+type TypedArrayConstructor =
+    | typeof Int8Array
+    | typeof Int16Array
+    | typeof Int32Array
+    | typeof Uint8Array
+    | typeof Uint16Array
+    | typeof Uint32Array
+    | typeof Float32Array;
+
+const typeFromArray = new Map<TypedArrayConstructor, string>([
     [Int8Array, 'int'],
     [Int16Array, 'int'],
     [Int32Array, 'int'],
@@ -59,21 +93,98 @@ const typeFromArray = new Map([
     [Float32Array, 'float'],
 ]);
 
-const toFloat = value => {
+const toFloat = (value: unknown) => {
     if (/e/g.test(value)) {
         return String(value).replace(/\+/g, '');
     } else {
         value = Number(value);
 
-        return value + (value % 1 ? '' : '.0');
+        return value + ((value as number) % 1 ? '' : '.0');
     }
 };
 
+interface Flow {
+    code: string;
+    result?: string | null | undefined;
+    vars?: string | undefined;
+}
+
+interface Context {
+    material: Material | Material[] | null;
+    tempRead?: boolean;
+}
+
 /**
  * Base class for builders which generate a shader program based
  * on a 3D object and its node material definition.
  */
-class NodeBuilder {
+abstract class NodeBuilder {
+    object: Object3D | null;
+    material: Material | Material[] | null;
+    geometry: BufferGeometry | null;
+    renderer: Renderer;
+    parser: NodeParser;
+    scene: Scene | null;
+    camera: Camera | null;
+
+    nodes: Node[];
+    sequentialNodes: Node[];
+    updateNodes: Node[];
+    updateBeforeNodes: Node[];
+    updateAfterNodes: Node[];
+    hashNodes: { [hash: string]: Node };
+
+    observer: NodeMaterialObserver | null;
+
+    lightsNode: LightsNode | null;
+    environmentNode: ShaderNodeObject<Node> | null;
+    fogNode: ShaderNodeObject<Node> | null;
+
+    clippingContext: ClippingContext | null;
+
+    vertexShader: string | null;
+    fragmentShader: string | null;
+    computeShader: string | null;
+
+    flowNodes: { vertex: Node[]; fragment: Node[]; compute: Node[] };
+    flowCode: { vertex: string; fragment: string; compute: string };
+    uniforms: {
+        vertex: NodeUniform<unknown>[];
+        fragment: NodeUniform<unknown>[];
+        compute: NodeUniform<unknown>[];
+        index: number;
+    };
+    structs: { vertex: StructType[]; fragment: StructType[]; compute: StructType[]; index: number };
+    bindings: {
+        vertex: { [groupName: string]: NodeUniformsGroup[] | undefined };
+        fragment: { [groupName: string]: NodeUniformsGroup[] | undefined };
+        compute: { [groupName: string]: NodeUniformsGroup[] | undefined };
+    };
+    bindingsIndexes: { [groupName: string]: { binding: number; group: number } | undefined };
+    bindGroups: BindGroup[] | null;
+    attributes: NodeAttribute[];
+    bufferAttributes: NodeAttribute[];
+    varyings: NodeVarying[];
+    codes: { vertex?: NodeCode[] | undefined; fragment?: NodeCode[] | undefined; compute?: NodeCode[] | undefined };
+    vars: { vertex?: NodeVar[] | undefined; fragment?: NodeVar[] | undefined; compute?: NodeVar[] | undefined };
+    flow: Flow;
+    chaining: Node[];
+    stack: ShaderNodeObject<StackNode>;
+    stacks: ShaderNodeObject<StackNode>[];
+    tab: string;
+
+    currentFunctionNode: FunctionNode | null;
+
+    context: Context;
+
+    cache: NodeCache;
+    globalCache: NodeCache;
+
+    flowsData: WeakMap<Node, Flow>;
+
+    shaderStage: NodeShaderStage | null;
+    buildStage: string | null;
+
     /**
      * Constructs a new node builder.
      *
@@ -81,7 +192,7 @@ class NodeBuilder {
      * @param {Renderer} renderer - The current renderer.
      * @param {NodeParser} parser - A reference to a node parser.
      */
-    constructor(object, renderer, parser) {
+    constructor(object: Object3D | null, renderer: Renderer, parser: NodeParser) {
         /**
          * The 3D object.
          *
@@ -94,14 +205,14 @@ class NodeBuilder {
          *
          * @type {?Material}
          */
-        this.material = (object && object.material) || null;
+        this.material = (object && (object as Mesh).material) || null;
 
         /**
          * The geometry of the 3D object.
          *
          * @type {?BufferGeometry}
          */
-        this.geometry = (object && object.geometry) || null;
+        this.geometry = (object && (object as Mesh).geometry) || null;
 
         /**
          * The current renderer.
@@ -410,7 +521,7 @@ class NodeBuilder {
          */
         this.globalCache = this.cache;
 
-        this.flowsData = new WeakMap();
+        this.flowsData = new WeakMap<Node, Flow>();
 
         /**
          * The current shader stage.
@@ -453,7 +564,7 @@ class NodeBuilder {
      * @param {Object} options - The options of the render target.
      * @return {RenderTarget} The render target.
      */
-    createRenderTarget(width, height, options) {
+    createRenderTarget(width?: number, height?: number, options?: RenderTargetOptions) {
         return new RenderTarget(width, height, options);
     }
 
@@ -467,7 +578,7 @@ class NodeBuilder {
      * @param {Object} options - The options of the render target.
      * @return {RenderTargetArray} The render target.
      */
-    createRenderTargetArray(width, height, depth, options) {
+    createRenderTargetArray(width: number, height: number, depth: number, options: RenderTargetOptions) {
         return new RenderTargetArray(width, height, depth, options);
     }
 
@@ -479,7 +590,7 @@ class NodeBuilder {
      * @param {Object} options - The options of the cube render target.
      * @return {CubeRenderTarget} The cube render target.
      */
-    createCubeRenderTarget(size, options) {
+    createCubeRenderTarget(size?: number, options?: RenderTargetOptions) {
         return new CubeRenderTarget(size, options);
     }
 
@@ -489,7 +600,7 @@ class NodeBuilder {
      * @param {Node} node - The node to test.
      * @return {boolean} Whether the given node is included in the internal array of nodes or not.
      */
-    includes(node) {
+    includes(node: Node) {
         return this.nodes.includes(node);
     }
 
@@ -510,12 +621,12 @@ class NodeBuilder {
      * @param {Array<NodeUniformsGroup>} bindings - List of bindings.
      * @return {BindGroup} The bind group
      */
-    _getBindGroup(groupName, bindings) {
+    _getBindGroup(groupName: string, bindings: NodeUniformsGroup[]) {
         const bindGroupsCache = this.getBindGroupsCache();
 
         //
 
-        const bindingsArray = [];
+        const bindingsArray: NodeUniformsGroup[] = [];
 
         let sharedGroup = true;
 
@@ -530,20 +641,20 @@ class NodeBuilder {
         let bindGroup;
 
         if (sharedGroup) {
-            bindGroup = bindGroupsCache.get(bindingsArray);
+            bindGroup = bindGroupsCache.get(bindingsArray) as BindGroup | undefined;
 
             if (bindGroup === undefined) {
                 bindGroup = new BindGroup(
                     groupName,
                     bindingsArray,
-                    this.bindingsIndexes[groupName].group,
+                    this.bindingsIndexes[groupName]!.group,
                     bindingsArray,
                 );
 
                 bindGroupsCache.set(bindingsArray, bindGroup);
             }
         } else {
-            bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);
+            bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName]!.group, bindingsArray);
         }
 
         return bindGroup;
@@ -556,7 +667,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {Array<NodeUniformsGroup>} The array of node uniform groups.
      */
-    getBindGroupArray(groupName, shaderStage) {
+    getBindGroupArray(groupName: string, shaderStage: NodeShaderStage) {
         const bindings = this.bindings[shaderStage];
 
         let bindGroup = bindings[groupName];
@@ -581,12 +692,12 @@ class NodeBuilder {
         let bindingsGroups = this.bindGroups;
 
         if (bindingsGroups === null) {
-            const groups = {};
+            const groups: { [groupName: string]: NodeUniformsGroup[] | undefined } = {};
             const bindings = this.bindings;
 
             for (const shaderStage of shaderStages) {
                 for (const groupName in bindings[shaderStage]) {
-                    const uniforms = bindings[shaderStage][groupName];
+                    const uniforms = bindings[shaderStage][groupName]!;
 
                     const groupUniforms = groups[groupName] || (groups[groupName] = []);
                     groupUniforms.push(...uniforms);
@@ -596,7 +707,7 @@ class NodeBuilder {
             bindingsGroups = [];
 
             for (const groupName in groups) {
-                const group = groups[groupName];
+                const group = groups[groupName]!;
 
                 const bindingsGroup = this._getBindGroup(groupName, group);
 
@@ -632,7 +743,7 @@ class NodeBuilder {
      * @param {Node} node - The node to add.
      * @param {number} hash - The hash of the node.
      */
-    setHashNode(node, hash) {
+    setHashNode(node: Node, hash: string) {
         this.hashNodes[hash] = node;
     }
 
@@ -641,7 +752,7 @@ class NodeBuilder {
      *
      * @param {Node} node - The node to add.
      */
-    addNode(node) {
+    addNode(node: Node) {
         if (this.nodes.includes(node) === false) {
             this.nodes.push(node);
 
@@ -704,7 +815,7 @@ class NodeBuilder {
      * @param {Texture} texture - The texture to check.
      * @return {boolean} Whether the given texture is filtered or not.
      */
-    isFilteredTexture(texture) {
+    isFilteredTexture(texture: Texture) {
         return (
             texture.magFilter === LinearFilter ||
             texture.magFilter === LinearMipmapNearestFilter ||
@@ -723,7 +834,7 @@ class NodeBuilder {
      *
      * @param {Node} node - The node to add.
      */
-    addChain(node) {
+    addChain(node: Node) {
         /*
 		if ( this.chaining.indexOf( node ) !== - 1 ) {
 
@@ -740,7 +851,7 @@ class NodeBuilder {
      *
      * @param {Node} node - The node to remove.
      */
-    removeChain(node) {
+    removeChain(node: Node) {
         const lastChain = this.chaining.pop();
 
         if (lastChain !== node) {
@@ -757,7 +868,7 @@ class NodeBuilder {
      * @param {string} method - The method name to resolve.
      * @return {string} The resolved method name.
      */
-    getMethod(method) {
+    getMethod(method: string) {
         return method;
     }
 
@@ -767,7 +878,7 @@ class NodeBuilder {
      * @param {number} hash - The hash of the node.
      * @return {Node} The found node.
      */
-    getNodeFromHash(hash) {
+    getNodeFromHash(hash: string) {
         return this.hashNodes[hash];
     }
 
@@ -778,7 +889,7 @@ class NodeBuilder {
      * @param {Node} node - The node to add.
      * @return {Node} The node.
      */
-    addFlow(shaderStage, node) {
+    addFlow(shaderStage: NodeShaderStage, node: Node) {
         this.flowNodes[shaderStage].push(node);
 
         return node;
@@ -789,7 +900,7 @@ class NodeBuilder {
      *
      * @param {Object} context - The context to set.
      */
-    setContext(context) {
+    setContext(context: Context) {
         this.context = context;
     }
 
@@ -821,7 +932,7 @@ class NodeBuilder {
      *
      * @param {NodeCache} cache - The cache to set.
      */
-    setCache(cache) {
+    setCache(cache: NodeCache) {
         this.cache = cache;
     }
 
@@ -841,7 +952,7 @@ class NodeBuilder {
      * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
      * @return {NodeCache} The cache.
      */
-    getCacheFromNode(node, parent = true) {
+    getCacheFromNode(node: Node, parent = true) {
         const data = this.getDataFromNode(node);
         if (data.cache === undefined) data.cache = new NodeCache(parent ? this.getCache() : null);
 
@@ -855,7 +966,7 @@ class NodeBuilder {
      * @param {string} name - The requested feature.
      * @return {boolean} Whether the requested feature is supported or not.
      */
-    isAvailable(/*name*/) {
+    isAvailable(name: string) {
         return false;
     }
 
@@ -943,9 +1054,12 @@ class NodeBuilder {
      * @param {string} uvSnippet - Snippet defining the texture coordinates.
      * @return {string} The generated shader string.
      */
-    generateTexture(/* texture, textureProperty, uvSnippet */) {
-        console.warn('Abstract function.');
-    }
+    abstract generateTexture(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        depthSnippet: string | null,
+    ): string;
 
     /**
      * Generates a texture LOD shader string for the given texture data.
@@ -958,9 +1072,29 @@ class NodeBuilder {
      * @param {string} levelSnippet - Snippet defining the mip level.
      * @return {string} The generated shader string.
      */
-    generateTextureLod(/* texture, textureProperty, uvSnippet, depthSnippet, levelSnippet */) {
-        console.warn('Abstract function.');
-    }
+    abstract generateTextureLod(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        depthSnippet: string | null,
+        levelSnippet: string | null,
+    ): string;
+
+    abstract generateTextureGrad(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        gradSnippet: [string, string] | null,
+        depthSnippet: string | null,
+    ): string;
+
+    abstract generateTextureCompare(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        compareSnippet: string | null,
+        depthSnippet: string | null,
+    ): string;
 
     /**
      * Generates the array declaration string.
@@ -1032,7 +1166,7 @@ class NodeBuilder {
      * @param {?any} [value=null] - The value.
      * @return {string} The generated value as a shader string.
      */
-    generateConst(type, value = null) {
+    generateConst(type: string | null, value: unknown = null): string {
         if (value === null) {
             if (type === 'float' || type === 'int' || type === 'uint') value = 0;
             else if (type === 'bool') value = false;
@@ -1043,20 +1177,20 @@ class NodeBuilder {
         }
 
         if (type === 'float') return toFloat(value);
-        if (type === 'int') return `${Math.round(value)}`;
-        if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';
+        if (type === 'int') return `${Math.round(value as number)}`;
+        if (type === 'uint') return (value as number) >= 0 ? `${Math.round(value as number)}u` : '0u';
         if (type === 'bool') return value ? 'true' : 'false';
         if (type === 'color')
-            return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
+            return `${this.getType('vec3')}( ${toFloat((value as Color).r)}, ${toFloat((value as Color).g)}, ${toFloat((value as Color).b)} )`;
 
         const typeLength = this.getTypeLength(type);
 
         const componentType = this.getComponentType(type);
 
-        const generateConst = value => this.generateConst(componentType, value);
+        const generateConst = (value: unknown) => this.generateConst(componentType, value);
 
         if (typeLength === 2) {
-            return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;
+            return `${this.getType(type)}( ${generateConst((value as Vector2).x)}, ${generateConst((value as Vector2).y)} )`;
         } else if (typeLength === 3) {
             return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;
         } else if (typeLength === 4 && type !== 'mat2') {
@@ -1077,7 +1211,7 @@ class NodeBuilder {
      * @param {string} type - The type.
      * @return {string} The updated type.
      */
-    getType(type) {
+    getType(type: string | null) {
         if (type === 'color') return 'vec3';
 
         return type;
@@ -1089,7 +1223,7 @@ class NodeBuilder {
      * @param {string} name - The attribute name.
      * @return {boolean} Whether the given attribute name is defined in the geometry.
      */
-    hasGeometryAttribute(name) {
+    hasGeometryAttribute(name: string) {
         return this.geometry && this.geometry.getAttribute(name) !== undefined;
     }
 
@@ -1100,7 +1234,7 @@ class NodeBuilder {
      * @param {string} type - The attribute's type.
      * @return {NodeAttribute} The node attribute.
      */
-    getAttribute(name, type) {
+    getAttribute(name: string, type: string | null) {
         const attributes = this.attributes;
 
         // find attribute
@@ -1129,8 +1263,8 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The property name.
      */
-    getPropertyName(node /*, shaderStage*/) {
-        return node.name;
+    getPropertyName(node: unknown, shaderStage?: NodeShaderStage) {
+        return (node as { name?: string }).name;
     }
 
     /**
@@ -1139,8 +1273,8 @@ class NodeBuilder {
      * @param {string} type - The type to check.
      * @return {boolean} Whether the given type is a vector type or not.
      */
-    isVector(type) {
-        return /vec\d/.test(type);
+    isVector(type: string | null) {
+        return /vec\d/.test(type!);
     }
 
     /**
@@ -1149,8 +1283,8 @@ class NodeBuilder {
      * @param {string} type - The type to check.
      * @return {boolean} Whether the given type is a matrix type or not.
      */
-    isMatrix(type) {
-        return /mat\d/.test(type);
+    isMatrix(type: string | null) {
+        return /mat\d/.test(type!);
     }
 
     /**
@@ -1159,7 +1293,7 @@ class NodeBuilder {
      * @param {string} type - The type to check.
      * @return {boolean} Whether the given type is a reference type or not.
      */
-    isReference(type) {
+    isReference(type: string | null) {
         return (
             type === 'void' ||
             type === 'property' ||
@@ -1190,10 +1324,10 @@ class NodeBuilder {
      * @param {Texture} texture - The texture.
      * @return {string} The component type.
      */
-    getComponentTypeFromTexture(texture) {
+    getComponentTypeFromTexture(texture: Texture) {
         const type = texture.type;
 
-        if (texture.isDataTexture) {
+        if ((texture as DataTexture).isDataTexture) {
             if (type === IntType) return 'int';
             if (type === UnsignedIntType) return 'uint';
         }
@@ -1207,7 +1341,7 @@ class NodeBuilder {
      * @param {string} type - The type.
      * @return {string} The element type.
      */
-    getElementType(type) {
+    getElementType(type: string | null) {
         if (type === 'mat2') return 'vec2';
         if (type === 'mat3') return 'vec3';
         if (type === 'mat4') return 'vec4';
@@ -1221,7 +1355,7 @@ class NodeBuilder {
      * @param {string} type - The type.
      * @return {string} The component type.
      */
-    getComponentType(type) {
+    getComponentType(type: string | null) {
         type = this.getVectorType(type);
 
         if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;
@@ -1243,7 +1377,7 @@ class NodeBuilder {
      * @param {string} type - The type.
      * @return {string} The vector type.
      */
-    getVectorType(type) {
+    getVectorType(type: string | null) {
         if (type === 'color') return 'vec3';
         if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D')
             return 'vec4';
@@ -1258,11 +1392,11 @@ class NodeBuilder {
      * @param {string} [componentType='float'] - The component type.
      * @return {string} The type.
      */
-    getTypeFromLength(length, componentType = 'float') {
+    getTypeFromLength(length: number, componentType: string | null = 'float') {
         if (length === 1) return componentType;
 
         let baseType = getTypeFromLength(length);
-        const prefix = componentType === 'float' ? '' : componentType[0];
+        const prefix = componentType === 'float' ? '' : componentType![0];
 
         // fix edge case for mat2x2 being same size as vec4
         if (/mat2/.test(componentType) === true) {
@@ -1278,7 +1412,7 @@ class NodeBuilder {
      * @param {TypedArray} array - The typed array.
      * @return {string} The type.
      */
-    getTypeFromArray(array) {
+    getTypeFromArray(array: TypedArray) {
         return typeFromArray.get(array.constructor);
     }
 
@@ -1298,10 +1432,10 @@ class NodeBuilder {
      * @param {BufferAttribute} attribute - The buffer attribute.
      * @return {string} The type.
      */
-    getTypeFromAttribute(attribute) {
-        let dataAttribute = attribute;
-
-        if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;
+    getTypeFromAttribute(attribute: BufferAttribute | InterleavedBufferAttribute) {
+        const dataAttribute = (attribute as InterleavedBufferAttribute).isInterleavedBufferAttribute
+            ? (attribute as InterleavedBufferAttribute).data
+            : attribute;
 
         const array = dataAttribute.array;
         const itemSize = attribute.itemSize;
@@ -1322,15 +1456,15 @@ class NodeBuilder {
      * @param {string} type - The data type.
      * @return {number} The length.
      */
-    getTypeLength(type) {
+    getTypeLength(type: string | null) {
         const vecType = this.getVectorType(type);
-        const vecNum = /vec([2-4])/.exec(vecType);
+        const vecNum = /vec([2-4])/.exec(vecType!);
 
         if (vecNum !== null) return Number(vecNum[1]);
         if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;
-        if (/mat2/.test(type) === true) return 4;
-        if (/mat3/.test(type) === true) return 9;
-        if (/mat4/.test(type) === true) return 16;
+        if (/mat2/.test(type!) === true) return 4;
+        if (/mat3/.test(type!) === true) return 9;
+        if (/mat4/.test(type!) === true) return 16;
 
         return 0;
     }
@@ -1341,7 +1475,7 @@ class NodeBuilder {
      * @param {string} type - The matrix type.
      * @return {string} The vector type.
      */
-    getVectorFromMatrix(type) {
+    getVectorFromMatrix(type: string) {
         return type.replace('mat', 'vec');
     }
 
@@ -1354,7 +1488,7 @@ class NodeBuilder {
      * @param {string} newComponentType - The new component type.
      * @return {string} The new type.
      */
-    changeComponentType(type, newComponentType) {
+    changeComponentType(type: string, newComponentType: string) {
         return this.getTypeFromLength(this.getTypeLength(type), newComponentType);
     }
 
@@ -1364,7 +1498,7 @@ class NodeBuilder {
      * @param {string} type - The type.
      * @return {string} The integer type.
      */
-    getIntegerType(type) {
+    getIntegerType(type: string) {
         const componentType = this.getComponentType(type);
 
         if (componentType === 'int' || componentType === 'uint') return type;
@@ -1409,7 +1543,11 @@ class NodeBuilder {
      * @param {?NodeCache} cache - An optional cache.
      * @return {Object} The node data.
      */
-    getDataFromNode(node, shaderStage = this.shaderStage, cache = null) {
+    getDataFromNode(
+        node: Node,
+        shaderStage: NodeShaderStage | 'any' = this.shaderStage!,
+        cache: NodeCache | null = null,
+    ) {
         cache = cache === null ? (node.isGlobal(this) ? this.globalCache : this.cache) : cache;
 
         let nodeData = cache.getData(node);
@@ -1422,7 +1560,7 @@ class NodeBuilder {
 
         if (nodeData[shaderStage] === undefined) nodeData[shaderStage] = {};
 
-        return nodeData[shaderStage];
+        return nodeData[shaderStage]!;
     }
 
     /**
@@ -1432,7 +1570,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.
      * @return {Object} The node properties.
      */
-    getNodeProperties(node, shaderStage = 'any') {
+    getNodeProperties(node: Node, shaderStage: NodeShaderStage | 'any' = 'any') {
         const nodeData = this.getDataFromNode(node, shaderStage);
 
         return nodeData.properties || (nodeData.properties = { outputNode: null });
@@ -1445,7 +1583,7 @@ class NodeBuilder {
      * @param {string} type - The node type.
      * @return {NodeAttribute} The node attribute.
      */
-    getBufferAttributeFromNode(node, type) {
+    getBufferAttributeFromNode(node: Node, type: string | null) {
         const nodeData = this.getDataFromNode(node);
 
         let bufferAttribute = nodeData.bufferAttribute;
@@ -1472,7 +1610,12 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
      * @return {StructType} The struct type attribute.
      */
-    getStructTypeFromNode(node, membersLayout, name = null, shaderStage = this.shaderStage) {
+    getStructTypeFromNode(
+        node: StructTypeNode,
+        membersLayout: MemberLayout[],
+        name: string | null = null,
+        shaderStage = this.shaderStage!,
+    ) {
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
         let structType = nodeData.structType;
@@ -1515,7 +1658,12 @@ class NodeBuilder {
      * @param {?string} name - The name of the uniform.
      * @return {NodeUniform} The node uniform.
      */
-    getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {
+    getUniformFromNode(
+        node: UniformNode<unknown>,
+        type: string | null,
+        shaderStage = this.shaderStage!,
+        name: string | null = null,
+    ) {
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
         let nodeUniform = nodeData.uniform;
@@ -1561,7 +1709,13 @@ class NodeBuilder {
      *
      * @return {NodeVar} The node variable.
      */
-    getVarFromNode(node, name = null, type = node.getNodeType(this), shaderStage = this.shaderStage, readOnly = false) {
+    getVarFromNode(
+        node: Node,
+        name: string | null = null,
+        type = node.getNodeType(this),
+        shaderStage = this.shaderStage!,
+        readOnly = false,
+    ) {
         const nodeData = this.getDataFromNode(node, shaderStage);
 
         let nodeVar = nodeData.variable;
@@ -1639,11 +1793,11 @@ class NodeBuilder {
      * @return {NodeVar} The node varying.
      */
     getVaryingFromNode(
-        node,
-        name = null,
+        node: Node,
+        name: string | null = null,
         type = node.getNodeType(this),
-        interpolationType = null,
-        interpolationSampling = null,
+        interpolationType: InterpolationSamplingType | null = null,
+        interpolationSampling: InterpolationSamplingMode | null = null,
     ) {
         const nodeData = this.getDataFromNode(node, 'any');
 
@@ -1706,7 +1860,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
      * @return {NodeCode} The node code.
      */
-    getCodeFromNode(node, type, shaderStage = this.shaderStage) {
+    getCodeFromNode(node: Node, type: string | null, shaderStage = this.shaderStage!) {
         const nodeData = this.getDataFromNode(node);
 
         let nodeCode = nodeData.code;
@@ -1779,7 +1933,7 @@ class NodeBuilder {
      * @param {?Node} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.
      * @return {NodeBuilder} A reference to this node builder.
      */
-    addLineFlowCode(code, node = null) {
+    addLineFlowCode(code: string, node = null) {
         if (code === '') return this;
 
         if (node !== null && this.context.nodeBlock) {
@@ -1803,7 +1957,7 @@ class NodeBuilder {
      * @param {string} code - Shader code.
      * @return {NodeBuilder} A reference to this node builder.
      */
-    addFlowCode(code) {
+    addFlowCode(code: string) {
         this.flow.code += code;
 
         return this;
@@ -1839,7 +1993,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {Object} The flow data.
      */
-    getFlowData(node /*, shaderStage*/) {
+    getFlowData(node: Node /*, shaderStage*/) {
         return this.flowsData.get(node);
     }
 
@@ -1849,7 +2003,7 @@ class NodeBuilder {
      * @param {Node} node - The node to execute.
      * @return {Object} The code flow.
      */
-    flowNode(node) {
+    flowNode(node: Node) {
         const output = node.getNodeType(this);
 
         const flowData = this.flowChildNode(node, output);
@@ -1865,12 +2019,14 @@ class NodeBuilder {
      * @param {Node} node - The node to include.
      * @returns {void}
      */
-    addInclude(node) {
+    addInclude(node: Node) {
         if (this.currentFunctionNode !== null) {
             this.currentFunctionNode.includes.push(node);
         }
     }
 
+    abstract buildFunctionCode(shaderNode: ShaderNodeInternal): string;
+
     /**
      * Returns the native shader operator name for a given generic name.
      * It is a similar type of method like {@link NodeBuilder#getMethod}.
@@ -1878,7 +2034,7 @@ class NodeBuilder {
      * @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.
      * @return {FunctionNode} The build function node.
      */
-    buildFunctionNode(shaderNode) {
+    buildFunctionNode(shaderNode: ShaderNodeInternal) {
         const fn = new FunctionNode();
 
         const previous = this.currentFunctionNode;
@@ -1898,7 +2054,7 @@ class NodeBuilder {
      * @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.
      * @return {Object}
      */
-    flowShaderNode(shaderNode) {
+    flowShaderNode(shaderNode: ShaderNodeInternal) {
         const layout = shaderNode.layout;
 
         const inputs = {
@@ -1914,7 +2070,7 @@ class NodeBuilder {
             },
         };
 
-        for (const input of layout.inputs) {
+        for (const input of layout!.inputs) {
             inputs[input.name] = new ParameterNode(input.type, input.name);
         }
 
@@ -1937,7 +2093,7 @@ class NodeBuilder {
      * @param {?string} output - Expected output type. For example 'vec3'.
      * @return {Object}
      */
-    flowStagesNode(node, output = null) {
+    flowStagesNode(node: Node, output: string | null = null) {
         const previousFlow = this.flow;
         const previousVars = this.vars;
         const previousDeclarations = this.declarations;
@@ -1945,7 +2101,7 @@ class NodeBuilder {
         const previousBuildStage = this.buildStage;
         const previousStack = this.stack;
 
-        const flow = {
+        const flow: Flow = {
             code: '',
         };
 
@@ -1961,7 +2117,7 @@ class NodeBuilder {
             flow.result = node.build(this, output);
         }
 
-        flow.vars = this.getVars(this.shaderStage);
+        flow.vars = this.getVars(this.shaderStage!);
 
         this.flow = previousFlow;
         this.vars = previousVars;
@@ -2004,10 +2160,10 @@ class NodeBuilder {
      * @param {?string} output - Expected output type. For example 'vec3'.
      * @return {Object} The code flow.
      */
-    flowChildNode(node, output = null) {
+    flowChildNode(node: Node, output: string | null = null) {
         const previousFlow = this.flow;
 
-        const flow = {
+        const flow: Flow = {
             code: '',
         };
 
@@ -2032,7 +2188,12 @@ class NodeBuilder {
      * @param {?string} propertyName - The property name to assign the result.
      * @return {Object}
      */
-    flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {
+    flowNodeFromShaderStage(
+        shaderStage: 'vertex' | 'fragment' | 'compute',
+        node: Node,
+        output: string | null = null,
+        propertyName: string | null = null,
+    ) {
         const previousShaderStage = this.shaderStage;
 
         this.setShaderStage(shaderStage);
@@ -2066,9 +2227,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The attribute code section.
      */
-    getAttributes(/*shaderStage*/) {
-        console.warn('Abstract function.');
-    }
+    abstract getAttributes(shaderStage: NodeShaderStage): string;
 
     /**
      * Returns the varying definitions as a shader string for the given shader stage.
@@ -2077,9 +2236,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The varying code section.
      */
-    getVaryings(/*shaderStage*/) {
-        console.warn('Abstract function.');
-    }
+    abstract getVaryings(shaderStage: NodeShaderStage): string;
 
     /**
      * Returns a single variable definition as a shader string for the given variable type and name.
@@ -2089,7 +2246,7 @@ class NodeBuilder {
      * @param {?number} [count=null] - The array length.
      * @return {string} The shader string.
      */
-    getVar(type, name, count = null) {
+    getVar(type: string, name: string, count: number | null = null) {
         return `${count !== null ? this.generateArrayDeclaration(type, count) : this.getType(type)} ${name}`;
     }
 
@@ -2099,7 +2256,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The variable code section.
      */
-    getVars(shaderStage) {
+    getVars(shaderStage: 'vertex' | 'fragment' | 'compute') {
         let snippet = '';
 
         const vars = this.vars[shaderStage];
@@ -2120,9 +2277,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The uniform code section.
      */
-    getUniforms(/*shaderStage*/) {
-        console.warn('Abstract function.');
-    }
+    abstract getUniforms(shaderStage: NodeShaderStage): string;
 
     /**
      * Returns the native code definitions as a shader string for the given shader stage.
@@ -2130,7 +2285,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The native code section.
      */
-    getCodes(shaderStage) {
+    getCodes(shaderStage: 'vertex' | 'fragment' | 'compute') {
         const codes = this.codes[shaderStage];
 
         let code = '';
@@ -2150,7 +2305,7 @@ class NodeBuilder {
      * @return {string} The hash.
      */
     getHash() {
-        return this.vertexShader + this.fragmentShader + this.computeShader;
+        return this.vertexShader! + this.fragmentShader + this.computeShader;
     }
 
     /**
@@ -2158,7 +2313,7 @@ class NodeBuilder {
      *
      * @param {?('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage to set.
      */
-    setShaderStage(shaderStage) {
+    setShaderStage(shaderStage: NodeShaderStage | null) {
         this.shaderStage = shaderStage;
     }
 
@@ -2176,7 +2331,7 @@ class NodeBuilder {
      *
      * @param {?('setup'|'analyze'|'generate')} buildStage - The build stage to set.
      */
-    setBuildStage(buildStage) {
+    setBuildStage(buildStage: string | null) {
         this.buildStage = buildStage;
     }
 
@@ -2264,7 +2419,7 @@ class NodeBuilder {
      * @param {string} type - The requested type.
      * @return {Uniform} The uniform.
      */
-    getNodeUniform(uniformNode, type) {
+    getNodeUniform(uniformNode: NodeUniform<unknown>, type: string | null) {
         if (type === 'float' || type === 'int' || type === 'uint') return new NumberNodeUniform(uniformNode);
         if (type === 'vec2' || type === 'ivec2' || type === 'uvec2') return new Vector2NodeUniform(uniformNode);
         if (type === 'vec3' || type === 'ivec3' || type === 'uvec3') return new Vector3NodeUniform(uniformNode);
@@ -2287,7 +2442,7 @@ class NodeBuilder {
      * @param {string} toType - The target type.
      * @return {string} The updated shader string.
      */
-    format(snippet, fromType, toType) {
+    format(snippet: string, fromType: string | null, toType: string | null): string {
         fromType = this.getVectorType(fromType);
         toType = this.getVectorType(toType);
 
diff --git a/src-testing/src/nodes/core/NodeCache.ts b/src-testing/src/nodes/core/NodeCache.ts
index 60ca0039..180c7e3b 100644
--- a/src-testing/src/nodes/core/NodeCache.ts
+++ b/src-testing/src/nodes/core/NodeCache.ts
@@ -1,16 +1,64 @@
+import NodeAttribute from './NodeAttribute.js';
+import NodeUniform from './NodeUniform.js';
+import NodeVar from './NodeVar.js';
+import NodeVarying from './NodeVarying.js';
+import NodeCode from './NodeCode.js';
+import Node from './Node.js';
+import BufferAttributeNode from '../accessors/BufferAttributeNode.js';
+import { BufferAttribute, TypedArray } from '../../core/BufferAttribute.js';
+import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
+import StructType from './StructType.js';
+
 let _id = 0;
 
+export interface ShaderStageNodeData {
+    properties?:
+        | ({
+              outputNode: Node | null;
+              initialized?: boolean | undefined;
+          } & {
+              [K in `node${string}`]?: Node | undefined;
+          })
+        | undefined;
+    bufferAttribute?: NodeAttribute | undefined;
+    structType?: StructType | undefined;
+    uniform?: NodeUniform<unknown> | undefined;
+    variable?: NodeVar | undefined;
+    varying?: NodeVarying | undefined;
+    code?: NodeCode | undefined;
+    usageCount?: number | undefined;
+    snippet?: string | undefined;
+    propertyName?: string | undefined;
+    propertySizeName?: string | undefined;
+}
+
+interface NodeData {
+    vertex?: ShaderStageNodeData | undefined;
+    fragment?: ShaderStageNodeData | undefined;
+    compute?: ShaderStageNodeData | undefined;
+    any?: ShaderStageNodeData | undefined;
+}
+
+interface BufferAttributeData {
+    node: BufferAttributeNode;
+}
+
 /**
  * This utility class is used in {@link NodeBuilder} as an internal
  * cache data structure for node data.
  */
 class NodeCache {
+    id: number;
+    nodesData: WeakMap<Node | TypedArray | InterleavedBuffer | BufferAttribute, NodeData | BufferAttributeData>;
+
+    parent: NodeCache | null;
+
     /**
      * Constructs a new node cache.
      *
      * @param {?NodeCache} parent - A reference to a parent cache.
      */
-    constructor(parent = null) {
+    constructor(parent: NodeCache | null = null) {
         /**
          * The id of the cache.
          *
@@ -41,11 +89,13 @@ class NodeCache {
      * @param {Node} node - The node.
      * @return {?Object} The data for the node.
      */
-    getData(node) {
+    getData(node: Node): NodeData | undefined;
+    getData(node: TypedArray | InterleavedBuffer | BufferAttribute): BufferAttributeData | undefined;
+    getData(node: Node | TypedArray | InterleavedBuffer | BufferAttribute): NodeData | BufferAttributeData | undefined {
         let data = this.nodesData.get(node);
 
         if (data === undefined && this.parent !== null) {
-            data = this.parent.getData(node);
+            data = this.parent.getData(node as Node);
         }
 
         return data;
@@ -57,7 +107,9 @@ class NodeCache {
      * @param {Node} node - The node.
      * @param {Object} data - The data that should be cached.
      */
-    setData(node, data) {
+    setData(node: Node, data: NodeData): void;
+    setData(node: TypedArray | InterleavedBuffer | BufferAttribute, data: BufferAttributeData): void;
+    setData(node: Node | TypedArray | InterleavedBuffer | BufferAttribute, data: NodeData | BufferAttributeData) {
         this.nodesData.set(node, data);
     }
 }
diff --git a/src-testing/src/nodes/core/NodeCode.ts b/src-testing/src/nodes/core/NodeCode.ts
index 7cf21cda..08eb89d0 100644
--- a/src-testing/src/nodes/core/NodeCode.ts
+++ b/src-testing/src/nodes/core/NodeCode.ts
@@ -5,6 +5,10 @@
  * for this purpose.
  */
 class NodeCode {
+    name: string;
+    type: string | null;
+    code: string;
+
     /**
      * Constructs a new code node.
      *
@@ -12,7 +16,7 @@ class NodeCode {
      * @param {string} type - The node type.
      * @param {string} [code=''] - The native shader code.
      */
-    constructor(name, type, code = '') {
+    constructor(name: string, type: string | null, code = '') {
         /**
          * The name of the code.
          *
diff --git a/src-testing/src/nodes/core/NodeFrame.ts b/src-testing/src/nodes/core/NodeFrame.ts
index 017e4de2..25752cc2 100644
--- a/src-testing/src/nodes/core/NodeFrame.ts
+++ b/src-testing/src/nodes/core/NodeFrame.ts
@@ -1,4 +1,7 @@
 import { NodeUpdateType } from './constants.js';
+import Node from './Node.js';
+import Renderer from '../../renderers/common/Renderer.js';
+import { Camera, Material, Object3D, Scene } from 'three';
 
 /**
  * Management class for updating nodes. The module tracks metrics like
@@ -7,6 +10,23 @@ import { NodeUpdateType } from './constants.js';
  * and {@link Node#updateAfter} depending on the node's configuration.
  */
 class NodeFrame {
+    time: number;
+    deltaTime: number;
+
+    frameId: number;
+    renderId: number;
+
+    // TODO startTime
+
+    // TODO updateMap
+    // TODO updateBeforeMap
+
+    renderer: Renderer | null;
+    material: Material | null;
+    camera: Camera | null;
+    object: Object3D | null;
+    scene: Scene | null;
+
     /**
      * Constructs a new node fame.
      */
@@ -137,7 +157,7 @@ class NodeFrame {
      *
      * @param {Node} node - The node that should be updated.
      */
-    updateBeforeNode(node) {
+    updateBeforeNode(node: Node) {
         const updateType = node.getUpdateBeforeType();
         const reference = node.updateReference(this);
 
@@ -203,7 +223,7 @@ class NodeFrame {
      *
      * @param {Node} node - The node that should be updated.
      */
-    updateNode(node) {
+    updateNode(node: Node) {
         const updateType = node.getUpdateType();
         const reference = node.updateReference(this);
 
diff --git a/src-testing/src/nodes/core/NodeParser.ts b/src-testing/src/nodes/core/NodeParser.ts
index a7db4aab..65e57edd 100644
--- a/src-testing/src/nodes/core/NodeParser.ts
+++ b/src-testing/src/nodes/core/NodeParser.ts
@@ -1,8 +1,10 @@
+import NodeFunction from './NodeFunction.js';
+
 /**
  * Base class for node parsers. A derived parser must be implemented
  * for each supported native shader language.
  */
-class NodeParser {
+abstract class NodeParser {
     /**
      * The method parses the given native code an returns a node function.
      *
@@ -10,9 +12,7 @@ class NodeParser {
      * @param {string} source - The native shader code.
      * @return {NodeFunction} A node function.
      */
-    parseFunction(/*source*/) {
-        console.warn('Abstract function.');
-    }
+    abstract parseFunction(source: string): NodeFunction;
 }
 
 export default NodeParser;
diff --git a/src-testing/src/nodes/core/NodeUniform.ts b/src-testing/src/nodes/core/NodeUniform.ts
index a161dada..ed07bd6d 100644
--- a/src-testing/src/nodes/core/NodeUniform.ts
+++ b/src-testing/src/nodes/core/NodeUniform.ts
@@ -1,10 +1,19 @@
+import UniformNode from './UniformNode.js';
+
 /**
  * {@link NodeBuilder} is going to create instances of this class during the build process
  * of nodes. They represent the final shader uniforms that are going to be generated
  * by the builder. A dictionary of node uniforms is maintained in {@link NodeBuilder#uniforms}
  * for this purpose.
  */
-class NodeUniform {
+class NodeUniform<TValue> {
+    readonly isNodeUniform: true;
+
+    name: string;
+    type: string | null;
+    node: UniformNode<TValue>;
+    needsUpdate: boolean | undefined;
+
     /**
      * Constructs a new node uniform.
      *
@@ -12,7 +21,7 @@ class NodeUniform {
      * @param {string} type - The type of the uniform.
      * @param {UniformNode} node - An reference to the node.
      */
-    constructor(name, type, node) {
+    constructor(name: string, type: string | null, node: UniformNode<TValue>) {
         /**
          * This flag can be used for type testing.
          *
diff --git a/src-testing/src/nodes/core/NodeUtils.ts b/src-testing/src/nodes/core/NodeUtils.ts
index 91b1d9ba..ca165e48 100644
--- a/src-testing/src/nodes/core/NodeUtils.ts
+++ b/src-testing/src/nodes/core/NodeUtils.ts
@@ -5,13 +5,14 @@ import { Matrix4 } from '../../math/Matrix4.js';
 import { Vector2 } from '../../math/Vector2.js';
 import { Vector3 } from '../../math/Vector3.js';
 import { Vector4 } from '../../math/Vector4.js';
+import Node from './Node.js';
 
 // cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.
 // A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.
 // Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.
 // See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480
 // https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js
-function cyrb53(value, seed = 0) {
+function cyrb53(value: number[] | string, seed: number = 0) {
     let h1 = 0xdeadbeef ^ seed,
         h2 = 0x41c6ce57 ^ seed;
 
@@ -44,7 +45,7 @@ function cyrb53(value, seed = 0) {
  * @param {string} str - The string to be hashed.
  * @return {number} The hash.
  */
-export const hashString = str => cyrb53(str);
+export const hashString = (str: string) => cyrb53(str);
 
 /**
  * Computes a hash for the given array.
@@ -53,7 +54,7 @@ export const hashString = str => cyrb53(str);
  * @param {Array<number>} array - The array to be hashed.
  * @return {number} The hash.
  */
-export const hashArray = array => cyrb53(array);
+export const hashArray = (array: number[]) => cyrb53(array);
 
 /**
  * Computes a hash for the given list of parameters.
@@ -62,7 +63,7 @@ export const hashArray = array => cyrb53(array);
  * @param {...number} params - A list of parameters.
  * @return {number} The hash.
  */
-export const hash = (...params) => cyrb53(params);
+export const hash = (...params: number[]) => cyrb53(params);
 
 /**
  * Computes a cache key for the given node.
@@ -72,12 +73,12 @@ export const hash = (...params) => cyrb53(params);
  * @param {boolean} [force=false] - Whether to force a cache key computation or not.
  * @return {number} The hash.
  */
-export function getCacheKey(object, force = false) {
-    const values = [];
+export function getCacheKey(object: object, force = false) {
+    const values: number[] = [];
 
-    if (object.isNode === true) {
-        values.push(object.id);
-        object = object.getSelf();
+    if ((object as Node).isNode === true) {
+        values.push((object as Node).id);
+        object = (object as Node).getSelf();
     }
 
     for (const { property, childNode } of getNodeChildren(object)) {
@@ -86,6 +87,17 @@ export function getCacheKey(object, force = false) {
 
     return cyrb53(values);
 }
+export interface NodeChild {
+    property: string;
+    index?: number | string;
+    childNode: Node;
+}
+
+export interface NodeChildWithToJSON {
+    property: string;
+    index?: number | string;
+    childNode: Node | { toJSON: () => unknown };
+}
 
 /**
  * This generator function can be used to iterate over the node children
@@ -96,29 +108,39 @@ export function getCacheKey(object, force = false) {
  * @param {boolean} [toJSON=false] - Whether to return JSON or not.
  * @yields {Object} A result node holding the property, index (if available) and the child node.
  */
-export function* getNodeChildren(node, toJSON = false) {
+export function getNodeChildren(node: object): Generator<NodeChild, void, unknown>;
+export function getNodeChildren(node: object, toJSON: boolean): Generator<NodeChildWithToJSON, void, unknown>;
+export function* getNodeChildren(node: object, toJSON = false) {
     for (const property in node) {
         // Ignore private properties.
         if (property.startsWith('_') === true) continue;
 
-        const object = node[property];
+        const object = node[property as keyof typeof node] as unknown;
 
         if (Array.isArray(object) === true) {
             for (let i = 0; i < object.length; i++) {
-                const child = object[i];
-
-                if (child && (child.isNode === true || (toJSON && typeof child.toJSON === 'function'))) {
-                    yield { property, index: i, childNode: child };
+                const child = object[i] as unknown;
+
+                if (
+                    child &&
+                    ((child as Node).isNode === true ||
+                        (toJSON && typeof (child as { toJSON: () => unknown }).toJSON === 'function'))
+                ) {
+                    yield { property, index: i, childNode: child as Node | { toJSON: () => unknown } };
                 }
             }
-        } else if (object && object.isNode === true) {
-            yield { property, childNode: object };
+        } else if (object && (object as Node).isNode === true) {
+            yield { property, childNode: object as Node };
         } else if (typeof object === 'object') {
             for (const subProperty in object) {
-                const child = object[subProperty];
-
-                if (child && (child.isNode === true || (toJSON && typeof child.toJSON === 'function'))) {
-                    yield { property, index: subProperty, childNode: child };
+                const child = object[subProperty as keyof typeof object];
+
+                if (
+                    child &&
+                    ((child as Node).isNode === true ||
+                        (toJSON && typeof (child as { toJSON: () => unknown }).toJSON === 'function'))
+                ) {
+                    yield { property, index: subProperty, childNode: child as Node | { toJSON: () => unknown } };
                 }
             }
         }
@@ -202,7 +224,7 @@ export function getLengthFromType(type) {
  * @param {any} value - The value.
  * @return {?string} The data type.
  */
-export function getValueType(value) {
+export function getValueType(value: unknown) {
     if (value === undefined || value === null) return null;
 
     const typeOf = typeof value;
diff --git a/src-testing/src/nodes/core/NodeVar.ts b/src-testing/src/nodes/core/NodeVar.ts
index 1bc2f6d1..07624271 100644
--- a/src-testing/src/nodes/core/NodeVar.ts
+++ b/src-testing/src/nodes/core/NodeVar.ts
@@ -5,6 +5,16 @@
  * this purpose.
  */
 class NodeVar {
+    readonly isNodeVar: true;
+
+    name: string;
+
+    type: string;
+
+    readOnly: boolean;
+
+    count: number | null;
+
     /**
      * Constructs a new node variable.
      *
@@ -13,7 +23,7 @@ class NodeVar {
      * @param {boolean} [readOnly=false] - The read-only flag.
      * @param {?number} [count=null] - The size.
      */
-    constructor(name, type, readOnly = false, count = null) {
+    constructor(name: string, type: string, readOnly = false, count: number | null = null) {
         /**
          * This flag can be used for type testing.
          *
diff --git a/src-testing/src/nodes/core/NodeVarying.ts b/src-testing/src/nodes/core/NodeVarying.ts
index d434bea5..baaec68f 100644
--- a/src-testing/src/nodes/core/NodeVarying.ts
+++ b/src-testing/src/nodes/core/NodeVarying.ts
@@ -1,4 +1,5 @@
 import NodeVar from './NodeVar.js';
+import { InterpolationSamplingMode, InterpolationSamplingType } from '../../constants.js';
 
 /**
  * {@link NodeBuilder} is going to create instances of this class during the build process
@@ -9,6 +10,13 @@ import NodeVar from './NodeVar.js';
  * @augments NodeVar
  */
 class NodeVarying extends NodeVar {
+    needsInterpolation: boolean;
+
+    readonly isNodeVarying: true;
+
+    interpolationType: InterpolationSamplingType | null;
+    interpolationSampling: InterpolationSamplingMode | null;
+
     /**
      * Constructs a new node varying.
      *
@@ -17,7 +25,12 @@ class NodeVarying extends NodeVar {
      * @param {?string} interpolationType - The interpolation type of the varying.
      * @param {?string} interpolationSampling - The interpolation sampling type of the varying.
      */
-    constructor(name, type, interpolationType = null, interpolationSampling = null) {
+    constructor(
+        name: string,
+        type: string,
+        interpolationType: InterpolationSamplingType | null = null,
+        interpolationSampling: InterpolationSamplingMode | null = null,
+    ) {
         super(name, type);
 
         /**
diff --git a/src-testing/src/nodes/core/StackNode.ts b/src-testing/src/nodes/core/StackNode.ts
index 09205527..5704461e 100644
--- a/src-testing/src/nodes/core/StackNode.ts
+++ b/src-testing/src/nodes/core/StackNode.ts
@@ -1,6 +1,7 @@
 import Node from './Node.js';
 import { select } from '../math/ConditionalNode.js';
-import { ShaderNode, nodeProxy, getCurrentStack, setCurrentStack } from '../tsl/TSLBase.js';
+import { ShaderNode, nodeProxy, getCurrentStack, setCurrentStack, ShaderNodeObject } from '../tsl/TSLBase.js';
+import NodeBuilder from './NodeBuilder.js';
 
 /**
  * Stack is a helper for Nodes that need to produce stack-based code instead of continuous flow.
@@ -13,6 +14,15 @@ class StackNode extends Node {
         return 'StackNode';
     }
 
+    nodes: Node[];
+    outputNode: Node | null;
+
+    parent: ShaderNodeObject<StackNode> | null;
+
+    _currentCond: ShaderNodeObject<Node> | null;
+
+    readonly isStackNode: true;
+
     /**
      * Constructs a new stack node.
      *
@@ -63,7 +73,7 @@ class StackNode extends Node {
         this.isStackNode = true;
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.outputNode ? this.outputNode.getNodeType(builder) : 'void';
     }
 
@@ -77,7 +87,7 @@ class StackNode extends Node {
      * @param {Node} node - The node to add.
      * @return {StackNode} A reference to this stack node.
      */
-    add(node) {
+    add(node: Node) {
         this.nodes.push(node);
 
         return this;
@@ -90,7 +100,7 @@ class StackNode extends Node {
      * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
      * @return {StackNode} A reference to this stack node.
      */
-    If(boolNode, method) {
+    If(boolNode: Node, method: () => void) {
         const methodNode = new ShaderNode(method);
         this._currentCond = select(boolNode, methodNode);
 
@@ -104,7 +114,7 @@ class StackNode extends Node {
      * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
      * @return {StackNode} A reference to this stack node.
      */
-    ElseIf(boolNode, method) {
+    ElseIf(boolNode: Node, method: () => void) {
         const methodNode = new ShaderNode(method);
         const ifNode = select(boolNode, methodNode);
 
@@ -120,13 +130,13 @@ class StackNode extends Node {
      * @param {Function} method - TSL code which is executed in the `else` case.
      * @return {StackNode} A reference to this stack node.
      */
-    Else(method) {
+    Else(method: () => void) {
         this._currentCond.elseNode = new ShaderNode(method);
 
         return this;
     }
 
-    build(builder, ...params) {
+    build(builder: NodeBuilder, ...params) {
         const previousStack = getCurrentStack();
 
         setCurrentStack(this);
diff --git a/src-testing/src/nodes/core/StructType.ts b/src-testing/src/nodes/core/StructType.ts
index b06830b4..27e70330 100644
--- a/src-testing/src/nodes/core/StructType.ts
+++ b/src-testing/src/nodes/core/StructType.ts
@@ -1,5 +1,11 @@
+import { MemberLayout } from './StructTypeNode.js';
+
 class StructType {
-    constructor(name, members) {
+    name: string;
+    members: MemberLayout[];
+    output: boolean;
+
+    constructor(name: string, members: MemberLayout[]) {
         this.name = name;
         this.members = members;
         this.output = false;
diff --git a/src-testing/src/nodes/core/StructTypeNode.ts b/src-testing/src/nodes/core/StructTypeNode.ts
index aee48070..1a10ed51 100644
--- a/src-testing/src/nodes/core/StructTypeNode.ts
+++ b/src-testing/src/nodes/core/StructTypeNode.ts
@@ -1,5 +1,16 @@
 import Node from './Node.js';
 import { getLengthFromType } from './NodeUtils.js';
+import NodeBuilder from './NodeBuilder.js';
+
+export interface MembersLayout {
+    [name: string]: string | { type: string; atomic?: boolean };
+}
+
+export interface MemberLayout {
+    name: string;
+    type: string;
+    atomic: boolean;
+}
 
 /**
  * Generates a layout for struct members.
@@ -9,7 +20,7 @@ import { getLengthFromType } from './NodeUtils.js';
  * @param {Object.<string, string|Object>} members - An object where keys are member names and values are either types (as strings) or objects with type and atomic properties.
  * @returns {Array.<{name: string, type: string, atomic: boolean}>} An array of member layouts.
  */
-function getMembersLayout(members) {
+function getMembersLayout(members: MembersLayout) {
     return Object.entries(members).map(([name, value]) => {
         if (typeof value === 'string') {
             return { name, type: value, atomic: false };
@@ -32,13 +43,18 @@ class StructTypeNode extends Node {
         return 'StructTypeNode';
     }
 
+    membersLayout: MemberLayout[];
+    name: string | null;
+
+    readonly isStructLayoutNode: true;
+
     /**
      * Creates an instance of StructTypeNode.
      *
      * @param {Object} membersLayout - The layout of the members for the struct.
      * @param {?string} [name=null] - The optional name of the struct.
      */
-    constructor(membersLayout, name = null) {
+    constructor(membersLayout: MembersLayout, name: string | null = null) {
         super('struct');
 
         /**
@@ -76,29 +92,29 @@ class StructTypeNode extends Node {
         let length = 0;
 
         for (const member of this.membersLayout) {
-            length += getLengthFromType(member.type);
+            length += getLengthFromType(member.type)!;
         }
 
         return length;
     }
 
-    getMemberType(builder, name) {
+    getMemberType(builder: NodeBuilder, name: string) {
         const member = this.membersLayout.find(m => m.name === name);
 
         return member ? member.type : 'void';
     }
 
-    getNodeType(builder) {
-        const structType = builder.getStructTypeFromNode(this, this.membersLayout, this.name);
+    getNodeType(builder: NodeBuilder) {
+        const structType = builder.getStructTypeFromNode(this, this.membersLayout, this.name)!;
 
         return structType.name;
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         builder.addInclude(this);
     }
 
-    generate(builder) {
+    generate(builder: NodeBuilder) {
         return this.getNodeType(builder);
     }
 }
diff --git a/src-testing/src/nodes/core/UniformGroupNode.ts b/src-testing/src/nodes/core/UniformGroupNode.ts
index 94299fca..125e9ad4 100644
--- a/src-testing/src/nodes/core/UniformGroupNode.ts
+++ b/src-testing/src/nodes/core/UniformGroupNode.ts
@@ -1,4 +1,4 @@
-import Node from './Node.js';
+import Node, { NodeJSONInputData, NodeJSONIntermediateOutputData } from './Node.js';
 
 /**
  * This node can be used to group single instances of {@link UniformNode}
@@ -18,6 +18,10 @@ class UniformGroupNode extends Node {
         return 'UniformGroupNode';
     }
 
+    shared: boolean;
+    order: number;
+    readonly isUniformGroup: true;
+
     /**
      * Constructs a new uniform group node.
      *
@@ -62,7 +66,7 @@ class UniformGroupNode extends Node {
         this.isUniformGroup = true;
     }
 
-    serialize(data) {
+    serialize(data: NodeJSONIntermediateOutputData) {
         super.serialize(data);
 
         data.name = this.name;
@@ -70,7 +74,7 @@ class UniformGroupNode extends Node {
         data.shared = this.shared;
     }
 
-    deserialize(data) {
+    deserialize(data: NodeJSONInputData) {
         super.deserialize(data);
 
         this.name = data.name;
diff --git a/src-testing/src/nodes/core/UniformNode.ts b/src-testing/src/nodes/core/UniformNode.ts
index 267d4433..a369001b 100644
--- a/src-testing/src/nodes/core/UniformNode.ts
+++ b/src-testing/src/nodes/core/UniformNode.ts
@@ -1,24 +1,33 @@
 import InputNode from './InputNode.js';
-import { objectGroup } from './UniformGroupNode.js';
+import UniformGroupNode, { objectGroup } from './UniformGroupNode.js';
 import { nodeObject, getConstNodeType } from '../tsl/TSLCore.js';
+import Node from './Node.js';
+import NodeBuilder from './NodeBuilder.js';
+import NodeFrame from './NodeFrame.js';
+import { NodeUpdateType } from './constants.js';
 
 /**
  * Class for representing a uniform.
  *
  * @augments InputNode
  */
-class UniformNode extends InputNode {
+class UniformNode<TValue> extends InputNode<TValue> {
     static get type() {
         return 'UniformNode';
     }
 
+    readonly isUniformNode: true;
+
+    name: string;
+    groupNode: UniformGroupNode;
+
     /**
      * Constructs a new uniform node.
      *
      * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
      * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
      */
-    constructor(value, nodeType = null) {
+    constructor(value: TValue, nodeType: string | null = null) {
         super(value, nodeType);
 
         /**
@@ -54,7 +63,7 @@ class UniformNode extends InputNode {
      * @param {string} name - The name of the uniform.
      * @return {UniformNode} A reference to this node.
      */
-    label(name) {
+    label(name: string) {
         this.name = name;
 
         return this;
@@ -66,7 +75,7 @@ class UniformNode extends InputNode {
      * @param {UniformGroupNode} group - The uniform group.
      * @return {UniformNode} A reference to this node.
      */
-    setGroup(group) {
+    setGroup(group: UniformGroupNode) {
         this.groupNode = group;
 
         return this;
@@ -88,11 +97,11 @@ class UniformNode extends InputNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The uniform hash.
      */
-    getUniformHash(builder) {
+    getUniformHash(builder: NodeBuilder) {
         return this.getHash(builder);
     }
 
-    onUpdate(callback, updateType) {
+    onUpdate(callback: (frame: NodeFrame, self: this) => TValue | undefined, updateType: NodeUpdateType) {
         const self = this.getSelf();
 
         callback = callback.bind(self);
@@ -106,12 +115,12 @@ class UniformNode extends InputNode {
         }, updateType);
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output: string | null) {
         const type = this.getNodeType(builder);
 
         const hash = this.getUniformHash(builder);
 
-        let sharedNode = builder.getNodeFromHash(hash);
+        let sharedNode = builder.getNodeFromHash(hash) as this;
 
         if (sharedNode === undefined) {
             builder.setHashNode(this, hash);
@@ -124,7 +133,7 @@ class UniformNode extends InputNode {
         const nodeUniform = builder.getUniformFromNode(
             sharedNode,
             sharedNodeType,
-            builder.shaderStage,
+            builder.shaderStage!,
             this.name || builder.context.label,
         );
         const propertyName = builder.getPropertyName(nodeUniform);
@@ -146,11 +155,14 @@ export default UniformNode;
  * @param {string} [arg2] - The node type. If no explicit type is defined, the node tries to derive the type from its value.
  * @returns {UniformNode}
  */
-export const uniform = (arg1, arg2) => {
+export const uniform = <TValue>(arg1: InputNode<TValue> | TValue, arg2?: Node | string) => {
     const nodeType = getConstNodeType(arg2 || arg1);
 
     // @TODO: get ConstNode from .traverse() in the future
-    const value = arg1 && arg1.isNode === true ? (arg1.node && arg1.node.value) || arg1.value : arg1;
+    const value: TValue =
+        arg1 && (arg1 as Node).isNode === true
+            ? (arg1.node && arg1.node.value) || (arg1 as InputNode<TValue>).value
+            : arg1;
 
     return nodeObject(new UniformNode(value, nodeType));
 };
diff --git a/src-testing/src/nodes/core/constants.ts b/src-testing/src/nodes/core/constants.ts
index 1fe2dbbd..a431897f 100644
--- a/src-testing/src/nodes/core/constants.ts
+++ b/src-testing/src/nodes/core/constants.ts
@@ -7,7 +7,7 @@
 export const NodeShaderStage = {
     VERTEX: 'vertex',
     FRAGMENT: 'fragment',
-};
+} as const;
 
 /**
  * Update types of a node.
@@ -22,7 +22,7 @@ export const NodeUpdateType = {
     FRAME: 'frame',
     RENDER: 'render',
     OBJECT: 'object',
-};
+} as const;
 
 /**
  * Data types of a node.
@@ -47,7 +47,7 @@ export const NodeType = {
     MATRIX2: 'mat2',
     MATRIX3: 'mat3',
     MATRIX4: 'mat4',
-};
+} as const;
 
 /**
  * Access types of a node. These are relevant for compute and storage usage.
@@ -60,9 +60,13 @@ export const NodeAccess = {
     READ_ONLY: 'readOnly',
     WRITE_ONLY: 'writeOnly',
     READ_WRITE: 'readWrite',
-};
+} as const;
 
-export const defaultShaderStages = ['fragment', 'vertex'];
+export type NodeShaderStage = 'vertex' | 'fragment' | 'compute';
+export type NodeUpdateType = 'none' | 'frame' | 'render' | 'object';
+export type NodeAccess = 'readOnly' | 'writeOnly' | 'readWrite';
+
+export const defaultShaderStages: NodeShaderStage[] = ['fragment', 'vertex'];
 export const defaultBuildStages = ['setup', 'analyze', 'generate'];
-export const shaderStages = [...defaultShaderStages, 'compute'];
+export const shaderStages: NodeShaderStage[] = [...defaultShaderStages, 'compute'];
 export const vectorComponents = ['x', 'y', 'z', 'w'];
diff --git a/src-testing/src/nodes/lighting/LightingContextNode.ts b/src-testing/src/nodes/lighting/LightingContextNode.ts
index ee5cf92a..c58f0886 100644
--- a/src-testing/src/nodes/lighting/LightingContextNode.ts
+++ b/src-testing/src/nodes/lighting/LightingContextNode.ts
@@ -1,5 +1,23 @@
 import ContextNode from '../core/ContextNode.js';
-import { nodeProxy, float, vec3 } from '../tsl/TSLBase.js';
+import { nodeProxy, float, vec3, ShaderNodeObject } from '../tsl/TSLBase.js';
+import Node from '../core/Node.js';
+import NodeBuilder from '../core/NodeBuilder.js';
+import LightingModel from '../core/LightingModel.js';
+
+interface LightingContext {
+    radiance: ShaderNodeObject<Node>;
+    irradiance: ShaderNodeObject<Node>;
+    iblIrradiance: ShaderNodeObject<Node>;
+    ambientOcclusion: ShaderNodeObject<Node>;
+    reflectedLight: {
+        directDiffuse: ShaderNodeObject<Node>;
+        directSpecular: ShaderNodeObject<Node>;
+        indirectDiffuse: ShaderNodeObject<Node>;
+        indirectSpecular: ShaderNodeObject<Node>;
+    };
+    backdrop: Node | null;
+    backdropAlpha: Node | null;
+}
 
 /**
  * `LightingContextNode` represents an extension of the {@link ContextNode} module
@@ -8,11 +26,17 @@ import { nodeProxy, float, vec3 } from '../tsl/TSLBase.js';
  *
  * @augments ContextNode
  */
-class LightingContextNode extends ContextNode {
+class LightingContextNode extends ContextNode<LightingContext> {
     static get type() {
         return 'LightingContextNode';
     }
 
+    lightingModel: LightingModel | null;
+    backdropNode: Node | null;
+    backdropAlphaNode: Node | null;
+
+    _value: LightingContext | null;
+
     /**
      * Constructs a new lighting context node.
      *
@@ -21,8 +45,13 @@ class LightingContextNode extends ContextNode {
      * @param {?Node<vec3>} [backdropNode=null] - A backdrop node.
      * @param {?Node<float>} [backdropAlphaNode=null] - A backdrop alpha node.
      */
-    constructor(lightsNode, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
-        super(lightsNode);
+    constructor(
+        lightsNode: Node,
+        lightingModel: LightingModel | null = null,
+        backdropNode: Node | null = null,
+        backdropAlphaNode: Node | null = null,
+    ) {
+        super(node);
 
         /**
          * The current lighting model.
@@ -79,7 +108,7 @@ class LightingContextNode extends ContextNode {
             indirectSpecular,
         };
 
-        const context = {
+        const context: LightingContext = {
             radiance: vec3().toVar('radiance'),
             irradiance: vec3().toVar('irradiance'),
             iblIrradiance: vec3().toVar('iblIrradiance'),
@@ -92,7 +121,7 @@ class LightingContextNode extends ContextNode {
         return context;
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         this.value = this._value || (this._value = this.getContext());
         this.value.lightingModel = this.lightingModel || builder.context.lightingModel;
 
diff --git a/src-testing/src/nodes/tsl/TSLCore.ts b/src-testing/src/nodes/tsl/TSLCore.ts
index cb8cb804..270726a0 100644
--- a/src-testing/src/nodes/tsl/TSLCore.ts
+++ b/src-testing/src/nodes/tsl/TSLCore.ts
@@ -8,9 +8,38 @@ import FlipNode from '../utils/FlipNode.js';
 import ConstNode from '../core/ConstNode.js';
 import MemberNode from '../utils/MemberNode.js';
 import { getValueFromType, getValueType } from '../core/NodeUtils.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 let currentStack = null;
 
+export interface NodeElements {
+    append: typeof append;
+
+    toColor: typeof color;
+    toFloat: typeof float;
+    toInt: typeof int;
+    toUint: typeof uint;
+    toBool: typeof bool;
+    toVec2: typeof vec2;
+    toIvec2: typeof ivec2;
+    toUvec2: typeof uvec2;
+    toBvec2: typeof bvec2;
+    toVec3: typeof vec3;
+    toIvec3: typeof ivec3;
+    toUvec3: typeof uvec3;
+    toBvec3: typeof bvec3;
+    toVec4: typeof vec4;
+    toIvec4: typeof ivec4;
+    toUvec4: typeof uvec4;
+    toBvec4: typeof bvec4;
+    toMat2: typeof mat2;
+    toMat3: typeof mat3;
+    toMat4: typeof mat4;
+
+    element: typeof element;
+    convert: typeof convert;
+}
+
 const NodeElements = new Map();
 
 export function addMethodChaining(name, nodeElement) {
@@ -24,6 +53,141 @@ export function addMethodChaining(name, nodeElement) {
     NodeElements.set(name, nodeElement);
 }
 
+export type SwizzleCharacter = 'x' | 'y' | 'z' | 'w' | 'r' | 'g' | 'b' | 'a' | 's' | 't' | 'p' | 'q';
+
+export type SwizzleOption = Exclude<
+    | `${SwizzleCharacter}`
+    | `${SwizzleCharacter}${SwizzleCharacter}`
+    | `${SwizzleCharacter}${SwizzleCharacter}${SwizzleCharacter}`
+    | `${SwizzleCharacter}${SwizzleCharacter}${SwizzleCharacter}${SwizzleCharacter}`,
+    'abs' | 'sqrt'
+>;
+
+export type Swizzable<T extends Node = Node> = T & {
+    [key in SwizzleOption | number]: ShaderNodeObject<Node>;
+};
+
+export type ShaderNodeObject<T extends Node> = T & {
+    [Key in keyof NodeElements]: T extends { [K in Key]: infer M }
+        ? M
+        : NodeElements[Key] extends (node: T, ...args: infer Args) => infer R
+          ? (...args: Args) => R
+          : never;
+} & {
+    [Key in keyof NodeElements as `${Key}Assign`]: T extends { [K in Key]: infer M }
+        ? M
+        : NodeElements[Key] extends (node: T, ...args: infer Args) => unknown
+          ? (...args: Args) => ShaderNodeObject<T>
+          : never;
+} & Swizzable<T>;
+
+/** anything that can be passed to {@link nodeObject} and returns a proxy */
+export type NodeRepresentation<T extends Node = Node> = number | boolean | Node | ShaderNodeObject<T>;
+
+/** anything that can be passed to {@link nodeObject} */
+export type NodeObjectOption = NodeRepresentation | string;
+
+// same logic as in ShaderNodeObject: number,boolean,node->ShaderNodeObject, otherwise do nothing
+export type NodeObject<T> = T extends Node
+    ? ShaderNodeObject<T>
+    : T extends number | boolean
+      ? ShaderNodeObject<ConstNode<number | boolean>>
+      : T;
+
+// opposite of NodeObject: node -> node|ShaderNodeObject|boolean|number, otherwise do nothing
+type Proxied<T> = T extends Node ? NodeRepresentation<T> : T;
+// https://github.com/microsoft/TypeScript/issues/42435#issuecomment-765557874
+export type ProxiedTuple<T extends readonly [...unknown[]]> = [...{ [index in keyof T]: Proxied<T[index]> }];
+export type ProxiedObject<T> = { [index in keyof T]: Proxied<T[index]> };
+type RemoveTail<T extends readonly [...unknown[]]> = T extends [unknown, ...infer X] ? X : [];
+type RemoveHeadAndTail<T extends readonly [...unknown[]]> = T extends [unknown, ...infer X, unknown] ? X : [];
+
+/**
+ * Temporary type to save signatures of 4 constructors. Each element may be tuple or undefined.
+ *
+ * We use an object instead of tuple or union as it makes stuff easier, especially in Typescript 4.0.
+ */
+interface Construtors<
+    A extends undefined | [...unknown[]],
+    B extends undefined | [...unknown[]],
+    C extends undefined | [...unknown[]],
+    D extends undefined | [...unknown[]],
+> {
+    a: A;
+    b: B;
+    c: C;
+    d: D;
+}
+
+/**
+ * Returns all constructors
+ *
+ * <https://github.com/microsoft/TypeScript/issues/37079>
+ * <https://stackoverflow.com/a/52761156/1623826>
+ */
+type OverloadedConstructorsOf<T> = T extends {
+    new (...args: infer A1): unknown;
+    new (...args: infer A2): unknown;
+    new (...args: infer A3): unknown;
+    new (...args: infer A4): unknown;
+}
+    ? Construtors<A1, A2, A3, A4>
+    : T extends {
+            new (...args: infer A1): unknown;
+            new (...args: infer A2): unknown;
+            new (...args: infer A3): unknown;
+        }
+      ? Construtors<A1, A2, A3, undefined>
+      : T extends {
+              new (...args: infer A1): unknown;
+              new (...args: infer A2): unknown;
+          }
+        ? Construtors<A1, A2, undefined, undefined>
+        : T extends new (...args: infer A) => unknown
+          ? Construtors<A, undefined, undefined, undefined>
+          : Construtors<undefined, undefined, undefined, undefined>;
+
+type AnyConstructors = Construtors<any, any, any, any>;
+
+/**
+ * Returns all constructors where the first paramter is assignable to given "scope"
+ */
+// eslint-disable-next-line @typescript-eslint/consistent-type-definitions
+type FilterConstructorsByScope<T extends AnyConstructors, S> = {
+    a: S extends T['a'][0] ? T['a'] : undefined;
+    b: S extends T['b'][0] ? T['b'] : undefined;
+    c: S extends T['c'][0] ? T['c'] : undefined;
+    d: S extends T['d'][0] ? T['d'] : undefined;
+};
+/**
+ * "flattens" the tuple into an union type
+ */
+type ConstructorUnion<T extends AnyConstructors> =
+    | Exclude<T['a'], undefined>
+    | Exclude<T['b'], undefined>
+    | Exclude<T['c'], undefined>
+    | Exclude<T['d'], undefined>;
+
+/**
+ * Extract list of possible scopes - union of the first paramter
+ * of all constructors, should it be string
+ */
+type ExtractScopes<T extends AnyConstructors> =
+    | (T['a'][0] extends string ? T['a'][0] : never)
+    | (T['b'][0] extends string ? T['b'][0] : never)
+    | (T['c'][0] extends string ? T['c'][0] : never)
+    | (T['d'][0] extends string ? T['d'][0] : never);
+
+type GetConstructorsByScope<T, S> = ConstructorUnion<FilterConstructorsByScope<OverloadedConstructorsOf<T>, S>>;
+type GetConstructors<T> = ConstructorUnion<OverloadedConstructorsOf<T>>;
+type GetPossibleScopes<T> = ExtractScopes<OverloadedConstructorsOf<T>>;
+
+export type ConvertType = (...params: unknown[]) => ShaderNodeObject<Node>;
+
+type NodeArray<T extends NodeObjectOption[]> = { [index in keyof T]: NodeObject<T[index]> };
+type NodeObjects<T> = { [key in keyof T]: T[key] extends NodeObjectOption ? NodeObject<T[key]> : T[key] };
+type ConstructedNode<T> = T extends new (...args: any[]) => infer R ? (R extends Node ? R : never) : never;
+
 const parseSwizzle = props => props.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');
 const parseSwizzleAndSort = props => parseSwizzle(props).split('').sort().join('');
 
@@ -120,7 +284,7 @@ const shaderNodeHandler = {
 const nodeObjectsCacheMap = new WeakMap();
 const nodeBuilderFunctionsCacheMap = new WeakMap();
 
-const ShaderNodeObject = function (obj, altType = null) {
+const ShaderNodeObject = function <T extends NodeObjectOption>(obj: T, altType: string | null = null) {
     const type = getValueType(obj);
 
     if (type === 'node') {
@@ -228,14 +392,16 @@ const ShaderNodeImmutable = function (NodeClass, ...params) {
 };
 
 class ShaderCallNodeInternal extends Node {
-    constructor(shaderNode, inputNodes) {
+    shaderNode: ShaderNodeInternal;
+
+    constructor(shaderNode: ShaderNodeInternal, inputNodes) {
         super();
 
         this.shaderNode = shaderNode;
         this.inputNodes = inputNodes;
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.shaderNode.nodeType || this.getOutputNode(builder).getNodeType(builder);
     }
 
@@ -243,7 +409,7 @@ class ShaderCallNodeInternal extends Node {
         return this.getOutputNode(builder).getMemberType(builder, name);
     }
 
-    call(builder) {
+    call(builder: NodeBuilder) {
         const { shaderNode, inputNodes } = this;
 
         const properties = builder.getNodeProperties(shaderNode);
@@ -317,7 +483,15 @@ class ShaderCallNodeInternal extends Node {
     }
 }
 
+interface Layout {
+    name: string;
+    type: string;
+    inputs: { name: string; type: string }[];
+}
+
 class ShaderNodeInternal extends Node {
+    layout: Layout | null;
+
     constructor(jsFunc, nodeType) {
         super(nodeType);
 
@@ -329,7 +503,7 @@ class ShaderNodeInternal extends Node {
         this.once = false;
     }
 
-    setLayout(layout) {
+    setLayout(layout: Layout | null) {
         this.layout = layout;
 
         return this;
@@ -346,6 +520,8 @@ class ShaderNodeInternal extends Node {
     }
 }
 
+export type { ShaderNodeInternal };
+
 const bools = [false, true];
 const uints = [0, 1, 2, 3];
 const ints = [-1, -2];
@@ -439,10 +615,27 @@ export function ShaderNode(jsFunc, nodeType) {
     return new Proxy(new ShaderNodeInternal(jsFunc, nodeType), shaderNodeHandler);
 }
 
-export const nodeObject = (val, altType = null) => /* new */ ShaderNodeObject(val, altType);
+export const nodeObject = <T extends NodeObjectOption>(val: T, altType: string | null = null): NodeObject<T> =>
+    /* new */ ShaderNodeObject(val, altType);
 export const nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);
 export const nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
-export const nodeProxy = (...params) => new ShaderNodeProxy(...params);
+
+interface NodeProxy {
+    <T>(nodeClass: T): (...params: ProxiedTuple<GetConstructors<T>>) => ShaderNodeObject<ConstructedNode<T>>;
+    <T, S extends GetPossibleScopes<T>>(
+        nodeClass: T,
+        scope: S,
+    ): (...params: ProxiedTuple<RemoveTail<GetConstructorsByScope<T, S>>>) => ShaderNodeObject<ConstructedNode<T>>;
+    <T, S extends GetPossibleScopes<T>>(
+        nodeClass: T,
+        scope: S,
+        factor: NodeObjectOption,
+    ): (
+        ...params: ProxiedTuple<RemoveHeadAndTail<GetConstructorsByScope<T, S>>>
+    ) => ShaderNodeObject<ConstructedNode<T>>;
+}
+
+export const nodeProxy: NodeProxy = (...params) => new ShaderNodeProxy(...params);
 export const nodeImmutable = (...params) => new ShaderNodeImmutable(...params);
 
 let fnId = 0;
diff --git a/src-testing/src/renderers/common/Animation.ts b/src-testing/src/renderers/common/Animation.ts
index 384007e1..2ad5cdd7 100644
--- a/src-testing/src/renderers/common/Animation.ts
+++ b/src-testing/src/renderers/common/Animation.ts
@@ -1,16 +1,31 @@
+import Nodes from './nodes/Nodes.js';
+import Info from './Info.js';
+
+export interface AnimationContext {
+    requestAnimationFrame(callback: FrameRequestCallback, xrFrame?: XRFrame): number;
+    cancelAnimationFrame(handle: number): void;
+}
+
 /**
  * This module manages the internal animation loop of the renderer.
  *
  * @private
  */
 class Animation {
+    nodes: Nodes;
+    info: Info;
+
+    _context: AnimationContext | null;
+    _animationLoop: ((time: DOMHighResTimeStamp, xrFrame?: XRFrame) => void) | null;
+    _requestId: number | null;
+
     /**
      * Constructs a new animation loop management component.
      *
      * @param {Nodes} nodes - Renderer component for managing nodes related logic.
      * @param {Info} info - Renderer component for managing metrics and monitoring data.
      */
-    constructor(nodes, info) {
+    constructor(nodes: Nodes, info: Info) {
         /**
          * Renderer component for managing nodes related logic.
          *
@@ -55,8 +70,8 @@ class Animation {
      * Starts the internal animation loop.
      */
     start() {
-        const update = (time, xrFrame) => {
-            this._requestId = this._context.requestAnimationFrame(update);
+        const update = (time?: DOMHighResTimeStamp, xrFrame?: XRFrame) => {
+            this._requestId = this._context!.requestAnimationFrame(update);
 
             if (this.info.autoReset === true) this.info.reset();
 
@@ -64,7 +79,7 @@ class Animation {
 
             this.info.frame = this.nodes.nodeFrame.frameId;
 
-            if (this._animationLoop !== null) this._animationLoop(time, xrFrame);
+            if (this._animationLoop !== null) this._animationLoop(time!, xrFrame);
         };
 
         update();
@@ -74,7 +89,7 @@ class Animation {
      * Stops the internal animation loop.
      */
     stop() {
-        this._context.cancelAnimationFrame(this._requestId);
+        this._context!.cancelAnimationFrame(this._requestId!);
 
         this._requestId = null;
     }
@@ -93,7 +108,7 @@ class Animation {
      *
      * @param {?Function} callback - The animation loop.
      */
-    setAnimationLoop(callback) {
+    setAnimationLoop(callback: ((time: DOMHighResTimeStamp, xrFrame?: XRFrame) => void) | null) {
         this._animationLoop = callback;
     }
 
@@ -111,7 +126,7 @@ class Animation {
      *
      * @param {Window|XRSession} context - The context to set.
      */
-    setContext(context) {
+    setContext(context: AnimationContext) {
         this._context = context;
     }
 
diff --git a/src-testing/src/renderers/common/Attributes.ts b/src-testing/src/renderers/common/Attributes.ts
index 837cbce7..12a2da6a 100644
--- a/src-testing/src/renderers/common/Attributes.ts
+++ b/src-testing/src/renderers/common/Attributes.ts
@@ -2,6 +2,14 @@ import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
 
 import { DynamicDrawUsage } from '../../constants.js';
+import { BufferAttribute } from '../../core/BufferAttribute.js';
+import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
+import Backend from './Backend.js';
+import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
+
+interface Data {
+    version?: number | undefined;
+}
 
 /**
  * This renderer module manages geometry attributes.
@@ -9,13 +17,15 @@ import { DynamicDrawUsage } from '../../constants.js';
  * @private
  * @augments DataMap
  */
-class Attributes extends DataMap {
+class Attributes extends DataMap<{ attribute: { key: BufferAttribute | InterleavedBufferAttribute; value: Data } }> {
+    backend: Backend;
+
     /**
      * Constructs a new attribute management component.
      *
      * @param {Backend} backend - The renderer's backend.
      */
-    constructor(backend) {
+    constructor(backend: Backend) {
         super();
 
         /**
@@ -32,7 +42,7 @@ class Attributes extends DataMap {
      * @param {BufferAttribute} attribute - The attribute.
      * @return {Object|null} The deleted attribute data.
      */
-    delete(attribute) {
+    delete(attribute: BufferAttribute | InterleavedBufferAttribute) {
         const attributeData = super.delete(attribute);
 
         if (attributeData !== null) {
@@ -49,7 +59,7 @@ class Attributes extends DataMap {
      * @param {BufferAttribute} attribute - The attribute to update.
      * @param {number} type - The attribute type.
      */
-    update(attribute, type) {
+    update(attribute: BufferAttribute | InterleavedBufferAttribute, type: AttributeType) {
         const data = this.get(attribute);
 
         if (data.version === undefined) {
@@ -82,10 +92,11 @@ class Attributes extends DataMap {
      * @param {BufferAttribute} attribute - The attribute.
      * @return {BufferAttribute|InterleavedBuffer}
      */
-    _getBufferAttribute(attribute) {
-        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
+    _getBufferAttribute(attribute: BufferAttribute | InterleavedBufferAttribute) {
+        if ((attribute as InterleavedBufferAttribute).isInterleavedBufferAttribute)
+            (attribute as BufferAttribute | InterleavedBuffer) = (attribute as InterleavedBufferAttribute).data;
 
-        return attribute;
+        return attribute as BufferAttribute | InterleavedBuffer;
     }
 }
 
diff --git a/src-testing/src/renderers/common/Backend.ts b/src-testing/src/renderers/common/Backend.ts
index 3708522d..b6f51892 100644
--- a/src-testing/src/renderers/common/Backend.ts
+++ b/src-testing/src/renderers/common/Backend.ts
@@ -1,10 +1,39 @@
-let _vector2 = null;
-let _color4 = null;
-
 import Color4 from './Color4.js';
 import { Vector2 } from '../../math/Vector2.js';
 import { createCanvasElement, warnOnce } from '../../utils.js';
-import { REVISION } from '../../constants.js';
+import { CoordinateSystem, REVISION } from '../../constants.js';
+import RenderObject from './RenderObject.js';
+import RenderContext from './RenderContext.js';
+import RenderBundle from './RenderBundle.js';
+import { Texture } from '../../textures/Texture.js';
+import Renderer from './Renderer.js';
+import { BufferAttribute, TypedArray } from '../../core/BufferAttribute.js';
+import { Object3D } from '../../core/Object3D.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import { Scene } from '../../scenes/Scene.js';
+import NodeBuilder from '../../nodes/core/NodeBuilder.js';
+import TimestampQueryPool from './TimestampQueryPool.js';
+import { TimestampQuery } from '@types/three';
+
+let _vector2: Vector2 | null = null;
+let _color4: Color4 | null = null;
+
+export interface BackendParameters {
+    canvas?: HTMLCanvasElement | undefined;
+    antialias?: boolean;
+}
+
+interface RenderContextData {
+    renderObjects?: RenderObject[];
+}
+
+interface RenderBundleData {
+    renderContexts?: Set<RenderContext>;
+}
+
+interface RenderObjectData {}
+
+interface TextureData {}
 
 /**
  * Most of the rendering related logic is implemented in the
@@ -18,13 +47,25 @@ import { REVISION } from '../../constants.js';
  * @abstract
  * @private
  */
-class Backend {
+abstract class Backend {
+    parameters: BackendParameters;
+    data: WeakMap<
+        RenderContext | RenderBundle | RenderObject | Texture,
+        RenderContextData | RenderBundleData | RenderObjectData | TextureData
+    >;
+    renderer: Renderer | null;
+    domElement: HTMLCanvasElement | null;
+    timestampQueryPool: {
+        render: TimestampQueryPool | null;
+        compute: TimestampQueryPool | null;
+    };
+
     /**
      * Constructs a new backend.
      *
      * @param {Object} parameters - An object holding parameters for the backend.
      */
-    constructor(parameters = {}) {
+    constructor(parameters: BackendParameters = {}) {
         /**
          * The parameters of the backend.
          *
@@ -38,7 +79,10 @@ class Backend {
          *
          * @type {WeakMap}
          */
-        this.data = new WeakMap();
+        this.data = new WeakMap<
+            RenderContext | RenderBundle | RenderObject | Texture,
+            RenderContextData | RenderBundleData | RenderObjectData | TextureData
+        >();
 
         /**
          * A reference to the renderer.
@@ -84,7 +128,7 @@ class Backend {
      * @param {Renderer} renderer - The renderer.
      * @return {Promise} A Promise that resolves when the backend has been initialized.
      */
-    async init(renderer) {
+    async init(renderer: Renderer) {
         this.renderer = renderer;
     }
 
@@ -95,7 +139,9 @@ class Backend {
      * @type {number}
      * @readonly
      */
-    get coordinateSystem() {}
+    abstract get coordinateSystem(): CoordinateSystem;
+
+    abstract getArrayBufferAsync(attribute: BufferAttribute): Promise<ArrayBuffer>;
 
     // render context
 
@@ -263,7 +309,11 @@ class Backend {
      * @param {Renderer} renderer - The renderer.
      * @return {NodeBuilder} The node builder.
      */
-    createNodeBuilder(/*renderObject, renderer*/) {}
+    abstract createNodeBuilder(
+        renderObject: Object3D | ComputeNode,
+        renderer: Renderer,
+        scene?: Scene | null,
+    ): NodeBuilder;
 
     // textures
 
@@ -339,7 +389,14 @@ class Backend {
      * @param {number} faceIndex - The face index.
      * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
      */
-    async copyTextureToBuffer(/*texture, x, y, width, height, faceIndex*/) {}
+    abstract copyTextureToBuffer(
+        texture: Texture,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+        faceIndex: number,
+    ): Promise<TypedArray>;
 
     /**
      * Copies data of the given source texture to the given destination texture.
@@ -444,7 +501,7 @@ class Backend {
      * @param {Object3D} object - The 3D object to test.
      * @return {boolean} Whether the 3D object is fully occluded or not.
      */
-    isOccluded(/*renderContext, object*/) {}
+    abstract isOccluded(/*renderContext, object*/): boolean;
 
     /**
      * Resolves the time stamp for the given render context and type.
@@ -454,7 +511,7 @@ class Backend {
      * @param {string} [type='render'] - The type of the time stamp.
      * @return {Promise<number>} A Promise that resolves with the time stamp.
      */
-    async resolveTimestampsAsync(type = 'render') {
+    async resolveTimestampsAsync(type: TimestampQuery = 'render') {
         if (!this.trackTimestamp) {
             warnOnce('WebGPURenderer: Timestamp tracking is disabled.');
             return;
@@ -468,7 +525,7 @@ class Backend {
 
         const duration = await queryPool.resolveQueriesAsync();
 
-        this.renderer.info[type].timestamp = duration;
+        this.renderer!.info[type].timestamp = duration;
 
         return duration;
     }
@@ -518,7 +575,7 @@ class Backend {
      * @abstract
      * @return {number} The maximum anisotropy texture filtering value.
      */
-    getMaxAnisotropy() {}
+    abstract getMaxAnisotropy(): number;
 
     /**
      * Returns the drawing buffer size.
@@ -528,7 +585,7 @@ class Backend {
     getDrawingBufferSize() {
         _vector2 = _vector2 || new Vector2();
 
-        return this.renderer.getDrawingBufferSize(_vector2);
+        return this.renderer!.getDrawingBufferSize(_vector2);
     }
 
     /**
@@ -550,7 +607,7 @@ class Backend {
 
         _color4 = _color4 || new Color4();
 
-        renderer.getClearColor(_color4);
+        renderer!.getClearColor(_color4);
 
         _color4.getRGB(_color4);
 
@@ -595,7 +652,11 @@ class Backend {
      * @param {Object} object - The object.
      * @return {Object} The object's dictionary.
      */
-    get(object) {
+    get(object: RenderContext): RenderContextData;
+    get(object: RenderBundle): RenderBundleData;
+    get(object: RenderObject): RenderObjectData;
+    get(object: Texture): TextureData;
+    get(object: RenderContext | RenderBundle | RenderObject | Texture) {
         let map = this.data.get(object);
 
         if (map === undefined) {
@@ -613,7 +674,7 @@ class Backend {
      * @param {Object} object - The object.
      * @return {boolean} Whether a dictionary for the given object as been defined or not.
      */
-    has(object) {
+    has(object: RenderContext) {
         return this.data.has(object);
     }
 
@@ -622,7 +683,7 @@ class Backend {
      *
      * @param {Object} object - The object to delete.
      */
-    delete(object) {
+    delete(object: RenderContext) {
         this.data.delete(object);
     }
 
diff --git a/src-testing/src/renderers/common/Background.ts b/src-testing/src/renderers/common/Background.ts
index baa25e45..700f7c06 100644
--- a/src-testing/src/renderers/common/Background.ts
+++ b/src-testing/src/renderers/common/Background.ts
@@ -14,23 +14,38 @@ import NodeMaterial from '../../materials/nodes/NodeMaterial.js';
 import { Mesh } from '../../objects/Mesh.js';
 import { SphereGeometry } from '../../geometries/SphereGeometry.js';
 import { BackSide } from '../../constants.js';
+import { Scene } from '../../scenes/Scene.js';
+import Renderer from './Renderer.js';
+import Nodes from './nodes/Nodes.js';
+import RenderList from './RenderList.js';
+import RenderContext from './RenderContext.js';
 
 const _clearColor = /*@__PURE__*/ new Color4();
 
+interface SceneData {
+    backgroundMesh?: Mesh;
+    // TODO
+    // backgroundMeshNode?: Node;
+    backgroundCacheKey: string;
+}
+
 /**
  * This renderer module manages the background.
  *
  * @private
  * @augments DataMap
  */
-class Background extends DataMap {
+class Background extends DataMap<{ scene: { key: Scene; value: SceneData } }> {
+    renderer: Renderer;
+    nodes: Nodes;
+
     /**
      * Constructs a new background management component.
      *
      * @param {Renderer} renderer - The renderer.
      * @param {Nodes} nodes - Renderer component for managing nodes related logic.
      */
-    constructor(renderer, nodes) {
+    constructor(renderer: Renderer, nodes: Nodes) {
         super();
 
         /**
@@ -58,7 +73,7 @@ class Background extends DataMap {
      * @param {RenderList} renderList - The current render list.
      * @param {RenderContext} renderContext - The current render context.
      */
-    update(scene, renderList, renderContext) {
+    update(scene: Scene, renderList: RenderList, renderContext: RenderContext) {
         const renderer = this.renderer;
         const background = this.nodes.getBackgroundNode(scene) || scene.background;
 
diff --git a/src-testing/src/renderers/common/BindGroup.ts b/src-testing/src/renderers/common/BindGroup.ts
index 50e578f0..5e2b17b7 100644
--- a/src-testing/src/renderers/common/BindGroup.ts
+++ b/src-testing/src/renderers/common/BindGroup.ts
@@ -1,3 +1,6 @@
+import NodeUniformsGroup from './nodes/NodeUniformsGroup.js';
+import Binding from './Binding.js';
+
 let _id = 0;
 
 /**
@@ -8,6 +11,13 @@ let _id = 0;
  * @private
  */
 class BindGroup {
+    name: string;
+    bindings: NodeUniformsGroup[] | Binding[];
+    index: number;
+    bindingsReference: NodeUniformsGroup[] | BindGroup;
+
+    id: number;
+
     /**
      * Constructs a new bind group.
      *
@@ -16,7 +26,12 @@ class BindGroup {
      * @param {number} index - The group index.
      * @param {Array<Binding>} bindingsReference - An array of reference bindings.
      */
-    constructor(name = '', bindings = [], index = 0, bindingsReference = []) {
+    constructor(
+        name = '',
+        bindings: NodeUniformsGroup[] = [],
+        index = 0,
+        bindingsReference: NodeUniformsGroup[] | BindGroup = [],
+    ) {
         /**
          * The bind group's name.
          *
diff --git a/src-testing/src/renderers/common/Binding.ts b/src-testing/src/renderers/common/Binding.ts
index 0cdcb293..885a7b95 100644
--- a/src-testing/src/renderers/common/Binding.ts
+++ b/src-testing/src/renderers/common/Binding.ts
@@ -8,6 +8,10 @@
  * @private
  */
 class Binding {
+    name: string;
+
+    visibility: number;
+
     /**
      * Constructs a new binding.
      *
@@ -35,7 +39,7 @@ class Binding {
      *
      * @param {number} visibility - The shader stage.
      */
-    setVisibility(visibility) {
+    setVisibility(visibility: number) {
         this.visibility |= visibility;
     }
 
@@ -45,7 +49,7 @@ class Binding {
      * @return {Binding} The cloned binding.
      */
     clone() {
-        return Object.assign(new this.constructor(), this);
+        return Object.assign(new (this.constructor as typeof Binding)(), this);
     }
 }
 
diff --git a/src-testing/src/renderers/common/Bindings.ts b/src-testing/src/renderers/common/Bindings.ts
index aae74556..a490fb81 100644
--- a/src-testing/src/renderers/common/Bindings.ts
+++ b/src-testing/src/renderers/common/Bindings.ts
@@ -1,5 +1,23 @@
 import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
+import Backend from './Backend.js';
+import Nodes from './nodes/Nodes.js';
+import Textures from './Textures.js';
+import Attributes from './Attributes.js';
+import Pipelines from './Pipelines.js';
+import Info from './Info.js';
+import RenderObject from './RenderObject.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import { SampledTexture } from './SampledTexture.js';
+import StorageBuffer from './StorageBuffer.js';
+import NodeUniformsGroup from './nodes/NodeUniformsGroup.js';
+import UniformBuffer from './UniformBuffer.js';
+import Sampler from './Sampler.js';
+import BindGroup from './BindGroup.js';
+
+interface BindGroupData {
+    bindGroup?: BindGroup | undefined;
+}
 
 /**
  * This renderer module manages the bindings of the renderer.
@@ -7,7 +25,7 @@ import { AttributeType } from './Constants.js';
  * @private
  * @augments DataMap
  */
-class Bindings extends DataMap {
+class Bindings extends DataMap<{
     /**
      * Constructs a new bindings management component.
      *
@@ -18,7 +36,23 @@ class Bindings extends DataMap {
      * @param {Pipelines} pipelines - Renderer component for managing pipelines.
      * @param {Info} info - Renderer component for managing metrics and monitoring data.
      */
-    constructor(backend, nodes, textures, attributes, pipelines, info) {
+    bindGroup: { key: BindGroup; value: BindGroupData };
+}> {
+    backend: Backend;
+    textures: Textures;
+    pipelines: Pipelines;
+    attributes: Attributes;
+    nodes: Nodes;
+    info: Info;
+
+    constructor(
+        backend: Backend,
+        nodes: Nodes,
+        textures: Textures,
+        attributes: Attributes,
+        pipelines: Pipelines,
+        info: Info,
+    ) {
         super();
 
         /**
@@ -72,7 +106,7 @@ class Bindings extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {Array<BindGroup>} The bind groups.
      */
-    getForRender(renderObject) {
+    getForRender(renderObject: RenderObject) {
         const bindings = renderObject.getBindings();
 
         for (const bindGroup of bindings) {
@@ -98,7 +132,7 @@ class Bindings extends DataMap {
      * @param {Node} computeNode - The compute node.
      * @return {Array<BindGroup>} The bind groups.
      */
-    getForCompute(computeNode) {
+    getForCompute(computeNode: ComputeNode) {
         const bindings = this.nodes.getForCompute(computeNode).bindings;
 
         for (const bindGroup of bindings) {
@@ -121,7 +155,7 @@ class Bindings extends DataMap {
      *
      * @param {Node} computeNode - The compute node.
      */
-    updateForCompute(computeNode) {
+    updateForCompute(computeNode: ComputeNode) {
         this._updateBindings(this.getForCompute(computeNode));
     }
 
@@ -130,7 +164,7 @@ class Bindings extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         this._updateBindings(this.getForRender(renderObject));
     }
 
@@ -139,7 +173,7 @@ class Bindings extends DataMap {
      *
      * @param {Array<BindGroup>} bindings - The bind groups.
      */
-    _updateBindings(bindings) {
+    _updateBindings(bindings: BindGroup[]) {
         for (const bindGroup of bindings) {
             this._update(bindGroup, bindings);
         }
@@ -150,12 +184,12 @@ class Bindings extends DataMap {
      *
      * @param {BindGroup} bindGroup - The bind group to initialize.
      */
-    _init(bindGroup) {
+    _init(bindGroup: BindGroup) {
         for (const binding of bindGroup.bindings) {
-            if (binding.isSampledTexture) {
-                this.textures.updateTexture(binding.texture);
-            } else if (binding.isStorageBuffer) {
-                const attribute = binding.attribute;
+            if ((binding as SampledTexture).isSampledTexture) {
+                this.textures.updateTexture((binding as SampledTexture).texture);
+            } else if ((binding as StorageBuffer).isStorageBuffer) {
+                const attribute = (binding as StorageBuffer).attribute;
                 const attributeType = attribute.isIndirectStorageBufferAttribute
                     ? AttributeType.INDIRECT
                     : AttributeType.STORAGE;
@@ -171,7 +205,7 @@ class Bindings extends DataMap {
      * @param {BindGroup} bindGroup - The bind group to update.
      * @param {Array<BindGroup>} bindings - The bind groups.
      */
-    _update(bindGroup, bindings) {
+    _update(bindGroup: BindGroup, bindings: BindGroup[]) {
         const { backend } = this;
 
         let needsBindingsUpdate = false;
@@ -182,8 +216,8 @@ class Bindings extends DataMap {
         // iterate over all bindings and check if buffer updates or a new binding group is required
 
         for (const binding of bindGroup.bindings) {
-            if (binding.isNodeUniformsGroup) {
-                const updated = this.nodes.updateGroup(binding);
+            if ((binding as NodeUniformsGroup).isNodeUniformsGroup) {
+                const updated = this.nodes.updateGroup(binding as NodeUniformsGroup);
 
                 // every uniforms group is a uniform buffer. So if no update is required,
                 // we move one with the next binding. Otherwise the next if block will update the group.
@@ -200,22 +234,23 @@ class Bindings extends DataMap {
                 this.attributes.update(attribute, attributeType);
             }
 
-            if (binding.isUniformBuffer) {
-                const updated = binding.update();
+            if ((binding as UniformBuffer).isUniformBuffer) {
+                const updated = (binding as UniformBuffer).update();
 
                 if (updated) {
-                    backend.updateBinding(binding);
+                    backend.updateBinding(binding as UniformBuffer);
                 }
-            } else if (binding.isSampler) {
-                binding.update();
-            } else if (binding.isSampledTexture) {
-                const texturesTextureData = this.textures.get(binding.texture);
+            } else if ((binding as Sampler).isSampler) {
+                (binding as Sampler).update();
+            } else if ((binding as SampledTexture).isSampledTexture) {
+                const texturesTextureData = this.textures.get((binding as SampledTexture).texture);
 
-                if (binding.needsBindingsUpdate(texturesTextureData.generation)) needsBindingsUpdate = true;
+                if ((binding as SampledTexture).needsBindingsUpdate(texturesTextureData.generation))
+                    needsBindingsUpdate = true;
 
-                const updated = binding.update();
+                const updated = (binding as SampledTexture).update();
 
-                const texture = binding.texture;
+                const texture = (binding as SampledTexture).texture;
 
                 if (updated) {
                     this.textures.updateTexture(texture);
@@ -238,10 +273,10 @@ class Bindings extends DataMap {
                     // TODO: Remove this once we found why updated === false isn't bound to a texture in the WebGPU backend
                     console.error(
                         'Bindings._update: binding should be available:',
-                        binding,
+                        binding as SampledTexture,
                         updated,
                         texture,
-                        binding.textureNode.value,
+                        (binding as SampledTexture).textureNode.value,
                         needsBindingsUpdate,
                     );
 
@@ -252,7 +287,7 @@ class Bindings extends DataMap {
                 if (texture.isStorageTexture === true) {
                     const textureData = this.get(texture);
 
-                    if (binding.store === true) {
+                    if ((binding as SampledTexture).store === true) {
                         textureData.needsMipmap = true;
                     } else if (this.textures.needsMipmaps(texture) && textureData.needsMipmap === true) {
                         this.backend.generateMipmaps(texture);
diff --git a/src-testing/src/renderers/common/Buffer.ts b/src-testing/src/renderers/common/Buffer.ts
index 6696b17b..ba595cf8 100644
--- a/src-testing/src/renderers/common/Buffer.ts
+++ b/src-testing/src/renderers/common/Buffer.ts
@@ -9,13 +9,19 @@ import { getFloatLength } from './BufferUtils.js';
  * @augments Binding
  */
 class Buffer extends Binding {
+    readonly isBuffer: true;
+
+    bytesPerElement: number;
+
+    _buffer: Float32Array | null;
+
     /**
      * Constructs a new buffer.
      *
      * @param {string} name - The buffer's name.
      * @param {TypedArray} [buffer=null] - The buffer.
      */
-    constructor(name, buffer = null) {
+    constructor(name?: string, buffer: Float32Array | null = null) {
         super(name);
 
         /**
@@ -50,7 +56,7 @@ class Buffer extends Binding {
      * @readonly
      */
     get byteLength() {
-        return getFloatLength(this._buffer.byteLength);
+        return getFloatLength(this._buffer!.byteLength);
     }
 
     /**
@@ -59,7 +65,7 @@ class Buffer extends Binding {
      * @type {Float32Array}
      * @readonly
      */
-    get buffer() {
+    get buffer(): Float32Array | null {
         return this._buffer;
     }
 
diff --git a/src-testing/src/renderers/common/BufferUtils.ts b/src-testing/src/renderers/common/BufferUtils.ts
index 80f441ef..244f30b2 100644
--- a/src-testing/src/renderers/common/BufferUtils.ts
+++ b/src-testing/src/renderers/common/BufferUtils.ts
@@ -8,7 +8,7 @@ import { GPU_CHUNK_BYTES } from './Constants.js';
  * @param {number} floatLength - The buffer length.
  * @return {number} The padded length.
  */
-function getFloatLength(floatLength) {
+function getFloatLength(floatLength: number) {
     // ensure chunk size alignment (STD140 layout)
 
     return floatLength + ((GPU_CHUNK_BYTES - (floatLength % GPU_CHUNK_BYTES)) % GPU_CHUNK_BYTES);
@@ -23,7 +23,7 @@ function getFloatLength(floatLength) {
  * @param {number} [vectorLength=4] - The vector length.
  * @return {number} The padded length.
  */
-function getVectorLength(count, vectorLength = 4) {
+function getVectorLength(count: number, vectorLength = 4) {
     const strideLength = getStrideLength(vectorLength);
 
     const floatLength = strideLength * count;
@@ -39,7 +39,7 @@ function getVectorLength(count, vectorLength = 4) {
  * @param {number} vectorLength - The vector length.
  * @return {number} The padded length.
  */
-function getStrideLength(vectorLength) {
+function getStrideLength(vectorLength: number) {
     const strideLength = 4;
 
     return vectorLength + ((strideLength - (vectorLength % strideLength)) % strideLength);
diff --git a/src-testing/src/renderers/common/BundleGroup.ts b/src-testing/src/renderers/common/BundleGroup.ts
index c684ced9..52f90d47 100644
--- a/src-testing/src/renderers/common/BundleGroup.ts
+++ b/src-testing/src/renderers/common/BundleGroup.ts
@@ -13,6 +13,13 @@ import { Group } from '../../objects/Group.js';
  * @augments Group
  */
 class BundleGroup extends Group {
+    readonly isBundleGroup: true;
+
+    readonly type: string;
+
+    static: boolean;
+    version: number;
+
     /**
      * Constructs a new bundle group.
      */
@@ -69,7 +76,7 @@ class BundleGroup extends Group {
      * @default false
      * @param {boolean} value
      */
-    set needsUpdate(value) {
+    set needsUpdate(value: boolean) {
         if (value === true) this.version++;
     }
 }
diff --git a/src-testing/src/renderers/common/ChainMap.ts b/src-testing/src/renderers/common/ChainMap.ts
index 0537458f..342cdf37 100644
--- a/src-testing/src/renderers/common/ChainMap.ts
+++ b/src-testing/src/renderers/common/ChainMap.ts
@@ -1,3 +1,5 @@
+type RecursiveWeakMap<K extends readonly object[], V> = WeakMap<K[number], V | RecursiveWeakMap<K, V>>;
+
 /**
  * Data structure for the renderer. It allows defining values
  * with chained, hierarchical keys. Keys are meant to be
@@ -6,7 +8,8 @@
  *
  * @private
  */
-class ChainMap {
+class ChainMap<K extends readonly object[], V> {
+    weakMap: RecursiveWeakMap<K, V>;
     /**
      * Constructs a new Chain Map.
      */
@@ -16,7 +19,7 @@ class ChainMap {
          *
          * @type {WeakMap}
          */
-        this.weakMap = new WeakMap();
+        this.weakMap = new WeakMap<K[number], V | RecursiveWeakMap<K, V>>();
     }
 
     /**
@@ -25,16 +28,16 @@ class ChainMap {
      * @param {Array<Object>} keys - List of keys.
      * @return {any} The value. Returns `undefined` if no value was found.
      */
-    get(keys) {
-        let map = this.weakMap;
+    get(keys: K): V | undefined {
+        let map: RecursiveWeakMap<K, V> | undefined = this.weakMap;
 
         for (let i = 0; i < keys.length - 1; i++) {
-            map = map.get(keys[i]);
+            map = map.get(keys[i]) as RecursiveWeakMap<K, V> | undefined;
 
             if (map === undefined) return undefined;
         }
 
-        return map.get(keys[keys.length - 1]);
+        return map.get(keys[keys.length - 1]) as V | undefined;
     }
 
     /**
@@ -44,18 +47,18 @@ class ChainMap {
      * @param {any} value - The value to set.
      * @return {ChainMap} A reference to this Chain Map.
      */
-    set(keys, value) {
-        let map = this.weakMap;
+    set(keys: K, value: V) {
+        let map: RecursiveWeakMap<K, V> = this.weakMap;
 
         for (let i = 0; i < keys.length - 1; i++) {
             const key = keys[i];
 
-            if (map.has(key) === false) map.set(key, new WeakMap());
+            if (map.has(key) === false) map.set(key, new WeakMap<K[number], V | RecursiveWeakMap<K, V>>());
 
-            map = map.get(key);
+            map = map.get(key) as RecursiveWeakMap<K, V>;
         }
 
-        map.set(keys[keys.length - 1], value);
+        map.set(keys[keys.length - 1], value) as V;
 
         return this;
     }
@@ -66,11 +69,11 @@ class ChainMap {
      * @param {Array<Object>} keys - The keys.
      * @return {boolean} Returns `true` if the value has been removed successfully and `false` if the value has not be found.
      */
-    delete(keys) {
-        let map = this.weakMap;
+    delete(keys: K) {
+        let map: RecursiveWeakMap<K, V> | undefined = this.weakMap;
 
         for (let i = 0; i < keys.length - 1; i++) {
-            map = map.get(keys[i]);
+            map = map.get(keys[i]) as RecursiveWeakMap<K, V> | undefined;
 
             if (map === undefined) return false;
         }
diff --git a/src-testing/src/renderers/common/ClippingContext.ts b/src-testing/src/renderers/common/ClippingContext.ts
index 41243208..33f82c41 100644
--- a/src-testing/src/renderers/common/ClippingContext.ts
+++ b/src-testing/src/renderers/common/ClippingContext.ts
@@ -1,6 +1,10 @@
 import { Matrix3 } from '../../math/Matrix3.js';
 import { Plane } from '../../math/Plane.js';
 import { Vector4 } from '../../math/Vector4.js';
+import { Matrix4 } from '../../math/Matrix4.js';
+import { Camera } from '../../cameras/Camera.js';
+import { Scene } from '../../scenes/Scene.js';
+import { ClippingGroup } from '../../objects/ClippingGroup.js';
 
 const _plane = /*@__PURE__*/ new Plane();
 
@@ -13,12 +17,29 @@ const _plane = /*@__PURE__*/ new Plane();
  * @private
  */
 class ClippingContext {
+    version: number;
+
+    clipIntersection: boolean | null;
+    cacheKey: string;
+
+    intersectionPlanes?: Plane[];
+    unionPlanes?: Plane[];
+
+    viewNormalMatrix: Matrix3;
+    clippingGroupContexts: WeakMap<ClippingGroup, ClippingContext>;
+
+    shadowPass: boolean;
+
+    viewMatrix?: Matrix4;
+
+    parentVersion: number | null;
+
     /**
      * Constructs a new clipping context.
      *
      * @param {?ClippingContext} [parentContext=null] - A reference to the parent clipping context.
      */
-    constructor(parentContext = null) {
+    constructor(parentContext: ClippingContext | null = null) {
         /**
          * The clipping context's version.
          *
@@ -103,11 +124,11 @@ class ClippingContext {
      * @param {Array<Vector4>} destination - The destination.
      * @param {number} offset - The offset.
      */
-    projectPlanes(source, destination, offset) {
+    projectPlanes(source: readonly Plane[], destination: readonly Vector4[], offset: number) {
         const l = source.length;
 
         for (let i = 0; i < l; i++) {
-            _plane.copy(source[i]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
+            _plane.copy(source[i]).applyMatrix4(this.viewMatrix!, this.viewNormalMatrix);
 
             const v = destination[offset + i];
             const normal = _plane.normal;
@@ -125,7 +146,7 @@ class ClippingContext {
      * @param {Scene} scene - The scene.
      * @param {Camera} camera - The camera that is used to render the scene.
      */
-    updateGlobal(scene, camera) {
+    updateGlobal(scene: Scene, camera: Camera) {
         this.shadowPass = scene.overrideMaterial !== null && scene.overrideMaterial.isShadowPassMaterial;
         this.viewMatrix = camera.matrixWorldInverse;
 
@@ -138,12 +159,12 @@ class ClippingContext {
      * @param {ClippingContext} parentContext - The parent context.
      * @param {ClippingGroup} clippingGroup - The clipping group this context belongs to.
      */
-    update(parentContext, clippingGroup) {
+    update(parentContext: ClippingContext, clippingGroup: ClippingGroup) {
         let update = false;
 
         if (parentContext.version !== this.parentVersion) {
-            this.intersectionPlanes = Array.from(parentContext.intersectionPlanes);
-            this.unionPlanes = Array.from(parentContext.unionPlanes);
+            this.intersectionPlanes = Array.from(parentContext.intersectionPlanes!);
+            this.unionPlanes = Array.from(parentContext.unionPlanes!);
             this.parentVersion = parentContext.version;
         }
 
@@ -151,24 +172,24 @@ class ClippingContext {
             this.clipIntersection = clippingGroup.clipIntersection;
 
             if (this.clipIntersection) {
-                this.unionPlanes.length = parentContext.unionPlanes.length;
+                this.unionPlanes!.length = parentContext.unionPlanes!.length;
             } else {
-                this.intersectionPlanes.length = parentContext.intersectionPlanes.length;
+                this.intersectionPlanes!.length = parentContext.intersectionPlanes!.length;
             }
         }
 
         const srcClippingPlanes = clippingGroup.clippingPlanes;
         const l = srcClippingPlanes.length;
 
-        let dstClippingPlanes;
+        let dstClippingPlanes: (Plane | Vector4)[];
         let offset;
 
         if (this.clipIntersection) {
-            dstClippingPlanes = this.intersectionPlanes;
-            offset = parentContext.intersectionPlanes.length;
+            dstClippingPlanes = this.intersectionPlanes!;
+            offset = parentContext.intersectionPlanes!.length;
         } else {
-            dstClippingPlanes = this.unionPlanes;
-            offset = parentContext.unionPlanes.length;
+            dstClippingPlanes = this.unionPlanes!;
+            offset = parentContext.unionPlanes!.length;
         }
 
         if (dstClippingPlanes.length !== offset + l) {
@@ -181,11 +202,11 @@ class ClippingContext {
             update = true;
         }
 
-        this.projectPlanes(srcClippingPlanes, dstClippingPlanes, offset);
+        this.projectPlanes(srcClippingPlanes, dstClippingPlanes as Vector4[], offset);
 
         if (update) {
             this.version++;
-            this.cacheKey = `${this.intersectionPlanes.length}:${this.unionPlanes.length}`;
+            this.cacheKey = `${this.intersectionPlanes!.length}:${this.unionPlanes!.length}`;
         }
     }
 
@@ -195,7 +216,7 @@ class ClippingContext {
      * @param {ClippingGroup} clippingGroup - The clipping group.
      * @return {ClippingContext} The clipping context.
      */
-    getGroupContext(clippingGroup) {
+    getGroupContext(clippingGroup: ClippingGroup) {
         if (this.shadowPass && !clippingGroup.clipShadows) return this;
 
         let context = this.clippingGroupContexts.get(clippingGroup);
@@ -217,7 +238,7 @@ class ClippingContext {
      * @readonly
      */
     get unionClippingCount() {
-        return this.unionPlanes.length;
+        return this.unionPlanes!.length;
     }
 }
 
diff --git a/src-testing/src/renderers/common/Color4.ts b/src-testing/src/renderers/common/Color4.ts
index 4a914d60..a0513578 100644
--- a/src-testing/src/renderers/common/Color4.ts
+++ b/src-testing/src/renderers/common/Color4.ts
@@ -1,4 +1,4 @@
-import { Color } from '../../math/Color.js';
+import { Color, ColorRepresentation } from '../../math/Color.js';
 
 /**
  * A four-component version of {@link Color} which is internally
@@ -9,6 +9,8 @@ import { Color } from '../../math/Color.js';
  * @augments Color
  */
 class Color4 extends Color {
+    a: number;
+
     /**
      * Constructs a new four-component color.
      * You can also pass a single THREE.Color, hex or
@@ -19,8 +21,10 @@ class Color4 extends Color {
      * @param {number} [b=1] - The blue value.
      * @param {number} [a=1] - The alpha value.
      */
-    constructor(r, g, b, a = 1) {
-        super(r, g, b);
+    constructor(color?: ColorRepresentation);
+    constructor(r: number, g: number, b: number, a?: number);
+    constructor(r?: number, g?: number, b?: number, a = 1) {
+        super(r as number, g!, b!);
 
         this.a = a;
     }
@@ -36,7 +40,8 @@ class Color4 extends Color {
      * @param {number} [a=1] - The alpha value.
      * @return {Color4} A reference to this object.
      */
-    set(r, g, b, a = 1) {
+    set(...args: [color: ColorRepresentation] | [r: number, g: number, b: number, a?: number]): this;
+    set(r: number, g: number, b: number, a = 1) {
         this.a = a;
 
         return super.set(r, g, b);
@@ -48,8 +53,8 @@ class Color4 extends Color {
      * @param {Color4} color - The color to copy.
      * @return {Color4} A reference to this object.
      */
-    copy(color) {
-        if (color.a !== undefined) this.a = color.a;
+    copy(color: Color) {
+        if ((color as Color4).a !== undefined) this.a = (color as Color4).a;
 
         return super.copy(color);
     }
@@ -59,8 +64,8 @@ class Color4 extends Color {
      *
      * @return {Color4} The cloned color.
      */
-    clone() {
-        return new this.constructor(this.r, this.g, this.b, this.a);
+    clone(): this {
+        return new (this.constructor as typeof Color4)(this.r, this.g, this.b, this.a) as this;
     }
 }
 
diff --git a/src-testing/src/renderers/common/ComputePipeline.ts b/src-testing/src/renderers/common/ComputePipeline.ts
index f48a81f6..0cac27d8 100644
--- a/src-testing/src/renderers/common/ComputePipeline.ts
+++ b/src-testing/src/renderers/common/ComputePipeline.ts
@@ -1,4 +1,5 @@
 import Pipeline from './Pipeline.js';
+import ProgrammableStage from './ProgrammableStage.js';
 
 /**
  * Class for representing compute pipelines.
@@ -7,13 +8,17 @@ import Pipeline from './Pipeline.js';
  * @augments Pipeline
  */
 class ComputePipeline extends Pipeline {
+    computeProgram: ProgrammableStage;
+
+    readonly isComputePipeline: true;
+
     /**
      * Constructs a new render pipeline.
      *
      * @param {string} cacheKey - The pipeline's cache key.
      * @param {ProgrammableStage} computeProgram - The pipeline's compute shader.
      */
-    constructor(cacheKey, computeProgram) {
+    constructor(cacheKey: string, computeProgram: ProgrammableStage) {
         super(cacheKey);
 
         /**
diff --git a/src-testing/src/renderers/common/Constants.ts b/src-testing/src/renderers/common/Constants.ts
index c2dfad4c..02330947 100644
--- a/src-testing/src/renderers/common/Constants.ts
+++ b/src-testing/src/renderers/common/Constants.ts
@@ -3,7 +3,9 @@ export const AttributeType = {
     INDEX: 2,
     STORAGE: 3,
     INDIRECT: 4,
-};
+} as const;
+
+export type AttributeType = (typeof AttributeType)[keyof typeof AttributeType];
 
 // size of a chunk in bytes (STD140 layout)
 
diff --git a/src-testing/src/renderers/common/CubeRenderTarget.ts b/src-testing/src/renderers/common/CubeRenderTarget.ts
index 1e217f88..e10f21ec 100644
--- a/src-testing/src/renderers/common/CubeRenderTarget.ts
+++ b/src-testing/src/renderers/common/CubeRenderTarget.ts
@@ -9,6 +9,9 @@ import { CubeCamera } from '../../cameras/CubeCamera.js';
 import { BoxGeometry } from '../../geometries/BoxGeometry.js';
 import { Mesh } from '../../objects/Mesh.js';
 import { BackSide, NoBlending, LinearFilter, LinearMipmapLinearFilter } from '../../constants.js';
+import { RenderTargetOptions } from '../../core/RenderTarget.js';
+import { WebGLRenderer } from '../WebGLRenderer.js';
+import { Texture } from '../../textures/Texture.js';
 
 // @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget
 
@@ -19,13 +22,15 @@ import { BackSide, NoBlending, LinearFilter, LinearMipmapLinearFilter } from '..
  * @augments WebGLCubeRenderTarget
  */
 class CubeRenderTarget extends WebGLCubeRenderTarget {
+    readonly isCubeRenderTarget: true;
+
     /**
      * Constructs a new cube render target.
      *
      * @param {number} [size=1] - The size of the render target.
      * @param {RenderTarget~Options} [options] - The configuration object.
      */
-    constructor(size = 1, options = {}) {
+    constructor(size = 1, options: RenderTargetOptions = {}) {
         super(size, options);
 
         /**
@@ -45,7 +50,7 @@ class CubeRenderTarget extends WebGLCubeRenderTarget {
      * @param {Texture} texture - The equirectangular texture.
      * @return {CubeRenderTarget} A reference to this cube render target.
      */
-    fromEquirectangularTexture(renderer, texture) {
+    fromEquirectangularTexture(renderer: WebGLRenderer, texture: Texture) {
         const currentMinFilter = texture.minFilter;
         const currentGenerateMipmaps = texture.generateMipmaps;
 
diff --git a/src-testing/src/renderers/common/DataMap.ts b/src-testing/src/renderers/common/DataMap.ts
index 78ce34a6..225eb8c6 100644
--- a/src-testing/src/renderers/common/DataMap.ts
+++ b/src-testing/src/renderers/common/DataMap.ts
@@ -4,7 +4,9 @@
  *
  * @private
  */
-class DataMap {
+class DataMap<M extends { [key: string]: { key: object; value: unknown } }> {
+    data: WeakMap<M[keyof M]['key'], M[keyof M]['value']>;
+
     /**
      * Constructs a new data map.
      */
@@ -15,7 +17,7 @@ class DataMap {
          *
          * @type {WeakMap}
          */
-        this.data = new WeakMap();
+        this.data = new WeakMap<M[keyof M]['key'], M[keyof M]['value']>();
     }
 
     /**
@@ -24,7 +26,7 @@ class DataMap {
      * @param {Object} object - The object.
      * @return {Object} The dictionary.
      */
-    get(object) {
+    get<K extends M[keyof M]['key']>(object: K): Extract<M[keyof M], { key: K }>['value'] {
         let map = this.data.get(object);
 
         if (map === undefined) {
@@ -41,7 +43,7 @@ class DataMap {
      * @param {Object} object - The object.
      * @return {?Object} The deleted dictionary.
      */
-    delete(object) {
+    delete<K extends M[keyof M]['key']>(object: K): Extract<M[keyof M], { key: K }>['value'] {
         let map = null;
 
         if (this.data.has(object)) {
@@ -59,7 +61,7 @@ class DataMap {
      * @param {Object} object - The object to test.
      * @return {boolean} Whether a dictionary is defined or not.
      */
-    has(object) {
+    has(object: M[keyof M]['key']) {
         return this.data.has(object);
     }
 
diff --git a/src-testing/src/renderers/common/Geometries.ts b/src-testing/src/renderers/common/Geometries.ts
index 338d2fd4..442d1acf 100644
--- a/src-testing/src/renderers/common/Geometries.ts
+++ b/src-testing/src/renderers/common/Geometries.ts
@@ -2,7 +2,13 @@ import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
 import { arrayNeedsUint32 } from '../../utils.js';
 
-import { Uint16BufferAttribute, Uint32BufferAttribute } from '../../core/BufferAttribute.js';
+import { BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from '../../core/BufferAttribute.js';
+import { BufferGeometry } from '../../core/BufferGeometry.js';
+import Attributes from './Attributes.js';
+import Info from './Info.js';
+import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
+import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
+import RenderObject from './RenderObject.js';
 
 /**
  * Returns the wireframe version for the given geometry.
@@ -12,8 +18,8 @@ import { Uint16BufferAttribute, Uint32BufferAttribute } from '../../core/BufferA
  * @param {BufferGeometry} geometry - The geometry.
  * @return {number} The version.
  */
-function getWireframeVersion(geometry) {
-    return geometry.index !== null ? geometry.index.version : geometry.attributes.position.version;
+function getWireframeVersion(geometry: BufferGeometry) {
+    return geometry.index !== null ? geometry.index.version : (geometry.attributes.position as BufferAttribute).version;
 }
 
 /**
@@ -24,7 +30,7 @@ function getWireframeVersion(geometry) {
  * @param {BufferGeometry} geometry - The geometry.
  * @return {BufferAttribute} The wireframe index attribute.
  */
-function getWireframeIndex(geometry) {
+function getWireframeIndex(geometry: BufferGeometry) {
     const indices = [];
 
     const geometryIndex = geometry.index;
@@ -58,20 +64,30 @@ function getWireframeIndex(geometry) {
     return attribute;
 }
 
+interface GeometryData {
+    initialized?: boolean | undefined;
+}
+
 /**
  * This renderer module manages geometries.
  *
  * @private
  * @augments DataMap
  */
-class Geometries extends DataMap {
+class Geometries extends DataMap<{ geometry: { key: BufferGeometry; value: GeometryData } }> {
+    attributes: Attributes;
+    info: Info;
+
+    wireframes: WeakMap<BufferGeometry, BufferAttribute>;
+    attributeCall: WeakMap<BufferAttribute | InterleavedBufferAttribute | InterleavedBuffer, number>;
+
     /**
      * Constructs a new geometry management component.
      *
      * @param {Attributes} attributes - Renderer component for managing attributes.
      * @param {Info} info - Renderer component for managing metrics and monitoring data.
      */
-    constructor(attributes, info) {
+    constructor(attributes: Attributes, info: Info) {
         super();
 
         /**
@@ -93,7 +109,7 @@ class Geometries extends DataMap {
          *
          * @type {WeakMap<BufferGeometry,BufferAttribute>}
          */
-        this.wireframes = new WeakMap();
+        this.wireframes = new WeakMap<BufferGeometry, BufferAttribute>();
 
         /**
          * This Weak Map is used to make sure buffer attributes are
@@ -101,7 +117,7 @@ class Geometries extends DataMap {
          *
          * @type {WeakMap<BufferAttribute,number>}
          */
-        this.attributeCall = new WeakMap();
+        this.attributeCall = new WeakMap<BufferAttribute | InterleavedBufferAttribute, number>();
     }
 
     /**
@@ -110,8 +126,8 @@ class Geometries extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {boolean} Whether if the given render object has an initialized geometry or not.
      */
-    has(renderObject) {
-        const geometry = renderObject.geometry;
+    has(renderObject: RenderObject | BufferGeometry) {
+        const geometry = (renderObject as RenderObject).geometry;
 
         return super.has(geometry) && this.get(geometry).initialized === true;
     }
@@ -121,7 +137,7 @@ class Geometries extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         if (this.has(renderObject) === false) this.initGeometry(renderObject);
 
         this.updateAttributes(renderObject);
@@ -132,7 +148,7 @@ class Geometries extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    initGeometry(renderObject) {
+    initGeometry(renderObject: RenderObject) {
         const geometry = renderObject.geometry;
         const geometryData = this.get(geometry);
 
@@ -171,9 +187,8 @@ class Geometries extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateAttributes(renderObject) {
+    updateAttributes(renderObject: RenderObject) {
         // attributes
-
         const attributes = renderObject.getAttributes();
 
         for (const attribute of attributes) {
@@ -207,10 +222,10 @@ class Geometries extends DataMap {
      * @param {BufferAttribute} attribute - The attribute to update.
      * @param {number} type - The attribute type.
      */
-    updateAttribute(attribute, type) {
+    updateAttribute(attribute: BufferAttribute | InterleavedBufferAttribute, type: AttributeType) {
         const callId = this.info.render.calls;
 
-        if (!attribute.isInterleavedBufferAttribute) {
+        if (!(attribute as InterleavedBufferAttribute).isInterleavedBufferAttribute) {
             if (this.attributeCall.get(attribute) !== callId) {
                 this.attributes.update(attribute, type);
 
@@ -221,10 +236,10 @@ class Geometries extends DataMap {
                 this.attributes.update(attribute, type);
 
                 this.attributeCall.set(attribute, callId);
-            } else if (this.attributeCall.get(attribute.data) !== callId) {
+            } else if (this.attributeCall.get((attribute as InterleavedBufferAttribute).data) !== callId) {
                 this.attributes.update(attribute, type);
 
-                this.attributeCall.set(attribute.data, callId);
+                this.attributeCall.set((attribute as InterleavedBufferAttribute).data, callId);
 
                 this.attributeCall.set(attribute, callId);
             }
@@ -237,7 +252,7 @@ class Geometries extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
      */
-    getIndirect(renderObject) {
+    getIndirect(renderObject: RenderObject) {
         return renderObject.geometry.indirect;
     }
 
@@ -248,7 +263,7 @@ class Geometries extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
      */
-    getIndex(renderObject) {
+    getIndex(renderObject: RenderObject) {
         const { geometry, material } = renderObject;
 
         let index = geometry.index;
diff --git a/src-testing/src/renderers/common/Info.ts b/src-testing/src/renderers/common/Info.ts
index 0b4fef90..858e99a2 100644
--- a/src-testing/src/renderers/common/Info.ts
+++ b/src-testing/src/renderers/common/Info.ts
@@ -1,9 +1,42 @@
+import { Object3D } from '../../core/Object3D.js';
+import { Mesh } from '../../objects/Mesh.js';
+import { Sprite } from '../../objects/Sprite.js';
+import { Points } from '../../objects/Points.js';
+import { LineSegments } from '../../objects/LineSegments.js';
+import { Line } from '../../objects/Line.js';
+
 /**
  * This renderer module provides a series of statistical information
  * about the GPU memory and the rendering process. Useful for debugging
  * and monitoring.
  */
 class Info {
+    autoReset: boolean;
+
+    frame: number;
+    calls: number;
+
+    render: {
+        calls: number;
+        frameCalls: number;
+        drawCalls: number;
+        triangles: number;
+        points: number;
+        lines: number;
+        timestamp: number;
+    };
+
+    compute: {
+        calls: number;
+        frameCalls: number;
+        timestamp: number;
+    };
+
+    memory: {
+        geometries: number;
+        textures: number;
+    };
+
     /**
      * Constructs a new info component.
      */
@@ -98,16 +131,16 @@ class Info {
      * @param {number} count - The vertex or index count.
      * @param {number} instanceCount - The instance count.
      */
-    update(object, count, instanceCount) {
+    update(object: Object3D, count: number, instanceCount: number) {
         this.render.drawCalls++;
 
-        if (object.isMesh || object.isSprite) {
+        if ((object as Mesh).isMesh || (object as Sprite).isSprite) {
             this.render.triangles += instanceCount * (count / 3);
-        } else if (object.isPoints) {
+        } else if ((object as Points).isPoints) {
             this.render.points += instanceCount * count;
-        } else if (object.isLineSegments) {
+        } else if ((object as LineSegments).isLineSegments) {
             this.render.lines += instanceCount * (count / 2);
-        } else if (object.isLine) {
+        } else if ((object as Line).isLine) {
             this.render.lines += instanceCount * (count - 1);
         } else {
             console.error('THREE.WebGPUInfo: Unknown object type.');
diff --git a/src-testing/src/renderers/common/Pipeline.ts b/src-testing/src/renderers/common/Pipeline.ts
index ea931b7e..4bfaa3c1 100644
--- a/src-testing/src/renderers/common/Pipeline.ts
+++ b/src-testing/src/renderers/common/Pipeline.ts
@@ -5,12 +5,16 @@
  * @abstract
  */
 class Pipeline {
+    cacheKey: string;
+
+    usedTimes: number;
+
     /**
      * Constructs a new pipeline.
      *
      * @param {string} cacheKey - The pipeline's cache key.
      */
-    constructor(cacheKey) {
+    constructor(cacheKey: string) {
         /**
          * The pipeline's cache key.
          *
diff --git a/src-testing/src/renderers/common/Pipelines.ts b/src-testing/src/renderers/common/Pipelines.ts
index 06530ce3..a15872f7 100644
--- a/src-testing/src/renderers/common/Pipelines.ts
+++ b/src-testing/src/renderers/common/Pipelines.ts
@@ -2,6 +2,22 @@ import DataMap from './DataMap.js';
 import RenderPipeline from './RenderPipeline.js';
 import ComputePipeline from './ComputePipeline.js';
 import ProgrammableStage from './ProgrammableStage.js';
+import Backend from './Backend.js';
+import Nodes from './nodes/Nodes.js';
+import Bindings from './Bindings.js';
+import RenderObject from './RenderObject.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import Binding from './Binding.js';
+import Pipeline from './Pipeline.js';
+
+interface ComputeNodeData {
+    version: number;
+    pipeline: ComputePipeline;
+}
+
+interface RenderObjectData {
+    pipeline: RenderPipeline;
+}
 
 /**
  * This renderer module manages the pipelines of the renderer.
@@ -9,14 +25,29 @@ import ProgrammableStage from './ProgrammableStage.js';
  * @private
  * @augments DataMap
  */
-class Pipelines extends DataMap {
+class Pipelines extends DataMap<{
+    computeNode: { key: ComputeNode; value: ComputeNodeData };
+    renderObject: { key: RenderObject; value: RenderObjectData };
+}> {
+    backend: Backend;
+    nodes: Nodes;
+
+    bindings: Bindings | null;
+
+    caches: Map<string, Pipeline>;
+    programs: {
+        vertex: Map<string, ProgrammableStage>;
+        fragment: Map<string, ProgrammableStage>;
+        compute: Map<string, ProgrammableStage>;
+    };
+
     /**
      * Constructs a new pipeline management component.
      *
      * @param {Backend} backend - The renderer's backend.
      * @param {Nodes} nodes - Renderer component for managing nodes related logic.
      */
-    constructor(backend, nodes) {
+    constructor(backend: Backend, nodes: Nodes) {
         super();
 
         /**
@@ -49,7 +80,7 @@ class Pipelines extends DataMap {
          *
          * @type {Map<string,Pipeline>}
          */
-        this.caches = new Map();
+        this.caches = new Map<string, Pipeline>();
 
         /**
          * This dictionary maintains for each shader stage type (vertex,
@@ -59,9 +90,9 @@ class Pipelines extends DataMap {
          * @type {Object<string,Map>}
          */
         this.programs = {
-            vertex: new Map(),
-            fragment: new Map(),
-            compute: new Map(),
+            vertex: new Map<string, ProgrammableStage>(),
+            fragment: new Map<string, ProgrammableStage>(),
+            compute: new Map<string, ProgrammableStage>(),
         };
     }
 
@@ -72,7 +103,7 @@ class Pipelines extends DataMap {
      * @param {Array<BindGroup>} bindings - The bindings.
      * @return {ComputePipeline} The compute pipeline.
      */
-    getForCompute(computeNode, bindings) {
+    getForCompute(computeNode: ComputeNode, bindings: Binding[]) {
         const { backend } = this;
 
         const data = this.get(computeNode);
@@ -91,20 +122,20 @@ class Pipelines extends DataMap {
 
             // programmable stage
 
-            let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader);
+            let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader!);
 
             if (stageCompute === undefined) {
                 if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0)
                     this._releaseProgram(previousPipeline.computeProgram);
 
                 stageCompute = new ProgrammableStage(
-                    nodeBuilderState.computeShader,
+                    nodeBuilderState.computeShader!,
                     'compute',
                     computeNode.name,
                     nodeBuilderState.transforms,
                     nodeBuilderState.nodeAttributes,
                 );
-                this.programs.compute.set(nodeBuilderState.computeShader, stageCompute);
+                this.programs.compute.set(nodeBuilderState.computeShader!, stageCompute);
 
                 backend.createProgram(stageCompute);
             }
@@ -113,7 +144,7 @@ class Pipelines extends DataMap {
 
             const cacheKey = this._getComputeCacheKey(computeNode, stageCompute);
 
-            let pipeline = this.caches.get(cacheKey);
+            let pipeline = this.caches.get(cacheKey) as ComputePipeline | undefined;
 
             if (pipeline === undefined) {
                 if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
@@ -142,7 +173,7 @@ class Pipelines extends DataMap {
      * @param {?Array<Promise>} [promises=null] - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
      * @return {RenderPipeline} The render pipeline.
      */
-    getForRender(renderObject, promises = null) {
+    getForRender(renderObject: RenderObject, promises: Promise<void>[] | null = null) {
         const { backend } = this;
 
         const data = this.get(renderObject);
@@ -164,26 +195,26 @@ class Pipelines extends DataMap {
 
             // programmable stages
 
-            let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);
+            let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader!);
 
             if (stageVertex === undefined) {
                 if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0)
                     this._releaseProgram(previousPipeline.vertexProgram);
 
-                stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader, 'vertex', name);
-                this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);
+                stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader!, 'vertex', name);
+                this.programs.vertex.set(nodeBuilderState.vertexShader!, stageVertex);
 
                 backend.createProgram(stageVertex);
             }
 
-            let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader);
+            let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader!);
 
             if (stageFragment === undefined) {
                 if (previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0)
                     this._releaseProgram(previousPipeline.fragmentProgram);
 
-                stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader, 'fragment', name);
-                this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);
+                stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader!, 'fragment', name);
+                this.programs.fragment.set(nodeBuilderState.fragmentShader!, stageFragment);
 
                 backend.createProgram(stageFragment);
             }
@@ -192,7 +223,7 @@ class Pipelines extends DataMap {
 
             const cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
 
-            let pipeline = this.caches.get(cacheKey);
+            let pipeline = this.caches.get(cacheKey) as RenderPipeline | undefined;
 
             if (pipeline === undefined) {
                 if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
@@ -222,7 +253,7 @@ class Pipelines extends DataMap {
      * @param {RenderObject} object - The render object.
      * @return {?Object} The deleted dictionary.
      */
-    delete(object) {
+    delete(object: ComputeNode | RenderObject): never {
         const pipeline = this.get(object).pipeline;
 
         if (pipeline) {
@@ -234,20 +265,23 @@ class Pipelines extends DataMap {
 
             // programs
 
-            if (pipeline.isComputePipeline) {
-                pipeline.computeProgram.usedTimes--;
+            if ((pipeline as ComputePipeline).isComputePipeline) {
+                (pipeline as ComputePipeline).computeProgram.usedTimes--;
 
-                if (pipeline.computeProgram.usedTimes === 0) this._releaseProgram(pipeline.computeProgram);
+                if ((pipeline as ComputePipeline).computeProgram.usedTimes === 0)
+                    this._releaseProgram((pipeline as ComputePipeline).computeProgram);
             } else {
-                pipeline.fragmentProgram.usedTimes--;
-                pipeline.vertexProgram.usedTimes--;
+                (pipeline as RenderPipeline).fragmentProgram.usedTimes--;
+                (pipeline as RenderPipeline).vertexProgram.usedTimes--;
 
-                if (pipeline.vertexProgram.usedTimes === 0) this._releaseProgram(pipeline.vertexProgram);
-                if (pipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(pipeline.fragmentProgram);
+                if ((pipeline as RenderPipeline).vertexProgram.usedTimes === 0)
+                    this._releaseProgram((pipeline as RenderPipeline).vertexProgram);
+                if ((pipeline as RenderPipeline).fragmentProgram.usedTimes === 0)
+                    this._releaseProgram((pipeline as RenderPipeline).fragmentProgram);
             }
         }
 
-        return super.delete(object);
+        return super.delete(object) as never;
     }
 
     /**
@@ -269,7 +303,7 @@ class Pipelines extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         this.getForRender(renderObject);
     }
 
@@ -283,12 +317,17 @@ class Pipelines extends DataMap {
      * @param {Array<BindGroup>} bindings - The bindings.
      * @return {ComputePipeline} The compute pipeline.
      */
-    _getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {
+    _getComputePipeline(
+        computeNode: ComputeNode,
+        stageCompute: ProgrammableStage,
+        cacheKey: string,
+        bindings: Binding[],
+    ) {
         // check for existing pipeline
 
         cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);
 
-        let pipeline = this.caches.get(cacheKey);
+        let pipeline = this.caches.get(cacheKey) as ComputePipeline | undefined;
 
         if (pipeline === undefined) {
             pipeline = new ComputePipeline(cacheKey, stageCompute);
@@ -312,12 +351,18 @@ class Pipelines extends DataMap {
      * @param {?Array<Promise>} promises - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
      * @return {ComputePipeline} The compute pipeline.
      */
-    _getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises) {
+    _getRenderPipeline(
+        renderObject: RenderObject,
+        stageVertex: ProgrammableStage,
+        stageFragment: ProgrammableStage,
+        cacheKey: string,
+        promises: Promise<void>[] | null,
+    ) {
         // check for existing pipeline
 
         cacheKey = cacheKey || this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
 
-        let pipeline = this.caches.get(cacheKey);
+        let pipeline = this.caches.get(cacheKey) as RenderPipeline | undefined;
 
         if (pipeline === undefined) {
             pipeline = new RenderPipeline(cacheKey, stageVertex, stageFragment);
@@ -344,7 +389,7 @@ class Pipelines extends DataMap {
      * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
      * @return {string} The cache key.
      */
-    _getComputeCacheKey(computeNode, stageCompute) {
+    _getComputeCacheKey(computeNode: ComputeNode, stageCompute: ProgrammableStage) {
         return computeNode.id + ',' + stageCompute.id;
     }
 
@@ -357,7 +402,7 @@ class Pipelines extends DataMap {
      * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
      * @return {string} The cache key.
      */
-    _getRenderCacheKey(renderObject, stageVertex, stageFragment) {
+    _getRenderCacheKey(renderObject: RenderObject, stageVertex: ProgrammableStage, stageFragment: ProgrammableStage) {
         return stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey(renderObject);
     }
 
@@ -367,7 +412,7 @@ class Pipelines extends DataMap {
      * @private
      * @param {Pipeline} pipeline - The pipeline to release.
      */
-    _releasePipeline(pipeline) {
+    _releasePipeline(pipeline: Pipeline) {
         this.caches.delete(pipeline.cacheKey);
     }
 
@@ -377,7 +422,7 @@ class Pipelines extends DataMap {
      * @private
      * @param {Object} program - The shader program to release.
      */
-    _releaseProgram(program) {
+    _releaseProgram(program: ProgrammableStage) {
         const code = program.code;
         const stage = program.stage;
 
@@ -391,7 +436,7 @@ class Pipelines extends DataMap {
      * @param {Node} computeNode - The compute node.
      * @return {boolean} Whether the compute pipeline for the given compute node requires an update or not.
      */
-    _needsComputeUpdate(computeNode) {
+    _needsComputeUpdate(computeNode: ComputeNode) {
         const data = this.get(computeNode);
 
         return data.pipeline === undefined || data.version !== computeNode.version;
@@ -404,7 +449,7 @@ class Pipelines extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {boolean} Whether the render object for the given render object requires an update or not.
      */
-    _needsRenderUpdate(renderObject) {
+    _needsRenderUpdate(renderObject: RenderObject) {
         const data = this.get(renderObject);
 
         return data.pipeline === undefined || this.backend.needsRenderUpdate(renderObject);
diff --git a/src-testing/src/renderers/common/ProgrammableStage.ts b/src-testing/src/renderers/common/ProgrammableStage.ts
index 0dc5923e..64092893 100644
--- a/src-testing/src/renderers/common/ProgrammableStage.ts
+++ b/src-testing/src/renderers/common/ProgrammableStage.ts
@@ -1,3 +1,5 @@
+import NodeAttribute from '../../nodes/core/NodeAttribute.js';
+
 let _id = 0;
 
 /**
@@ -8,6 +10,17 @@ let _id = 0;
  * @private
  */
 class ProgrammableStage {
+    id: number;
+
+    code: string;
+    stage: 'compute' | 'vertex' | 'fragment';
+    name: string;
+    // TODO
+    // transforms
+    attributes: NodeAttribute[] | null;
+
+    usedTimes: number;
+
     /**
      * Constructs a new programmable stage.
      *
@@ -17,7 +30,13 @@ class ProgrammableStage {
      * @param {?Array<Object>} [transforms=null] - The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
      * @param {?Array<Object>} [attributes=null] - The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
      */
-    constructor(code, stage, name, transforms = null, attributes = null) {
+    constructor(
+        code: string,
+        stage: 'compute' | 'vertex' | 'fragment',
+        name: string,
+        transforms = null,
+        attributes: NodeAttribute[] | null = null,
+    ) {
         /**
          * The id of the programmable stage.
          *
diff --git a/src-testing/src/renderers/common/RenderBundle.ts b/src-testing/src/renderers/common/RenderBundle.ts
index ffa28996..f690315a 100644
--- a/src-testing/src/renderers/common/RenderBundle.ts
+++ b/src-testing/src/renderers/common/RenderBundle.ts
@@ -1,3 +1,6 @@
+import { Camera } from '../../cameras/Camera.js';
+import BundleGroup from './BundleGroup.js';
+
 /**
  * This module is used to represent render bundles inside the renderer
  * for further processing.
@@ -5,13 +8,16 @@
  * @private
  */
 class RenderBundle {
+    bundleGroup: BundleGroup;
+    camera: Camera;
+
     /**
      * Constructs a new bundle group.
      *
      * @param {BundleGroup} bundleGroup - The bundle group.
      * @param {Camera} camera - The camera the bundle group is rendered with.
      */
-    constructor(bundleGroup, camera) {
+    constructor(bundleGroup: BundleGroup, camera: Camera) {
         this.bundleGroup = bundleGroup;
         this.camera = camera;
     }
diff --git a/src-testing/src/renderers/common/RenderBundles.ts b/src-testing/src/renderers/common/RenderBundles.ts
index d6c72696..3ae4005b 100644
--- a/src-testing/src/renderers/common/RenderBundles.ts
+++ b/src-testing/src/renderers/common/RenderBundles.ts
@@ -1,7 +1,9 @@
 import ChainMap from './ChainMap.js';
 import RenderBundle from './RenderBundle.js';
+import { Camera } from '../../cameras/Camera.js';
+import BundleGroup from './BundleGroup.js';
 
-const _chainKeys = [];
+const _chainKeys = [] as unknown as [BundleGroup, Camera];
 
 /**
  * This renderer module manages render bundles.
@@ -9,6 +11,8 @@ const _chainKeys = [];
  * @private
  */
 class RenderBundles {
+    bundles: ChainMap<readonly [BundleGroup, Camera], RenderBundle>;
+
     /**
      * Constructs a new render bundle management component.
      */
@@ -28,7 +32,7 @@ class RenderBundles {
      * @param {Camera} camera - The camera the bundle group is rendered with.
      * @return {RenderBundle} The render bundle.
      */
-    get(bundleGroup, camera) {
+    get(bundleGroup: BundleGroup, camera: Camera) {
         const bundles = this.bundles;
 
         _chainKeys[0] = bundleGroup;
diff --git a/src-testing/src/renderers/common/RenderContext.ts b/src-testing/src/renderers/common/RenderContext.ts
index 16b7aca8..5be14117 100644
--- a/src-testing/src/renderers/common/RenderContext.ts
+++ b/src-testing/src/renderers/common/RenderContext.ts
@@ -1,5 +1,9 @@
 import { Vector4 } from '../../math/Vector4.js';
 import { hashArray } from '../../nodes/core/NodeUtils.js';
+import { Texture } from '../../textures/Texture.js';
+import { DepthTexture } from '../../textures/DepthTexture.js';
+import ClippingContext from './ClippingContext.js';
+import { RenderTarget } from '../../core/RenderTarget.js';
 
 let _id = 0;
 
@@ -12,6 +16,43 @@ let _id = 0;
  * @private
  */
 class RenderContext {
+    id: number;
+
+    color: boolean;
+    clearColor: boolean;
+    clearColorValue: { r: number; g: number; b: number; a: number };
+
+    depth: boolean;
+    clearDepth: boolean;
+    clearDepthValue: number;
+
+    stencil: boolean;
+    clearStencil: boolean;
+    clearStencilValue: number;
+
+    viewport: boolean;
+    viewportValue: Vector4;
+    scissor: boolean;
+    scissorValue: Vector4;
+    renderTarget: RenderTarget | null;
+
+    textures: Texture[] | null;
+    depthTexture: DepthTexture | null;
+    activeCubeFace: number;
+    sampleCount: number;
+
+    width: number;
+    height: number;
+    occlusionQueryCount: number;
+    clippingContext: ClippingContext | null;
+
+    readonly isRenderContext: true;
+
+    depthClearValue?: number | undefined;
+    stencilClearValue?: number | undefined;
+
+    activeMipmapLevel?: number | undefined;
+
     /**
      * Constructs a new render context.
      */
@@ -240,12 +281,12 @@ class RenderContext {
  * @param {RenderContext} renderContext - The render context.
  * @return {number} The cache key.
  */
-export function getCacheKey(renderContext) {
+export function getCacheKey(renderContext: RenderContext) {
     const { textures, activeCubeFace } = renderContext;
 
     const values = [activeCubeFace];
 
-    for (const texture of textures) {
+    for (const texture of textures!) {
         values.push(texture.id);
     }
 
diff --git a/src-testing/src/renderers/common/RenderContexts.ts b/src-testing/src/renderers/common/RenderContexts.ts
index 67cb78af..00146508 100644
--- a/src-testing/src/renderers/common/RenderContexts.ts
+++ b/src-testing/src/renderers/common/RenderContexts.ts
@@ -2,8 +2,9 @@ import ChainMap from './ChainMap.js';
 import RenderContext from './RenderContext.js';
 import { Scene } from '../../scenes/Scene.js';
 import { Camera } from '../../cameras/Camera.js';
+import { RenderTarget } from '../../core/RenderTarget.js';
 
-const _chainKeys = [];
+const _chainKeys = [] as unknown as [Scene, Camera];
 const _defaultScene = /*@__PURE__*/ new Scene();
 const _defaultCamera = /*@__PURE__*/ new Camera();
 
@@ -13,6 +14,10 @@ const _defaultCamera = /*@__PURE__*/ new Camera();
  * @private
  */
 class RenderContexts {
+    chainMaps: {
+        [attachmentState: string]: ChainMap<readonly [Scene, Camera], RenderContext> | undefined;
+    };
+
     /**
      * Constructs a new render context management component.
      */
@@ -34,7 +39,7 @@ class RenderContexts {
      * @param {?RenderTarget} [renderTarget=null] - The active render target.
      * @return {RenderContext} The render context.
      */
-    get(scene, camera, renderTarget = null) {
+    get(scene: Scene, camera: Camera, renderTarget: RenderTarget | null = null) {
         _chainKeys[0] = scene;
         _chainKeys[1] = camera;
 
@@ -72,7 +77,7 @@ class RenderContexts {
      * @param {?RenderTarget} [renderTarget=null] - The active render target.
      * @return {RenderContext} The render context.
      */
-    getForClear(renderTarget = null) {
+    getForClear(renderTarget: RenderTarget | null = null) {
         return this.get(_defaultScene, _defaultCamera, renderTarget);
     }
 
@@ -83,8 +88,11 @@ class RenderContexts {
      * @param {string} attachmentState - The attachment state.
      * @return {ChainMap} The chain map.
      */
-    _getChainMap(attachmentState) {
-        return this.chainMaps[attachmentState] || (this.chainMaps[attachmentState] = new ChainMap());
+    _getChainMap(attachmentState: string) {
+        return (
+            this.chainMaps[attachmentState] ||
+            (this.chainMaps[attachmentState] = new ChainMap<readonly [Object3D, Camera], RenderContext>())
+        );
     }
 
     /**
diff --git a/src-testing/src/renderers/common/RenderList.ts b/src-testing/src/renderers/common/RenderList.ts
index 20e4c9b7..34f5553d 100644
--- a/src-testing/src/renderers/common/RenderList.ts
+++ b/src-testing/src/renderers/common/RenderList.ts
@@ -1,4 +1,13 @@
 import { DoubleSide } from '../../constants.js';
+import { LightsNode } from '../../nodes/Nodes.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Camera } from '../../cameras/Camera.js';
+import { BufferGeometry, GeometryGroup } from '../../core/BufferGeometry.js';
+import { Material } from '../../materials/Material.js';
+import { Light } from '../../lights/Light.js';
+import BundleGroup from './BundleGroup.js';
+import Lighting from './Lighting.js';
+import ClippingContext from './ClippingContext.js';
 
 /**
  * Default sorting function for opaque render items.
@@ -9,15 +18,15 @@ import { DoubleSide } from '../../constants.js';
  * @param {Object} b - The second render item.
  * @return {number} A numeric value which defines the sort order.
  */
-function painterSortStable(a, b) {
+function painterSortStable(a: RenderItem, b: RenderItem) {
     if (a.groupOrder !== b.groupOrder) {
-        return a.groupOrder - b.groupOrder;
+        return a.groupOrder! - b.groupOrder!;
     } else if (a.renderOrder !== b.renderOrder) {
-        return a.renderOrder - b.renderOrder;
+        return a.renderOrder! - b.renderOrder!;
     } else if (a.z !== b.z) {
-        return a.z - b.z;
+        return a.z! - b.z!;
     } else {
-        return a.id - b.id;
+        return a.id! - b.id!;
     }
 }
 
@@ -30,18 +39,36 @@ function painterSortStable(a, b) {
  * @param {Object} b - The second render item.
  * @return {number} A numeric value which defines the sort order.
  */
-function reversePainterSortStable(a, b) {
+function reversePainterSortStable(a: RenderItem, b: RenderItem) {
     if (a.groupOrder !== b.groupOrder) {
-        return a.groupOrder - b.groupOrder;
+        return a.groupOrder! - b.groupOrder!;
     } else if (a.renderOrder !== b.renderOrder) {
-        return a.renderOrder - b.renderOrder;
+        return a.renderOrder! - b.renderOrder!;
     } else if (a.z !== b.z) {
-        return b.z - a.z;
+        return b.z! - a.z!;
     } else {
-        return a.id - b.id;
+        return a.id! - b.id!;
     }
 }
 
+export interface Bundle {
+    bundleGroup: BundleGroup;
+    camera: Camera;
+    renderList: RenderList;
+}
+
+export interface RenderItem {
+    id: number | null;
+    object: Object3D | null;
+    geometry: BufferGeometry | null;
+    material: Material | null;
+    groupOrder: number | null;
+    renderOrder: number | null;
+    z: number | null;
+    group: GeometryGroup | null;
+    clippingContext: ClippingContext | null;
+}
+
 /**
  * Returns `true` if the given transparent material requires a double pass.
  *
@@ -50,7 +77,7 @@ function reversePainterSortStable(a, b) {
  * @param {Material} material - The transparent material.
  * @return {boolean} Whether the given material requires a double pass or not.
  */
-function needsDoublePass(material) {
+function needsDoublePass(material: Material) {
     const hasTransmission = material.transmission > 0 || material.transmissionNode;
 
     return hasTransmission && material.side === DoubleSide && material.forceSinglePass === false;
@@ -68,6 +95,22 @@ function needsDoublePass(material) {
  * @augments Pipeline
  */
 class RenderList {
+    renderItems: RenderItem[];
+    renderItemsIndex: number;
+
+    opaque: RenderItem[];
+    transparentDoublePass: RenderItem[];
+    transparent: RenderItem[];
+    bundles: Bundle[];
+
+    lightsNode: LightsNode;
+    lightsArray: Light[];
+
+    scene: Object3D;
+    camera: Camera;
+
+    occlusionQueryCount: number;
+
     /**
      * Constructs a render list.
      *
@@ -75,7 +118,7 @@ class RenderList {
      * @param {Scene} scene - The scene.
      * @param {Camera} camera - The camera the scene is rendered with.
      */
-    constructor(lighting, scene, camera) {
+    constructor(lighting: Lighting, scene: Object3D, camera: Camera) {
         /**
          * 3D objects are transformed into render items and stored in this array.
          *
@@ -198,7 +241,15 @@ class RenderList {
      * @param {ClippingContext} clippingContext - The current clipping context.
      * @return {Object} The render item.
      */
-    getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext) {
+    getNextRenderItem(
+        object: Object3D,
+        geometry: BufferGeometry,
+        material: Material,
+        groupOrder: number,
+        z: number,
+        group: GeometryGroup | null,
+        clippingContext: ClippingContext | null,
+    ) {
         let renderItem = this.renderItems[this.renderItemsIndex];
 
         if (renderItem === undefined) {
@@ -244,7 +295,15 @@ class RenderList {
      * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
      * @param {ClippingContext} clippingContext - The current clipping context.
      */
-    push(object, geometry, material, groupOrder, z, group, clippingContext) {
+    push(
+        object: Object3D,
+        geometry: BufferGeometry,
+        material: Material,
+        groupOrder: number,
+        z: number,
+        group: GeometryGroup | null,
+        clippingContext: ClippingContext | null,
+    ) {
         const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);
 
         if (object.occlusionTest === true) this.occlusionQueryCount++;
@@ -270,7 +329,15 @@ class RenderList {
      * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
      * @param {ClippingContext} clippingContext - The current clipping context.
      */
-    unshift(object, geometry, material, groupOrder, z, group, clippingContext) {
+    unshift(
+        object: Object3D,
+        geometry: BufferGeometry,
+        material: Material,
+        groupOrder: number,
+        z: number,
+        group: GeometryGroup | null,
+        clippingContext: ClippingContext | null,
+    ) {
         const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);
 
         if (material.transparent === true || material.transmission > 0) {
@@ -287,7 +354,7 @@ class RenderList {
      *
      * @param {Object} group - Bundle group data.
      */
-    pushBundle(group) {
+    pushBundle(group: Bundle) {
         this.bundles.push(group);
     }
 
@@ -296,7 +363,7 @@ class RenderList {
      *
      * @param {Light} light - The light.
      */
-    pushLight(light) {
+    pushLight(light: Light) {
         this.lightsArray.push(light);
     }
 
@@ -306,7 +373,10 @@ class RenderList {
      * @param {?function(any, any): number} customOpaqueSort - A custom sort function for opaque objects.
      * @param {?function(any, any): number} customTransparentSort -  A custom sort function for transparent objects.
      */
-    sort(customOpaqueSort, customTransparentSort) {
+    sort(
+        customOpaqueSort: ((a: RenderItem, b: RenderItem) => number) | null,
+        customTransparentSort: ((a: RenderItem, b: RenderItem) => number) | null,
+    ) {
         if (this.opaque.length > 1) this.opaque.sort(customOpaqueSort || painterSortStable);
         if (this.transparentDoublePass.length > 1)
             this.transparentDoublePass.sort(customTransparentSort || reversePainterSortStable);
diff --git a/src-testing/src/renderers/common/RenderLists.ts b/src-testing/src/renderers/common/RenderLists.ts
index d12ad583..ef6e14ec 100644
--- a/src-testing/src/renderers/common/RenderLists.ts
+++ b/src-testing/src/renderers/common/RenderLists.ts
@@ -1,7 +1,10 @@
 import ChainMap from './ChainMap.js';
 import RenderList from './RenderList.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Camera } from '../../cameras/Camera.js';
+import Lighting from './Lighting.js';
 
-const _chainKeys = [];
+const _chainKeys = [] as unknown as [Object3D, Camera];
 
 /**
  * This renderer module manages the render lists which are unique
@@ -10,12 +13,16 @@ const _chainKeys = [];
  * @private
  */
 class RenderLists {
+    lighting: Lighting;
+
+    lists: ChainMap<readonly [Object3D, Camera], RenderList>;
+
     /**
      * Constructs a render lists management component.
      *
      * @param {Lighting} lighting - The lighting management component.
      */
-    constructor(lighting) {
+    constructor(lighting: Lighting) {
         /**
          * The lighting management component.
          *
@@ -28,7 +35,7 @@ class RenderLists {
          *
          * @type {ChainMap}
          */
-        this.lists = new ChainMap();
+        this.lists = new ChainMap<readonly [Object3D, Camera], RenderList>();
     }
 
     /**
@@ -38,7 +45,7 @@ class RenderLists {
      * @param {Camera} camera - The camera.
      * @return {RenderList} The render list.
      */
-    get(scene, camera) {
+    get(scene: Object3D, camera: Camera) {
         const lists = this.lists;
 
         _chainKeys[0] = scene;
@@ -60,7 +67,7 @@ class RenderLists {
      * Frees all internal resources.
      */
     dispose() {
-        this.lists = new ChainMap();
+        this.lists = new ChainMap<readonly [Object3D, Camera], RenderList>();
     }
 }
 
diff --git a/src-testing/src/renderers/common/RenderObject.ts b/src-testing/src/renderers/common/RenderObject.ts
index a74e309f..8e4b71b0 100644
--- a/src-testing/src/renderers/common/RenderObject.ts
+++ b/src-testing/src/renderers/common/RenderObject.ts
@@ -1,8 +1,27 @@
 import { hash, hashString } from '../../nodes/core/NodeUtils.js';
+import ClippingContext from './ClippingContext.js';
+import { Material } from '../../materials/Material.js';
+import Nodes from './nodes/Nodes.js';
+import Geometries from './Geometries.js';
+import Renderer from './Renderer.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Scene } from '../../scenes/Scene.js';
+import { Camera } from '../../cameras/Camera.js';
+import { LightsNode } from '../../nodes/Nodes.js';
+import RenderContext from './RenderContext.js';
+import { BufferGeometry } from '../../core/BufferGeometry.js';
+import { BufferAttribute } from '../../core/BufferAttribute.js';
+import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
+import RenderPipeline from './RenderPipeline.js';
+import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
+import NodeBuilderState from './nodes/NodeBuilderState.js';
+import BindGroup from './BindGroup.js';
+import NodeMaterialObserver from '../../materials/nodes/manager/NodeMaterialObserver.js';
+import BundleGroup from './BundleGroup.js';
 
 let _id = 0;
 
-function getKeys(obj) {
+function getKeys(obj: Material) {
     const keys = Object.keys(obj);
 
     let proto = Object.getPrototypeOf(obj);
@@ -45,6 +64,47 @@ function getKeys(obj) {
  * @private
  */
 class RenderObject {
+    _nodes: Nodes;
+    _geometries: Geometries;
+
+    id: number;
+
+    renderer: Renderer;
+    object: Object3D;
+    material: Material;
+    scene: Scene;
+    camera: Camera;
+    lightsNode: LightsNode;
+    context: RenderContext;
+
+    geometry: BufferGeometry;
+    version: number;
+
+    drawRange: { start: number; count: number } | null;
+
+    attributes: Array<BufferAttribute | InterleavedBufferAttribute> | null;
+    pipeline: RenderPipeline | null;
+    vertexBuffers: Array<BufferAttribute | InterleavedBuffer> | null;
+    drawParams: { vertexCount: number; firstVertex: number; instanceCount: number; firstInstance: number } | null;
+
+    bundle: BundleGroup | null;
+
+    clippingContext: ClippingContext | null;
+
+    clippingContextCacheKey: string;
+
+    initialNodesCacheKey: string;
+    initialCacheKey: string;
+
+    _nodeBuilderState: NodeBuilderState | null;
+    _bindings: BindGroup[] | null;
+    _monitor: NodeMaterialObserver | null;
+
+    onDispose: (() => void) | null;
+
+    readonly isRenderObject: true;
+
+    onMaterialDispose: () => void;
     /**
      * Constructs a new render object.
      *
@@ -60,16 +120,16 @@ class RenderObject {
      * @param {ClippingContext} clippingContext - The clipping context.
      */
     constructor(
-        nodes,
-        geometries,
-        renderer,
-        object,
-        material,
-        scene,
-        camera,
-        lightsNode,
-        renderContext,
-        clippingContext,
+        nodes: Nodes,
+        geometries: Geometries,
+        renderer: Renderer,
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+        clippingContext: ClippingContext | null,
     ) {
         this.id = _id++;
 
@@ -305,7 +365,7 @@ class RenderObject {
      *
      * @param {ClippingContext} context - The clipping context to set.
      */
-    updateClipping(context) {
+    updateClipping(context: ClippingContext) {
         this.clippingContext = context;
     }
 
@@ -319,7 +379,7 @@ class RenderObject {
         if (this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey)
             return false;
 
-        this.clippingContextCacheKey = this.clippingContext.cacheKey;
+        this.clippingContextCacheKey = this.clippingContext!.cacheKey;
 
         return true;
     }
@@ -367,7 +427,7 @@ class RenderObject {
      * @param {string} name - The name of the binding group.
      * @return {?BindGroup} The bindings.
      */
-    getBindingGroup(name) {
+    getBindingGroup(name: string) {
         for (const bindingGroup of this.getBindings()) {
             if (bindingGroup.name === name) {
                 return bindingGroup;
@@ -399,7 +459,7 @@ class RenderObject {
      * @return {Array<Object>} An array with object references.
      */
     getChainArray() {
-        return [this.object, this.material, this.context, this.lightsNode];
+        return [this.object, this.material, this.context, this.lightsNode] as const;
     }
 
     /**
@@ -408,7 +468,7 @@ class RenderObject {
      *
      * @param {BufferGeometry} geometry - The geometry to set.
      */
-    setGeometry(geometry) {
+    setGeometry(geometry: BufferGeometry) {
         this.geometry = geometry;
         this.attributes = null;
     }
@@ -425,8 +485,8 @@ class RenderObject {
         const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
         const geometry = this.geometry;
 
-        const attributes = [];
-        const vertexBuffers = new Set();
+        const attributes: Array<BufferAttribute | InterleavedBufferAttribute> = [];
+        const vertexBuffers = new Set<BufferAttribute | InterleavedBuffer>();
 
         for (const nodeAttribute of nodeAttributes) {
             const attribute =
@@ -729,7 +789,7 @@ class RenderObject {
     dispose() {
         this.material.removeEventListener('dispose', this.onMaterialDispose);
 
-        this.onDispose();
+        this.onDispose!();
     }
 }
 
diff --git a/src-testing/src/renderers/common/RenderObjects.ts b/src-testing/src/renderers/common/RenderObjects.ts
index 01cd49a0..e6a255b9 100644
--- a/src-testing/src/renderers/common/RenderObjects.ts
+++ b/src-testing/src/renderers/common/RenderObjects.ts
@@ -1,7 +1,20 @@
 import ChainMap from './ChainMap.js';
 import RenderObject from './RenderObject.js';
+import Renderer from './Renderer.js';
+import Nodes from './nodes/Nodes.js';
+import Geometries from './Geometries.js';
+import Pipelines from './Pipelines.js';
+import Bindings from './Bindings.js';
+import Info from './Info.js';
+import LightsNode from '../../nodes/lighting/LightsNode.js';
+import RenderContext from './RenderContext.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Material } from '../../materials/Material.js';
+import { Scene } from '../../scenes/Scene.js';
+import { Camera } from '../../cameras/Camera.js';
+import ClippingContext from './ClippingContext.js';
 
-const _chainKeys = [];
+const _chainKeys = [] as unknown as [Object3D, Material, RenderContext, LightsNode];
 
 /**
  * This module manages the render objects of the renderer.
@@ -9,6 +22,15 @@ const _chainKeys = [];
  * @private
  */
 class RenderObjects {
+    renderer: Renderer;
+    nodes: Nodes;
+    geometries: Geometries;
+    pipelines: Pipelines;
+    bindings: Bindings;
+    info: Info;
+
+    chainMaps: { [passId: string]: ChainMap<readonly [Object3D, Material, RenderContext, LightsNode], RenderObject> };
+
     /**
      * Constructs a new render object management component.
      *
@@ -19,7 +41,14 @@ class RenderObjects {
      * @param {Bindings} bindings - Renderer component for managing bindings.
      * @param {Info} info - Renderer component for managing metrics and monitoring data.
      */
-    constructor(renderer, nodes, geometries, pipelines, bindings, info) {
+    constructor(
+        renderer: Renderer,
+        nodes: Nodes,
+        geometries: Geometries,
+        pipelines: Pipelines,
+        bindings: Bindings,
+        info: Info,
+    ) {
         /**
          * The renderer.
          *
@@ -84,7 +113,16 @@ class RenderObjects {
      * @param {string} [passId] - An optional ID for identifying the pass.
      * @return {RenderObject} The render object.
      */
-    get(object, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {
+    get(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+        clippingContext: ClippingContext | null,
+        passId?: string | undefined,
+    ): RenderObject {
         const chainMap = this.getChainMap(passId);
 
         // reuse chainArray
@@ -112,7 +150,7 @@ class RenderObjects {
 
             chainMap.set(_chainKeys, renderObject);
         } else {
-            renderObject.updateClipping(clippingContext);
+            renderObject.updateClipping(clippingContext!);
 
             if (renderObject.needsGeometryUpdate) {
                 renderObject.setGeometry(object.geometry);
@@ -150,7 +188,13 @@ class RenderObjects {
      * @return {ChainMap} The chain map.
      */
     getChainMap(passId = 'default') {
-        return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());
+        return (
+            this.chainMaps[passId] ||
+            (this.chainMaps[passId] = new ChainMap<
+                readonly [Object3D, Material, RenderContext, LightsNode],
+                RenderObject
+            >())
+        );
     }
 
     /**
@@ -177,17 +221,17 @@ class RenderObjects {
      * @return {RenderObject} The render object.
      */
     createRenderObject(
-        nodes,
-        geometries,
-        renderer,
-        object,
-        material,
-        scene,
-        camera,
-        lightsNode,
-        renderContext,
-        clippingContext,
-        passId,
+        nodes: Nodes,
+        geometries: Geometries,
+        renderer: Renderer,
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+        clippingContext: ClippingContext | null,
+        passId: string | undefined,
     ) {
         const chainMap = this.getChainMap(passId);
 
diff --git a/src-testing/src/renderers/common/RenderPipeline.ts b/src-testing/src/renderers/common/RenderPipeline.ts
index 7527627e..c0fcddf9 100644
--- a/src-testing/src/renderers/common/RenderPipeline.ts
+++ b/src-testing/src/renderers/common/RenderPipeline.ts
@@ -1,4 +1,5 @@
 import Pipeline from './Pipeline.js';
+import ProgrammableStage from './ProgrammableStage.js';
 
 /**
  * Class for representing render pipelines.
@@ -7,6 +8,9 @@ import Pipeline from './Pipeline.js';
  * @augments Pipeline
  */
 class RenderPipeline extends Pipeline {
+    vertexProgram: ProgrammableStage;
+    fragmentProgram: ProgrammableStage;
+
     /**
      * Constructs a new render pipeline.
      *
@@ -14,7 +18,7 @@ class RenderPipeline extends Pipeline {
      * @param {ProgrammableStage} vertexProgram - The pipeline's vertex shader.
      * @param {ProgrammableStage} fragmentProgram - The pipeline's fragment shader.
      */
-    constructor(cacheKey, vertexProgram, fragmentProgram) {
+    constructor(cacheKey: string, vertexProgram: ProgrammableStage, fragmentProgram: ProgrammableStage) {
         super(cacheKey);
 
         /**
diff --git a/src-testing/src/renderers/common/Renderer.ts b/src-testing/src/renderers/common/Renderer.ts
index 751bff45..8159ce82 100644
--- a/src-testing/src/renderers/common/Renderer.ts
+++ b/src-testing/src/renderers/common/Renderer.ts
@@ -25,6 +25,7 @@ import { Frustum } from '../../math/Frustum.js';
 import { FrustumArray } from '../../math/FrustumArray.js';
 import { Matrix4 } from '../../math/Matrix4.js';
 import { Vector2 } from '../../math/Vector2.js';
+import { Vector3 } from '../../math/Vector3.js';
 import { Vector4 } from '../../math/Vector4.js';
 import { RenderTarget } from '../../core/RenderTarget.js';
 import {
@@ -38,7 +39,37 @@ import {
     HalfFloatType,
     RGBAFormat,
     PCFShadowMap,
+    ToneMapping,
+    ShadowMapType,
+    TimestampQuery,
+    TextureDataType,
 } from '../../constants.js';
+import Backend from './Backend.js';
+import RenderContext from './RenderContext.js';
+import RenderList, { Bundle, RenderItem } from './RenderList.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Camera } from '../../cameras/Camera.js';
+import { BufferGeometry, GeometryGroup } from '../../core/BufferGeometry.js';
+import { Material } from '../../materials/Material.js';
+import RenderBundle from './RenderBundle.js';
+import { Light } from '../../lights/Light.js';
+import { BufferAttribute } from '../../core/BufferAttribute.js';
+import { Texture } from '../../textures/Texture.js';
+import { FramebufferTexture } from '../../textures/FramebufferTexture.js';
+import { Box2 } from '../../math/Box2.js';
+import { Box3 } from '../../math/Box3.js';
+import { ColorRepresentation } from '../../math/Color.js';
+import { Group } from '../../objects/Group.js';
+import { LOD } from '../../objects/LOD.js';
+import { Sprite } from '../../objects/Sprite.js';
+import { LineLoop } from '../../objects/LineLoop.js';
+import { Mesh } from '../../objects/Mesh.js';
+import { Line } from '../../objects/Line.js';
+import { Points } from '../../objects/Points.js';
+import MRTNode from '../../nodes/core/MRTNode.js';
+import LightsNode from '../../nodes/lighting/LightsNode.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import { ArrayCamera } from '../../cameras/ArrayCamera.js';
 
 const _scene = /*@__PURE__*/ new Scene();
 const _drawingBufferSize = /*@__PURE__*/ new Vector2();
@@ -49,10 +80,186 @@ const _frustumArray = /*@__PURE__*/ new FrustumArray();
 const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
 const _vector4 = /*@__PURE__*/ new Vector4();
 
+interface Rectangle {
+    x: number;
+    y: number;
+    z: number;
+    w: number;
+}
+
+interface DeviceLostInfo {
+    api: 'WebGL' | 'WebGPU';
+    message: string;
+    reason: string | null;
+    originalEvent: unknown;
+}
+
+export interface RendererParameters {
+    logarithmicDepthBuffer?: boolean | undefined;
+    alpha?: boolean | undefined;
+    depth?: boolean | undefined;
+    stencil?: boolean | undefined;
+    antialias?: boolean | undefined;
+    samples?: number | undefined;
+    getFallback?: ((error: unknown) => Backend) | null | undefined;
+    colorBufferType?: TextureDataType | undefined;
+    multiview?: boolean | undefined;
+}
+
 /**
  * Base class for renderers.
  */
 class Renderer {
+    readonly isRenderer: true;
+
+    domElement: HTMLCanvasElement;
+
+    backend: Backend;
+
+    samples: number;
+
+    autoClear: boolean;
+    autoClearColor: boolean;
+    autoClearDepth: boolean;
+    autoClearStencil: boolean;
+
+    alpha: boolean;
+
+    logarithmicDepthBuffer: boolean;
+
+    outputColorSpace: string;
+
+    toneMapping: ToneMapping;
+    toneMappingExposure: number;
+
+    sortObjects: boolean;
+
+    depth: boolean;
+    stencil: boolean;
+
+    info: Info;
+
+    library: NodeLibrary;
+    lighting: Lighting;
+
+    _getFallback: ((error: unknown) => Backend) | null;
+
+    _pixelRatio: number;
+    _width: number;
+    _height: number;
+
+    _viewport: Vector4;
+    _scissor: Vector4;
+    _scissorTest: boolean;
+
+    _attributes: Attributes | null;
+    _geometries: Geometries | null;
+    _nodes: Nodes | null;
+    _animation: Animation | null;
+    _bindings: Bindings | null;
+    _objects: RenderObjects | null;
+    _pipelines: Pipelines | null;
+    _bundles: RenderBundles | null;
+    _renderLists: RenderLists | null;
+    _renderContexts: RenderContexts | null;
+    _textures: Textures | null;
+    _background: Background | null;
+
+    _quad: QuadMesh;
+
+    _currentRenderContext: RenderContext | null;
+
+    _opaqueSort: ((a: RenderItem, b: RenderItem) => number) | null;
+    _transparentSort: ((a: RenderItem, b: RenderItem) => number) | null;
+
+    _frameBufferTarget: RenderTarget | null;
+
+    _clearColor: Color4;
+    _clearDepth: number;
+    _clearStencil: number;
+
+    _renderTarget: RenderTarget | null;
+    _activeCubeFace: number;
+    _activeMipmapLevel: number;
+    _outputRenderTarget: RenderTarget | null;
+
+    _mrt: MRTNode | null;
+
+    _renderObjectFunction:
+        | ((
+              object: Object3D,
+              scene: Scene,
+              camera: Camera,
+              geometry: BufferGeometry,
+              material: Material,
+              group: GeometryGroup,
+              lightsNode: LightsNode,
+              clippingContext: ClippingContext | null,
+              passId: string | null,
+          ) => void)
+        | null;
+    _currentRenderObjectFunction:
+        | ((
+              object: Object3D,
+              scene: Scene,
+              camera: Camera,
+              geometry: BufferGeometry,
+              material: Material,
+              group: GeometryGroup,
+              lightsNode: LightsNode,
+              clippingContext: ClippingContext | null,
+              passId: string | null,
+          ) => void)
+        | null;
+    _currentRenderBundle: RenderBundle | null;
+
+    _handleObjectFunction: (
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: GeometryGroup,
+        clippingContext: ClippingContext | null,
+        passId?: string,
+    ) => void;
+
+    _isDeviceLost: boolean;
+    onDeviceLost: (info: DeviceLostInfo) => void;
+
+    _colorBufferType: TextureDataType;
+
+    _initialized: boolean;
+    _initPromise: Promise<this> | null;
+
+    _compilationPromises: Promise<void>[] | null;
+
+    transparent: boolean;
+    opaque: boolean;
+
+    shadowMap: { enabled: boolean; type: ShadowMapType | null };
+
+    xr: XRManager;
+
+    debug: {
+        checkShaderErrors: boolean;
+        onShaderError:
+            | ((
+                  gl: WebGL2RenderingContext,
+                  programGPU: WebGLProgram,
+                  glVertexShader: WebGLShader,
+                  glFragmentShader: WebGLShader,
+              ) => void)
+            | null;
+        getShaderAsync: (
+            scene: Scene,
+            camera: Camera,
+            object: Object3D,
+        ) => Promise<{ fragmentShader: string | null; vertexShader: string | null }>;
+    };
+
+    localClippingEnabled?: boolean | undefined;
+
     /**
      * Renderer options.
      *
@@ -77,7 +284,7 @@ class Renderer {
 	 * @param {Renderer~Options} [parameters] - The configuration parameter.
 
 	 */
-    constructor(backend, parameters = {}) {
+    constructor(backend: Backend, parameters: RendererParameters = {}) {
         /**
          * This flag can be used for type testing.
          *
@@ -711,12 +918,12 @@ class Renderer {
             getShaderAsync: async (scene, camera, object) => {
                 await this.compileAsync(scene, camera);
 
-                const renderList = this._renderLists.get(scene, camera);
-                const renderContext = this._renderContexts.get(scene, camera, this._renderTarget);
+                const renderList = this._renderLists!.get(scene, camera);
+                const renderContext = this._renderContexts!.get(scene, camera, this._renderTarget);
 
-                const material = scene.overrideMaterial || object.material;
+                const material = scene.overrideMaterial || (object as Mesh<BufferGeometry, Material>).material;
 
-                const renderObject = this._objects.get(
+                const renderObject = this._objects!.get(
                     object,
                     material,
                     scene,
@@ -748,7 +955,7 @@ class Renderer {
             return this._initPromise;
         }
 
-        this._initPromise = new Promise(async (resolve, reject) => {
+        this._initPromise = new Promise<this>(async (resolve, reject) => {
             let backend = this.backend;
 
             try {
@@ -835,14 +1042,14 @@ class Renderer {
      * @param {?Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
      * @return {Promise<Array|undefined>} A Promise that resolves when the compile has been finished.
      */
-    async compileAsync(scene, camera, targetScene = null) {
+    async compileAsync(scene: Object3D, camera: Camera, targetScene: Object3D | null = null) {
         if (this._isDeviceLost === true) return;
 
         if (this._initialized === false) await this.init();
 
         // preserve render tree
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
         const previousRenderContext = this._currentRenderContext;
@@ -851,15 +1058,15 @@ class Renderer {
 
         //
 
-        const sceneRef = scene.isScene === true ? scene : _scene;
+        const sceneRef = (scene as Scene).isScene === true ? (scene as Scene) : _scene;
 
         if (targetScene === null) targetScene = scene;
 
         const renderTarget = this._renderTarget;
-        const renderContext = this._renderContexts.get(targetScene, camera, renderTarget);
+        const renderContext = this._renderContexts!.get(targetScene, camera, renderTarget);
         const activeMipmapLevel = this._activeMipmapLevel;
 
-        const compilationPromises = [];
+        const compilationPromises: Promise<void>[] = [];
 
         this._currentRenderContext = renderContext;
         this._currentRenderObjectFunction = this.renderObject;
@@ -888,7 +1095,7 @@ class Renderer {
 
         //
 
-        const renderList = this._renderLists.get(scene, camera);
+        const renderList = this._renderLists!.get(scene, camera);
         renderList.begin();
 
         this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);
@@ -896,8 +1103,8 @@ class Renderer {
         // include lights from target scene
         if (targetScene !== scene) {
             targetScene.traverseVisible(function (object) {
-                if (object.isLight && object.layers.test(camera.layers)) {
-                    renderList.pushLight(object);
+                if ((object as Light).isLight && object.layers.test(camera.layers)) {
+                    renderList.pushLight(object as Light);
                 }
             });
         }
@@ -907,12 +1114,12 @@ class Renderer {
         //
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
+            this._textures!.updateRenderTarget(renderTarget, activeMipmapLevel);
 
-            const renderTargetData = this._textures.get(renderTarget);
+            const renderTargetData = this._textures!.get(renderTarget);
 
-            renderContext.textures = renderTargetData.textures;
-            renderContext.depthTexture = renderTargetData.depthTexture;
+            renderContext.textures = renderTargetData.textures!;
+            renderContext.depthTexture = renderTargetData.depthTexture!;
         } else {
             renderContext.textures = null;
             renderContext.depthTexture = null;
@@ -920,7 +1127,7 @@ class Renderer {
 
         //
 
-        this._background.update(sceneRef, renderList, renderContext);
+        this._background!.update(sceneRef, renderList, renderContext);
 
         // process render lists
 
@@ -957,7 +1164,7 @@ class Renderer {
      * @param {Camera} camera - The camera.
      * @return {Promise} A Promise that resolves when the render has been finished.
      */
-    async renderAsync(scene, camera) {
+    async renderAsync(scene: Scene, camera: Camera) {
         if (this._initialized === false) await this.init();
 
         this._renderScene(scene, camera);
@@ -980,7 +1187,7 @@ class Renderer {
      * @param {MRTNode} mrt - The MRT node to set.
      * @return {Renderer} A reference to this renderer.
      */
-    setMRT(mrt) {
+    setMRT(mrt: MRTNode | null) {
         this._mrt = mrt;
 
         return this;
@@ -1010,7 +1217,7 @@ class Renderer {
      * @private
      * @param {Object} info - Information about the context lost.
      */
-    _onDeviceLost(info) {
+    _onDeviceLost(info: DeviceLostInfo) {
         let errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\n\nMessage: ${info.message}`;
 
         if (info.reason) {
@@ -1030,14 +1237,14 @@ class Renderer {
      * @param {Scene} sceneRef - The scene the render bundle belongs to.
      * @param {LightsNode} lightsNode - The lights node.
      */
-    _renderBundle(bundle, sceneRef, lightsNode) {
+    _renderBundle(bundle: Bundle, sceneRef: Scene, lightsNode: LightsNode) {
         const { bundleGroup, camera, renderList } = bundle;
 
-        const renderContext = this._currentRenderContext;
+        const renderContext = this._currentRenderContext!;
 
         //
 
-        const renderBundle = this._bundles.get(bundleGroup, camera);
+        const renderBundle = this._bundles!.get(bundleGroup, camera);
         const renderBundleData = this.backend.get(renderBundle);
 
         if (renderBundleData.renderContexts === undefined) renderBundleData.renderContexts = new Set();
@@ -1088,13 +1295,13 @@ class Renderer {
             for (let i = 0, l = renderObjects.length; i < l; i++) {
                 const renderObject = renderObjects[i];
 
-                if (this._nodes.needsRefresh(renderObject)) {
-                    this._nodes.updateBefore(renderObject);
+                if (this._nodes!.needsRefresh(renderObject)) {
+                    this._nodes!.updateBefore(renderObject);
 
-                    this._nodes.updateForRender(renderObject);
-                    this._bindings.updateForRender(renderObject);
+                    this._nodes!.updateForRender(renderObject);
+                    this._bindings!.updateForRender(renderObject);
 
-                    this._nodes.updateAfter(renderObject);
+                    this._nodes!.updateAfter(renderObject);
                 }
             }
         }
@@ -1114,7 +1321,7 @@ class Renderer {
      * @return {?Promise} A Promise that resolve when the scene has been rendered.
      * Only returned when the renderer has not been initialized.
      */
-    render(scene, camera) {
+    render(scene: Scene, camera: Camera) {
         if (this._initialized === false) {
             console.warn(
                 'THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.',
@@ -1189,14 +1396,14 @@ class Renderer {
      * @param {boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.
      * @return {RenderContext} The current render context.
      */
-    _renderScene(scene, camera, useFrameBufferTarget = true) {
+    _renderScene(scene: Scene, camera: Camera, useFrameBufferTarget = true) {
         if (this._isDeviceLost === true) return;
 
         const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;
 
         // preserve render tree
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
         const previousRenderContext = this._currentRenderContext;
@@ -1225,7 +1432,7 @@ class Renderer {
 
         //
 
-        const renderContext = this._renderContexts.get(scene, camera, renderTarget);
+        const renderContext = this._renderContexts!.get(scene, camera, renderTarget);
 
         this._currentRenderContext = renderContext;
         this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;
@@ -1313,7 +1520,7 @@ class Renderer {
             frustum.setFromProjectionMatrix(_projScreenMatrix, coordinateSystem);
         }
 
-        const renderList = this._renderLists.get(scene, camera);
+        const renderList = this._renderLists!.get(scene, camera);
         renderList.begin();
 
         this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);
@@ -1327,14 +1534,14 @@ class Renderer {
         //
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
+            this._textures!.updateRenderTarget(renderTarget, activeMipmapLevel);
 
-            const renderTargetData = this._textures.get(renderTarget);
+            const renderTargetData = this._textures!.get(renderTarget);
 
-            renderContext.textures = renderTargetData.textures;
-            renderContext.depthTexture = renderTargetData.depthTexture;
-            renderContext.width = renderTargetData.width;
-            renderContext.height = renderTargetData.height;
+            renderContext.textures = renderTargetData.textures!;
+            renderContext.depthTexture = renderTargetData.depthTexture!;
+            renderContext.width = renderTargetData.width!;
+            renderContext.height = renderTargetData.height!;
             renderContext.renderTarget = renderTarget;
             renderContext.depth = renderTarget.depthBuffer;
             renderContext.stencil = renderTarget.stencilBuffer;
@@ -1355,7 +1562,7 @@ class Renderer {
 
         //
 
-        this._background.update(sceneRef, renderList, renderContext);
+        this._background!.update(sceneRef, renderList, renderContext);
 
         //
 
@@ -1412,11 +1619,11 @@ class Renderer {
      * @private
      * @param {RenderTarget} renderTarget - The current render target.
      */
-    _renderOutput(renderTarget) {
+    _renderOutput(renderTarget: RenderTarget) {
         const quad = this._quad;
 
-        if (this._nodes.hasOutputChange(renderTarget.texture)) {
-            quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);
+        if (this._nodes!.hasOutputChange(renderTarget!.texture)) {
+            quad.material.fragmentNode = this._nodes!.getOutputNode(renderTarget!.texture);
             quad.material.needsUpdate = true;
         }
 
@@ -1470,10 +1677,10 @@ class Renderer {
      * @param {?Function} callback - The application's animation loop.
      * @return {Promise} A Promise that resolves when the set has been executed.
      */
-    async setAnimationLoop(callback) {
+    async setAnimationLoop(callback: ((time: DOMHighResTimeStamp, frame?: XRFrame) => void) | null) {
         if (this._initialized === false) await this.init();
 
-        this._animation.setAnimationLoop(callback);
+        this._animation!.setAnimationLoop(callback);
     }
 
     /**
@@ -1484,7 +1691,7 @@ class Renderer {
      * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
      * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
      */
-    async getArrayBufferAsync(attribute) {
+    async getArrayBufferAsync(attribute: BufferAttribute) {
         return await this.backend.getArrayBufferAsync(attribute);
     }
 
@@ -1512,7 +1719,7 @@ class Renderer {
      * @param {Vector2} target - The method writes the result in this target object.
      * @return {Vector2} The drawing buffer size.
      */
-    getDrawingBufferSize(target) {
+    getDrawingBufferSize(target: Vector2) {
         return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
     }
 
@@ -1522,7 +1729,7 @@ class Renderer {
      * @param {Vector2} target - The method writes the result in this target object.
      * @return {Vector2} The renderer's size in logical pixels.
      */
-    getSize(target) {
+    getSize(target: Vector2) {
         return target.set(this._width, this._height);
     }
 
@@ -1552,10 +1759,9 @@ class Renderer {
      * @param {number} height - The height in logical pixels.
      * @param {number} pixelRatio - The pixel ratio.
      */
-    setDrawingBufferSize(width, height, pixelRatio) {
+    setDrawingBufferSize(width: number, height: number, pixelRatio: number) {
         // Renderer can't be resized while presenting in XR.
         if (this.xr && this.xr.isPresenting) return;
-
         this._width = width;
         this._height = height;
 
@@ -1576,10 +1782,9 @@ class Renderer {
      * @param {number} height - The height in logical pixels.
      * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
      */
-    setSize(width, height, updateStyle = true) {
+    setSize(width: number, height: number, updateStyle = true) {
         // Renderer can't be resized while presenting in XR.
         if (this.xr && this.xr.isPresenting) return;
-
         this._width = width;
         this._height = height;
 
@@ -1602,7 +1807,7 @@ class Renderer {
      *
      * @param {Function} method - The sort function.
      */
-    setOpaqueSort(method) {
+    setOpaqueSort(method: ((a: RenderItem, b: RenderItem) => number) | null) {
         this._opaqueSort = method;
     }
 
@@ -1612,7 +1817,7 @@ class Renderer {
      *
      * @param {Function} method - The sort function.
      */
-    setTransparentSort(method) {
+    setTransparentSort(method: ((a: RenderItem, b: RenderItem) => number) | null) {
         this._transparentSort = method;
     }
 
@@ -1622,7 +1827,7 @@ class Renderer {
      * @param {Vector4} target - The method writes the result in this target object.
      * @return {Vector4} The scissor rectangle.
      */
-    getScissor(target) {
+    getScissor(target: Vector4) {
         const scissor = this._scissor;
 
         target.x = scissor.x;
@@ -1642,13 +1847,15 @@ class Renderer {
      * @param {number} width - The width of the scissor box in logical pixel unit.
      * @param {number} height - The height of the scissor box in logical pixel unit.
      */
-    setScissor(x, y, width, height) {
+    setScissor(x: Vector4): void;
+    setScissor(x: number, y: number, width: number, height: number): void;
+    setScissor(x: Vector4 | number, y?: number, width?: number, height?: number) {
         const scissor = this._scissor;
 
-        if (x.isVector4) {
-            scissor.copy(x);
+        if ((x as Vector4).isVector4) {
+            scissor.copy(x as Vector4);
         } else {
-            scissor.set(x, y, width, height);
+            scissor.set(x as number, y!, width!, height!);
         }
     }
 
@@ -1666,7 +1873,7 @@ class Renderer {
      *
      * @param {boolean} boolean - Whether the scissor test should be enabled or not.
      */
-    setScissorTest(boolean) {
+    setScissorTest(boolean: boolean) {
         this._scissorTest = boolean;
 
         this.backend.setScissorTest(boolean);
@@ -1678,7 +1885,7 @@ class Renderer {
      * @param {Vector4} target - The method writes the result in this target object.
      * @return {Vector4} The viewport definition.
      */
-    getViewport(target) {
+    getViewport(target: Vector4) {
         return target.copy(this._viewport);
     }
 
@@ -1692,13 +1899,15 @@ class Renderer {
      * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.
      * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.
      */
-    setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {
+    setViewport(x: Vector4): void;
+    setViewport(x: number, y: number, width: number, height: number, minDepth?: number, maxDepth?: number): void;
+    setViewport(x: Vector4 | number, y?: number, width?: number, height?: number, minDepth = 0, maxDepth = 1) {
         const viewport = this._viewport;
 
-        if (x.isVector4) {
-            viewport.copy(x);
+        if ((x as Vector4).isVector4) {
+            viewport.copy(x as Vector4);
         } else {
-            viewport.set(x, y, width, height);
+            viewport.set(x as number, y!, width!, height!);
         }
 
         viewport.minDepth = minDepth;
@@ -1711,7 +1920,7 @@ class Renderer {
      * @param {Color} target - The method writes the result in this target object.
      * @return {Color} The clear color.
      */
-    getClearColor(target) {
+    getClearColor(target: Color4) {
         return target.copy(this._clearColor);
     }
 
@@ -1721,7 +1930,7 @@ class Renderer {
      * @param {Color} color - The clear color.
      * @param {number} [alpha=1] - The clear alpha.
      */
-    setClearColor(color, alpha = 1) {
+    setClearColor(color: ColorRepresentation, alpha = 1) {
         this._clearColor.set(color);
         this._clearColor.a = alpha;
     }
@@ -1740,7 +1949,7 @@ class Renderer {
      *
      * @param {number} alpha - The clear alpha.
      */
-    setClearAlpha(alpha) {
+    setClearAlpha(alpha: number) {
         this._clearColor.a = alpha;
     }
 
@@ -1758,7 +1967,7 @@ class Renderer {
      *
      * @param {number} depth - The clear depth.
      */
-    setClearDepth(depth) {
+    setClearDepth(depth: number) {
         this._clearDepth = depth;
     }
 
@@ -1776,7 +1985,7 @@ class Renderer {
      *
      * @param {number} stencil - The clear stencil.
      */
-    setClearStencil(stencil) {
+    setClearStencil(stencil: number) {
         this._clearStencil = stencil;
     }
 
@@ -1788,7 +1997,7 @@ class Renderer {
      * @param {Object3D} object - The 3D object to test.
      * @return {boolean} Whether the 3D object is fully occluded or not.
      */
-    isOccluded(object) {
+    isOccluded(object: Object3D) {
         const renderContext = this._currentRenderContext;
 
         return renderContext && this.backend.isOccluded(renderContext, object);
@@ -1817,9 +2026,9 @@ class Renderer {
         let renderContext = null;
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget);
+            this._textures!.updateRenderTarget(renderTarget);
 
-            const renderTargetData = this._textures.get(renderTarget);
+            const renderTargetData = this._textures!.get(renderTarget);
 
             renderContext = this._renderContexts.getForClear(renderTarget);
             renderContext.textures = renderTargetData.textures;
@@ -1954,14 +2163,14 @@ class Renderer {
         this.info.dispose();
         this.backend.dispose();
 
-        this._animation.dispose();
-        this._objects.dispose();
-        this._pipelines.dispose();
-        this._nodes.dispose();
-        this._bindings.dispose();
-        this._renderLists.dispose();
-        this._renderContexts.dispose();
-        this._textures.dispose();
+        this._animation!.dispose();
+        this._objects!.dispose();
+        this._pipelines!.dispose();
+        this._nodes!.dispose();
+        this._bindings!.dispose();
+        this._renderLists!.dispose();
+        this._renderContexts!.dispose();
+        this._textures!.dispose();
 
         if (this._frameBufferTarget !== null) this._frameBufferTarget.dispose();
 
@@ -1982,7 +2191,7 @@ class Renderer {
      * @param {number} [activeCubeFace=0] - The active cube face.
      * @param {number} [activeMipmapLevel=0] - The active mipmap level.
      */
-    setRenderTarget(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
+    setRenderTarget(renderTarget: RenderTarget | null, activeCubeFace = 0, activeMipmapLevel = 0) {
         this._renderTarget = renderTarget;
         this._activeCubeFace = activeCubeFace;
         this._activeMipmapLevel = activeMipmapLevel;
@@ -2002,7 +2211,7 @@ class Renderer {
      *
      * @param {Object} renderTarget - The render target to set as the output target.
      */
-    setOutputRenderTarget(renderTarget) {
+    setOutputRenderTarget(renderTarget: RenderTarget | null) {
         this._outputRenderTarget = renderTarget;
     }
 
@@ -2041,7 +2250,19 @@ class Renderer {
      *
      * @param {?renderObjectFunction} renderObjectFunction - The render object function.
      */
-    setRenderObjectFunction(renderObjectFunction) {
+    setRenderObjectFunction(
+        renderObjectFunction:
+            | ((
+                  object: Object3D,
+                  scene: Scene,
+                  camera: Camera,
+                  geometry: BufferGeometry,
+                  material: Material,
+                  group: GeometryGroup,
+                  lightsNode: LightsNode,
+              ) => void)
+            | null,
+    ) {
         this._renderObjectFunction = renderObjectFunction;
     }
 
@@ -2061,7 +2282,7 @@ class Renderer {
      * @param {Node|Array<Node>} computeNodes - The compute node(s).
      * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
      */
-    compute(computeNodes) {
+    compute(computeNodes: ComputeNode | ComputeNode[]) {
         if (this._isDeviceLost === true) return;
 
         if (this._initialized === false) {
@@ -2074,7 +2295,7 @@ class Renderer {
 
         //
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
 
@@ -2089,9 +2310,9 @@ class Renderer {
         //
 
         const backend = this.backend;
-        const pipelines = this._pipelines;
-        const bindings = this._bindings;
-        const nodes = this._nodes;
+        const pipelines = this._pipelines!;
+        const bindings = this._bindings!;
+        const nodes = this._nodes!;
 
         const computeList = Array.isArray(computeNodes) ? computeNodes : [computeNodes];
 
@@ -2147,7 +2368,7 @@ class Renderer {
      * @param {Node|Array<Node>} computeNodes - The compute node(s).
      * @return {Promise} A Promise that resolve when the compute has finished.
      */
-    async computeAsync(computeNodes) {
+    async computeAsync(computeNodes: ComputeNode | ComputeNode[]) {
         if (this._initialized === false) await this.init();
 
         this.compute(computeNodes);
@@ -2160,13 +2381,13 @@ class Renderer {
      * @param {string} name - The feature's name.
      * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
      */
-    async hasFeatureAsync(name) {
+    async hasFeatureAsync(name: string) {
         if (this._initialized === false) await this.init();
 
         return this.backend.hasFeature(name);
     }
 
-    async resolveTimestampsAsync(type = 'render') {
+    async resolveTimestampsAsync(type: TimestampQuery = 'render') {
         if (this._initialized === false) await this.init();
 
         return this.backend.resolveTimestampsAsync(type);
@@ -2179,7 +2400,7 @@ class Renderer {
      * @param {string} name - The feature's name.
      * @return {boolean} Whether the feature is supported or not.
      */
-    hasFeature(name) {
+    hasFeature(name: string) {
         if (this._initialized === false) {
             console.warn(
                 'THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.',
@@ -2208,10 +2429,10 @@ class Renderer {
      * @param {Texture} texture - The texture.
      * @return {Promise} A Promise that resolves when the texture has been initialized.
      */
-    async initTextureAsync(texture) {
+    async initTextureAsync(texture: Texture) {
         if (this._initialized === false) await this.init();
 
-        this._textures.updateTexture(texture);
+        this._textures!.updateTexture(texture);
     }
 
     /**
@@ -2222,14 +2443,14 @@ class Renderer {
      *
      * @param {Texture} texture - The texture.
      */
-    initTexture(texture) {
+    initTexture(texture: Texture) {
         if (this._initialized === false) {
             console.warn(
                 'THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead.',
             );
         }
 
-        this._textures.updateTexture(texture);
+        this._textures!.updateTexture(texture);
     }
 
     /**
@@ -2238,7 +2459,7 @@ class Renderer {
      * @param {FramebufferTexture} framebufferTexture - The texture.
      * @param {?Vector2|Vector4} [rectangle=null] - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.
      */
-    copyFramebufferToTexture(framebufferTexture, rectangle = null) {
+    copyFramebufferToTexture(framebufferTexture: FramebufferTexture, rectangle: Rectangle | null = null) {
         if (rectangle !== null) {
             if (rectangle.isVector2) {
                 rectangle = _vector4
@@ -2289,7 +2510,14 @@ class Renderer {
      * @param {number} [srcLevel=0] - The source mip level to copy from.
      * @param {number} [dstLevel=0] - The destination mip level to copy to.
      */
-    copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
+    copyTextureToTexture(
+        srcTexture: Texture,
+        dstTexture: Texture,
+        srcRegion: Box2 | Box3 | null = null,
+        dstPosition: Vector2 | Vector3 | null = null,
+        srcLevel = 0,
+        dstLevel = 0,
+    ) {
         this._textures.updateTexture(srcTexture);
         this._textures.updateTexture(dstTexture);
 
@@ -2309,7 +2537,15 @@ class Renderer {
      * @param {number} [faceIndex=0] - The active cube face index.
      * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
      */
-    async readRenderTargetPixelsAsync(renderTarget, x, y, width, height, textureIndex = 0, faceIndex = 0) {
+    async readRenderTargetPixelsAsync(
+        renderTarget: RenderTarget,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+        textureIndex = 0,
+        faceIndex = 0,
+    ) {
         return this.backend.copyTextureToBuffer(renderTarget.textures[textureIndex], x, y, width, height, faceIndex);
     }
 
@@ -2323,49 +2559,63 @@ class Renderer {
      * @param {RenderList} renderList - The current render list.
      * @param {ClippingContext} clippingContext - The current clipping context.
      */
-    _projectObject(object, camera, groupOrder, renderList, clippingContext) {
+    _projectObject(
+        object: Object3D,
+        camera: Camera,
+        groupOrder: number,
+        renderList: RenderList,
+        clippingContext: ClippingContext | null,
+    ) {
         if (object.visible === false) return;
 
         const visible = object.layers.test(camera.layers);
 
         if (visible) {
-            if (object.isGroup) {
-                groupOrder = object.renderOrder;
+            if ((object as Group).isGroup) {
+                groupOrder = (object as Group).renderOrder;
 
                 if (object.isClippingGroup && object.enabled) clippingContext = clippingContext.getGroupContext(object);
-            } else if (object.isLOD) {
-                if (object.autoUpdate === true) object.update(camera);
-            } else if (object.isLight) {
-                renderList.pushLight(object);
-            } else if (object.isSprite) {
-                const frustum = camera.isArrayCamera ? _frustumArray : _frustum;
-
-                if (!object.frustumCulled || frustum.intersectsSprite(object, camera)) {
+            } else if ((object as LOD).isLOD) {
+                if ((object as LOD).autoUpdate === true) (object as LOD).update(camera);
+            } else if ((object as Light).isLight) {
+                renderList.pushLight(object as Light);
+            } else if ((object as Sprite).isSprite) {
+                const frustum = (camera as ArrayCamera).isArrayCamera ? _frustumArray : _frustum;
+
+                if (!object.frustumCulled || frustum.intersectsSprite(object as Sprite, camera)) {
                     if (this.sortObjects === true) {
                         _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                     }
 
-                    const { geometry, material } = object;
+                    const { geometry, material } = object as Sprite;
 
                     if (material.visible) {
-                        renderList.push(object, geometry, material, groupOrder, _vector4.z, null, clippingContext);
+                        renderList.push(
+                            object as Sprite,
+                            geometry,
+                            material,
+                            groupOrder,
+                            _vector4.z,
+                            null,
+                            clippingContext,
+                        );
                     }
                 }
-            } else if (object.isLineLoop) {
+            } else if ((object as LineLoop).isLineLoop) {
                 console.error(
                     'THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.',
                 );
-            } else if (object.isMesh || object.isLine || object.isPoints) {
+            } else if ((object as Mesh).isMesh || (object as Line).isLine || (object as Points).isPoints) {
                 const frustum = camera.isArrayCamera ? _frustumArray : _frustum;
 
                 if (!object.frustumCulled || frustum.intersectsObject(object, camera)) {
-                    const { geometry, material } = object;
+                    const { geometry, material } = object as Mesh | Line | Points;
 
                     if (this.sortObjects === true) {
                         if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
 
                         _vector4
-                            .copy(geometry.boundingSphere.center)
+                            .copy(geometry.boundingSphere!.center)
                             .applyMatrix4(object.matrixWorld)
                             .applyMatrix4(_projScreenMatrix);
                     }
@@ -2375,7 +2625,7 @@ class Renderer {
 
                         for (let i = 0, l = groups.length; i < l; i++) {
                             const group = groups[i];
-                            const groupMaterial = material[group.materialIndex];
+                            const groupMaterial = material[group.materialIndex!];
 
                             if (groupMaterial && groupMaterial.visible) {
                                 renderList.push(
@@ -2400,7 +2650,7 @@ class Renderer {
             const baseRenderList = renderList;
 
             // replace render list
-            renderList = this._renderLists.get(object, camera);
+            renderList = this._renderLists!.get(object, camera);
 
             renderList.begin();
 
@@ -2428,7 +2678,7 @@ class Renderer {
      * @param {Scene} sceneRef - The scene the render bundles belong to.
      * @param {LightsNode} lightsNode - The current lights node.
      */
-    _renderBundles(bundles, sceneRef, lightsNode) {
+    _renderBundles(bundles: Bundle[], sceneRef: Scene, lightsNode: LightsNode) {
         for (const bundle of bundles) {
             this._renderBundle(bundle, sceneRef, lightsNode);
         }
@@ -2444,7 +2694,13 @@ class Renderer {
      * @param {Scene} scene - The scene the render list belongs to.
      * @param {LightsNode} lightsNode - The current lights node.
      */
-    _renderTransparents(renderList, doublePassList, camera, scene, lightsNode) {
+    _renderTransparents(
+        renderList: RenderItem[],
+        doublePassList: RenderItem[],
+        camera: Camera,
+        scene: Scene,
+        lightsNode: LightsNode,
+    ) {
         if (doublePassList.length > 0) {
             // render back side
 
@@ -2482,17 +2738,23 @@ class Renderer {
      * @param {LightsNode} lightsNode - The current lights node.
      * @param {?string} [passId=null] - An optional ID for identifying the pass.
      */
-    _renderObjects(renderList, camera, scene, lightsNode, passId = null) {
+    _renderObjects(
+        renderList: RenderItem[],
+        camera: Camera,
+        scene: Scene,
+        lightsNode: LightsNode,
+        passId: string | null = null,
+    ) {
         for (let i = 0, il = renderList.length; i < il; i++) {
             const { object, geometry, material, group, clippingContext } = renderList[i];
 
-            this._currentRenderObjectFunction(
-                object,
+            this._currentRenderObjectFunction!(
+                object!,
                 scene,
                 camera,
-                geometry,
-                material,
-                group,
+                geometry!,
+                material!,
+                group!,
                 lightsNode,
                 clippingContext,
                 passId,
@@ -2514,7 +2776,17 @@ class Renderer {
      * @param {?ClippingContext} clippingContext - The clipping context.
      * @param {?string} [passId=null] - An optional ID for identifying the pass.
      */
-    renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null) {
+    renderObject(
+        object: Object3D,
+        scene: Scene,
+        camera: Camera,
+        geometry: BufferGeometry,
+        material: Material,
+        group: GeometryGroup,
+        lightsNode: LightsNode,
+        clippingContext: ClippingContext | null = null,
+        passId: string | null = null,
+    ) {
         let overridePositionNode;
         let overrideColorNode;
         let overrideDepthNode;
@@ -2601,14 +2873,23 @@ class Renderer {
      * @param {ClippingContext} clippingContext - The clipping context.
      * @param {?string} [passId=null] - An optional ID for identifying the pass.
      */
-    _renderObjectDirect(object, material, scene, camera, lightsNode, group, clippingContext, passId) {
-        const renderObject = this._objects.get(
+    _renderObjectDirect(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: GeometryGroup,
+        clippingContext: ClippingContext | null,
+        passId?: string,
+    ) {
+        const renderObject = this._objects!.get(
             object,
             material,
             scene,
             camera,
             lightsNode,
-            this._currentRenderContext,
+            this._currentRenderContext!,
             clippingContext,
             passId,
         );
@@ -2617,18 +2898,18 @@ class Renderer {
 
         //
 
-        const needsRefresh = this._nodes.needsRefresh(renderObject);
+        const needsRefresh = this._nodes!.needsRefresh(renderObject);
 
         if (needsRefresh) {
-            this._nodes.updateBefore(renderObject);
+            this._nodes!.updateBefore(renderObject);
 
-            this._geometries.updateForRender(renderObject);
+            this._geometries!.updateForRender(renderObject);
 
-            this._nodes.updateForRender(renderObject);
-            this._bindings.updateForRender(renderObject);
+            this._nodes!.updateForRender(renderObject);
+            this._bindings!.updateForRender(renderObject);
         }
 
-        this._pipelines.updateForRender(renderObject);
+        this._pipelines!.updateForRender(renderObject);
 
         //
 
@@ -2642,7 +2923,7 @@ class Renderer {
 
         this.backend.draw(renderObject, this.info);
 
-        if (needsRefresh) this._nodes.updateAfter(renderObject);
+        if (needsRefresh) this._nodes!.updateAfter(renderObject);
     }
 
     /**
@@ -2659,14 +2940,23 @@ class Renderer {
      * @param {ClippingContext} clippingContext - The clipping context.
      * @param {?string} [passId=null] - An optional ID for identifying the pass.
      */
-    _createObjectPipeline(object, material, scene, camera, lightsNode, group, clippingContext, passId) {
-        const renderObject = this._objects.get(
+    _createObjectPipeline(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: Group,
+        clippingContext: ClippingContext | null,
+        passId?: string,
+    ) {
+        const renderObject = this._objects!.get(
             object,
             material,
             scene,
             camera,
             lightsNode,
-            this._currentRenderContext,
+            this._currentRenderContext!,
             clippingContext,
             passId,
         );
@@ -2675,16 +2965,16 @@ class Renderer {
 
         //
 
-        this._nodes.updateBefore(renderObject);
+        this._nodes!.updateBefore(renderObject);
 
-        this._geometries.updateForRender(renderObject);
+        this._geometries!.updateForRender(renderObject);
 
-        this._nodes.updateForRender(renderObject);
-        this._bindings.updateForRender(renderObject);
+        this._nodes!.updateForRender(renderObject);
+        this._bindings!.updateForRender(renderObject);
 
-        this._pipelines.getForRender(renderObject, this._compilationPromises);
+        this._pipelines!.getForRender(renderObject, this._compilationPromises);
 
-        this._nodes.updateAfter(renderObject);
+        this._nodes!.updateAfter(renderObject);
     }
 
     /**
diff --git a/src-testing/src/renderers/common/SampledTexture.ts b/src-testing/src/renderers/common/SampledTexture.ts
index 59359763..2950603b 100644
--- a/src-testing/src/renderers/common/SampledTexture.ts
+++ b/src-testing/src/renderers/common/SampledTexture.ts
@@ -1,4 +1,6 @@
 import Binding from './Binding.js';
+import { Texture } from '../../textures/Texture.js';
+import { VideoTexture } from '../../textures/VideoTexture.js';
 
 let _id = 0;
 
@@ -9,13 +11,22 @@ let _id = 0;
  * @augments Binding
  */
 class SampledTexture extends Binding {
+    id: number;
+
+    texture: Texture;
+    version: number;
+    store: boolean;
+    generation: number | null;
+
+    readonly isSampledTexture: true;
+
     /**
      * Constructs a new sampled texture.
      *
      * @param {string} name - The sampled texture's name.
      * @param {?Texture} texture - The texture this binding is referring to.
      */
-    constructor(name, texture) {
+    constructor(name: string, texture: Texture) {
         super(name);
 
         /**
@@ -73,7 +84,7 @@ class SampledTexture extends Binding {
      * @param {number} generation - The generation.
      * @return {boolean} Whether an update is required or not.
      */
-    needsBindingsUpdate(generation) {
+    needsBindingsUpdate(generation: number) {
         const { texture } = this;
 
         if (generation !== this.generation) {
@@ -82,7 +93,7 @@ class SampledTexture extends Binding {
             return true;
         }
 
-        return texture.isVideoTexture;
+        return (texture as VideoTexture).isVideoTexture;
     }
 
     /**
@@ -111,13 +122,15 @@ class SampledTexture extends Binding {
  * @augments SampledTexture
  */
 class SampledArrayTexture extends SampledTexture {
+    readonly isSampledArrayTexture: true;
+
     /**
      * Constructs a new sampled array texture.
      *
      * @param {string} name - The sampled array texture's name.
      * @param {?(DataArrayTexture|CompressedArrayTexture)} texture - The texture this binding is referring to.
      */
-    constructor(name, texture) {
+    constructor(name: string, texture) {
         super(name, texture);
 
         /**
@@ -138,13 +151,15 @@ class SampledArrayTexture extends SampledTexture {
  * @augments SampledTexture
  */
 class Sampled3DTexture extends SampledTexture {
+    readonly isSampled3DTexture: true;
+
     /**
      * Constructs a new sampled 3D texture.
      *
      * @param {string} name - The sampled 3D texture's name.
      * @param {?Data3DTexture} texture - The texture this binding is referring to.
      */
-    constructor(name, texture) {
+    constructor(name: string, texture) {
         super(name, texture);
 
         /**
@@ -165,13 +180,15 @@ class Sampled3DTexture extends SampledTexture {
  * @augments SampledTexture
  */
 class SampledCubeTexture extends SampledTexture {
+    readonly isSampledCubeTexture: true;
+
     /**
      * Constructs a new sampled cube texture.
      *
      * @param {string} name - The sampled cube texture's name.
      * @param {?(CubeTexture|CompressedCubeTexture)} texture - The texture this binding is referring to.
      */
-    constructor(name, texture) {
+    constructor(name: string, texture) {
         super(name, texture);
 
         /**
diff --git a/src-testing/src/renderers/common/Sampler.ts b/src-testing/src/renderers/common/Sampler.ts
index 2265c6e2..ea252b69 100644
--- a/src-testing/src/renderers/common/Sampler.ts
+++ b/src-testing/src/renderers/common/Sampler.ts
@@ -7,13 +7,19 @@ import Binding from './Binding.js';
  * @augments Binding
  */
 class Sampler extends Binding {
+    // TODO
+    // texture
+    version: number;
+
+    readonly isSampler: true;
+
     /**
      * Constructs a new sampler.
      *
      * @param {string} name - The samplers's name.
      * @param {?Texture} texture - The texture this binding is referring to.
      */
-    constructor(name, texture) {
+    constructor(name: string, texture) {
         super(name);
 
         /**
diff --git a/src-testing/src/renderers/common/StorageBuffer.ts b/src-testing/src/renderers/common/StorageBuffer.ts
index 4b7c259d..96cda7ef 100644
--- a/src-testing/src/renderers/common/StorageBuffer.ts
+++ b/src-testing/src/renderers/common/StorageBuffer.ts
@@ -7,13 +7,18 @@ import Buffer from './Buffer.js';
  * @augments Buffer
  */
 class StorageBuffer extends Buffer {
+    // TODO
+    // attribute
+
+    readonly isStorageBuffer: true;
+
     /**
      * Constructs a new uniform buffer.
      *
      * @param {string} name - The buffer's name.
      * @param {BufferAttribute} attribute - The buffer attribute.
      */
-    constructor(name, attribute) {
+    constructor(name: string, attribute) {
         super(name, attribute ? attribute.array : null);
 
         /**
diff --git a/src-testing/src/renderers/common/Textures.ts b/src-testing/src/renderers/common/Textures.ts
index 7faf61ee..f0ecc3e3 100644
--- a/src-testing/src/renderers/common/Textures.ts
+++ b/src-testing/src/renderers/common/Textures.ts
@@ -10,8 +10,46 @@ import {
     UnsignedInt248Type,
     UnsignedByteType,
 } from '../../constants.js';
+import { Texture } from '../../textures/Texture.js';
+import { RenderTarget } from '../../core/RenderTarget.js';
+import Renderer from './Renderer.js';
+import Backend from './Backend.js';
+import Info from './Info.js';
+import { CubeTexture } from '../../textures/CubeTexture.js';
+import { CompressedTexture } from '../../textures/CompressedTexture.js';
+
+type SizeVector3Unitialized = Vector3 & { width?: number; height?: number; depth?: number };
+type SizeVector3 = Vector3 & { width: number; height: number; depth: number };
+
+const _size: SizeVector3Unitialized = /*@__PURE__*/ new Vector3();
+
+interface RenderTargetData {
+    depthTextureMips?: { [activeMipmapLevel: number]: DepthTexture };
+    width?: number;
+    height?: number;
+    textures?: Texture[];
+    depthTexture?: DepthTexture;
+    depth?: boolean;
+    stencil?: boolean;
+    renderTarget?: RenderTarget;
+    sampleCount?: number;
+    initialized?: boolean;
+}
 
-const _size = /*@__PURE__*/ new Vector3();
+interface TextureData {
+    initialized?: boolean;
+    version?: number;
+    isDefaultTexture?: boolean;
+    generation?: number;
+}
+
+interface TextureOptions {
+    width?: number;
+    height?: number;
+    depth?: number;
+    needsMipmaps?: boolean;
+    levels?: number;
+}
 
 /**
  * This module manages the textures of the renderer.
@@ -19,7 +57,14 @@ const _size = /*@__PURE__*/ new Vector3();
  * @private
  * @augments DataMap
  */
-class Textures extends DataMap {
+class Textures extends DataMap<{
+    renderTarget: { key: RenderTarget; value: RenderTargetData };
+    texture: { key: Texture; value: TextureData };
+}> {
+    renderer: Renderer;
+    backend: Backend;
+    info: Info;
+
     /**
      * Constructs a new texture management component.
      *
@@ -27,7 +72,7 @@ class Textures extends DataMap {
      * @param {Backend} backend - The renderer's backend.
      * @param {Info} info - Renderer component for managing metrics and monitoring data.
      */
-    constructor(renderer, backend, info) {
+    constructor(renderer: Renderer, backend: Backend, info: Info) {
         super();
 
         /**
@@ -59,7 +104,7 @@ class Textures extends DataMap {
      * @param {RenderTarget} renderTarget - The render target to update.
      * @param {number} [activeMipmapLevel=0] - The active mipmap level.
      */
-    updateRenderTarget(renderTarget, activeMipmapLevel = 0) {
+    updateRenderTarget(renderTarget: RenderTarget, activeMipmapLevel = 0) {
         const renderTargetData = this.get(renderTarget);
 
         const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
@@ -176,7 +221,7 @@ class Textures extends DataMap {
      * @param {Texture} texture - The texture to update.
      * @param {Object} [options={}] - The options.
      */
-    updateTexture(texture, options = {}) {
+    updateTexture(texture: Texture, options: TextureOptions = {}) {
         const textureData = this.get(texture);
         if (textureData.initialized === true && textureData.version === texture.version) return;
 
@@ -305,7 +350,7 @@ class Textures extends DataMap {
      * @param {Vector3} target - The target vector.
      * @return {Vector3} The target vector.
      */
-    getSize(texture, target = _size) {
+    getSize(texture: Texture, target = _size) {
         let image = texture.images ? texture.images[0] : texture.image;
 
         if (image) {
@@ -313,12 +358,12 @@ class Textures extends DataMap {
 
             target.width = image.width || 1;
             target.height = image.height || 1;
-            target.depth = texture.isCubeTexture ? 6 : image.depth || 1;
+            target.depth = (texture as CubeTexture).isCubeTexture ? 6 : image.depth || 1;
         } else {
             target.width = target.height = target.depth = 1;
         }
 
-        return target;
+        return target as SizeVector3;
     }
 
     /**
@@ -329,10 +374,10 @@ class Textures extends DataMap {
      * @param {number} height - The texture's height.
      * @return {number} The number of mipmap levels.
      */
-    getMipLevels(texture, width, height) {
+    getMipLevels(texture: Texture, width: number, height: number) {
         let mipLevelCount;
 
-        if (texture.isCompressedTexture) {
+        if ((texture as CompressedTexture).isCompressedTexture) {
             if (texture.mipmaps) {
                 mipLevelCount = texture.mipmaps.length;
             } else {
@@ -351,8 +396,8 @@ class Textures extends DataMap {
      * @param {Texture} texture - The texture.
      * @return {boolean} Whether mipmaps are required or not.
      */
-    needsMipmaps(texture) {
-        return texture.isCompressedTexture === true || texture.generateMipmaps;
+    needsMipmaps(texture: Texture) {
+        return (texture as CompressedTexture).isCompressedTexture === true || texture.generateMipmaps;
     }
 
     /**
@@ -361,7 +406,7 @@ class Textures extends DataMap {
      *
      * @param {Texture} texture - The texture to destroy.
      */
-    _destroyTexture(texture) {
+    _destroyTexture(texture: Texture) {
         this.backend.destroySampler(texture);
         this.backend.destroyTexture(texture);
 
diff --git a/src-testing/src/renderers/common/TimestampQueryPool.ts b/src-testing/src/renderers/common/TimestampQueryPool.ts
index d165f4ef..fc595a83 100644
--- a/src-testing/src/renderers/common/TimestampQueryPool.ts
+++ b/src-testing/src/renderers/common/TimestampQueryPool.ts
@@ -1,9 +1,19 @@
+import RenderContext from './RenderContext.js';
+
 /**
  * Abstract base class of a timestamp query pool.
  *
  * @abstract
  */
-class TimestampQueryPool {
+abstract class TimestampQueryPool {
+    trackTimestamp: boolean;
+    maxQueries: number;
+    currentQueryIndex: number;
+    queryOffsets: Map<number, number>;
+    isDisposed: boolean;
+    lastValue: number;
+    pendingResolve: boolean;
+
     /**
      * Creates a new timestamp query pool.
      *
@@ -73,7 +83,7 @@ class TimestampQueryPool {
      * @param {Object} renderContext - The render context to allocate queries for.
      * @returns {?number}
      */
-    allocateQueriesForContext(/* renderContext */) {}
+    abstract allocateQueriesForContext(renderContext: RenderContext): number | null;
 
     /**
      * Resolve all timestamps and return data (or process them).
@@ -82,14 +92,14 @@ class TimestampQueryPool {
      * @async
      * @returns {Promise<number>|number} The resolved timestamp value.
      */
-    async resolveQueriesAsync() {}
+    abstract resolveQueriesAsync(): Promise<number>;
 
     /**
      * Dispose of the query pool.
      *
      * @abstract
      */
-    dispose() {}
+    abstract dispose(): void;
 }
 
 export default TimestampQueryPool;
diff --git a/src-testing/src/renderers/common/Uniform.ts b/src-testing/src/renderers/common/Uniform.ts
index 0fb25e20..9424984a 100644
--- a/src-testing/src/renderers/common/Uniform.ts
+++ b/src-testing/src/renderers/common/Uniform.ts
@@ -12,14 +12,22 @@ import { Vector4 } from '../../math/Vector4.js';
  * @abstract
  * @private
  */
-class Uniform {
+class Uniform<TValue> {
+    name: string;
+    value: TValue;
+
+    boundary: number;
+    itemSize: number;
+
+    offset: number;
+
     /**
      * Constructs a new uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {any} value - The uniform's value.
      */
-    constructor(name, value) {
+    constructor(name: string, value: TValue) {
         /**
          * The uniform's name.
          *
@@ -65,7 +73,7 @@ class Uniform {
      *
      * @param {any} value - The value to set.
      */
-    setValue(value) {
+    setValue(value: TValue) {
         this.value = value;
     }
 
@@ -85,14 +93,16 @@ class Uniform {
  * @private
  * @augments Uniform
  */
-class NumberUniform extends Uniform {
+class NumberUniform extends Uniform<number> {
+    readonly isNumberUniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {number} value - The uniform's value.
      */
-    constructor(name, value = 0) {
+    constructor(name: string, value = 0) {
         super(name, value);
 
         /**
@@ -115,14 +125,16 @@ class NumberUniform extends Uniform {
  * @private
  * @augments Uniform
  */
-class Vector2Uniform extends Uniform {
+class Vector2Uniform extends Uniform<Vector2> {
+    readonly isVector2Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Vector2} value - The uniform's value.
      */
-    constructor(name, value = new Vector2()) {
+    constructor(name: string, value = new Vector2()) {
         super(name, value);
 
         /**
@@ -145,14 +157,16 @@ class Vector2Uniform extends Uniform {
  * @private
  * @augments Uniform
  */
-class Vector3Uniform extends Uniform {
+class Vector3Uniform extends Uniform<Vector3> {
+    readonly isVector3Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Vector3} value - The uniform's value.
      */
-    constructor(name, value = new Vector3()) {
+    constructor(name: string, value = new Vector3()) {
         super(name, value);
 
         /**
@@ -175,14 +189,16 @@ class Vector3Uniform extends Uniform {
  * @private
  * @augments Uniform
  */
-class Vector4Uniform extends Uniform {
+class Vector4Uniform extends Uniform<Vector4> {
+    readonly isVector4Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Vector4} value - The uniform's value.
      */
-    constructor(name, value = new Vector4()) {
+    constructor(name: string, value = new Vector4()) {
         super(name, value);
 
         /**
@@ -205,14 +221,16 @@ class Vector4Uniform extends Uniform {
  * @private
  * @augments Uniform
  */
-class ColorUniform extends Uniform {
+class ColorUniform extends Uniform<Color> {
+    readonly isColorUniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Color} value - The uniform's value.
      */
-    constructor(name, value = new Color()) {
+    constructor(name: string, value = new Color()) {
         super(name, value);
 
         /**
@@ -235,14 +253,16 @@ class ColorUniform extends Uniform {
  * @private
  * @augments Uniform
  */
-class Matrix2Uniform extends Uniform {
+class Matrix2Uniform extends Uniform<Matrix2> {
+    readonly isMatrix2Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Matrix2} value - The uniform's value.
      */
-    constructor(name, value = new Matrix2()) {
+    constructor(name: string, value = new Matrix2()) {
         super(name, value);
 
         /**
@@ -265,14 +285,16 @@ class Matrix2Uniform extends Uniform {
  * @private
  * @augments Uniform
  */
-class Matrix3Uniform extends Uniform {
+class Matrix3Uniform extends Uniform<Matrix3> {
+    readonly isMatrix3Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Matrix3} value - The uniform's value.
      */
-    constructor(name, value = new Matrix3()) {
+    constructor(name: string, value = new Matrix3()) {
         super(name, value);
 
         /**
@@ -295,14 +317,16 @@ class Matrix3Uniform extends Uniform {
  * @private
  * @augments Uniform
  */
-class Matrix4Uniform extends Uniform {
+class Matrix4Uniform extends Uniform<Matrix4> {
+    readonly isMatrix4Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Matrix4} value - The uniform's value.
      */
-    constructor(name, value = new Matrix4()) {
+    constructor(name: string, value = new Matrix4()) {
         super(name, value);
 
         /**
diff --git a/src-testing/src/renderers/common/UniformBuffer.ts b/src-testing/src/renderers/common/UniformBuffer.ts
index 93c9419f..aa5b6b4b 100644
--- a/src-testing/src/renderers/common/UniformBuffer.ts
+++ b/src-testing/src/renderers/common/UniformBuffer.ts
@@ -7,13 +7,15 @@ import Buffer from './Buffer.js';
  * @augments Buffer
  */
 class UniformBuffer extends Buffer {
+    readonly isUniformBuffer: true;
+
     /**
      * Constructs a new uniform buffer.
      *
      * @param {string} name - The buffer's name.
      * @param {TypedArray} [buffer=null] - The buffer.
      */
-    constructor(name, buffer = null) {
+    constructor(name?: string, buffer = null) {
         super(name, buffer);
 
         /**
diff --git a/src-testing/src/renderers/common/UniformsGroup.ts b/src-testing/src/renderers/common/UniformsGroup.ts
index 93cc042e..5ff6ce79 100644
--- a/src-testing/src/renderers/common/UniformsGroup.ts
+++ b/src-testing/src/renderers/common/UniformsGroup.ts
@@ -1,5 +1,15 @@
 import UniformBuffer from './UniformBuffer.js';
 import { GPU_CHUNK_BYTES } from './Constants.js';
+import {
+    ColorNodeUniform,
+    Matrix3NodeUniform,
+    Matrix4NodeUniform,
+    NodeUniformGPU,
+    NumberNodeUniform,
+    Vector2NodeUniform,
+    Vector3NodeUniform,
+    Vector4NodeUniform,
+} from './nodes/NodeUniform.js';
 
 /**
  * This class represents a uniform buffer binding but with
@@ -9,12 +19,18 @@ import { GPU_CHUNK_BYTES } from './Constants.js';
  * @augments UniformBuffer
  */
 class UniformsGroup extends UniformBuffer {
+    readonly isUniformsGroup: true;
+
+    _values: number[] | null;
+
+    uniforms: NodeUniformGPU[];
+
     /**
      * Constructs a new uniforms group.
      *
      * @param {string} name - The group's name.
      */
-    constructor(name) {
+    constructor(name?: string) {
         super(name);
 
         /**
@@ -51,7 +67,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Uniform} uniform - The uniform to add.
      * @return {UniformsGroup} A reference to this group.
      */
-    addUniform(uniform) {
+    addUniform(uniform: NodeUniformGPU) {
         this.uniforms.push(uniform);
 
         return this;
@@ -63,7 +79,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Uniform} uniform - The uniform to remove.
      * @return {UniformsGroup} A reference to this group.
      */
-    removeUniform(uniform) {
+    removeUniform(uniform: NodeUniformGPU) {
         const index = this.uniforms.indexOf(uniform);
 
         if (index !== -1) {
@@ -91,7 +107,7 @@ class UniformsGroup extends UniformBuffer {
      *
      * @type {Float32Array}
      */
-    get buffer() {
+    get buffer(): Float32Array {
         let buffer = this._buffer;
 
         if (buffer === null) {
@@ -171,14 +187,14 @@ class UniformsGroup extends UniformBuffer {
      * @param {Uniform} uniform - The uniform to update.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateByType(uniform) {
-        if (uniform.isNumberUniform) return this.updateNumber(uniform);
-        if (uniform.isVector2Uniform) return this.updateVector2(uniform);
-        if (uniform.isVector3Uniform) return this.updateVector3(uniform);
-        if (uniform.isVector4Uniform) return this.updateVector4(uniform);
-        if (uniform.isColorUniform) return this.updateColor(uniform);
-        if (uniform.isMatrix3Uniform) return this.updateMatrix3(uniform);
-        if (uniform.isMatrix4Uniform) return this.updateMatrix4(uniform);
+    updateByType(uniform: NodeUniformGPU) {
+        if ((uniform as NumberNodeUniform).isNumberUniform) return this.updateNumber(uniform as NumberNodeUniform);
+        if ((uniform as Vector2NodeUniform).isVector2Uniform) return this.updateVector2(uniform as Vector2NodeUniform);
+        if ((uniform as Vector3NodeUniform).isVector3Uniform) return this.updateVector3(uniform as Vector3NodeUniform);
+        if ((uniform as Vector4NodeUniform).isVector4Uniform) return this.updateVector4(uniform as Vector4NodeUniform);
+        if ((uniform as ColorNodeUniform).isColorUniform) return this.updateColor(uniform as ColorNodeUniform);
+        if ((uniform as Matrix3NodeUniform).isMatrix3Uniform) return this.updateMatrix3(uniform as Matrix3NodeUniform);
+        if ((uniform as Matrix4NodeUniform).isMatrix4Uniform) return this.updateMatrix4(uniform as Matrix4NodeUniform);
 
         console.error('THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform);
     }
@@ -189,7 +205,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {NumberUniform} uniform - The Number uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateNumber(uniform) {
+    updateNumber(uniform: NumberNodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -213,7 +229,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Vector2Uniform} uniform - The Vector2 uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateVector2(uniform) {
+    updateVector2(uniform: Vector2NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -239,7 +255,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Vector3Uniform} uniform - The Vector3 uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateVector3(uniform) {
+    updateVector3(uniform: Vector3NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -266,7 +282,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Vector4Uniform} uniform - The Vector4 uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateVector4(uniform) {
+    updateVector4(uniform: Vector4NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -294,7 +310,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {ColorUniform} uniform - The Color uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateColor(uniform) {
+    updateColor(uniform: ColorNodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -320,7 +336,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Matrix3Uniform} uniform - The Matrix3 uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateMatrix3(uniform) {
+    updateMatrix3(uniform: Matrix3NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -362,7 +378,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Matrix4Uniform} uniform - The Matrix4 uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateMatrix4(uniform) {
+    updateMatrix4(uniform: Matrix4NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -385,7 +401,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {string} type - The data type.
      * @return {TypedArray} The typed array.
      */
-    _getBufferForType(type) {
+    _getBufferForType(type: string | null): Int32Array | Uint32Array | Float32Array {
         if (type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4')
             return new Int32Array(this.buffer.buffer);
         if (type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4')
@@ -402,7 +418,7 @@ class UniformsGroup extends UniformBuffer {
  * @param {TypedArray} b - The second array.
  * @param {number} offset - An index offset for the first array.
  */
-function setArray(a, b, offset) {
+function setArray(a: number[], b: number[], offset: number) {
     for (let i = 0, l = b.length; i < l; i++) {
         a[offset + i] = b[i];
     }
@@ -417,7 +433,7 @@ function setArray(a, b, offset) {
  * @param {number} offset - An index offset for the first array.
  * @return {boolean} Whether the given arrays are equal or not.
  */
-function arraysEqual(a, b, offset) {
+function arraysEqual(a: number[], b: number[], offset: number) {
     for (let i = 0, l = b.length; i < l; i++) {
         if (a[offset + i] !== b[i]) return false;
     }
diff --git a/src-testing/src/renderers/common/XRManager.ts b/src-testing/src/renderers/common/XRManager.ts
index b93a07f2..cd59a472 100644
--- a/src-testing/src/renderers/common/XRManager.ts
+++ b/src-testing/src/renderers/common/XRManager.ts
@@ -27,10 +27,60 @@ import { CylinderGeometry } from '../../geometries/CylinderGeometry.js';
 import { PlaneGeometry } from '../../geometries/PlaneGeometry.js';
 import { MeshBasicMaterial } from '../../materials/MeshBasicMaterial.js';
 import { Mesh } from '../../objects/Mesh.js';
+import Renderer from './Renderer.js';
+import { AnimationContext } from './Animation.js';
+import { Camera } from '../../cameras/Camera.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Material } from '../../materials/Material.js';
 
 const _cameraLPos = /*@__PURE__*/ new Vector3();
 const _cameraRPos = /*@__PURE__*/ new Vector3();
 
+export interface XRManagerEventMap {
+    sessionstart: {};
+    sessionend: {};
+    planesdetected: { data: XRFrame };
+}
+
+export interface XRQuadLayerObject {
+    type: 'quad';
+    width: number;
+    height: number;
+    translation: Vector3;
+    quaternion: Quaternion;
+    pixelwidth: number;
+    pixelheight: number;
+    plane: Mesh;
+    material: Material;
+    rendercall: () => void;
+    renderTarget: XRRenderTarget;
+
+    xrlayer?: XRLayer;
+}
+
+export interface XRCylinderLayerObject {
+    type: 'cylinder';
+    radius: number;
+    centralAngle: number;
+    aspectratio: number;
+    translation: Vector3;
+    quaternion: Quaternion;
+    pixelwidth: number;
+    pixelheight: number;
+    plane: Mesh;
+    material: Material;
+    rendercall: () => void;
+    renderTarget: XRRenderTarget;
+
+    xrlayer?: XRLayer;
+}
+
+export type XRLayerObject = XRQuadLayerObject | XRCylinderLayerObject;
+
+export interface LayerAttributes {
+    stencil?: boolean | undefined;
+}
+
 /**
  * The XR manager is built on top of the WebXR Device API to
  * manage XR sessions with `WebGPURenderer`.
@@ -39,14 +89,90 @@ const _cameraRPos = /*@__PURE__*/ new Vector3();
  *
  * @augments EventDispatcher
  */
-class XRManager extends EventDispatcher {
+class XRManager extends EventDispatcher<XRManagerEventMap> {
+    enabled: boolean;
+
+    isPresenting: boolean;
+
+    cameraAutoUpdate: boolean;
+
+    _renderer: Renderer;
+
+    _cameraL: PerspectiveCamera;
+
+    _cameraR: PerspectiveCamera;
+
+    _cameras: PerspectiveCamera[];
+
+    _cameraXR: ArrayCamera;
+
+    _currentDepthNear: number | null;
+
+    _currentDepthFar: number | null;
+
+    _controllers: WebXRController[];
+
+    _controllerInputSources: (XRInputSource | null)[];
+
+    _xrRenderTarget: XRRenderTarget | null;
+
+    _layers: XRLayerObject[];
+
+    _supportsLayers: boolean;
+
+    _createXRLayer: (layer: XRLayerObject) => XRLayer;
+
+    _gl: WebGL2RenderingContext | null;
+
+    _currentAnimationContext: AnimationContext | null;
+
+    _currentAnimationLoop: ((time: DOMHighResTimeStamp, frame?: XRFrame) => void) | null;
+
+    _currentPixelRatio: number | null;
+
+    _currentSize: Vector2;
+
+    _onSessionEvent: (event: XRInputSourceEvent) => void;
+
+    _onSessionEnd: () => void;
+
+    _onInputSourcesChange: (event: XRInputSourcesChangeEvent) => void;
+
+    _onAnimationFrame: (time: DOMHighResTimeStamp, frame?: XRFrame) => void;
+
+    _referenceSpace: XRReferenceSpace | null;
+
+    _referenceSpaceType: XRReferenceSpaceType;
+
+    _customReferenceSpace: XRReferenceSpace | null;
+
+    _framebufferScaleFactor: number;
+
+    _foveation: number;
+
+    _session: XRSession | null;
+
+    _glBaseLayer: XRWebGLLayer | null;
+
+    _glBinding: XRWebGLBinding | null;
+
+    _glProjLayer: XRProjectionLayer | null;
+
+    _xrFrame: XRFrame | null;
+
+    _useLayers: boolean;
+
+    _useMultiviewIfPossible: boolean;
+
+    _useMultiview: boolean;
+
     /**
      * Constructs a new XR manager.
      *
      * @param {Renderer} renderer - The renderer.
      * @param {boolean} [multiview=false] - Enables multiview if the device supports it.
      */
-    constructor(renderer, multiview = false) {
+    constructor(renderer: Renderer, multiview = false) {
         super();
 
         /**
@@ -395,7 +521,7 @@ class XRManager extends EventDispatcher {
      * @param {number} index - The index of the XR controller.
      * @return {Group} A group that represents the controller's transformation.
      */
-    getController(index) {
+    getController(index: number) {
         const controller = this._getController(index);
 
         return controller.getTargetRaySpace();
@@ -409,7 +535,7 @@ class XRManager extends EventDispatcher {
      * @param {number} index - The index of the XR controller.
      * @return {Group} A group that represents the controller's transformation.
      */
-    getControllerGrip(index) {
+    getControllerGrip(index: number) {
         const controller = this._getController(index);
 
         return controller.getGripSpace();
@@ -423,7 +549,7 @@ class XRManager extends EventDispatcher {
      * @param {number} index - The index of the XR controller.
      * @return {Group} A group that represents the controller's transformation.
      */
-    getHand(index) {
+    getHand(index: number) {
         const controller = this._getController(index);
 
         return controller.getHandSpace();
@@ -448,7 +574,7 @@ class XRManager extends EventDispatcher {
      * @param {number} foveation - A number in the range `[0,1]` where `0` means no foveation (full resolution)
      * and `1` means maximum foveation (the edges render at lower resolution).
      */
-    setFoveation(foveation) {
+    setFoveation(foveation: number) {
         this._foveation = foveation;
 
         if (this._glProjLayer !== null) {
@@ -476,7 +602,7 @@ class XRManager extends EventDispatcher {
      *
      * @param {number} factor - The framebuffer scale factor.
      */
-    setFramebufferScaleFactor(factor) {
+    setFramebufferScaleFactor(factor: number) {
         this._framebufferScaleFactor = factor;
 
         if (this.isPresenting === true) {
@@ -500,7 +626,7 @@ class XRManager extends EventDispatcher {
      *
      * @param {XRReferenceSpaceType} type - The reference space type.
      */
-    setReferenceSpaceType(type) {
+    setReferenceSpaceType(type: XRReferenceSpaceType) {
         this._referenceSpaceType = type;
 
         if (this.isPresenting === true) {
@@ -522,7 +648,7 @@ class XRManager extends EventDispatcher {
      *
      * @param {XRReferenceSpace} space - The XR reference space.
      */
-    setReferenceSpace(space) {
+    setReferenceSpace(space: XRReferenceSpace) {
         this._customReferenceSpace = space;
     }
 
@@ -564,7 +690,16 @@ class XRManager extends EventDispatcher {
         return this._useMultiview;
     }
 
-    createQuadLayer(width, height, translation, quaternion, pixelwidth, pixelheight, rendercall, attributes = []) {
+    createQuadLayer(
+        width: number,
+        height: number,
+        translation: Vector3,
+        quaternion: Quaternion,
+        pixelwidth: number,
+        pixelheight: number,
+        rendercall: () => void,
+        attributes: LayerAttributes = {},
+    ) {
         const geometry = new PlaneGeometry(width, height);
         const renderTarget = new XRRenderTarget(pixelwidth, pixelheight, {
             format: RGBAFormat,
@@ -594,7 +729,7 @@ class XRManager extends EventDispatcher {
         plane.position.copy(translation);
         plane.quaternion.copy(quaternion);
 
-        const layer = {
+        const layer: XRQuadLayerObject = {
             type: 'quad',
             width: width,
             height: height,
@@ -619,7 +754,7 @@ class XRManager extends EventDispatcher {
 
             layer.xrlayer = this._createXRLayer(layer);
 
-            const xrlayers = this._session.renderState.layers;
+            const xrlayers = this._session.renderState.layers!;
             xrlayers.unshift(layer.xrlayer);
             this._session.updateRenderState({ layers: xrlayers });
         } else {
@@ -630,15 +765,15 @@ class XRManager extends EventDispatcher {
     }
 
     createCylinderLayer(
-        radius,
-        centralAngle,
-        aspectratio,
-        translation,
-        quaternion,
-        pixelwidth,
-        pixelheight,
-        rendercall,
-        attributes = [],
+        radius: number,
+        centralAngle: number,
+        aspectratio: number,
+        translation: Vector3,
+        quaternion: Quaternion,
+        pixelwidth: number,
+        pixelheight: number,
+        rendercall: () => void,
+        attributes: LayerAttributes = {},
     ) {
         const geometry = new CylinderGeometry(
             radius,
@@ -678,7 +813,7 @@ class XRManager extends EventDispatcher {
         plane.position.copy(translation);
         plane.quaternion.copy(quaternion);
 
-        const layer = {
+        const layer: XRCylinderLayerObject = {
             type: 'cylinder',
             radius: radius,
             centralAngle: centralAngle,
@@ -704,7 +839,7 @@ class XRManager extends EventDispatcher {
 
             layer.xrlayer = this._createXRLayer(layer);
 
-            const xrlayers = this._session.renderState.layers;
+            const xrlayers = this._session.renderState.layers!;
             xrlayers.unshift(layer.xrlayer);
             this._session.updateRenderState({ layers: xrlayers });
         } else {
@@ -732,7 +867,7 @@ class XRManager extends EventDispatcher {
                     layer.plane.getWorldQuaternion(quaternionObject),
                 );
 
-                const glSubImage = this._glBinding.getSubImage(layer.xrlayer, this._xrFrame);
+                const glSubImage = this._glBinding!.getSubImage(layer.xrlayer, this._xrFrame!);
                 this._renderer.backend.setXRRenderTargetTextures(
                     layer.renderTarget,
                     glSubImage.colorTexture,
@@ -766,7 +901,7 @@ class XRManager extends EventDispatcher {
      * @param {XRSession} session - The XR session to set.
      * @return {Promise} A Promise that resolves when the session has been set.
      */
-    async setSession(session) {
+    async setSession(session: XRSession) {
         const renderer = this._renderer;
         const backend = renderer.backend;
 
@@ -796,9 +931,9 @@ class XRManager extends EventDispatcher {
             this._currentPixelRatio = renderer.getPixelRatio();
             renderer.getSize(this._currentSize);
 
-            this._currentAnimationContext = renderer._animation.getContext();
-            this._currentAnimationLoop = renderer._animation.getAnimationLoop();
-            renderer._animation.stop();
+            this._currentAnimationContext = renderer._animation!.getContext();
+            this._currentAnimationLoop = renderer._animation!.getAnimationLoop();
+            renderer._animation!.stop();
 
             //
 
@@ -929,11 +1064,11 @@ class XRManager extends EventDispatcher {
 
             //
 
-            this.setFoveation(this.getFoveation());
+            this.setFoveation(this.getFoveation()!);
 
-            renderer._animation.setAnimationLoop(this._onAnimationFrame);
-            renderer._animation.setContext(session);
-            renderer._animation.start();
+            renderer._animation!.setAnimationLoop(this._onAnimationFrame);
+            renderer._animation!.setContext(session);
+            renderer._animation!.start();
 
             this.isPresenting = true;
 
@@ -948,7 +1083,7 @@ class XRManager extends EventDispatcher {
      *
      * @param {PerspectiveCamera} camera - The camera.
      */
-    updateCamera(camera) {
+    updateCamera(camera: PerspectiveCamera) {
         const session = this._session;
 
         if (session === null) return;
@@ -980,7 +1115,7 @@ class XRManager extends EventDispatcher {
         cameraR.layers.mask = camera.layers.mask | 0b100;
         cameraXR.layers.mask = cameraL.layers.mask | cameraR.layers.mask;
 
-        const parent = camera.parent;
+        const parent = camera.parent!;
         const cameras = cameraXR.cameras;
 
         updateCamera(cameraXR, parent);
@@ -1011,7 +1146,7 @@ class XRManager extends EventDispatcher {
      * @param {number} index - The controller index.
      * @return {WebXRController} The XR controller.
      */
-    _getController(index) {
+    _getController(index: number) {
         let controller = this._controllers[index];
 
         if (controller === undefined) {
@@ -1033,7 +1168,7 @@ class XRManager extends EventDispatcher {
  * @param {PerspectiveCamera} cameraL - The left camera.
  * @param {PerspectiveCamera} cameraR - The right camera.
  */
-function setProjectionFromUnion(camera, cameraL, cameraR) {
+function setProjectionFromUnion(camera: ArrayCamera, cameraL: PerspectiveCamera, cameraR: PerspectiveCamera) {
     _cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
     _cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
 
@@ -1097,7 +1232,7 @@ function setProjectionFromUnion(camera, cameraL, cameraR) {
  * @param {Camera} camera - The camera to update.
  * @param {Object3D} parent - The parent 3D object.
  */
-function updateCamera(camera, parent) {
+function updateCamera(camera: Camera, parent: Object3D) {
     if (parent === null) {
         camera.matrixWorld.copy(camera.matrix);
     } else {
@@ -1115,7 +1250,7 @@ function updateCamera(camera, parent) {
  * @param {ArrayCamera} cameraXR - The XR camera.
  * @param {Object3D} parent - The parent 3D object.
  */
-function updateUserCamera(camera, cameraXR, parent) {
+function updateUserCamera(camera: Camera, cameraXR: ArrayCamera, parent: Object3D) {
     if (parent === null) {
         camera.matrix.copy(cameraXR.matrixWorld);
     } else {
@@ -1130,13 +1265,14 @@ function updateUserCamera(camera, cameraXR, parent) {
     camera.projectionMatrix.copy(cameraXR.projectionMatrix);
     camera.projectionMatrixInverse.copy(cameraXR.projectionMatrixInverse);
 
-    if (camera.isPerspectiveCamera) {
-        camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
-        camera.zoom = 1;
+    if ((camera as PerspectiveCamera).isPerspectiveCamera) {
+        (camera as PerspectiveCamera).fov =
+            RAD2DEG * 2 * Math.atan(1 / (camera as PerspectiveCamera).projectionMatrix.elements[5]);
+        (camera as PerspectiveCamera).zoom = 1;
     }
 }
 
-function onSessionEvent(event) {
+function onSessionEvent(this: XRManager, event: XRInputSourceEvent) {
     const controllerIndex = this._controllerInputSources.indexOf(event.inputSource);
 
     if (controllerIndex === -1) {
@@ -1146,15 +1282,15 @@ function onSessionEvent(event) {
     const controller = this._controllers[controllerIndex];
 
     if (controller !== undefined) {
-        const referenceSpace = this.getReferenceSpace();
+        const referenceSpace = this.getReferenceSpace()!;
 
         controller.update(event.inputSource, event.frame, referenceSpace);
         controller.dispatchEvent({ type: event.type, data: event.inputSource });
     }
 }
 
-function onSessionEnd() {
-    const session = this._session;
+function onSessionEnd(this: XRManager) {
+    const session = this._session!;
     const renderer = this._renderer;
 
     session.removeEventListener('select', this._onSessionEvent);
@@ -1225,19 +1361,19 @@ function onSessionEnd() {
     this.isPresenting = false;
     this._useMultiview = false;
 
-    renderer._animation.stop();
+    renderer._animation!.stop();
 
-    renderer._animation.setAnimationLoop(this._currentAnimationLoop);
-    renderer._animation.setContext(this._currentAnimationContext);
-    renderer._animation.start();
+    renderer._animation!.setAnimationLoop(this._currentAnimationLoop);
+    renderer._animation!.setContext(this._currentAnimationContext!);
+    renderer._animation!.start();
 
-    renderer.setPixelRatio(this._currentPixelRatio);
+    renderer.setPixelRatio(this._currentPixelRatio!);
     renderer.setSize(this._currentSize.width, this._currentSize.height, false);
 
     this.dispatchEvent({ type: 'sessionend' });
 }
 
-function onInputSourcesChange(event) {
+function onInputSourcesChange(this: XRManager, event: XRInputSourcesChangeEvent) {
     const controllers = this._controllers;
     const controllerInputSources = this._controllerInputSources;
 
@@ -1289,25 +1425,25 @@ function onInputSourcesChange(event) {
 }
 
 // Creation method for native WebXR layers
-function createXRLayer(layer) {
+function createXRLayer(this: XRManager, layer: XRLayerObject) {
     if (layer.type === 'quad') {
-        return this._glBinding.createQuadLayer({
+        return this._glBinding!.createQuadLayer({
             transform: new XRRigidTransform(layer.translation, layer.quaternion),
-            depthFormat: this._gl.DEPTH_COMPONENT,
+            depthFormat: this._gl!.DEPTH_COMPONENT,
             width: layer.width / 2,
             height: layer.height / 2,
-            space: this._referenceSpace,
+            space: this._referenceSpace!,
             viewPixelWidth: layer.pixelwidth,
             viewPixelHeight: layer.pixelheight,
         });
     } else {
-        return this._glBinding.createCylinderLayer({
+        return this._glBinding!.createCylinderLayer({
             transform: new XRRigidTransform(layer.translation, layer.quaternion),
-            depthFormat: this._gl.DEPTH_COMPONENT,
+            depthFormat: this._gl!.DEPTH_COMPONENT,
             radius: layer.radius,
             centralAngle: layer.centralAngle,
             aspectRatio: layer.aspectRatio,
-            space: this._referenceSpace,
+            space: this._referenceSpace!,
             viewPixelWidth: layer.pixelwidth,
             viewPixelHeight: layer.pixelheight,
         });
@@ -1316,7 +1452,7 @@ function createXRLayer(layer) {
 
 // Animation Loop
 
-function onAnimationFrame(time, frame) {
+function onAnimationFrame(this: XRManager, time: DOMHighResTimeStamp, frame?: XRFrame) {
     if (frame === undefined) return;
 
     const cameraXR = this._cameraXR;
@@ -1325,16 +1461,16 @@ function onAnimationFrame(time, frame) {
 
     const glBaseLayer = this._glBaseLayer;
 
-    const referenceSpace = this.getReferenceSpace();
+    const referenceSpace = this.getReferenceSpace()!;
     const pose = frame.getViewerPose(referenceSpace);
 
     this._xrFrame = frame;
 
     if (pose !== null) {
-        const views = pose.views;
+        const views = pose!.views;
 
         if (this._glBaseLayer !== null) {
-            backend.setXRTarget(glBaseLayer.framebuffer);
+            backend.setXRTarget(glBaseLayer!.framebuffer);
         }
 
         let cameraXRNeedsUpdate = false;
@@ -1352,7 +1488,7 @@ function onAnimationFrame(time, frame) {
             let viewport;
 
             if (this._useLayers === true) {
-                const glSubImage = this._glBinding.getViewSubImage(this._glProjLayer, view);
+                const glSubImage = this._glBinding!.getViewSubImage(this._glProjLayer!, view);
                 viewport = glSubImage.viewport;
 
                 // For side-by-side projection, we only produce a single texture for both eyes.
@@ -1360,13 +1496,13 @@ function onAnimationFrame(time, frame) {
                     backend.setXRRenderTargetTextures(
                         this._xrRenderTarget,
                         glSubImage.colorTexture,
-                        this._glProjLayer.ignoreDepthValues && !this._useMultiview
+                        this._glProjLayer!.ignoreDepthValues && !this._useMultiview
                             ? undefined
                             : glSubImage.depthStencilTexture,
                     );
                 }
             } else {
-                viewport = glBaseLayer.getViewport(view);
+                viewport = glBaseLayer!.getViewport(view)!;
             }
 
             let camera = this._cameras[i];
@@ -1382,7 +1518,7 @@ function onAnimationFrame(time, frame) {
             camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
             camera.projectionMatrix.fromArray(view.projectionMatrix);
             camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
-            camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
+            camera.viewport!.set(viewport.x, viewport.y, viewport.width, viewport.height);
 
             if (i === 0) {
                 cameraXR.matrix.copy(camera.matrix);
diff --git a/src-testing/src/renderers/common/XRRenderTarget.ts b/src-testing/src/renderers/common/XRRenderTarget.ts
index 95fac673..d104ced9 100644
--- a/src-testing/src/renderers/common/XRRenderTarget.ts
+++ b/src-testing/src/renderers/common/XRRenderTarget.ts
@@ -1,4 +1,4 @@
-import { RenderTarget } from '../../core/RenderTarget.js';
+import { RenderTarget, RenderTargetOptions } from '../../core/RenderTarget.js';
 
 /**
  * A special type of render target that is used when rendering
@@ -8,6 +8,12 @@ import { RenderTarget } from '../../core/RenderTarget.js';
  * @augments RenderTarget
  */
 class XRRenderTarget extends RenderTarget {
+    readonly isXRRenderTarget: true;
+
+    hasExternalTextures: boolean;
+
+    autoAllocateDepthBuffer: boolean;
+
     /**
      * Constructs a new XR render target.
      *
@@ -15,7 +21,7 @@ class XRRenderTarget extends RenderTarget {
      * @param {number} [height=1] - The height of the render target.
      * @param {Object} [options={}] - The configuration options.
      */
-    constructor(width = 1, height = 1, options = {}) {
+    constructor(width = 1, height = 1, options: RenderTargetOptions = {}) {
         super(width, height, options);
 
         /**
@@ -54,7 +60,7 @@ class XRRenderTarget extends RenderTarget {
         this.autoAllocateDepthBuffer = true;
     }
 
-    copy(source) {
+    copy(source: XRRenderTarget) {
         super.copy(source);
 
         this.hasExternalTextures = source.hasExternalTextures;
diff --git a/src-testing/src/renderers/common/nodes/NodeBuilderState.ts b/src-testing/src/renderers/common/nodes/NodeBuilderState.ts
index 42d80e47..a0e8c024 100644
--- a/src-testing/src/renderers/common/nodes/NodeBuilderState.ts
+++ b/src-testing/src/renderers/common/nodes/NodeBuilderState.ts
@@ -1,4 +1,8 @@
 import BindGroup from '../BindGroup.js';
+import NodeAttribute from '../../../nodes/core/NodeAttribute.js';
+import Node from '../../../nodes/core/Node.js';
+import NodeUniformsGroup from './NodeUniformsGroup.js';
+import NodeMaterialObserver from '../../../materials/nodes/manager/NodeMaterialObserver.js';
 
 /**
  * This module represents the state of a node builder after it was
@@ -10,6 +14,22 @@ import BindGroup from '../BindGroup.js';
  * @private
  */
 class NodeBuilderState {
+    vertexShader: string | null;
+    fragmentShader: string | null;
+    computeShader: string | null;
+    transforms: never[];
+
+    nodeAttributes: NodeAttribute[];
+    bindings: BindGroup[];
+
+    updateNodes: Node[];
+    updateBeforeNodes: Node[];
+    updateAfterNodes: Node[];
+
+    observer: NodeMaterialObserver;
+
+    usedTimes: number;
+
     /**
      * Constructs a new node builder state.
      *
@@ -25,16 +45,16 @@ class NodeBuilderState {
      * @param {Array<Object>} transforms - An array with transform attribute objects. Only relevant when using compute shaders with WebGL 2.
      */
     constructor(
-        vertexShader,
-        fragmentShader,
-        computeShader,
-        nodeAttributes,
-        bindings,
-        updateNodes,
-        updateBeforeNodes,
-        updateAfterNodes,
-        observer,
-        transforms = [],
+        vertexShader: string | null,
+        fragmentShader: string | null,
+        computeShader: string | null,
+        nodeAttributes: NodeAttribute[],
+        bindings: BindGroup[],
+        updateNodes: Node[],
+        updateBeforeNodes: Node[],
+        updateAfterNodes: Node[],
+        observer: NodeMaterialObserver,
+        transforms: never[] = [],
     ) {
         /**
          * The native vertex shader code.
@@ -128,14 +148,14 @@ class NodeBuilderState {
         const bindings = [];
 
         for (const instanceGroup of this.bindings) {
-            const shared = instanceGroup.bindings[0].groupNode.shared; // All bindings in the group must have the same groupNode.
+            const shared = (instanceGroup.bindings[0] as NodeUniformsGroup).groupNode.shared; // All bindings in the group must have the same groupNode.
 
             if (shared !== true) {
                 const bindingsGroup = new BindGroup(instanceGroup.name, [], instanceGroup.index, instanceGroup);
                 bindings.push(bindingsGroup);
 
                 for (const instanceBinding of instanceGroup.bindings) {
-                    bindingsGroup.bindings.push(instanceBinding.clone());
+                    bindingsGroup.bindings.push((instanceBinding as NodeUniformsGroup).clone());
                 }
             } else {
                 bindings.push(instanceGroup);
diff --git a/src-testing/src/renderers/common/nodes/NodeLibrary.ts b/src-testing/src/renderers/common/nodes/NodeLibrary.ts
index a08726f3..1563b212 100644
--- a/src-testing/src/renderers/common/nodes/NodeLibrary.ts
+++ b/src-testing/src/renderers/common/nodes/NodeLibrary.ts
@@ -1,3 +1,12 @@
+import { Material } from '../../../materials/Material.js';
+import NodeMaterial from '../../../materials/nodes/NodeMaterial.js';
+import { ToneMapping } from '../../../constants.js';
+import { NodeRepresentation, ShaderNodeObject } from '../../../nodes/tsl/TSLCore.js';
+import Node from '../../../nodes/core/Node.js';
+import { Light } from '../../../lights/Light.js';
+import AnalyticLightNode from '../../../nodes/lighting/AnalyticLightNode.js';
+import { ColorSpaceMethod } from '../../../nodes/display/ColorSpaceNode.js';
+
 /**
  * The purpose of a node library is to assign node implementations
  * to existing library features. In `WebGPURenderer` lights, materials
@@ -7,6 +16,13 @@
  * @private
  */
 class NodeLibrary {
+    lightNodes: WeakMap<{ new (): Light }, { new (light: Light): AnalyticLightNode<Light> }>;
+    materialNodes: Map<string, { new (): NodeMaterial }>;
+    toneMappingNodes: Map<
+        ToneMapping,
+        (color: NodeRepresentation, exposure: NodeRepresentation) => ShaderNodeObject<Node>
+    >;
+
     /**
      * Constructs a new node library.
      */
@@ -44,8 +60,8 @@ class NodeLibrary {
      * @param {Material} material - A material.
      * @return {NodeMaterial} The corresponding node material.
      */
-    fromMaterial(material) {
-        if (material.isNodeMaterial) return material;
+    fromMaterial(material: Material) {
+        if ((material as NodeMaterial).isNodeMaterial) return material;
 
         let nodeMaterial = null;
 
@@ -68,7 +84,10 @@ class NodeLibrary {
      * @param {Function} toneMappingNode - The tone mapping node function.
      * @param {number} toneMapping - The tone mapping.
      */
-    addToneMapping(toneMappingNode, toneMapping) {
+    addToneMapping(
+        toneMappingNode: (color: NodeRepresentation, exposure: NodeRepresentation) => ShaderNodeObject<Node>,
+        toneMapping: ToneMapping,
+    ) {
         this.addType(toneMappingNode, toneMapping, this.toneMappingNodes);
     }
 
@@ -78,7 +97,7 @@ class NodeLibrary {
      * @param {number} toneMapping - The tone mapping.
      * @return {?Function} The tone mapping node function. Returns `null` if no node function is found.
      */
-    getToneMappingFunction(toneMapping) {
+    getToneMappingFunction(toneMapping: ToneMapping) {
         return this.toneMappingNodes.get(toneMapping) || null;
     }
 
@@ -88,7 +107,7 @@ class NodeLibrary {
      * @param {string} materialType - The material type.
      * @return {?NodeMaterial.constructor} The node material class definition. Returns `null` if no node material is found.
      */
-    getMaterialNodeClass(materialType) {
+    getMaterialNodeClass(materialType: string) {
         return this.materialNodes.get(materialType) || null;
     }
 
@@ -98,7 +117,7 @@ class NodeLibrary {
      * @param {NodeMaterial.constructor} materialNodeClass - The node material class definition.
      * @param {string} materialClassType - The material type.
      */
-    addMaterial(materialNodeClass, materialClassType) {
+    addMaterial(materialNodeClass: { new (): NodeMaterial }, materialClassType: string) {
         this.addType(materialNodeClass, materialClassType, this.materialNodes);
     }
 
@@ -108,7 +127,7 @@ class NodeLibrary {
      * @param {Light.constructor} light - The light class definition.
      * @return {?AnalyticLightNode.constructor} The light node class definition. Returns `null` if no light node is found.
      */
-    getLightNodeClass(light) {
+    getLightNodeClass(light: Light) {
         return this.lightNodes.get(light) || null;
     }
 
@@ -118,8 +137,18 @@ class NodeLibrary {
      * @param {AnalyticLightNode.constructor} lightNodeClass - The light node class definition.
      * @param {Light.constructor} lightClass - The light class definition.
      */
-    addLight(lightNodeClass, lightClass) {
-        this.addClass(lightNodeClass, lightClass, this.lightNodes);
+    addLight<TLight extends Light>(
+        lightNodeClass: { new (light: TLight): AnalyticLightNode<TLight> },
+        lightClass: { new (): TLight },
+    ) {
+        this.addClass(
+            lightNodeClass,
+            lightClass,
+            this.lightNodes as unknown as WeakMap<
+                { new (): TLight },
+                { new (light: TLight): AnalyticLightNode<TLight> }
+            >,
+        );
     }
 
     /**
@@ -129,7 +158,7 @@ class NodeLibrary {
      * @param {number|string} type - The object type.
      * @param {Map} library - The type library.
      */
-    addType(nodeClass, type, library) {
+    addType<TNodeClass, TType>(nodeClass: TNodeClass, type: TType, library: Map<TType, TNodeClass>) {
         if (library.has(type)) {
             console.warn(`Redefinition of node ${type}`);
             return;
@@ -149,7 +178,11 @@ class NodeLibrary {
      * @param {any} baseClass - The class definition.
      * @param {WeakMap} library - The type library.
      */
-    addClass(nodeClass, baseClass, library) {
+    addClass<TNodeClass, TBaseClass extends object>(
+        nodeClass: TNodeClass,
+        baseClass: TBaseClass,
+        library: WeakMap<TBaseClass, TNodeClass>,
+    ) {
         if (library.has(baseClass)) {
             console.warn(`Redefinition of node ${baseClass.name}`);
             return;
diff --git a/src-testing/src/renderers/common/nodes/NodeUniform.ts b/src-testing/src/renderers/common/nodes/NodeUniform.ts
index 81d9f2ce..f4c0431c 100644
--- a/src-testing/src/renderers/common/nodes/NodeUniform.ts
+++ b/src-testing/src/renderers/common/nodes/NodeUniform.ts
@@ -8,6 +8,14 @@ import {
     Matrix3Uniform,
     Matrix4Uniform,
 } from '../Uniform.js';
+import NodeUniform from '../../../nodes/core/NodeUniform.js';
+import { Vector2 } from '../../../math/Vector2.js';
+import { Vector3 } from '../../../math/Vector3.js';
+import { Vector4 } from '../../../math/Vector4.js';
+import { Color } from '../../../math/Color.js';
+import { Matrix2 } from '../../../math/Matrix2.js';
+import { Matrix3 } from '../../../math/Matrix3.js';
+import { Matrix4 } from '../../../math/Matrix4.js';
 
 /**
  * A special form of Number uniform binding type.
@@ -17,12 +25,14 @@ import {
  * @augments NumberUniform
  */
 class NumberNodeUniform extends NumberUniform {
+    nodeUniform: NodeUniform<number>;
+
     /**
      * Constructs a new node-based Number uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<number>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -60,12 +70,14 @@ class NumberNodeUniform extends NumberUniform {
  * @augments Vector2Uniform
  */
 class Vector2NodeUniform extends Vector2Uniform {
+    nodeUniform: NodeUniform<Vector2>;
+
     /**
      * Constructs a new node-based Vector2 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<Vector2>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -103,12 +115,14 @@ class Vector2NodeUniform extends Vector2Uniform {
  * @augments Vector3Uniform
  */
 class Vector3NodeUniform extends Vector3Uniform {
+    nodeUniform: NodeUniform<Vector3>;
+
     /**
      * Constructs a new node-based Vector3 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<Vector3>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -146,12 +160,14 @@ class Vector3NodeUniform extends Vector3Uniform {
  * @augments Vector4Uniform
  */
 class Vector4NodeUniform extends Vector4Uniform {
+    nodeUniform: NodeUniform<Vector4>;
+
     /**
      * Constructs a new node-based Vector4 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<Vector4>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -189,12 +205,14 @@ class Vector4NodeUniform extends Vector4Uniform {
  * @augments ColorUniform
  */
 class ColorNodeUniform extends ColorUniform {
+    nodeUniform: NodeUniform<Color>;
+
     /**
      * Constructs a new node-based Color uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<Color>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -232,12 +250,14 @@ class ColorNodeUniform extends ColorUniform {
  * @augments Matrix2Uniform
  */
 class Matrix2NodeUniform extends Matrix2Uniform {
+    nodeUniform: NodeUniform<Matrix2>;
+
     /**
      * Constructs a new node-based Matrix2 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<Matrix2>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -275,12 +295,14 @@ class Matrix2NodeUniform extends Matrix2Uniform {
  * @augments Matrix3Uniform
  */
 class Matrix3NodeUniform extends Matrix3Uniform {
+    nodeUniform: NodeUniform<Matrix3>;
+
     /**
      * Constructs a new node-based Matrix3 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<Matrix3>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -318,12 +340,14 @@ class Matrix3NodeUniform extends Matrix3Uniform {
  * @augments Matrix4Uniform
  */
 class Matrix4NodeUniform extends Matrix4Uniform {
+    nodeUniform: NodeUniform<Matrix4>;
+
     /**
      * Constructs a new node-based Matrix4 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<Matrix4>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -363,3 +387,11 @@ export {
     Matrix3NodeUniform,
     Matrix4NodeUniform,
 };
+export type NodeUniformGPU =
+    | NumberNodeUniform
+    | Vector2NodeUniform
+    | Vector3NodeUniform
+    | Vector4NodeUniform
+    | ColorNodeUniform
+    | Matrix3NodeUniform
+    | Matrix4NodeUniform;
diff --git a/src-testing/src/renderers/common/nodes/NodeUniformsGroup.ts b/src-testing/src/renderers/common/nodes/NodeUniformsGroup.ts
index 19a8dd2a..26f39bf2 100644
--- a/src-testing/src/renderers/common/nodes/NodeUniformsGroup.ts
+++ b/src-testing/src/renderers/common/nodes/NodeUniformsGroup.ts
@@ -1,4 +1,5 @@
 import UniformsGroup from '../UniformsGroup.js';
+import { UniformGroupNode, UniformNode } from '../../../nodes/Nodes.js';
 
 let _id = 0;
 
@@ -10,13 +11,18 @@ let _id = 0;
  * @augments UniformsGroup
  */
 class NodeUniformsGroup extends UniformsGroup {
+    id: number;
+    groupNode: UniformGroupNode;
+
+    readonly isNodeUniformsGroup: true;
+
     /**
      * Constructs a new node-based uniforms group.
      *
      * @param {string} name - The group's name.
      * @param {UniformGroupNode} groupNode - The uniform group node.
      */
-    constructor(name, groupNode) {
+    constructor(name: string, groupNode: UniformGroupNode) {
         super(name);
 
         /**
diff --git a/src-testing/src/renderers/common/nodes/Nodes.ts b/src-testing/src/renderers/common/nodes/Nodes.ts
index bb6afd0b..eb775194 100644
--- a/src-testing/src/renderers/common/nodes/Nodes.ts
+++ b/src-testing/src/renderers/common/nodes/Nodes.ts
@@ -17,6 +17,7 @@ import {
     reference,
     pmremTexture,
     screenUV,
+    ShaderNodeObject,
 } from '../../../nodes/TSL.js';
 import { builtin } from '../../../nodes/accessors/BuiltinNode.js';
 
@@ -26,10 +27,63 @@ import {
     EquirectangularRefractionMapping,
 } from '../../../constants.js';
 import { hashArray } from '../../../nodes/core/NodeUtils.js';
+import { Color } from '../../../math/Color.js';
+import { Texture } from '../../../textures/Texture.js';
+import { CubeTexture } from '../../../textures/CubeTexture.js';
+import { Fog } from '../../../scenes/Fog.js';
+import { FogExp2 } from '../../../scenes/FogExp2.js';
+import NodeUniformsGroup from './NodeUniformsGroup.js';
+import RenderObject from '../RenderObject.js';
+import { Scene } from '../../../scenes/Scene.js';
+import Renderer from '../Renderer.js';
+import Backend from '../Backend.js';
+import { Object3D } from '../../../core/Object3D.js';
+import { Camera } from '../../../cameras/Camera.js';
+import { Material } from '../../../materials/Material.js';
+import Node from '../../../nodes/core/Node.js';
+import ComputeNode from '../../../nodes/gpgpu/ComputeNode.js';
+import LightsNode from '../../../nodes/lighting/LightsNode.js';
+import UniformGroupNode from '../../../nodes/core/UniformGroupNode.js';
+import NodeBuilder from '../../../nodes/core/NodeBuilder.js';
+
+interface NodeUniformsGroupData {
+    renderId?: number | undefined;
+    frameId?: number | undefined;
+}
+
+interface RenderObjectData {
+    nodeBuilderState?: NodeBuilderState | undefined;
+}
+
+interface ComputeNodeData {
+    nodeBuilderState?: NodeBuilderState | undefined;
+}
+
+interface SceneData {
+    background?: Color | Texture | CubeTexture | undefined;
+    backgroundNode?: ShaderNodeObject<Node> | undefined;
+    fog?: Fog | FogExp2 | undefined;
+    fogNode?: ShaderNodeObject<Node> | undefined;
+    environment?: Texture | undefined;
+    environmentNode?: ShaderNodeObject<Node> | undefined;
+}
+
+interface CacheKeyData {
+    callId: number;
+    cacheKey: number;
+}
+
+declare module '../../../scenes/Scene.js' {
+    interface Scene {
+        environmentNode?: ShaderNodeObject<Node> | null | undefined;
+        backgroundNode?: ShaderNodeObject<Node> | null | undefined;
+        fogNode?: ShaderNodeObject<Node> | null | undefined;
+    }
+}
 
 const _outputNodeMap = new WeakMap();
-const _chainKeys = [];
-const _cacheKeyValues = [];
+const _chainKeys = [] as unknown as [UniformGroupNode, NodeUniformsGroup] | [Scene, LightsNode];
+const _cacheKeyValues: number[] = [];
 
 /**
  * This renderer module manages node-related objects and is the
@@ -38,14 +92,27 @@ const _cacheKeyValues = [];
  * @private
  * @augments DataMap
  */
-class Nodes extends DataMap {
+class Nodes extends DataMap<{
     /**
      * Constructs a new nodes management component.
      *
      * @param {Renderer} renderer - The renderer.
      * @param {Backend} backend - The renderer's backend.
      */
-    constructor(renderer, backend) {
+    nodeUniformsGroup: { key: NodeUniformsGroup; value: NodeUniformsGroupData };
+    renderObject: { key: RenderObject; value: RenderObjectData };
+    computeNode: { key: ComputeNode; value: ComputeNodeData };
+    scene: { key: Scene; value: SceneData };
+}> {
+    renderer: Renderer;
+    backend: Backend;
+    nodeFrame: NodeFrame;
+    nodeBuilderCache: Map<string, NodeBuilderState>;
+    callHashCache: ChainMap<readonly [Scene, LightsNode], CacheKeyData>;
+    groupsData: ChainMap<readonly [UniformGroupNode, NodeUniformsGroup], { version?: number }>;
+    cacheLib: { [type: string]: WeakMap<object, ShaderNodeObject<Node> | undefined> };
+
+    constructor(renderer: Renderer, backend: Backend) {
         super();
 
         /**
@@ -105,7 +172,7 @@ class Nodes extends DataMap {
      * @param {NodeUniformsGroup} nodeUniformsGroup - The node uniforms group.
      * @return {boolean} Whether the node uniforms group requires an update or not.
      */
-    updateGroup(nodeUniformsGroup) {
+    updateGroup(nodeUniformsGroup: NodeUniformsGroup) {
         const groupNode = nodeUniformsGroup.groupNode;
         const name = groupNode.name;
 
@@ -168,7 +235,7 @@ class Nodes extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {number} The cache key.
      */
-    getForRenderCacheKey(renderObject) {
+    getForRenderCacheKey(renderObject: RenderObject) {
         return renderObject.initialCacheKey;
     }
 
@@ -178,7 +245,7 @@ class Nodes extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {NodeBuilderState} The node builder state.
      */
-    getForRender(renderObject) {
+    getForRender(renderObject: RenderObject) {
         const renderObjectData = this.get(renderObject);
 
         let nodeBuilderState = renderObjectData.nodeBuilderState;
@@ -225,13 +292,13 @@ class Nodes extends DataMap {
      * @param {any} object - The object to delete.
      * @return {?Object} The deleted dictionary.
      */
-    delete(object) {
-        if (object.isRenderObject) {
-            const nodeBuilderState = this.get(object).nodeBuilderState;
+    delete(object: NodeUniformsGroup | RenderObject | ComputeNode | Scene) {
+        if ((object as RenderObject).isRenderObject) {
+            const nodeBuilderState = this.get(object as RenderObject).nodeBuilderState!;
             nodeBuilderState.usedTimes--;
 
             if (nodeBuilderState.usedTimes === 0) {
-                this.nodeBuilderCache.delete(this.getForRenderCacheKey(object));
+                this.nodeBuilderCache.delete(this.getForRenderCacheKey(object as RenderObject));
             }
         }
 
@@ -244,7 +311,7 @@ class Nodes extends DataMap {
      * @param {Node} computeNode - The compute node.
      * @return {NodeBuilderState} The node builder state.
      */
-    getForCompute(computeNode) {
+    getForCompute(computeNode: ComputeNode) {
         const computeData = this.get(computeNode);
 
         let nodeBuilderState = computeData.nodeBuilderState;
@@ -268,7 +335,7 @@ class Nodes extends DataMap {
      * @param {NodeBuilder} nodeBuilder - The node builder.
      * @return {NodeBuilderState} The node builder state.
      */
-    _createNodeBuilderState(nodeBuilder) {
+    _createNodeBuilderState(nodeBuilder: NodeBuilder) {
         return new NodeBuilderState(
             nodeBuilder.vertexShader,
             nodeBuilder.fragmentShader,
@@ -290,9 +357,8 @@ class Nodes extends DataMap {
      * @param {Scene} scene - The scene.
      * @return {Node} A node representing the current scene environment.
      */
-    getEnvironmentNode(scene) {
+    getEnvironmentNode(scene: Scene) {
         this.updateEnvironment(scene);
-
         let environmentNode = null;
 
         if (scene.environmentNode && scene.environmentNode.isNode) {
@@ -315,9 +381,8 @@ class Nodes extends DataMap {
      * @param {Scene} scene - The scene.
      * @return {Node} A node representing the current scene background.
      */
-    getBackgroundNode(scene) {
+    getBackgroundNode(scene: Scene) {
         this.updateBackground(scene);
-
         let backgroundNode = null;
 
         if (scene.backgroundNode && scene.backgroundNode.isNode) {
@@ -339,9 +404,8 @@ class Nodes extends DataMap {
      * @param {Scene} scene - The scene.
      * @return {Node} A node representing the current scene fog.
      */
-    getFogNode(scene) {
+    getFogNode(scene: Scene) {
         this.updateFog(scene);
-
         return scene.fogNode || this.get(scene).fogNode || null;
     }
 
@@ -355,13 +419,13 @@ class Nodes extends DataMap {
      * @param {LightsNode} lightsNode - The lights node.
      * @return {number} The cache key.
      */
-    getCacheKey(scene, lightsNode) {
+    getCacheKey(scene: Scene, lightsNode: LightsNode) {
         _chainKeys[0] = scene;
         _chainKeys[1] = lightsNode;
 
         const callId = this.renderer.info.calls;
 
-        const cacheKeyData = this.callHashCache.get(_chainKeys) || {};
+        const cacheKeyData = this.callHashCache.get(_chainKeys as readonly [Scene, LightsNode]) || ({} as CacheKeyData);
 
         if (cacheKeyData.callId !== callId) {
             const environmentNode = this.getEnvironmentNode(scene);
@@ -376,7 +440,7 @@ class Nodes extends DataMap {
             cacheKeyData.callId = callId;
             cacheKeyData.cacheKey = hashArray(_cacheKeyValues);
 
-            this.callHashCache.set(_chainKeys, cacheKeyData);
+            this.callHashCache.set(_chainKeys as readonly [Scene, LightsNode], cacheKeyData);
 
             _cacheKeyValues.length = 0;
         }
@@ -402,7 +466,7 @@ class Nodes extends DataMap {
      *
      * @param {Scene} scene - The scene.
      */
-    updateBackground(scene) {
+    updateBackground(scene: Scene) {
         const sceneData = this.get(scene);
         const background = scene.background;
 
@@ -417,7 +481,7 @@ class Nodes extends DataMap {
                     background,
                     () => {
                         if (
-                            background.isCubeTexture === true ||
+                            (background as CubeTexture).isCubeTexture === true ||
                             background.mapping === EquirectangularReflectionMapping ||
                             background.mapping === EquirectangularRefractionMapping ||
                             background.mapping === CubeUVReflectionMapping
@@ -427,18 +491,18 @@ class Nodes extends DataMap {
                             } else {
                                 let envMap;
 
-                                if (background.isCubeTexture === true) {
-                                    envMap = cubeTexture(background);
+                                if ((background as CubeTexture).isCubeTexture === true) {
+                                    envMap = cubeTexture(background as CubeTexture);
                                 } else {
                                     envMap = texture(background);
                                 }
 
                                 return cubeMapNode(envMap);
                             }
-                        } else if (background.isTexture === true) {
-                            return texture(background, screenUV.flipY()).setUpdateMatrix(true);
-                        } else if (background.isColor !== true) {
-                            console.error('WebGPUNodes: Unsupported background configuration.', background);
+                        } else if ((background as Texture).isTexture === true) {
+                            return texture(background as Texture, screenUV.flipY()).setUpdateMatrix(true);
+                        } else if ((background as Color).isColor !== true) {
+                            console.error('WebGPUNodes: Unsupported background configuration.', background as Color);
                         }
                     },
                     forceUpdate,
@@ -464,7 +528,12 @@ class Nodes extends DataMap {
      * @param {boolean} [forceUpdate=false] - Whether an update should be enforced or not.
      * @return {Node} The node representation.
      */
-    getCacheNode(type, object, callback, forceUpdate = false) {
+    getCacheNode(
+        type: string,
+        object: object,
+        callback: () => ShaderNodeObject<Node> | undefined,
+        forceUpdate = false,
+    ) {
         const nodeCache = this.cacheLib[type] || (this.cacheLib[type] = new WeakMap());
 
         let node = nodeCache.get(object);
@@ -483,22 +552,22 @@ class Nodes extends DataMap {
      *
      * @param {Scene} scene - The scene.
      */
-    updateFog(scene) {
+    updateFog(scene: Scene) {
         const sceneData = this.get(scene);
         const sceneFog = scene.fog;
 
         if (sceneFog) {
             if (sceneData.fog !== sceneFog) {
                 const fogNode = this.getCacheNode('fog', sceneFog, () => {
-                    if (sceneFog.isFogExp2) {
-                        const color = reference('color', 'color', sceneFog).setGroup(renderGroup);
-                        const density = reference('density', 'float', sceneFog).setGroup(renderGroup);
+                    if ((sceneFog as FogExp2).isFogExp2) {
+                        const color = reference('color', 'color', sceneFog as FogExp2).setGroup(renderGroup);
+                        const density = reference('density', 'float', sceneFog as FogExp2).setGroup(renderGroup);
 
                         return fog(color, densityFogFactor(density));
-                    } else if (sceneFog.isFog) {
-                        const color = reference('color', 'color', sceneFog).setGroup(renderGroup);
-                        const near = reference('near', 'float', sceneFog).setGroup(renderGroup);
-                        const far = reference('far', 'float', sceneFog).setGroup(renderGroup);
+                    } else if ((sceneFog as Fog).isFog) {
+                        const color = reference('color', 'color', sceneFog as Fog).setGroup(renderGroup);
+                        const near = reference('near', 'float', sceneFog as Fog).setGroup(renderGroup);
+                        const far = reference('far', 'float', sceneFog as Fog).setGroup(renderGroup);
 
                         return fog(color, rangeFogFactor(near, far));
                     } else {
@@ -521,14 +590,14 @@ class Nodes extends DataMap {
      *
      * @param {Scene} scene - The scene.
      */
-    updateEnvironment(scene) {
+    updateEnvironment(scene: Scene) {
         const sceneData = this.get(scene);
         const environment = scene.environment;
 
         if (environment) {
             if (sceneData.environment !== environment) {
                 const environmentNode = this.getCacheNode('environment', environment, () => {
-                    if (environment.isCubeTexture === true) {
+                    if ((environment as CubeTexture).isCubeTexture === true) {
                         return cubeTexture(environment);
                     } else if (environment.isTexture === true) {
                         return texture(environment);
@@ -546,7 +615,13 @@ class Nodes extends DataMap {
         }
     }
 
-    getNodeFrame(renderer = this.renderer, scene = null, object = null, camera = null, material = null) {
+    getNodeFrame(
+        renderer = this.renderer,
+        scene: Scene | null = null,
+        object: Object3D | null = null,
+        camera: Camera | null = null,
+        material: Material | null = null,
+    ) {
         const nodeFrame = this.nodeFrame;
         nodeFrame.renderer = renderer;
         nodeFrame.scene = scene;
@@ -557,7 +632,7 @@ class Nodes extends DataMap {
         return nodeFrame;
     }
 
-    getNodeFrameForRender(renderObject) {
+    getNodeFrameForRender(renderObject: RenderObject) {
         return this.getNodeFrame(
             renderObject.renderer,
             renderObject.scene,
@@ -585,7 +660,7 @@ class Nodes extends DataMap {
      * @param {Texture} outputTarget - The output target.
      * @return {boolean} Whether the output configuration has changed or not.
      */
-    hasOutputChange(outputTarget) {
+    hasOutputChange(outputTarget: Texture) {
         const cacheKey = _outputNodeMap.get(outputTarget);
 
         return cacheKey !== this.getOutputCacheKey();
@@ -598,11 +673,11 @@ class Nodes extends DataMap {
      * @param {Texture} outputTarget - The output target.
      * @return {Node} The output node.
      */
-    getOutputNode(outputTarget) {
+    getOutputNode(outputTarget: Texture) {
         const renderer = this.renderer;
         const cacheKey = this.getOutputCacheKey();
 
-        const output = outputTarget.isTextureArray
+        const output: ShaderNodeObject<Node> = outputTarget.isTextureArray
             ? texture3D(outputTarget, vec3(screenUV, builtin('gl_ViewID_OVR'))).renderOutput(
                   renderer.toneMapping,
                   renderer.currentColorSpace,
@@ -620,7 +695,7 @@ class Nodes extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateBefore(renderObject) {
+    updateBefore(renderObject: RenderObject) {
         const nodeBuilder = renderObject.getNodeBuilderState();
 
         for (const node of nodeBuilder.updateBeforeNodes) {
@@ -636,7 +711,7 @@ class Nodes extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateAfter(renderObject) {
+    updateAfter(renderObject: RenderObject) {
         const nodeBuilder = renderObject.getNodeBuilderState();
 
         for (const node of nodeBuilder.updateAfterNodes) {
@@ -652,7 +727,7 @@ class Nodes extends DataMap {
      *
      * @param {Node} computeNode - The compute node.
      */
-    updateForCompute(computeNode) {
+    updateForCompute(computeNode: ComputeNode) {
         const nodeFrame = this.getNodeFrame();
         const nodeBuilder = this.getForCompute(computeNode);
 
@@ -667,7 +742,7 @@ class Nodes extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         const nodeFrame = this.getNodeFrameForRender(renderObject);
         const nodeBuilder = renderObject.getNodeBuilderState();
 
@@ -682,7 +757,7 @@ class Nodes extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {boolean} Whether the given render object requires a refresh or not.
      */
-    needsRefresh(renderObject) {
+    needsRefresh(renderObject: RenderObject) {
         const nodeFrame = this.getNodeFrameForRender(renderObject);
         const monitor = renderObject.getMonitor();
 
diff --git a/src-testing/src/renderers/webgl-fallback/WebGLBackend.ts b/src-testing/src/renderers/webgl-fallback/WebGLBackend.ts
index ae4442ed..38e8fe63 100644
--- a/src-testing/src/renderers/webgl-fallback/WebGLBackend.ts
+++ b/src-testing/src/renderers/webgl-fallback/WebGLBackend.ts
@@ -14,6 +14,7 @@ import { WebGLBufferRenderer } from './WebGLBufferRenderer.js';
 import { warnOnce } from '../../utils.js';
 import { WebGLCoordinateSystem } from '../../constants.js';
 import WebGLTimestampQueryPool from './utils/WebGLTimestampQueryPool.js';
+import { Texture } from '../../textures/Texture.js';
 
 /**
  * A backend implementation targeting WebGL 2.
@@ -1186,7 +1187,14 @@ class WebGLBackend extends Backend {
      * @param {number} faceIndex - The face index.
      * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
      */
-    async copyTextureToBuffer(texture, x, y, width, height, faceIndex) {
+    async copyTextureToBuffer(
+        texture: Texture,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+        faceIndex: number,
+    ) {
         return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);
     }
 
diff --git a/src-testing/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.ts b/src-testing/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.ts
index 29e827b2..c5d689a4 100644
--- a/src-testing/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.ts
+++ b/src-testing/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.ts
@@ -1,4 +1,4 @@
-import { GLSLNodeParser, NodeBuilder, TextureNode, vectorComponents } from '../../../nodes/Nodes.js';
+import { GLSLNodeParser, NodeBuilder, NodeShaderStage, TextureNode, vectorComponents } from '../../../nodes/Nodes.js';
 
 import NodeUniformBuffer from '../../common/nodes/NodeUniformBuffer.js';
 import NodeUniformsGroup from '../../common/nodes/NodeUniformsGroup.js';
@@ -28,8 +28,19 @@ import {
     FloatType,
 } from '../../../constants.js';
 import { DataTexture } from '../../../textures/DataTexture.js';
-
-const glslMethods = {
+import Renderer from '../../common/Renderer.js';
+import StructTypeNode from '../../../nodes/core/StructTypeNode.js';
+import BufferAttributeNode from '../../../nodes/accessors/BufferAttributeNode.js';
+import UniformNode from '../../../nodes/core/UniformNode.js';
+import { Object3D } from '../../../core/Object3D.js';
+import { Texture } from '../../../textures/Texture.js';
+import { BufferAttribute } from '../../../core/BufferAttribute.js';
+import { InterleavedBufferAttribute } from '../../../core/InterleavedBufferAttribute.js';
+import { ShaderNodeInternal, ShaderNodeObject } from '../../../nodes/tsl/TSLCore.js';
+import StorageBufferNode from '../../../nodes/accessors/StorageBufferNode.js';
+import StorageArrayElementNode from '../../../nodes/utils/StorageArrayElementNode.js';
+
+const glslMethods: { [method: string]: string } = {
     textureDimensions: 'textureSize',
     equals: 'equal',
 };
@@ -79,6 +90,23 @@ precision lowp sampler2DArrayShadow;
 precision lowp samplerCubeShadow;
 `;
 
+export interface Transform {
+    varyingName: string | null | undefined;
+    attributeNode: ShaderNodeObject<BufferAttributeNode>;
+}
+
+interface StageData {
+    extensions?: string | undefined;
+    uniforms?: string | undefined;
+    attributes?: string | undefined;
+    varyings?: string | undefined;
+    vars?: string | undefined;
+    structs?: string | undefined;
+    codes?: string | undefined;
+    transforms?: string | undefined;
+    flow?: string | undefined;
+}
+
 /**
  * A node builder targeting GLSL.
  *
@@ -90,13 +118,25 @@ precision lowp samplerCubeShadow;
  * @augments NodeBuilder
  */
 class GLSLNodeBuilder extends NodeBuilder {
+    uniformGroups: {
+        vertex?: { [groupName: string]: NodeUniformsGroup | undefined };
+        fragment?: { [groupName: string]: NodeUniformsGroup | undefined };
+        compute?: { [groupName: string]: NodeUniformsGroup | undefined };
+    };
+    transforms: Transform[];
+    extensions: {
+        vertex?: Map<string, string>;
+        fragment?: Map<string, string>;
+        compute?: Map<string, string>;
+    };
+
     /**
      * Constructs a new GLSL node builder renderer.
      *
      * @param {Object3D} object - The 3D object.
      * @param {Renderer} renderer - The renderer.
      */
-    constructor(object, renderer) {
+    constructor(object: Object3D, renderer: Renderer) {
         super(object, renderer, new GLSLNodeParser());
 
         /**
@@ -146,7 +186,7 @@ class GLSLNodeBuilder extends NodeBuilder {
      * @param {string} method - The method name to resolve.
      * @return {string} The resolved GLSL method name.
      */
-    getMethod(method) {
+    getMethod(method: string) {
         return glslMethods[method] || method;
     }
 
@@ -165,7 +205,7 @@ class GLSLNodeBuilder extends NodeBuilder {
      * @param {ShaderNodeInternal} shaderNode - The shader node.
      * @return {string} The GLSL function code.
      */
-    buildFunctionCode(shaderNode) {
+    buildFunctionCode(shaderNode: ShaderNodeInternal) {
         const layout = shaderNode.layout;
         const flowData = this.flowShaderNode(shaderNode);
 
@@ -197,7 +237,7 @@ ${flowData.code}
      *
      * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
      */
-    setupPBO(storageBufferNode) {
+    setupPBO(storageBufferNode: StorageBufferNode) {
         const attribute = storageBufferNode.value;
 
         if (attribute.pbo === undefined) {
@@ -268,7 +308,7 @@ ${flowData.code}
      * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
      * @return {string} The property name.
      */
-    getPropertyName(node, shaderStage = this.shaderStage) {
+    getPropertyName(node: unknown, shaderStage = this.shaderStage) {
         if (node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true) {
             return shaderStage.charAt(0) + '_' + node.name;
         }
@@ -283,7 +323,7 @@ ${flowData.code}
      * @param {StorageArrayElementNode} storageArrayElementNode - The storage array element node.
      * @return {string} The property name.
      */
-    generatePBO(storageArrayElementNode) {
+    generatePBO(storageArrayElementNode: StorageArrayElementNode) {
         const { node, indexNode } = storageArrayElementNode;
         const attribute = node.value;
 
@@ -365,7 +405,13 @@ ${flowData.code}
      * @param {string} [levelSnippet='0u'] - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
      * @return {string} The GLSL snippet.
      */
-    generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0') {
+    generateTextureLoad(
+        texture: Texture | null,
+        textureProperty: string | undefined,
+        uvIndexSnippet: string,
+        depthSnippet: string | null,
+        levelSnippet = '0',
+    ) {
         if (depthSnippet) {
             return `texelFetch( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet} )`;
         } else {
@@ -382,7 +428,7 @@ ${flowData.code}
      * @param {?string} depthSnippet -  A GLSL snippet that represents the 0-based texture array index to sample.
      * @return {string} The GLSL snippet.
      */
-    generateTexture(texture, textureProperty, uvSnippet, depthSnippet) {
+    generateTexture(texture: Texture, textureProperty: string, uvSnippet: string | null, depthSnippet: string | null) {
         if (texture.isDepthTexture) {
             if (depthSnippet) uvSnippet = `vec4( ${uvSnippet}, ${depthSnippet} )`;
 
@@ -403,7 +449,12 @@ ${flowData.code}
      * @param {string} levelSnippet - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
      * @return {string} The GLSL snippet.
      */
-    generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet) {
+    generateTextureLevel(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        levelSnippet: string | null,
+    ) {
         return `textureLod( ${textureProperty}, ${uvSnippet}, ${levelSnippet} )`;
     }
 
@@ -416,7 +467,12 @@ ${flowData.code}
      * @param {string} biasSnippet - A GLSL snippet that represents the bias to apply to the mip level before sampling.
      * @return {string} The GLSL snippet.
      */
-    generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet) {
+    generateTextureBias(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        biasSnippet: string | null,
+    ) {
         return `texture( ${textureProperty}, ${uvSnippet}, ${biasSnippet} )`;
     }
 
@@ -429,7 +485,12 @@ ${flowData.code}
      * @param {Array<string>} gradSnippet - An array holding both gradient GLSL snippets.
      * @return {string} The GLSL snippet.
      */
-    generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet) {
+    generateTextureGrad(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        gradSnippet: [string, string] | null,
+    ) {
         return `textureGrad( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]} )`;
     }
 
@@ -446,11 +507,11 @@ ${flowData.code}
      * @return {string} The GLSL snippet.
      */
     generateTextureCompare(
-        texture,
-        textureProperty,
-        uvSnippet,
-        compareSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        compareSnippet: string | null,
+        depthSnippet: string | null,
         shaderStage = this.shaderStage,
     ) {
         if (shaderStage === 'fragment') {
@@ -463,6 +524,7 @@ ${flowData.code}
             console.error(
                 `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`,
             );
+            return undefined as unknown as string;
         }
     }
 
@@ -472,8 +534,8 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the variables.
      */
-    getVars(shaderStage) {
-        const snippets = [];
+    getVars(shaderStage: 'vertex' | 'fragment' | 'compute') {
+        const snippets: string[] = [];
 
         const vars = this.vars[shaderStage];
 
@@ -492,7 +554,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the uniforms.
      */
-    getUniforms(shaderStage) {
+    getUniforms(shaderStage: 'vertex' | 'fragment' | 'compute') {
         const uniforms = this.uniforms[shaderStage];
 
         const bindingSnippets = [];
@@ -588,7 +650,7 @@ ${flowData.code}
      * @param {BufferAttribute} attribute - The buffer attribute.
      * @return {string} The type.
      */
-    getTypeFromAttribute(attribute) {
+    getTypeFromAttribute(attribute: BufferAttribute | InterleavedBufferAttribute) {
         let nodeType = super.getTypeFromAttribute(attribute);
 
         if (/^[iu]/.test(nodeType) && attribute.gpuType !== IntType) {
@@ -612,7 +674,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the shader attributes.
      */
-    getAttributes(shaderStage) {
+    getAttributes(shaderStage: NodeShaderStage) {
         let snippet = '';
 
         if (shaderStage === 'vertex' || shaderStage === 'compute') {
@@ -634,8 +696,8 @@ ${flowData.code}
      * @param {StructTypeNode} struct - The struct type node.
      * @return {string} The GLSL snippet that defines the struct members.
      */
-    getStructMembers(struct) {
-        const snippets = [];
+    getStructMembers(struct: StructTypeNode) {
+        const snippets: string[] = [];
 
         for (const member of struct.members) {
             snippets.push(`\t${member.type} ${member.name};`);
@@ -650,7 +712,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the structs.
      */
-    getStructs(shaderStage) {
+    getStructs(shaderStage: NodeShaderStage) {
         const snippets = [];
         const structs = this.structs[shaderStage];
 
@@ -683,7 +745,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the varyings.
      */
-    getVaryings(shaderStage) {
+    getVaryings(shaderStage: NodeShaderStage) {
         let snippet = '';
 
         const varyings = this.varyings;
@@ -817,7 +879,7 @@ ${flowData.code}
      * @param {string} behavior - The extension behavior.
      * @param {string} [shaderStage=this.shaderStage] - The shader stage.
      */
-    enableExtension(name, behavior, shaderStage = this.shaderStage) {
+    enableExtension(name: string, behavior: string, shaderStage = this.shaderStage!) {
         const map = this.extensions[shaderStage] || (this.extensions[shaderStage] = new Map());
 
         if (map.has(name) === false) {
@@ -834,7 +896,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the enabled extensions.
      */
-    getExtensions(shaderStage) {
+    getExtensions(shaderStage: NodeShaderStage) {
         const snippets = [];
 
         if (shaderStage === 'vertex') {
@@ -872,7 +934,7 @@ ${flowData.code}
      * @param {string} name - The requested feature.
      * @return {boolean} Whether the requested feature is supported or not.
      */
-    isAvailable(name) {
+    isAvailable(name: string) {
         let result = supports[name];
 
         if (result === undefined) {
@@ -941,7 +1003,7 @@ ${flowData.code}
      * @param {string} varyingName - The varying name.
      * @param {AttributeNode} attributeNode - The attribute node.
      */
-    registerTransform(varyingName, attributeNode) {
+    registerTransform(varyingName: string | null | undefined, attributeNode: ShaderNodeObject<BufferAttributeNode>) {
         this.transforms.push({ varyingName, attributeNode });
     }
 
@@ -951,7 +1013,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the transforms.
      */
-    getTransforms(/* shaderStage  */) {
+    getTransforms(shaderStage: NodeShaderStage) {
         const transforms = this.transforms;
 
         let snippet = '';
@@ -974,7 +1036,7 @@ ${flowData.code}
      * @param {string} vars - The struct variables.
      * @return {string} The GLSL snippet representing a struct.
      */
-    _getGLSLUniformStruct(name, vars) {
+    _getGLSLUniformStruct(name: string, vars: string) {
         return `
 layout( std140 ) uniform ${name} {
 ${vars}
@@ -988,7 +1050,7 @@ ${vars}
      * @param {Object} shaderData - The shader data.
      * @return {string} The vertex shader.
      */
-    _getGLSLVertexCode(shaderData) {
+    _getGLSLVertexCode(shaderData: StageData) {
         return `#version 300 es
 
 ${this.getSignature()}
@@ -1035,7 +1097,7 @@ void main() {
      * @param {Object} shaderData - The shader data.
      * @return {string} The vertex shader.
      */
-    _getGLSLFragmentCode(shaderData) {
+    _getGLSLFragmentCode(shaderData: StageData) {
         return `#version 300 es
 
 ${this.getSignature()}
@@ -1074,19 +1136,20 @@ void main() {
      * Controls the code build of the shader stages.
      */
     buildCode() {
-        const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
+        const shadersData: { fragment?: StageData; vertex?: StageData; compute?: StageData } =
+            this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
 
         this.sortBindingGroups();
 
         for (const shaderStage in shadersData) {
             let flow = '// code\n\n';
-            flow += this.flowCode[shaderStage];
+            flow += this.flowCode[shaderStage as NodeShaderStage];
 
-            const flowNodes = this.flowNodes[shaderStage];
+            const flowNodes = this.flowNodes[shaderStage as NodeShaderStage];
             const mainNode = flowNodes[flowNodes.length - 1];
 
             for (const node of flowNodes) {
-                const flowSlotData = this.getFlowData(node /*, shaderStage*/);
+                const flowSlotData = this.getFlowData(node /*, shaderStage*/)!;
                 const slotName = node.name;
 
                 if (slotName) {
@@ -1112,24 +1175,24 @@ void main() {
                 }
             }
 
-            const stageData = shadersData[shaderStage];
+            const stageData = shadersData[shaderStage as NodeShaderStage]!;
 
-            stageData.extensions = this.getExtensions(shaderStage);
-            stageData.uniforms = this.getUniforms(shaderStage);
-            stageData.attributes = this.getAttributes(shaderStage);
-            stageData.varyings = this.getVaryings(shaderStage);
-            stageData.vars = this.getVars(shaderStage);
-            stageData.structs = this.getStructs(shaderStage);
-            stageData.codes = this.getCodes(shaderStage);
-            stageData.transforms = this.getTransforms(shaderStage);
+            stageData.extensions = this.getExtensions(shaderStage as NodeShaderStage);
+            stageData.uniforms = this.getUniforms(shaderStage as NodeShaderStage);
+            stageData.attributes = this.getAttributes(shaderStage as NodeShaderStage);
+            stageData.varyings = this.getVaryings(shaderStage as NodeShaderStage);
+            stageData.vars = this.getVars(shaderStage as NodeShaderStage);
+            stageData.structs = this.getStructs(shaderStage as NodeShaderStage);
+            stageData.codes = this.getCodes(shaderStage as NodeShaderStage);
+            stageData.transforms = this.getTransforms(shaderStage as NodeShaderStage);
             stageData.flow = flow;
         }
 
         if (this.material !== null) {
-            this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);
-            this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);
+            this.vertexShader = this._getGLSLVertexCode(shadersData.vertex!);
+            this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment!);
         } else {
-            this.computeShader = this._getGLSLVertexCode(shadersData.compute);
+            this.computeShader = this._getGLSLVertexCode(shadersData.compute!);
         }
     }
 
@@ -1146,7 +1209,12 @@ void main() {
      * @param {?string} [name=null] - An optional uniform name.
      * @return {NodeUniform} The node uniform object.
      */
-    getUniformFromNode(node, type, shaderStage, name = null) {
+    getUniformFromNode(
+        node: UniformNode<unknown>,
+        type: string | null,
+        shaderStage: 'vertex' | 'fragment' | 'compute',
+        name: string | null = null,
+    ) {
         const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
diff --git a/src-testing/src/renderers/webgpu/WebGPUBackend.ts b/src-testing/src/renderers/webgpu/WebGPUBackend.ts
index 68c2fef2..e7879111 100644
--- a/src-testing/src/renderers/webgpu/WebGPUBackend.ts
+++ b/src-testing/src/renderers/webgpu/WebGPUBackend.ts
@@ -1614,7 +1614,14 @@ class WebGPUBackend extends Backend {
      * @param {number} faceIndex - The face index.
      * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
      */
-    async copyTextureToBuffer(texture, x, y, width, height, faceIndex) {
+    async copyTextureToBuffer(
+        texture: Texture,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+        faceIndex: number,
+    ) {
         return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);
     }
 
diff --git a/src-testing/src/renderers/webgpu/nodes/WGSLNodeBuilder.ts b/src-testing/src/renderers/webgpu/nodes/WGSLNodeBuilder.ts
index 40031689..1196f2dc 100644
--- a/src-testing/src/renderers/webgpu/nodes/WGSLNodeBuilder.ts
+++ b/src-testing/src/renderers/webgpu/nodes/WGSLNodeBuilder.ts
@@ -10,7 +10,7 @@ import {
 import NodeUniformBuffer from '../../common/nodes/NodeUniformBuffer.js';
 import NodeStorageBuffer from '../../common/nodes/NodeStorageBuffer.js';
 
-import { NodeBuilder, CodeNode } from '../../../nodes/Nodes.js';
+import { NodeBuilder, CodeNode, NodeShaderStage, ShaderNodeInternal } from '../../../nodes/Nodes.js';
 
 import { getFormat } from '../utils/WebGPUTextureUtils.js';
 
@@ -28,6 +28,8 @@ import {
     MirroredRepeatWrapping,
     NearestFilter,
 } from '../../../constants.js';
+import { Texture } from '../../../textures/Texture.js';
+import UniformNode from '../../../nodes/core/UniformNode.js';
 
 // GPUShaderStage is not defined in browsers not supporting WebGPU
 const GPUShaderStage = typeof self !== 'undefined' ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };
@@ -257,7 +259,13 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
      * @return {string} The WGSL snippet.
      */
-    _generateTextureSample(texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage) {
+    _generateTextureSample(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        depthSnippet: string | null,
+        shaderStage = this.shaderStage,
+    ) {
         if (shaderStage === 'fragment') {
             if (depthSnippet) {
                 return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet} )`;
@@ -475,7 +483,13 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
      * @return {string} The WGSL snippet.
      */
-    generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, levelSnippet = '0u') {
+    generateTextureLod(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        depthSnippet: string | null,
+        levelSnippet: string | null = '0u',
+    ) {
         const wrapFunction = this.generateWrapFunction(texture);
         const textureDimension = this.generateTextureDimension(texture, textureProperty, levelSnippet);
 
@@ -495,9 +509,14 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
      * @return {string} The WGSL snippet.
      */
-    generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u') {
+    generateTextureLoad(
+        texture: Texture,
+        textureProperty: string,
+        uvIndexSnippet: string | null,
+        depthSnippet: string | null,
+        levelSnippet = '0u',
+    ) {
         let snippet;
-
         if (texture.isVideoTexture === true || texture.isStorageTexture === true) {
             snippet = `textureLoad( ${textureProperty}, ${uvIndexSnippet} )`;
         } else if (depthSnippet) {
@@ -589,11 +608,11 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @return {string} The WGSL snippet.
      */
     generateTextureGrad(
-        texture,
-        textureProperty,
-        uvSnippet,
-        gradSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        gradSnippet: [string, string] | null,
+        depthSnippet: string | null,
         shaderStage = this.shaderStage,
     ) {
         if (shaderStage === 'fragment') {
@@ -617,11 +636,11 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @return {string} The WGSL snippet.
      */
     generateTextureCompare(
-        texture,
-        textureProperty,
-        uvSnippet,
-        compareSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        compareSnippet: string | null,
+        depthSnippet: string | null,
         shaderStage = this.shaderStage,
     ) {
         if (shaderStage === 'fragment') {
@@ -649,11 +668,11 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @return {string} The WGSL snippet.
      */
     generateTextureLevel(
-        texture,
-        textureProperty,
-        uvSnippet,
-        levelSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        levelSnippet: string | null,
+        depthSnippet: string | null,
         shaderStage = this.shaderStage,
     ) {
         let snippet = null;
@@ -686,11 +705,11 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @return {string} The WGSL snippet.
      */
     generateTextureBias(
-        texture,
-        textureProperty,
-        uvSnippet,
-        biasSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        biasSnippet: string | null,
+        depthSnippet: string | null,
         shaderStage = this.shaderStage,
     ) {
         if (shaderStage === 'fragment') {
@@ -707,7 +726,7 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
      * @return {string} The property name.
      */
-    getPropertyName(node, shaderStage = this.shaderStage) {
+    getPropertyName(node: unknown, shaderStage = this.shaderStage) {
         if (node.isNodeVarying === true && node.needsInterpolation === true) {
             if (shaderStage === 'vertex') {
                 return `varyings.${node.name}`;
@@ -796,7 +815,12 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {?string} [name=null] - An optional uniform name.
      * @return {NodeUniform} The node uniform object.
      */
-    getUniformFromNode(node, type, shaderStage, name = null) {
+    getUniformFromNode(
+        node: UniformNode<unknown>,
+        type: string | null,
+        shaderStage: NodeShaderStage,
+        name: string | null = null,
+    ) {
         const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
@@ -931,7 +955,7 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {ShaderNodeInternal} shaderNode - The shader node.
      * @return {string} The WGSL function code.
      */
-    buildFunctionCode(shaderNode) {
+    buildFunctionCode(shaderNode: ShaderNodeInternal) {
         const layout = shaderNode.layout;
         const flowData = this.flowShaderNode(shaderNode);
 
@@ -1215,8 +1239,8 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The WGSL snippet that defines the shader attributes.
      */
-    getAttributes(shaderStage) {
-        const snippets = [];
+    getAttributes(shaderStage: NodeShaderStage) {
+        const snippets: string[] = [];
 
         if (shaderStage === 'compute') {
             this.getBuiltin('global_invocation_id', 'globalId', 'vec3<u32>', 'attribute');
@@ -1350,8 +1374,8 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The WGSL snippet that defines the varyings.
      */
-    getVaryings(shaderStage) {
-        const snippets = [];
+    getVaryings(shaderStage: NodeShaderStage) {
+        const snippets: string[] = [];
 
         if (shaderStage === 'vertex') {
             this.getBuiltin('position', 'Vertex', 'vec4<f32>', 'vertex');
@@ -1404,7 +1428,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The WGSL snippet that defines the uniforms.
      */
-    getUniforms(shaderStage) {
+    getUniforms(shaderStage: NodeShaderStage) {
         const uniforms = this.uniforms[shaderStage];
 
         const bindingSnippets = [];
diff --git a/src-testing/src/renderers/webgpu/nodes/WGSLNodeFunction.ts b/src-testing/src/renderers/webgpu/nodes/WGSLNodeFunction.ts
index 34a93355..6e5e4a86 100644
--- a/src-testing/src/renderers/webgpu/nodes/WGSLNodeFunction.ts
+++ b/src-testing/src/renderers/webgpu/nodes/WGSLNodeFunction.ts
@@ -138,7 +138,7 @@ class WGSLNodeFunction extends NodeFunction {
      *
      * @param {string} source - The WGSL source.
      */
-    constructor(source) {
+    constructor(source: string) {
         const { type, inputs, name, inputsCode, blockCode, outputType } = parse(source);
 
         super(type, inputs, name);
diff --git a/src-testing/src/renderers/webgpu/nodes/WGSLNodeParser.ts b/src-testing/src/renderers/webgpu/nodes/WGSLNodeParser.ts
index d52f7500..97fbffe0 100644
--- a/src-testing/src/renderers/webgpu/nodes/WGSLNodeParser.ts
+++ b/src-testing/src/renderers/webgpu/nodes/WGSLNodeParser.ts
@@ -13,7 +13,7 @@ class WGSLNodeParser extends NodeParser {
      * @param {string} source - The WGSL code.
      * @return {WGSLNodeFunction} A node function.
      */
-    parseFunction(source) {
+    parseFunction(source: string) {
         return new WGSLNodeFunction(source);
     }
 }
