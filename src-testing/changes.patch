diff --git a/src-testing/src/materials/nodes/manager/NodeMaterialObserver.ts b/src-testing/src/materials/nodes/manager/NodeMaterialObserver.ts
index 8ab1a6d6..dab659ab 100644
--- a/src-testing/src/materials/nodes/manager/NodeMaterialObserver.ts
+++ b/src-testing/src/materials/nodes/manager/NodeMaterialObserver.ts
@@ -1,3 +1,10 @@
+import NodeBuilder from '../../../nodes/core/NodeBuilder.js';
+import RenderObject from '../../../renderers/common/RenderObject.js';
+import { Matrix4 } from '../../../math/Matrix4.js';
+import { Material } from '../../Material.js';
+import NodeFrame from '../../../nodes/core/NodeFrame.js';
+import { BufferAttribute } from '../../../core/BufferAttribute.js';
+
 const refreshUniforms = [
     'alphaMap',
     'alphaTest',
@@ -49,10 +56,33 @@ const refreshUniforms = [
     'thickness',
     'transmission',
     'transmissionMap',
-];
+] as const;
+
+type RefreshUniform = (typeof refreshUniforms)[number];
+
+type MaterialData = {
+    [K in RefreshUniform]?: unknown;
+};
+
+interface AttributesData {
+    [name: string]: { version: number };
+}
+
+interface RenderObjectData {
+    material: MaterialData;
+    geometry: { attributes: AttributesData; indexVersion: number | null; drawRange: { start: number; count: number } };
+    worldMatrix: Matrix4;
+    version?: number;
+}
 
 class NodeMaterialObserver {
-    constructor(builder) {
+    renderObjects: WeakMap<RenderObject, RenderObjectData>;
+    hasNode: boolean;
+    hasAnimation: boolean;
+    refreshUniforms: readonly RefreshUniform[];
+    renderId: number;
+
+    constructor(builder: NodeBuilder) {
         this.renderObjects = new WeakMap();
         this.hasNode = this.containsNode(builder);
         this.hasAnimation = builder.object.isSkinnedMesh === true;
@@ -60,7 +90,7 @@ class NodeMaterialObserver {
         this.renderId = 0;
     }
 
-    firstInitialization(renderObject) {
+    firstInitialization(renderObject: RenderObject) {
         const hasInitialized = this.renderObjects.has(renderObject);
 
         if (hasInitialized === false) {
@@ -72,7 +102,7 @@ class NodeMaterialObserver {
         return false;
     }
 
-    getRenderObjectData(renderObject) {
+    getRenderObjectData(renderObject: RenderObject) {
         let data = this.renderObjects.get(renderObject);
 
         if (data === undefined) {
@@ -106,8 +136,8 @@ class NodeMaterialObserver {
         return data;
     }
 
-    getAttributesData(attributes) {
-        const attributesData = {};
+    getAttributesData(attributes: Record<string, BufferAttribute>) {
+        const attributesData: AttributesData = {};
 
         for (const name in attributes) {
             const attribute = attributes[name];
@@ -120,7 +150,7 @@ class NodeMaterialObserver {
         return attributesData;
     }
 
-    containsNode(builder) {
+    containsNode(builder: NodeBuilder) {
         const material = builder.material;
 
         for (const property in material) {
@@ -133,8 +163,8 @@ class NodeMaterialObserver {
         return false;
     }
 
-    getMaterialData(material) {
-        const data = {};
+    getMaterialData(material: Material) {
+        const data: MaterialData = {};
 
         for (const property of this.refreshUniforms) {
             const value = material[property];
@@ -155,7 +185,7 @@ class NodeMaterialObserver {
         return data;
     }
 
-    equals(renderObject) {
+    equals(renderObject: RenderObject) {
         const { object, material, geometry } = renderObject;
 
         const renderObjectData = this.getRenderObjectData(renderObject);
@@ -280,7 +310,7 @@ class NodeMaterialObserver {
         return true;
     }
 
-    needsRefresh(renderObject, nodeFrame) {
+    needsRefresh(renderObject: RenderObject, nodeFrame: NodeFrame) {
         if (this.hasNode || this.hasAnimation || this.firstInitialization(renderObject)) return true;
 
         const { renderId } = nodeFrame;
diff --git a/src-testing/src/nodes/accessors/BufferAttributeNode.ts b/src-testing/src/nodes/accessors/BufferAttributeNode.ts
index 97456dbc..c99ecb8a 100644
--- a/src-testing/src/nodes/accessors/BufferAttributeNode.ts
+++ b/src-testing/src/nodes/accessors/BufferAttributeNode.ts
@@ -4,14 +4,33 @@ import { varying } from '../core/VaryingNode.js';
 
 import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
 import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
-import { StaticDrawUsage, DynamicDrawUsage } from '../../constants.js';
+import { StaticDrawUsage, DynamicDrawUsage, Usage } from '../../constants.js';
+import { BufferAttribute, TypedArray } from '../../core/BufferAttribute.js';
+import { InstancedBufferAttribute } from '../../core/InstancedBufferAttribute.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
-class BufferAttributeNode extends InputNode {
+class BufferAttributeNode extends InputNode<TypedArray | InterleavedBuffer | BufferAttribute> {
     static get type() {
         return 'BufferAttributeNode';
     }
 
-    constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
+    readonly isBufferNode: true;
+
+    bufferType: string | null;
+    bufferStride: number;
+    bufferOffset: number;
+
+    usage: Usage;
+    instanced: boolean;
+
+    attribute: BufferAttribute | InterleavedBufferAttribute | null;
+
+    constructor(
+        value: TypedArray | InterleavedBuffer | BufferAttribute,
+        bufferType: string | null = null,
+        bufferStride = 0,
+        bufferOffset = 0,
+    ) {
         super(value, bufferType);
 
         this.isBufferNode = true;
@@ -27,14 +46,14 @@ class BufferAttributeNode extends InputNode {
 
         this.global = true;
 
-        if (value && value.isBufferAttribute === true) {
-            this.attribute = value;
-            this.usage = value.usage;
-            this.instanced = value.isInstancedBufferAttribute;
+        if (value && (value as BufferAttribute).isBufferAttribute === true) {
+            this.attribute = value as BufferAttribute;
+            this.usage = (value as BufferAttribute).usage;
+            this.instanced = (value as InstancedBufferAttribute).isInstancedBufferAttribute;
         }
     }
 
-    getHash(builder) {
+    getHash(builder: NodeBuilder) {
         if (this.bufferStride === 0 && this.bufferOffset === 0) {
             let bufferData = builder.globalCache.getData(this.value);
 
@@ -52,7 +71,7 @@ class BufferAttributeNode extends InputNode {
         return this.uuid;
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         if (this.bufferType === null) {
             this.bufferType = builder.getTypeFromAttribute(this.attribute);
         }
@@ -60,16 +79,19 @@ class BufferAttributeNode extends InputNode {
         return this.bufferType;
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         if (this.attribute !== null) return;
 
         const type = this.getNodeType(builder);
-        const array = this.value;
+        const array = this.value as TypedArray | InterleavedBuffer;
         const itemSize = builder.getTypeLength(type);
         const stride = this.bufferStride || itemSize;
         const offset = this.bufferOffset;
 
-        const buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer(array, stride);
+        const buffer =
+            (array as InterleavedBuffer).isInterleavedBuffer === true
+                ? (array as InterleavedBuffer)
+                : new InterleavedBuffer(array as TypedArray, stride);
         const bufferAttribute = new InterleavedBufferAttribute(buffer, itemSize, offset);
 
         buffer.setUsage(this.usage);
@@ -78,13 +100,13 @@ class BufferAttributeNode extends InputNode {
         this.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute
     }
 
-    generate(builder) {
+    generate(builder: NodeBuilder) {
         const nodeType = this.getNodeType(builder);
 
         const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);
         const propertyName = builder.getPropertyName(nodeAttribute);
 
-        let output = null;
+        let output: string | null | undefined = null;
 
         if (builder.shaderStage === 'vertex' || builder.shaderStage === 'compute') {
             this.name = propertyName;
@@ -103,17 +125,17 @@ class BufferAttributeNode extends InputNode {
         return 'bufferAttribute';
     }
 
-    setUsage(value) {
+    setUsage(value: Usage) {
         this.usage = value;
 
-        if (this.attribute && this.attribute.isBufferAttribute === true) {
-            this.attribute.usage = value;
+        if (this.attribute && (this.attribute as BufferAttribute).isBufferAttribute === true) {
+            (this.attribute as BufferAttribute).usage = value;
         }
 
         return this;
     }
 
-    setInstanced(value) {
+    setInstanced(value: boolean) {
         this.instanced = value;
 
         return this;
@@ -122,14 +144,30 @@ class BufferAttributeNode extends InputNode {
 
 export default BufferAttributeNode;
 
-export const bufferAttribute = (array, type, stride, offset) =>
-    nodeObject(new BufferAttributeNode(array, type, stride, offset));
-export const dynamicBufferAttribute = (array, type, stride, offset) =>
-    bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);
-
-export const instancedBufferAttribute = (array, type, stride, offset) =>
-    bufferAttribute(array, type, stride, offset).setInstanced(true);
-export const instancedDynamicBufferAttribute = (array, type, stride, offset) =>
-    dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);
+export const bufferAttribute = (
+    array: TypedArray | InterleavedBuffer | BufferAttribute,
+    type?: string | null,
+    stride?: number,
+    offset?: number,
+) => nodeObject(new BufferAttributeNode(array, type, stride, offset));
+export const dynamicBufferAttribute = (
+    array: TypedArray | InterleavedBuffer | BufferAttribute,
+    type?: string | null,
+    stride?: number,
+    offset?: number,
+) => bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);
+
+export const instancedBufferAttribute = (
+    array: TypedArray | InterleavedBuffer | BufferAttribute,
+    type?: string | null,
+    stride?: number,
+    offset?: number,
+) => bufferAttribute(array, type, stride, offset).setInstanced(true);
+export const instancedDynamicBufferAttribute = (
+    array: TypedArray | InterleavedBuffer | BufferAttribute,
+    type?: string | null,
+    stride?: number,
+    offset?: number,
+) => dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);
 
 addMethodChaining('toAttribute', bufferNode => bufferAttribute(bufferNode.value));
diff --git a/src-testing/src/nodes/accessors/TextureNode.ts b/src-testing/src/nodes/accessors/TextureNode.ts
index f97a04d1..31307477 100644
--- a/src-testing/src/nodes/accessors/TextureNode.ts
+++ b/src-testing/src/nodes/accessors/TextureNode.ts
@@ -4,17 +4,44 @@ import { textureSize } from './TextureSizeNode.js';
 import { colorSpaceToWorking } from '../display/ColorSpaceNode.js';
 import { expression } from '../code/ExpressionNode.js';
 import { maxMipLevel } from '../utils/MaxMipLevelNode.js';
-import { nodeProxy, vec3, nodeObject, int } from '../tsl/TSLBase.js';
+import { nodeProxy, vec3, nodeObject, int, ShaderNodeObject } from '../tsl/TSLBase.js';
 import { NodeUpdateType } from '../core/constants.js';
 
 import { IntType, UnsignedIntType } from '../../constants.js';
+import Node from '../core/Node.js';
+import { Texture } from '../../textures/Texture.js';
+import { DepthTexture } from '../../textures/DepthTexture.js';
+import NodeBuilder from '../core/NodeBuilder.js';
+import { Matrix3 } from '../../math/Matrix3.js';
 
-class TextureNode extends UniformNode {
+class TextureNode extends UniformNode<Texture> {
     static get type() {
         return 'TextureNode';
     }
 
-    constructor(value, uvNode = null, levelNode = null, biasNode = null) {
+    readonly isTextureNode: true;
+
+    uvNode: ShaderNodeObject<Node> | null;
+    levelNode: ShaderNodeObject<Node> | null;
+    biasNode: ShaderNodeObject<Node> | null;
+    compareNode: Node | null;
+    depthNode: Node | null;
+    gradNode: Node | null;
+
+    sampler: boolean;
+    updateMatrix: boolean;
+
+    referenceNode: this | null;
+
+    _value: Texture;
+    _matrixUniform: ShaderNodeObject<UniformNode<Matrix3>> | null;
+
+    constructor(
+        value: Texture,
+        uvNode: ShaderNodeObject<Node> | null = null,
+        levelNode: ShaderNodeObject<Node> | null = null,
+        biasNode: ShaderNodeObject<Node> | null = null,
+    ) {
         super(value);
 
         this.isTextureNode = true;
@@ -38,7 +65,7 @@ class TextureNode extends UniformNode {
         this.setUpdateMatrix(uvNode === null);
     }
 
-    set value(value) {
+    set value(value: Texture) {
         if (this.referenceNode) {
             this.referenceNode.value = value;
         } else {
@@ -55,7 +82,7 @@ class TextureNode extends UniformNode {
     }
 
     getNodeType(/*builder*/) {
-        if (this.value.isDepthTexture === true) return 'float';
+        if ((this.value as DepthTexture).isDepthTexture === true) return 'float';
 
         if (this.value.type === UnsignedIntType) {
             return 'uvec4';
@@ -84,14 +111,14 @@ class TextureNode extends UniformNode {
         return this._matrixUniform.mul(vec3(uvNode, 1)).xy;
     }
 
-    setUpdateMatrix(value) {
+    setUpdateMatrix(value: boolean) {
         this.updateMatrix = value;
         this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;
 
         return this;
     }
 
-    setupUV(builder, uvNode) {
+    setupUV(builder: NodeBuilder, uvNode) {
         const texture = this.value;
 
         if (
@@ -110,7 +137,7 @@ class TextureNode extends UniformNode {
         return uvNode;
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         const properties = builder.getNodeProperties(this);
         properties.referenceNode = this.referenceNode;
 
@@ -148,19 +175,19 @@ class TextureNode extends UniformNode {
         properties.depthNode = this.depthNode;
     }
 
-    generateUV(builder, uvNode) {
+    generateUV(builder: NodeBuilder, uvNode: Node) {
         return uvNode.build(builder, this.sampler === true ? 'vec2' : 'ivec2');
     }
 
     generateSnippet(
-        builder,
-        textureProperty,
-        uvSnippet,
-        levelSnippet,
-        biasSnippet,
-        depthSnippet,
-        compareSnippet,
-        gradSnippet,
+        builder: NodeBuilder,
+        textureProperty: string,
+        uvSnippet: string | null,
+        levelSnippet: string | null,
+        biasSnippet: string | null,
+        depthSnippet: string | null,
+        compareSnippet: string | null,
+        gradSnippet: [string, string] | null,
     ) {
         const texture = this.value;
 
@@ -183,7 +210,7 @@ class TextureNode extends UniformNode {
         return snippet;
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output) {
         const properties = builder.getNodeProperties(this);
 
         const texture = this.value;
@@ -249,7 +276,7 @@ class TextureNode extends UniformNode {
         }
     }
 
-    setSampler(value) {
+    setSampler(value: boolean) {
         this.sampler = value;
 
         return this;
@@ -261,7 +288,7 @@ class TextureNode extends UniformNode {
 
     // @TODO: Move to TSL
 
-    uv(uvNode) {
+    uv(uvNode: ShaderNodeObject<Node> | null) {
         const textureNode = this.clone();
         textureNode.uvNode = nodeObject(uvNode);
         textureNode.referenceNode = this.getSelf();
@@ -269,7 +296,7 @@ class TextureNode extends UniformNode {
         return nodeObject(textureNode);
     }
 
-    blur(amountNode) {
+    blur(amountNode: ShaderNodeObject<Node>) {
         const textureNode = this.clone();
         textureNode.biasNode = nodeObject(amountNode).mul(maxMipLevel(textureNode));
         textureNode.referenceNode = this.getSelf();
@@ -277,7 +304,7 @@ class TextureNode extends UniformNode {
         return nodeObject(textureNode);
     }
 
-    level(levelNode) {
+    level(levelNode: ShaderNodeObject<Node> | null) {
         const textureNode = this.clone();
         textureNode.levelNode = nodeObject(levelNode);
         textureNode.referenceNode = this.getSelf();
diff --git a/src-testing/src/nodes/code/CodeNode.ts b/src-testing/src/nodes/code/CodeNode.ts
index 2f4c6051..2560bdb8 100644
--- a/src-testing/src/nodes/code/CodeNode.ts
+++ b/src-testing/src/nodes/code/CodeNode.ts
@@ -1,11 +1,17 @@
 import Node from '../core/Node.js';
 import { nodeProxy } from '../tsl/TSLBase.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 class CodeNode extends Node {
     static get type() {
         return 'CodeNode';
     }
 
+    readonly isCodeNode: true;
+
+    code: string;
+    language: string;
+
     constructor(code = '', includes = [], language = '') {
         super('code');
 
@@ -27,11 +33,11 @@ class CodeNode extends Node {
         return this;
     }
 
-    getIncludes(/*builder*/) {
+    getIncludes(builder: NodeBuilder) {
         return this.includes;
     }
 
-    generate(builder) {
+    generate(builder: NodeBuilder) {
         const includes = this.getIncludes(builder);
 
         for (const include of includes) {
diff --git a/src-testing/src/nodes/code/FunctionNode.ts b/src-testing/src/nodes/code/FunctionNode.ts
index 54d8a5c5..6e1282b4 100644
--- a/src-testing/src/nodes/code/FunctionNode.ts
+++ b/src-testing/src/nodes/code/FunctionNode.ts
@@ -1,5 +1,6 @@
 import CodeNode from './CodeNode.js';
 import { nodeObject } from '../tsl/TSLBase.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 class FunctionNode extends CodeNode {
     static get type() {
@@ -10,15 +11,15 @@ class FunctionNode extends CodeNode {
         super(code, includes, language);
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.getNodeFunction(builder).type;
     }
 
-    getInputs(builder) {
+    getInputs(builder: NodeBuilder) {
         return this.getNodeFunction(builder).inputs;
     }
 
-    getNodeFunction(builder) {
+    getNodeFunction(builder: NodeBuilder) {
         const nodeData = builder.getDataFromNode(this);
 
         let nodeFunction = nodeData.nodeFunction;
@@ -32,7 +33,7 @@ class FunctionNode extends CodeNode {
         return nodeFunction;
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null) {
         super.generate(builder);
 
         const nodeFunction = this.getNodeFunction(builder);
@@ -64,7 +65,7 @@ class FunctionNode extends CodeNode {
 
 export default FunctionNode;
 
-const nativeFn = (code, includes = [], language = '') => {
+const nativeFn = (code: string, includes = [], language = '') => {
     for (let i = 0; i < includes.length; i++) {
         const include = includes[i];
 
@@ -83,5 +84,5 @@ const nativeFn = (code, includes = [], language = '') => {
     return fn;
 };
 
-export const glslFn = (code, includes) => nativeFn(code, includes, 'glsl');
-export const wgslFn = (code, includes) => nativeFn(code, includes, 'wgsl');
+export const glslFn = (code: string, includes) => nativeFn(code, includes, 'glsl');
+export const wgslFn = (code: string, includes) => nativeFn(code, includes, 'wgsl');
diff --git a/src-testing/src/nodes/core/ContextNode.ts b/src-testing/src/nodes/core/ContextNode.ts
index 32b8ac0a..f61425de 100644
--- a/src-testing/src/nodes/core/ContextNode.ts
+++ b/src-testing/src/nodes/core/ContextNode.ts
@@ -1,12 +1,18 @@
 import Node from './Node.js';
-import { addMethodChaining, nodeProxy } from '../tsl/TSLCore.js';
+import { addMethodChaining, nodeProxy, NodeRepresentation } from '../tsl/TSLCore.js';
+import NodeBuilder from './NodeBuilder.js';
 
-class ContextNode extends Node {
+class ContextNode<TContext> extends Node {
     static get type() {
         return 'ContextNode';
     }
 
-    constructor(node, value = {}) {
+    readonly isContextNode: true;
+
+    node: Node;
+    value: TContext;
+
+    constructor(node: Node, value: TContext = {} as TContext) {
         super();
 
         this.isContextNode = true;
@@ -19,15 +25,15 @@ class ContextNode extends Node {
         return this.node.getScope();
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.node.getNodeType(builder);
     }
 
-    analyze(builder) {
+    analyze(builder: NodeBuilder) {
         this.node.build(builder);
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         const previousContext = builder.getContext();
 
         builder.setContext({ ...builder.context, ...this.value });
@@ -39,7 +45,7 @@ class ContextNode extends Node {
         return node;
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null) {
         const previousContext = builder.getContext();
 
         builder.setContext({ ...builder.context, ...this.value });
@@ -55,7 +61,7 @@ class ContextNode extends Node {
 export default ContextNode;
 
 export const context = /*@__PURE__*/ nodeProxy(ContextNode);
-export const label = (node, name) => context(node, { label: name });
+export const label = (node: NodeRepresentation, name: string) => context(node, { label: name });
 
 addMethodChaining('context', context);
 addMethodChaining('label', label);
diff --git a/src-testing/src/nodes/core/InputNode.ts b/src-testing/src/nodes/core/InputNode.ts
index 07af45dc..85bc5537 100644
--- a/src-testing/src/nodes/core/InputNode.ts
+++ b/src-testing/src/nodes/core/InputNode.ts
@@ -1,12 +1,18 @@
 import Node from './Node.js';
 import { getValueType, getValueFromType, arrayBufferToBase64 } from './NodeUtils.js';
+import NodeBuilder from './NodeBuilder.js';
 
-class InputNode extends Node {
+class InputNode<TValue> extends Node {
     static get type() {
         return 'InputNode';
     }
 
-    constructor(value, nodeType = null) {
+    readonly isInputNode: true;
+
+    value: TValue;
+    precision: 'low' | 'medium' | 'high' | null;
+
+    constructor(value: TValue, nodeType: string | null = null) {
         super(nodeType);
 
         this.isInputNode = true;
@@ -15,7 +21,7 @@ class InputNode extends Node {
         this.precision = null;
     }
 
-    getNodeType(/*builder*/) {
+    getNodeType(builder: NodeBuilder) {
         if (this.nodeType === null) {
             return getValueType(this.value);
         }
@@ -23,11 +29,11 @@ class InputNode extends Node {
         return this.nodeType;
     }
 
-    getInputType(builder) {
+    getInputType(builder: NodeBuilder) {
         return this.getNodeType(builder);
     }
 
-    setPrecision(precision) {
+    setPrecision(precision: 'low' | 'medium' | 'high' | null) {
         this.precision = precision;
 
         return this;
@@ -58,10 +64,6 @@ class InputNode extends Node {
 
         if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);
     }
-
-    generate(/*builder, output*/) {
-        console.warn('Abstract function.');
-    }
 }
 
 export default InputNode;
diff --git a/src-testing/src/nodes/core/Node.ts b/src-testing/src/nodes/core/Node.ts
index 20ea15c5..a2b6bef7 100644
--- a/src-testing/src/nodes/core/Node.ts
+++ b/src-testing/src/nodes/core/Node.ts
@@ -3,15 +3,93 @@ import { getNodeChildren, getCacheKey } from './NodeUtils.js';
 
 import { EventDispatcher } from '../../core/EventDispatcher.js';
 import { MathUtils } from '../../math/MathUtils.js';
+import NodeFrame from './NodeFrame.js';
+import NodeBuilder from './NodeBuilder.js';
 
 let _nodeId = 0;
 
-class Node extends EventDispatcher {
+interface NodeConstructor {
+    type?: string;
+}
+
+interface NodeJSONMeta {
+    textures: { [key: string]: unknown };
+    images: { [key: string]: unknown };
+    nodes: { [key: string]: NodeJSONIntermediateOutputData };
+}
+
+interface NodeJSONMetadata {
+    version: number;
+    type: 'Node';
+    generator: 'Node.toJSON';
+}
+
+interface NodeJSONInputNodes {
+    [property: string]:
+        | string[]
+        | {
+              [index: string]: string | undefined;
+          }
+        | string
+        | undefined;
+}
+
+export interface NodeJSONInputData {
+    inputNodes?: NodeJSONInputNodes | undefined;
+    meta: {
+        textures: { [key: string]: unknown };
+        nodes: { [key: string]: Node };
+    };
+}
+
+export interface NodeJSONIntermediateOutputData {
+    uuid: string;
+    type: string | undefined;
+    meta?: NodeJSONMeta | undefined;
+    metadata?: NodeJSONMetadata;
+    inputNodes?: NodeJSONInputNodes | undefined;
+    textures?: unknown[];
+    images?: unknown[];
+    nodes?: NodeJSONIntermediateOutputData[];
+}
+
+interface NodeJSONOutputData {
+    uuid: string;
+    type: string | undefined;
+    metadata?: NodeJSONMetadata;
+    inputNodes?: NodeJSONInputNodes | undefined;
+    textures?: unknown[];
+    images?: unknown[];
+    nodes?: NodeJSONOutputData[];
+}
+
+class Node extends EventDispatcher<{ dispose: {} }> {
     static get type() {
         return 'Node';
     }
 
-    constructor(nodeType = null) {
+    nodeType: string | null;
+
+    updateType: NodeUpdateType;
+    updateBeforeType: NodeUpdateType;
+    updateAfterType: NodeUpdateType;
+
+    uuid: string;
+
+    version: number;
+
+    _cacheKey: number | null;
+    _cacheKeyVersion: number;
+
+    global: boolean;
+
+    readonly isNode: true;
+
+    readonly id!: number;
+
+    self?: this;
+
+    constructor(nodeType: string | null = null) {
         super();
 
         this.nodeType = nodeType;
@@ -34,36 +112,36 @@ class Node extends EventDispatcher {
         Object.defineProperty(this, 'id', { value: _nodeId++ });
     }
 
-    set needsUpdate(value) {
+    set needsUpdate(value: boolean) {
         if (value === true) {
             this.version++;
         }
     }
 
     get type() {
-        return this.constructor.type;
+        return (this.constructor as NodeConstructor).type;
     }
 
-    onUpdate(callback, updateType) {
+    onUpdate(callback: (this: this, frame: NodeFrame) => unknown, updateType: NodeUpdateType) {
         this.updateType = updateType;
         this.update = callback.bind(this.getSelf());
 
         return this;
     }
 
-    onFrameUpdate(callback) {
+    onFrameUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.FRAME);
     }
 
-    onRenderUpdate(callback) {
+    onRenderUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.RENDER);
     }
 
-    onObjectUpdate(callback) {
+    onObjectUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.OBJECT);
     }
 
-    onReference(callback) {
+    onReference(callback: (this: this, frame: NodeBuilder | NodeFrame) => unknown) {
         this.updateReference = callback.bind(this.getSelf());
 
         return this;
@@ -75,11 +153,11 @@ class Node extends EventDispatcher {
         return this.self || this;
     }
 
-    updateReference(/*state*/) {
+    updateReference(state: NodeBuilder | NodeFrame): unknown {
         return this;
     }
 
-    isGlobal(/*builder*/) {
+    isGlobal(builder: NodeBuilder) {
         return this.global;
     }
 
@@ -93,7 +171,7 @@ class Node extends EventDispatcher {
         this.dispatchEvent({ type: 'dispose' });
     }
 
-    traverse(callback) {
+    traverse(callback: (node: Node) => void) {
         callback(this);
 
         for (const childNode of this.getChildren()) {
@@ -116,7 +194,7 @@ class Node extends EventDispatcher {
         return this;
     }
 
-    getHash(/*builder*/) {
+    getHash(builder: NodeBuilder) {
         return this.uuid;
     }
 
@@ -132,14 +210,14 @@ class Node extends EventDispatcher {
         return this.updateAfterType;
     }
 
-    getElementType(builder) {
+    getElementType(builder: NodeBuilder) {
         const type = this.getNodeType(builder);
         const elementType = builder.getElementType(type);
 
         return elementType;
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder): string | null {
         const nodeProperties = builder.getNodeProperties(this);
 
         if (nodeProperties.outputNode) {
@@ -149,27 +227,27 @@ class Node extends EventDispatcher {
         return this.nodeType;
     }
 
-    getShared(builder) {
+    getShared(builder: NodeBuilder) {
         const hash = this.getHash(builder);
         const nodeFromHash = builder.getNodeFromHash(hash);
 
         return nodeFromHash || this;
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder): unknown {
         const nodeProperties = builder.getNodeProperties(this);
 
         let index = 0;
 
         for (const childNode of this.getChildren()) {
-            nodeProperties['node' + index++] = childNode;
+            nodeProperties[`node${index++}`] = childNode;
         }
 
         // return a outputNode if exists
         return null;
     }
 
-    analyze(builder) {
+    analyze(builder: NodeBuilder) {
         const usageCount = builder.increaseUsage(this);
 
         if (usageCount === 1) {
@@ -178,14 +256,14 @@ class Node extends EventDispatcher {
             const nodeProperties = builder.getNodeProperties(this);
 
             for (const childNode of Object.values(nodeProperties)) {
-                if (childNode && childNode.isNode === true) {
-                    childNode.build(builder);
+                if (childNode && (childNode as Node).isNode === true) {
+                    (childNode as Node).build(builder);
                 }
             }
         }
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null): string | null | undefined {
         const { outputNode } = builder.getNodeProperties(this);
 
         if (outputNode && outputNode.isNode === true) {
@@ -193,19 +271,19 @@ class Node extends EventDispatcher {
         }
     }
 
-    updateBefore(/*frame*/) {
+    updateBefore(frame: NodeFrame) {
         console.warn('Abstract function.');
     }
 
-    updateAfter(/*frame*/) {
+    updateAfter(frame: NodeFrame) {
         console.warn('Abstract function.');
     }
 
-    update(/*frame*/) {
+    update(frame: NodeFrame) {
         console.warn('Abstract function.');
     }
 
-    build(builder, output = null) {
+    build(builder: NodeBuilder, output: string | null = null): string | null {
         const refNode = this.getShared(builder);
 
         if (this !== refNode) {
@@ -241,8 +319,8 @@ class Node extends EventDispatcher {
                 }
 
                 for (const childNode of Object.values(properties)) {
-                    if (childNode && childNode.isNode === true) {
-                        childNode.build(builder);
+                    if (childNode && (childNode as Node).isNode === true) {
+                        (childNode as Node).build(builder);
                     }
                 }
             }
@@ -280,10 +358,10 @@ class Node extends EventDispatcher {
         return getNodeChildren(this);
     }
 
-    serialize(json) {
+    serialize(json: NodeJSONIntermediateOutputData) {
         const nodeChildren = this.getSerializeChildren();
 
-        const inputNodes = {};
+        const inputNodes: NodeJSONInputNodes = {};
 
         for (const { property, index, childNode } of nodeChildren) {
             if (index !== undefined) {
@@ -291,7 +369,9 @@ class Node extends EventDispatcher {
                     inputNodes[property] = Number.isInteger(index) ? [] : {};
                 }
 
-                inputNodes[property][index] = childNode.toJSON(json.meta).uuid;
+                (inputNodes[property]! as { [index: number | string]: string })[index] = childNode.toJSON(
+                    json.meta,
+                ).uuid;
             } else {
                 inputNodes[property] = childNode.toJSON(json.meta).uuid;
             }
@@ -302,39 +382,39 @@ class Node extends EventDispatcher {
         }
     }
 
-    deserialize(json) {
+    deserialize(json: NodeJSONInputData) {
         if (json.inputNodes !== undefined) {
             const nodes = json.meta.nodes;
 
             for (const property in json.inputNodes) {
                 if (Array.isArray(json.inputNodes[property])) {
-                    const inputArray = [];
+                    const inputArray: Node[] = [];
 
-                    for (const uuid of json.inputNodes[property]) {
+                    for (const uuid of json.inputNodes[property] as string[]) {
                         inputArray.push(nodes[uuid]);
                     }
 
-                    this[property] = inputArray;
+                    (this[property as keyof typeof this] as Node[]) = inputArray;
                 } else if (typeof json.inputNodes[property] === 'object') {
-                    const inputObject = {};
+                    const inputObject: { [subProperty: string]: Node } = {};
 
-                    for (const subProperty in json.inputNodes[property]) {
-                        const uuid = json.inputNodes[property][subProperty];
+                    for (const subProperty in json.inputNodes[property] as { [subProperty: string]: string }) {
+                        const uuid = (json.inputNodes[property] as { [subProperty: string]: string })[subProperty];
 
                         inputObject[subProperty] = nodes[uuid];
                     }
 
-                    this[property] = inputObject;
+                    (this[property as keyof typeof this] as { [subProperty: string]: Node }) = inputObject;
                 } else {
-                    const uuid = json.inputNodes[property];
+                    const uuid = json.inputNodes[property] as string;
 
-                    this[property] = nodes[uuid];
+                    (this[property as keyof typeof this] as Node) = nodes[uuid];
                 }
             }
         }
     }
 
-    toJSON(meta) {
+    toJSON(meta?: NodeJSONMeta | string): NodeJSONOutputData {
         const { uuid, type } = this;
         const isRoot = meta === undefined || typeof meta === 'string';
 
@@ -343,18 +423,18 @@ class Node extends EventDispatcher {
                 textures: {},
                 images: {},
                 nodes: {},
-            };
+            } satisfies NodeJSONMeta;
         }
 
         // serialize
 
-        let data = meta.nodes[uuid];
+        let data = (meta as NodeJSONMeta).nodes[uuid];
 
         if (data === undefined) {
             data = {
                 uuid,
                 type,
-                meta,
+                meta: meta as NodeJSONMeta,
                 metadata: {
                     version: 4.6,
                     type: 'Node',
@@ -362,7 +442,7 @@ class Node extends EventDispatcher {
                 },
             };
 
-            if (isRoot !== true) meta.nodes[data.uuid] = data;
+            if (isRoot !== true) (meta as NodeJSONMeta).nodes[data.uuid] = data;
 
             this.serialize(data);
 
@@ -371,12 +451,12 @@ class Node extends EventDispatcher {
 
         // TODO: Copied from Object3D.toJSON
 
-        function extractFromCache(cache) {
+        function extractFromCache<T>(cache: { [key: string]: T }) {
             const values = [];
 
             for (const key in cache) {
                 const data = cache[key];
-                delete data.metadata;
+                delete (data as NodeJSONIntermediateOutputData).metadata;
                 values.push(data);
             }
 
@@ -384,9 +464,9 @@ class Node extends EventDispatcher {
         }
 
         if (isRoot) {
-            const textures = extractFromCache(meta.textures);
-            const images = extractFromCache(meta.images);
-            const nodes = extractFromCache(meta.nodes);
+            const textures = extractFromCache((meta as NodeJSONMeta).textures);
+            const images = extractFromCache((meta as NodeJSONMeta).images);
+            const nodes = extractFromCache((meta as NodeJSONMeta).nodes);
 
             if (textures.length > 0) data.textures = textures;
             if (images.length > 0) data.images = images;
diff --git a/src-testing/src/nodes/core/NodeAttribute.ts b/src-testing/src/nodes/core/NodeAttribute.ts
index 190fe8c5..d873bb24 100644
--- a/src-testing/src/nodes/core/NodeAttribute.ts
+++ b/src-testing/src/nodes/core/NodeAttribute.ts
@@ -1,5 +1,13 @@
+import Node from './Node.js';
+
 class NodeAttribute {
-    constructor(name, type, node = null) {
+    readonly isNodeAttribute: true;
+
+    name: string;
+    type: string | null;
+    node: Node | null;
+
+    constructor(name: string, type: string | null, node: Node | null = null) {
         this.isNodeAttribute = true;
 
         this.name = name;
diff --git a/src-testing/src/nodes/core/NodeBuilder.ts b/src-testing/src/nodes/core/NodeBuilder.ts
index 36477c8f..3b07d7e0 100644
--- a/src-testing/src/nodes/core/NodeBuilder.ts
+++ b/src-testing/src/nodes/core/NodeBuilder.ts
@@ -7,7 +7,7 @@ import NodeCache from './NodeCache.js';
 import ParameterNode from './ParameterNode.js';
 import FunctionNode from '../code/FunctionNode.js';
 import NodeMaterial from '../../materials/nodes/NodeMaterial.js';
-import { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';
+import { NodeUpdateType, defaultBuildStages, shaderStages, NodeShaderStage } from './constants.js';
 
 import {
     NumberNodeUniform,
@@ -19,8 +19,8 @@ import {
     Matrix4NodeUniform,
 } from '../../renderers/common/nodes/NodeUniform.js';
 
-import { stack } from './StackNode.js';
-import { getCurrentStack, setCurrentStack } from '../tsl/TSLBase.js';
+import StackNode, { stack } from './StackNode.js';
+import { getCurrentStack, setCurrentStack, ShaderNodeInternal, ShaderNodeObject } from '../tsl/TSLBase.js';
 
 import CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';
 import ChainMap from '../../renderers/common/ChainMap.js';
@@ -30,12 +30,12 @@ import PMREMGenerator from '../../renderers/common/extras/PMREMGenerator.js';
 import BindGroup from '../../renderers/common/BindGroup.js';
 
 import { REVISION } from '../../constants.js';
-import { RenderTarget } from '../../core/RenderTarget.js';
+import { RenderTarget, RenderTargetOptions } from '../../core/RenderTarget.js';
 import { Color } from '../../math/Color.js';
 import { Vector2 } from '../../math/Vector2.js';
 import { Vector3 } from '../../math/Vector3.js';
 import { Vector4 } from '../../math/Vector4.js';
-import { Float16BufferAttribute } from '../../core/BufferAttribute.js';
+import { BufferAttribute, Float16BufferAttribute, TypedArray } from '../../core/BufferAttribute.js';
 import {
     IntType,
     UnsignedIntType,
@@ -44,8 +44,32 @@ import {
     NearestMipmapLinearFilter,
     LinearMipmapLinearFilter,
 } from '../../constants.js';
-
-const rendererCache = new WeakMap();
+import Renderer from '../../renderers/common/Renderer.js';
+import UniformNode from './UniformNode.js';
+import NodeUniformsGroup from '../../renderers/common/nodes/NodeUniformsGroup.js';
+import { Material } from '../../materials/Material.js';
+import { Object3D } from '../../core/Object3D.js';
+import { BufferGeometry } from '../../core/BufferGeometry.js';
+import NodeParser from './NodeParser.js';
+import { Scene } from '../../scenes/Scene.js';
+import { Camera } from '../../cameras/Camera.js';
+import Node from './Node.js';
+import LightsNode from '../lighting/LightsNode.js';
+import EnvironmentNode from '../lighting/EnvironmentNode.js';
+import FogNode from '../fog/FogNode.js';
+import ClippingContext from '../../renderers/common/ClippingContext.js';
+import StructTypeNode from './StructTypeNode.js';
+import { Mesh } from '../../objects/Mesh.js';
+import { Texture } from '../../textures/Texture.js';
+import { Matrix3 } from '../../math/Matrix3.js';
+import { Matrix4 } from '../../math/Matrix4.js';
+import { DataTexture } from '../../textures/DataTexture.js';
+import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
+
+const rendererCache = new WeakMap<
+    Renderer,
+    ChainMap<UniformNode<unknown>[] | NodeUniformsGroup[], NodeUniformsGroup | BindGroup>
+>();
 
 const typeFromLength = new Map([
     [2, 'vec2'],
@@ -55,7 +79,16 @@ const typeFromLength = new Map([
     [16, 'mat4'],
 ]);
 
-const typeFromArray = new Map([
+type TypedArrayConstructor =
+    | typeof Int8Array
+    | typeof Int16Array
+    | typeof Int32Array
+    | typeof Uint8Array
+    | typeof Uint16Array
+    | typeof Uint32Array
+    | typeof Float32Array;
+
+const typeFromArray = new Map<TypedArrayConstructor, string>([
     [Int8Array, 'int'],
     [Int16Array, 'int'],
     [Int32Array, 'int'],
@@ -65,21 +98,99 @@ const typeFromArray = new Map([
     [Float32Array, 'float'],
 ]);
 
-const toFloat = value => {
+const toFloat = (value: unknown) => {
     if (/e/g.test(value)) {
         return String(value).replace(/\+/g, '');
     } else {
         value = Number(value);
 
-        return value + (value % 1 ? '' : '.0');
+        return value + ((value as number) % 1 ? '' : '.0');
     }
 };
 
-class NodeBuilder {
-    constructor(object, renderer, parser) {
+interface Flow {
+    code: string;
+    result?: string | null | undefined;
+    vars?: string | undefined;
+}
+
+interface Context {
+    material: Material | Material[] | null;
+    tempRead?: boolean;
+}
+
+abstract class NodeBuilder {
+    object: Object3D | null;
+    material: Material | Material[] | null;
+    geometry: BufferGeometry | null;
+    renderer: Renderer;
+    parser: NodeParser;
+    scene: Scene | null;
+    camera: Camera | null;
+
+    nodes: Node[];
+    updateNodes: Node[];
+    updateBeforeNodes: Node[];
+    updateAfterNodes: Node[];
+    hashNodes: { [hash: string]: Node };
+
+    lightsNode: LightsNode | null;
+    environmentNode: EnvironmentNode | null;
+    fogNode: FogNode | null;
+
+    clippingContext: ClippingContext | null;
+
+    vertexShader: string | null;
+    fragmentShader: string | null;
+    computeShader: string | null;
+
+    flowNodes: { vertex: Node[]; fragment: Node[]; compute: Node[] };
+    flowCode: { vertex: string; fragment: string; compute: string };
+    uniforms: {
+        vertex: NodeUniform<unknown>[];
+        fragment: NodeUniform<unknown>[];
+        compute: NodeUniform<unknown>[];
+        index: number;
+    };
+    structs: { vertex: StructTypeNode[]; fragment: StructTypeNode[]; compute: StructTypeNode[]; index: number };
+    bindings: {
+        vertex: { [groupName: string]: NodeUniformsGroup[] | undefined };
+        fragment: { [groupName: string]: NodeUniformsGroup[] | undefined };
+        compute: { [groupName: string]: NodeUniformsGroup[] | undefined };
+    };
+    bindingsIndexes: { [groupName: string]: { binding: number; group: number } | undefined };
+    bindGroups: BindGroup[] | null;
+    attributes: NodeAttribute[];
+    bufferAttributes: NodeAttribute[];
+    varyings: NodeVarying[];
+    codes: { vertex?: NodeCode[] | undefined; fragment?: NodeCode[] | undefined; compute?: NodeCode[] | undefined };
+    vars: { vertex?: NodeVar[] | undefined; fragment?: NodeVar[] | undefined; compute?: NodeVar[] | undefined };
+    flow: Flow;
+    chaining: Node[];
+    stack: ShaderNodeObject<StackNode>;
+    stacks: ShaderNodeObject<StackNode>[];
+    tab: string;
+
+    instanceBindGroups: boolean;
+
+    currentFunctionNode: FunctionNode | null;
+
+    context: Context;
+
+    cache: NodeCache;
+    globalCache: NodeCache;
+
+    flowsData: WeakMap<Node, Flow>;
+
+    shaderStage: NodeShaderStage | null;
+    buildStage: string | null;
+
+    useComparisonMethod: boolean;
+
+    constructor(object: Object3D | null, renderer: Renderer, parser: NodeParser) {
         this.object = object;
-        this.material = (object && object.material) || null;
-        this.geometry = (object && object.geometry) || null;
+        this.material = (object && (object as Mesh).material) || null;
+        this.geometry = (object && (object as Mesh).geometry) || null;
         this.renderer = renderer;
         this.parser = parser;
         this.scene = null;
@@ -130,7 +241,7 @@ class NodeBuilder {
         this.cache = new NodeCache();
         this.globalCache = this.cache;
 
-        this.flowsData = new WeakMap();
+        this.flowsData = new WeakMap<Node, Flow>();
 
         this.shaderStage = null;
         this.buildStage = null;
@@ -150,11 +261,11 @@ class NodeBuilder {
         return bindGroupsCache;
     }
 
-    createRenderTarget(width, height, options) {
+    createRenderTarget(width?: number, height?: number, options?: RenderTargetOptions) {
         return new RenderTarget(width, height, options);
     }
 
-    createCubeRenderTarget(size, options) {
+    createCubeRenderTarget(size?: number, options?: RenderTargetOptions) {
         return new CubeRenderTarget(size, options);
     }
 
@@ -164,16 +275,16 @@ class NodeBuilder {
         return new PMREMGenerator(this.renderer);
     }
 
-    includes(node) {
+    includes(node: Node) {
         return this.nodes.includes(node);
     }
 
-    _getBindGroup(groupName, bindings) {
+    _getBindGroup(groupName: string, bindings: NodeUniformsGroup[]) {
         const bindGroupsCache = this.getBindGroupsCache();
 
         //
 
-        const bindingsArray = [];
+        const bindingsArray: NodeUniformsGroup[] = [];
 
         let sharedGroup = true;
 
@@ -188,26 +299,26 @@ class NodeBuilder {
         let bindGroup;
 
         if (sharedGroup) {
-            bindGroup = bindGroupsCache.get(bindingsArray);
+            bindGroup = bindGroupsCache.get(bindingsArray) as BindGroup | undefined;
 
             if (bindGroup === undefined) {
                 bindGroup = new BindGroup(
                     groupName,
                     bindingsArray,
-                    this.bindingsIndexes[groupName].group,
+                    this.bindingsIndexes[groupName]!.group,
                     bindingsArray,
                 );
 
                 bindGroupsCache.set(bindingsArray, bindGroup);
             }
         } else {
-            bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);
+            bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName]!.group, bindingsArray);
         }
 
         return bindGroup;
     }
 
-    getBindGroupArray(groupName, shaderStage) {
+    getBindGroupArray(groupName: string, shaderStage: NodeShaderStage) {
         const bindings = this.bindings[shaderStage];
 
         let bindGroup = bindings[groupName];
@@ -227,12 +338,12 @@ class NodeBuilder {
         let bindingsGroups = this.bindGroups;
 
         if (bindingsGroups === null) {
-            const groups = {};
+            const groups: { [groupName: string]: NodeUniformsGroup[] | undefined } = {};
             const bindings = this.bindings;
 
             for (const shaderStage of shaderStages) {
                 for (const groupName in bindings[shaderStage]) {
-                    const uniforms = bindings[shaderStage][groupName];
+                    const uniforms = bindings[shaderStage][groupName]!;
 
                     const groupUniforms = groups[groupName] || (groups[groupName] = []);
                     groupUniforms.push(...uniforms);
@@ -242,7 +353,7 @@ class NodeBuilder {
             bindingsGroups = [];
 
             for (const groupName in groups) {
-                const group = groups[groupName];
+                const group = groups[groupName]!;
 
                 const bindingsGroup = this._getBindGroup(groupName, group);
 
@@ -268,11 +379,11 @@ class NodeBuilder {
         }
     }
 
-    setHashNode(node, hash) {
+    setHashNode(node: Node, hash: string) {
         this.hashNodes[hash] = node;
     }
 
-    addNode(node) {
+    addNode(node: Node) {
         if (this.nodes.includes(node) === false) {
             this.nodes.push(node);
 
@@ -304,7 +415,7 @@ class NodeBuilder {
         return this.chaining[this.chaining.length - 1];
     }
 
-    isFilteredTexture(texture) {
+    isFilteredTexture(texture: Texture) {
         return (
             texture.magFilter === LinearFilter ||
             texture.magFilter === LinearMipmapNearestFilter ||
@@ -317,7 +428,7 @@ class NodeBuilder {
         );
     }
 
-    addChain(node) {
+    addChain(node: Node) {
         /*
 		if ( this.chaining.indexOf( node ) !== - 1 ) {
 
@@ -329,7 +440,7 @@ class NodeBuilder {
         this.chaining.push(node);
     }
 
-    removeChain(node) {
+    removeChain(node: Node) {
         const lastChain = this.chaining.pop();
 
         if (lastChain !== node) {
@@ -337,21 +448,21 @@ class NodeBuilder {
         }
     }
 
-    getMethod(method) {
+    getMethod(method: string) {
         return method;
     }
 
-    getNodeFromHash(hash) {
+    getNodeFromHash(hash: string) {
         return this.hashNodes[hash];
     }
 
-    addFlow(shaderStage, node) {
+    addFlow(shaderStage: NodeShaderStage, node: Node) {
         this.flowNodes[shaderStage].push(node);
 
         return node;
     }
 
-    setContext(context) {
+    setContext(context: Context) {
         this.context = context;
     }
 
@@ -367,7 +478,7 @@ class NodeBuilder {
         return this.context;
     }
 
-    setCache(cache) {
+    setCache(cache: NodeCache) {
         this.cache = cache;
     }
 
@@ -375,14 +486,14 @@ class NodeBuilder {
         return this.cache;
     }
 
-    getCacheFromNode(node, parent = true) {
+    getCacheFromNode(node: Node, parent = true) {
         const data = this.getDataFromNode(node);
         if (data.cache === undefined) data.cache = new NodeCache(parent ? this.getCache() : null);
 
         return data.cache;
     }
 
-    isAvailable(/*name*/) {
+    isAvailable(name: string) {
         return false;
     }
 
@@ -417,15 +528,53 @@ class NodeBuilder {
         return nodeData.usageCount;
     }
 
-    generateTexture(/* texture, textureProperty, uvSnippet */) {
-        console.warn('Abstract function.');
-    }
-
-    generateTextureLod(/* texture, textureProperty, uvSnippet, levelSnippet */) {
-        console.warn('Abstract function.');
-    }
-
-    generateConst(type, value = null) {
+    abstract generateTexture(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        depthSnippet: string | null,
+    ): string;
+
+    abstract generateTextureLod(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        levelSnippet: string | null,
+        depthSnippet: string | null,
+    ): string;
+
+    abstract generateTextureGrad(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        gradSnippet: [string, string] | null,
+        depthSnippet: string | null,
+    ): string;
+
+    abstract generateTextureCompare(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        compareSnippet: string | null,
+        depthSnippet: string | null,
+    ): string;
+
+    abstract generateTextureLoad(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        depthSnippet: string | null,
+    ): string;
+
+    abstract generateTextureBias(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        biasSnippet: string | null,
+        depthSnippet: string | null,
+    ): string;
+
+    generateConst(type: string | null, value: unknown = null): string {
         if (value === null) {
             if (type === 'float' || type === 'int' || type === 'uint') value = 0;
             else if (type === 'bool') value = false;
@@ -436,26 +585,26 @@ class NodeBuilder {
         }
 
         if (type === 'float') return toFloat(value);
-        if (type === 'int') return `${Math.round(value)}`;
-        if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';
+        if (type === 'int') return `${Math.round(value as number)}`;
+        if (type === 'uint') return (value as number) >= 0 ? `${Math.round(value as number)}u` : '0u';
         if (type === 'bool') return value ? 'true' : 'false';
         if (type === 'color')
-            return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
+            return `${this.getType('vec3')}( ${toFloat((value as Color).r)}, ${toFloat((value as Color).g)}, ${toFloat((value as Color).b)} )`;
 
         const typeLength = this.getTypeLength(type);
 
         const componentType = this.getComponentType(type);
 
-        const generateConst = value => this.generateConst(componentType, value);
+        const generateConst = (value: unknown) => this.generateConst(componentType, value);
 
         if (typeLength === 2) {
-            return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;
+            return `${this.getType(type)}( ${generateConst((value as Vector2).x)}, ${generateConst((value as Vector2).y)} )`;
         } else if (typeLength === 3) {
-            return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;
+            return `${this.getType(type)}( ${generateConst((value as Vector3).x)}, ${generateConst((value as Vector3).y)}, ${generateConst((value as Vector3).z)} )`;
         } else if (typeLength === 4) {
-            return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;
-        } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {
-            return `${this.getType(type)}( ${value.elements.map(generateConst).join(', ')} )`;
+            return `${this.getType(type)}( ${generateConst((value as Vector4).x)}, ${generateConst((value as Vector4).y)}, ${generateConst((value as Vector4).z)}, ${generateConst((value as Vector4).w)} )`;
+        } else if (typeLength > 4 && value && ((value as Matrix3).isMatrix3 || (value as Matrix4).isMatrix4)) {
+            return `${this.getType(type)}( ${(value as Matrix3 | Matrix4).elements.map(generateConst).join(', ')} )`;
         } else if (typeLength > 4) {
             return `${this.getType(type)}()`;
         }
@@ -463,17 +612,17 @@ class NodeBuilder {
         throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);
     }
 
-    getType(type) {
+    getType(type: string | null) {
         if (type === 'color') return 'vec3';
 
         return type;
     }
 
-    hasGeometryAttribute(name) {
+    hasGeometryAttribute(name: string) {
         return this.geometry && this.geometry.getAttribute(name) !== undefined;
     }
 
-    getAttribute(name, type) {
+    getAttribute(name: string, type: string | null) {
         const attributes = this.attributes;
 
         // find attribute
@@ -493,19 +642,19 @@ class NodeBuilder {
         return attribute;
     }
 
-    getPropertyName(node /*, shaderStage*/) {
-        return node.name;
+    getPropertyName(node: unknown, shaderStage?: NodeShaderStage) {
+        return (node as { name?: string }).name;
     }
 
-    isVector(type) {
-        return /vec\d/.test(type);
+    isVector(type: string | null) {
+        return /vec\d/.test(type!);
     }
 
-    isMatrix(type) {
-        return /mat\d/.test(type);
+    isMatrix(type: string | null) {
+        return /mat\d/.test(type!);
     }
 
-    isReference(type) {
+    isReference(type: string | null) {
         return (
             type === 'void' ||
             type === 'property' ||
@@ -522,10 +671,10 @@ class NodeBuilder {
         return false;
     }
 
-    getComponentTypeFromTexture(texture) {
+    getComponentTypeFromTexture(texture: Texture) {
         const type = texture.type;
 
-        if (texture.isDataTexture) {
+        if ((texture as DataTexture).isDataTexture) {
             if (type === IntType) return 'int';
             if (type === UnsignedIntType) return 'uint';
         }
@@ -533,7 +682,7 @@ class NodeBuilder {
         return 'float';
     }
 
-    getElementType(type) {
+    getElementType(type: string | null) {
         if (type === 'mat2') return 'vec2';
         if (type === 'mat3') return 'vec3';
         if (type === 'mat4') return 'vec4';
@@ -541,7 +690,7 @@ class NodeBuilder {
         return this.getComponentType(type);
     }
 
-    getComponentType(type) {
+    getComponentType(type: string | null) {
         type = this.getVectorType(type);
 
         if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;
@@ -557,7 +706,7 @@ class NodeBuilder {
         return 'float';
     }
 
-    getVectorType(type) {
+    getVectorType(type: string | null) {
         if (type === 'color') return 'vec3';
         if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D')
             return 'vec4';
@@ -565,23 +714,23 @@ class NodeBuilder {
         return type;
     }
 
-    getTypeFromLength(length, componentType = 'float') {
+    getTypeFromLength(length: number, componentType: string | null = 'float') {
         if (length === 1) return componentType;
 
         const baseType = typeFromLength.get(length);
-        const prefix = componentType === 'float' ? '' : componentType[0];
+        const prefix = componentType === 'float' ? '' : componentType![0];
 
         return prefix + baseType;
     }
 
-    getTypeFromArray(array) {
-        return typeFromArray.get(array.constructor);
+    getTypeFromArray(array: TypedArray) {
+        return typeFromArray.get(array.constructor as TypedArrayConstructor);
     }
 
-    getTypeFromAttribute(attribute) {
-        let dataAttribute = attribute;
-
-        if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;
+    getTypeFromAttribute(attribute: BufferAttribute | InterleavedBufferAttribute) {
+        const dataAttribute = (attribute as InterleavedBufferAttribute).isInterleavedBufferAttribute
+            ? (attribute as InterleavedBufferAttribute).data
+            : attribute;
 
         const array = dataAttribute.array;
         const itemSize = attribute.itemSize;
@@ -596,28 +745,28 @@ class NodeBuilder {
         return this.getTypeFromLength(itemSize, arrayType);
     }
 
-    getTypeLength(type) {
+    getTypeLength(type: string | null) {
         const vecType = this.getVectorType(type);
-        const vecNum = /vec([2-4])/.exec(vecType);
+        const vecNum = /vec([2-4])/.exec(vecType!);
 
         if (vecNum !== null) return Number(vecNum[1]);
         if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;
-        if (/mat2/.test(type) === true) return 4;
-        if (/mat3/.test(type) === true) return 9;
-        if (/mat4/.test(type) === true) return 16;
+        if (/mat2/.test(type!) === true) return 4;
+        if (/mat3/.test(type!) === true) return 9;
+        if (/mat4/.test(type!) === true) return 16;
 
         return 0;
     }
 
-    getVectorFromMatrix(type) {
+    getVectorFromMatrix(type: string) {
         return type.replace('mat', 'vec');
     }
 
-    changeComponentType(type, newComponentType) {
+    changeComponentType(type: string, newComponentType: string) {
         return this.getTypeFromLength(this.getTypeLength(type), newComponentType);
     }
 
-    getIntegerType(type) {
+    getIntegerType(type: string) {
         const componentType = this.getComponentType(type);
 
         if (componentType === 'int' || componentType === 'uint') return type;
@@ -643,7 +792,11 @@ class NodeBuilder {
         return lastStack;
     }
 
-    getDataFromNode(node, shaderStage = this.shaderStage, cache = null) {
+    getDataFromNode(
+        node: Node,
+        shaderStage: NodeShaderStage | 'any' = this.shaderStage!,
+        cache: NodeCache | null = null,
+    ) {
         cache = cache === null ? (node.isGlobal(this) ? this.globalCache : this.cache) : cache;
 
         let nodeData = cache.getData(node);
@@ -656,16 +809,16 @@ class NodeBuilder {
 
         if (nodeData[shaderStage] === undefined) nodeData[shaderStage] = {};
 
-        return nodeData[shaderStage];
+        return nodeData[shaderStage]!;
     }
 
-    getNodeProperties(node, shaderStage = 'any') {
+    getNodeProperties(node: Node, shaderStage: NodeShaderStage | 'any' = 'any') {
         const nodeData = this.getDataFromNode(node, shaderStage);
 
         return nodeData.properties || (nodeData.properties = { outputNode: null });
     }
 
-    getBufferAttributeFromNode(node, type) {
+    getBufferAttributeFromNode(node: Node, type: string | null) {
         const nodeData = this.getDataFromNode(node);
 
         let bufferAttribute = nodeData.bufferAttribute;
@@ -683,7 +836,7 @@ class NodeBuilder {
         return bufferAttribute;
     }
 
-    getStructTypeFromNode(node, shaderStage = this.shaderStage) {
+    getStructTypeFromNode(node: StructTypeNode, shaderStage = this.shaderStage!) {
         const nodeData = this.getDataFromNode(node, shaderStage);
 
         if (nodeData.structType === undefined) {
@@ -698,7 +851,12 @@ class NodeBuilder {
         return node;
     }
 
-    getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {
+    getUniformFromNode(
+        node: UniformNode<unknown>,
+        type: string | null,
+        shaderStage = this.shaderStage!,
+        name: string | null = null,
+    ) {
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
         let nodeUniform = nodeData.uniform;
@@ -716,7 +874,12 @@ class NodeBuilder {
         return nodeUniform;
     }
 
-    getVarFromNode(node, name = null, type = node.getNodeType(this), shaderStage = this.shaderStage) {
+    getVarFromNode(
+        node: Node,
+        name: string | null = null,
+        type = node.getNodeType(this),
+        shaderStage = this.shaderStage!,
+    ) {
         const nodeData = this.getDataFromNode(node, shaderStage);
 
         let nodeVar = nodeData.variable;
@@ -736,7 +899,7 @@ class NodeBuilder {
         return nodeVar;
     }
 
-    getVaryingFromNode(node, name = null, type = node.getNodeType(this)) {
+    getVaryingFromNode(node: Node, name: string | null = null, type = node.getNodeType(this)) {
         const nodeData = this.getDataFromNode(node, 'any');
 
         let nodeVarying = nodeData.varying;
@@ -757,7 +920,7 @@ class NodeBuilder {
         return nodeVarying;
     }
 
-    getCodeFromNode(node, type, shaderStage = this.shaderStage) {
+    getCodeFromNode(node: Node, type: string | null, shaderStage = this.shaderStage!) {
         const nodeData = this.getDataFromNode(node);
 
         let nodeCode = nodeData.code;
@@ -807,7 +970,7 @@ class NodeBuilder {
         codeBlock.set(nodeBlock, true);
     }
 
-    addLineFlowCode(code, node = null) {
+    addLineFlowCode(code: string, node = null) {
         if (code === '') return this;
 
         if (node !== null && this.context.nodeBlock) {
@@ -825,7 +988,7 @@ class NodeBuilder {
         return this;
     }
 
-    addFlowCode(code) {
+    addFlowCode(code: string) {
         this.flow.code += code;
 
         return this;
@@ -843,11 +1006,11 @@ class NodeBuilder {
         return this;
     }
 
-    getFlowData(node /*, shaderStage*/) {
+    getFlowData(node: Node /*, shaderStage*/) {
         return this.flowsData.get(node);
     }
 
-    flowNode(node) {
+    flowNode(node: Node) {
         const output = node.getNodeType(this);
 
         const flowData = this.flowChildNode(node, output);
@@ -857,7 +1020,9 @@ class NodeBuilder {
         return flowData;
     }
 
-    buildFunctionNode(shaderNode) {
+    abstract buildFunctionCode(shaderNode: ShaderNodeInternal): string;
+
+    buildFunctionNode(shaderNode: ShaderNodeInternal) {
         const fn = new FunctionNode();
 
         const previous = this.currentFunctionNode;
@@ -871,7 +1036,7 @@ class NodeBuilder {
         return fn;
     }
 
-    flowShaderNode(shaderNode) {
+    flowShaderNode(shaderNode: ShaderNodeInternal) {
         const layout = shaderNode.layout;
 
         const inputs = {
@@ -887,7 +1052,7 @@ class NodeBuilder {
             },
         };
 
-        for (const input of layout.inputs) {
+        for (const input of layout!.inputs) {
             inputs[input.name] = new ParameterNode(input.type, input.name);
         }
 
@@ -903,14 +1068,14 @@ class NodeBuilder {
         return flowData;
     }
 
-    flowStagesNode(node, output = null) {
+    flowStagesNode(node: Node, output: string | null = null) {
         const previousFlow = this.flow;
         const previousVars = this.vars;
         const previousCache = this.cache;
         const previousBuildStage = this.buildStage;
         const previousStack = this.stack;
 
-        const flow = {
+        const flow: Flow = {
             code: '',
         };
 
@@ -925,7 +1090,7 @@ class NodeBuilder {
             flow.result = node.build(this, output);
         }
 
-        flow.vars = this.getVars(this.shaderStage);
+        flow.vars = this.getVars(this.shaderStage!);
 
         this.flow = previousFlow;
         this.vars = previousVars;
@@ -941,10 +1106,10 @@ class NodeBuilder {
         return null;
     }
 
-    flowChildNode(node, output = null) {
+    flowChildNode(node: Node, output: string | null = null) {
         const previousFlow = this.flow;
 
-        const flow = {
+        const flow: Flow = {
             code: '',
         };
 
@@ -957,7 +1122,12 @@ class NodeBuilder {
         return flow;
     }
 
-    flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {
+    flowNodeFromShaderStage(
+        shaderStage: 'vertex' | 'fragment' | 'compute',
+        node: Node,
+        output: string | null = null,
+        propertyName: string | null = null,
+    ) {
         const previousShaderStage = this.shaderStage;
 
         this.setShaderStage(shaderStage);
@@ -979,19 +1149,15 @@ class NodeBuilder {
         return this.attributes.concat(this.bufferAttributes);
     }
 
-    getAttributes(/*shaderStage*/) {
-        console.warn('Abstract function.');
-    }
+    abstract getAttributes(shaderStage: NodeShaderStage): string;
 
-    getVaryings(/*shaderStage*/) {
-        console.warn('Abstract function.');
-    }
+    abstract getVaryings(shaderStage: NodeShaderStage): string;
 
-    getVar(type, name) {
+    getVar(type: string | null, name: string) {
         return `${this.getType(type)} ${name}`;
     }
 
-    getVars(shaderStage) {
+    getVars(shaderStage: 'vertex' | 'fragment' | 'compute') {
         let snippet = '';
 
         const vars = this.vars[shaderStage];
@@ -1005,11 +1171,9 @@ class NodeBuilder {
         return snippet;
     }
 
-    getUniforms(/*shaderStage*/) {
-        console.warn('Abstract function.');
-    }
+    abstract getUniforms(shaderStage: NodeShaderStage): string;
 
-    getCodes(shaderStage) {
+    getCodes(shaderStage: 'vertex' | 'fragment' | 'compute') {
         const codes = this.codes[shaderStage];
 
         let code = '';
@@ -1024,10 +1188,10 @@ class NodeBuilder {
     }
 
     getHash() {
-        return this.vertexShader + this.fragmentShader + this.computeShader;
+        return this.vertexShader! + this.fragmentShader + this.computeShader;
     }
 
-    setShaderStage(shaderStage) {
+    setShaderStage(shaderStage: NodeShaderStage | null) {
         this.shaderStage = shaderStage;
     }
 
@@ -1035,7 +1199,7 @@ class NodeBuilder {
         return this.shaderStage;
     }
 
-    setBuildStage(buildStage) {
+    setBuildStage(buildStage: string | null) {
         this.buildStage = buildStage;
     }
 
@@ -1101,7 +1265,7 @@ class NodeBuilder {
         return this;
     }
 
-    getNodeUniform(uniformNode, type) {
+    getNodeUniform(uniformNode: NodeUniform<unknown>, type: string | null) {
         if (type === 'float' || type === 'int' || type === 'uint') return new NumberNodeUniform(uniformNode);
         if (type === 'vec2' || type === 'ivec2' || type === 'uvec2') return new Vector2NodeUniform(uniformNode);
         if (type === 'vec3' || type === 'ivec3' || type === 'uvec3') return new Vector3NodeUniform(uniformNode);
@@ -1119,7 +1283,7 @@ class NodeBuilder {
         throw new Error(`THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${type}() instead.`);
     }
 
-    format(snippet, fromType, toType) {
+    format(snippet: string, fromType: string | null, toType: string | null): string {
         fromType = this.getVectorType(fromType);
         toType = this.getVectorType(toType);
 
diff --git a/src-testing/src/nodes/core/NodeCache.ts b/src-testing/src/nodes/core/NodeCache.ts
index ad72d50c..a7a5a966 100644
--- a/src-testing/src/nodes/core/NodeCache.ts
+++ b/src-testing/src/nodes/core/NodeCache.ts
@@ -1,24 +1,75 @@
+import NodeAttribute from './NodeAttribute.js';
+import NodeUniform from './NodeUniform.js';
+import NodeVar from './NodeVar.js';
+import NodeVarying from './NodeVarying.js';
+import NodeCode from './NodeCode.js';
+import Node from './Node.js';
+import BufferAttributeNode from '../accessors/BufferAttributeNode.js';
+import { BufferAttribute, TypedArray } from '../../core/BufferAttribute.js';
+import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
+
 let id = 0;
 
+export interface ShaderStageNodeData {
+    properties?:
+        | ({
+              outputNode: Node | null;
+              initialized?: boolean | undefined;
+          } & {
+              [K in `node${string}`]?: Node | undefined;
+          })
+        | undefined;
+    bufferAttribute?: NodeAttribute | undefined;
+    structType?: Node | undefined;
+    uniform?: NodeUniform<unknown> | undefined;
+    variable?: NodeVar | undefined;
+    varying?: NodeVarying | undefined;
+    code?: NodeCode | undefined;
+    usageCount?: number | undefined;
+    snippet?: string | undefined;
+    propertyName?: string | undefined;
+    propertySizeName?: string | undefined;
+}
+
+interface NodeData {
+    vertex?: ShaderStageNodeData | undefined;
+    fragment?: ShaderStageNodeData | undefined;
+    compute?: ShaderStageNodeData | undefined;
+    any?: ShaderStageNodeData | undefined;
+}
+
+interface BufferAttributeData {
+    node: BufferAttributeNode;
+}
+
 class NodeCache {
-    constructor(parent = null) {
+    id: number;
+    nodesData: WeakMap<Node | TypedArray | InterleavedBuffer | BufferAttribute, NodeData | BufferAttributeData>;
+
+    parent: NodeCache | null;
+
+    constructor(parent: NodeCache | null = null) {
         this.id = id++;
         this.nodesData = new WeakMap();
 
         this.parent = parent;
     }
 
-    getData(node) {
+    getData(node: Node): NodeData | undefined;
+    getData(node: TypedArray | InterleavedBuffer | BufferAttribute): BufferAttributeData | undefined;
+    getData(node: Node | TypedArray | InterleavedBuffer | BufferAttribute): NodeData | BufferAttributeData | undefined {
         let data = this.nodesData.get(node);
 
         if (data === undefined && this.parent !== null) {
-            data = this.parent.getData(node);
+            data = this.parent.getData(node as Node);
         }
 
         return data;
     }
 
-    setData(node, data) {
+    setData(node: Node, data: NodeData): void;
+    setData(node: TypedArray | InterleavedBuffer | BufferAttribute, data: BufferAttributeData): void;
+    setData(node: Node | TypedArray | InterleavedBuffer | BufferAttribute, data: NodeData | BufferAttributeData) {
         this.nodesData.set(node, data);
     }
 }
diff --git a/src-testing/src/nodes/core/NodeCode.ts b/src-testing/src/nodes/core/NodeCode.ts
index 2ee50903..0c0d8c87 100644
--- a/src-testing/src/nodes/core/NodeCode.ts
+++ b/src-testing/src/nodes/core/NodeCode.ts
@@ -1,5 +1,9 @@
 class NodeCode {
-    constructor(name, type, code = '') {
+    name: string;
+    type: string | null;
+    code: string;
+
+    constructor(name: string, type: string | null, code = '') {
         this.name = name;
         this.type = type;
         this.code = code;
diff --git a/src-testing/src/nodes/core/NodeFrame.ts b/src-testing/src/nodes/core/NodeFrame.ts
index ee64620c..14eb7f75 100644
--- a/src-testing/src/nodes/core/NodeFrame.ts
+++ b/src-testing/src/nodes/core/NodeFrame.ts
@@ -1,6 +1,26 @@
 import { NodeUpdateType } from './constants.js';
+import Node from './Node.js';
+import Renderer from '../../renderers/common/Renderer.js';
+import { Camera, Material, Object3D, Scene } from 'three';
 
 class NodeFrame {
+    time: number;
+    deltaTime: number;
+
+    frameId: number;
+    renderId: number;
+
+    // TODO startTime
+
+    // TODO updateMap
+    // TODO updateBeforeMap
+
+    renderer: Renderer | null;
+    material: Material | null;
+    camera: Camera | null;
+    object: Object3D | null;
+    scene: Scene | null;
+
     constructor() {
         this.time = 0;
         this.deltaTime = 0;
@@ -36,7 +56,7 @@ class NodeFrame {
         return maps;
     }
 
-    updateBeforeNode(node) {
+    updateBeforeNode(node: Node) {
         const updateType = node.getUpdateBeforeType();
         const reference = node.updateReference(this);
 
@@ -86,7 +106,7 @@ class NodeFrame {
         }
     }
 
-    updateNode(node) {
+    updateNode(node: Node) {
         const updateType = node.getUpdateType();
         const reference = node.updateReference(this);
 
diff --git a/src-testing/src/nodes/core/NodeParser.ts b/src-testing/src/nodes/core/NodeParser.ts
index 9849452f..76c5b9be 100644
--- a/src-testing/src/nodes/core/NodeParser.ts
+++ b/src-testing/src/nodes/core/NodeParser.ts
@@ -1,7 +1,7 @@
-class NodeParser {
-    parseFunction(/*source*/) {
-        console.warn('Abstract function.');
-    }
+import NodeFunction from './NodeFunction.js';
+
+abstract class NodeParser {
+    abstract parseFunction(source: string): NodeFunction;
 }
 
 export default NodeParser;
diff --git a/src-testing/src/nodes/core/NodeUniform.ts b/src-testing/src/nodes/core/NodeUniform.ts
index ca43958f..ae51479e 100644
--- a/src-testing/src/nodes/core/NodeUniform.ts
+++ b/src-testing/src/nodes/core/NodeUniform.ts
@@ -1,5 +1,14 @@
-class NodeUniform {
-    constructor(name, type, node) {
+import UniformNode from './UniformNode.js';
+
+class NodeUniform<TValue> {
+    readonly isNodeUniform: true;
+
+    name: string;
+    type: string | null;
+    node: UniformNode<TValue>;
+    needsUpdate: boolean | undefined;
+
+    constructor(name: string, type: string | null, node: UniformNode<TValue>) {
         this.isNodeUniform = true;
 
         this.name = name;
diff --git a/src-testing/src/nodes/core/NodeUtils.ts b/src-testing/src/nodes/core/NodeUtils.ts
index 7ebac01f..0662c6a0 100644
--- a/src-testing/src/nodes/core/NodeUtils.ts
+++ b/src-testing/src/nodes/core/NodeUtils.ts
@@ -4,13 +4,14 @@ import { Matrix4 } from '../../math/Matrix4.js';
 import { Vector2 } from '../../math/Vector2.js';
 import { Vector3 } from '../../math/Vector3.js';
 import { Vector4 } from '../../math/Vector4.js';
+import Node from './Node.js';
 
 // cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.
 // A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.
 // Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.
 // See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480
 // https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js
-function cyrb53(value, seed = 0) {
+function cyrb53(value: number[] | string, seed: number = 0) {
     let h1 = 0xdeadbeef ^ seed,
         h2 = 0x41c6ce57 ^ seed;
 
@@ -36,16 +37,16 @@ function cyrb53(value, seed = 0) {
     return 4294967296 * (2097151 & h2) + (h1 >>> 0);
 }
 
-export const hashString = str => cyrb53(str);
-export const hashArray = array => cyrb53(array);
-export const hash = (...params) => cyrb53(params);
+export const hashString = (str: string) => cyrb53(str);
+export const hashArray = (array: number[]) => cyrb53(array);
+export const hash = (...params: number[]) => cyrb53(params);
 
-export function getCacheKey(object, force = false) {
-    const values = [];
+export function getCacheKey(object: object, force = false) {
+    const values: number[] = [];
 
-    if (object.isNode === true) {
-        values.push(object.id);
-        object = object.getSelf();
+    if ((object as Node).isNode === true) {
+        values.push((object as Node).id);
+        object = (object as Node).getSelf();
     }
 
     for (const { property, childNode } of getNodeChildren(object)) {
@@ -55,36 +56,58 @@ export function getCacheKey(object, force = false) {
     return cyrb53(values);
 }
 
-export function* getNodeChildren(node, toJSON = false) {
+export interface NodeChild {
+    property: string;
+    index?: number | string;
+    childNode: Node;
+}
+
+export interface NodeChildWithToJSON {
+    property: string;
+    index?: number | string;
+    childNode: Node | { toJSON: () => unknown };
+}
+
+export function getNodeChildren(node: object): Generator<NodeChild, void, unknown>;
+export function getNodeChildren(node: object, toJSON: boolean): Generator<NodeChildWithToJSON, void, unknown>;
+export function* getNodeChildren(node: object, toJSON = false) {
     for (const property in node) {
         // Ignore private properties.
         if (property.startsWith('_') === true) continue;
 
-        const object = node[property];
+        const object = node[property as keyof typeof node] as unknown;
 
         if (Array.isArray(object) === true) {
             for (let i = 0; i < object.length; i++) {
-                const child = object[i];
-
-                if (child && (child.isNode === true || (toJSON && typeof child.toJSON === 'function'))) {
-                    yield { property, index: i, childNode: child };
+                const child = object[i] as unknown;
+
+                if (
+                    child &&
+                    ((child as Node).isNode === true ||
+                        (toJSON && typeof (child as { toJSON: () => unknown }).toJSON === 'function'))
+                ) {
+                    yield { property, index: i, childNode: child as Node | { toJSON: () => unknown } };
                 }
             }
-        } else if (object && object.isNode === true) {
-            yield { property, childNode: object };
+        } else if (object && (object as Node).isNode === true) {
+            yield { property, childNode: object as Node };
         } else if (typeof object === 'object') {
             for (const subProperty in object) {
-                const child = object[subProperty];
-
-                if (child && (child.isNode === true || (toJSON && typeof child.toJSON === 'function'))) {
-                    yield { property, index: subProperty, childNode: child };
+                const child = object[subProperty as keyof typeof object];
+
+                if (
+                    child &&
+                    ((child as Node).isNode === true ||
+                        (toJSON && typeof (child as { toJSON: () => unknown }).toJSON === 'function'))
+                ) {
+                    yield { property, index: subProperty, childNode: child as Node | { toJSON: () => unknown } };
                 }
             }
         }
     }
 }
 
-export function getValueType(value) {
+export function getValueType(value: unknown) {
     if (value === undefined || value === null) return null;
 
     const typeOf = typeof value;
diff --git a/src-testing/src/nodes/core/NodeVar.ts b/src-testing/src/nodes/core/NodeVar.ts
index e6e935b3..8d04ff16 100644
--- a/src-testing/src/nodes/core/NodeVar.ts
+++ b/src-testing/src/nodes/core/NodeVar.ts
@@ -1,5 +1,10 @@
 class NodeVar {
-    constructor(name, type) {
+    readonly isNodeVar: true;
+
+    name: string;
+    type: string | null;
+
+    constructor(name: string, type: string | null) {
         this.isNodeVar = true;
 
         this.name = name;
diff --git a/src-testing/src/nodes/core/NodeVarying.ts b/src-testing/src/nodes/core/NodeVarying.ts
index a1482362..0a62b23d 100644
--- a/src-testing/src/nodes/core/NodeVarying.ts
+++ b/src-testing/src/nodes/core/NodeVarying.ts
@@ -1,7 +1,11 @@
 import NodeVar from './NodeVar.js';
 
 class NodeVarying extends NodeVar {
-    constructor(name, type) {
+    needsInterpolation: boolean;
+
+    readonly isNodeVarying: true;
+
+    constructor(name: string, type: string | null) {
         super(name, type);
 
         this.needsInterpolation = false;
diff --git a/src-testing/src/nodes/core/StackNode.ts b/src-testing/src/nodes/core/StackNode.ts
index 79313afa..c06474c2 100644
--- a/src-testing/src/nodes/core/StackNode.ts
+++ b/src-testing/src/nodes/core/StackNode.ts
@@ -1,12 +1,22 @@
 import Node from './Node.js';
 import { select } from '../math/ConditionalNode.js';
-import { ShaderNode, nodeProxy, getCurrentStack, setCurrentStack } from '../tsl/TSLBase.js';
+import { ShaderNode, nodeProxy, getCurrentStack, setCurrentStack, ShaderNodeObject } from '../tsl/TSLBase.js';
+import NodeBuilder from './NodeBuilder.js';
 
 class StackNode extends Node {
     static get type() {
         return 'StackNode';
     }
 
+    nodes: Node[];
+    outputNode: Node | null;
+
+    parent: ShaderNodeObject<StackNode> | null;
+
+    _currentCond: ShaderNodeObject<Node> | null;
+
+    readonly isStackNode: true;
+
     constructor(parent = null) {
         super();
 
@@ -20,24 +30,24 @@ class StackNode extends Node {
         this.isStackNode = true;
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.outputNode ? this.outputNode.getNodeType(builder) : 'void';
     }
 
-    add(node) {
+    add(node: Node) {
         this.nodes.push(node);
 
         return this;
     }
 
-    If(boolNode, method) {
+    If(boolNode: Node, method: () => void) {
         const methodNode = new ShaderNode(method);
         this._currentCond = select(boolNode, methodNode);
 
         return this.add(this._currentCond);
     }
 
-    ElseIf(boolNode, method) {
+    ElseIf(boolNode: Node, method: () => void) {
         const methodNode = new ShaderNode(method);
         const ifNode = select(boolNode, methodNode);
 
@@ -47,13 +57,13 @@ class StackNode extends Node {
         return this;
     }
 
-    Else(method) {
+    Else(method: () => void) {
         this._currentCond.elseNode = new ShaderNode(method);
 
         return this;
     }
 
-    build(builder, ...params) {
+    build(builder: NodeBuilder, ...params) {
         const previousStack = getCurrentStack();
 
         setCurrentStack(this);
diff --git a/src-testing/src/nodes/core/StructTypeNode.ts b/src-testing/src/nodes/core/StructTypeNode.ts
index acadb07e..28f7f19f 100644
--- a/src-testing/src/nodes/core/StructTypeNode.ts
+++ b/src-testing/src/nodes/core/StructTypeNode.ts
@@ -5,7 +5,10 @@ class StructTypeNode extends Node {
         return 'StructTypeNode';
     }
 
-    constructor(types) {
+    types: string[];
+    readonly isStructTypeNode: true;
+
+    constructor(types: string[]) {
         super();
 
         this.types = types;
diff --git a/src-testing/src/nodes/core/UniformGroupNode.ts b/src-testing/src/nodes/core/UniformGroupNode.ts
index 829fd3ee..f18d67ba 100644
--- a/src-testing/src/nodes/core/UniformGroupNode.ts
+++ b/src-testing/src/nodes/core/UniformGroupNode.ts
@@ -1,10 +1,14 @@
-import Node from './Node.js';
+import Node, { NodeJSONInputData, NodeJSONIntermediateOutputData } from './Node.js';
 
 class UniformGroupNode extends Node {
     static get type() {
         return 'UniformGroupNode';
     }
 
+    shared: boolean;
+    order: number;
+    readonly isUniformGroup: true;
+
     constructor(name, shared = false, order = 1) {
         super('string');
 
@@ -16,11 +20,11 @@ class UniformGroupNode extends Node {
         this.isUniformGroup = true;
     }
 
-    set needsUpdate(value) {
+    set needsUpdate(value: boolean) {
         if (value === true) this.version++;
     }
 
-    serialize(data) {
+    serialize(data: NodeJSONIntermediateOutputData) {
         super.serialize(data);
 
         data.name = this.name;
@@ -28,7 +32,7 @@ class UniformGroupNode extends Node {
         data.shared = this.shared;
     }
 
-    deserialize(data) {
+    deserialize(data: NodeJSONInputData) {
         super.deserialize(data);
 
         this.name = data.name;
diff --git a/src-testing/src/nodes/core/UniformNode.ts b/src-testing/src/nodes/core/UniformNode.ts
index ec9fa9ae..c6218c7f 100644
--- a/src-testing/src/nodes/core/UniformNode.ts
+++ b/src-testing/src/nodes/core/UniformNode.ts
@@ -1,13 +1,22 @@
 import InputNode from './InputNode.js';
-import { objectGroup } from './UniformGroupNode.js';
+import UniformGroupNode, { objectGroup } from './UniformGroupNode.js';
 import { nodeObject, getConstNodeType } from '../tsl/TSLCore.js';
+import Node from './Node.js';
+import NodeBuilder from './NodeBuilder.js';
+import NodeFrame from './NodeFrame.js';
+import { NodeUpdateType } from './constants.js';
 
-class UniformNode extends InputNode {
+class UniformNode<TValue> extends InputNode<TValue> {
     static get type() {
         return 'UniformNode';
     }
 
-    constructor(value, nodeType = null) {
+    readonly isUniformNode: true;
+
+    name: string;
+    groupNode: UniformGroupNode;
+
+    constructor(value: TValue, nodeType: string | null = null) {
         super(value, nodeType);
 
         this.isUniformNode = true;
@@ -16,13 +25,13 @@ class UniformNode extends InputNode {
         this.groupNode = objectGroup;
     }
 
-    label(name) {
+    label(name: string) {
         this.name = name;
 
         return this;
     }
 
-    setGroup(group) {
+    setGroup(group: UniformGroupNode) {
         this.groupNode = group;
 
         return this;
@@ -32,11 +41,11 @@ class UniformNode extends InputNode {
         return this.groupNode;
     }
 
-    getUniformHash(builder) {
+    getUniformHash(builder: NodeBuilder) {
         return this.getHash(builder);
     }
 
-    onUpdate(callback, updateType) {
+    onUpdate(callback: (frame: NodeFrame, self: this) => TValue | undefined, updateType: NodeUpdateType) {
         const self = this.getSelf();
 
         callback = callback.bind(self);
@@ -50,12 +59,12 @@ class UniformNode extends InputNode {
         }, updateType);
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output: string | null) {
         const type = this.getNodeType(builder);
 
         const hash = this.getUniformHash(builder);
 
-        let sharedNode = builder.getNodeFromHash(hash);
+        let sharedNode = builder.getNodeFromHash(hash) as this;
 
         if (sharedNode === undefined) {
             builder.setHashNode(this, hash);
@@ -68,7 +77,7 @@ class UniformNode extends InputNode {
         const nodeUniform = builder.getUniformFromNode(
             sharedNode,
             sharedNodeType,
-            builder.shaderStage,
+            builder.shaderStage!,
             this.name || builder.context.label,
         );
         const propertyName = builder.getPropertyName(nodeUniform);
@@ -81,11 +90,14 @@ class UniformNode extends InputNode {
 
 export default UniformNode;
 
-export const uniform = (arg1, arg2) => {
+export const uniform = <TValue>(arg1: InputNode<TValue> | TValue, arg2?: Node | string) => {
     const nodeType = getConstNodeType(arg2 || arg1);
 
     // @TODO: get ConstNode from .traverse() in the future
-    const value = arg1 && arg1.isNode === true ? (arg1.node && arg1.node.value) || arg1.value : arg1;
+    const value: TValue =
+        arg1 && (arg1 as Node).isNode === true
+            ? (arg1.node && arg1.node.value) || (arg1 as InputNode<TValue>).value
+            : arg1;
 
     return nodeObject(new UniformNode(value, nodeType));
 };
diff --git a/src-testing/src/nodes/core/constants.ts b/src-testing/src/nodes/core/constants.ts
index 3b01a9a6..5ff6ad5f 100644
--- a/src-testing/src/nodes/core/constants.ts
+++ b/src-testing/src/nodes/core/constants.ts
@@ -1,14 +1,14 @@
 export const NodeShaderStage = {
     VERTEX: 'vertex',
     FRAGMENT: 'fragment',
-};
+} as const;
 
 export const NodeUpdateType = {
     NONE: 'none',
     FRAME: 'frame',
     RENDER: 'render',
     OBJECT: 'object',
-};
+} as const;
 
 export const NodeType = {
     BOOLEAN: 'bool',
@@ -20,9 +20,12 @@ export const NodeType = {
     MATRIX2: 'mat2',
     MATRIX3: 'mat3',
     MATRIX4: 'mat4',
-};
+} as const;
 
-export const defaultShaderStages = ['fragment', 'vertex'];
+export type NodeShaderStage = 'vertex' | 'fragment' | 'compute';
+export type NodeUpdateType = 'none' | 'frame' | 'render' | 'object';
+
+export const defaultShaderStages: NodeShaderStage[] = ['fragment', 'vertex'];
 export const defaultBuildStages = ['setup', 'analyze', 'generate'];
-export const shaderStages = [...defaultShaderStages, 'compute'];
+export const shaderStages: NodeShaderStage[] = [...defaultShaderStages, 'compute'];
 export const vectorComponents = ['x', 'y', 'z', 'w'];
diff --git a/src-testing/src/nodes/fog/FogNode.ts b/src-testing/src/nodes/fog/FogNode.ts
index f08efb70..fdb3f470 100644
--- a/src-testing/src/nodes/fog/FogNode.ts
+++ b/src-testing/src/nodes/fog/FogNode.ts
@@ -1,6 +1,7 @@
 import Node from '../core/Node.js';
 import { positionView } from '../accessors/Position.js';
 import { nodeProxy } from '../tsl/TSLBase.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 class FogNode extends Node {
     static get type() {
@@ -16,7 +17,7 @@ class FogNode extends Node {
         this.factorNode = factorNode;
     }
 
-    getViewZNode(builder) {
+    getViewZNode(builder: NodeBuilder) {
         let viewZ;
 
         const getViewZ = builder.context.getViewZ;
diff --git a/src-testing/src/nodes/lighting/LightingContextNode.ts b/src-testing/src/nodes/lighting/LightingContextNode.ts
index f9dbf1a8..89e11615 100644
--- a/src-testing/src/nodes/lighting/LightingContextNode.ts
+++ b/src-testing/src/nodes/lighting/LightingContextNode.ts
@@ -1,12 +1,34 @@
 import ContextNode from '../core/ContextNode.js';
-import { nodeProxy, float, vec3 } from '../tsl/TSLBase.js';
+import { nodeProxy, float, vec3, ShaderNodeObject } from '../tsl/TSLBase.js';
+import Node from '../core/Node.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
-class LightingContextNode extends ContextNode {
+interface LightingContext {
+    radiance: ShaderNodeObject<Node>;
+    irradiance: ShaderNodeObject<Node>;
+    iblIrradiance: ShaderNodeObject<Node>;
+    ambientOcclusion: ShaderNodeObject<Node>;
+    reflectedLight: {
+        directDiffuse: ShaderNodeObject<Node>;
+        directSpecular: ShaderNodeObject<Node>;
+        indirectDiffuse: ShaderNodeObject<Node>;
+        indirectSpecular: ShaderNodeObject<Node>;
+    };
+    backdrop: Node | null;
+    backdropAlpha: Node | null;
+}
+
+class LightingContextNode extends ContextNode<LightingContext> {
     static get type() {
         return 'LightingContextNode';
     }
 
-    constructor(node, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
+    backdropNode: Node | null;
+    backdropAlphaNode: Node | null;
+
+    _value: LightingContext | null;
+
+    constructor(node: Node, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
         super(node);
 
         this.lightingModel = lightingModel;
@@ -31,7 +53,7 @@ class LightingContextNode extends ContextNode {
             indirectSpecular,
         };
 
-        const context = {
+        const context: LightingContext = {
             radiance: vec3().toVar('radiance'),
             irradiance: vec3().toVar('irradiance'),
             iblIrradiance: vec3().toVar('iblIrradiance'),
@@ -44,7 +66,7 @@ class LightingContextNode extends ContextNode {
         return context;
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         this.value = this._value || (this._value = this.getContext());
         this.value.lightingModel = this.lightingModel || builder.context.lightingModel;
 
diff --git a/src-testing/src/nodes/tsl/TSLCore.ts b/src-testing/src/nodes/tsl/TSLCore.ts
index 4ac059f0..fcb1c9fd 100644
--- a/src-testing/src/nodes/tsl/TSLCore.ts
+++ b/src-testing/src/nodes/tsl/TSLCore.ts
@@ -7,11 +7,40 @@ import SetNode from '../utils/SetNode.js';
 import FlipNode from '../utils/FlipNode.js';
 import ConstNode from '../core/ConstNode.js';
 import { getValueFromType, getValueType } from '../core/NodeUtils.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 //
 
 let currentStack = null;
 
+export interface NodeElements {
+    append: typeof append;
+
+    toColor: typeof color;
+    toFloat: typeof float;
+    toInt: typeof int;
+    toUint: typeof uint;
+    toBool: typeof bool;
+    toVec2: typeof vec2;
+    toIvec2: typeof ivec2;
+    toUvec2: typeof uvec2;
+    toBvec2: typeof bvec2;
+    toVec3: typeof vec3;
+    toIvec3: typeof ivec3;
+    toUvec3: typeof uvec3;
+    toBvec3: typeof bvec3;
+    toVec4: typeof vec4;
+    toIvec4: typeof ivec4;
+    toUvec4: typeof uvec4;
+    toBvec4: typeof bvec4;
+    toMat2: typeof mat2;
+    toMat3: typeof mat3;
+    toMat4: typeof mat4;
+
+    element: typeof element;
+    convert: typeof convert;
+}
+
 const NodeElements = new Map();
 
 export function addMethodChaining(name, nodeElement) {
@@ -25,6 +54,141 @@ export function addMethodChaining(name, nodeElement) {
     NodeElements.set(name, nodeElement);
 }
 
+export type SwizzleCharacter = 'x' | 'y' | 'z' | 'w' | 'r' | 'g' | 'b' | 'a' | 's' | 't' | 'p' | 'q';
+
+export type SwizzleOption = Exclude<
+    | `${SwizzleCharacter}`
+    | `${SwizzleCharacter}${SwizzleCharacter}`
+    | `${SwizzleCharacter}${SwizzleCharacter}${SwizzleCharacter}`
+    | `${SwizzleCharacter}${SwizzleCharacter}${SwizzleCharacter}${SwizzleCharacter}`,
+    'abs' | 'sqrt'
+>;
+
+export type Swizzable<T extends Node = Node> = T & {
+    [key in SwizzleOption | number]: ShaderNodeObject<Node>;
+};
+
+export type ShaderNodeObject<T extends Node> = T & {
+    [Key in keyof NodeElements]: T extends { [K in Key]: infer M }
+        ? M
+        : NodeElements[Key] extends (node: T, ...args: infer Args) => infer R
+          ? (...args: Args) => R
+          : never;
+} & {
+    [Key in keyof NodeElements as `${Key}Assign`]: T extends { [K in Key]: infer M }
+        ? M
+        : NodeElements[Key] extends (node: T, ...args: infer Args) => unknown
+          ? (...args: Args) => ShaderNodeObject<T>
+          : never;
+} & Swizzable<T>;
+
+/** anything that can be passed to {@link nodeObject} and returns a proxy */
+export type NodeRepresentation<T extends Node = Node> = number | boolean | Node | ShaderNodeObject<T>;
+
+/** anything that can be passed to {@link nodeObject} */
+export type NodeObjectOption = NodeRepresentation | string;
+
+// same logic as in ShaderNodeObject: number,boolean,node->ShaderNodeObject, otherwise do nothing
+export type NodeObject<T> = T extends Node
+    ? ShaderNodeObject<T>
+    : T extends number | boolean
+      ? ShaderNodeObject<ConstNode<number | boolean>>
+      : T;
+
+// opposite of NodeObject: node -> node|ShaderNodeObject|boolean|number, otherwise do nothing
+type Proxied<T> = T extends Node ? NodeRepresentation<T> : T;
+// https://github.com/microsoft/TypeScript/issues/42435#issuecomment-765557874
+export type ProxiedTuple<T extends readonly [...unknown[]]> = [...{ [index in keyof T]: Proxied<T[index]> }];
+export type ProxiedObject<T> = { [index in keyof T]: Proxied<T[index]> };
+type RemoveTail<T extends readonly [...unknown[]]> = T extends [unknown, ...infer X] ? X : [];
+type RemoveHeadAndTail<T extends readonly [...unknown[]]> = T extends [unknown, ...infer X, unknown] ? X : [];
+
+/**
+ * Temporary type to save signatures of 4 constructors. Each element may be tuple or undefined.
+ *
+ * We use an object instead of tuple or union as it makes stuff easier, especially in Typescript 4.0.
+ */
+interface Construtors<
+    A extends undefined | [...unknown[]],
+    B extends undefined | [...unknown[]],
+    C extends undefined | [...unknown[]],
+    D extends undefined | [...unknown[]],
+> {
+    a: A;
+    b: B;
+    c: C;
+    d: D;
+}
+
+/**
+ * Returns all constructors
+ *
+ * <https://github.com/microsoft/TypeScript/issues/37079>
+ * <https://stackoverflow.com/a/52761156/1623826>
+ */
+type OverloadedConstructorsOf<T> = T extends {
+    new (...args: infer A1): unknown;
+    new (...args: infer A2): unknown;
+    new (...args: infer A3): unknown;
+    new (...args: infer A4): unknown;
+}
+    ? Construtors<A1, A2, A3, A4>
+    : T extends {
+            new (...args: infer A1): unknown;
+            new (...args: infer A2): unknown;
+            new (...args: infer A3): unknown;
+        }
+      ? Construtors<A1, A2, A3, undefined>
+      : T extends {
+              new (...args: infer A1): unknown;
+              new (...args: infer A2): unknown;
+          }
+        ? Construtors<A1, A2, undefined, undefined>
+        : T extends new (...args: infer A) => unknown
+          ? Construtors<A, undefined, undefined, undefined>
+          : Construtors<undefined, undefined, undefined, undefined>;
+
+type AnyConstructors = Construtors<any, any, any, any>;
+
+/**
+ * Returns all constructors where the first paramter is assignable to given "scope"
+ */
+// eslint-disable-next-line @typescript-eslint/consistent-type-definitions
+type FilterConstructorsByScope<T extends AnyConstructors, S> = {
+    a: S extends T['a'][0] ? T['a'] : undefined;
+    b: S extends T['b'][0] ? T['b'] : undefined;
+    c: S extends T['c'][0] ? T['c'] : undefined;
+    d: S extends T['d'][0] ? T['d'] : undefined;
+};
+/**
+ * "flattens" the tuple into an union type
+ */
+type ConstructorUnion<T extends AnyConstructors> =
+    | Exclude<T['a'], undefined>
+    | Exclude<T['b'], undefined>
+    | Exclude<T['c'], undefined>
+    | Exclude<T['d'], undefined>;
+
+/**
+ * Extract list of possible scopes - union of the first paramter
+ * of all constructors, should it be string
+ */
+type ExtractScopes<T extends AnyConstructors> =
+    | (T['a'][0] extends string ? T['a'][0] : never)
+    | (T['b'][0] extends string ? T['b'][0] : never)
+    | (T['c'][0] extends string ? T['c'][0] : never)
+    | (T['d'][0] extends string ? T['d'][0] : never);
+
+type GetConstructorsByScope<T, S> = ConstructorUnion<FilterConstructorsByScope<OverloadedConstructorsOf<T>, S>>;
+type GetConstructors<T> = ConstructorUnion<OverloadedConstructorsOf<T>>;
+type GetPossibleScopes<T> = ExtractScopes<OverloadedConstructorsOf<T>>;
+
+export type ConvertType = (...params: unknown[]) => ShaderNodeObject<Node>;
+
+type NodeArray<T extends NodeObjectOption[]> = { [index in keyof T]: NodeObject<T[index]> };
+type NodeObjects<T> = { [key in keyof T]: T[key] extends NodeObjectOption ? NodeObject<T[key]> : T[key] };
+type ConstructedNode<T> = T extends new (...args: any[]) => infer R ? (R extends Node ? R : never) : never;
+
 const parseSwizzle = props => props.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');
 const parseSwizzleAndSort = props => parseSwizzle(props).split('').sort().join('');
 
@@ -117,7 +281,7 @@ const shaderNodeHandler = {
 const nodeObjectsCacheMap = new WeakMap();
 const nodeBuilderFunctionsCacheMap = new WeakMap();
 
-const ShaderNodeObject = function (obj, altType = null) {
+const ShaderNodeObject = function <T extends NodeObjectOption>(obj: T, altType: string | null = null) {
     const type = getValueType(obj);
 
     if (type === 'node') {
@@ -186,18 +350,20 @@ const ShaderNodeImmutable = function (NodeClass, ...params) {
 };
 
 class ShaderCallNodeInternal extends Node {
-    constructor(shaderNode, inputNodes) {
+    shaderNode: ShaderNodeInternal;
+
+    constructor(shaderNode: ShaderNodeInternal, inputNodes) {
         super();
 
         this.shaderNode = shaderNode;
         this.inputNodes = inputNodes;
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.shaderNode.nodeType || this.getOutputNode(builder).getNodeType(builder);
     }
 
-    call(builder) {
+    call(builder: NodeBuilder) {
         const { shaderNode, inputNodes } = this;
 
         const properties = builder.getNodeProperties(shaderNode);
@@ -272,7 +438,15 @@ class ShaderCallNodeInternal extends Node {
     }
 }
 
+interface Layout {
+    name: string;
+    type: string;
+    inputs: { name: string; type: string }[];
+}
+
 class ShaderNodeInternal extends Node {
+    layout: Layout | null;
+
     constructor(jsFunc, nodeType) {
         super(nodeType);
 
@@ -284,7 +458,7 @@ class ShaderNodeInternal extends Node {
         this.once = false;
     }
 
-    setLayout(layout) {
+    setLayout(layout: Layout | null) {
         this.layout = layout;
 
         return this;
@@ -301,6 +475,8 @@ class ShaderNodeInternal extends Node {
     }
 }
 
+export type { ShaderNodeInternal };
+
 const bools = [false, true];
 const uints = [0, 1, 2, 3];
 const ints = [-1, -2];
@@ -394,10 +570,27 @@ export function ShaderNode(jsFunc, nodeType) {
     return new Proxy(new ShaderNodeInternal(jsFunc, nodeType), shaderNodeHandler);
 }
 
-export const nodeObject = (val, altType = null) => /* new */ ShaderNodeObject(val, altType);
+export const nodeObject = <T extends NodeObjectOption>(val: T, altType: string | null = null): NodeObject<T> =>
+    /* new */ ShaderNodeObject(val, altType);
 export const nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);
 export const nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
-export const nodeProxy = (...params) => new ShaderNodeProxy(...params);
+
+interface NodeProxy {
+    <T>(nodeClass: T): (...params: ProxiedTuple<GetConstructors<T>>) => ShaderNodeObject<ConstructedNode<T>>;
+    <T, S extends GetPossibleScopes<T>>(
+        nodeClass: T,
+        scope: S,
+    ): (...params: ProxiedTuple<RemoveTail<GetConstructorsByScope<T, S>>>) => ShaderNodeObject<ConstructedNode<T>>;
+    <T, S extends GetPossibleScopes<T>>(
+        nodeClass: T,
+        scope: S,
+        factor: NodeObjectOption,
+    ): (
+        ...params: ProxiedTuple<RemoveHeadAndTail<GetConstructorsByScope<T, S>>>
+    ) => ShaderNodeObject<ConstructedNode<T>>;
+}
+
+export const nodeProxy: NodeProxy = (...params) => new ShaderNodeProxy(...params);
 export const nodeImmutable = (...params) => new ShaderNodeImmutable(...params);
 
 export const Fn = (jsFunc, nodeType) => {
diff --git a/src-testing/src/renderers/common/Animation.ts b/src-testing/src/renderers/common/Animation.ts
index 0b00319a..c190633b 100644
--- a/src-testing/src/renderers/common/Animation.ts
+++ b/src-testing/src/renderers/common/Animation.ts
@@ -1,5 +1,14 @@
+import Nodes from './nodes/Nodes.js';
+import Info from './Info.js';
+
 class Animation {
-    constructor(nodes, info) {
+    nodes: Nodes;
+    info: Info;
+
+    animationLoop: ((time: DOMHighResTimeStamp, frame?: XRFrame) => void) | null;
+    requestId: number | null;
+
+    constructor(nodes: Nodes, info: Info) {
         this.nodes = nodes;
         this.info = info;
 
@@ -10,7 +19,7 @@ class Animation {
     }
 
     _init() {
-        const update = (time, frame) => {
+        const update = (time?: DOMHighResTimeStamp, frame?: XRFrame) => {
             this.requestId = self.requestAnimationFrame(update);
 
             if (this.info.autoReset === true) this.info.reset();
@@ -19,18 +28,18 @@ class Animation {
 
             this.info.frame = this.nodes.nodeFrame.frameId;
 
-            if (this.animationLoop !== null) this.animationLoop(time, frame);
+            if (this.animationLoop !== null) this.animationLoop(time!, frame);
         };
 
         update();
     }
 
     dispose() {
-        self.cancelAnimationFrame(this.requestId);
+        self.cancelAnimationFrame(this.requestId!);
         this.requestId = null;
     }
 
-    setAnimationLoop(callback) {
+    setAnimationLoop(callback: ((time: DOMHighResTimeStamp, frame?: XRFrame) => void) | null) {
         this.animationLoop = callback;
     }
 }
diff --git a/src-testing/src/renderers/common/Attributes.ts b/src-testing/src/renderers/common/Attributes.ts
index 4631d528..a9edf948 100644
--- a/src-testing/src/renderers/common/Attributes.ts
+++ b/src-testing/src/renderers/common/Attributes.ts
@@ -2,15 +2,25 @@ import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
 
 import { DynamicDrawUsage } from '../../constants.js';
+import { BufferAttribute } from '../../core/BufferAttribute.js';
+import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
+import Backend from './Backend.js';
+import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
 
-class Attributes extends DataMap {
-    constructor(backend) {
+interface Data {
+    version?: number | undefined;
+}
+
+class Attributes extends DataMap<{ attribute: { key: BufferAttribute | InterleavedBufferAttribute; value: Data } }> {
+    backend: Backend;
+
+    constructor(backend: Backend) {
         super();
 
         this.backend = backend;
     }
 
-    delete(attribute) {
+    delete(attribute: BufferAttribute | InterleavedBufferAttribute) {
         const attributeData = super.delete(attribute);
 
         if (attributeData !== undefined) {
@@ -20,7 +30,7 @@ class Attributes extends DataMap {
         return attributeData;
     }
 
-    update(attribute, type) {
+    update(attribute: BufferAttribute | InterleavedBufferAttribute, type: AttributeType) {
         const data = this.get(attribute);
 
         if (data.version === undefined) {
@@ -46,10 +56,11 @@ class Attributes extends DataMap {
         }
     }
 
-    _getBufferAttribute(attribute) {
-        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
+    _getBufferAttribute(attribute: BufferAttribute | InterleavedBufferAttribute) {
+        if ((attribute as InterleavedBufferAttribute).isInterleavedBufferAttribute)
+            (attribute as BufferAttribute | InterleavedBuffer) = (attribute as InterleavedBufferAttribute).data;
 
-        return attribute;
+        return attribute as BufferAttribute | InterleavedBuffer;
     }
 }
 
diff --git a/src-testing/src/renderers/common/Backend.ts b/src-testing/src/renderers/common/Backend.ts
index edd4fcf9..28f354e9 100644
--- a/src-testing/src/renderers/common/Backend.ts
+++ b/src-testing/src/renderers/common/Backend.ts
@@ -1,25 +1,71 @@
-let vector2 = null;
-let vector4 = null;
-let color4 = null;
-
 import Color4 from './Color4.js';
 import { Vector2 } from '../../math/Vector2.js';
 import { Vector4 } from '../../math/Vector4.js';
 import { createCanvasElement } from '../../utils.js';
-import { REVISION } from '../../constants.js';
+import { CoordinateSystem, REVISION } from '../../constants.js';
+import RenderObject from './RenderObject.js';
+import RenderContext from './RenderContext.js';
+import RenderBundle from './RenderBundle.js';
+import { Texture } from '../../textures/Texture.js';
+import Renderer from './Renderer.js';
+import { BufferAttribute, TypedArray } from '../../core/BufferAttribute.js';
+import { Object3D } from '../../core/Object3D.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import { Scene } from '../../scenes/Scene.js';
+import NodeBuilder from '../../nodes/core/NodeBuilder.js';
+
+let vector2: Vector2 | null = null;
+let vector4: Vector4 | null = null;
+let color4: Color4 | null = null;
+
+export interface BackendParameters {
+    canvas?: HTMLCanvasElement | undefined;
+    antialias?: boolean;
+}
+
+interface RenderContextData {
+    renderObjects?: RenderObject[];
+}
+
+interface RenderBundleData {
+    renderContexts?: Set<RenderContext>;
+}
+
+interface RenderObjectData {}
 
-class Backend {
-    constructor(parameters = {}) {
+interface TextureData {}
+
+abstract class Backend {
+    parameters: BackendParameters;
+    data: WeakMap<
+        RenderContext | RenderBundle | RenderObject | Texture,
+        RenderContextData | RenderBundleData | RenderObjectData | TextureData
+    >;
+    renderer: Renderer | null;
+    domElement: HTMLCanvasElement | null;
+
+    constructor(parameters: BackendParameters = {}) {
         this.parameters = Object.assign({}, parameters);
-        this.data = new WeakMap();
+        this.data = new WeakMap<
+            RenderContext | RenderBundle | RenderObject | Texture,
+            RenderContextData | RenderBundleData | RenderObjectData | TextureData
+        >();
         this.renderer = null;
         this.domElement = null;
     }
 
-    async init(renderer) {
+    async init(renderer: Renderer) {
         this.renderer = renderer;
     }
 
+    abstract get coordinateSystem(): CoordinateSystem;
+
+    abstract getArrayBufferAsync(attribute: BufferAttribute): Promise<ArrayBuffer>;
+
+    abstract isOccluded(renderContext: RenderContext, object: Object): boolean;
+
+    abstract getMaxAnisotropy(): number;
+
     // render context
 
     begin(/*renderContext*/) {}
@@ -58,7 +104,11 @@ class Backend {
 
     // node builder
 
-    createNodeBuilder(/*renderObject*/) {} // return NodeBuilder (ADD IT)
+    abstract createNodeBuilder(
+        renderObject: Object3D | ComputeNode,
+        renderer: Renderer,
+        scene?: Scene | null,
+    ): NodeBuilder; // return NodeBuilder (ADD IT)
 
     // textures
 
@@ -68,7 +118,13 @@ class Backend {
 
     createTexture(/*texture*/) {}
 
-    copyTextureToBuffer(/*texture, x, y, width, height*/) {}
+    abstract copyTextureToBuffer(
+        texture: Texture,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+    ): Promise<TypedArray>;
 
     // attributes
 
@@ -147,7 +203,11 @@ class Backend {
         this.data.set(object, value);
     }
 
-    get(object) {
+    get(object: RenderContext): RenderContextData;
+    get(object: RenderBundle): RenderBundleData;
+    get(object: RenderObject): RenderObjectData;
+    get(object: Texture): TextureData;
+    get(object: RenderContext | RenderBundle | RenderObject | Texture) {
         let map = this.data.get(object);
 
         if (map === undefined) {
@@ -158,11 +218,11 @@ class Backend {
         return map;
     }
 
-    has(object) {
+    has(object: RenderContext) {
         return this.data.has(object);
     }
 
-    delete(object) {
+    delete(object: RenderContext) {
         this.data.delete(object);
     }
 }
diff --git a/src-testing/src/renderers/common/Background.ts b/src-testing/src/renderers/common/Background.ts
index b56dd372..c9935ed7 100644
--- a/src-testing/src/renderers/common/Background.ts
+++ b/src-testing/src/renderers/common/Background.ts
@@ -13,18 +13,33 @@ import NodeMaterial from '../../materials/nodes/NodeMaterial.js';
 import { Mesh } from '../../objects/Mesh.js';
 import { SphereGeometry } from '../../geometries/SphereGeometry.js';
 import { BackSide, LinearSRGBColorSpace } from '../../constants.js';
+import { Scene } from '../../scenes/Scene.js';
+import Renderer from './Renderer.js';
+import Nodes from './nodes/Nodes.js';
+import RenderList from './RenderList.js';
+import RenderContext from './RenderContext.js';
 
 const _clearColor = /*@__PURE__*/ new Color4();
 
-class Background extends DataMap {
-    constructor(renderer, nodes) {
+interface SceneData {
+    backgroundMesh?: Mesh;
+    // TODO
+    // backgroundMeshNode?: Node;
+    backgroundCacheKey: string;
+}
+
+class Background extends DataMap<{ scene: { key: Scene; value: SceneData } }> {
+    renderer: Renderer;
+    nodes: Nodes;
+
+    constructor(renderer: Renderer, nodes: Nodes) {
         super();
 
         this.renderer = renderer;
         this.nodes = nodes;
     }
 
-    update(scene, renderList, renderContext) {
+    update(scene: Scene, renderList: RenderList, renderContext: RenderContext) {
         const renderer = this.renderer;
         const background = this.nodes.getBackgroundNode(scene) || scene.background;
 
diff --git a/src-testing/src/renderers/common/BindGroup.ts b/src-testing/src/renderers/common/BindGroup.ts
index ae78d478..8ed6febb 100644
--- a/src-testing/src/renderers/common/BindGroup.ts
+++ b/src-testing/src/renderers/common/BindGroup.ts
@@ -1,7 +1,22 @@
+import NodeUniformsGroup from './nodes/NodeUniformsGroup.js';
+import Binding from './Binding.js';
+
 let _id = 0;
 
 class BindGroup {
-    constructor(name = '', bindings = [], index = 0, bindingsReference = []) {
+    name: string;
+    bindings: NodeUniformsGroup[] | Binding[];
+    index: number;
+    bindingsReference: NodeUniformsGroup[] | BindGroup;
+
+    id: number;
+
+    constructor(
+        name = '',
+        bindings: NodeUniformsGroup[] = [],
+        index = 0,
+        bindingsReference: NodeUniformsGroup[] | BindGroup = [],
+    ) {
         this.name = name;
         this.bindings = bindings;
         this.index = index;
diff --git a/src-testing/src/renderers/common/Binding.ts b/src-testing/src/renderers/common/Binding.ts
index a12f3563..e7ae8d1c 100644
--- a/src-testing/src/renderers/common/Binding.ts
+++ b/src-testing/src/renderers/common/Binding.ts
@@ -1,16 +1,20 @@
 class Binding {
+    name: string;
+
+    visibility: number;
+
     constructor(name = '') {
         this.name = name;
 
         this.visibility = 0;
     }
 
-    setVisibility(visibility) {
+    setVisibility(visibility: number) {
         this.visibility |= visibility;
     }
 
     clone() {
-        return Object.assign(new this.constructor(), this);
+        return Object.assign(new (this.constructor as typeof Binding)(), this);
     }
 }
 
diff --git a/src-testing/src/renderers/common/Bindings.ts b/src-testing/src/renderers/common/Bindings.ts
index fee94385..0c13e27c 100644
--- a/src-testing/src/renderers/common/Bindings.ts
+++ b/src-testing/src/renderers/common/Bindings.ts
@@ -1,8 +1,42 @@
 import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
+import Backend from './Backend.js';
+import Nodes from './nodes/Nodes.js';
+import Textures from './Textures.js';
+import Attributes from './Attributes.js';
+import Pipelines from './Pipelines.js';
+import Info from './Info.js';
+import RenderObject from './RenderObject.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import { SampledTexture } from './SampledTexture.js';
+import StorageBuffer from './StorageBuffer.js';
+import NodeUniformsGroup from './nodes/NodeUniformsGroup.js';
+import UniformBuffer from './UniformBuffer.js';
+import Sampler from './Sampler.js';
+import BindGroup from './BindGroup.js';
+
+interface BindGroupData {
+    bindGroup?: BindGroup | undefined;
+}
 
-class Bindings extends DataMap {
-    constructor(backend, nodes, textures, attributes, pipelines, info) {
+class Bindings extends DataMap<{
+    bindGroup: { key: BindGroup; value: BindGroupData };
+}> {
+    backend: Backend;
+    textures: Textures;
+    pipelines: Pipelines;
+    attributes: Attributes;
+    nodes: Nodes;
+    info: Info;
+
+    constructor(
+        backend: Backend,
+        nodes: Nodes,
+        textures: Textures,
+        attributes: Attributes,
+        pipelines: Pipelines,
+        info: Info,
+    ) {
         super();
 
         this.backend = backend;
@@ -15,7 +49,7 @@ class Bindings extends DataMap {
         this.pipelines.bindings = this; // assign bindings to pipelines
     }
 
-    getForRender(renderObject) {
+    getForRender(renderObject: RenderObject) {
         const bindings = renderObject.getBindings();
 
         for (const bindGroup of bindings) {
@@ -35,7 +69,7 @@ class Bindings extends DataMap {
         return bindings;
     }
 
-    getForCompute(computeNode) {
+    getForCompute(computeNode: ComputeNode) {
         const bindings = this.nodes.getForCompute(computeNode).bindings;
 
         for (const bindGroup of bindings) {
@@ -53,26 +87,26 @@ class Bindings extends DataMap {
         return bindings;
     }
 
-    updateForCompute(computeNode) {
+    updateForCompute(computeNode: ComputeNode) {
         this._updateBindings(this.getForCompute(computeNode));
     }
 
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         this._updateBindings(this.getForRender(renderObject));
     }
 
-    _updateBindings(bindings) {
+    _updateBindings(bindings: BindGroup[]) {
         for (const bindGroup of bindings) {
             this._update(bindGroup, bindings);
         }
     }
 
-    _init(bindGroup) {
+    _init(bindGroup: BindGroup) {
         for (const binding of bindGroup.bindings) {
-            if (binding.isSampledTexture) {
-                this.textures.updateTexture(binding.texture);
-            } else if (binding.isStorageBuffer) {
-                const attribute = binding.attribute;
+            if ((binding as SampledTexture).isSampledTexture) {
+                this.textures.updateTexture((binding as SampledTexture).texture);
+            } else if ((binding as StorageBuffer).isStorageBuffer) {
+                const attribute = (binding as StorageBuffer).attribute;
                 const attributeType = attribute.isIndirectStorageBufferAttribute
                     ? AttributeType.INDIRECT
                     : AttributeType.STORAGE;
@@ -82,7 +116,7 @@ class Bindings extends DataMap {
         }
     }
 
-    _update(bindGroup, bindings) {
+    _update(bindGroup: BindGroup, bindings: BindGroup[]) {
         const { backend } = this;
 
         let needsBindingsUpdate = false;
@@ -90,27 +124,31 @@ class Bindings extends DataMap {
         // iterate over all bindings and check if buffer updates or a new binding group is required
 
         for (const binding of bindGroup.bindings) {
-            if (binding.isNodeUniformsGroup) {
-                const updated = this.nodes.updateGroup(binding);
+            if ((binding as NodeUniformsGroup).isNodeUniformsGroup) {
+                const updated = this.nodes.updateGroup(binding as NodeUniformsGroup);
 
                 if (!updated) continue;
             }
 
-            if (binding.isUniformBuffer) {
-                const updated = binding.update();
+            if ((binding as UniformBuffer).isUniformBuffer) {
+                const updated = (binding as UniformBuffer).update();
 
                 if (updated) {
-                    backend.updateBinding(binding);
+                    backend.updateBinding(binding as UniformBuffer);
                 }
-            } else if (binding.isSampler) {
-                binding.update();
-            } else if (binding.isSampledTexture) {
-                if (binding.needsBindingsUpdate(this.textures.get(binding.texture).generation))
+            } else if ((binding as Sampler).isSampler) {
+                (binding as Sampler).update();
+            } else if ((binding as SampledTexture).isSampledTexture) {
+                if (
+                    (binding as SampledTexture).needsBindingsUpdate(
+                        this.textures.get((binding as SampledTexture).texture).generation,
+                    )
+                )
                     needsBindingsUpdate = true;
 
-                const updated = binding.update();
+                const updated = (binding as SampledTexture).update();
 
-                const texture = binding.texture;
+                const texture = (binding as SampledTexture).texture;
 
                 if (updated) {
                     this.textures.updateTexture(texture);
@@ -126,10 +164,10 @@ class Bindings extends DataMap {
                     // TODO: Remove this once we found why updated === false isn't bound to a texture in the WebGPU backend
                     console.error(
                         'Bindings._update: binding should be available:',
-                        binding,
+                        binding as SampledTexture,
                         updated,
                         texture,
-                        binding.textureNode.value,
+                        (binding as SampledTexture).textureNode.value,
                         needsBindingsUpdate,
                     );
 
@@ -140,7 +178,7 @@ class Bindings extends DataMap {
                 if (texture.isStorageTexture === true) {
                     const textureData = this.get(texture);
 
-                    if (binding.store === true) {
+                    if ((binding as SampledTexture).store === true) {
                         textureData.needsMipmap = true;
                     } else if (
                         texture.generateMipmaps === true &&
diff --git a/src-testing/src/renderers/common/Buffer.ts b/src-testing/src/renderers/common/Buffer.ts
index 17013c6d..830dc0a8 100644
--- a/src-testing/src/renderers/common/Buffer.ts
+++ b/src-testing/src/renderers/common/Buffer.ts
@@ -2,7 +2,13 @@ import Binding from './Binding.js';
 import { getFloatLength } from './BufferUtils.js';
 
 class Buffer extends Binding {
-    constructor(name, buffer = null) {
+    readonly isBuffer: true;
+
+    bytesPerElement: number;
+
+    _buffer: Float32Array | null;
+
+    constructor(name?: string, buffer: Float32Array | null = null) {
         super(name);
 
         this.isBuffer = true;
@@ -13,7 +19,7 @@ class Buffer extends Binding {
     }
 
     get byteLength() {
-        return getFloatLength(this._buffer.byteLength);
+        return getFloatLength(this._buffer!.byteLength);
     }
 
     get buffer() {
diff --git a/src-testing/src/renderers/common/BufferUtils.ts b/src-testing/src/renderers/common/BufferUtils.ts
index 99ddcb48..e18679b1 100644
--- a/src-testing/src/renderers/common/BufferUtils.ts
+++ b/src-testing/src/renderers/common/BufferUtils.ts
@@ -1,12 +1,12 @@
 import { GPU_CHUNK_BYTES } from './Constants.js';
 
-function getFloatLength(floatLength) {
+function getFloatLength(floatLength: number) {
     // ensure chunk size alignment (STD140 layout)
 
     return floatLength + ((GPU_CHUNK_BYTES - (floatLength % GPU_CHUNK_BYTES)) % GPU_CHUNK_BYTES);
 }
 
-function getVectorLength(count, vectorLength = 4) {
+function getVectorLength(count: number, vectorLength = 4) {
     const strideLength = getStrideLength(vectorLength);
 
     const floatLength = strideLength * count;
@@ -14,7 +14,7 @@ function getVectorLength(count, vectorLength = 4) {
     return getFloatLength(floatLength);
 }
 
-function getStrideLength(vectorLength) {
+function getStrideLength(vectorLength: number) {
     const strideLength = 4;
 
     return vectorLength + ((strideLength - (vectorLength % strideLength)) % strideLength);
diff --git a/src-testing/src/renderers/common/BundleGroup.ts b/src-testing/src/renderers/common/BundleGroup.ts
index 1dd8e0a2..b0e36aaf 100644
--- a/src-testing/src/renderers/common/BundleGroup.ts
+++ b/src-testing/src/renderers/common/BundleGroup.ts
@@ -1,6 +1,13 @@
 import { Group } from '../../objects/Group.js';
 
 class BundleGroup extends Group {
+    readonly isBundleGroup: true;
+
+    readonly type: string;
+
+    static: boolean;
+    version: number;
+
     constructor() {
         super();
 
@@ -12,7 +19,7 @@ class BundleGroup extends Group {
         this.version = 0;
     }
 
-    set needsUpdate(value) {
+    set needsUpdate(value: boolean) {
         if (value === true) this.version++;
     }
 }
diff --git a/src-testing/src/renderers/common/ChainMap.ts b/src-testing/src/renderers/common/ChainMap.ts
index b17e7080..e2b545b7 100644
--- a/src-testing/src/renderers/common/ChainMap.ts
+++ b/src-testing/src/renderers/common/ChainMap.ts
@@ -1,39 +1,43 @@
-export default class ChainMap {
+type RecursiveWeakMap<K extends readonly object[], V> = WeakMap<K[number], V | RecursiveWeakMap<K, V>>;
+
+export default class ChainMap<K extends readonly object[], V> {
+    weakMap: RecursiveWeakMap<K, V>;
+
     constructor() {
-        this.weakMap = new WeakMap();
+        this.weakMap = new WeakMap<K[number], V | RecursiveWeakMap<K, V>>();
     }
 
-    get(keys) {
-        let map = this.weakMap;
+    get(keys: K): V | undefined {
+        let map: RecursiveWeakMap<K, V> | undefined = this.weakMap;
 
         for (let i = 0; i < keys.length; i++) {
-            map = map.get(keys[i]);
+            map = map.get(keys[i]) as RecursiveWeakMap<K, V> | undefined;
 
             if (map === undefined) return undefined;
         }
 
-        return map.get(keys[keys.length - 1]);
+        return map.get(keys[keys.length - 1]) as V | undefined;
     }
 
-    set(keys, value) {
-        let map = this.weakMap;
+    set(keys: K, value: V) {
+        let map: RecursiveWeakMap<K, V> = this.weakMap;
 
         for (let i = 0; i < keys.length; i++) {
             const key = keys[i];
 
-            if (map.has(key) === false) map.set(key, new WeakMap());
+            if (map.has(key) === false) map.set(key, new WeakMap<K[number], V | RecursiveWeakMap<K, V>>());
 
-            map = map.get(key);
+            map = map.get(key) as RecursiveWeakMap<K, V>;
         }
 
-        return map.set(keys[keys.length - 1], value);
+        return map.set(keys[keys.length - 1], value) as V;
     }
 
-    delete(keys) {
-        let map = this.weakMap;
+    delete(keys: K) {
+        let map: RecursiveWeakMap<K, V> | undefined = this.weakMap;
 
         for (let i = 0; i < keys.length; i++) {
-            map = map.get(keys[i]);
+            map = map.get(keys[i]) as RecursiveWeakMap<K, V> | undefined;
 
             if (map === undefined) return false;
         }
diff --git a/src-testing/src/renderers/common/ClippingContext.ts b/src-testing/src/renderers/common/ClippingContext.ts
index c5659721..ec2d8550 100644
--- a/src-testing/src/renderers/common/ClippingContext.ts
+++ b/src-testing/src/renderers/common/ClippingContext.ts
@@ -2,10 +2,30 @@ import { Matrix3 } from '../../math/Matrix3.js';
 import { Plane } from '../../math/Plane.js';
 import { Vector4 } from '../../math/Vector4.js';
 import { hash } from '../../nodes/core/NodeUtils.js';
+import { Matrix4 } from '../../math/Matrix4.js';
+import Renderer from './Renderer.js';
+import { Camera } from '../../cameras/Camera.js';
+import { Material } from '../../materials/Material.js';
 
 const _plane = /*@__PURE__*/ new Plane();
 
 class ClippingContext {
+    version: number;
+
+    globalClippingCount: number;
+
+    localClippingCount: number;
+    localClippingEnabled: boolean | undefined;
+    localClipIntersection: boolean;
+
+    planes: Vector4[];
+
+    parentVersion: number;
+    viewNormalMatrix: Matrix3;
+    cacheKey: number;
+
+    viewMatrix?: Matrix4 | undefined;
+
     constructor() {
         this.version = 0;
 
@@ -22,12 +42,12 @@ class ClippingContext {
         this.cacheKey = 0;
     }
 
-    projectPlanes(source, offset) {
+    projectPlanes(source: readonly Plane[], offset: number) {
         const l = source.length;
         const planes = this.planes;
 
         for (let i = 0; i < l; i++) {
-            _plane.copy(source[i]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
+            _plane.copy(source[i]).applyMatrix4(this.viewMatrix!, this.viewNormalMatrix);
 
             const v = planes[offset + i];
             const normal = _plane.normal;
@@ -39,7 +59,7 @@ class ClippingContext {
         }
     }
 
-    updateGlobal(renderer, camera) {
+    updateGlobal(renderer: Renderer, camera: Camera) {
         const rendererClippingPlanes = renderer.clippingPlanes;
         this.viewMatrix = camera.matrixWorldInverse;
 
@@ -81,7 +101,7 @@ class ClippingContext {
         }
     }
 
-    update(parent, material) {
+    update(parent: ClippingContext, material: Material) {
         let update = false;
 
         if (this !== parent && parent.version !== this.parentVersion) {
diff --git a/src-testing/src/renderers/common/Color4.ts b/src-testing/src/renderers/common/Color4.ts
index 77caa31e..8ec327a7 100644
--- a/src-testing/src/renderers/common/Color4.ts
+++ b/src-testing/src/renderers/common/Color4.ts
@@ -1,26 +1,31 @@
-import { Color } from '../../math/Color.js';
+import { Color, ColorRepresentation } from '../../math/Color.js';
 
 class Color4 extends Color {
-    constructor(r, g, b, a = 1) {
-        super(r, g, b);
+    a: number;
+
+    constructor(color?: ColorRepresentation);
+    constructor(r: number, g: number, b: number, a?: number);
+    constructor(r?: number, g?: number, b?: number, a = 1) {
+        super(r as number, g!, b!);
 
         this.a = a;
     }
 
-    set(r, g, b, a = 1) {
+    set(...args: [color: ColorRepresentation] | [r: number, g: number, b: number, a?: number]): this;
+    set(r: number, g: number, b: number, a = 1) {
         this.a = a;
 
         return super.set(r, g, b);
     }
 
-    copy(color) {
-        if (color.a !== undefined) this.a = color.a;
+    copy(color: Color) {
+        if ((color as Color4).a !== undefined) this.a = (color as Color4).a;
 
         return super.copy(color);
     }
 
-    clone() {
-        return new this.constructor(this.r, this.g, this.b, this.a);
+    clone(): this {
+        return new (this.constructor as typeof Color4)(this.r, this.g, this.b, this.a) as this;
     }
 }
 
diff --git a/src-testing/src/renderers/common/ComputePipeline.ts b/src-testing/src/renderers/common/ComputePipeline.ts
index 0fd3ca53..f6112ccf 100644
--- a/src-testing/src/renderers/common/ComputePipeline.ts
+++ b/src-testing/src/renderers/common/ComputePipeline.ts
@@ -1,7 +1,12 @@
 import Pipeline from './Pipeline.js';
+import ProgrammableStage from './ProgrammableStage.js';
 
 class ComputePipeline extends Pipeline {
-    constructor(cacheKey, computeProgram) {
+    computeProgram: ProgrammableStage;
+
+    readonly isComputePipeline: true;
+
+    constructor(cacheKey: string, computeProgram: ProgrammableStage) {
         super(cacheKey);
 
         this.computeProgram = computeProgram;
diff --git a/src-testing/src/renderers/common/Constants.ts b/src-testing/src/renderers/common/Constants.ts
index c2dfad4c..02330947 100644
--- a/src-testing/src/renderers/common/Constants.ts
+++ b/src-testing/src/renderers/common/Constants.ts
@@ -3,7 +3,9 @@ export const AttributeType = {
     INDEX: 2,
     STORAGE: 3,
     INDIRECT: 4,
-};
+} as const;
+
+export type AttributeType = (typeof AttributeType)[keyof typeof AttributeType];
 
 // size of a chunk in bytes (STD140 layout)
 
diff --git a/src-testing/src/renderers/common/CubeRenderTarget.ts b/src-testing/src/renderers/common/CubeRenderTarget.ts
index 00c0fd8c..50f7e146 100644
--- a/src-testing/src/renderers/common/CubeRenderTarget.ts
+++ b/src-testing/src/renderers/common/CubeRenderTarget.ts
@@ -9,17 +9,22 @@ import { CubeCamera } from '../../cameras/CubeCamera.js';
 import { BoxGeometry } from '../../geometries/BoxGeometry.js';
 import { Mesh } from '../../objects/Mesh.js';
 import { BackSide, NoBlending, LinearFilter, LinearMipmapLinearFilter } from '../../constants.js';
+import { RenderTargetOptions } from '../../core/RenderTarget.js';
+import { WebGLRenderer } from '../WebGLRenderer.js';
+import { Texture } from '../../textures/Texture.js';
 
 // @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget
 
 class CubeRenderTarget extends WebGLCubeRenderTarget {
-    constructor(size = 1, options = {}) {
+    readonly isCubeRenderTarget: true;
+
+    constructor(size = 1, options: RenderTargetOptions = {}) {
         super(size, options);
 
         this.isCubeRenderTarget = true;
     }
 
-    fromEquirectangularTexture(renderer, texture) {
+    fromEquirectangularTexture(renderer: WebGLRenderer, texture: Texture) {
         const currentMinFilter = texture.minFilter;
         const currentGenerateMipmaps = texture.generateMipmaps;
 
diff --git a/src-testing/src/renderers/common/DataMap.ts b/src-testing/src/renderers/common/DataMap.ts
index 006bc295..eb39fca8 100644
--- a/src-testing/src/renderers/common/DataMap.ts
+++ b/src-testing/src/renderers/common/DataMap.ts
@@ -1,9 +1,11 @@
-class DataMap {
+class DataMap<M extends { [key: string]: { key: object; value: unknown } }> {
+    data: WeakMap<M[keyof M]['key'], M[keyof M]['value']>;
+
     constructor() {
-        this.data = new WeakMap();
+        this.data = new WeakMap<M[keyof M]['key'], M[keyof M]['value']>();
     }
 
-    get(object) {
+    get<K extends M[keyof M]['key']>(object: K): Extract<M[keyof M], { key: K }>['value'] {
         let map = this.data.get(object);
 
         if (map === undefined) {
@@ -14,7 +16,7 @@ class DataMap {
         return map;
     }
 
-    delete(object) {
+    delete<K extends M[keyof M]['key']>(object: K): Extract<M[keyof M], { key: K }>['value'] {
         let map;
 
         if (this.data.has(object)) {
@@ -26,7 +28,7 @@ class DataMap {
         return map;
     }
 
-    has(object) {
+    has(object: M[keyof M]['key']) {
         return this.data.has(object);
     }
 
diff --git a/src-testing/src/renderers/common/Geometries.ts b/src-testing/src/renderers/common/Geometries.ts
index 9072f238..a8e29552 100644
--- a/src-testing/src/renderers/common/Geometries.ts
+++ b/src-testing/src/renderers/common/Geometries.ts
@@ -1,9 +1,15 @@
 import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
 
-import { Uint16BufferAttribute, Uint32BufferAttribute } from '../../core/BufferAttribute.js';
-
-function arrayNeedsUint32(array) {
+import { BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from '../../core/BufferAttribute.js';
+import { BufferGeometry } from '../../core/BufferGeometry.js';
+import Attributes from './Attributes.js';
+import Info from './Info.js';
+import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
+import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
+import RenderObject from './RenderObject.js';
+
+function arrayNeedsUint32(array: number[]) {
     // assumes larger values usually on last
 
     for (let i = array.length - 1; i >= 0; --i) {
@@ -13,11 +19,11 @@ function arrayNeedsUint32(array) {
     return false;
 }
 
-function getWireframeVersion(geometry) {
-    return geometry.index !== null ? geometry.index.version : geometry.attributes.position.version;
+function getWireframeVersion(geometry: BufferGeometry) {
+    return geometry.index !== null ? geometry.index.version : (geometry.attributes.position as BufferAttribute).version;
 }
 
-function getWireframeIndex(geometry) {
+function getWireframeIndex(geometry: BufferGeometry) {
     const indices = [];
 
     const geometryIndex = geometry.index;
@@ -51,31 +57,41 @@ function getWireframeIndex(geometry) {
     return attribute;
 }
 
-class Geometries extends DataMap {
-    constructor(attributes, info) {
+interface GeometryData {
+    initialized?: boolean | undefined;
+}
+
+class Geometries extends DataMap<{ geometry: { key: BufferGeometry; value: GeometryData } }> {
+    attributes: Attributes;
+    info: Info;
+
+    wireframes: WeakMap<BufferGeometry, BufferAttribute>;
+    attributeCall: WeakMap<BufferAttribute | InterleavedBufferAttribute | InterleavedBuffer, number>;
+
+    constructor(attributes: Attributes, info: Info) {
         super();
 
         this.attributes = attributes;
         this.info = info;
 
-        this.wireframes = new WeakMap();
+        this.wireframes = new WeakMap<BufferGeometry, BufferAttribute>();
 
-        this.attributeCall = new WeakMap();
+        this.attributeCall = new WeakMap<BufferAttribute | InterleavedBufferAttribute, number>();
     }
 
-    has(renderObject) {
-        const geometry = renderObject.geometry;
+    has(renderObject: RenderObject | BufferGeometry) {
+        const geometry = (renderObject as RenderObject).geometry;
 
         return super.has(geometry) && this.get(geometry).initialized === true;
     }
 
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         if (this.has(renderObject) === false) this.initGeometry(renderObject);
 
         this.updateAttributes(renderObject);
     }
 
-    initGeometry(renderObject) {
+    initGeometry(renderObject: RenderObject) {
         const geometry = renderObject.geometry;
         const geometryData = this.get(geometry);
 
@@ -109,7 +125,7 @@ class Geometries extends DataMap {
         geometry.addEventListener('dispose', onDispose);
     }
 
-    updateAttributes(renderObject) {
+    updateAttributes(renderObject: RenderObject) {
         const attributes = renderObject.getAttributes();
 
         for (const attribute of attributes) {
@@ -127,10 +143,10 @@ class Geometries extends DataMap {
         }
     }
 
-    updateAttribute(attribute, type) {
+    updateAttribute(attribute: BufferAttribute | InterleavedBufferAttribute, type: AttributeType) {
         const callId = this.info.render.calls;
 
-        if (!attribute.isInterleavedBufferAttribute) {
+        if (!(attribute as InterleavedBufferAttribute).isInterleavedBufferAttribute) {
             if (this.attributeCall.get(attribute) !== callId) {
                 this.attributes.update(attribute, type);
 
@@ -141,17 +157,17 @@ class Geometries extends DataMap {
                 this.attributes.update(attribute, type);
 
                 this.attributeCall.set(attribute, callId);
-            } else if (this.attributeCall.get(attribute.data) !== callId) {
+            } else if (this.attributeCall.get((attribute as InterleavedBufferAttribute).data) !== callId) {
                 this.attributes.update(attribute, type);
 
-                this.attributeCall.set(attribute.data, callId);
+                this.attributeCall.set((attribute as InterleavedBufferAttribute).data, callId);
 
                 this.attributeCall.set(attribute, callId);
             }
         }
     }
 
-    getIndex(renderObject) {
+    getIndex(renderObject: RenderObject) {
         const { geometry, material } = renderObject;
 
         let index = geometry.index;
diff --git a/src-testing/src/renderers/common/Info.ts b/src-testing/src/renderers/common/Info.ts
index 4ede75de..38b7b9cd 100644
--- a/src-testing/src/renderers/common/Info.ts
+++ b/src-testing/src/renderers/common/Info.ts
@@ -1,4 +1,41 @@
+import { Object3D } from '../../core/Object3D.js';
+import { Mesh } from '../../objects/Mesh.js';
+import { Sprite } from '../../objects/Sprite.js';
+import { Points } from '../../objects/Points.js';
+import { LineSegments } from '../../objects/LineSegments.js';
+import { Line } from '../../objects/Line.js';
+
 class Info {
+    autoReset: boolean;
+
+    frame: number;
+    calls: number;
+
+    render: {
+        calls: number;
+        frameCalls: number;
+        drawCalls: number;
+        triangles: number;
+        points: number;
+        lines: number;
+        timestamp: number;
+        previousFrameCalls: number;
+        timestampCalls: number;
+    };
+
+    compute: {
+        calls: number;
+        frameCalls: number;
+        timestamp: number;
+        previousFrameCalls: number;
+        timestampCalls: number;
+    };
+
+    memory: {
+        geometries: number;
+        textures: number;
+    };
+
     constructor() {
         this.autoReset = true;
 
@@ -31,23 +68,23 @@ class Info {
         };
     }
 
-    update(object, count, instanceCount) {
+    update(object: Object3D, count: number, instanceCount: number) {
         this.render.drawCalls++;
 
-        if (object.isMesh || object.isSprite) {
+        if ((object as Mesh).isMesh || (object as Sprite).isSprite) {
             this.render.triangles += instanceCount * (count / 3);
-        } else if (object.isPoints) {
+        } else if ((object as Points).isPoints) {
             this.render.points += instanceCount * count;
-        } else if (object.isLineSegments) {
+        } else if ((object as LineSegments).isLineSegments) {
             this.render.lines += instanceCount * (count / 2);
-        } else if (object.isLine) {
+        } else if ((object as Line).isLine) {
             this.render.lines += instanceCount * (count - 1);
         } else {
             console.error('THREE.WebGPUInfo: Unknown object type.');
         }
     }
 
-    updateTimestamp(type, time) {
+    updateTimestamp(type: 'render' | 'compute', time: number) {
         if (this[type].timestampCalls === 0) {
             this[type].timestamp = 0;
         }
diff --git a/src-testing/src/renderers/common/Pipeline.ts b/src-testing/src/renderers/common/Pipeline.ts
index 16017455..16b5276c 100644
--- a/src-testing/src/renderers/common/Pipeline.ts
+++ b/src-testing/src/renderers/common/Pipeline.ts
@@ -1,5 +1,9 @@
 class Pipeline {
-    constructor(cacheKey) {
+    cacheKey: string;
+
+    usedTimes: number;
+
+    constructor(cacheKey: string) {
         this.cacheKey = cacheKey;
 
         this.usedTimes = 0;
diff --git a/src-testing/src/renderers/common/Pipelines.ts b/src-testing/src/renderers/common/Pipelines.ts
index 68c8f223..104bf8c9 100644
--- a/src-testing/src/renderers/common/Pipelines.ts
+++ b/src-testing/src/renderers/common/Pipelines.ts
@@ -2,9 +2,40 @@ import DataMap from './DataMap.js';
 import RenderPipeline from './RenderPipeline.js';
 import ComputePipeline from './ComputePipeline.js';
 import ProgrammableStage from './ProgrammableStage.js';
+import Backend from './Backend.js';
+import Nodes from './nodes/Nodes.js';
+import Bindings from './Bindings.js';
+import RenderObject from './RenderObject.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import Binding from './Binding.js';
+import Pipeline from './Pipeline.js';
+
+interface ComputeNodeData {
+    version: number;
+    pipeline: ComputePipeline;
+}
+
+interface RenderObjectData {
+    pipeline: RenderPipeline;
+}
+
+class Pipelines extends DataMap<{
+    computeNode: { key: ComputeNode; value: ComputeNodeData };
+    renderObject: { key: RenderObject; value: RenderObjectData };
+}> {
+    backend: Backend;
+    nodes: Nodes;
+
+    bindings: Bindings | null;
 
-class Pipelines extends DataMap {
-    constructor(backend, nodes) {
+    caches: Map<string, Pipeline>;
+    programs: {
+        vertex: Map<string, ProgrammableStage>;
+        fragment: Map<string, ProgrammableStage>;
+        compute: Map<string, ProgrammableStage>;
+    };
+
+    constructor(backend: Backend, nodes: Nodes) {
         super();
 
         this.backend = backend;
@@ -12,15 +43,15 @@ class Pipelines extends DataMap {
 
         this.bindings = null; // set by the bindings
 
-        this.caches = new Map();
+        this.caches = new Map<string, Pipeline>();
         this.programs = {
-            vertex: new Map(),
-            fragment: new Map(),
-            compute: new Map(),
+            vertex: new Map<string, ProgrammableStage>(),
+            fragment: new Map<string, ProgrammableStage>(),
+            compute: new Map<string, ProgrammableStage>(),
         };
     }
 
-    getForCompute(computeNode, bindings) {
+    getForCompute(computeNode: ComputeNode, bindings: Binding[]) {
         const { backend } = this;
 
         const data = this.get(computeNode);
@@ -39,19 +70,19 @@ class Pipelines extends DataMap {
 
             // programmable stage
 
-            let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader);
+            let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader!);
 
             if (stageCompute === undefined) {
                 if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0)
                     this._releaseProgram(previousPipeline.computeProgram);
 
                 stageCompute = new ProgrammableStage(
-                    nodeBuilderState.computeShader,
+                    nodeBuilderState.computeShader!,
                     'compute',
                     nodeBuilderState.transforms,
                     nodeBuilderState.nodeAttributes,
                 );
-                this.programs.compute.set(nodeBuilderState.computeShader, stageCompute);
+                this.programs.compute.set(nodeBuilderState.computeShader!, stageCompute);
 
                 backend.createProgram(stageCompute);
             }
@@ -60,7 +91,7 @@ class Pipelines extends DataMap {
 
             const cacheKey = this._getComputeCacheKey(computeNode, stageCompute);
 
-            let pipeline = this.caches.get(cacheKey);
+            let pipeline = this.caches.get(cacheKey) as ComputePipeline | undefined;
 
             if (pipeline === undefined) {
                 if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
@@ -82,7 +113,7 @@ class Pipelines extends DataMap {
         return data.pipeline;
     }
 
-    getForRender(renderObject, promises = null) {
+    getForRender(renderObject: RenderObject, promises: Promise<void>[] | null = null) {
         const { backend } = this;
 
         const data = this.get(renderObject);
@@ -102,26 +133,26 @@ class Pipelines extends DataMap {
 
             // programmable stages
 
-            let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);
+            let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader!);
 
             if (stageVertex === undefined) {
                 if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0)
                     this._releaseProgram(previousPipeline.vertexProgram);
 
-                stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader, 'vertex');
-                this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);
+                stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader!, 'vertex');
+                this.programs.vertex.set(nodeBuilderState.vertexShader!, stageVertex);
 
                 backend.createProgram(stageVertex);
             }
 
-            let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader);
+            let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader!);
 
             if (stageFragment === undefined) {
                 if (previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0)
                     this._releaseProgram(previousPipeline.fragmentProgram);
 
-                stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader, 'fragment');
-                this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);
+                stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader!, 'fragment');
+                this.programs.fragment.set(nodeBuilderState.fragmentShader!, stageFragment);
 
                 backend.createProgram(stageFragment);
             }
@@ -130,7 +161,7 @@ class Pipelines extends DataMap {
 
             const cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
 
-            let pipeline = this.caches.get(cacheKey);
+            let pipeline = this.caches.get(cacheKey) as RenderPipeline | undefined;
 
             if (pipeline === undefined) {
                 if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
@@ -154,7 +185,7 @@ class Pipelines extends DataMap {
         return data.pipeline;
     }
 
-    delete(object) {
+    delete(object: ComputeNode | RenderObject): never {
         const pipeline = this.get(object).pipeline;
 
         if (pipeline) {
@@ -166,20 +197,23 @@ class Pipelines extends DataMap {
 
             // programs
 
-            if (pipeline.isComputePipeline) {
-                pipeline.computeProgram.usedTimes--;
+            if ((pipeline as ComputePipeline).isComputePipeline) {
+                (pipeline as ComputePipeline).computeProgram.usedTimes--;
 
-                if (pipeline.computeProgram.usedTimes === 0) this._releaseProgram(pipeline.computeProgram);
+                if ((pipeline as ComputePipeline).computeProgram.usedTimes === 0)
+                    this._releaseProgram((pipeline as ComputePipeline).computeProgram);
             } else {
-                pipeline.fragmentProgram.usedTimes--;
-                pipeline.vertexProgram.usedTimes--;
+                (pipeline as RenderPipeline).fragmentProgram.usedTimes--;
+                (pipeline as RenderPipeline).vertexProgram.usedTimes--;
 
-                if (pipeline.vertexProgram.usedTimes === 0) this._releaseProgram(pipeline.vertexProgram);
-                if (pipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(pipeline.fragmentProgram);
+                if ((pipeline as RenderPipeline).vertexProgram.usedTimes === 0)
+                    this._releaseProgram((pipeline as RenderPipeline).vertexProgram);
+                if ((pipeline as RenderPipeline).fragmentProgram.usedTimes === 0)
+                    this._releaseProgram((pipeline as RenderPipeline).fragmentProgram);
             }
         }
 
-        return super.delete(object);
+        return super.delete(object) as never;
     }
 
     dispose() {
@@ -193,16 +227,21 @@ class Pipelines extends DataMap {
         };
     }
 
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         this.getForRender(renderObject);
     }
 
-    _getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {
+    _getComputePipeline(
+        computeNode: ComputeNode,
+        stageCompute: ProgrammableStage,
+        cacheKey: string,
+        bindings: Binding[],
+    ) {
         // check for existing pipeline
 
         cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);
 
-        let pipeline = this.caches.get(cacheKey);
+        let pipeline = this.caches.get(cacheKey) as ComputePipeline | undefined;
 
         if (pipeline === undefined) {
             pipeline = new ComputePipeline(cacheKey, stageCompute);
@@ -215,12 +254,18 @@ class Pipelines extends DataMap {
         return pipeline;
     }
 
-    _getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises) {
+    _getRenderPipeline(
+        renderObject: RenderObject,
+        stageVertex: ProgrammableStage,
+        stageFragment: ProgrammableStage,
+        cacheKey: string,
+        promises: Promise<void>[] | null,
+    ) {
         // check for existing pipeline
 
         cacheKey = cacheKey || this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
 
-        let pipeline = this.caches.get(cacheKey);
+        let pipeline = this.caches.get(cacheKey) as RenderPipeline | undefined;
 
         if (pipeline === undefined) {
             pipeline = new RenderPipeline(cacheKey, stageVertex, stageFragment);
@@ -235,32 +280,32 @@ class Pipelines extends DataMap {
         return pipeline;
     }
 
-    _getComputeCacheKey(computeNode, stageCompute) {
+    _getComputeCacheKey(computeNode: ComputeNode, stageCompute: ProgrammableStage) {
         return computeNode.id + ',' + stageCompute.id;
     }
 
-    _getRenderCacheKey(renderObject, stageVertex, stageFragment) {
+    _getRenderCacheKey(renderObject: RenderObject, stageVertex: ProgrammableStage, stageFragment: ProgrammableStage) {
         return stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey(renderObject);
     }
 
-    _releasePipeline(pipeline) {
+    _releasePipeline(pipeline: Pipeline) {
         this.caches.delete(pipeline.cacheKey);
     }
 
-    _releaseProgram(program) {
+    _releaseProgram(program: ProgrammableStage) {
         const code = program.code;
         const stage = program.stage;
 
         this.programs[stage].delete(code);
     }
 
-    _needsComputeUpdate(computeNode) {
+    _needsComputeUpdate(computeNode: ComputeNode) {
         const data = this.get(computeNode);
 
         return data.pipeline === undefined || data.version !== computeNode.version;
     }
 
-    _needsRenderUpdate(renderObject) {
+    _needsRenderUpdate(renderObject: RenderObject) {
         const data = this.get(renderObject);
 
         return data.pipeline === undefined || this.backend.needsRenderUpdate(renderObject);
diff --git a/src-testing/src/renderers/common/ProgrammableStage.ts b/src-testing/src/renderers/common/ProgrammableStage.ts
index a684e444..62ebf0a0 100644
--- a/src-testing/src/renderers/common/ProgrammableStage.ts
+++ b/src-testing/src/renderers/common/ProgrammableStage.ts
@@ -1,7 +1,24 @@
+import NodeAttribute from '../../nodes/core/NodeAttribute.js';
+
 let _id = 0;
 
 class ProgrammableStage {
-    constructor(code, type, transforms = null, attributes = null) {
+    id: number;
+
+    code: string;
+    stage: 'compute' | 'vertex' | 'fragment';
+    // TODO
+    // transforms
+    attributes: NodeAttribute[] | null;
+
+    usedTimes: number;
+
+    constructor(
+        code: string,
+        type: 'compute' | 'vertex' | 'fragment',
+        transforms = null,
+        attributes: NodeAttribute[] | null = null,
+    ) {
         this.id = _id++;
 
         this.code = code;
diff --git a/src-testing/src/renderers/common/RenderBundle.ts b/src-testing/src/renderers/common/RenderBundle.ts
index e59e4937..ca572cea 100644
--- a/src-testing/src/renderers/common/RenderBundle.ts
+++ b/src-testing/src/renderers/common/RenderBundle.ts
@@ -1,11 +1,17 @@
+import { Object3D } from '../../core/Object3D.js';
+import { Camera } from '../../cameras/Camera.js';
+
 class RenderBundle {
-    constructor(scene, camera) {
+    scene: Object3D;
+    camera: Camera;
+
+    constructor(scene: Object3D, camera: Camera) {
         this.scene = scene;
         this.camera = camera;
     }
 
     clone() {
-        return Object.assign(new this.constructor(), this);
+        return Object.assign(new (this.constructor as { new (): RenderBundle })(), this);
     }
 }
 
diff --git a/src-testing/src/renderers/common/RenderBundles.ts b/src-testing/src/renderers/common/RenderBundles.ts
index 29140365..46f14369 100644
--- a/src-testing/src/renderers/common/RenderBundles.ts
+++ b/src-testing/src/renderers/common/RenderBundles.ts
@@ -1,14 +1,18 @@
 import ChainMap from './ChainMap.js';
 import RenderBundle from './RenderBundle.js';
+import { Camera } from '../../cameras/Camera.js';
+import BundleGroup from './BundleGroup.js';
 
 class RenderBundles {
+    lists: ChainMap<readonly [BundleGroup, Camera], RenderBundle>;
+
     constructor() {
         this.lists = new ChainMap();
     }
 
-    get(scene, camera) {
+    get(scene: BundleGroup, camera: Camera) {
         const lists = this.lists;
-        const keys = [scene, camera];
+        const keys = [scene, camera] as const;
 
         let list = lists.get(keys);
 
diff --git a/src-testing/src/renderers/common/RenderContext.ts b/src-testing/src/renderers/common/RenderContext.ts
index 9b5ee3a2..1a937652 100644
--- a/src-testing/src/renderers/common/RenderContext.ts
+++ b/src-testing/src/renderers/common/RenderContext.ts
@@ -1,9 +1,52 @@
 import { Vector4 } from '../../math/Vector4.js';
 import { hashArray } from '../../nodes/core/NodeUtils.js';
+import { Texture } from '../../textures/Texture.js';
+import { DepthTexture } from '../../textures/DepthTexture.js';
+import ClippingContext from './ClippingContext.js';
+import { RenderTarget } from '../../core/RenderTarget.js';
 
 let id = 0;
 
 class RenderContext {
+    id: number;
+
+    color: boolean;
+    clearColor: boolean;
+    clearColorValue: { r: number; g: number; b: number; a: number };
+
+    depth: boolean;
+    clearDepth: boolean;
+    clearDepthValue: number;
+
+    stencil: boolean;
+    clearStencil: boolean;
+    clearStencilValue: number;
+
+    viewport: boolean;
+    viewportValue: Vector4;
+    scissor: boolean;
+    scissorValue: Vector4;
+
+    textures: Texture[] | null;
+    depthTexture: DepthTexture | null;
+    activeCubeFace: number;
+    sampleCount: number;
+
+    width: number;
+    height: number;
+
+    readonly isRenderContext: true;
+
+    clippingContext?: ClippingContext | undefined;
+
+    depthClearValue?: number | undefined;
+    stencilClearValue?: number | undefined;
+
+    renderTarget?: RenderTarget | undefined;
+
+    activeMipmapLevel?: number | undefined;
+    occlusionQueryCount?: number | undefined;
+
     constructor() {
         this.id = id++;
 
@@ -41,12 +84,12 @@ class RenderContext {
     }
 }
 
-export function getCacheKey(renderContext) {
+export function getCacheKey(renderContext: RenderContext) {
     const { textures, activeCubeFace } = renderContext;
 
     const values = [activeCubeFace];
 
-    for (const texture of textures) {
+    for (const texture of textures!) {
         values.push(texture.id);
     }
 
diff --git a/src-testing/src/renderers/common/RenderContexts.ts b/src-testing/src/renderers/common/RenderContexts.ts
index e77308c1..a3556aa1 100644
--- a/src-testing/src/renderers/common/RenderContexts.ts
+++ b/src-testing/src/renderers/common/RenderContexts.ts
@@ -1,13 +1,18 @@
 import ChainMap from './ChainMap.js';
 import RenderContext from './RenderContext.js';
+import { Camera } from '../../cameras/Camera.js';
+import { RenderTarget } from '../../core/RenderTarget.js';
+import { Object3D } from '../../core/Object3D.js';
 
 class RenderContexts {
+    chainMaps: { [attachmentState: string]: ChainMap<readonly [Object3D, Camera], RenderContext> | undefined };
+
     constructor() {
         this.chainMaps = {};
     }
 
-    get(scene, camera, renderTarget = null) {
-        const chainKey = [scene, camera];
+    get(scene: Object3D, camera: Camera, renderTarget: RenderTarget | null = null) {
+        const chainKey = [scene, camera] as const;
 
         let attachmentState;
 
@@ -35,8 +40,11 @@ class RenderContexts {
         return renderState;
     }
 
-    getChainMap(attachmentState) {
-        return this.chainMaps[attachmentState] || (this.chainMaps[attachmentState] = new ChainMap());
+    getChainMap(attachmentState: string) {
+        return (
+            this.chainMaps[attachmentState] ||
+            (this.chainMaps[attachmentState] = new ChainMap<readonly [Object3D, Camera], RenderContext>())
+        );
     }
 
     dispose() {
diff --git a/src-testing/src/renderers/common/RenderList.ts b/src-testing/src/renderers/common/RenderList.ts
index 0a9c07da..4587e6da 100644
--- a/src-testing/src/renderers/common/RenderList.ts
+++ b/src-testing/src/renderers/common/RenderList.ts
@@ -1,32 +1,67 @@
 import { LightsNode } from '../../nodes/Nodes.js';
-
-function painterSortStable(a, b) {
+import { Object3D } from '../../core/Object3D.js';
+import { Camera } from '../../cameras/Camera.js';
+import { BufferGeometry, GeometryGroup } from '../../core/BufferGeometry.js';
+import { Material } from '../../materials/Material.js';
+import { Light } from '../../lights/Light.js';
+import BundleGroup from './BundleGroup.js';
+
+function painterSortStable(a: RenderItem, b: RenderItem) {
     if (a.groupOrder !== b.groupOrder) {
-        return a.groupOrder - b.groupOrder;
+        return a.groupOrder! - b.groupOrder!;
     } else if (a.renderOrder !== b.renderOrder) {
-        return a.renderOrder - b.renderOrder;
-    } else if (a.material.id !== b.material.id) {
-        return a.material.id - b.material.id;
+        return a.renderOrder! - b.renderOrder!;
+    } else if (a.material!.id !== b.material!.id) {
+        return a.material!.id - b.material!.id;
     } else if (a.z !== b.z) {
-        return a.z - b.z;
+        return a.z! - b.z!;
     } else {
-        return a.id - b.id;
+        return a.id! - b.id!;
     }
 }
 
-function reversePainterSortStable(a, b) {
+function reversePainterSortStable(a: RenderItem, b: RenderItem) {
     if (a.groupOrder !== b.groupOrder) {
-        return a.groupOrder - b.groupOrder;
+        return a.groupOrder! - b.groupOrder!;
     } else if (a.renderOrder !== b.renderOrder) {
-        return a.renderOrder - b.renderOrder;
+        return a.renderOrder! - b.renderOrder!;
     } else if (a.z !== b.z) {
-        return b.z - a.z;
+        return b.z! - a.z!;
     } else {
-        return a.id - b.id;
+        return a.id! - b.id!;
     }
 }
 
+export interface Bundle {
+    bundleGroup: BundleGroup;
+    camera: Camera;
+    renderList: RenderList;
+}
+
+export interface RenderItem {
+    id: number | null;
+    object: Object3D | null;
+    geometry: BufferGeometry | null;
+    material: Material | null;
+    groupOrder: number | null;
+    renderOrder: number | null;
+    z: number | null;
+    group: GeometryGroup | null;
+}
+
 class RenderList {
+    renderItems: RenderItem[];
+    renderItemsIndex: number;
+
+    opaque: RenderItem[];
+    transparent: RenderItem[];
+    bundles: Bundle[];
+
+    lightsNode: LightsNode;
+    lightsArray: Light[];
+
+    occlusionQueryCount: number;
+
     constructor() {
         this.renderItems = [];
         this.renderItemsIndex = 0;
@@ -55,7 +90,14 @@ class RenderList {
         return this;
     }
 
-    getNextRenderItem(object, geometry, material, groupOrder, z, group) {
+    getNextRenderItem(
+        object: Object3D,
+        geometry: BufferGeometry,
+        material: Material,
+        groupOrder: number,
+        z: number,
+        group: GeometryGroup | null,
+    ) {
         let renderItem = this.renderItems[this.renderItemsIndex];
 
         if (renderItem === undefined) {
@@ -87,7 +129,14 @@ class RenderList {
         return renderItem;
     }
 
-    push(object, geometry, material, groupOrder, z, group) {
+    push(
+        object: Object3D,
+        geometry: BufferGeometry,
+        material: Material,
+        groupOrder: number,
+        z: number,
+        group: GeometryGroup | null,
+    ) {
         const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group);
 
         if (object.occlusionTest === true) this.occlusionQueryCount++;
@@ -95,21 +144,31 @@ class RenderList {
         (material.transparent === true || material.transmission > 0 ? this.transparent : this.opaque).push(renderItem);
     }
 
-    unshift(object, geometry, material, groupOrder, z, group) {
+    unshift(
+        object: Object3D,
+        geometry: BufferGeometry,
+        material: Material,
+        groupOrder: number,
+        z: number,
+        group: GeometryGroup | null,
+    ) {
         const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group);
 
         (material.transparent === true ? this.transparent : this.opaque).unshift(renderItem);
     }
 
-    pushBundle(group) {
+    pushBundle(group: Bundle) {
         this.bundles.push(group);
     }
 
-    pushLight(light) {
+    pushLight(light: Light) {
         this.lightsArray.push(light);
     }
 
-    sort(customOpaqueSort, customTransparentSort) {
+    sort(
+        customOpaqueSort: ((a: RenderItem, b: RenderItem) => number) | null,
+        customTransparentSort: ((a: RenderItem, b: RenderItem) => number) | null,
+    ) {
         if (this.opaque.length > 1) this.opaque.sort(customOpaqueSort || painterSortStable);
         if (this.transparent.length > 1) this.transparent.sort(customTransparentSort || reversePainterSortStable);
     }
diff --git a/src-testing/src/renderers/common/RenderLists.ts b/src-testing/src/renderers/common/RenderLists.ts
index 3fc3134e..c002ed0c 100644
--- a/src-testing/src/renderers/common/RenderLists.ts
+++ b/src-testing/src/renderers/common/RenderLists.ts
@@ -1,14 +1,18 @@
 import ChainMap from './ChainMap.js';
 import RenderList from './RenderList.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Camera } from '../../cameras/Camera.js';
 
 class RenderLists {
+    lists: ChainMap<readonly [Object3D, Camera], RenderList>;
+
     constructor() {
-        this.lists = new ChainMap();
+        this.lists = new ChainMap<readonly [Object3D, Camera], RenderList>();
     }
 
-    get(scene, camera) {
+    get(scene: Object3D, camera: Camera) {
         const lists = this.lists;
-        const keys = [scene, camera];
+        const keys = [scene, camera] as const;
 
         let list = lists.get(keys);
 
@@ -21,7 +25,7 @@ class RenderLists {
     }
 
     dispose() {
-        this.lists = new ChainMap();
+        this.lists = new ChainMap<readonly [Object3D, Camera], RenderList>();
     }
 }
 
diff --git a/src-testing/src/renderers/common/RenderObject.ts b/src-testing/src/renderers/common/RenderObject.ts
index 55fb4318..ea297bfd 100644
--- a/src-testing/src/renderers/common/RenderObject.ts
+++ b/src-testing/src/renderers/common/RenderObject.ts
@@ -1,9 +1,27 @@
 import { hashString } from '../../nodes/core/NodeUtils.js';
 import ClippingContext from './ClippingContext.js';
+import { Material } from '../../materials/Material.js';
+import Nodes from './nodes/Nodes.js';
+import Geometries from './Geometries.js';
+import Renderer from './Renderer.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Scene } from '../../scenes/Scene.js';
+import { Camera } from '../../cameras/Camera.js';
+import { LightsNode } from '../../nodes/Nodes.js';
+import RenderContext from './RenderContext.js';
+import { BufferGeometry } from '../../core/BufferGeometry.js';
+import { BufferAttribute } from '../../core/BufferAttribute.js';
+import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
+import RenderPipeline from './RenderPipeline.js';
+import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
+import NodeBuilderState from './nodes/NodeBuilderState.js';
+import BindGroup from './BindGroup.js';
+import NodeMaterialObserver from '../../materials/nodes/manager/NodeMaterialObserver.js';
+import BundleGroup from './BundleGroup.js';
 
 let _id = 0;
 
-function getKeys(obj) {
+function getKeys(obj: Material) {
     const keys = Object.keys(obj);
 
     let proto = Object.getPrototypeOf(obj);
@@ -28,7 +46,59 @@ function getKeys(obj) {
 }
 
 export default class RenderObject {
-    constructor(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext) {
+    _nodes: Nodes;
+    _geometries: Geometries;
+
+    id: number;
+
+    renderer: Renderer;
+    object: Object3D;
+    material: Material;
+    scene: Scene;
+    camera: Camera;
+    lightsNode: LightsNode;
+    context: RenderContext;
+
+    geometry: BufferGeometry;
+    version: number;
+
+    drawRange: { start: number; count: number } | null;
+
+    attributes: Array<BufferAttribute | InterleavedBufferAttribute> | null;
+    pipeline: RenderPipeline | null;
+    vertexBuffers: Array<BufferAttribute | InterleavedBuffer> | null;
+    drawParams: { vertexCount: number; firstVertex: number; instanceCount: number; firstInstance: number } | null;
+
+    bundle: BundleGroup | null;
+
+    clippingContext!: ClippingContext;
+
+    clippingContextVersion: number;
+
+    initialNodesCacheKey: string;
+    initialCacheKey: string;
+
+    _nodeBuilderState: NodeBuilderState | null;
+    _bindings: BindGroup[] | null;
+    _monitor: NodeMaterialObserver | null;
+
+    onDispose: (() => void) | null;
+
+    readonly isRenderObject: true;
+
+    onMaterialDispose: () => void;
+
+    constructor(
+        nodes: Nodes,
+        geometries: Geometries,
+        renderer: Renderer,
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+    ) {
         this._nodes = nodes;
         this._geometries = geometries;
 
@@ -54,7 +124,7 @@ export default class RenderObject {
 
         this.bundle = null;
 
-        this.updateClipping(renderContext.clippingContext);
+        this.updateClipping(renderContext.clippingContext!);
 
         this.clippingContextVersion = this.clippingContext.version;
 
@@ -76,7 +146,7 @@ export default class RenderObject {
         this.material.addEventListener('dispose', this.onMaterialDispose);
     }
 
-    updateClipping(parent) {
+    updateClipping(parent: ClippingContext) {
         const material = this.material;
 
         let clippingContext = this.clippingContext;
@@ -94,9 +164,9 @@ export default class RenderObject {
     }
 
     get clippingNeedsUpdate() {
-        if (this.clippingContext.version === this.clippingContextVersion) return false;
+        if (this.clippingContext!.version === this.clippingContextVersion) return false;
 
-        this.clippingContextVersion = this.clippingContext.version;
+        this.clippingContextVersion = this.clippingContext!.version;
 
         return true;
     }
@@ -118,7 +188,7 @@ export default class RenderObject {
     }
 
     getChainArray() {
-        return [this.object, this.material, this.context, this.lightsNode];
+        return [this.object, this.material, this.context, this.lightsNode] as const;
     }
 
     getAttributes() {
@@ -127,8 +197,8 @@ export default class RenderObject {
         const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
         const geometry = this.geometry;
 
-        const attributes = [];
-        const vertexBuffers = new Set();
+        const attributes: Array<BufferAttribute | InterleavedBufferAttribute> = [];
+        const vertexBuffers = new Set<BufferAttribute | InterleavedBuffer>();
 
         for (const nodeAttribute of nodeAttributes) {
             const attribute =
@@ -341,6 +411,6 @@ export default class RenderObject {
     dispose() {
         this.material.removeEventListener('dispose', this.onMaterialDispose);
 
-        this.onDispose();
+        this.onDispose!();
     }
 }
diff --git a/src-testing/src/renderers/common/RenderObjects.ts b/src-testing/src/renderers/common/RenderObjects.ts
index 6bd06dd5..dc499905 100644
--- a/src-testing/src/renderers/common/RenderObjects.ts
+++ b/src-testing/src/renderers/common/RenderObjects.ts
@@ -1,10 +1,43 @@
 import ChainMap from './ChainMap.js';
 import RenderObject from './RenderObject.js';
-
-const chainArray = [];
+import Renderer from './Renderer.js';
+import Nodes from './nodes/Nodes.js';
+import Geometries from './Geometries.js';
+import Pipelines from './Pipelines.js';
+import Bindings from './Bindings.js';
+import Info from './Info.js';
+import LightsNode from '../../nodes/lighting/LightsNode.js';
+import RenderContext from './RenderContext.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Material } from '../../materials/Material.js';
+import { Scene } from '../../scenes/Scene.js';
+import { Camera } from '../../cameras/Camera.js';
+
+const chainArray: [Object3D, Material, RenderContext, LightsNode] = [] as unknown as [
+    Object3D,
+    Material,
+    RenderContext,
+    LightsNode,
+];
 
 class RenderObjects {
-    constructor(renderer, nodes, geometries, pipelines, bindings, info) {
+    renderer: Renderer;
+    nodes: Nodes;
+    geometries: Geometries;
+    pipelines: Pipelines;
+    bindings: Bindings;
+    info: Info;
+
+    chainMaps: { [passId: string]: ChainMap<readonly [Object3D, Material, RenderContext, LightsNode], RenderObject> };
+
+    constructor(
+        renderer: Renderer,
+        nodes: Nodes,
+        geometries: Geometries,
+        pipelines: Pipelines,
+        bindings: Bindings,
+        info: Info,
+    ) {
         this.renderer = renderer;
         this.nodes = nodes;
         this.geometries = geometries;
@@ -15,7 +48,15 @@ class RenderObjects {
         this.chainMaps = {};
     }
 
-    get(object, material, scene, camera, lightsNode, renderContext, passId) {
+    get(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+        passId?: string | undefined,
+    ): RenderObject {
         const chainMap = this.getChainMap(passId);
 
         // reuse chainArray
@@ -42,7 +83,7 @@ class RenderObjects {
 
             chainMap.set(chainArray, renderObject);
         } else {
-            renderObject.updateClipping(renderContext.clippingContext);
+            renderObject.updateClipping(renderContext.clippingContext!);
 
             if (renderObject.version !== material.version || renderObject.needsUpdate) {
                 if (renderObject.initialCacheKey !== renderObject.getCacheKey()) {
@@ -59,7 +100,13 @@ class RenderObjects {
     }
 
     getChainMap(passId = 'default') {
-        return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());
+        return (
+            this.chainMaps[passId] ||
+            (this.chainMaps[passId] = new ChainMap<
+                readonly [Object3D, Material, RenderContext, LightsNode],
+                RenderObject
+            >())
+        );
     }
 
     dispose() {
@@ -67,16 +114,16 @@ class RenderObjects {
     }
 
     createRenderObject(
-        nodes,
-        geometries,
-        renderer,
-        object,
-        material,
-        scene,
-        camera,
-        lightsNode,
-        renderContext,
-        passId,
+        nodes: Nodes,
+        geometries: Geometries,
+        renderer: Renderer,
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+        passId: string | undefined,
     ) {
         const chainMap = this.getChainMap(passId);
 
diff --git a/src-testing/src/renderers/common/RenderPipeline.ts b/src-testing/src/renderers/common/RenderPipeline.ts
index 0ec34b04..573cae2b 100644
--- a/src-testing/src/renderers/common/RenderPipeline.ts
+++ b/src-testing/src/renderers/common/RenderPipeline.ts
@@ -1,7 +1,11 @@
 import Pipeline from './Pipeline.js';
+import ProgrammableStage from './ProgrammableStage.js';
 
 class RenderPipeline extends Pipeline {
-    constructor(cacheKey, vertexProgram, fragmentProgram) {
+    vertexProgram: ProgrammableStage;
+    fragmentProgram: ProgrammableStage;
+
+    constructor(cacheKey: string, vertexProgram: ProgrammableStage, fragmentProgram: ProgrammableStage) {
         super(cacheKey);
 
         this.vertexProgram = vertexProgram;
diff --git a/src-testing/src/renderers/common/Renderer.ts b/src-testing/src/renderers/common/Renderer.ts
index 03410828..1677575f 100644
--- a/src-testing/src/renderers/common/Renderer.ts
+++ b/src-testing/src/renderers/common/Renderer.ts
@@ -35,7 +35,35 @@ import {
     HalfFloatType,
     RGBAFormat,
     PCFShadowMap,
+    ToneMapping,
+    ShadowMapType,
 } from '../../constants.js';
+import Backend from './Backend.js';
+import { Plane } from '../../math/Plane.js';
+import RenderContext from './RenderContext.js';
+import RenderList, { Bundle, RenderItem } from './RenderList.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Camera } from '../../cameras/Camera.js';
+import { BufferGeometry, GeometryGroup } from '../../core/BufferGeometry.js';
+import { Material } from '../../materials/Material.js';
+import RenderBundle from './RenderBundle.js';
+import { Light } from '../../lights/Light.js';
+import { BufferAttribute } from '../../core/BufferAttribute.js';
+import { Texture } from '../../textures/Texture.js';
+import { FramebufferTexture } from '../../textures/FramebufferTexture.js';
+import { Box2 } from '../../math/Box2.js';
+import { Color } from '../../math/Color.js';
+import { Group } from '../../objects/Group.js';
+import { LOD } from '../../objects/LOD.js';
+import { Sprite } from '../../objects/Sprite.js';
+import { LineLoop } from '../../objects/LineLoop.js';
+import { Mesh } from '../../objects/Mesh.js';
+import { Line } from '../../objects/Line.js';
+import { Points } from '../../objects/Points.js';
+import { ArrayCamera } from '../../cameras/ArrayCamera.js';
+import MRTNode from '../../nodes/core/MRTNode.js';
+import LightsNode from '../../nodes/lighting/LightsNode.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
 
 const _scene = /*@__PURE__*/ new Scene();
 const _drawingBufferSize = /*@__PURE__*/ new Vector2();
@@ -44,8 +72,165 @@ const _frustum = /*@__PURE__*/ new Frustum();
 const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
 const _vector4 = /*@__PURE__*/ new Vector4();
 
+interface Rectangle {
+    x: number;
+    y: number;
+    z: number;
+    w: number;
+}
+
+export interface RendererParameters {
+    logarithmicDepthBuffer?: boolean | undefined;
+    alpha?: boolean | undefined;
+    depth?: boolean | undefined;
+    stencil?: boolean | undefined;
+    antialias?: boolean | undefined;
+    samples?: number | undefined;
+    getFallback?: ((error: unknown) => Backend) | null | undefined;
+}
+
 class Renderer {
-    constructor(backend, parameters = {}) {
+    readonly isRenderer: true;
+
+    domElement: HTMLCanvasElement;
+
+    backend: Backend;
+
+    samples: number;
+
+    autoClear: boolean;
+    autoClearColor: boolean;
+    autoClearDepth: boolean;
+    autoClearStencil: boolean;
+
+    alpha: boolean;
+
+    logarithmicDepthBuffer: boolean;
+
+    outputColorSpace: string;
+
+    toneMapping: ToneMapping;
+    toneMappingExposure: number;
+
+    sortObjects: boolean;
+
+    depth: boolean;
+    stencil: boolean;
+
+    clippingPlanes: readonly Plane[];
+
+    info: Info;
+
+    nodes: { library: NodeLibrary };
+
+    _getFallback: ((error: unknown) => Backend) | null;
+
+    _pixelRatio: number;
+    _width: number;
+    _height: number;
+
+    _viewport: Vector4;
+    _scissor: Vector4;
+    _scissorTest: boolean;
+
+    _attributes: Attributes | null;
+    _geometries: Geometries | null;
+    _nodes: Nodes | null;
+    _animation: Animation | null;
+    _bindings: Bindings | null;
+    _objects: RenderObjects | null;
+    _pipelines: Pipelines | null;
+    _bundles: RenderBundles | null;
+    _renderLists: RenderLists | null;
+    _renderContexts: RenderContexts | null;
+    _textures: Textures | null;
+    _background: Background | null;
+
+    _quad: QuadMesh;
+
+    _currentRenderContext: RenderContext | null;
+
+    _opaqueSort: ((a: RenderItem, b: RenderItem) => number) | null;
+    _transparentSort: ((a: RenderItem, b: RenderItem) => number) | null;
+
+    _frameBufferTarget: RenderTarget | null;
+
+    _clearColor: Color4;
+    _clearDepth: number;
+    _clearStencil: number;
+
+    _renderTarget: RenderTarget | null;
+    _activeCubeFace: number;
+    _activeMipmapLevel: number;
+
+    _mrt: MRTNode | null;
+
+    _renderObjectFunction:
+        | ((
+              object: Object3D,
+              scene: Scene,
+              camera: Camera,
+              geometry: BufferGeometry,
+              material: Material,
+              group: GeometryGroup,
+              lightsNode: LightsNode,
+          ) => void)
+        | null;
+    _currentRenderObjectFunction:
+        | ((
+              object: Object3D,
+              scene: Scene,
+              camera: Camera,
+              geometry: BufferGeometry,
+              material: Material,
+              group: GeometryGroup,
+              lightsNode: LightsNode,
+          ) => void)
+        | null;
+    _currentRenderBundle: RenderBundle | null;
+
+    _handleObjectFunction: (
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: GeometryGroup,
+        passId?: string,
+    ) => void;
+
+    _initialized: boolean;
+    _initPromise: Promise<void> | null;
+
+    _compilationPromises: Promise<void>[] | null;
+
+    transparent: boolean;
+    opaque: boolean;
+
+    shadowMap: { enabled: boolean; type: ShadowMapType | null };
+
+    xr: { enabled: boolean };
+
+    debug: {
+        checkShaderErrors: boolean;
+        onShaderError:
+            | ((
+                  gl: WebGL2RenderingContext,
+                  programGPU: WebGLProgram,
+                  glVertexShader: WebGLShader,
+                  glFragmentShader: WebGLShader,
+              ) => void)
+            | null;
+        getShaderAsync: (
+            scene: Scene,
+            camera: Camera,
+            object: Object3D,
+        ) => Promise<{ fragmentShader: string | null; vertexShader: string | null }>;
+    };
+
+    localClippingEnabled?: boolean | undefined;
+
+    constructor(backend: Backend, parameters: RendererParameters = {}) {
         this.isRenderer = true;
 
         //
@@ -172,12 +357,12 @@ class Renderer {
             getShaderAsync: async (scene, camera, object) => {
                 await this.compileAsync(scene, camera);
 
-                const renderList = this._renderLists.get(scene, camera);
-                const renderContext = this._renderContexts.get(scene, camera, this._renderTarget);
+                const renderList = this._renderLists!.get(scene, camera);
+                const renderContext = this._renderContexts!.get(scene, camera, this._renderTarget);
 
-                const material = scene.overrideMaterial || object.material;
+                const material = scene.overrideMaterial || (object as Mesh<BufferGeometry, Material>).material;
 
-                const renderObject = this._objects.get(
+                const renderObject = this._objects!.get(
                     object,
                     material,
                     scene,
@@ -265,12 +450,12 @@ class Renderer {
         return this.backend.coordinateSystem;
     }
 
-    async compileAsync(scene, camera, targetScene = null) {
+    async compileAsync(scene: Object3D, camera: Camera, targetScene: Object3D | null = null) {
         if (this._initialized === false) await this.init();
 
         // preserve render tree
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
         const previousRenderContext = this._currentRenderContext;
@@ -279,15 +464,15 @@ class Renderer {
 
         //
 
-        const sceneRef = scene.isScene === true ? scene : _scene;
+        const sceneRef = (scene as Scene).isScene === true ? (scene as Scene) : _scene;
 
         if (targetScene === null) targetScene = scene;
 
         const renderTarget = this._renderTarget;
-        const renderContext = this._renderContexts.get(targetScene, camera, renderTarget);
+        const renderContext = this._renderContexts!.get(targetScene, camera, renderTarget);
         const activeMipmapLevel = this._activeMipmapLevel;
 
-        const compilationPromises = [];
+        const compilationPromises: Promise<void>[] = [];
 
         this._currentRenderContext = renderContext;
         this._currentRenderObjectFunction = this.renderObject;
@@ -316,7 +501,7 @@ class Renderer {
 
         //
 
-        const renderList = this._renderLists.get(scene, camera);
+        const renderList = this._renderLists!.get(scene, camera);
         renderList.begin();
 
         this._projectObject(scene, camera, 0, renderList);
@@ -324,8 +509,8 @@ class Renderer {
         // include lights from target scene
         if (targetScene !== scene) {
             targetScene.traverseVisible(function (object) {
-                if (object.isLight && object.layers.test(camera.layers)) {
-                    renderList.pushLight(object);
+                if ((object as Light).isLight && object.layers.test(camera.layers)) {
+                    renderList.pushLight(object as Light);
                 }
             });
         }
@@ -335,12 +520,12 @@ class Renderer {
         //
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
+            this._textures!.updateRenderTarget(renderTarget, activeMipmapLevel);
 
-            const renderTargetData = this._textures.get(renderTarget);
+            const renderTargetData = this._textures!.get(renderTarget);
 
-            renderContext.textures = renderTargetData.textures;
-            renderContext.depthTexture = renderTargetData.depthTexture;
+            renderContext.textures = renderTargetData.textures!;
+            renderContext.depthTexture = renderTargetData.depthTexture!;
         } else {
             renderContext.textures = null;
             renderContext.depthTexture = null;
@@ -348,11 +533,11 @@ class Renderer {
 
         //
 
-        this._nodes.updateScene(sceneRef);
+        this._nodes!.updateScene(sceneRef);
 
         //
 
-        this._background.update(sceneRef, renderList, renderContext);
+        this._background!.update(sceneRef, renderList, renderContext);
 
         // process render lists
 
@@ -380,7 +565,7 @@ class Renderer {
         await Promise.all(compilationPromises);
     }
 
-    async renderAsync(scene, camera) {
+    async renderAsync(scene: Scene, camera: Camera) {
         if (this._initialized === false) await this.init();
 
         const renderContext = this._renderScene(scene, camera);
@@ -388,7 +573,7 @@ class Renderer {
         await this.backend.resolveTimestampAsync(renderContext, 'render');
     }
 
-    setMRT(mrt) {
+    setMRT(mrt: MRTNode | null) {
         this._mrt = mrt;
 
         return this;
@@ -398,14 +583,14 @@ class Renderer {
         return this._mrt;
     }
 
-    _renderBundle(bundle, sceneRef, lightsNode) {
+    _renderBundle(bundle: Bundle, sceneRef: Scene, lightsNode: LightsNode) {
         const { bundleGroup, camera, renderList } = bundle;
 
-        const renderContext = this._currentRenderContext;
+        const renderContext = this._currentRenderContext!;
 
         //
 
-        const renderBundle = this._bundles.get(bundleGroup, camera);
+        const renderBundle = this._bundles!.get(bundleGroup, camera);
         const renderBundleData = this.backend.get(renderBundle);
 
         if (renderBundleData.renderContexts === undefined) renderBundleData.renderContexts = new Set();
@@ -443,13 +628,13 @@ class Renderer {
             for (let i = 0, l = renderObjects.length; i < l; i++) {
                 const renderObject = renderObjects[i];
 
-                if (this._nodes.needsRefresh(renderObject)) {
-                    this._nodes.updateBefore(renderObject);
+                if (this._nodes!.needsRefresh(renderObject)) {
+                    this._nodes!.updateBefore(renderObject);
 
-                    this._nodes.updateForRender(renderObject);
-                    this._bindings.updateForRender(renderObject);
+                    this._nodes!.updateForRender(renderObject);
+                    this._bindings!.updateForRender(renderObject);
 
-                    this._nodes.updateAfter(renderObject);
+                    this._nodes!.updateAfter(renderObject);
                 }
             }
         }
@@ -457,7 +642,7 @@ class Renderer {
         this.backend.addBundle(renderContext, renderBundle);
     }
 
-    render(scene, camera) {
+    render(scene: Scene, camera: Camera) {
         if (this._initialized === false) {
             console.warn(
                 'THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.',
@@ -512,12 +697,12 @@ class Renderer {
         return frameBufferTarget;
     }
 
-    _renderScene(scene, camera, useFrameBufferTarget = true) {
+    _renderScene(scene: Scene, camera: Camera, useFrameBufferTarget = true) {
         const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;
 
         // preserve render tree
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
         const previousRenderContext = this._currentRenderContext;
@@ -546,7 +731,7 @@ class Renderer {
 
         //
 
-        const renderContext = this._renderContexts.get(scene, camera, renderTarget);
+        const renderContext = this._renderContexts!.get(scene, camera, renderTarget);
 
         this._currentRenderContext = renderContext;
         this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;
@@ -618,7 +803,7 @@ class Renderer {
         _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
         _frustum.setFromProjectionMatrix(_projScreenMatrix, coordinateSystem);
 
-        const renderList = this._renderLists.get(scene, camera);
+        const renderList = this._renderLists!.get(scene, camera);
         renderList.begin();
 
         this._projectObject(scene, camera, 0, renderList);
@@ -632,14 +817,14 @@ class Renderer {
         //
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
+            this._textures!.updateRenderTarget(renderTarget, activeMipmapLevel);
 
-            const renderTargetData = this._textures.get(renderTarget);
+            const renderTargetData = this._textures!.get(renderTarget);
 
-            renderContext.textures = renderTargetData.textures;
-            renderContext.depthTexture = renderTargetData.depthTexture;
-            renderContext.width = renderTargetData.width;
-            renderContext.height = renderTargetData.height;
+            renderContext.textures = renderTargetData.textures!;
+            renderContext.depthTexture = renderTargetData.depthTexture!;
+            renderContext.width = renderTargetData.width!;
+            renderContext.height = renderTargetData.height!;
             renderContext.renderTarget = renderTarget;
             renderContext.depth = renderTarget.depthBuffer;
             renderContext.stencil = renderTarget.stencilBuffer;
@@ -660,11 +845,11 @@ class Renderer {
 
         //
 
-        this._nodes.updateScene(sceneRef);
+        this._nodes!.updateScene(sceneRef);
 
         //
 
-        this._background.update(sceneRef, renderList, renderContext);
+        this._background!.update(sceneRef, renderList, renderContext);
 
         //
 
@@ -698,8 +883,8 @@ class Renderer {
 
             const quad = this._quad;
 
-            if (this._nodes.hasOutputChange(renderTarget.texture)) {
-                quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);
+            if (this._nodes!.hasOutputChange(renderTarget!.texture)) {
+                quad.material.fragmentNode = this._nodes!.getOutputNode(renderTarget!.texture);
                 quad.material.needsUpdate = true;
             }
 
@@ -727,13 +912,13 @@ class Renderer {
         return this._activeMipmapLevel;
     }
 
-    async setAnimationLoop(callback) {
+    async setAnimationLoop(callback: ((time: DOMHighResTimeStamp, frame?: XRFrame) => void) | null) {
         if (this._initialized === false) await this.init();
 
-        this._animation.setAnimationLoop(callback);
+        this._animation!.setAnimationLoop(callback);
     }
 
-    async getArrayBufferAsync(attribute) {
+    async getArrayBufferAsync(attribute: BufferAttribute) {
         return await this.backend.getArrayBufferAsync(attribute);
     }
 
@@ -745,11 +930,11 @@ class Renderer {
         return this._pixelRatio;
     }
 
-    getDrawingBufferSize(target) {
+    getDrawingBufferSize(target: Vector2) {
         return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
     }
 
-    getSize(target) {
+    getSize(target: Vector2) {
         return target.set(this._width, this._height);
     }
 
@@ -761,7 +946,7 @@ class Renderer {
         this.setSize(this._width, this._height, false);
     }
 
-    setDrawingBufferSize(width, height, pixelRatio) {
+    setDrawingBufferSize(width: number, height: number, pixelRatio: number) {
         this._width = width;
         this._height = height;
 
@@ -775,7 +960,7 @@ class Renderer {
         if (this._initialized) this.backend.updateSize();
     }
 
-    setSize(width, height, updateStyle = true) {
+    setSize(width: number, height: number, updateStyle = true) {
         this._width = width;
         this._height = height;
 
@@ -792,15 +977,15 @@ class Renderer {
         if (this._initialized) this.backend.updateSize();
     }
 
-    setOpaqueSort(method) {
+    setOpaqueSort(method: ((a: RenderItem, b: RenderItem) => number) | null) {
         this._opaqueSort = method;
     }
 
-    setTransparentSort(method) {
+    setTransparentSort(method: ((a: RenderItem, b: RenderItem) => number) | null) {
         this._transparentSort = method;
     }
 
-    getScissor(target) {
+    getScissor(target: Vector4) {
         const scissor = this._scissor;
 
         target.x = scissor.x;
@@ -811,13 +996,15 @@ class Renderer {
         return target;
     }
 
-    setScissor(x, y, width, height) {
+    setScissor(x: Vector4): void;
+    setScissor(x: number, y: number, width: number, height: number): void;
+    setScissor(x: Vector4 | number, y?: number, width?: number, height?: number) {
         const scissor = this._scissor;
 
-        if (x.isVector4) {
-            scissor.copy(x);
+        if ((x as Vector4).isVector4) {
+            scissor.copy(x as Vector4);
         } else {
-            scissor.set(x, y, width, height);
+            scissor.set(x as number, y!, width!, height!);
         }
     }
 
@@ -825,34 +1012,36 @@ class Renderer {
         return this._scissorTest;
     }
 
-    setScissorTest(boolean) {
+    setScissorTest(boolean: boolean) {
         this._scissorTest = boolean;
 
         this.backend.setScissorTest(boolean);
     }
 
-    getViewport(target) {
+    getViewport(target: Vector4) {
         return target.copy(this._viewport);
     }
 
-    setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {
+    setViewport(x: Vector4): void;
+    setViewport(x: number, y: number, width: number, height: number, minDepth?: number, maxDepth?: number): void;
+    setViewport(x: Vector4 | number, y?: number, width?: number, height?: number, minDepth = 0, maxDepth = 1) {
         const viewport = this._viewport;
 
-        if (x.isVector4) {
-            viewport.copy(x);
+        if ((x as Vector4).isVector4) {
+            viewport.copy(x as Vector4);
         } else {
-            viewport.set(x, y, width, height);
+            viewport.set(x as number, y!, width!, height!);
         }
 
         viewport.minDepth = minDepth;
         viewport.maxDepth = maxDepth;
     }
 
-    getClearColor(target) {
+    getClearColor(target: Color4) {
         return target.copy(this._clearColor);
     }
 
-    setClearColor(color, alpha = 1) {
+    setClearColor(color: Color, alpha = 1) {
         this._clearColor.set(color);
         this._clearColor.a = alpha;
     }
@@ -861,7 +1050,7 @@ class Renderer {
         return this._clearColor.a;
     }
 
-    setClearAlpha(alpha) {
+    setClearAlpha(alpha: number) {
         this._clearColor.a = alpha;
     }
 
@@ -869,7 +1058,7 @@ class Renderer {
         return this._clearDepth;
     }
 
-    setClearDepth(depth) {
+    setClearDepth(depth: number) {
         this._clearDepth = depth;
     }
 
@@ -877,11 +1066,11 @@ class Renderer {
         return this._clearStencil;
     }
 
-    setClearStencil(stencil) {
+    setClearStencil(stencil: number) {
         this._clearStencil = stencil;
     }
 
-    isOccluded(object) {
+    isOccluded(object: Object3D) {
         const renderContext = this._currentRenderContext;
 
         return renderContext && this.backend.isOccluded(renderContext, object);
@@ -901,9 +1090,9 @@ class Renderer {
         let renderTargetData = null;
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget);
+            this._textures!.updateRenderTarget(renderTarget);
 
-            renderTargetData = this._textures.get(renderTarget);
+            renderTargetData = this._textures!.get(renderTarget);
         }
 
         this.backend.clear(color, depth, stencil, renderTargetData);
@@ -914,8 +1103,8 @@ class Renderer {
 
             const quad = this._quad;
 
-            if (this._nodes.hasOutputChange(renderTarget.texture)) {
-                quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);
+            if (this._nodes!.hasOutputChange(renderTarget.texture)) {
+                quad.material.fragmentNode = this._nodes!.getOutputNode(renderTarget.texture);
                 quad.material.needsUpdate = true;
             }
 
@@ -964,20 +1153,20 @@ class Renderer {
     dispose() {
         this.info.dispose();
 
-        this._animation.dispose();
-        this._objects.dispose();
-        this._pipelines.dispose();
-        this._nodes.dispose();
-        this._bindings.dispose();
-        this._renderLists.dispose();
-        this._renderContexts.dispose();
-        this._textures.dispose();
+        this._animation!.dispose();
+        this._objects!.dispose();
+        this._pipelines!.dispose();
+        this._nodes!.dispose();
+        this._bindings!.dispose();
+        this._renderLists!.dispose();
+        this._renderContexts!.dispose();
+        this._textures!.dispose();
 
         this.setRenderTarget(null);
         this.setAnimationLoop(null);
     }
 
-    setRenderTarget(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
+    setRenderTarget(renderTarget: RenderTarget | null, activeCubeFace = 0, activeMipmapLevel = 0) {
         this._renderTarget = renderTarget;
         this._activeCubeFace = activeCubeFace;
         this._activeMipmapLevel = activeMipmapLevel;
@@ -987,7 +1176,19 @@ class Renderer {
         return this._renderTarget;
     }
 
-    setRenderObjectFunction(renderObjectFunction) {
+    setRenderObjectFunction(
+        renderObjectFunction:
+            | ((
+                  object: Object3D,
+                  scene: Scene,
+                  camera: Camera,
+                  geometry: BufferGeometry,
+                  material: Material,
+                  group: GeometryGroup,
+                  lightsNode: LightsNode,
+              ) => void)
+            | null,
+    ) {
         this._renderObjectFunction = renderObjectFunction;
     }
 
@@ -995,7 +1196,7 @@ class Renderer {
         return this._renderObjectFunction;
     }
 
-    compute(computeNodes) {
+    compute(computeNodes: ComputeNode | ComputeNode[]) {
         if (this._initialized === false) {
             console.warn(
                 'THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.',
@@ -1006,7 +1207,7 @@ class Renderer {
 
         //
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
 
@@ -1021,9 +1222,9 @@ class Renderer {
         //
 
         const backend = this.backend;
-        const pipelines = this._pipelines;
-        const bindings = this._bindings;
-        const nodes = this._nodes;
+        const pipelines = this._pipelines!;
+        const bindings = this._bindings!;
+        const nodes = this._nodes!;
 
         const computeList = Array.isArray(computeNodes) ? computeNodes : [computeNodes];
 
@@ -1072,7 +1273,7 @@ class Renderer {
         nodeFrame.renderId = previousRenderId;
     }
 
-    async computeAsync(computeNodes) {
+    async computeAsync(computeNodes: ComputeNode | ComputeNode[]) {
         if (this._initialized === false) await this.init();
 
         this.compute(computeNodes);
@@ -1080,13 +1281,13 @@ class Renderer {
         await this.backend.resolveTimestampAsync(computeNodes, 'compute');
     }
 
-    async hasFeatureAsync(name) {
+    async hasFeatureAsync(name: string) {
         if (this._initialized === false) await this.init();
 
         return this.backend.hasFeature(name);
     }
 
-    hasFeature(name) {
+    hasFeature(name: string) {
         if (this._initialized === false) {
             console.warn(
                 'THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.',
@@ -1098,7 +1299,7 @@ class Renderer {
         return this.backend.hasFeature(name);
     }
 
-    copyFramebufferToTexture(framebufferTexture, rectangle = null) {
+    copyFramebufferToTexture(framebufferTexture: FramebufferTexture, rectangle: Rectangle | null = null) {
         const renderContext = this._currentRenderContext;
 
         this._textures.updateTexture(framebufferTexture);
@@ -1111,54 +1312,68 @@ class Renderer {
         this.backend.copyFramebufferToTexture(framebufferTexture, renderContext, rectangle);
     }
 
-    copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
+    copyTextureToTexture(
+        srcTexture: Texture,
+        dstTexture: Texture,
+        srcRegion: Box2 | null = null,
+        dstPosition: Vector2 | null = null,
+        level = 0,
+    ) {
         this._textures.updateTexture(srcTexture);
         this._textures.updateTexture(dstTexture);
 
         this.backend.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);
     }
 
-    readRenderTargetPixelsAsync(renderTarget, x, y, width, height, index = 0, faceIndex = 0) {
+    readRenderTargetPixelsAsync(
+        renderTarget: RenderTarget,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+        index = 0,
+        faceIndex = 0,
+    ) {
         return this.backend.copyTextureToBuffer(renderTarget.textures[index], x, y, width, height, faceIndex);
     }
 
-    _projectObject(object, camera, groupOrder, renderList) {
+    _projectObject(object: Object3D, camera: Camera, groupOrder: number, renderList: RenderList) {
         if (object.visible === false) return;
 
         const visible = object.layers.test(camera.layers);
 
         if (visible) {
-            if (object.isGroup) {
-                groupOrder = object.renderOrder;
-            } else if (object.isLOD) {
-                if (object.autoUpdate === true) object.update(camera);
-            } else if (object.isLight) {
-                renderList.pushLight(object);
-            } else if (object.isSprite) {
-                if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
+            if ((object as Group).isGroup) {
+                groupOrder = (object as Group).renderOrder;
+            } else if ((object as LOD).isLOD) {
+                if ((object as LOD).autoUpdate === true) (object as LOD).update(camera);
+            } else if ((object as Light).isLight) {
+                renderList.pushLight(object as Light);
+            } else if ((object as Sprite).isSprite) {
+                if (!object.frustumCulled || _frustum.intersectsSprite(object as Sprite)) {
                     if (this.sortObjects === true) {
                         _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                     }
 
-                    const { geometry, material } = object;
+                    const { geometry, material } = object as Sprite;
 
                     if (material.visible) {
-                        renderList.push(object, geometry, material, groupOrder, _vector4.z, null);
+                        renderList.push(object as Sprite, geometry, material, groupOrder, _vector4.z, null);
                     }
                 }
-            } else if (object.isLineLoop) {
+            } else if ((object as LineLoop).isLineLoop) {
                 console.error(
                     'THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.',
                 );
-            } else if (object.isMesh || object.isLine || object.isPoints) {
+            } else if ((object as Mesh).isMesh || (object as Line).isLine || (object as Points).isPoints) {
                 if (!object.frustumCulled || _frustum.intersectsObject(object)) {
-                    const { geometry, material } = object;
+                    const { geometry, material } = object as Mesh | Line | Points;
 
                     if (this.sortObjects === true) {
                         if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
 
                         _vector4
-                            .copy(geometry.boundingSphere.center)
+                            .copy(geometry.boundingSphere!.center)
                             .applyMatrix4(object.matrixWorld)
                             .applyMatrix4(_projScreenMatrix);
                     }
@@ -1168,7 +1383,7 @@ class Renderer {
 
                         for (let i = 0, l = groups.length; i < l; i++) {
                             const group = groups[i];
-                            const groupMaterial = material[group.materialIndex];
+                            const groupMaterial = material[group.materialIndex!];
 
                             if (groupMaterial && groupMaterial.visible) {
                                 renderList.push(object, geometry, groupMaterial, groupOrder, _vector4.z, group);
@@ -1185,7 +1400,7 @@ class Renderer {
             const baseRenderList = renderList;
 
             // replace render list
-            renderList = this._renderLists.get(object, camera);
+            renderList = this._renderLists!.get(object, camera);
 
             renderList.begin();
 
@@ -1205,13 +1420,13 @@ class Renderer {
         }
     }
 
-    _renderBundles(bundles, sceneRef, lightsNode) {
+    _renderBundles(bundles: Bundle[], sceneRef: Scene, lightsNode: LightsNode) {
         for (const bundle of bundles) {
             this._renderBundle(bundle, sceneRef, lightsNode);
         }
     }
 
-    _renderObjects(renderList, camera, scene, lightsNode) {
+    _renderObjects(renderList: RenderItem[], camera: Camera, scene: Scene, lightsNode: LightsNode) {
         // process renderable objects
 
         for (let i = 0, il = renderList.length; i < il; i++) {
@@ -1222,42 +1437,50 @@ class Renderer {
 
             const { object, geometry, material, group } = renderItem;
 
-            if (camera.isArrayCamera) {
-                const cameras = camera.cameras;
+            if ((camera as ArrayCamera).isArrayCamera) {
+                const cameras = (camera as ArrayCamera).cameras;
 
                 for (let j = 0, jl = cameras.length; j < jl; j++) {
                     const camera2 = cameras[j];
 
-                    if (object.layers.test(camera2.layers)) {
+                    if (object!.layers.test(camera2.layers)) {
                         const vp = camera2.viewport;
                         const minDepth = vp.minDepth === undefined ? 0 : vp.minDepth;
                         const maxDepth = vp.maxDepth === undefined ? 1 : vp.maxDepth;
 
-                        const viewportValue = this._currentRenderContext.viewportValue;
+                        const viewportValue = this._currentRenderContext!.viewportValue;
                         viewportValue.copy(vp).multiplyScalar(this._pixelRatio).floor();
                         viewportValue.minDepth = minDepth;
                         viewportValue.maxDepth = maxDepth;
 
                         this.backend.updateViewport(this._currentRenderContext);
 
-                        this._currentRenderObjectFunction(
-                            object,
+                        this._currentRenderObjectFunction!(
+                            object!,
                             scene,
                             camera2,
-                            geometry,
-                            material,
-                            group,
+                            geometry!,
+                            material!,
+                            group!,
                             lightsNode,
                         );
                     }
                 }
             } else {
-                this._currentRenderObjectFunction(object, scene, camera, geometry, material, group, lightsNode);
+                this._currentRenderObjectFunction!(object!, scene, camera, geometry!, material!, group!, lightsNode);
             }
         }
     }
 
-    renderObject(object, scene, camera, geometry, material, group, lightsNode) {
+    renderObject(
+        object: Object3D,
+        scene: Scene,
+        camera: Camera,
+        geometry: BufferGeometry,
+        material: Material,
+        group: GeometryGroup,
+        lightsNode: LightsNode,
+    ) {
         let overridePositionNode;
         let overrideFragmentNode;
         let overrideDepthNode;
@@ -1342,14 +1565,22 @@ class Renderer {
         object.onAfterRender(this, scene, camera, geometry, material, group);
     }
 
-    _renderObjectDirect(object, material, scene, camera, lightsNode, group, passId) {
-        const renderObject = this._objects.get(
+    _renderObjectDirect(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: GeometryGroup,
+        passId?: string,
+    ) {
+        const renderObject = this._objects!.get(
             object,
             material,
             scene,
             camera,
             lightsNode,
-            this._currentRenderContext,
+            this._currentRenderContext!,
             passId,
         );
         renderObject.drawRange = object.geometry.drawRange;
@@ -1357,18 +1588,18 @@ class Renderer {
 
         //
 
-        const needsRefresh = this._nodes.needsRefresh(renderObject);
+        const needsRefresh = this._nodes!.needsRefresh(renderObject);
 
         if (needsRefresh) {
-            this._nodes.updateBefore(renderObject);
+            this._nodes!.updateBefore(renderObject);
 
-            this._geometries.updateForRender(renderObject);
+            this._geometries!.updateForRender(renderObject);
 
-            this._nodes.updateForRender(renderObject);
-            this._bindings.updateForRender(renderObject);
+            this._nodes!.updateForRender(renderObject);
+            this._bindings!.updateForRender(renderObject);
         }
 
-        this._pipelines.updateForRender(renderObject);
+        this._pipelines!.updateForRender(renderObject);
 
         //
 
@@ -1382,32 +1613,39 @@ class Renderer {
 
         this.backend.draw(renderObject, this.info);
 
-        if (needsRefresh) this._nodes.updateAfter(renderObject);
+        if (needsRefresh) this._nodes!.updateAfter(renderObject);
     }
 
-    _createObjectPipeline(object, material, scene, camera, lightsNode, passId) {
-        const renderObject = this._objects.get(
+    _createObjectPipeline(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        passId?: string,
+    ) {
+        const renderObject = this._objects!.get(
             object,
             material,
             scene,
             camera,
             lightsNode,
-            this._currentRenderContext,
+            this._currentRenderContext!,
             passId,
         );
 
         //
 
-        this._nodes.updateBefore(renderObject);
+        this._nodes!.updateBefore(renderObject);
 
-        this._geometries.updateForRender(renderObject);
+        this._geometries!.updateForRender(renderObject);
 
-        this._nodes.updateForRender(renderObject);
-        this._bindings.updateForRender(renderObject);
+        this._nodes!.updateForRender(renderObject);
+        this._bindings!.updateForRender(renderObject);
 
-        this._pipelines.getForRender(renderObject, this._compilationPromises);
+        this._pipelines!.getForRender(renderObject, this._compilationPromises);
 
-        this._nodes.updateAfter(renderObject);
+        this._nodes!.updateAfter(renderObject);
     }
 
     get compile() {
diff --git a/src-testing/src/renderers/common/SampledTexture.ts b/src-testing/src/renderers/common/SampledTexture.ts
index 841e6a85..542d5dd8 100644
--- a/src-testing/src/renderers/common/SampledTexture.ts
+++ b/src-testing/src/renderers/common/SampledTexture.ts
@@ -1,9 +1,20 @@
 import Binding from './Binding.js';
+import { Texture } from '../../textures/Texture.js';
+import { VideoTexture } from '../../textures/VideoTexture.js';
 
 let _id = 0;
 
 class SampledTexture extends Binding {
-    constructor(name, texture) {
+    id: number;
+
+    texture: Texture;
+    version: number;
+    store: boolean;
+    generation: number | null;
+
+    readonly isSampledTexture: true;
+
+    constructor(name: string, texture: Texture) {
         super(name);
 
         this.id = _id++;
@@ -16,7 +27,7 @@ class SampledTexture extends Binding {
         this.isSampledTexture = true;
     }
 
-    needsBindingsUpdate(generation) {
+    needsBindingsUpdate(generation: number) {
         const { texture } = this;
 
         if (generation !== this.generation) {
@@ -25,7 +36,7 @@ class SampledTexture extends Binding {
             return true;
         }
 
-        return texture.isVideoTexture;
+        return (texture as VideoTexture).isVideoTexture;
     }
 
     update() {
@@ -42,7 +53,9 @@ class SampledTexture extends Binding {
 }
 
 class SampledArrayTexture extends SampledTexture {
-    constructor(name, texture) {
+    readonly isSampledArrayTexture: true;
+
+    constructor(name: string, texture) {
         super(name, texture);
 
         this.isSampledArrayTexture = true;
@@ -50,7 +63,9 @@ class SampledArrayTexture extends SampledTexture {
 }
 
 class Sampled3DTexture extends SampledTexture {
-    constructor(name, texture) {
+    readonly isSampled3DTexture: true;
+
+    constructor(name: string, texture) {
         super(name, texture);
 
         this.isSampled3DTexture = true;
@@ -58,7 +73,9 @@ class Sampled3DTexture extends SampledTexture {
 }
 
 class SampledCubeTexture extends SampledTexture {
-    constructor(name, texture) {
+    readonly isSampledCubeTexture: true;
+
+    constructor(name: string, texture) {
         super(name, texture);
 
         this.isSampledCubeTexture = true;
diff --git a/src-testing/src/renderers/common/Sampler.ts b/src-testing/src/renderers/common/Sampler.ts
index 8cd20d04..86e6f45e 100644
--- a/src-testing/src/renderers/common/Sampler.ts
+++ b/src-testing/src/renderers/common/Sampler.ts
@@ -1,7 +1,13 @@
 import Binding from './Binding.js';
 
 class Sampler extends Binding {
-    constructor(name, texture) {
+    // TODO
+    // texture
+    version: number;
+
+    readonly isSampler: true;
+
+    constructor(name: string, texture) {
         super(name);
 
         this.texture = texture;
diff --git a/src-testing/src/renderers/common/StorageBuffer.ts b/src-testing/src/renderers/common/StorageBuffer.ts
index ef5d3e46..fb6acc45 100644
--- a/src-testing/src/renderers/common/StorageBuffer.ts
+++ b/src-testing/src/renderers/common/StorageBuffer.ts
@@ -1,7 +1,12 @@
 import Buffer from './Buffer.js';
 
 class StorageBuffer extends Buffer {
-    constructor(name, attribute) {
+    // TODO
+    // attribute
+
+    readonly isStorageBuffer: true;
+
+    constructor(name: string, attribute) {
         super(name, attribute ? attribute.array : null);
 
         this.attribute = attribute;
diff --git a/src-testing/src/renderers/common/Textures.ts b/src-testing/src/renderers/common/Textures.ts
index 5eae41df..f88f361b 100644
--- a/src-testing/src/renderers/common/Textures.ts
+++ b/src-testing/src/renderers/common/Textures.ts
@@ -15,11 +15,56 @@ import {
     CubeRefractionMapping,
     UnsignedByteType,
 } from '../../constants.js';
+import { Texture } from '../../textures/Texture.js';
+import { RenderTarget } from '../../core/RenderTarget.js';
+import Renderer from './Renderer.js';
+import Backend from './Backend.js';
+import Info from './Info.js';
+import { CubeTexture } from '../../textures/CubeTexture.js';
+import { CompressedTexture } from '../../textures/CompressedTexture.js';
+
+type SizeVector3Unitialized = Vector3 & { width?: number; height?: number; depth?: number };
+type SizeVector3 = Vector3 & { width: number; height: number; depth: number };
+
+const _size: SizeVector3Unitialized = /*@__PURE__*/ new Vector3();
+
+interface RenderTargetData {
+    depthTextureMips?: { [activeMipmapLevel: number]: DepthTexture };
+    width?: number;
+    height?: number;
+    textures?: Texture[];
+    depthTexture?: DepthTexture;
+    depth?: boolean;
+    stencil?: boolean;
+    renderTarget?: RenderTarget;
+    sampleCount?: number;
+    initialized?: boolean;
+}
+
+interface TextureData {
+    initialized?: boolean;
+    version?: number;
+    isDefaultTexture?: boolean;
+    generation?: number;
+}
+
+interface TextureOptions {
+    width?: number;
+    height?: number;
+    depth?: number;
+    needsMipmaps?: boolean;
+    levels?: number;
+}
 
-const _size = /*@__PURE__*/ new Vector3();
+class Textures extends DataMap<{
+    renderTarget: { key: RenderTarget; value: RenderTargetData };
+    texture: { key: Texture; value: TextureData };
+}> {
+    renderer: Renderer;
+    backend: Backend;
+    info: Info;
 
-class Textures extends DataMap {
-    constructor(renderer, backend, info) {
+    constructor(renderer: Renderer, backend: Backend, info: Info) {
         super();
 
         this.renderer = renderer;
@@ -27,7 +72,7 @@ class Textures extends DataMap {
         this.info = info;
     }
 
-    updateRenderTarget(renderTarget, activeMipmapLevel = 0) {
+    updateRenderTarget(renderTarget: RenderTarget, activeMipmapLevel = 0) {
         const renderTargetData = this.get(renderTarget);
 
         const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
@@ -124,7 +169,7 @@ class Textures extends DataMap {
         }
     }
 
-    updateTexture(texture, options = {}) {
+    updateTexture(texture: Texture, options: TextureOptions = {}) {
         const textureData = this.get(texture);
         if (textureData.initialized === true && textureData.version === texture.version) return;
 
@@ -242,7 +287,7 @@ class Textures extends DataMap {
         textureData.version = texture.version;
     }
 
-    getSize(texture, target = _size) {
+    getSize(texture: Texture, target = _size) {
         let image = texture.images ? texture.images[0] : texture.image;
 
         if (image) {
@@ -250,18 +295,18 @@ class Textures extends DataMap {
 
             target.width = image.width;
             target.height = image.height;
-            target.depth = texture.isCubeTexture ? 6 : image.depth || 1;
+            target.depth = (texture as CubeTexture).isCubeTexture ? 6 : image.depth || 1;
         } else {
             target.width = target.height = target.depth = 1;
         }
 
-        return target;
+        return target as SizeVector3;
     }
 
-    getMipLevels(texture, width, height) {
+    getMipLevels(texture: Texture, width: number, height: number) {
         let mipLevelCount;
 
-        if (texture.isCompressedTexture) {
+        if ((texture as CompressedTexture).isCompressedTexture) {
             mipLevelCount = texture.mipmaps.length;
         } else {
             mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1;
@@ -270,16 +315,16 @@ class Textures extends DataMap {
         return mipLevelCount;
     }
 
-    needsMipmaps(texture) {
+    needsMipmaps(texture: Texture) {
         if (this.isEnvironmentTexture(texture)) return true;
 
         return (
-            texture.isCompressedTexture === true ||
+            (texture as CompressedTexture).isCompressedTexture === true ||
             (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter)
         );
     }
 
-    isEnvironmentTexture(texture) {
+    isEnvironmentTexture(texture: Texture) {
         const mapping = texture.mapping;
 
         return (
@@ -290,7 +335,7 @@ class Textures extends DataMap {
         );
     }
 
-    _destroyTexture(texture) {
+    _destroyTexture(texture: Texture) {
         this.backend.destroySampler(texture);
         this.backend.destroyTexture(texture);
 
diff --git a/src-testing/src/renderers/common/Uniform.ts b/src-testing/src/renderers/common/Uniform.ts
index 80c13149..dcecc0e2 100644
--- a/src-testing/src/renderers/common/Uniform.ts
+++ b/src-testing/src/renderers/common/Uniform.ts
@@ -5,8 +5,16 @@ import { Vector2 } from '../../math/Vector2.js';
 import { Vector3 } from '../../math/Vector3.js';
 import { Vector4 } from '../../math/Vector4.js';
 
-class Uniform {
-    constructor(name, value) {
+class Uniform<TValue> {
+    name: string;
+    value: TValue;
+
+    boundary: number;
+    itemSize: number;
+
+    offset: number;
+
+    constructor(name: string, value: TValue) {
         this.name = name;
         this.value = value;
 
@@ -16,7 +24,7 @@ class Uniform {
         this.offset = 0; // this property is set by WebGPUUniformsGroup and marks the start position in the uniform buffer
     }
 
-    setValue(value) {
+    setValue(value: TValue) {
         this.value = value;
     }
 
@@ -25,8 +33,10 @@ class Uniform {
     }
 }
 
-class NumberUniform extends Uniform {
-    constructor(name, value = 0) {
+class NumberUniform extends Uniform<number> {
+    readonly isNumberUniform: true;
+
+    constructor(name: string, value = 0) {
         super(name, value);
 
         this.isNumberUniform = true;
@@ -36,8 +46,10 @@ class NumberUniform extends Uniform {
     }
 }
 
-class Vector2Uniform extends Uniform {
-    constructor(name, value = new Vector2()) {
+class Vector2Uniform extends Uniform<Vector2> {
+    readonly isVector2Uniform: true;
+
+    constructor(name: string, value = new Vector2()) {
         super(name, value);
 
         this.isVector2Uniform = true;
@@ -47,8 +59,10 @@ class Vector2Uniform extends Uniform {
     }
 }
 
-class Vector3Uniform extends Uniform {
-    constructor(name, value = new Vector3()) {
+class Vector3Uniform extends Uniform<Vector3> {
+    readonly isVector3Uniform: true;
+
+    constructor(name: string, value = new Vector3()) {
         super(name, value);
 
         this.isVector3Uniform = true;
@@ -58,8 +72,10 @@ class Vector3Uniform extends Uniform {
     }
 }
 
-class Vector4Uniform extends Uniform {
-    constructor(name, value = new Vector4()) {
+class Vector4Uniform extends Uniform<Vector4> {
+    readonly isVector4Uniform: true;
+
+    constructor(name: string, value = new Vector4()) {
         super(name, value);
 
         this.isVector4Uniform = true;
@@ -69,8 +85,10 @@ class Vector4Uniform extends Uniform {
     }
 }
 
-class ColorUniform extends Uniform {
-    constructor(name, value = new Color()) {
+class ColorUniform extends Uniform<Color> {
+    readonly isColorUniform: true;
+
+    constructor(name: string, value = new Color()) {
         super(name, value);
 
         this.isColorUniform = true;
@@ -80,8 +98,10 @@ class ColorUniform extends Uniform {
     }
 }
 
-class Matrix3Uniform extends Uniform {
-    constructor(name, value = new Matrix3()) {
+class Matrix3Uniform extends Uniform<Matrix3> {
+    readonly isMatrix3Uniform: true;
+
+    constructor(name: string, value = new Matrix3()) {
         super(name, value);
 
         this.isMatrix3Uniform = true;
@@ -91,8 +111,10 @@ class Matrix3Uniform extends Uniform {
     }
 }
 
-class Matrix4Uniform extends Uniform {
-    constructor(name, value = new Matrix4()) {
+class Matrix4Uniform extends Uniform<Matrix4> {
+    readonly isMatrix4Uniform: true;
+
+    constructor(name: string, value = new Matrix4()) {
         super(name, value);
 
         this.isMatrix4Uniform = true;
diff --git a/src-testing/src/renderers/common/UniformBuffer.ts b/src-testing/src/renderers/common/UniformBuffer.ts
index 28aac0d7..2479d00d 100644
--- a/src-testing/src/renderers/common/UniformBuffer.ts
+++ b/src-testing/src/renderers/common/UniformBuffer.ts
@@ -1,7 +1,9 @@
 import Buffer from './Buffer.js';
 
 class UniformBuffer extends Buffer {
-    constructor(name, buffer = null) {
+    readonly isUniformBuffer: true;
+
+    constructor(name?: string, buffer = null) {
         super(name, buffer);
 
         this.isUniformBuffer = true;
diff --git a/src-testing/src/renderers/common/UniformsGroup.ts b/src-testing/src/renderers/common/UniformsGroup.ts
index e2b62671..5c48602e 100644
--- a/src-testing/src/renderers/common/UniformsGroup.ts
+++ b/src-testing/src/renderers/common/UniformsGroup.ts
@@ -1,8 +1,24 @@
 import UniformBuffer from './UniformBuffer.js';
 import { GPU_CHUNK_BYTES } from './Constants.js';
+import {
+    ColorNodeUniform,
+    Matrix3NodeUniform,
+    Matrix4NodeUniform,
+    NodeUniformGPU,
+    NumberNodeUniform,
+    Vector2NodeUniform,
+    Vector3NodeUniform,
+    Vector4NodeUniform,
+} from './nodes/NodeUniform.js';
 
 class UniformsGroup extends UniformBuffer {
-    constructor(name) {
+    readonly isUniformsGroup: true;
+
+    _values: number[] | null;
+
+    uniforms: NodeUniformGPU[];
+
+    constructor(name?: string) {
         super(name);
 
         this.isUniformsGroup = true;
@@ -14,13 +30,13 @@ class UniformsGroup extends UniformBuffer {
         this.uniforms = [];
     }
 
-    addUniform(uniform) {
+    addUniform(uniform: NodeUniformGPU) {
         this.uniforms.push(uniform);
 
         return this;
     }
 
-    removeUniform(uniform) {
+    removeUniform(uniform: NodeUniformGPU) {
         const index = this.uniforms.indexOf(uniform);
 
         if (index !== -1) {
@@ -97,19 +113,19 @@ class UniformsGroup extends UniformBuffer {
         return updated;
     }
 
-    updateByType(uniform) {
-        if (uniform.isNumberUniform) return this.updateNumber(uniform);
-        if (uniform.isVector2Uniform) return this.updateVector2(uniform);
-        if (uniform.isVector3Uniform) return this.updateVector3(uniform);
-        if (uniform.isVector4Uniform) return this.updateVector4(uniform);
-        if (uniform.isColorUniform) return this.updateColor(uniform);
-        if (uniform.isMatrix3Uniform) return this.updateMatrix3(uniform);
-        if (uniform.isMatrix4Uniform) return this.updateMatrix4(uniform);
+    updateByType(uniform: NodeUniformGPU) {
+        if ((uniform as NumberNodeUniform).isNumberUniform) return this.updateNumber(uniform as NumberNodeUniform);
+        if ((uniform as Vector2NodeUniform).isVector2Uniform) return this.updateVector2(uniform as Vector2NodeUniform);
+        if ((uniform as Vector3NodeUniform).isVector3Uniform) return this.updateVector3(uniform as Vector3NodeUniform);
+        if ((uniform as Vector4NodeUniform).isVector4Uniform) return this.updateVector4(uniform as Vector4NodeUniform);
+        if ((uniform as ColorNodeUniform).isColorUniform) return this.updateColor(uniform as ColorNodeUniform);
+        if ((uniform as Matrix3NodeUniform).isMatrix3Uniform) return this.updateMatrix3(uniform as Matrix3NodeUniform);
+        if ((uniform as Matrix4NodeUniform).isMatrix4Uniform) return this.updateMatrix4(uniform as Matrix4NodeUniform);
 
         console.error('THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform);
     }
 
-    updateNumber(uniform) {
+    updateNumber(uniform: NumberNodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -126,7 +142,7 @@ class UniformsGroup extends UniformBuffer {
         return updated;
     }
 
-    updateVector2(uniform) {
+    updateVector2(uniform: Vector2NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -145,7 +161,7 @@ class UniformsGroup extends UniformBuffer {
         return updated;
     }
 
-    updateVector3(uniform) {
+    updateVector3(uniform: Vector3NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -165,7 +181,7 @@ class UniformsGroup extends UniformBuffer {
         return updated;
     }
 
-    updateVector4(uniform) {
+    updateVector4(uniform: Vector4NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -186,7 +202,7 @@ class UniformsGroup extends UniformBuffer {
         return updated;
     }
 
-    updateColor(uniform) {
+    updateColor(uniform: ColorNodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -206,7 +222,7 @@ class UniformsGroup extends UniformBuffer {
         return updated;
     }
 
-    updateMatrix3(uniform) {
+    updateMatrix3(uniform: Matrix3NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -242,7 +258,7 @@ class UniformsGroup extends UniformBuffer {
         return updated;
     }
 
-    updateMatrix4(uniform) {
+    updateMatrix4(uniform: Matrix4NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -260,13 +276,13 @@ class UniformsGroup extends UniformBuffer {
     }
 }
 
-function setArray(a, b, offset) {
+function setArray(a: number[], b: number[], offset: number) {
     for (let i = 0, l = b.length; i < l; i++) {
         a[offset + i] = b[i];
     }
 }
 
-function arraysEqual(a, b, offset) {
+function arraysEqual(a: number[], b: number[], offset: number) {
     for (let i = 0, l = b.length; i < l; i++) {
         if (a[offset + i] !== b[i]) return false;
     }
diff --git a/src-testing/src/renderers/common/nodes/NodeBuilderState.ts b/src-testing/src/renderers/common/nodes/NodeBuilderState.ts
index 520a3c91..524d188c 100644
--- a/src-testing/src/renderers/common/nodes/NodeBuilderState.ts
+++ b/src-testing/src/renderers/common/nodes/NodeBuilderState.ts
@@ -1,17 +1,37 @@
 import BindGroup from '../BindGroup.js';
+import NodeAttribute from '../../../nodes/core/NodeAttribute.js';
+import Node from '../../../nodes/core/Node.js';
+import NodeUniformsGroup from './NodeUniformsGroup.js';
+import NodeMaterialObserver from '../../../materials/nodes/manager/NodeMaterialObserver.js';
 
 class NodeBuilderState {
+    vertexShader: string | null;
+    fragmentShader: string | null;
+    computeShader: string | null;
+    transforms: never[];
+
+    nodeAttributes: NodeAttribute[];
+    bindings: BindGroup[];
+
+    updateNodes: Node[];
+    updateBeforeNodes: Node[];
+    updateAfterNodes: Node[];
+
+    monitor: NodeMaterialObserver;
+
+    usedTimes: number;
+
     constructor(
-        vertexShader,
-        fragmentShader,
-        computeShader,
-        nodeAttributes,
-        bindings,
-        updateNodes,
-        updateBeforeNodes,
-        updateAfterNodes,
-        monitor,
-        transforms = [],
+        vertexShader: string | null,
+        fragmentShader: string | null,
+        computeShader: string | null,
+        nodeAttributes: NodeAttribute[],
+        bindings: BindGroup[],
+        updateNodes: Node[],
+        updateBeforeNodes: Node[],
+        updateAfterNodes: Node[],
+        monitor: NodeMaterialObserver,
+        transforms: never[] = [],
     ) {
         this.vertexShader = vertexShader;
         this.fragmentShader = fragmentShader;
@@ -34,14 +54,14 @@ class NodeBuilderState {
         const bindings = [];
 
         for (const instanceGroup of this.bindings) {
-            const shared = instanceGroup.bindings[0].groupNode.shared;
+            const shared = (instanceGroup.bindings[0] as NodeUniformsGroup).groupNode.shared;
 
             if (shared !== true) {
                 const bindingsGroup = new BindGroup(instanceGroup.name, [], instanceGroup.index, instanceGroup);
                 bindings.push(bindingsGroup);
 
                 for (const instanceBinding of instanceGroup.bindings) {
-                    bindingsGroup.bindings.push(instanceBinding.clone());
+                    bindingsGroup.bindings.push((instanceBinding as NodeUniformsGroup).clone());
                 }
             } else {
                 bindings.push(instanceGroup);
diff --git a/src-testing/src/renderers/common/nodes/NodeLibrary.ts b/src-testing/src/renderers/common/nodes/NodeLibrary.ts
index 15931016..2128aa79 100644
--- a/src-testing/src/renderers/common/nodes/NodeLibrary.ts
+++ b/src-testing/src/renderers/common/nodes/NodeLibrary.ts
@@ -1,4 +1,21 @@
+import { Material } from '../../../materials/Material.js';
+import NodeMaterial from '../../../materials/nodes/NodeMaterial.js';
+import { ToneMapping } from '../../../constants.js';
+import { NodeRepresentation, ShaderNodeObject } from '../../../nodes/tsl/TSLCore.js';
+import Node from '../../../nodes/core/Node.js';
+import { Light } from '../../../lights/Light.js';
+import AnalyticLightNode from '../../../nodes/lighting/AnalyticLightNode.js';
+import { ColorSpaceMethod } from '../../../nodes/display/ColorSpaceNode.js';
+
 class NodeLibrary {
+    lightNodes: WeakMap<{ new (): Light }, { new (light: Light): AnalyticLightNode<Light> }>;
+    materialNodes: Map<string, { new (): NodeMaterial }>;
+    toneMappingNodes: Map<
+        ToneMapping,
+        (color: NodeRepresentation, exposure: NodeRepresentation) => ShaderNodeObject<Node>
+    >;
+    colorSpaceNodes: Map<ColorSpaceMethod, (color: NodeRepresentation) => ShaderNodeObject<Node>>;
+
     constructor() {
         this.lightNodes = new WeakMap();
         this.materialNodes = new Map();
@@ -6,8 +23,8 @@ class NodeLibrary {
         this.colorSpaceNodes = new Map();
     }
 
-    fromMaterial(material) {
-        if (material.isNodeMaterial) return material;
+    fromMaterial(material: Material) {
+        if ((material as NodeMaterial).isNodeMaterial) return material;
 
         let nodeMaterial = null;
 
@@ -24,39 +41,52 @@ class NodeLibrary {
         return nodeMaterial;
     }
 
-    addColorSpace(colorSpaceNode, colorSpace) {
+    addColorSpace(colorSpaceNode: (color: NodeRepresentation) => ShaderNodeObject<Node>, colorSpace: ColorSpaceMethod) {
         this.addType(colorSpaceNode, colorSpace, this.colorSpaceNodes);
     }
 
-    getColorSpaceFunction(colorSpace) {
+    getColorSpaceFunction(colorSpace: ColorSpaceMethod) {
         return this.colorSpaceNodes.get(colorSpace) || null;
     }
 
-    addToneMapping(toneMappingNode, toneMapping) {
+    addToneMapping(
+        toneMappingNode: (color: NodeRepresentation, exposure: NodeRepresentation) => ShaderNodeObject<Node>,
+        toneMapping: ToneMapping,
+    ) {
         this.addType(toneMappingNode, toneMapping, this.toneMappingNodes);
     }
 
-    getToneMappingFunction(toneMapping) {
+    getToneMappingFunction(toneMapping: ToneMapping) {
         return this.toneMappingNodes.get(toneMapping) || null;
     }
 
-    getMaterialNodeClass(materialType) {
+    getMaterialNodeClass(materialType: string) {
         return this.materialNodes.get(materialType) || null;
     }
 
-    addMaterial(materialNodeClass, materialClass) {
+    addMaterial(materialNodeClass: { new (): NodeMaterial }, materialClass: { new (): Material }) {
         this.addType(materialNodeClass, materialClass.type, this.materialNodes);
     }
 
-    getLightNodeClass(light) {
+    getLightNodeClass(light: Light) {
         return this.lightNodes.get(light) || null;
     }
 
-    addLight(lightNodeClass, lightClass) {
-        this.addClass(lightNodeClass, lightClass, this.lightNodes);
+    addLight<TLight extends Light>(
+        lightNodeClass: { new (light: TLight): AnalyticLightNode<TLight> },
+        lightClass: { new (): TLight },
+    ) {
+        this.addClass(
+            lightNodeClass,
+            lightClass,
+            this.lightNodes as unknown as WeakMap<
+                { new (): TLight },
+                { new (light: TLight): AnalyticLightNode<TLight> }
+            >,
+        );
     }
 
-    addType(nodeClass, type, library) {
+    addType<TNodeClass, TType>(nodeClass: TNodeClass, type: TType, library: Map<TType, TNodeClass>) {
         if (library.has(type)) {
             console.warn(`Redefinition of node ${type}`);
             return;
@@ -69,7 +99,11 @@ class NodeLibrary {
         library.set(type, nodeClass);
     }
 
-    addClass(nodeClass, baseClass, library) {
+    addClass<TNodeClass, TBaseClass extends object>(
+        nodeClass: TNodeClass,
+        baseClass: TBaseClass,
+        library: WeakMap<TBaseClass, TNodeClass>,
+    ) {
         if (library.has(baseClass)) {
             console.warn(`Redefinition of node ${baseClass.name}`);
             return;
diff --git a/src-testing/src/renderers/common/nodes/NodeUniform.ts b/src-testing/src/renderers/common/nodes/NodeUniform.ts
index 659f5a82..d4f47579 100644
--- a/src-testing/src/renderers/common/nodes/NodeUniform.ts
+++ b/src-testing/src/renderers/common/nodes/NodeUniform.ts
@@ -7,9 +7,18 @@ import {
     Matrix3Uniform,
     Matrix4Uniform,
 } from '../Uniform.js';
+import NodeUniform from '../../../nodes/core/NodeUniform.js';
+import { Vector2 } from '../../../math/Vector2.js';
+import { Vector3 } from '../../../math/Vector3.js';
+import { Vector4 } from '../../../math/Vector4.js';
+import { Color } from '../../../math/Color.js';
+import { Matrix3 } from '../../../math/Matrix3.js';
+import { Matrix4 } from '../../../math/Matrix4.js';
 
 class NumberNodeUniform extends NumberUniform {
-    constructor(nodeUniform) {
+    nodeUniform: NodeUniform<number>;
+
+    constructor(nodeUniform: NodeUniform<number>) {
         super(nodeUniform.name, nodeUniform.value);
 
         this.nodeUniform = nodeUniform;
@@ -21,7 +30,9 @@ class NumberNodeUniform extends NumberUniform {
 }
 
 class Vector2NodeUniform extends Vector2Uniform {
-    constructor(nodeUniform) {
+    nodeUniform: NodeUniform<Vector2>;
+
+    constructor(nodeUniform: NodeUniform<Vector2>) {
         super(nodeUniform.name, nodeUniform.value);
 
         this.nodeUniform = nodeUniform;
@@ -33,7 +44,9 @@ class Vector2NodeUniform extends Vector2Uniform {
 }
 
 class Vector3NodeUniform extends Vector3Uniform {
-    constructor(nodeUniform) {
+    nodeUniform: NodeUniform<Vector3>;
+
+    constructor(nodeUniform: NodeUniform<Vector3>) {
         super(nodeUniform.name, nodeUniform.value);
 
         this.nodeUniform = nodeUniform;
@@ -45,7 +58,9 @@ class Vector3NodeUniform extends Vector3Uniform {
 }
 
 class Vector4NodeUniform extends Vector4Uniform {
-    constructor(nodeUniform) {
+    nodeUniform: NodeUniform<Vector4>;
+
+    constructor(nodeUniform: NodeUniform<Vector4>) {
         super(nodeUniform.name, nodeUniform.value);
 
         this.nodeUniform = nodeUniform;
@@ -57,7 +72,9 @@ class Vector4NodeUniform extends Vector4Uniform {
 }
 
 class ColorNodeUniform extends ColorUniform {
-    constructor(nodeUniform) {
+    nodeUniform: NodeUniform<Color>;
+
+    constructor(nodeUniform: NodeUniform<Color>) {
         super(nodeUniform.name, nodeUniform.value);
 
         this.nodeUniform = nodeUniform;
@@ -69,7 +86,9 @@ class ColorNodeUniform extends ColorUniform {
 }
 
 class Matrix3NodeUniform extends Matrix3Uniform {
-    constructor(nodeUniform) {
+    nodeUniform: NodeUniform<Matrix3>;
+
+    constructor(nodeUniform: NodeUniform<Matrix3>) {
         super(nodeUniform.name, nodeUniform.value);
 
         this.nodeUniform = nodeUniform;
@@ -81,7 +100,9 @@ class Matrix3NodeUniform extends Matrix3Uniform {
 }
 
 class Matrix4NodeUniform extends Matrix4Uniform {
-    constructor(nodeUniform) {
+    nodeUniform: NodeUniform<Matrix4>;
+
+    constructor(nodeUniform: NodeUniform<Matrix4>) {
         super(nodeUniform.name, nodeUniform.value);
 
         this.nodeUniform = nodeUniform;
@@ -101,3 +122,11 @@ export {
     Matrix3NodeUniform,
     Matrix4NodeUniform,
 };
+export type NodeUniformGPU =
+    | NumberNodeUniform
+    | Vector2NodeUniform
+    | Vector3NodeUniform
+    | Vector4NodeUniform
+    | ColorNodeUniform
+    | Matrix3NodeUniform
+    | Matrix4NodeUniform;
diff --git a/src-testing/src/renderers/common/nodes/NodeUniformsGroup.ts b/src-testing/src/renderers/common/nodes/NodeUniformsGroup.ts
index d2d92cb2..c022f814 100644
--- a/src-testing/src/renderers/common/nodes/NodeUniformsGroup.ts
+++ b/src-testing/src/renderers/common/nodes/NodeUniformsGroup.ts
@@ -1,9 +1,15 @@
 import UniformsGroup from '../UniformsGroup.js';
+import { UniformGroupNode, UniformNode } from '../../../nodes/Nodes.js';
 
 let _id = 0;
 
 class NodeUniformsGroup extends UniformsGroup {
-    constructor(name, groupNode) {
+    id: number;
+    groupNode: UniformGroupNode;
+
+    readonly isNodeUniformsGroup: true;
+
+    constructor(name: string, groupNode: UniformGroupNode) {
         super(name);
 
         this.id = _id++;
@@ -13,7 +19,7 @@ class NodeUniformsGroup extends UniformsGroup {
     }
 
     getNodes() {
-        const nodes = [];
+        const nodes: UniformNode<unknown>[] = [];
 
         for (const uniform of this.uniforms) {
             const node = uniform.nodeUniform.node;
diff --git a/src-testing/src/renderers/common/nodes/Nodes.ts b/src-testing/src/renderers/common/nodes/Nodes.ts
index f409c2b1..bb53c090 100644
--- a/src-testing/src/renderers/common/nodes/Nodes.ts
+++ b/src-testing/src/renderers/common/nodes/Nodes.ts
@@ -15,6 +15,7 @@ import {
     normalWorld,
     pmremTexture,
     screenUV,
+    ShaderNodeObject,
 } from '../../../nodes/TSL.js';
 
 import {
@@ -23,11 +24,71 @@ import {
     EquirectangularRefractionMapping,
 } from '../../../constants.js';
 import { hashArray } from '../../../nodes/core/NodeUtils.js';
+import { Color } from '../../../math/Color.js';
+import { Texture } from '../../../textures/Texture.js';
+import { CubeTexture } from '../../../textures/CubeTexture.js';
+import { Fog } from '../../../scenes/Fog.js';
+import { FogExp2 } from '../../../scenes/FogExp2.js';
+import NodeUniformsGroup from './NodeUniformsGroup.js';
+import RenderObject from '../RenderObject.js';
+import { Scene } from '../../../scenes/Scene.js';
+import Renderer from '../Renderer.js';
+import Backend from '../Backend.js';
+import { Object3D } from '../../../core/Object3D.js';
+import { Camera } from '../../../cameras/Camera.js';
+import { Material } from '../../../materials/Material.js';
+import Node from '../../../nodes/core/Node.js';
+import ComputeNode from '../../../nodes/gpgpu/ComputeNode.js';
+import LightsNode from '../../../nodes/lighting/LightsNode.js';
+import UniformGroupNode from '../../../nodes/core/UniformGroupNode.js';
+import NodeBuilder from '../../../nodes/core/NodeBuilder.js';
+
+interface NodeUniformsGroupData {
+    renderId?: number | undefined;
+    frameId?: number | undefined;
+}
+
+interface RenderObjectData {
+    nodeBuilderState?: NodeBuilderState | undefined;
+}
+
+interface ComputeNodeData {
+    nodeBuilderState?: NodeBuilderState | undefined;
+}
+
+interface SceneData {
+    background?: Color | Texture | CubeTexture | undefined;
+    backgroundNode?: Node | undefined;
+    fog?: Fog | FogExp2 | undefined;
+    fogNode?: Node | undefined;
+    environment?: Texture | undefined;
+    environmentNode?: Node | undefined;
+}
+
+declare module '../../../scenes/Scene.js' {
+    interface Scene {
+        environmentNode?: Node | null | undefined;
+        backgroundNode?: Node | null | undefined;
+        fogNode?: Node | null | undefined;
+    }
+}
 
 const outputNodeMap = new WeakMap();
 
-class Nodes extends DataMap {
-    constructor(renderer, backend) {
+class Nodes extends DataMap<{
+    nodeUniformsGroup: { key: NodeUniformsGroup; value: NodeUniformsGroupData };
+    renderObject: { key: RenderObject; value: RenderObjectData };
+    computeNode: { key: ComputeNode; value: ComputeNodeData };
+    scene: { key: Scene; value: SceneData };
+}> {
+    renderer: Renderer;
+    backend: Backend;
+    nodeFrame: NodeFrame;
+    nodeBuilderCache: Map<string, NodeBuilderState>;
+    callHashCache: ChainMap<readonly [Scene, LightsNode], { callId: number; cacheKey: string }>;
+    groupsData: ChainMap<readonly [UniformGroupNode, NodeUniformsGroup], { version?: number }>;
+
+    constructor(renderer: Renderer, backend: Backend) {
         super();
 
         this.renderer = renderer;
@@ -38,7 +99,7 @@ class Nodes extends DataMap {
         this.groupsData = new ChainMap();
     }
 
-    updateGroup(nodeUniformsGroup) {
+    updateGroup(nodeUniformsGroup: NodeUniformsGroup) {
         const groupNode = nodeUniformsGroup.groupNode;
         const name = groupNode.name;
 
@@ -78,7 +139,7 @@ class Nodes extends DataMap {
 
         // other groups are updated just when groupNode.needsUpdate is true
 
-        const groupChain = [groupNode, nodeUniformsGroup];
+        const groupChain = [groupNode, nodeUniformsGroup] as const;
 
         let groupData = this.groupsData.get(groupChain);
         if (groupData === undefined) this.groupsData.set(groupChain, (groupData = {}));
@@ -92,11 +153,11 @@ class Nodes extends DataMap {
         return false;
     }
 
-    getForRenderCacheKey(renderObject) {
+    getForRenderCacheKey(renderObject: RenderObject) {
         return renderObject.initialCacheKey;
     }
 
-    getForRender(renderObject) {
+    getForRender(renderObject: RenderObject) {
         const renderObjectData = this.get(renderObject);
 
         let nodeBuilderState = renderObjectData.nodeBuilderState;
@@ -133,20 +194,20 @@ class Nodes extends DataMap {
         return nodeBuilderState;
     }
 
-    delete(object) {
-        if (object.isRenderObject) {
-            const nodeBuilderState = this.get(object).nodeBuilderState;
+    delete(object: NodeUniformsGroup | RenderObject | ComputeNode | Scene) {
+        if ((object as RenderObject).isRenderObject) {
+            const nodeBuilderState = this.get(object as RenderObject).nodeBuilderState!;
             nodeBuilderState.usedTimes--;
 
             if (nodeBuilderState.usedTimes === 0) {
-                this.nodeBuilderCache.delete(this.getForRenderCacheKey(object));
+                this.nodeBuilderCache.delete(this.getForRenderCacheKey(object as RenderObject));
             }
         }
 
         return super.delete(object);
     }
 
-    getForCompute(computeNode) {
+    getForCompute(computeNode: ComputeNode) {
         const computeData = this.get(computeNode);
 
         let nodeBuilderState = computeData.nodeBuilderState;
@@ -163,7 +224,7 @@ class Nodes extends DataMap {
         return nodeBuilderState;
     }
 
-    _createNodeBuilderState(nodeBuilder) {
+    _createNodeBuilderState(nodeBuilder: NodeBuilder) {
         return new NodeBuilderState(
             nodeBuilder.vertexShader,
             nodeBuilder.fragmentShader,
@@ -178,20 +239,20 @@ class Nodes extends DataMap {
         );
     }
 
-    getEnvironmentNode(scene) {
+    getEnvironmentNode(scene: Scene) {
         return scene.environmentNode || this.get(scene).environmentNode || null;
     }
 
-    getBackgroundNode(scene) {
+    getBackgroundNode(scene: Scene) {
         return scene.backgroundNode || this.get(scene).backgroundNode || null;
     }
 
-    getFogNode(scene) {
+    getFogNode(scene: Scene) {
         return scene.fogNode || this.get(scene).fogNode || null;
     }
 
-    getCacheKey(scene, lightsNode) {
-        const chain = [scene, lightsNode];
+    getCacheKey(scene: Scene, lightsNode: LightsNode) {
+        const chain = [scene, lightsNode] as const;
         const callId = this.renderer.info.calls;
 
         let cacheKeyData = this.callHashCache.get(chain);
@@ -219,7 +280,7 @@ class Nodes extends DataMap {
         return cacheKeyData.cacheKey;
     }
 
-    updateScene(scene) {
+    updateScene(scene: Scene) {
         this.updateEnvironment(scene);
         this.updateFog(scene);
         this.updateBackground(scene);
@@ -229,7 +290,7 @@ class Nodes extends DataMap {
         return this.renderer.getRenderTarget() ? false : true;
     }
 
-    updateBackground(scene) {
+    updateBackground(scene: Scene) {
         const sceneData = this.get(scene);
         const background = scene.background;
 
@@ -242,7 +303,7 @@ class Nodes extends DataMap {
                 let backgroundNode = null;
 
                 if (
-                    background.isCubeTexture === true ||
+                    (background as CubeTexture).isCubeTexture === true ||
                     background.mapping === EquirectangularReflectionMapping ||
                     background.mapping === EquirectangularRefractionMapping ||
                     background.mapping === CubeUVReflectionMapping
@@ -252,18 +313,18 @@ class Nodes extends DataMap {
                     } else {
                         let envMap;
 
-                        if (background.isCubeTexture === true) {
-                            envMap = cubeTexture(background);
+                        if ((background as CubeTexture).isCubeTexture === true) {
+                            envMap = cubeTexture(background as CubeTexture);
                         } else {
                             envMap = texture(background);
                         }
 
                         backgroundNode = cubeMapNode(envMap);
                     }
-                } else if (background.isTexture === true) {
-                    backgroundNode = texture(background, screenUV.flipY()).setUpdateMatrix(true);
-                } else if (background.isColor !== true) {
-                    console.error('WebGPUNodes: Unsupported background configuration.', background);
+                } else if ((background as Texture).isTexture === true) {
+                    backgroundNode = texture(background as Texture, screenUV.flipY()).setUpdateMatrix(true);
+                } else if ((background as Color).isColor !== true) {
+                    console.error('WebGPUNodes: Unsupported background configuration.', background as Color);
                 }
 
                 sceneData.backgroundNode = backgroundNode;
@@ -276,7 +337,7 @@ class Nodes extends DataMap {
         }
     }
 
-    updateFog(scene) {
+    updateFog(scene: Scene) {
         const sceneData = this.get(scene);
         const fog = scene.fog;
 
@@ -284,15 +345,15 @@ class Nodes extends DataMap {
             if (sceneData.fog !== fog) {
                 let fogNode = null;
 
-                if (fog.isFogExp2) {
-                    const color = reference('color', 'color', fog).setGroup(renderGroup);
-                    const density = reference('density', 'float', fog).setGroup(renderGroup);
+                if ((fog as FogExp2).isFogExp2) {
+                    const color = reference('color', 'color', fog as FogExp2).setGroup(renderGroup);
+                    const density = reference('density', 'float', fog as FogExp2).setGroup(renderGroup);
 
                     fogNode = densityFog(color, density);
-                } else if (fog.isFog) {
-                    const color = reference('color', 'color', fog).setGroup(renderGroup);
-                    const near = reference('near', 'float', fog).setGroup(renderGroup);
-                    const far = reference('far', 'float', fog).setGroup(renderGroup);
+                } else if ((fog as Fog).isFog) {
+                    const color = reference('color', 'color', fog as Fog).setGroup(renderGroup);
+                    const near = reference('near', 'float', fog as Fog).setGroup(renderGroup);
+                    const far = reference('far', 'float', fog as Fog).setGroup(renderGroup);
 
                     fogNode = rangeFog(color, near, far);
                 } else {
@@ -308,7 +369,7 @@ class Nodes extends DataMap {
         }
     }
 
-    updateEnvironment(scene) {
+    updateEnvironment(scene: Scene) {
         const sceneData = this.get(scene);
         const environment = scene.environment;
 
@@ -316,7 +377,7 @@ class Nodes extends DataMap {
             if (sceneData.environment !== environment) {
                 let environmentNode = null;
 
-                if (environment.isCubeTexture === true) {
+                if ((environment as CubeTexture).isCubeTexture === true) {
                     environmentNode = cubeTexture(environment);
                 } else if (environment.isTexture === true) {
                     environmentNode = texture(environment);
@@ -333,7 +394,13 @@ class Nodes extends DataMap {
         }
     }
 
-    getNodeFrame(renderer = this.renderer, scene = null, object = null, camera = null, material = null) {
+    getNodeFrame(
+        renderer = this.renderer,
+        scene: Scene | null = null,
+        object: Object3D | null = null,
+        camera: Camera | null = null,
+        material: Material | null = null,
+    ) {
         const nodeFrame = this.nodeFrame;
         nodeFrame.renderer = renderer;
         nodeFrame.scene = scene;
@@ -344,7 +411,7 @@ class Nodes extends DataMap {
         return nodeFrame;
     }
 
-    getNodeFrameForRender(renderObject) {
+    getNodeFrameForRender(renderObject: RenderObject) {
         return this.getNodeFrame(
             renderObject.renderer,
             renderObject.scene,
@@ -360,24 +427,27 @@ class Nodes extends DataMap {
         return renderer.toneMapping + ',' + renderer.currentColorSpace;
     }
 
-    hasOutputChange(outputTarget) {
+    hasOutputChange(outputTarget: Texture) {
         const cacheKey = outputNodeMap.get(outputTarget);
 
         return cacheKey !== this.getOutputCacheKey();
     }
 
-    getOutputNode(outputTexture) {
+    getOutputNode(outputTexture: Texture) {
         const renderer = this.renderer;
         const cacheKey = this.getOutputCacheKey();
 
-        const output = texture(outputTexture, screenUV).renderOutput(renderer.toneMapping, renderer.currentColorSpace);
+        const output: ShaderNodeObject<Node> = texture(outputTexture, screenUV).renderOutput(
+            renderer.toneMapping,
+            renderer.currentColorSpace,
+        );
 
         outputNodeMap.set(outputTexture, cacheKey);
 
         return output;
     }
 
-    updateBefore(renderObject) {
+    updateBefore(renderObject: RenderObject) {
         const nodeBuilder = renderObject.getNodeBuilderState();
 
         for (const node of nodeBuilder.updateBeforeNodes) {
@@ -387,7 +457,7 @@ class Nodes extends DataMap {
         }
     }
 
-    updateAfter(renderObject) {
+    updateAfter(renderObject: RenderObject) {
         const nodeBuilder = renderObject.getNodeBuilderState();
 
         for (const node of nodeBuilder.updateAfterNodes) {
@@ -397,7 +467,7 @@ class Nodes extends DataMap {
         }
     }
 
-    updateForCompute(computeNode) {
+    updateForCompute(computeNode: ComputeNode) {
         const nodeFrame = this.getNodeFrame();
         const nodeBuilder = this.getForCompute(computeNode);
 
@@ -406,7 +476,7 @@ class Nodes extends DataMap {
         }
     }
 
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         const nodeFrame = this.getNodeFrameForRender(renderObject);
         const nodeBuilder = renderObject.getNodeBuilderState();
 
@@ -415,7 +485,7 @@ class Nodes extends DataMap {
         }
     }
 
-    needsRefresh(renderObject) {
+    needsRefresh(renderObject: RenderObject) {
         const nodeFrame = this.getNodeFrameForRender(renderObject);
         const monitor = renderObject.getMonitor();
 
diff --git a/src-testing/src/renderers/webgl-fallback/WebGLBackend.ts b/src-testing/src/renderers/webgl-fallback/WebGLBackend.ts
index 3ed6e6a0..e2436879 100644
--- a/src-testing/src/renderers/webgl-fallback/WebGLBackend.ts
+++ b/src-testing/src/renderers/webgl-fallback/WebGLBackend.ts
@@ -13,6 +13,7 @@ import { WebGLBufferRenderer } from './WebGLBufferRenderer.js';
 
 import { warnOnce } from '../../utils.js';
 import { WebGLCoordinateSystem } from '../../constants.js';
+import { Texture } from '../../textures/Texture.js';
 
 //
 
@@ -664,7 +665,7 @@ class WebGLBackend extends Backend {
         this.textureUtils.destroyTexture(texture);
     }
 
-    copyTextureToBuffer(texture, x, y, width, height, faceIndex) {
+    copyTextureToBuffer(texture: Texture, x: number, y: number, width: number, height: number, faceIndex: number) {
         return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);
     }
 
diff --git a/src-testing/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.ts b/src-testing/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.ts
index b1e72064..40f26bf1 100644
--- a/src-testing/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.ts
+++ b/src-testing/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.ts
@@ -1,4 +1,4 @@
-import { GLSLNodeParser, NodeBuilder, TextureNode, vectorComponents } from '../../../nodes/Nodes.js';
+import { GLSLNodeParser, NodeBuilder, NodeShaderStage, TextureNode, vectorComponents } from '../../../nodes/Nodes.js';
 
 import NodeUniformBuffer from '../../common/nodes/NodeUniformBuffer.js';
 import NodeUniformsGroup from '../../common/nodes/NodeUniformsGroup.js';
@@ -28,8 +28,19 @@ import {
     FloatType,
 } from '../../../constants.js';
 import { DataTexture } from '../../../textures/DataTexture.js';
-
-const glslMethods = {
+import Renderer from '../../common/Renderer.js';
+import StructTypeNode from '../../../nodes/core/StructTypeNode.js';
+import BufferAttributeNode from '../../../nodes/accessors/BufferAttributeNode.js';
+import UniformNode from '../../../nodes/core/UniformNode.js';
+import { Object3D } from '../../../core/Object3D.js';
+import { Texture } from '../../../textures/Texture.js';
+import { BufferAttribute } from '../../../core/BufferAttribute.js';
+import { InterleavedBufferAttribute } from '../../../core/InterleavedBufferAttribute.js';
+import { ShaderNodeInternal, ShaderNodeObject } from '../../../nodes/tsl/TSLCore.js';
+import StorageBufferNode from '../../../nodes/accessors/StorageBufferNode.js';
+import StorageArrayElementNode from '../../../nodes/utils/StorageArrayElementNode.js';
+
+const glslMethods: { [method: string]: string } = {
     atan2: 'atan',
     textureDimensions: 'textureSize',
     equals: 'equal',
@@ -67,8 +78,37 @@ precision highp isampler2DArray;
 precision lowp sampler2DShadow;
 `;
 
+export interface Transform {
+    varyingName: string | null | undefined;
+    attributeNode: ShaderNodeObject<BufferAttributeNode>;
+}
+
+interface StageData {
+    extensions?: string | undefined;
+    uniforms?: string | undefined;
+    attributes?: string | undefined;
+    varyings?: string | undefined;
+    vars?: string | undefined;
+    structs?: string | undefined;
+    codes?: string | undefined;
+    transforms?: string | undefined;
+    flow?: string | undefined;
+}
+
 class GLSLNodeBuilder extends NodeBuilder {
-    constructor(object, renderer) {
+    uniformGroups: {
+        vertex?: { [groupName: string]: NodeUniformsGroup | undefined };
+        fragment?: { [groupName: string]: NodeUniformsGroup | undefined };
+        compute?: { [groupName: string]: NodeUniformsGroup | undefined };
+    };
+    transforms: Transform[];
+    extensions: {
+        vertex?: Map<string, string>;
+        fragment?: Map<string, string>;
+        compute?: Map<string, string>;
+    };
+
+    constructor(object: Object3D, renderer: Renderer) {
         super(object, renderer, new GLSLNodeParser());
 
         this.uniformGroups = {};
@@ -82,7 +122,7 @@ class GLSLNodeBuilder extends NodeBuilder {
         return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;
     }
 
-    getMethod(method) {
+    getMethod(method: string) {
         return glslMethods[method] || method;
     }
 
@@ -90,7 +130,7 @@ class GLSLNodeBuilder extends NodeBuilder {
         return '';
     }
 
-    buildFunctionCode(shaderNode) {
+    buildFunctionCode(shaderNode: ShaderNodeInternal) {
         const layout = shaderNode.layout;
         const flowData = this.flowShaderNode(shaderNode);
 
@@ -116,7 +156,7 @@ ${flowData.code}
         return code;
     }
 
-    setupPBO(storageBufferNode) {
+    setupPBO(storageBufferNode: StorageBufferNode) {
         const attribute = storageBufferNode.value;
 
         if (attribute.pbo === undefined) {
@@ -180,7 +220,7 @@ ${flowData.code}
         }
     }
 
-    getPropertyName(node, shaderStage = this.shaderStage) {
+    getPropertyName(node: unknown, shaderStage = this.shaderStage) {
         if (node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true) {
             return shaderStage.charAt(0) + '_' + node.name;
         }
@@ -188,7 +228,7 @@ ${flowData.code}
         return super.getPropertyName(node, shaderStage);
     }
 
-    generatePBO(storageArrayElementNode) {
+    generatePBO(storageArrayElementNode: StorageArrayElementNode) {
         const { node, indexNode } = storageArrayElementNode;
         const attribute = node.value;
 
@@ -260,7 +300,13 @@ ${flowData.code}
         return propertyName;
     }
 
-    generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0') {
+    generateTextureLoad(
+        texture: Texture | null,
+        textureProperty: string | undefined,
+        uvIndexSnippet: string,
+        depthSnippet: string | null,
+        levelSnippet = '0',
+    ) {
         if (depthSnippet) {
             return `texelFetch( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet} )`;
         } else {
@@ -268,7 +314,7 @@ ${flowData.code}
         }
     }
 
-    generateTexture(texture, textureProperty, uvSnippet, depthSnippet) {
+    generateTexture(texture: Texture, textureProperty: string, uvSnippet: string | null, depthSnippet: string | null) {
         if (texture.isDepthTexture) {
             return `texture( ${textureProperty}, ${uvSnippet} ).x`;
         } else {
@@ -278,24 +324,39 @@ ${flowData.code}
         }
     }
 
-    generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet) {
+    generateTextureLevel(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        levelSnippet: string | null,
+    ) {
         return `textureLod( ${textureProperty}, ${uvSnippet}, ${levelSnippet} )`;
     }
 
-    generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet) {
+    generateTextureBias(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        biasSnippet: string | null,
+    ) {
         return `texture( ${textureProperty}, ${uvSnippet}, ${biasSnippet} )`;
     }
 
-    generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet) {
+    generateTextureGrad(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        gradSnippet: [string, string] | null,
+    ) {
         return `textureGrad( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]} )`;
     }
 
     generateTextureCompare(
-        texture,
-        textureProperty,
-        uvSnippet,
-        compareSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        compareSnippet: string | null,
+        depthSnippet: string | null,
         shaderStage = this.shaderStage,
     ) {
         if (shaderStage === 'fragment') {
@@ -304,11 +365,12 @@ ${flowData.code}
             console.error(
                 `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`,
             );
+            return undefined as unknown as string;
         }
     }
 
-    getVars(shaderStage) {
-        const snippets = [];
+    getVars(shaderStage: 'vertex' | 'fragment' | 'compute') {
+        const snippets: string[] = [];
 
         const vars = this.vars[shaderStage];
 
@@ -321,7 +383,7 @@ ${flowData.code}
         return snippets.join('\n\t');
     }
 
-    getUniforms(shaderStage) {
+    getUniforms(shaderStage: 'vertex' | 'fragment' | 'compute') {
         const uniforms = this.uniforms[shaderStage];
 
         const bindingSnippets = [];
@@ -403,7 +465,7 @@ ${flowData.code}
         return output;
     }
 
-    getTypeFromAttribute(attribute) {
+    getTypeFromAttribute(attribute: BufferAttribute | InterleavedBufferAttribute) {
         let nodeType = super.getTypeFromAttribute(attribute);
 
         if (/^[iu]/.test(nodeType) && attribute.gpuType !== IntType) {
@@ -421,7 +483,7 @@ ${flowData.code}
         return nodeType;
     }
 
-    getAttributes(shaderStage) {
+    getAttributes(shaderStage: NodeShaderStage) {
         let snippet = '';
 
         if (shaderStage === 'vertex' || shaderStage === 'compute') {
@@ -437,8 +499,8 @@ ${flowData.code}
         return snippet;
     }
 
-    getStructMembers(struct) {
-        const snippets = [];
+    getStructMembers(struct: StructTypeNode) {
+        const snippets: string[] = [];
         const members = struct.getMemberTypes();
 
         for (let i = 0; i < members.length; i++) {
@@ -449,7 +511,7 @@ ${flowData.code}
         return snippets.join('\n');
     }
 
-    getStructs(shaderStage) {
+    getStructs(shaderStage: NodeShaderStage) {
         const snippets = [];
         const structs = this.structs[shaderStage];
 
@@ -470,7 +532,7 @@ ${flowData.code}
         return snippets.join('\n\n');
     }
 
-    getVaryings(shaderStage) {
+    getVaryings(shaderStage: NodeShaderStage) {
         let snippet = '';
 
         const varyings = this.varyings;
@@ -535,7 +597,7 @@ ${flowData.code}
         return 'gl_FragDepth';
     }
 
-    enableExtension(name, behavior, shaderStage = this.shaderStage) {
+    enableExtension(name: string, behavior: string, shaderStage = this.shaderStage!) {
         const map = this.extensions[shaderStage] || (this.extensions[shaderStage] = new Map());
 
         if (map.has(name) === false) {
@@ -546,7 +608,7 @@ ${flowData.code}
         }
     }
 
-    getExtensions(shaderStage) {
+    getExtensions(shaderStage: NodeShaderStage) {
         const snippets = [];
 
         if (shaderStage === 'vertex') {
@@ -569,7 +631,7 @@ ${flowData.code}
         return snippets.join('\n');
     }
 
-    isAvailable(name) {
+    isAvailable(name: string) {
         let result = supports[name];
 
         if (result === undefined) {
@@ -594,11 +656,11 @@ ${flowData.code}
         return true;
     }
 
-    registerTransform(varyingName, attributeNode) {
+    registerTransform(varyingName: string | null | undefined, attributeNode: ShaderNodeObject<BufferAttributeNode>) {
         this.transforms.push({ varyingName, attributeNode });
     }
 
-    getTransforms(/* shaderStage  */) {
+    getTransforms(shaderStage: NodeShaderStage) {
         const transforms = this.transforms;
 
         let snippet = '';
@@ -614,14 +676,14 @@ ${flowData.code}
         return snippet;
     }
 
-    _getGLSLUniformStruct(name, vars) {
+    _getGLSLUniformStruct(name: string, vars: string) {
         return `
 layout( std140 ) uniform ${name} {
 ${vars}
 };`;
     }
 
-    _getGLSLVertexCode(shaderData) {
+    _getGLSLVertexCode(shaderData: StageData) {
         return `#version 300 es
 
 ${this.getSignature()}
@@ -661,7 +723,7 @@ void main() {
 `;
     }
 
-    _getGLSLFragmentCode(shaderData) {
+    _getGLSLFragmentCode(shaderData: StageData) {
         return `#version 300 es
 
 ${this.getSignature()}
@@ -693,19 +755,20 @@ void main() {
     }
 
     buildCode() {
-        const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
+        const shadersData: { fragment?: StageData; vertex?: StageData; compute?: StageData } =
+            this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
 
         this.sortBindingGroups();
 
         for (const shaderStage in shadersData) {
             let flow = '// code\n\n';
-            flow += this.flowCode[shaderStage];
+            flow += this.flowCode[shaderStage as NodeShaderStage];
 
-            const flowNodes = this.flowNodes[shaderStage];
+            const flowNodes = this.flowNodes[shaderStage as NodeShaderStage];
             const mainNode = flowNodes[flowNodes.length - 1];
 
             for (const node of flowNodes) {
-                const flowSlotData = this.getFlowData(node /*, shaderStage*/);
+                const flowSlotData = this.getFlowData(node /*, shaderStage*/)!;
                 const slotName = node.name;
 
                 if (slotName) {
@@ -731,28 +794,33 @@ void main() {
                 }
             }
 
-            const stageData = shadersData[shaderStage];
+            const stageData = shadersData[shaderStage as NodeShaderStage]!;
 
-            stageData.extensions = this.getExtensions(shaderStage);
-            stageData.uniforms = this.getUniforms(shaderStage);
-            stageData.attributes = this.getAttributes(shaderStage);
-            stageData.varyings = this.getVaryings(shaderStage);
-            stageData.vars = this.getVars(shaderStage);
-            stageData.structs = this.getStructs(shaderStage);
-            stageData.codes = this.getCodes(shaderStage);
-            stageData.transforms = this.getTransforms(shaderStage);
+            stageData.extensions = this.getExtensions(shaderStage as NodeShaderStage);
+            stageData.uniforms = this.getUniforms(shaderStage as NodeShaderStage);
+            stageData.attributes = this.getAttributes(shaderStage as NodeShaderStage);
+            stageData.varyings = this.getVaryings(shaderStage as NodeShaderStage);
+            stageData.vars = this.getVars(shaderStage as NodeShaderStage);
+            stageData.structs = this.getStructs(shaderStage as NodeShaderStage);
+            stageData.codes = this.getCodes(shaderStage as NodeShaderStage);
+            stageData.transforms = this.getTransforms(shaderStage as NodeShaderStage);
             stageData.flow = flow;
         }
 
         if (this.material !== null) {
-            this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);
-            this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);
+            this.vertexShader = this._getGLSLVertexCode(shadersData.vertex!);
+            this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment!);
         } else {
-            this.computeShader = this._getGLSLVertexCode(shadersData.compute);
+            this.computeShader = this._getGLSLVertexCode(shadersData.compute!);
         }
     }
 
-    getUniformFromNode(node, type, shaderStage, name = null) {
+    getUniformFromNode(
+        node: UniformNode<unknown>,
+        type: string | null,
+        shaderStage: 'vertex' | 'fragment' | 'compute',
+        name: string | null = null,
+    ) {
         const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
diff --git a/src-testing/src/renderers/webgpu/WebGPUBackend.ts b/src-testing/src/renderers/webgpu/WebGPUBackend.ts
index 263ccfa4..840b556c 100644
--- a/src-testing/src/renderers/webgpu/WebGPUBackend.ts
+++ b/src-testing/src/renderers/webgpu/WebGPUBackend.ts
@@ -947,7 +947,7 @@ class WebGPUBackend extends Backend {
         this.textureUtils.destroyTexture(texture);
     }
 
-    copyTextureToBuffer(texture, x, y, width, height, faceIndex) {
+    copyTextureToBuffer(texture: Texture, x: number, y: number, width: number, height: number, faceIndex: number) {
         return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);
     }
 
diff --git a/src-testing/src/renderers/webgpu/nodes/WGSLNodeBuilder.ts b/src-testing/src/renderers/webgpu/nodes/WGSLNodeBuilder.ts
index 1adea208..53774495 100644
--- a/src-testing/src/renderers/webgpu/nodes/WGSLNodeBuilder.ts
+++ b/src-testing/src/renderers/webgpu/nodes/WGSLNodeBuilder.ts
@@ -10,7 +10,7 @@ import {
 import NodeUniformBuffer from '../../common/nodes/NodeUniformBuffer.js';
 import NodeStorageBuffer from '../../common/nodes/NodeStorageBuffer.js';
 
-import { NodeBuilder, CodeNode } from '../../../nodes/Nodes.js';
+import { NodeBuilder, CodeNode, NodeShaderStage, ShaderNodeInternal } from '../../../nodes/Nodes.js';
 
 import { getFormat } from '../utils/WebGPUTextureUtils.js';
 
@@ -18,6 +18,8 @@ import WGSLNodeParser from './WGSLNodeParser.js';
 import { GPUBufferBindingType, GPUStorageTextureAccess } from '../utils/WebGPUConstants.js';
 
 import { NoColorSpace, FloatType } from '../../../constants.js';
+import { Texture } from '../../../textures/Texture.js';
+import UniformNode from '../../../nodes/core/UniformNode.js';
 
 // GPUShaderStage is not defined in browsers not supporting WebGPU
 const GPUShaderStage = self.GPUShaderStage;
@@ -194,7 +196,13 @@ class WGSLNodeBuilder extends NodeBuilder {
         return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;
     }
 
-    _generateTextureSample(texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage) {
+    _generateTextureSample(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        depthSnippet: string | null,
+        shaderStage = this.shaderStage,
+    ) {
         if (shaderStage === 'fragment') {
             if (depthSnippet) {
                 return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet} )`;
@@ -239,7 +247,12 @@ class WGSLNodeBuilder extends NodeBuilder {
         return `tsl_biquadraticTexture( ${textureProperty}, ${uvSnippet}, i32( ${levelSnippet} ) )`;
     }
 
-    generateTextureLod(texture, textureProperty, uvSnippet, levelSnippet = '0') {
+    generateTextureLod(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        levelSnippet: string | null = '0',
+    ) {
         this._include('repeatWrapping');
 
         const dimension =
@@ -250,7 +263,13 @@ class WGSLNodeBuilder extends NodeBuilder {
         return `textureLoad( ${textureProperty}, tsl_repeatWrapping( ${uvSnippet}, ${dimension} ), i32( ${levelSnippet} ) )`;
     }
 
-    generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u') {
+    generateTextureLoad(
+        texture: Texture,
+        textureProperty: string,
+        uvIndexSnippet: string | null,
+        depthSnippet: string | null,
+        levelSnippet = '0u',
+    ) {
         if (depthSnippet) {
             return `textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, ${levelSnippet} )`;
         } else {
@@ -285,11 +304,11 @@ class WGSLNodeBuilder extends NodeBuilder {
     }
 
     generateTextureGrad(
-        texture,
-        textureProperty,
-        uvSnippet,
-        gradSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        gradSnippet: [string, string] | null,
+        depthSnippet: string | null,
         shaderStage = this.shaderStage,
     ) {
         if (shaderStage === 'fragment') {
@@ -301,11 +320,11 @@ class WGSLNodeBuilder extends NodeBuilder {
     }
 
     generateTextureCompare(
-        texture,
-        textureProperty,
-        uvSnippet,
-        compareSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        compareSnippet: string | null,
+        depthSnippet: string | null,
         shaderStage = this.shaderStage,
     ) {
         if (shaderStage === 'fragment') {
@@ -318,11 +337,11 @@ class WGSLNodeBuilder extends NodeBuilder {
     }
 
     generateTextureLevel(
-        texture,
-        textureProperty,
-        uvSnippet,
-        levelSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        levelSnippet: string | null,
+        depthSnippet: string | null,
         shaderStage = this.shaderStage,
     ) {
         let snippet = null;
@@ -344,11 +363,11 @@ class WGSLNodeBuilder extends NodeBuilder {
     }
 
     generateTextureBias(
-        texture,
-        textureProperty,
-        uvSnippet,
-        biasSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        biasSnippet: string | null,
+        depthSnippet: string | null,
         shaderStage = this.shaderStage,
     ) {
         if (shaderStage === 'fragment') {
@@ -358,7 +377,7 @@ class WGSLNodeBuilder extends NodeBuilder {
         }
     }
 
-    getPropertyName(node, shaderStage = this.shaderStage) {
+    getPropertyName(node: unknown, shaderStage = this.shaderStage) {
         if (node.isNodeVarying === true && node.needsInterpolation === true) {
             if (shaderStage === 'vertex') {
                 return `varyings.${node.name}`;
@@ -425,7 +444,12 @@ class WGSLNodeBuilder extends NodeBuilder {
         }
     }
 
-    getUniformFromNode(node, type, shaderStage, name = null) {
+    getUniformFromNode(
+        node: UniformNode<unknown>,
+        type: string | null,
+        shaderStage: NodeShaderStage,
+        name: string | null = null,
+    ) {
         const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
@@ -542,7 +566,7 @@ class WGSLNodeBuilder extends NodeBuilder {
         return 'vertexIndex';
     }
 
-    buildFunctionCode(shaderNode) {
+    buildFunctionCode(shaderNode: ShaderNodeInternal) {
         const layout = shaderNode.layout;
         const flowData = this.flowShaderNode(shaderNode);
 
@@ -700,8 +724,8 @@ ${flowData.code}
         return snippets.join('\n');
     }
 
-    getAttributes(shaderStage) {
-        const snippets = [];
+    getAttributes(shaderStage: NodeShaderStage) {
+        const snippets: string[] = [];
 
         if (shaderStage === 'compute') {
             this.getBuiltin('global_invocation_id', 'id', 'vec3<u32>', 'attribute');
@@ -787,8 +811,8 @@ ${flowData.code}
         return `\n${snippets.join('\n')}\n`;
     }
 
-    getVaryings(shaderStage) {
-        const snippets = [];
+    getVaryings(shaderStage: NodeShaderStage) {
+        const snippets: string[] = [];
 
         if (shaderStage === 'vertex') {
             this.getBuiltin('position', 'Vertex', 'vec4<f32>', 'vertex');
@@ -824,7 +848,7 @@ ${flowData.code}
         return shaderStage === 'vertex' ? this._getWGSLStruct('VaryingsStruct', '\t' + code) : code;
     }
 
-    getUniforms(shaderStage) {
+    getUniforms(shaderStage: NodeShaderStage) {
         const uniforms = this.uniforms[shaderStage];
 
         const bindingSnippets = [];
diff --git a/src-testing/src/renderers/webgpu/nodes/WGSLNodeFunction.ts b/src-testing/src/renderers/webgpu/nodes/WGSLNodeFunction.ts
index 33b0d268..626e3cc1 100644
--- a/src-testing/src/renderers/webgpu/nodes/WGSLNodeFunction.ts
+++ b/src-testing/src/renderers/webgpu/nodes/WGSLNodeFunction.ts
@@ -122,7 +122,7 @@ const parse = source => {
 };
 
 class WGSLNodeFunction extends NodeFunction {
-    constructor(source) {
+    constructor(source: string) {
         const { type, inputs, name, inputsCode, blockCode, outputType } = parse(source);
 
         super(type, inputs, name);
diff --git a/src-testing/src/renderers/webgpu/nodes/WGSLNodeParser.ts b/src-testing/src/renderers/webgpu/nodes/WGSLNodeParser.ts
index c32133df..8ac06078 100644
--- a/src-testing/src/renderers/webgpu/nodes/WGSLNodeParser.ts
+++ b/src-testing/src/renderers/webgpu/nodes/WGSLNodeParser.ts
@@ -2,7 +2,7 @@ import NodeParser from '../../../nodes/core/NodeParser.js';
 import WGSLNodeFunction from './WGSLNodeFunction.js';
 
 class WGSLNodeParser extends NodeParser {
-    parseFunction(source) {
+    parseFunction(source: string) {
         return new WGSLNodeFunction(source);
     }
 }
