diff --git a/src-testing/src/materials/nodes/manager/NodeMaterialObserver.ts b/src-testing/src/materials/nodes/manager/NodeMaterialObserver.ts
index 9311024a..96372a10 100644
--- a/src-testing/src/materials/nodes/manager/NodeMaterialObserver.ts
+++ b/src-testing/src/materials/nodes/manager/NodeMaterialObserver.ts
@@ -1,3 +1,14 @@
+import NodeBuilder from '../../../nodes/core/NodeBuilder.js';
+import RenderObject from '../../../renderers/common/RenderObject.js';
+import { Matrix4 } from '../../../math/Matrix4.js';
+import { Material } from '../../Material.js';
+import NodeFrame from '../../../nodes/core/NodeFrame.js';
+import { BufferAttribute } from '../../../core/BufferAttribute.js';
+import Renderer from '../../../renderers/common/Renderer.js';
+import { Light } from '../../../lights/Light.js';
+import { SpotLight } from '../../../lights/SpotLight.js';
+import LightsNode from '../../../nodes/lighting/LightsNode.js';
+
 const refreshUniforms = [
     'alphaMap',
     'alphaTest',
@@ -53,7 +64,38 @@ const refreshUniforms = [
     'thickness',
     'transmission',
     'transmissionMap',
-];
+] as const;
+
+type RefreshUniform = (typeof refreshUniforms)[number];
+
+type MaterialData = {
+    [K in RefreshUniform]?: unknown;
+};
+
+interface AttributesData {
+    [name: string]: { version: number };
+}
+
+interface RenderObjectData {
+    material: MaterialData;
+    geometry: {
+        id: number;
+        attributes: AttributesData;
+        indexVersion: number | null;
+        drawRange: { start: number; count: number };
+    };
+    worldMatrix: Matrix4;
+    version?: number;
+}
+
+interface LightData {
+    map: number;
+}
+
+interface LightsCacheData {
+    renderId: number;
+    lightsData: LightData[];
+}
 
 /**
  * A WeakMap to cache lights data for node materials.
@@ -62,7 +104,7 @@ const refreshUniforms = [
  * @private
  * @type {WeakMap<LightsNode,Object>}
  */
-const _lightsCache = new WeakMap();
+const _lightsCache = new WeakMap<LightsNode, LightsCacheData>();
 
 /**
  * This class is used by {@link WebGPURenderer} as management component.
@@ -70,12 +112,18 @@ const _lightsCache = new WeakMap();
  * refresh right before they are going to be rendered or not.
  */
 class NodeMaterialObserver {
+    renderObjects: WeakMap<RenderObject, RenderObjectData>;
+    hasNode: boolean;
+    hasAnimation: boolean;
+    refreshUniforms: readonly RefreshUniform[];
+    renderId: number;
+
     /**
      * Constructs a new node material observer.
      *
      * @param {NodeBuilder} builder - The node builder.
      */
-    constructor(builder) {
+    constructor(builder: NodeBuilder) {
         /**
          * A node material can be used by more than one render object so the
          * monitor must maintain a list of render objects.
@@ -120,7 +168,7 @@ class NodeMaterialObserver {
      * @param {RenderObject} renderObject - The render object.
      * @return {boolean} Whether the given render object is verified for the first time of this observer.
      */
-    firstInitialization(renderObject) {
+    firstInitialization(renderObject: RenderObject) {
         const hasInitialized = this.renderObjects.has(renderObject);
 
         if (hasInitialized === false) {
@@ -138,7 +186,7 @@ class NodeMaterialObserver {
      * @param {Renderer} renderer - The renderer.
      * @return {boolean} Whether the current rendering produces motion vectors or not.
      */
-    needsVelocity(renderer) {
+    needsVelocity(renderer: Renderer) {
         const mrt = renderer.getMRT();
 
         return mrt !== null && mrt.has('velocity');
@@ -150,7 +198,7 @@ class NodeMaterialObserver {
      * @param {RenderObject} renderObject - The render object.
      * @return {Object} The monitoring data.
      */
-    getRenderObjectData(renderObject) {
+    getRenderObjectData(renderObject: RenderObject) {
         let data = this.renderObjects.get(renderObject);
 
         if (data === undefined) {
@@ -201,8 +249,8 @@ class NodeMaterialObserver {
      * @param {Object} attributes - The geometry attributes.
      * @return {Object} An object for monitoring the versions of attributes.
      */
-    getAttributesData(attributes) {
-        const attributesData = {};
+    getAttributesData(attributes: Record<string, BufferAttribute>) {
+        const attributesData: AttributesData = {};
 
         for (const name in attributes) {
             const attribute = attributes[name];
@@ -222,7 +270,7 @@ class NodeMaterialObserver {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {boolean} Whether the node builder's material uses node properties or not.
      */
-    containsNode(builder) {
+    containsNode(builder: NodeBuilder) {
         const material = builder.material;
 
         for (const property in material) {
@@ -241,8 +289,8 @@ class NodeMaterialObserver {
      * @param {Material} material - The material.
      * @return {Object} An object for monitoring material properties.
      */
-    getMaterialData(material) {
-        const data = {};
+    getMaterialData(material: Material) {
+        const data: MaterialData = {};
 
         for (const property of this.refreshUniforms) {
             const value = material[property];
@@ -270,7 +318,7 @@ class NodeMaterialObserver {
      * @param {Array<Light>} lightsData - The current material lights.
      * @return {boolean} Whether the given render object has changed its state or not.
      */
-    equals(renderObject, lightsData) {
+    equals(renderObject: RenderObject, lightsData: Light[]) {
         const { object, material, geometry } = renderObject;
 
         const renderObjectData = this.getRenderObjectData(renderObject);
@@ -431,14 +479,14 @@ class NodeMaterialObserver {
      * @param {Array<Light>} materialLights - The material lights.
      * @return {Array<Object>} The lights data for the given material lights.
      */
-    getLightsData(materialLights) {
-        const lights = [];
+    getLightsData(materialLights: Light[]) {
+        const lights: LightData[] = [];
 
         for (const light of materialLights) {
-            if (light.isSpotLight === true && light.map !== null) {
+            if ((light as SpotLight).isSpotLight === true && (light as SpotLight).map !== null) {
                 // only add lights that have a map
 
-                lights.push({ map: light.map.version });
+                lights.push({ map: (light as SpotLight).map!.version });
             }
         }
 
@@ -452,9 +500,9 @@ class NodeMaterialObserver {
      * @param {number} renderId - The render ID.
      * @return {Array<Object>} The lights for the given lights node and render ID.
      */
-    getLights(lightsNode, renderId) {
+    getLights(lightsNode: LightsNode, renderId: number) {
         if (_lightsCache.has(lightsNode)) {
-            const cached = _lightsCache.get(lightsNode);
+            const cached = _lightsCache.get(lightsNode)!;
 
             if (cached.renderId === renderId) {
                 return cached.lightsData;
@@ -475,7 +523,7 @@ class NodeMaterialObserver {
      * @param {NodeFrame} nodeFrame - The current node frame.
      * @return {boolean} Whether the given render object requires a refresh or not.
      */
-    needsRefresh(renderObject, nodeFrame) {
+    needsRefresh(renderObject: RenderObject, nodeFrame: NodeFrame) {
         if (
             this.hasNode ||
             this.hasAnimation ||
diff --git a/src-testing/src/nodes/accessors/BufferAttributeNode.ts b/src-testing/src/nodes/accessors/BufferAttributeNode.ts
index 5b4d8aa0..8123d6f9 100644
--- a/src-testing/src/nodes/accessors/BufferAttributeNode.ts
+++ b/src-testing/src/nodes/accessors/BufferAttributeNode.ts
@@ -4,7 +4,12 @@ import { varying } from '../core/VaryingNode.js';
 
 import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
 import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
-import { StaticDrawUsage, DynamicDrawUsage } from '../../constants.js';
+import { StaticDrawUsage, DynamicDrawUsage, Usage } from '../../constants.js';
+import { BufferAttribute, TypedArray } from '../../core/BufferAttribute.js';
+import { InstancedBufferAttribute } from '../../core/InstancedBufferAttribute.js';
+import NodeBuilder from '../core/NodeBuilder.js';
+import BufferNode from './BufferNode.js';
+import Node from '../core/Node.js';
 
 /**
  * Internal buffer attribute library.
@@ -12,7 +17,7 @@ import { StaticDrawUsage, DynamicDrawUsage } from '../../constants.js';
  * @private
  * @type {WeakMap<TypedArray, InterleavedBuffer>}
  */
-const _bufferLib = new WeakMap();
+const _bufferLib = new WeakMap<TypedArray, InterleavedBuffer>();
 
 /**
  * Internal method for retrieving or creating interleaved buffers.
@@ -22,7 +27,7 @@ const _bufferLib = new WeakMap();
  * @param {number} itemSize - The attribute item size.
  * @returns {InterleavedBuffer} The interleaved buffer.
  */
-function _getBufferAttribute(value, itemSize) {
+function _getBufferAttribute(value: TypedArray, itemSize: number) {
     let buffer = _bufferLib.get(value);
 
     if (buffer === undefined) {
@@ -56,11 +61,22 @@ function _getBufferAttribute(value, itemSize) {
  * ```
  * @augments InputNode
  */
-class BufferAttributeNode extends InputNode {
+class BufferAttributeNodeClass extends InputNode<unknown, TypedArray | InterleavedBuffer | BufferAttribute> {
     static get type() {
         return 'BufferAttributeNode';
     }
 
+    readonly isBufferNode: true;
+
+    bufferType: string | null;
+    bufferStride: number;
+    bufferOffset: number;
+
+    usage: Usage;
+    instanced: boolean;
+
+    attribute: BufferAttribute | InterleavedBufferAttribute | null;
+
     /**
      * Constructs a new buffer attribute node.
      *
@@ -69,7 +85,12 @@ class BufferAttributeNode extends InputNode {
      * @param {number} [bufferStride=0] - The buffer stride.
      * @param {number} [bufferOffset=0] - The buffer offset.
      */
-    constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
+    constructor(
+        value: TypedArray | InterleavedBuffer | BufferAttribute,
+        bufferType: string | null = null,
+        bufferStride = 0,
+        bufferOffset = 0,
+    ) {
         super(value, bufferType);
 
         /**
@@ -138,10 +159,10 @@ class BufferAttributeNode extends InputNode {
          */
         this.global = true;
 
-        if (value && value.isBufferAttribute === true && value.itemSize <= 4) {
-            this.attribute = value;
-            this.usage = value.usage;
-            this.instanced = value.isInstancedBufferAttribute;
+        if (value && (value as BufferAttribute).isBufferAttribute === true && value.itemSize <= 4) {
+            this.attribute = value as BufferAttribute;
+            this.usage = (value as BufferAttribute).usage;
+            this.instanced = (value as InstancedBufferAttribute).isInstancedBufferAttribute;
         }
     }
 
@@ -152,7 +173,7 @@ class BufferAttributeNode extends InputNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The hash.
      */
-    getHash(builder) {
+    getHash(builder: NodeBuilder) {
         if (this.bufferStride === 0 && this.bufferOffset === 0) {
             let bufferData = builder.globalCache.getData(this.value);
 
@@ -177,7 +198,7 @@ class BufferAttributeNode extends InputNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The node type.
      */
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         if (this.bufferType === null) {
             this.bufferType = builder.getTypeFromAttribute(this.attribute);
         }
@@ -192,7 +213,7 @@ class BufferAttributeNode extends InputNode {
      *
      * @param {NodeBuilder} builder - The current node builder.
      */
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         if (this.attribute !== null) return;
 
         //
@@ -203,14 +224,14 @@ class BufferAttributeNode extends InputNode {
         const stride = this.bufferStride || itemSize;
         const offset = this.bufferOffset;
 
-        let buffer;
+        let buffer: InterleavedBuffer;
 
-        if (value.isInterleavedBuffer === true) {
-            buffer = value;
-        } else if (value.isBufferAttribute === true) {
-            buffer = _getBufferAttribute(value.array, stride);
+        if ((value as InterleavedBuffer).isInterleavedBuffer === true) {
+            buffer = value as InterleavedBuffer;
+        } else if ((value as BufferAttribute).isBufferAttribute === true) {
+            buffer = _getBufferAttribute((value as BufferAttribute).array, stride);
         } else {
-            buffer = _getBufferAttribute(value, stride);
+            buffer = _getBufferAttribute(value as TypedArray, stride);
         }
 
         const bufferAttribute = new InterleavedBufferAttribute(buffer, itemSize, offset);
@@ -227,13 +248,13 @@ class BufferAttributeNode extends InputNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The generated code snippet.
      */
-    generate(builder) {
+    generate(builder: NodeBuilder) {
         const nodeType = this.getNodeType(builder);
 
         const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);
         const propertyName = builder.getPropertyName(nodeAttribute);
 
-        let output = null;
+        let output: string | null | undefined = null;
 
         if (builder.shaderStage === 'vertex' || builder.shaderStage === 'compute') {
             this.name = propertyName;
@@ -264,11 +285,11 @@ class BufferAttributeNode extends InputNode {
      * @param {number} value - The usage to set.
      * @return {BufferAttributeNode} A reference to this node.
      */
-    setUsage(value) {
+    setUsage(value: Usage) {
         this.usage = value;
 
-        if (this.attribute && this.attribute.isBufferAttribute === true) {
-            this.attribute.usage = value;
+        if (this.attribute && (this.attribute as BufferAttribute).isBufferAttribute === true) {
+            (this.attribute as BufferAttribute).usage = value;
         }
 
         return this;
@@ -280,12 +301,31 @@ class BufferAttributeNode extends InputNode {
      * @param {boolean} value - The value to set.
      * @return {BufferAttributeNode} A reference to this node.
      */
-    setInstanced(value) {
+    setInstanced(value: boolean) {
         this.instanced = value;
 
         return this;
     }
 }
+declare const BufferAttributeNode: {
+    /**
+     * Constructs a new buffer attribute node.
+     *
+     * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.
+     * @param {?string} [bufferType=null] - The buffer type (e.g. `'vec3'`).
+     * @param {number} [bufferStride=0] - The buffer stride.
+     * @param {number} [bufferOffset=0] - The buffer offset.
+     */
+    new <TNodeType>(
+        value: TypedArray | InterleavedBuffer | BufferAttribute,
+        bufferType?: string | null,
+        bufferStride?: number,
+        bufferOffset?: number,
+    ): BufferAttributeNode<TNodeType>;
+};
+
+type BufferAttributeNode<TNodeType> = InputNode<TNodeType, TypedArray | InterleavedBuffer | BufferAttribute> &
+    BufferAttributeNodeClass;
 
 export default BufferAttributeNode;
 
@@ -301,7 +341,14 @@ export default BufferAttributeNode;
  * @param {boolean} [instanced=false] - Whether the buffer is instanced.
  * @returns {BufferAttributeNode|Node} The buffer attribute node.
  */
-function createBufferAttribute(array, type = null, stride = 0, offset = 0, usage = StaticDrawUsage, instanced = false) {
+function createBufferAttribute<TNodeType>(
+    array: BufferAttribute | InterleavedBuffer | TypedArray,
+    type: string | null = null,
+    stride: number = 0,
+    offset: number = 0,
+    usage: Usage = StaticDrawUsage,
+    instanced = false,
+): Node<TNodeType> {
     if (type === 'mat3' || (type === null && array.itemSize === 9)) {
         return mat3(
             new BufferAttributeNode(array, 'vec3', 9, 0).setUsage(usage).setInstanced(instanced),
@@ -331,8 +378,12 @@ function createBufferAttribute(array, type = null, stride = 0, offset = 0, usage
  * @param {number} [offset=0] - The buffer offset.
  * @returns {BufferAttributeNode|Node}
  */
-export const bufferAttribute = (array, type = null, stride = 0, offset = 0) =>
-    createBufferAttribute(array, type, stride, offset);
+export const bufferAttribute = <TNodeType>(
+    array: BufferAttribute | InterleavedBuffer | TypedArray,
+    type: string | null = null,
+    stride: number = 0,
+    offset: number = 0,
+): Node<TNodeType> => createBufferAttribute<TNodeType>(array, type, stride, offset);
 
 /**
  * TSL function for creating a buffer attribute node but with dynamic draw usage.
@@ -346,8 +397,12 @@ export const bufferAttribute = (array, type = null, stride = 0, offset = 0) =>
  * @param {number} [offset=0] - The buffer offset.
  * @returns {BufferAttributeNode|Node}
  */
-export const dynamicBufferAttribute = (array, type = null, stride = 0, offset = 0) =>
-    createBufferAttribute(array, type, stride, offset, DynamicDrawUsage);
+export const dynamicBufferAttribute = <TNodeType>(
+    array: BufferAttribute | InterleavedBuffer | TypedArray,
+    type: string | null = null,
+    stride: number = 0,
+    offset: number = 0,
+): Node<TNodeType> => createBufferAttribute<TNodeType>(array, type, stride, offset, DynamicDrawUsage);
 
 /**
  * TSL function for creating a buffer attribute node but with enabled instancing
@@ -360,8 +415,12 @@ export const dynamicBufferAttribute = (array, type = null, stride = 0, offset =
  * @param {number} [offset=0] - The buffer offset.
  * @returns {BufferAttributeNode|Node}
  */
-export const instancedBufferAttribute = (array, type = null, stride = 0, offset = 0) =>
-    createBufferAttribute(array, type, stride, offset, StaticDrawUsage, true);
+export const instancedBufferAttribute = <TNodeType>(
+    array: BufferAttribute | InterleavedBuffer | TypedArray,
+    type: string | null = null,
+    stride: number = 0,
+    offset: number = 0,
+): Node<TNodeType> => createBufferAttribute<TNodeType>(array, type, stride, offset, StaticDrawUsage, true);
 
 /**
  * TSL function for creating a buffer attribute node but with dynamic draw usage and enabled instancing
@@ -374,7 +433,20 @@ export const instancedBufferAttribute = (array, type = null, stride = 0, offset
  * @param {number} [offset=0] - The buffer offset.
  * @returns {BufferAttributeNode|Node}
  */
-export const instancedDynamicBufferAttribute = (array, type = null, stride = 0, offset = 0) =>
-    createBufferAttribute(array, type, stride, offset, DynamicDrawUsage, true);
-
-addMethodChaining('toAttribute', bufferNode => bufferAttribute(bufferNode.value));
+export const instancedDynamicBufferAttribute = <TNodeType>(
+    array: BufferAttribute | InterleavedBuffer | TypedArray,
+    type: string | null = null,
+    stride: number = 0,
+    offset: number = 0,
+): Node<TNodeType> => createBufferAttribute<TNodeType>(array, type, stride, offset, DynamicDrawUsage, true);
+
+addMethodChaining('toAttribute', <TNodeType, TValue>(bufferNode: BufferNode<TNodeType, TValue>) =>
+    bufferAttribute(bufferNode.value),
+);
+
+declare module './BufferNode.js' {
+    interface BufferNodeExtensions<TNodeType, TValue> {
+        toAttribute: () => BufferAttributeNode<TNodeType>;
+        toAttributeAssign: () => this;
+    }
+}
diff --git a/src-testing/src/nodes/accessors/TextureNode.ts b/src-testing/src/nodes/accessors/TextureNode.ts
index cfb15fb4..505088da 100644
--- a/src-testing/src/nodes/accessors/TextureNode.ts
+++ b/src-testing/src/nodes/accessors/TextureNode.ts
@@ -11,6 +11,10 @@ import { IntType, NearestFilter, UnsignedIntType } from '../../constants.js';
 
 import { Texture } from '../../textures/Texture.js';
 import { warn } from '../../utils.js';
+import Node from '../core/Node.js';
+import { DepthTexture } from '../../textures/DepthTexture.js';
+import NodeBuilder from '../core/NodeBuilder.js';
+import { Matrix3 } from '../../math/Matrix3.js';
 
 const EmptyTexture = /*@__PURE__*/ new Texture();
 
@@ -19,11 +23,28 @@ const EmptyTexture = /*@__PURE__*/ new Texture();
  *
  * @augments UniformNode
  */
-class TextureNode extends UniformNode {
+class TextureNode extends UniformNode<Texture> {
     static get type() {
         return 'TextureNode';
     }
 
+    readonly isTextureNode: true;
+
+    uvNode: Node | null;
+    levelNode: Node | null;
+    biasNode: Node | null;
+    compareNode: Node | null;
+    depthNode: Node | null;
+    gradNode: Node | null;
+
+    sampler: boolean;
+    updateMatrix: boolean;
+
+    referenceNode: this | null;
+
+    _value: Texture;
+    _matrixUniform: UniformNode<Matrix3> | null;
+
     /**
      * Constructs a new texture node.
      *
@@ -32,7 +53,12 @@ class TextureNode extends UniformNode {
      * @param {?Node<int>} [levelNode=null] - The level node.
      * @param {?Node<float>} [biasNode=null] - The bias node.
      */
-    constructor(value = EmptyTexture, uvNode = null, levelNode = null, biasNode = null) {
+    constructor(
+        value: Texture = EmptyTexture,
+        uvNode: Node | null = null,
+        levelNode: Node | null = null,
+        biasNode: Node | null = null,
+    ) {
         super(value);
 
         /**
@@ -166,7 +192,7 @@ class TextureNode extends UniformNode {
         this.setUpdateMatrix(uvNode === null);
     }
 
-    set value(value) {
+    set value(value: Texture) {
         if (this.referenceNode) {
             this.referenceNode.value = value;
         } else {
@@ -200,7 +226,7 @@ class TextureNode extends UniformNode {
      * @return {string} The node type.
      */
     getNodeType(/*builder*/) {
-        if (this.value.isDepthTexture === true) return 'float';
+        if ((this.value as DepthTexture).isDepthTexture === true) return 'float';
 
         if (this.value.type === UnsignedIntType) {
             return 'uvec4';
@@ -258,7 +284,7 @@ class TextureNode extends UniformNode {
      * @param {boolean} value - The update toggle.
      * @return {TextureNode} A reference to this node.
      */
-    setUpdateMatrix(value) {
+    setUpdateMatrix(value: boolean) {
         this.updateMatrix = value;
 
         return this;
@@ -272,7 +298,7 @@ class TextureNode extends UniformNode {
      * @param {Node} uvNode - The uv node to setup.
      * @return {Node} The updated uv node.
      */
-    setupUV(builder, uvNode) {
+    setupUV(builder: NodeBuilder, uvNode) {
         if (builder.isFlipY()) {
             if (this._flipYUniform === null) this._flipYUniform = uniform(false);
 
@@ -296,7 +322,7 @@ class TextureNode extends UniformNode {
      *
      * @param {NodeBuilder} builder - The current node builder.
      */
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         const properties = builder.getNodeProperties(this);
         properties.referenceNode = this.referenceNode;
 
@@ -363,7 +389,7 @@ class TextureNode extends UniformNode {
      * @param {Node} uvNode - The uv node to generate code for.
      * @return {string} The generated code snippet.
      */
-    generateUV(builder, uvNode) {
+    generateUV(builder: NodeBuilder, uvNode: Node) {
         return uvNode.build(builder, this.sampler === true ? 'vec2' : 'ivec2');
     }
 
@@ -393,14 +419,14 @@ class TextureNode extends UniformNode {
      * @return {string} The generated code snippet.
      */
     generateSnippet(
-        builder,
-        textureProperty,
-        uvSnippet,
-        levelSnippet,
-        biasSnippet,
-        depthSnippet,
-        compareSnippet,
-        gradSnippet,
+        builder: NodeBuilder,
+        textureProperty: string,
+        uvSnippet: string | null,
+        levelSnippet: string | null,
+        biasSnippet: string | null,
+        depthSnippet: string | null,
+        compareSnippet: string | null,
+        gradSnippet: [string, string] | null,
         offsetSnippet,
     ) {
         const texture = this.value;
@@ -466,9 +492,8 @@ class TextureNode extends UniformNode {
      * @param {string} output - The current output.
      * @return {string} The generated code snippet.
      */
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output) {
         const texture = this.value;
-
         const properties = builder.getNodeProperties(this);
         const textureProperty = super.generate(builder, 'property');
 
@@ -535,7 +560,7 @@ class TextureNode extends UniformNode {
      * @param {boolean} value - The sampler value to set.
      * @return {TextureNode} A reference to this texture node.
      */
-    setSampler(value) {
+    setSampler(value: boolean) {
         this.sampler = value;
 
         return this;
@@ -559,7 +584,7 @@ class TextureNode extends UniformNode {
      * @param {Node} uvNode - The uv node.
      * @return {TextureNode} A texture node representing the texture sample.
      */
-    uv(uvNode) {
+    uv(uvNode: Node | null) {
         // @deprecated, r172
 
         warn('TextureNode: .uv() has been renamed. Use .sample() instead.');
@@ -597,7 +622,7 @@ class TextureNode extends UniformNode {
      * @param {Node<float>} amountNode - How blurred the texture should be.
      * @return {TextureNode} A texture node representing the texture sample.
      */
-    blur(amountNode) {
+    blur(amountNode: Node) {
         const textureNode = this.clone();
         textureNode.biasNode = nodeObject(amountNode).mul(maxMipLevel(textureNode));
         textureNode.referenceNode = this.getBase();
@@ -626,7 +651,7 @@ class TextureNode extends UniformNode {
      * @param {Node<int>} levelNode - The mip level to sample.
      * @return {TextureNode} A texture node representing the texture sample.
      */
-    level(levelNode) {
+    level(levelNode: Node | null) {
         const textureNode = this.clone();
         textureNode.levelNode = nodeObject(levelNode);
         textureNode.referenceNode = this.getBase();
diff --git a/src-testing/src/nodes/code/CodeNode.ts b/src-testing/src/nodes/code/CodeNode.ts
index 382d5107..efe92e0c 100644
--- a/src-testing/src/nodes/code/CodeNode.ts
+++ b/src-testing/src/nodes/code/CodeNode.ts
@@ -1,5 +1,6 @@
 import Node from '../core/Node.js';
 import { nodeProxy } from '../tsl/TSLBase.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 /**
  * This class represents native code sections. It is the base
@@ -13,6 +14,11 @@ class CodeNode extends Node {
         return 'CodeNode';
     }
 
+    readonly isCodeNode: true;
+
+    code: string;
+    language: string;
+
     /**
      * Constructs a new code node.
      *
@@ -83,11 +89,11 @@ class CodeNode extends Node {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {Array<Node>} The includes.
      */
-    getIncludes(/*builder*/) {
+    getIncludes(builder: NodeBuilder) {
         return this.includes;
     }
 
-    generate(builder) {
+    generate(builder: NodeBuilder) {
         const includes = this.getIncludes(builder);
 
         for (const include of includes) {
diff --git a/src-testing/src/nodes/code/FunctionNode.ts b/src-testing/src/nodes/code/FunctionNode.ts
index 0174f78c..34d4475c 100644
--- a/src-testing/src/nodes/code/FunctionNode.ts
+++ b/src-testing/src/nodes/code/FunctionNode.ts
@@ -1,5 +1,6 @@
 import CodeNode from './CodeNode.js';
 import { nodeObject } from '../tsl/TSLBase.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 /**
  * This class represents a native shader function. It can be used to implement
@@ -49,7 +50,7 @@ class FunctionNode extends CodeNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The type.
      */
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.getNodeFunction(builder).type;
     }
 
@@ -74,7 +75,7 @@ class FunctionNode extends CodeNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {Array<NodeFunctionInput>} The inputs.
      */
-    getInputs(builder) {
+    getInputs(builder: NodeBuilder) {
         return this.getNodeFunction(builder).inputs;
     }
 
@@ -84,7 +85,7 @@ class FunctionNode extends CodeNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {NodeFunction} The node function.
      */
-    getNodeFunction(builder) {
+    getNodeFunction(builder: NodeBuilder) {
         const nodeData = builder.getDataFromNode(this);
 
         let nodeFunction = nodeData.nodeFunction;
@@ -98,7 +99,7 @@ class FunctionNode extends CodeNode {
         return nodeFunction;
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null) {
         super.generate(builder);
 
         const nodeFunction = this.getNodeFunction(builder);
@@ -130,7 +131,7 @@ class FunctionNode extends CodeNode {
 
 export default FunctionNode;
 
-const nativeFn = (code, includes = [], language = '') => {
+const nativeFn = (code: string, includes = [], language = '') => {
     for (let i = 0; i < includes.length; i++) {
         const include = includes[i];
 
@@ -149,5 +150,5 @@ const nativeFn = (code, includes = [], language = '') => {
     return fn;
 };
 
-export const glslFn = (code, includes) => nativeFn(code, includes, 'glsl');
-export const wgslFn = (code, includes) => nativeFn(code, includes, 'wgsl');
+export const glslFn = (code: string, includes) => nativeFn(code, includes, 'glsl');
+export const wgslFn = (code: string, includes) => nativeFn(code, includes, 'wgsl');
diff --git a/src-testing/src/nodes/core/ContextNode.ts b/src-testing/src/nodes/core/ContextNode.ts
index 276f280f..6d67a0e9 100644
--- a/src-testing/src/nodes/core/ContextNode.ts
+++ b/src-testing/src/nodes/core/ContextNode.ts
@@ -1,6 +1,7 @@
 import Node from './Node.js';
 import { addMethodChaining } from '../tsl/TSLCore.js';
 import { warn } from '../../utils.js';
+import NodeBuilder from './NodeBuilder.js';
 
 /**
  * This node can be used as a context management component for another node.
@@ -18,18 +19,23 @@ import { warn } from '../../utils.js';
  *```
  * @augments Node
  */
-class ContextNode extends Node {
+class ContextNode<TContext> extends Node {
     static get type() {
         return 'ContextNode';
     }
 
+    readonly isContextNode: true;
+
+    node: Node | null;
+    value: TContext;
+
     /**
      * Constructs a new context node.
      *
      * @param {Node} node - The node whose context should be modified.
      * @param {Object} [value={}] - The modified context data.
      */
-    constructor(node = null, value = {}) {
+    constructor(node: Node | null = null, value: TContext = {} as TContext) {
         super();
 
         /**
@@ -72,7 +78,7 @@ class ContextNode extends Node {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The node type.
      */
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.node.getNodeType(builder);
     }
 
@@ -104,15 +110,14 @@ class ContextNode extends Node {
         return this.node.getMemberType(builder, name);
     }
 
-    analyze(builder) {
+    analyze(builder: NodeBuilder) {
         const previousContext = builder.addContext(this.value);
-
         this.node.build(builder);
 
         builder.setContext(previousContext);
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         const previousContext = builder.addContext(this.value);
 
         this.node.build(builder);
@@ -120,7 +125,7 @@ class ContextNode extends Node {
         builder.setContext(previousContext);
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null) {
         const previousContext = builder.addContext(this.value);
 
         const snippet = this.node.build(builder, output);
@@ -184,7 +189,7 @@ export const setName = (node, name) => context(node, { nodeName: name });
  * @param {string} name - The name/label to set.
  * @returns {ContextNode}
  */
-export function label(node, name) {
+export function label(node: Node, name: string) {
     warn('TSL: "label()" has been deprecated. Use "setName()" instead.'); // @deprecated r179
 
     return setName(node, name);
diff --git a/src-testing/src/nodes/core/InputNode.ts b/src-testing/src/nodes/core/InputNode.ts
index ffb7734e..2dc76d1c 100644
--- a/src-testing/src/nodes/core/InputNode.ts
+++ b/src-testing/src/nodes/core/InputNode.ts
@@ -1,24 +1,30 @@
 import Node from './Node.js';
 import { getValueType, getValueFromType, arrayBufferToBase64 } from './NodeUtils.js';
 import { warn } from '../../utils.js';
+import NodeBuilder from './NodeBuilder.js';
 
 /**
  * Base class for representing data input nodes.
  *
  * @augments Node
  */
-class InputNode extends Node {
+class InputNodeClass<TValue> extends Node {
     static get type() {
         return 'InputNode';
     }
 
+    readonly isInputNode: true;
+
+    value: TValue;
+    precision: 'low' | 'medium' | 'high' | null;
+
     /**
      * Constructs a new input node.
      *
      * @param {any} value - The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
      * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
      */
-    constructor(value, nodeType = null) {
+    constructor(value: TValue, nodeType: string | null = null) {
         super(nodeType);
 
         /**
@@ -46,7 +52,7 @@ class InputNode extends Node {
         this.precision = null;
     }
 
-    getNodeType(/*builder*/) {
+    getNodeType(builder: NodeBuilder) {
         if (this.nodeType === null) {
             return getValueType(this.value);
         }
@@ -64,7 +70,7 @@ class InputNode extends Node {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The input type.
      */
-    getInputType(builder) {
+    getInputType(builder: NodeBuilder) {
         return this.getNodeType(builder);
     }
 
@@ -76,7 +82,7 @@ class InputNode extends Node {
      * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.
      * @return {InputNode} A reference to this node.
      */
-    setPrecision(precision) {
+    setPrecision(precision: 'low' | 'medium' | 'high' | null) {
         this.precision = precision;
 
         return this;
@@ -107,10 +113,12 @@ class InputNode extends Node {
 
         if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);
     }
-
-    generate(/*builder, output*/) {
-        warn('Abstract function.');
-    }
 }
 
+declare const InputNode: {
+    new <TNodeType, TValue>(value: TValue, nodeType?: string | null): InputNode<TNodeType, TValue>;
+};
+
+type InputNode<TNodeType, TValue> = Node<TNodeType> & InputNodeClass<TValue>;
+
 export default InputNode;
diff --git a/src-testing/src/nodes/core/Node.ts b/src-testing/src/nodes/core/Node.ts
index 335f0bf3..33524b69 100644
--- a/src-testing/src/nodes/core/Node.ts
+++ b/src-testing/src/nodes/core/Node.ts
@@ -4,6 +4,8 @@ import { hash, hashArray, hashString } from './NodeUtils.js';
 import { EventDispatcher } from '../../core/EventDispatcher.js';
 import { MathUtils } from '../../math/MathUtils.js';
 import { warn, error } from '../../utils.js';
+import NodeFrame from './NodeFrame.js';
+import NodeBuilder from './NodeBuilder.js';
 
 const _parentBuildStage = {
     analyze: 'setup',
@@ -12,22 +14,108 @@ const _parentBuildStage = {
 
 let _nodeId = 0;
 
+interface NodeConstructor {
+    type?: string;
+}
+
+export interface NodeJSONMeta {
+    textures: { [key: string]: unknown };
+    images: { [key: string]: unknown };
+    nodes: { [key: string]: NodeJSONIntermediateOutputData };
+}
+
+export interface NodeJSONMetadata {
+    version: number;
+    type: 'Node';
+    generator: 'Node.toJSON';
+}
+
+interface NodeJSONInputNodes {
+    [property: string]:
+        | string[]
+        | {
+              [index: string]: string | undefined;
+          }
+        | string
+        | undefined;
+}
+
+export interface NodeJSONInputData {
+    inputNodes?: NodeJSONInputNodes | undefined;
+    meta: {
+        textures: { [key: string]: unknown };
+        nodes: { [key: string]: Node };
+    };
+}
+
+export interface NodeJSONIntermediateOutputData {
+    uuid: string;
+    type: string | undefined;
+    meta?: NodeJSONMeta | undefined;
+    metadata?: NodeJSONMetadata;
+    inputNodes?: NodeJSONInputNodes | undefined;
+    textures?: unknown[];
+    images?: unknown[];
+    nodes?: NodeJSONIntermediateOutputData[];
+}
+
+interface NodeJSONOutputData {
+    uuid: string;
+    type: string | undefined;
+    metadata?: NodeJSONMetadata;
+    inputNodes?: NodeJSONInputNodes | undefined;
+    textures?: unknown[];
+    images?: unknown[];
+    nodes?: NodeJSONOutputData[];
+}
+
+export interface NodeChild {
+    property: string;
+    index?: number | string;
+    childNode: Node;
+}
+
 /**
  * Base class for all nodes.
  *
  * @augments EventDispatcher
  */
-class Node extends EventDispatcher {
+class NodeClass extends EventDispatcher<{ dispose: {} }> {
     static get type() {
         return 'Node';
     }
 
+    nodeType: string | null;
+
+    updateType: NodeUpdateType;
+    updateBeforeType: NodeUpdateType;
+    updateAfterType: NodeUpdateType;
+
+    uuid: string;
+
+    version: number;
+
+    name: string | null;
+
+    _cacheKey: number | null;
+    _cacheKeyVersion: number;
+
+    global: boolean;
+
+    parents: boolean;
+
+    readonly isNode: true;
+
+    readonly id!: number;
+
+    self?: this;
+
     /**
      * Constructs a new node.
      *
      * @param {?string} nodeType - The node type.
      */
-    constructor(nodeType = null) {
+    constructor(nodeType: string | null = null) {
         super();
 
         /**
@@ -146,7 +234,7 @@ class Node extends EventDispatcher {
      * @default false
      * @param {boolean} value
      */
-    set needsUpdate(value) {
+    set needsUpdate(value: boolean) {
         if (value === true) {
             this.version++;
         }
@@ -159,7 +247,7 @@ class Node extends EventDispatcher {
      * @readonly
      */
     get type() {
-        return this.constructor.type;
+        return (this.constructor as NodeConstructor).type;
     }
 
     /**
@@ -169,7 +257,7 @@ class Node extends EventDispatcher {
      * @param {string} updateType - The update type.
      * @return {Node} A reference to this node.
      */
-    onUpdate(callback, updateType) {
+    onUpdate(callback: (this: this, frame: NodeFrame) => unknown, updateType: NodeUpdateType) {
         this.updateType = updateType;
         this.update = callback.bind(this);
 
@@ -183,7 +271,7 @@ class Node extends EventDispatcher {
      * @param {Function} callback - The update method.
      * @return {Node} A reference to this node.
      */
-    onFrameUpdate(callback) {
+    onFrameUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.FRAME);
     }
 
@@ -194,7 +282,7 @@ class Node extends EventDispatcher {
      * @param {Function} callback - The update method.
      * @return {Node} A reference to this node.
      */
-    onRenderUpdate(callback) {
+    onRenderUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.RENDER);
     }
 
@@ -205,7 +293,7 @@ class Node extends EventDispatcher {
      * @param {Function} callback - The update method.
      * @return {Node} A reference to this node.
      */
-    onObjectUpdate(callback) {
+    onObjectUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.OBJECT);
     }
 
@@ -215,7 +303,7 @@ class Node extends EventDispatcher {
      * @param {Function} callback - The update method.
      * @return {Node} A reference to this node.
      */
-    onReference(callback) {
+    onReference(callback: (this: this, frame: NodeBuilder | NodeFrame) => unknown) {
         this.updateReference = callback.bind(this);
 
         return this;
@@ -228,7 +316,7 @@ class Node extends EventDispatcher {
      * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
      * @return {any} The updated reference.
      */
-    updateReference(/*state*/) {
+    updateReference(state: NodeBuilder | NodeFrame): unknown {
         return this;
     }
 
@@ -240,7 +328,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {boolean} Whether this node is global or not.
      */
-    isGlobal(/*builder*/) {
+    isGlobal(builder: NodeBuilder) {
         return this.global;
     }
 
@@ -276,7 +364,7 @@ class Node extends EventDispatcher {
      *
      * @param {traverseCallback} callback - A callback that is executed per node.
      */
-    traverse(callback) {
+    traverse(callback: (node: Node) => void) {
         callback(this);
 
         for (const childNode of this.getChildren()) {
@@ -291,7 +379,7 @@ class Node extends EventDispatcher {
      * @param {Set<Node>} [ignores=new Set()] - A set of nodes to ignore during the search to avoid circular references.
      * @returns {Array<Object>} An array of objects describing the child nodes.
      */
-    _getChildren(ignores = new Set()) {
+    _getChildren(ignores: Set<Node> = new Set()): NodeChild[] {
         const children = [];
 
         // avoid circular references
@@ -339,7 +427,7 @@ class Node extends EventDispatcher {
      * @param {Set<Node>} [ignores=null] - A set of nodes to ignore during the computation of the cache key.
      * @return {number} The cache key of the node.
      */
-    getCacheKey(force = false, ignores = null) {
+    getCacheKey(force = false, ignores: Set<Node> | null = null) {
         force = force || this.version !== this._cacheKeyVersion;
 
         if (force === true || this._cacheKey === null) {
@@ -388,7 +476,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The hash.
      */
-    getHash(/*builder*/) {
+    getHash(builder: NodeBuilder) {
         return this.uuid;
     }
 
@@ -427,7 +515,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The type of the node.
      */
-    getElementType(builder) {
+    getElementType(builder: NodeBuilder) {
         const type = this.getNodeType(builder);
         const elementType = builder.getElementType(type);
 
@@ -441,7 +529,7 @@ class Node extends EventDispatcher {
      * @param {string} name - The name of the member.
      * @return {string} The type of the node.
      */
-    getMemberType(/*builder, name*/) {
+    getMemberType(builder: NodeBuilder, name: string) {
         return 'void';
     }
 
@@ -451,7 +539,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The type of the node.
      */
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder): string | null {
         const nodeProperties = builder.getNodeProperties(this);
 
         if (nodeProperties.outputNode) {
@@ -470,7 +558,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {Node} The shared node if possible. Otherwise `this` is returned.
      */
-    getShared(builder) {
+    getShared(builder: NodeBuilder) {
         const hash = this.getHash(builder);
         const nodeFromHash = builder.getNodeFromHash(hash);
 
@@ -483,7 +571,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {?number} The number of elements in the node array.
      */
-    getArrayCount(/*builder*/) {
+    getArrayCount(builder: NodeBuilder): number | null {
         return null;
     }
 
@@ -495,13 +583,13 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {?Node} The output node.
      */
-    setup(builder) {
+    setup(builder: NodeBuilder): unknown {
         const nodeProperties = builder.getNodeProperties(this);
 
         let index = 0;
 
         for (const childNode of this.getChildren()) {
-            nodeProperties['node' + index++] = childNode;
+            nodeProperties[`node${index++}`] = childNode;
         }
 
         // return a outputNode if exists or null
@@ -516,7 +604,7 @@ class Node extends EventDispatcher {
      * @param {NodeBuilder} builder - The current node builder.
      * @param {?Node} output - The target output node.
      */
-    analyze(builder, output = null) {
+    analyze(builder: NodeBuilder, output: Node | null = null) {
         const usageCount = builder.increaseUsage(this);
 
         if (this.parents === true) {
@@ -532,8 +620,8 @@ class Node extends EventDispatcher {
             const nodeProperties = builder.getNodeProperties(this);
 
             for (const childNode of Object.values(nodeProperties)) {
-                if (childNode && childNode.isNode === true) {
-                    childNode.build(builder, this);
+                if (childNode && (childNode as Node).isNode === true) {
+                    (childNode as Node).build(builder, this);
                 }
             }
         }
@@ -547,7 +635,7 @@ class Node extends EventDispatcher {
      * @param {?string} [output] - Can be used to define the output type.
      * @return {?string} The generated shader string.
      */
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null): string | null | undefined {
         const { outputNode } = builder.getNodeProperties(this);
 
         if (outputNode && outputNode.isNode === true) {
@@ -563,7 +651,7 @@ class Node extends EventDispatcher {
      * @param {NodeFrame} frame - A reference to the current node frame.
      * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
      */
-    updateBefore(/*frame*/) {
+    updateBefore(frame: NodeFrame) {
         warn('Abstract function.');
     }
 
@@ -575,7 +663,7 @@ class Node extends EventDispatcher {
      * @param {NodeFrame} frame - A reference to the current node frame.
      * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
      */
-    updateAfter(/*frame*/) {
+    updateAfter(frame: NodeFrame) {
         warn('Abstract function.');
     }
 
@@ -587,11 +675,11 @@ class Node extends EventDispatcher {
      * @param {NodeFrame} frame - A reference to the current node frame.
      * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
      */
-    update(/*frame*/) {
+    update(frame: NodeFrame) {
         warn('Abstract function.');
     }
 
-    before(node) {
+    before(node: Node) {
         if (this._beforeNodes === null) this._beforeNodes = [];
 
         this._beforeNodes.push(node);
@@ -609,7 +697,7 @@ class Node extends EventDispatcher {
      * @param {?(string|Node)} [output=null] - Can be used to define the output type.
      * @return {?(Node|string)} The result of the build process, depending on the build stage.
      */
-    build(builder, output = null) {
+    build(builder: NodeBuilder, output: string | Node | null = null): Node | string | null {
         const refNode = this.getShared(builder);
 
         if (this !== refNode) {
@@ -683,14 +771,14 @@ class Node extends EventDispatcher {
 				}*/
 
                 for (const childNode of Object.values(properties)) {
-                    if (childNode && childNode.isNode === true) {
-                        if (childNode.parents === true) {
-                            const childProperties = builder.getNodeProperties(childNode);
+                    if (childNode && (childNode as Node).isNode === true) {
+                        if ((childNode as Node).parents === true) {
+                            const childProperties = builder.getNodeProperties(childNode as Node);
                             childProperties.parents = childProperties.parents || [];
                             childProperties.parents.push(this);
                         }
 
-                        childNode.build(builder);
+                        (childNode as Node).build(builder);
                     }
                 }
             }
@@ -762,10 +850,10 @@ class Node extends EventDispatcher {
      *
      * @param {Object} json - The output JSON object.
      */
-    serialize(json) {
+    serialize(json: NodeJSONIntermediateOutputData) {
         const nodeChildren = this.getSerializeChildren();
 
-        const inputNodes = {};
+        const inputNodes: NodeJSONInputNodes = {};
 
         for (const { property, index, childNode } of nodeChildren) {
             if (index !== undefined) {
@@ -773,7 +861,9 @@ class Node extends EventDispatcher {
                     inputNodes[property] = Number.isInteger(index) ? [] : {};
                 }
 
-                inputNodes[property][index] = childNode.toJSON(json.meta).uuid;
+                (inputNodes[property]! as { [index: number | string]: string })[index] = childNode.toJSON(
+                    json.meta,
+                ).uuid;
             } else {
                 inputNodes[property] = childNode.toJSON(json.meta).uuid;
             }
@@ -789,33 +879,33 @@ class Node extends EventDispatcher {
      *
      * @param {Object} json - The JSON object.
      */
-    deserialize(json) {
+    deserialize(json: NodeJSONInputData) {
         if (json.inputNodes !== undefined) {
             const nodes = json.meta.nodes;
 
             for (const property in json.inputNodes) {
                 if (Array.isArray(json.inputNodes[property])) {
-                    const inputArray = [];
+                    const inputArray: Node[] = [];
 
-                    for (const uuid of json.inputNodes[property]) {
+                    for (const uuid of json.inputNodes[property] as string[]) {
                         inputArray.push(nodes[uuid]);
                     }
 
-                    this[property] = inputArray;
+                    (this[property as keyof typeof this] as Node[]) = inputArray;
                 } else if (typeof json.inputNodes[property] === 'object') {
-                    const inputObject = {};
+                    const inputObject: { [subProperty: string]: Node } = {};
 
-                    for (const subProperty in json.inputNodes[property]) {
-                        const uuid = json.inputNodes[property][subProperty];
+                    for (const subProperty in json.inputNodes[property] as { [subProperty: string]: string }) {
+                        const uuid = (json.inputNodes[property] as { [subProperty: string]: string })[subProperty];
 
                         inputObject[subProperty] = nodes[uuid];
                     }
 
-                    this[property] = inputObject;
+                    (this[property as keyof typeof this] as { [subProperty: string]: Node }) = inputObject;
                 } else {
-                    const uuid = json.inputNodes[property];
+                    const uuid = json.inputNodes[property] as string;
 
-                    this[property] = nodes[uuid];
+                    (this[property as keyof typeof this] as Node) = nodes[uuid];
                 }
             }
         }
@@ -827,7 +917,7 @@ class Node extends EventDispatcher {
      * @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.
      * @return {Object} The serialized node.
      */
-    toJSON(meta) {
+    toJSON(meta?: NodeJSONMeta | string): NodeJSONOutputData {
         const { uuid, type } = this;
         const isRoot = meta === undefined || typeof meta === 'string';
 
@@ -836,18 +926,18 @@ class Node extends EventDispatcher {
                 textures: {},
                 images: {},
                 nodes: {},
-            };
+            } satisfies NodeJSONMeta;
         }
 
         // serialize
 
-        let data = meta.nodes[uuid];
+        let data = (meta as NodeJSONMeta).nodes[uuid];
 
         if (data === undefined) {
             data = {
                 uuid,
                 type,
-                meta,
+                meta: meta as NodeJSONMeta,
                 metadata: {
                     version: 4.7,
                     type: 'Node',
@@ -855,7 +945,7 @@ class Node extends EventDispatcher {
                 },
             };
 
-            if (isRoot !== true) meta.nodes[data.uuid] = data;
+            if (isRoot !== true) (meta as NodeJSONMeta).nodes[data.uuid] = data;
 
             this.serialize(data);
 
@@ -864,12 +954,12 @@ class Node extends EventDispatcher {
 
         // TODO: Copied from Object3D.toJSON
 
-        function extractFromCache(cache) {
+        function extractFromCache<T>(cache: { [key: string]: T }) {
             const values = [];
 
             for (const key in cache) {
                 const data = cache[key];
-                delete data.metadata;
+                delete (data as NodeJSONIntermediateOutputData).metadata;
                 values.push(data);
             }
 
@@ -877,9 +967,9 @@ class Node extends EventDispatcher {
         }
 
         if (isRoot) {
-            const textures = extractFromCache(meta.textures);
-            const images = extractFromCache(meta.images);
-            const nodes = extractFromCache(meta.nodes);
+            const textures = extractFromCache((meta as NodeJSONMeta).textures);
+            const images = extractFromCache((meta as NodeJSONMeta).images);
+            const nodes = extractFromCache((meta as NodeJSONMeta).nodes);
 
             if (textures.length > 0) data.textures = textures;
             if (images.length > 0) data.images = images;
@@ -890,4 +980,2376 @@ class Node extends EventDispatcher {
     }
 }
 
+declare const Node: {
+    /**
+     * Constructs a new node.
+     *
+     * @param {?string} nodeType - The node type.
+     */
+    new <TNodeType>(nodeType?: string | null): Node<TNodeType>;
+    new (nodeType?: string | null): Node;
+    get type(): string;
+};
+
+export interface NodeElements {}
+
+type NumberToVec = {
+    float: 'vec';
+    int: 'ivec';
+    uint: 'uvec';
+};
+
+type NumberToVec2<TNumber extends NumberType> = `${NumberToVec[TNumber]}2`;
+type NumberToVec3<TNumber extends NumberType> = `${NumberToVec[TNumber]}3`;
+type NumberToVec4<TNumber extends NumberType> = `${NumberToVec[TNumber]}4`;
+
+type Number<TNumber extends NumberType> = Node<TNumber> | number;
+type Vec2OrLessOrNumber<TNumber extends NumberType> = Number<TNumber> | Node<NumberToVec2<TNumber>>;
+type Vec3OrLessOrNumber<TNumber extends NumberType> = Vec2OrLessOrNumber<TNumber> | Node<NumberToVec3<TNumber>>;
+type Vec4OrLessOrNumber<TNumber extends NumberType> = Vec3OrLessOrNumber<TNumber> | Node<NumberToVec4<TNumber>>;
+
+interface Swizzle1In1Out<TNumber extends NumberType> {
+    get x(): Node<TNumber>;
+    set x(value: Vec4OrLessOrNumber<TNumber>);
+    get r(): Node<TNumber>;
+    set r(value: Vec4OrLessOrNumber<TNumber>);
+    get s(): Node<TNumber>;
+    set s(value: Vec4OrLessOrNumber<TNumber>);
+}
+
+interface Swizzle2In1Out<TNumber extends NumberType> extends Swizzle1In1Out<TNumber> {
+    get y(): Node<TNumber>;
+    set y(value: Vec4OrLessOrNumber<TNumber>);
+    get g(): Node<TNumber>;
+    set g(value: Vec4OrLessOrNumber<TNumber>);
+    get t(): Node<TNumber>;
+    set t(value: Vec4OrLessOrNumber<TNumber>);
+}
+
+interface Swizzle3In1Out<TNumber extends NumberType> extends Swizzle2In1Out<TNumber> {
+    get z(): Node<TNumber>;
+    set z(value: Vec4OrLessOrNumber<TNumber>);
+    get b(): Node<TNumber>;
+    set b(value: Vec4OrLessOrNumber<TNumber>);
+    get p(): Node<TNumber>;
+    set p(value: Vec4OrLessOrNumber<TNumber>);
+}
+
+interface Swizzle4In1Out<TNumber extends NumberType> extends Swizzle3In1Out<TNumber> {
+    get w(): Node<TNumber>;
+    set w(value: Vec4OrLessOrNumber<TNumber>);
+    get a(): Node<TNumber>;
+    set a(value: Vec4OrLessOrNumber<TNumber>);
+    get q(): Node<TNumber>;
+    set q(value: Vec4OrLessOrNumber<TNumber>);
+}
+
+interface Swizzle1In2Out<TNumber extends NumberType> {
+    get xx(): Node<NumberToVec2<TNumber>>;
+    set xx(value: Vec4OrLessOrNumber<TNumber>);
+    get rr(): Node<NumberToVec2<TNumber>>;
+    set rr(value: Vec4OrLessOrNumber<TNumber>);
+    get ss(): Node<NumberToVec2<TNumber>>;
+    set ss(value: Vec4OrLessOrNumber<TNumber>);
+}
+
+interface Swizzle2In2Out<TNumber extends NumberType> extends Swizzle1In2Out<TNumber> {
+    get xy(): Node<NumberToVec2<TNumber>>;
+    set xy(value: Vec4OrLessOrNumber<TNumber>);
+    get rg(): Node<NumberToVec2<TNumber>>;
+    set rg(value: Vec4OrLessOrNumber<TNumber>);
+    get st(): Node<NumberToVec2<TNumber>>;
+    set st(value: Vec4OrLessOrNumber<TNumber>);
+    get yx(): Node<NumberToVec2<TNumber>>;
+    set yx(value: Vec4OrLessOrNumber<TNumber>);
+    get gr(): Node<NumberToVec2<TNumber>>;
+    set gr(value: Vec4OrLessOrNumber<TNumber>);
+    get ts(): Node<NumberToVec2<TNumber>>;
+    set ts(value: Vec4OrLessOrNumber<TNumber>);
+    get yy(): Node<NumberToVec2<TNumber>>;
+    set yy(value: Vec4OrLessOrNumber<TNumber>);
+    get gg(): Node<NumberToVec2<TNumber>>;
+    set gg(value: Vec4OrLessOrNumber<TNumber>);
+    get tt(): Node<NumberToVec2<TNumber>>;
+    set tt(value: Vec4OrLessOrNumber<TNumber>);
+}
+
+interface Swizzle3In2Out<TNumber extends NumberType> extends Swizzle2In2Out<TNumber> {
+    get xz(): Node<NumberToVec2<TNumber>>;
+    set xz(value: Vec4OrLessOrNumber<TNumber>);
+    get rb(): Node<NumberToVec2<TNumber>>;
+    set rb(value: Vec4OrLessOrNumber<TNumber>);
+    get sp(): Node<NumberToVec2<TNumber>>;
+    set sp(value: Vec4OrLessOrNumber<TNumber>);
+    get yz(): Node<NumberToVec2<TNumber>>;
+    set yz(value: Vec4OrLessOrNumber<TNumber>);
+    get gb(): Node<NumberToVec2<TNumber>>;
+    set gb(value: Vec4OrLessOrNumber<TNumber>);
+    get tp(): Node<NumberToVec2<TNumber>>;
+    set tp(value: Vec4OrLessOrNumber<TNumber>);
+    get zx(): Node<NumberToVec2<TNumber>>;
+    set zx(value: Vec4OrLessOrNumber<TNumber>);
+    get br(): Node<NumberToVec2<TNumber>>;
+    set br(value: Vec4OrLessOrNumber<TNumber>);
+    get ps(): Node<NumberToVec2<TNumber>>;
+    set ps(value: Vec4OrLessOrNumber<TNumber>);
+    get zy(): Node<NumberToVec2<TNumber>>;
+    set zy(value: Vec4OrLessOrNumber<TNumber>);
+    get bg(): Node<NumberToVec2<TNumber>>;
+    set bg(value: Vec4OrLessOrNumber<TNumber>);
+    get pt(): Node<NumberToVec2<TNumber>>;
+    set pt(value: Vec4OrLessOrNumber<TNumber>);
+    get zz(): Node<NumberToVec2<TNumber>>;
+    set zz(value: Vec4OrLessOrNumber<TNumber>);
+    get bb(): Node<NumberToVec2<TNumber>>;
+    set bb(value: Vec4OrLessOrNumber<TNumber>);
+    get pp(): Node<NumberToVec2<TNumber>>;
+    set pp(value: Vec4OrLessOrNumber<TNumber>);
+}
+
+interface Swizzle4In2Out<TNumber extends NumberType> extends Swizzle3In2Out<TNumber> {
+    get xw(): Node<NumberToVec2<TNumber>>;
+    set xw(value: Vec4OrLessOrNumber<TNumber>);
+    get ra(): Node<NumberToVec2<TNumber>>;
+    set ra(value: Vec4OrLessOrNumber<TNumber>);
+    get sq(): Node<NumberToVec2<TNumber>>;
+    set sq(value: Vec4OrLessOrNumber<TNumber>);
+    get yw(): Node<NumberToVec2<TNumber>>;
+    set yw(value: Vec4OrLessOrNumber<TNumber>);
+    get ga(): Node<NumberToVec2<TNumber>>;
+    set ga(value: Vec4OrLessOrNumber<TNumber>);
+    get tq(): Node<NumberToVec2<TNumber>>;
+    set tq(value: Vec4OrLessOrNumber<TNumber>);
+    get zw(): Node<NumberToVec2<TNumber>>;
+    set zw(value: Vec4OrLessOrNumber<TNumber>);
+    get ba(): Node<NumberToVec2<TNumber>>;
+    set ba(value: Vec4OrLessOrNumber<TNumber>);
+    get pq(): Node<NumberToVec2<TNumber>>;
+    set pq(value: Vec4OrLessOrNumber<TNumber>);
+    get wx(): Node<NumberToVec2<TNumber>>;
+    set wx(value: Vec4OrLessOrNumber<TNumber>);
+    get ar(): Node<NumberToVec2<TNumber>>;
+    set ar(value: Vec4OrLessOrNumber<TNumber>);
+    get qs(): Node<NumberToVec2<TNumber>>;
+    set qs(value: Vec4OrLessOrNumber<TNumber>);
+    get wy(): Node<NumberToVec2<TNumber>>;
+    set wy(value: Vec4OrLessOrNumber<TNumber>);
+    get ag(): Node<NumberToVec2<TNumber>>;
+    set ag(value: Vec4OrLessOrNumber<TNumber>);
+    get qt(): Node<NumberToVec2<TNumber>>;
+    set qt(value: Vec4OrLessOrNumber<TNumber>);
+    get wz(): Node<NumberToVec2<TNumber>>;
+    set wz(value: Vec4OrLessOrNumber<TNumber>);
+    get ab(): Node<NumberToVec2<TNumber>>;
+    set ab(value: Vec4OrLessOrNumber<TNumber>);
+    get qp(): Node<NumberToVec2<TNumber>>;
+    set qp(value: Vec4OrLessOrNumber<TNumber>);
+    get ww(): Node<NumberToVec2<TNumber>>;
+    set ww(value: Vec4OrLessOrNumber<TNumber>);
+    get aa(): Node<NumberToVec2<TNumber>>;
+    set aa(value: Vec4OrLessOrNumber<TNumber>);
+    get qq(): Node<NumberToVec2<TNumber>>;
+    set qq(value: Vec4OrLessOrNumber<TNumber>);
+}
+
+interface Swizzle1In3Out<TNumber extends NumberType> {
+    get xxx(): Node<NumberToVec3<TNumber>>;
+    set xxx(value: Vec4OrLessOrNumber<TNumber>);
+    get rrr(): Node<NumberToVec3<TNumber>>;
+    set rrr(value: Vec4OrLessOrNumber<TNumber>);
+    get sss(): Node<NumberToVec3<TNumber>>;
+    set sss(value: Vec4OrLessOrNumber<TNumber>);
+}
+
+interface Swizzle2In3Out<TNumber extends NumberType> extends Swizzle1In3Out<TNumber> {
+    get xxy(): Node<NumberToVec3<TNumber>>;
+    set xxy(value: Vec4OrLessOrNumber<TNumber>);
+    get rrg(): Node<NumberToVec3<TNumber>>;
+    set rrg(value: Vec4OrLessOrNumber<TNumber>);
+    get sst(): Node<NumberToVec3<TNumber>>;
+    set sst(value: Vec4OrLessOrNumber<TNumber>);
+    get xyx(): Node<NumberToVec3<TNumber>>;
+    set xyx(value: Vec4OrLessOrNumber<TNumber>);
+    get rgr(): Node<NumberToVec3<TNumber>>;
+    set rgr(value: Vec4OrLessOrNumber<TNumber>);
+    get sts(): Node<NumberToVec3<TNumber>>;
+    set sts(value: Vec4OrLessOrNumber<TNumber>);
+    get xyy(): Node<NumberToVec3<TNumber>>;
+    set xyy(value: Vec4OrLessOrNumber<TNumber>);
+    get rgg(): Node<NumberToVec3<TNumber>>;
+    set rgg(value: Vec4OrLessOrNumber<TNumber>);
+    get stt(): Node<NumberToVec3<TNumber>>;
+    set stt(value: Vec4OrLessOrNumber<TNumber>);
+    get yxx(): Node<NumberToVec3<TNumber>>;
+    set yxx(value: Vec4OrLessOrNumber<TNumber>);
+    get grr(): Node<NumberToVec3<TNumber>>;
+    set grr(value: Vec4OrLessOrNumber<TNumber>);
+    get tss(): Node<NumberToVec3<TNumber>>;
+    set tss(value: Vec4OrLessOrNumber<TNumber>);
+    get yxy(): Node<NumberToVec3<TNumber>>;
+    set yxy(value: Vec4OrLessOrNumber<TNumber>);
+    get grg(): Node<NumberToVec3<TNumber>>;
+    set grg(value: Vec4OrLessOrNumber<TNumber>);
+    get tst(): Node<NumberToVec3<TNumber>>;
+    set tst(value: Vec4OrLessOrNumber<TNumber>);
+    get yyx(): Node<NumberToVec3<TNumber>>;
+    set yyx(value: Vec4OrLessOrNumber<TNumber>);
+    get ggr(): Node<NumberToVec3<TNumber>>;
+    set ggr(value: Vec4OrLessOrNumber<TNumber>);
+    get tts(): Node<NumberToVec3<TNumber>>;
+    set tts(value: Vec4OrLessOrNumber<TNumber>);
+    get yyy(): Node<NumberToVec3<TNumber>>;
+    set yyy(value: Vec4OrLessOrNumber<TNumber>);
+    get ggg(): Node<NumberToVec3<TNumber>>;
+    set ggg(value: Vec4OrLessOrNumber<TNumber>);
+    get ttt(): Node<NumberToVec3<TNumber>>;
+    set ttt(value: Vec4OrLessOrNumber<TNumber>);
+}
+
+interface Swizzle3In3Out<TNumber extends NumberType> extends Swizzle2In3Out<TNumber> {
+    get xxz(): Node<NumberToVec3<TNumber>>;
+    set xxz(value: Vec4OrLessOrNumber<TNumber>);
+    get rrb(): Node<NumberToVec3<TNumber>>;
+    set rrb(value: Vec4OrLessOrNumber<TNumber>);
+    get ssp(): Node<NumberToVec3<TNumber>>;
+    set ssp(value: Vec4OrLessOrNumber<TNumber>);
+    get xyz(): Node<NumberToVec3<TNumber>>;
+    set xyz(value: Vec4OrLessOrNumber<TNumber>);
+    get rgb(): Node<NumberToVec3<TNumber>>;
+    set rgb(value: Vec4OrLessOrNumber<TNumber>);
+    get stp(): Node<NumberToVec3<TNumber>>;
+    set stp(value: Vec4OrLessOrNumber<TNumber>);
+    get xzx(): Node<NumberToVec3<TNumber>>;
+    set xzx(value: Vec4OrLessOrNumber<TNumber>);
+    get rbr(): Node<NumberToVec3<TNumber>>;
+    set rbr(value: Vec4OrLessOrNumber<TNumber>);
+    get sps(): Node<NumberToVec3<TNumber>>;
+    set sps(value: Vec4OrLessOrNumber<TNumber>);
+    get xzy(): Node<NumberToVec3<TNumber>>;
+    set xzy(value: Vec4OrLessOrNumber<TNumber>);
+    get rbg(): Node<NumberToVec3<TNumber>>;
+    set rbg(value: Vec4OrLessOrNumber<TNumber>);
+    get spt(): Node<NumberToVec3<TNumber>>;
+    set spt(value: Vec4OrLessOrNumber<TNumber>);
+    get xzz(): Node<NumberToVec3<TNumber>>;
+    set xzz(value: Vec4OrLessOrNumber<TNumber>);
+    get rbb(): Node<NumberToVec3<TNumber>>;
+    set rbb(value: Vec4OrLessOrNumber<TNumber>);
+    get spp(): Node<NumberToVec3<TNumber>>;
+    set spp(value: Vec4OrLessOrNumber<TNumber>);
+    get yxz(): Node<NumberToVec3<TNumber>>;
+    set yxz(value: Vec4OrLessOrNumber<TNumber>);
+    get grb(): Node<NumberToVec3<TNumber>>;
+    set grb(value: Vec4OrLessOrNumber<TNumber>);
+    get tsp(): Node<NumberToVec3<TNumber>>;
+    set tsp(value: Vec4OrLessOrNumber<TNumber>);
+    get yyz(): Node<NumberToVec3<TNumber>>;
+    set yyz(value: Vec4OrLessOrNumber<TNumber>);
+    get ggb(): Node<NumberToVec3<TNumber>>;
+    set ggb(value: Vec4OrLessOrNumber<TNumber>);
+    get ttp(): Node<NumberToVec3<TNumber>>;
+    set ttp(value: Vec4OrLessOrNumber<TNumber>);
+    get yzx(): Node<NumberToVec3<TNumber>>;
+    set yzx(value: Vec4OrLessOrNumber<TNumber>);
+    get gbr(): Node<NumberToVec3<TNumber>>;
+    set gbr(value: Vec4OrLessOrNumber<TNumber>);
+    get tps(): Node<NumberToVec3<TNumber>>;
+    set tps(value: Vec4OrLessOrNumber<TNumber>);
+    get yzy(): Node<NumberToVec3<TNumber>>;
+    set yzy(value: Vec4OrLessOrNumber<TNumber>);
+    get gbg(): Node<NumberToVec3<TNumber>>;
+    set gbg(value: Vec4OrLessOrNumber<TNumber>);
+    get tpt(): Node<NumberToVec3<TNumber>>;
+    set tpt(value: Vec4OrLessOrNumber<TNumber>);
+    get yzz(): Node<NumberToVec3<TNumber>>;
+    set yzz(value: Vec4OrLessOrNumber<TNumber>);
+    get gbb(): Node<NumberToVec3<TNumber>>;
+    set gbb(value: Vec4OrLessOrNumber<TNumber>);
+    get tpp(): Node<NumberToVec3<TNumber>>;
+    set tpp(value: Vec4OrLessOrNumber<TNumber>);
+    get zxx(): Node<NumberToVec3<TNumber>>;
+    set zxx(value: Vec4OrLessOrNumber<TNumber>);
+    get brr(): Node<NumberToVec3<TNumber>>;
+    set brr(value: Vec4OrLessOrNumber<TNumber>);
+    get pss(): Node<NumberToVec3<TNumber>>;
+    set pss(value: Vec4OrLessOrNumber<TNumber>);
+    get zxy(): Node<NumberToVec3<TNumber>>;
+    set zxy(value: Vec4OrLessOrNumber<TNumber>);
+    get brg(): Node<NumberToVec3<TNumber>>;
+    set brg(value: Vec4OrLessOrNumber<TNumber>);
+    get pst(): Node<NumberToVec3<TNumber>>;
+    set pst(value: Vec4OrLessOrNumber<TNumber>);
+    get zxz(): Node<NumberToVec3<TNumber>>;
+    set zxz(value: Vec4OrLessOrNumber<TNumber>);
+    get brb(): Node<NumberToVec3<TNumber>>;
+    set brb(value: Vec4OrLessOrNumber<TNumber>);
+    get psp(): Node<NumberToVec3<TNumber>>;
+    set psp(value: Vec4OrLessOrNumber<TNumber>);
+    get zyx(): Node<NumberToVec3<TNumber>>;
+    set zyx(value: Vec4OrLessOrNumber<TNumber>);
+    get bgr(): Node<NumberToVec3<TNumber>>;
+    set bgr(value: Vec4OrLessOrNumber<TNumber>);
+    get pts(): Node<NumberToVec3<TNumber>>;
+    set pts(value: Vec4OrLessOrNumber<TNumber>);
+    get zyy(): Node<NumberToVec3<TNumber>>;
+    set zyy(value: Vec4OrLessOrNumber<TNumber>);
+    get bgg(): Node<NumberToVec3<TNumber>>;
+    set bgg(value: Vec4OrLessOrNumber<TNumber>);
+    get ptt(): Node<NumberToVec3<TNumber>>;
+    set ptt(value: Vec4OrLessOrNumber<TNumber>);
+    get zyz(): Node<NumberToVec3<TNumber>>;
+    set zyz(value: Vec4OrLessOrNumber<TNumber>);
+    get bgb(): Node<NumberToVec3<TNumber>>;
+    set bgb(value: Vec4OrLessOrNumber<TNumber>);
+    get ptp(): Node<NumberToVec3<TNumber>>;
+    set ptp(value: Vec4OrLessOrNumber<TNumber>);
+    get zzx(): Node<NumberToVec3<TNumber>>;
+    set zzx(value: Vec4OrLessOrNumber<TNumber>);
+    get bbr(): Node<NumberToVec3<TNumber>>;
+    set bbr(value: Vec4OrLessOrNumber<TNumber>);
+    get pps(): Node<NumberToVec3<TNumber>>;
+    set pps(value: Vec4OrLessOrNumber<TNumber>);
+    get zzy(): Node<NumberToVec3<TNumber>>;
+    set zzy(value: Vec4OrLessOrNumber<TNumber>);
+    get bbg(): Node<NumberToVec3<TNumber>>;
+    set bbg(value: Vec4OrLessOrNumber<TNumber>);
+    get ppt(): Node<NumberToVec3<TNumber>>;
+    set ppt(value: Vec4OrLessOrNumber<TNumber>);
+    get zzz(): Node<NumberToVec3<TNumber>>;
+    set zzz(value: Vec4OrLessOrNumber<TNumber>);
+    get bbb(): Node<NumberToVec3<TNumber>>;
+    set bbb(value: Vec4OrLessOrNumber<TNumber>);
+    get ppp(): Node<NumberToVec3<TNumber>>;
+    set ppp(value: Vec4OrLessOrNumber<TNumber>);
+}
+
+interface Swizzle4In3Out<TNumber extends NumberType> extends Swizzle3In3Out<TNumber> {
+    get xxw(): Node<NumberToVec3<TNumber>>;
+    set xxw(value: Vec4OrLessOrNumber<TNumber>);
+    get rra(): Node<NumberToVec3<TNumber>>;
+    set rra(value: Vec4OrLessOrNumber<TNumber>);
+    get ssq(): Node<NumberToVec3<TNumber>>;
+    set ssq(value: Vec4OrLessOrNumber<TNumber>);
+    get xyw(): Node<NumberToVec3<TNumber>>;
+    set xyw(value: Vec4OrLessOrNumber<TNumber>);
+    get rga(): Node<NumberToVec3<TNumber>>;
+    set rga(value: Vec4OrLessOrNumber<TNumber>);
+    get stq(): Node<NumberToVec3<TNumber>>;
+    set stq(value: Vec4OrLessOrNumber<TNumber>);
+    get xzw(): Node<NumberToVec3<TNumber>>;
+    set xzw(value: Vec4OrLessOrNumber<TNumber>);
+    get rba(): Node<NumberToVec3<TNumber>>;
+    set rba(value: Vec4OrLessOrNumber<TNumber>);
+    get spq(): Node<NumberToVec3<TNumber>>;
+    set spq(value: Vec4OrLessOrNumber<TNumber>);
+    get xwx(): Node<NumberToVec3<TNumber>>;
+    set xwx(value: Vec4OrLessOrNumber<TNumber>);
+    get rar(): Node<NumberToVec3<TNumber>>;
+    set rar(value: Vec4OrLessOrNumber<TNumber>);
+    get sqs(): Node<NumberToVec3<TNumber>>;
+    set sqs(value: Vec4OrLessOrNumber<TNumber>);
+    get xwy(): Node<NumberToVec3<TNumber>>;
+    set xwy(value: Vec4OrLessOrNumber<TNumber>);
+    get rag(): Node<NumberToVec3<TNumber>>;
+    set rag(value: Vec4OrLessOrNumber<TNumber>);
+    get sqt(): Node<NumberToVec3<TNumber>>;
+    set sqt(value: Vec4OrLessOrNumber<TNumber>);
+    get xwz(): Node<NumberToVec3<TNumber>>;
+    set xwz(value: Vec4OrLessOrNumber<TNumber>);
+    get rab(): Node<NumberToVec3<TNumber>>;
+    set rab(value: Vec4OrLessOrNumber<TNumber>);
+    get sqp(): Node<NumberToVec3<TNumber>>;
+    set sqp(value: Vec4OrLessOrNumber<TNumber>);
+    get xww(): Node<NumberToVec3<TNumber>>;
+    set xww(value: Vec4OrLessOrNumber<TNumber>);
+    get raa(): Node<NumberToVec3<TNumber>>;
+    set raa(value: Vec4OrLessOrNumber<TNumber>);
+    get sqq(): Node<NumberToVec3<TNumber>>;
+    set sqq(value: Vec4OrLessOrNumber<TNumber>);
+    get yxw(): Node<NumberToVec3<TNumber>>;
+    set yxw(value: Vec4OrLessOrNumber<TNumber>);
+    get gra(): Node<NumberToVec3<TNumber>>;
+    set gra(value: Vec4OrLessOrNumber<TNumber>);
+    get tsq(): Node<NumberToVec3<TNumber>>;
+    set tsq(value: Vec4OrLessOrNumber<TNumber>);
+    get yyw(): Node<NumberToVec3<TNumber>>;
+    set yyw(value: Vec4OrLessOrNumber<TNumber>);
+    get gga(): Node<NumberToVec3<TNumber>>;
+    set gga(value: Vec4OrLessOrNumber<TNumber>);
+    get ttq(): Node<NumberToVec3<TNumber>>;
+    set ttq(value: Vec4OrLessOrNumber<TNumber>);
+    get yzw(): Node<NumberToVec3<TNumber>>;
+    set yzw(value: Vec4OrLessOrNumber<TNumber>);
+    get gba(): Node<NumberToVec3<TNumber>>;
+    set gba(value: Vec4OrLessOrNumber<TNumber>);
+    get tpq(): Node<NumberToVec3<TNumber>>;
+    set tpq(value: Vec4OrLessOrNumber<TNumber>);
+    get ywx(): Node<NumberToVec3<TNumber>>;
+    set ywx(value: Vec4OrLessOrNumber<TNumber>);
+    get gar(): Node<NumberToVec3<TNumber>>;
+    set gar(value: Vec4OrLessOrNumber<TNumber>);
+    get tqs(): Node<NumberToVec3<TNumber>>;
+    set tqs(value: Vec4OrLessOrNumber<TNumber>);
+    get ywy(): Node<NumberToVec3<TNumber>>;
+    set ywy(value: Vec4OrLessOrNumber<TNumber>);
+    get gag(): Node<NumberToVec3<TNumber>>;
+    set gag(value: Vec4OrLessOrNumber<TNumber>);
+    get tqt(): Node<NumberToVec3<TNumber>>;
+    set tqt(value: Vec4OrLessOrNumber<TNumber>);
+    get ywz(): Node<NumberToVec3<TNumber>>;
+    set ywz(value: Vec4OrLessOrNumber<TNumber>);
+    get gab(): Node<NumberToVec3<TNumber>>;
+    set gab(value: Vec4OrLessOrNumber<TNumber>);
+    get tqp(): Node<NumberToVec3<TNumber>>;
+    set tqp(value: Vec4OrLessOrNumber<TNumber>);
+    get yww(): Node<NumberToVec3<TNumber>>;
+    set yww(value: Vec4OrLessOrNumber<TNumber>);
+    get gaa(): Node<NumberToVec3<TNumber>>;
+    set gaa(value: Vec4OrLessOrNumber<TNumber>);
+    get tqq(): Node<NumberToVec3<TNumber>>;
+    set tqq(value: Vec4OrLessOrNumber<TNumber>);
+    get zxw(): Node<NumberToVec3<TNumber>>;
+    set zxw(value: Vec4OrLessOrNumber<TNumber>);
+    get bra(): Node<NumberToVec3<TNumber>>;
+    set bra(value: Vec4OrLessOrNumber<TNumber>);
+    get psq(): Node<NumberToVec3<TNumber>>;
+    set psq(value: Vec4OrLessOrNumber<TNumber>);
+    get zyw(): Node<NumberToVec3<TNumber>>;
+    set zyw(value: Vec4OrLessOrNumber<TNumber>);
+    get bga(): Node<NumberToVec3<TNumber>>;
+    set bga(value: Vec4OrLessOrNumber<TNumber>);
+    get ptq(): Node<NumberToVec3<TNumber>>;
+    set ptq(value: Vec4OrLessOrNumber<TNumber>);
+    get zzw(): Node<NumberToVec3<TNumber>>;
+    set zzw(value: Vec4OrLessOrNumber<TNumber>);
+    get bba(): Node<NumberToVec3<TNumber>>;
+    set bba(value: Vec4OrLessOrNumber<TNumber>);
+    get ppq(): Node<NumberToVec3<TNumber>>;
+    set ppq(value: Vec4OrLessOrNumber<TNumber>);
+    get zwx(): Node<NumberToVec3<TNumber>>;
+    set zwx(value: Vec4OrLessOrNumber<TNumber>);
+    get bar(): Node<NumberToVec3<TNumber>>;
+    set bar(value: Vec4OrLessOrNumber<TNumber>);
+    get pqs(): Node<NumberToVec3<TNumber>>;
+    set pqs(value: Vec4OrLessOrNumber<TNumber>);
+    get zwy(): Node<NumberToVec3<TNumber>>;
+    set zwy(value: Vec4OrLessOrNumber<TNumber>);
+    get bag(): Node<NumberToVec3<TNumber>>;
+    set bag(value: Vec4OrLessOrNumber<TNumber>);
+    get pqt(): Node<NumberToVec3<TNumber>>;
+    set pqt(value: Vec4OrLessOrNumber<TNumber>);
+    get zwz(): Node<NumberToVec3<TNumber>>;
+    set zwz(value: Vec4OrLessOrNumber<TNumber>);
+    get bab(): Node<NumberToVec3<TNumber>>;
+    set bab(value: Vec4OrLessOrNumber<TNumber>);
+    get pqp(): Node<NumberToVec3<TNumber>>;
+    set pqp(value: Vec4OrLessOrNumber<TNumber>);
+    get zww(): Node<NumberToVec3<TNumber>>;
+    set zww(value: Vec4OrLessOrNumber<TNumber>);
+    get baa(): Node<NumberToVec3<TNumber>>;
+    set baa(value: Vec4OrLessOrNumber<TNumber>);
+    get pqq(): Node<NumberToVec3<TNumber>>;
+    set pqq(value: Vec4OrLessOrNumber<TNumber>);
+    get wxx(): Node<NumberToVec3<TNumber>>;
+    set wxx(value: Vec4OrLessOrNumber<TNumber>);
+    get arr(): Node<NumberToVec3<TNumber>>;
+    set arr(value: Vec4OrLessOrNumber<TNumber>);
+    get qss(): Node<NumberToVec3<TNumber>>;
+    set qss(value: Vec4OrLessOrNumber<TNumber>);
+    get wxy(): Node<NumberToVec3<TNumber>>;
+    set wxy(value: Vec4OrLessOrNumber<TNumber>);
+    get arg(): Node<NumberToVec3<TNumber>>;
+    set arg(value: Vec4OrLessOrNumber<TNumber>);
+    get qst(): Node<NumberToVec3<TNumber>>;
+    set qst(value: Vec4OrLessOrNumber<TNumber>);
+    get wxz(): Node<NumberToVec3<TNumber>>;
+    set wxz(value: Vec4OrLessOrNumber<TNumber>);
+    get arb(): Node<NumberToVec3<TNumber>>;
+    set arb(value: Vec4OrLessOrNumber<TNumber>);
+    get qsp(): Node<NumberToVec3<TNumber>>;
+    set qsp(value: Vec4OrLessOrNumber<TNumber>);
+    get wxw(): Node<NumberToVec3<TNumber>>;
+    set wxw(value: Vec4OrLessOrNumber<TNumber>);
+    get ara(): Node<NumberToVec3<TNumber>>;
+    set ara(value: Vec4OrLessOrNumber<TNumber>);
+    get qsq(): Node<NumberToVec3<TNumber>>;
+    set qsq(value: Vec4OrLessOrNumber<TNumber>);
+    get wyx(): Node<NumberToVec3<TNumber>>;
+    set wyx(value: Vec4OrLessOrNumber<TNumber>);
+    get agr(): Node<NumberToVec3<TNumber>>;
+    set agr(value: Vec4OrLessOrNumber<TNumber>);
+    get qts(): Node<NumberToVec3<TNumber>>;
+    set qts(value: Vec4OrLessOrNumber<TNumber>);
+    get wyy(): Node<NumberToVec3<TNumber>>;
+    set wyy(value: Vec4OrLessOrNumber<TNumber>);
+    get agg(): Node<NumberToVec3<TNumber>>;
+    set agg(value: Vec4OrLessOrNumber<TNumber>);
+    get qtt(): Node<NumberToVec3<TNumber>>;
+    set qtt(value: Vec4OrLessOrNumber<TNumber>);
+    get wyz(): Node<NumberToVec3<TNumber>>;
+    set wyz(value: Vec4OrLessOrNumber<TNumber>);
+    get agb(): Node<NumberToVec3<TNumber>>;
+    set agb(value: Vec4OrLessOrNumber<TNumber>);
+    get qtp(): Node<NumberToVec3<TNumber>>;
+    set qtp(value: Vec4OrLessOrNumber<TNumber>);
+    get wyw(): Node<NumberToVec3<TNumber>>;
+    set wyw(value: Vec4OrLessOrNumber<TNumber>);
+    get aga(): Node<NumberToVec3<TNumber>>;
+    set aga(value: Vec4OrLessOrNumber<TNumber>);
+    get qtq(): Node<NumberToVec3<TNumber>>;
+    set qtq(value: Vec4OrLessOrNumber<TNumber>);
+    get wzx(): Node<NumberToVec3<TNumber>>;
+    set wzx(value: Vec4OrLessOrNumber<TNumber>);
+    get abr(): Node<NumberToVec3<TNumber>>;
+    set abr(value: Vec4OrLessOrNumber<TNumber>);
+    get qps(): Node<NumberToVec3<TNumber>>;
+    set qps(value: Vec4OrLessOrNumber<TNumber>);
+    get wzy(): Node<NumberToVec3<TNumber>>;
+    set wzy(value: Vec4OrLessOrNumber<TNumber>);
+    get abg(): Node<NumberToVec3<TNumber>>;
+    set abg(value: Vec4OrLessOrNumber<TNumber>);
+    get qpt(): Node<NumberToVec3<TNumber>>;
+    set qpt(value: Vec4OrLessOrNumber<TNumber>);
+    get wzz(): Node<NumberToVec3<TNumber>>;
+    set wzz(value: Vec4OrLessOrNumber<TNumber>);
+    get abb(): Node<NumberToVec3<TNumber>>;
+    set abb(value: Vec4OrLessOrNumber<TNumber>);
+    get qpp(): Node<NumberToVec3<TNumber>>;
+    set qpp(value: Vec4OrLessOrNumber<TNumber>);
+    get wzw(): Node<NumberToVec3<TNumber>>;
+    set wzw(value: Vec4OrLessOrNumber<TNumber>);
+    get aba(): Node<NumberToVec3<TNumber>>;
+    set aba(value: Vec4OrLessOrNumber<TNumber>);
+    get qpq(): Node<NumberToVec3<TNumber>>;
+    set qpq(value: Vec4OrLessOrNumber<TNumber>);
+    get wwx(): Node<NumberToVec3<TNumber>>;
+    set wwx(value: Vec4OrLessOrNumber<TNumber>);
+    get aar(): Node<NumberToVec3<TNumber>>;
+    set aar(value: Vec4OrLessOrNumber<TNumber>);
+    get qqs(): Node<NumberToVec3<TNumber>>;
+    set qqs(value: Vec4OrLessOrNumber<TNumber>);
+    get wwy(): Node<NumberToVec3<TNumber>>;
+    set wwy(value: Vec4OrLessOrNumber<TNumber>);
+    get aag(): Node<NumberToVec3<TNumber>>;
+    set aag(value: Vec4OrLessOrNumber<TNumber>);
+    get qqt(): Node<NumberToVec3<TNumber>>;
+    set qqt(value: Vec4OrLessOrNumber<TNumber>);
+    get wwz(): Node<NumberToVec3<TNumber>>;
+    set wwz(value: Vec4OrLessOrNumber<TNumber>);
+    get aab(): Node<NumberToVec3<TNumber>>;
+    set aab(value: Vec4OrLessOrNumber<TNumber>);
+    get qqp(): Node<NumberToVec3<TNumber>>;
+    set qqp(value: Vec4OrLessOrNumber<TNumber>);
+    get www(): Node<NumberToVec3<TNumber>>;
+    set www(value: Vec4OrLessOrNumber<TNumber>);
+    get aaa(): Node<NumberToVec3<TNumber>>;
+    set aaa(value: Vec4OrLessOrNumber<TNumber>);
+    get qqq(): Node<NumberToVec3<TNumber>>;
+    set qqq(value: Vec4OrLessOrNumber<TNumber>);
+}
+
+interface Swizzle1In4Out<TNumber extends NumberType> {
+    get xxxx(): Node<NumberToVec4<TNumber>>;
+    set xxxx(value: Vec4OrLessOrNumber<TNumber>);
+    get rrrr(): Node<NumberToVec4<TNumber>>;
+    set rrrr(value: Vec4OrLessOrNumber<TNumber>);
+    get ssss(): Node<NumberToVec4<TNumber>>;
+    set ssss(value: Vec4OrLessOrNumber<TNumber>);
+}
+
+interface Swizzle2In4Out<TNumber extends NumberType> extends Swizzle1In4Out<TNumber> {
+    get xxxy(): Node<NumberToVec4<TNumber>>;
+    set xxxy(value: Vec4OrLessOrNumber<TNumber>);
+    get rrrg(): Node<NumberToVec4<TNumber>>;
+    set rrrg(value: Vec4OrLessOrNumber<TNumber>);
+    get ssst(): Node<NumberToVec4<TNumber>>;
+    set ssst(value: Vec4OrLessOrNumber<TNumber>);
+    get xxyx(): Node<NumberToVec4<TNumber>>;
+    set xxyx(value: Vec4OrLessOrNumber<TNumber>);
+    get rrgr(): Node<NumberToVec4<TNumber>>;
+    set rrgr(value: Vec4OrLessOrNumber<TNumber>);
+    get ssts(): Node<NumberToVec4<TNumber>>;
+    set ssts(value: Vec4OrLessOrNumber<TNumber>);
+    get xxyy(): Node<NumberToVec4<TNumber>>;
+    set xxyy(value: Vec4OrLessOrNumber<TNumber>);
+    get rrgg(): Node<NumberToVec4<TNumber>>;
+    set rrgg(value: Vec4OrLessOrNumber<TNumber>);
+    get sstt(): Node<NumberToVec4<TNumber>>;
+    set sstt(value: Vec4OrLessOrNumber<TNumber>);
+    get xyxx(): Node<NumberToVec4<TNumber>>;
+    set xyxx(value: Vec4OrLessOrNumber<TNumber>);
+    get rgrr(): Node<NumberToVec4<TNumber>>;
+    set rgrr(value: Vec4OrLessOrNumber<TNumber>);
+    get stss(): Node<NumberToVec4<TNumber>>;
+    set stss(value: Vec4OrLessOrNumber<TNumber>);
+    get xyxy(): Node<NumberToVec4<TNumber>>;
+    set xyxy(value: Vec4OrLessOrNumber<TNumber>);
+    get rgrg(): Node<NumberToVec4<TNumber>>;
+    set rgrg(value: Vec4OrLessOrNumber<TNumber>);
+    get stst(): Node<NumberToVec4<TNumber>>;
+    set stst(value: Vec4OrLessOrNumber<TNumber>);
+    get xyyx(): Node<NumberToVec4<TNumber>>;
+    set xyyx(value: Vec4OrLessOrNumber<TNumber>);
+    get rggr(): Node<NumberToVec4<TNumber>>;
+    set rggr(value: Vec4OrLessOrNumber<TNumber>);
+    get stts(): Node<NumberToVec4<TNumber>>;
+    set stts(value: Vec4OrLessOrNumber<TNumber>);
+    get xyyy(): Node<NumberToVec4<TNumber>>;
+    set xyyy(value: Vec4OrLessOrNumber<TNumber>);
+    get rggg(): Node<NumberToVec4<TNumber>>;
+    set rggg(value: Vec4OrLessOrNumber<TNumber>);
+    get sttt(): Node<NumberToVec4<TNumber>>;
+    set sttt(value: Vec4OrLessOrNumber<TNumber>);
+    get yxxx(): Node<NumberToVec4<TNumber>>;
+    set yxxx(value: Vec4OrLessOrNumber<TNumber>);
+    get grrr(): Node<NumberToVec4<TNumber>>;
+    set grrr(value: Vec4OrLessOrNumber<TNumber>);
+    get tsss(): Node<NumberToVec4<TNumber>>;
+    set tsss(value: Vec4OrLessOrNumber<TNumber>);
+    get yxxy(): Node<NumberToVec4<TNumber>>;
+    set yxxy(value: Vec4OrLessOrNumber<TNumber>);
+    get grrg(): Node<NumberToVec4<TNumber>>;
+    set grrg(value: Vec4OrLessOrNumber<TNumber>);
+    get tsst(): Node<NumberToVec4<TNumber>>;
+    set tsst(value: Vec4OrLessOrNumber<TNumber>);
+    get yxyx(): Node<NumberToVec4<TNumber>>;
+    set yxyx(value: Vec4OrLessOrNumber<TNumber>);
+    get grgr(): Node<NumberToVec4<TNumber>>;
+    set grgr(value: Vec4OrLessOrNumber<TNumber>);
+    get tsts(): Node<NumberToVec4<TNumber>>;
+    set tsts(value: Vec4OrLessOrNumber<TNumber>);
+    get yxyy(): Node<NumberToVec4<TNumber>>;
+    set yxyy(value: Vec4OrLessOrNumber<TNumber>);
+    get grgg(): Node<NumberToVec4<TNumber>>;
+    set grgg(value: Vec4OrLessOrNumber<TNumber>);
+    get tstt(): Node<NumberToVec4<TNumber>>;
+    set tstt(value: Vec4OrLessOrNumber<TNumber>);
+    get yyxx(): Node<NumberToVec4<TNumber>>;
+    set yyxx(value: Vec4OrLessOrNumber<TNumber>);
+    get ggrr(): Node<NumberToVec4<TNumber>>;
+    set ggrr(value: Vec4OrLessOrNumber<TNumber>);
+    get ttss(): Node<NumberToVec4<TNumber>>;
+    set ttss(value: Vec4OrLessOrNumber<TNumber>);
+    get yyxy(): Node<NumberToVec4<TNumber>>;
+    set yyxy(value: Vec4OrLessOrNumber<TNumber>);
+    get ggrg(): Node<NumberToVec4<TNumber>>;
+    set ggrg(value: Vec4OrLessOrNumber<TNumber>);
+    get ttst(): Node<NumberToVec4<TNumber>>;
+    set ttst(value: Vec4OrLessOrNumber<TNumber>);
+    get yyyx(): Node<NumberToVec4<TNumber>>;
+    set yyyx(value: Vec4OrLessOrNumber<TNumber>);
+    get gggr(): Node<NumberToVec4<TNumber>>;
+    set gggr(value: Vec4OrLessOrNumber<TNumber>);
+    get ttts(): Node<NumberToVec4<TNumber>>;
+    set ttts(value: Vec4OrLessOrNumber<TNumber>);
+    get yyyy(): Node<NumberToVec4<TNumber>>;
+    set yyyy(value: Vec4OrLessOrNumber<TNumber>);
+    get gggg(): Node<NumberToVec4<TNumber>>;
+    set gggg(value: Vec4OrLessOrNumber<TNumber>);
+    get tttt(): Node<NumberToVec4<TNumber>>;
+    set tttt(value: Vec4OrLessOrNumber<TNumber>);
+}
+
+interface Swizzle3In4Out<TNumber extends NumberType> extends Swizzle2In4Out<TNumber> {
+    get xxxz(): Node<NumberToVec4<TNumber>>;
+    set xxxz(value: Vec4OrLessOrNumber<TNumber>);
+    get rrrb(): Node<NumberToVec4<TNumber>>;
+    set rrrb(value: Vec4OrLessOrNumber<TNumber>);
+    get sssp(): Node<NumberToVec4<TNumber>>;
+    set sssp(value: Vec4OrLessOrNumber<TNumber>);
+    get xxyz(): Node<NumberToVec4<TNumber>>;
+    set xxyz(value: Vec4OrLessOrNumber<TNumber>);
+    get rrgb(): Node<NumberToVec4<TNumber>>;
+    set rrgb(value: Vec4OrLessOrNumber<TNumber>);
+    get sstp(): Node<NumberToVec4<TNumber>>;
+    set sstp(value: Vec4OrLessOrNumber<TNumber>);
+    get xxzx(): Node<NumberToVec4<TNumber>>;
+    set xxzx(value: Vec4OrLessOrNumber<TNumber>);
+    get rrbr(): Node<NumberToVec4<TNumber>>;
+    set rrbr(value: Vec4OrLessOrNumber<TNumber>);
+    get ssps(): Node<NumberToVec4<TNumber>>;
+    set ssps(value: Vec4OrLessOrNumber<TNumber>);
+    get xxzy(): Node<NumberToVec4<TNumber>>;
+    set xxzy(value: Vec4OrLessOrNumber<TNumber>);
+    get rrbg(): Node<NumberToVec4<TNumber>>;
+    set rrbg(value: Vec4OrLessOrNumber<TNumber>);
+    get sspt(): Node<NumberToVec4<TNumber>>;
+    set sspt(value: Vec4OrLessOrNumber<TNumber>);
+    get xxzz(): Node<NumberToVec4<TNumber>>;
+    set xxzz(value: Vec4OrLessOrNumber<TNumber>);
+    get rrbb(): Node<NumberToVec4<TNumber>>;
+    set rrbb(value: Vec4OrLessOrNumber<TNumber>);
+    get sspp(): Node<NumberToVec4<TNumber>>;
+    set sspp(value: Vec4OrLessOrNumber<TNumber>);
+    get xyxz(): Node<NumberToVec4<TNumber>>;
+    set xyxz(value: Vec4OrLessOrNumber<TNumber>);
+    get rgrb(): Node<NumberToVec4<TNumber>>;
+    set rgrb(value: Vec4OrLessOrNumber<TNumber>);
+    get stsp(): Node<NumberToVec4<TNumber>>;
+    set stsp(value: Vec4OrLessOrNumber<TNumber>);
+    get xyyz(): Node<NumberToVec4<TNumber>>;
+    set xyyz(value: Vec4OrLessOrNumber<TNumber>);
+    get rggb(): Node<NumberToVec4<TNumber>>;
+    set rggb(value: Vec4OrLessOrNumber<TNumber>);
+    get sttp(): Node<NumberToVec4<TNumber>>;
+    set sttp(value: Vec4OrLessOrNumber<TNumber>);
+    get xyzx(): Node<NumberToVec4<TNumber>>;
+    set xyzx(value: Vec4OrLessOrNumber<TNumber>);
+    get rgbr(): Node<NumberToVec4<TNumber>>;
+    set rgbr(value: Vec4OrLessOrNumber<TNumber>);
+    get stps(): Node<NumberToVec4<TNumber>>;
+    set stps(value: Vec4OrLessOrNumber<TNumber>);
+    get xyzy(): Node<NumberToVec4<TNumber>>;
+    set xyzy(value: Vec4OrLessOrNumber<TNumber>);
+    get rgbg(): Node<NumberToVec4<TNumber>>;
+    set rgbg(value: Vec4OrLessOrNumber<TNumber>);
+    get stpt(): Node<NumberToVec4<TNumber>>;
+    set stpt(value: Vec4OrLessOrNumber<TNumber>);
+    get xyzz(): Node<NumberToVec4<TNumber>>;
+    set xyzz(value: Vec4OrLessOrNumber<TNumber>);
+    get rgbb(): Node<NumberToVec4<TNumber>>;
+    set rgbb(value: Vec4OrLessOrNumber<TNumber>);
+    get stpp(): Node<NumberToVec4<TNumber>>;
+    set stpp(value: Vec4OrLessOrNumber<TNumber>);
+    get xzxx(): Node<NumberToVec4<TNumber>>;
+    set xzxx(value: Vec4OrLessOrNumber<TNumber>);
+    get rbrr(): Node<NumberToVec4<TNumber>>;
+    set rbrr(value: Vec4OrLessOrNumber<TNumber>);
+    get spss(): Node<NumberToVec4<TNumber>>;
+    set spss(value: Vec4OrLessOrNumber<TNumber>);
+    get xzxy(): Node<NumberToVec4<TNumber>>;
+    set xzxy(value: Vec4OrLessOrNumber<TNumber>);
+    get rbrg(): Node<NumberToVec4<TNumber>>;
+    set rbrg(value: Vec4OrLessOrNumber<TNumber>);
+    get spst(): Node<NumberToVec4<TNumber>>;
+    set spst(value: Vec4OrLessOrNumber<TNumber>);
+    get xzxz(): Node<NumberToVec4<TNumber>>;
+    set xzxz(value: Vec4OrLessOrNumber<TNumber>);
+    get rbrb(): Node<NumberToVec4<TNumber>>;
+    set rbrb(value: Vec4OrLessOrNumber<TNumber>);
+    get spsp(): Node<NumberToVec4<TNumber>>;
+    set spsp(value: Vec4OrLessOrNumber<TNumber>);
+    get xzyx(): Node<NumberToVec4<TNumber>>;
+    set xzyx(value: Vec4OrLessOrNumber<TNumber>);
+    get rbgr(): Node<NumberToVec4<TNumber>>;
+    set rbgr(value: Vec4OrLessOrNumber<TNumber>);
+    get spts(): Node<NumberToVec4<TNumber>>;
+    set spts(value: Vec4OrLessOrNumber<TNumber>);
+    get xzyy(): Node<NumberToVec4<TNumber>>;
+    set xzyy(value: Vec4OrLessOrNumber<TNumber>);
+    get rbgg(): Node<NumberToVec4<TNumber>>;
+    set rbgg(value: Vec4OrLessOrNumber<TNumber>);
+    get sptt(): Node<NumberToVec4<TNumber>>;
+    set sptt(value: Vec4OrLessOrNumber<TNumber>);
+    get xzyz(): Node<NumberToVec4<TNumber>>;
+    set xzyz(value: Vec4OrLessOrNumber<TNumber>);
+    get rbgb(): Node<NumberToVec4<TNumber>>;
+    set rbgb(value: Vec4OrLessOrNumber<TNumber>);
+    get sptp(): Node<NumberToVec4<TNumber>>;
+    set sptp(value: Vec4OrLessOrNumber<TNumber>);
+    get xzzx(): Node<NumberToVec4<TNumber>>;
+    set xzzx(value: Vec4OrLessOrNumber<TNumber>);
+    get rbbr(): Node<NumberToVec4<TNumber>>;
+    set rbbr(value: Vec4OrLessOrNumber<TNumber>);
+    get spps(): Node<NumberToVec4<TNumber>>;
+    set spps(value: Vec4OrLessOrNumber<TNumber>);
+    get xzzy(): Node<NumberToVec4<TNumber>>;
+    set xzzy(value: Vec4OrLessOrNumber<TNumber>);
+    get rbbg(): Node<NumberToVec4<TNumber>>;
+    set rbbg(value: Vec4OrLessOrNumber<TNumber>);
+    get sppt(): Node<NumberToVec4<TNumber>>;
+    set sppt(value: Vec4OrLessOrNumber<TNumber>);
+    get xzzz(): Node<NumberToVec4<TNumber>>;
+    set xzzz(value: Vec4OrLessOrNumber<TNumber>);
+    get rbbb(): Node<NumberToVec4<TNumber>>;
+    set rbbb(value: Vec4OrLessOrNumber<TNumber>);
+    get sppp(): Node<NumberToVec4<TNumber>>;
+    set sppp(value: Vec4OrLessOrNumber<TNumber>);
+    get yxxz(): Node<NumberToVec4<TNumber>>;
+    set yxxz(value: Vec4OrLessOrNumber<TNumber>);
+    get grrb(): Node<NumberToVec4<TNumber>>;
+    set grrb(value: Vec4OrLessOrNumber<TNumber>);
+    get tssp(): Node<NumberToVec4<TNumber>>;
+    set tssp(value: Vec4OrLessOrNumber<TNumber>);
+    get yxyz(): Node<NumberToVec4<TNumber>>;
+    set yxyz(value: Vec4OrLessOrNumber<TNumber>);
+    get grgb(): Node<NumberToVec4<TNumber>>;
+    set grgb(value: Vec4OrLessOrNumber<TNumber>);
+    get tstp(): Node<NumberToVec4<TNumber>>;
+    set tstp(value: Vec4OrLessOrNumber<TNumber>);
+    get yxzx(): Node<NumberToVec4<TNumber>>;
+    set yxzx(value: Vec4OrLessOrNumber<TNumber>);
+    get grbr(): Node<NumberToVec4<TNumber>>;
+    set grbr(value: Vec4OrLessOrNumber<TNumber>);
+    get tsps(): Node<NumberToVec4<TNumber>>;
+    set tsps(value: Vec4OrLessOrNumber<TNumber>);
+    get yxzy(): Node<NumberToVec4<TNumber>>;
+    set yxzy(value: Vec4OrLessOrNumber<TNumber>);
+    get grbg(): Node<NumberToVec4<TNumber>>;
+    set grbg(value: Vec4OrLessOrNumber<TNumber>);
+    get tspt(): Node<NumberToVec4<TNumber>>;
+    set tspt(value: Vec4OrLessOrNumber<TNumber>);
+    get yxzz(): Node<NumberToVec4<TNumber>>;
+    set yxzz(value: Vec4OrLessOrNumber<TNumber>);
+    get grbb(): Node<NumberToVec4<TNumber>>;
+    set grbb(value: Vec4OrLessOrNumber<TNumber>);
+    get tspp(): Node<NumberToVec4<TNumber>>;
+    set tspp(value: Vec4OrLessOrNumber<TNumber>);
+    get yyxz(): Node<NumberToVec4<TNumber>>;
+    set yyxz(value: Vec4OrLessOrNumber<TNumber>);
+    get ggrb(): Node<NumberToVec4<TNumber>>;
+    set ggrb(value: Vec4OrLessOrNumber<TNumber>);
+    get ttsp(): Node<NumberToVec4<TNumber>>;
+    set ttsp(value: Vec4OrLessOrNumber<TNumber>);
+    get yyyz(): Node<NumberToVec4<TNumber>>;
+    set yyyz(value: Vec4OrLessOrNumber<TNumber>);
+    get gggb(): Node<NumberToVec4<TNumber>>;
+    set gggb(value: Vec4OrLessOrNumber<TNumber>);
+    get tttp(): Node<NumberToVec4<TNumber>>;
+    set tttp(value: Vec4OrLessOrNumber<TNumber>);
+    get yyzx(): Node<NumberToVec4<TNumber>>;
+    set yyzx(value: Vec4OrLessOrNumber<TNumber>);
+    get ggbr(): Node<NumberToVec4<TNumber>>;
+    set ggbr(value: Vec4OrLessOrNumber<TNumber>);
+    get ttps(): Node<NumberToVec4<TNumber>>;
+    set ttps(value: Vec4OrLessOrNumber<TNumber>);
+    get yyzy(): Node<NumberToVec4<TNumber>>;
+    set yyzy(value: Vec4OrLessOrNumber<TNumber>);
+    get ggbg(): Node<NumberToVec4<TNumber>>;
+    set ggbg(value: Vec4OrLessOrNumber<TNumber>);
+    get ttpt(): Node<NumberToVec4<TNumber>>;
+    set ttpt(value: Vec4OrLessOrNumber<TNumber>);
+    get yyzz(): Node<NumberToVec4<TNumber>>;
+    set yyzz(value: Vec4OrLessOrNumber<TNumber>);
+    get ggbb(): Node<NumberToVec4<TNumber>>;
+    set ggbb(value: Vec4OrLessOrNumber<TNumber>);
+    get ttpp(): Node<NumberToVec4<TNumber>>;
+    set ttpp(value: Vec4OrLessOrNumber<TNumber>);
+    get yzxx(): Node<NumberToVec4<TNumber>>;
+    set yzxx(value: Vec4OrLessOrNumber<TNumber>);
+    get gbrr(): Node<NumberToVec4<TNumber>>;
+    set gbrr(value: Vec4OrLessOrNumber<TNumber>);
+    get tpss(): Node<NumberToVec4<TNumber>>;
+    set tpss(value: Vec4OrLessOrNumber<TNumber>);
+    get yzxy(): Node<NumberToVec4<TNumber>>;
+    set yzxy(value: Vec4OrLessOrNumber<TNumber>);
+    get gbrg(): Node<NumberToVec4<TNumber>>;
+    set gbrg(value: Vec4OrLessOrNumber<TNumber>);
+    get tpst(): Node<NumberToVec4<TNumber>>;
+    set tpst(value: Vec4OrLessOrNumber<TNumber>);
+    get yzxz(): Node<NumberToVec4<TNumber>>;
+    set yzxz(value: Vec4OrLessOrNumber<TNumber>);
+    get gbrb(): Node<NumberToVec4<TNumber>>;
+    set gbrb(value: Vec4OrLessOrNumber<TNumber>);
+    get tpsp(): Node<NumberToVec4<TNumber>>;
+    set tpsp(value: Vec4OrLessOrNumber<TNumber>);
+    get yzyx(): Node<NumberToVec4<TNumber>>;
+    set yzyx(value: Vec4OrLessOrNumber<TNumber>);
+    get gbgr(): Node<NumberToVec4<TNumber>>;
+    set gbgr(value: Vec4OrLessOrNumber<TNumber>);
+    get tpts(): Node<NumberToVec4<TNumber>>;
+    set tpts(value: Vec4OrLessOrNumber<TNumber>);
+    get yzyy(): Node<NumberToVec4<TNumber>>;
+    set yzyy(value: Vec4OrLessOrNumber<TNumber>);
+    get gbgg(): Node<NumberToVec4<TNumber>>;
+    set gbgg(value: Vec4OrLessOrNumber<TNumber>);
+    get tptt(): Node<NumberToVec4<TNumber>>;
+    set tptt(value: Vec4OrLessOrNumber<TNumber>);
+    get yzyz(): Node<NumberToVec4<TNumber>>;
+    set yzyz(value: Vec4OrLessOrNumber<TNumber>);
+    get gbgb(): Node<NumberToVec4<TNumber>>;
+    set gbgb(value: Vec4OrLessOrNumber<TNumber>);
+    get tptp(): Node<NumberToVec4<TNumber>>;
+    set tptp(value: Vec4OrLessOrNumber<TNumber>);
+    get yzzx(): Node<NumberToVec4<TNumber>>;
+    set yzzx(value: Vec4OrLessOrNumber<TNumber>);
+    get gbbr(): Node<NumberToVec4<TNumber>>;
+    set gbbr(value: Vec4OrLessOrNumber<TNumber>);
+    get tpps(): Node<NumberToVec4<TNumber>>;
+    set tpps(value: Vec4OrLessOrNumber<TNumber>);
+    get yzzy(): Node<NumberToVec4<TNumber>>;
+    set yzzy(value: Vec4OrLessOrNumber<TNumber>);
+    get gbbg(): Node<NumberToVec4<TNumber>>;
+    set gbbg(value: Vec4OrLessOrNumber<TNumber>);
+    get tppt(): Node<NumberToVec4<TNumber>>;
+    set tppt(value: Vec4OrLessOrNumber<TNumber>);
+    get yzzz(): Node<NumberToVec4<TNumber>>;
+    set yzzz(value: Vec4OrLessOrNumber<TNumber>);
+    get gbbb(): Node<NumberToVec4<TNumber>>;
+    set gbbb(value: Vec4OrLessOrNumber<TNumber>);
+    get tppp(): Node<NumberToVec4<TNumber>>;
+    set tppp(value: Vec4OrLessOrNumber<TNumber>);
+    get zxxx(): Node<NumberToVec4<TNumber>>;
+    set zxxx(value: Vec4OrLessOrNumber<TNumber>);
+    get brrr(): Node<NumberToVec4<TNumber>>;
+    set brrr(value: Vec4OrLessOrNumber<TNumber>);
+    get psss(): Node<NumberToVec4<TNumber>>;
+    set psss(value: Vec4OrLessOrNumber<TNumber>);
+    get zxxy(): Node<NumberToVec4<TNumber>>;
+    set zxxy(value: Vec4OrLessOrNumber<TNumber>);
+    get brrg(): Node<NumberToVec4<TNumber>>;
+    set brrg(value: Vec4OrLessOrNumber<TNumber>);
+    get psst(): Node<NumberToVec4<TNumber>>;
+    set psst(value: Vec4OrLessOrNumber<TNumber>);
+    get zxxz(): Node<NumberToVec4<TNumber>>;
+    set zxxz(value: Vec4OrLessOrNumber<TNumber>);
+    get brrb(): Node<NumberToVec4<TNumber>>;
+    set brrb(value: Vec4OrLessOrNumber<TNumber>);
+    get pssp(): Node<NumberToVec4<TNumber>>;
+    set pssp(value: Vec4OrLessOrNumber<TNumber>);
+    get zxyx(): Node<NumberToVec4<TNumber>>;
+    set zxyx(value: Vec4OrLessOrNumber<TNumber>);
+    get brgr(): Node<NumberToVec4<TNumber>>;
+    set brgr(value: Vec4OrLessOrNumber<TNumber>);
+    get psts(): Node<NumberToVec4<TNumber>>;
+    set psts(value: Vec4OrLessOrNumber<TNumber>);
+    get zxyy(): Node<NumberToVec4<TNumber>>;
+    set zxyy(value: Vec4OrLessOrNumber<TNumber>);
+    get brgg(): Node<NumberToVec4<TNumber>>;
+    set brgg(value: Vec4OrLessOrNumber<TNumber>);
+    get pstt(): Node<NumberToVec4<TNumber>>;
+    set pstt(value: Vec4OrLessOrNumber<TNumber>);
+    get zxyz(): Node<NumberToVec4<TNumber>>;
+    set zxyz(value: Vec4OrLessOrNumber<TNumber>);
+    get brgb(): Node<NumberToVec4<TNumber>>;
+    set brgb(value: Vec4OrLessOrNumber<TNumber>);
+    get pstp(): Node<NumberToVec4<TNumber>>;
+    set pstp(value: Vec4OrLessOrNumber<TNumber>);
+    get zxzx(): Node<NumberToVec4<TNumber>>;
+    set zxzx(value: Vec4OrLessOrNumber<TNumber>);
+    get brbr(): Node<NumberToVec4<TNumber>>;
+    set brbr(value: Vec4OrLessOrNumber<TNumber>);
+    get psps(): Node<NumberToVec4<TNumber>>;
+    set psps(value: Vec4OrLessOrNumber<TNumber>);
+    get zxzy(): Node<NumberToVec4<TNumber>>;
+    set zxzy(value: Vec4OrLessOrNumber<TNumber>);
+    get brbg(): Node<NumberToVec4<TNumber>>;
+    set brbg(value: Vec4OrLessOrNumber<TNumber>);
+    get pspt(): Node<NumberToVec4<TNumber>>;
+    set pspt(value: Vec4OrLessOrNumber<TNumber>);
+    get zxzz(): Node<NumberToVec4<TNumber>>;
+    set zxzz(value: Vec4OrLessOrNumber<TNumber>);
+    get brbb(): Node<NumberToVec4<TNumber>>;
+    set brbb(value: Vec4OrLessOrNumber<TNumber>);
+    get pspp(): Node<NumberToVec4<TNumber>>;
+    set pspp(value: Vec4OrLessOrNumber<TNumber>);
+    get zyxx(): Node<NumberToVec4<TNumber>>;
+    set zyxx(value: Vec4OrLessOrNumber<TNumber>);
+    get bgrr(): Node<NumberToVec4<TNumber>>;
+    set bgrr(value: Vec4OrLessOrNumber<TNumber>);
+    get ptss(): Node<NumberToVec4<TNumber>>;
+    set ptss(value: Vec4OrLessOrNumber<TNumber>);
+    get zyxy(): Node<NumberToVec4<TNumber>>;
+    set zyxy(value: Vec4OrLessOrNumber<TNumber>);
+    get bgrg(): Node<NumberToVec4<TNumber>>;
+    set bgrg(value: Vec4OrLessOrNumber<TNumber>);
+    get ptst(): Node<NumberToVec4<TNumber>>;
+    set ptst(value: Vec4OrLessOrNumber<TNumber>);
+    get zyxz(): Node<NumberToVec4<TNumber>>;
+    set zyxz(value: Vec4OrLessOrNumber<TNumber>);
+    get bgrb(): Node<NumberToVec4<TNumber>>;
+    set bgrb(value: Vec4OrLessOrNumber<TNumber>);
+    get ptsp(): Node<NumberToVec4<TNumber>>;
+    set ptsp(value: Vec4OrLessOrNumber<TNumber>);
+    get zyyx(): Node<NumberToVec4<TNumber>>;
+    set zyyx(value: Vec4OrLessOrNumber<TNumber>);
+    get bggr(): Node<NumberToVec4<TNumber>>;
+    set bggr(value: Vec4OrLessOrNumber<TNumber>);
+    get ptts(): Node<NumberToVec4<TNumber>>;
+    set ptts(value: Vec4OrLessOrNumber<TNumber>);
+    get zyyy(): Node<NumberToVec4<TNumber>>;
+    set zyyy(value: Vec4OrLessOrNumber<TNumber>);
+    get bggg(): Node<NumberToVec4<TNumber>>;
+    set bggg(value: Vec4OrLessOrNumber<TNumber>);
+    get pttt(): Node<NumberToVec4<TNumber>>;
+    set pttt(value: Vec4OrLessOrNumber<TNumber>);
+    get zyyz(): Node<NumberToVec4<TNumber>>;
+    set zyyz(value: Vec4OrLessOrNumber<TNumber>);
+    get bggb(): Node<NumberToVec4<TNumber>>;
+    set bggb(value: Vec4OrLessOrNumber<TNumber>);
+    get pttp(): Node<NumberToVec4<TNumber>>;
+    set pttp(value: Vec4OrLessOrNumber<TNumber>);
+    get zyzx(): Node<NumberToVec4<TNumber>>;
+    set zyzx(value: Vec4OrLessOrNumber<TNumber>);
+    get bgbr(): Node<NumberToVec4<TNumber>>;
+    set bgbr(value: Vec4OrLessOrNumber<TNumber>);
+    get ptps(): Node<NumberToVec4<TNumber>>;
+    set ptps(value: Vec4OrLessOrNumber<TNumber>);
+    get zyzy(): Node<NumberToVec4<TNumber>>;
+    set zyzy(value: Vec4OrLessOrNumber<TNumber>);
+    get bgbg(): Node<NumberToVec4<TNumber>>;
+    set bgbg(value: Vec4OrLessOrNumber<TNumber>);
+    get ptpt(): Node<NumberToVec4<TNumber>>;
+    set ptpt(value: Vec4OrLessOrNumber<TNumber>);
+    get zyzz(): Node<NumberToVec4<TNumber>>;
+    set zyzz(value: Vec4OrLessOrNumber<TNumber>);
+    get bgbb(): Node<NumberToVec4<TNumber>>;
+    set bgbb(value: Vec4OrLessOrNumber<TNumber>);
+    get ptpp(): Node<NumberToVec4<TNumber>>;
+    set ptpp(value: Vec4OrLessOrNumber<TNumber>);
+    get zzxx(): Node<NumberToVec4<TNumber>>;
+    set zzxx(value: Vec4OrLessOrNumber<TNumber>);
+    get bbrr(): Node<NumberToVec4<TNumber>>;
+    set bbrr(value: Vec4OrLessOrNumber<TNumber>);
+    get ppss(): Node<NumberToVec4<TNumber>>;
+    set ppss(value: Vec4OrLessOrNumber<TNumber>);
+    get zzxy(): Node<NumberToVec4<TNumber>>;
+    set zzxy(value: Vec4OrLessOrNumber<TNumber>);
+    get bbrg(): Node<NumberToVec4<TNumber>>;
+    set bbrg(value: Vec4OrLessOrNumber<TNumber>);
+    get ppst(): Node<NumberToVec4<TNumber>>;
+    set ppst(value: Vec4OrLessOrNumber<TNumber>);
+    get zzxz(): Node<NumberToVec4<TNumber>>;
+    set zzxz(value: Vec4OrLessOrNumber<TNumber>);
+    get bbrb(): Node<NumberToVec4<TNumber>>;
+    set bbrb(value: Vec4OrLessOrNumber<TNumber>);
+    get ppsp(): Node<NumberToVec4<TNumber>>;
+    set ppsp(value: Vec4OrLessOrNumber<TNumber>);
+    get zzyx(): Node<NumberToVec4<TNumber>>;
+    set zzyx(value: Vec4OrLessOrNumber<TNumber>);
+    get bbgr(): Node<NumberToVec4<TNumber>>;
+    set bbgr(value: Vec4OrLessOrNumber<TNumber>);
+    get ppts(): Node<NumberToVec4<TNumber>>;
+    set ppts(value: Vec4OrLessOrNumber<TNumber>);
+    get zzyy(): Node<NumberToVec4<TNumber>>;
+    set zzyy(value: Vec4OrLessOrNumber<TNumber>);
+    get bbgg(): Node<NumberToVec4<TNumber>>;
+    set bbgg(value: Vec4OrLessOrNumber<TNumber>);
+    get pptt(): Node<NumberToVec4<TNumber>>;
+    set pptt(value: Vec4OrLessOrNumber<TNumber>);
+    get zzyz(): Node<NumberToVec4<TNumber>>;
+    set zzyz(value: Vec4OrLessOrNumber<TNumber>);
+    get bbgb(): Node<NumberToVec4<TNumber>>;
+    set bbgb(value: Vec4OrLessOrNumber<TNumber>);
+    get pptp(): Node<NumberToVec4<TNumber>>;
+    set pptp(value: Vec4OrLessOrNumber<TNumber>);
+    get zzzx(): Node<NumberToVec4<TNumber>>;
+    set zzzx(value: Vec4OrLessOrNumber<TNumber>);
+    get bbbr(): Node<NumberToVec4<TNumber>>;
+    set bbbr(value: Vec4OrLessOrNumber<TNumber>);
+    get ppps(): Node<NumberToVec4<TNumber>>;
+    set ppps(value: Vec4OrLessOrNumber<TNumber>);
+    get zzzy(): Node<NumberToVec4<TNumber>>;
+    set zzzy(value: Vec4OrLessOrNumber<TNumber>);
+    get bbbg(): Node<NumberToVec4<TNumber>>;
+    set bbbg(value: Vec4OrLessOrNumber<TNumber>);
+    get pppt(): Node<NumberToVec4<TNumber>>;
+    set pppt(value: Vec4OrLessOrNumber<TNumber>);
+    get zzzz(): Node<NumberToVec4<TNumber>>;
+    set zzzz(value: Vec4OrLessOrNumber<TNumber>);
+    get bbbb(): Node<NumberToVec4<TNumber>>;
+    set bbbb(value: Vec4OrLessOrNumber<TNumber>);
+    get pppp(): Node<NumberToVec4<TNumber>>;
+    set pppp(value: Vec4OrLessOrNumber<TNumber>);
+}
+
+interface Swizzle4In4Out<TNumber extends NumberType> extends Swizzle3In4Out<TNumber> {
+    get xxxw(): Node<NumberToVec4<TNumber>>;
+    set xxxw(value: Vec4OrLessOrNumber<TNumber>);
+    get rrra(): Node<NumberToVec4<TNumber>>;
+    set rrra(value: Vec4OrLessOrNumber<TNumber>);
+    get sssq(): Node<NumberToVec4<TNumber>>;
+    set sssq(value: Vec4OrLessOrNumber<TNumber>);
+    get xxyw(): Node<NumberToVec4<TNumber>>;
+    set xxyw(value: Vec4OrLessOrNumber<TNumber>);
+    get rrga(): Node<NumberToVec4<TNumber>>;
+    set rrga(value: Vec4OrLessOrNumber<TNumber>);
+    get sstq(): Node<NumberToVec4<TNumber>>;
+    set sstq(value: Vec4OrLessOrNumber<TNumber>);
+    get xxzw(): Node<NumberToVec4<TNumber>>;
+    set xxzw(value: Vec4OrLessOrNumber<TNumber>);
+    get rrba(): Node<NumberToVec4<TNumber>>;
+    set rrba(value: Vec4OrLessOrNumber<TNumber>);
+    get sspq(): Node<NumberToVec4<TNumber>>;
+    set sspq(value: Vec4OrLessOrNumber<TNumber>);
+    get xxwx(): Node<NumberToVec4<TNumber>>;
+    set xxwx(value: Vec4OrLessOrNumber<TNumber>);
+    get rrar(): Node<NumberToVec4<TNumber>>;
+    set rrar(value: Vec4OrLessOrNumber<TNumber>);
+    get ssqs(): Node<NumberToVec4<TNumber>>;
+    set ssqs(value: Vec4OrLessOrNumber<TNumber>);
+    get xxwy(): Node<NumberToVec4<TNumber>>;
+    set xxwy(value: Vec4OrLessOrNumber<TNumber>);
+    get rrag(): Node<NumberToVec4<TNumber>>;
+    set rrag(value: Vec4OrLessOrNumber<TNumber>);
+    get ssqt(): Node<NumberToVec4<TNumber>>;
+    set ssqt(value: Vec4OrLessOrNumber<TNumber>);
+    get xxwz(): Node<NumberToVec4<TNumber>>;
+    set xxwz(value: Vec4OrLessOrNumber<TNumber>);
+    get rrab(): Node<NumberToVec4<TNumber>>;
+    set rrab(value: Vec4OrLessOrNumber<TNumber>);
+    get ssqp(): Node<NumberToVec4<TNumber>>;
+    set ssqp(value: Vec4OrLessOrNumber<TNumber>);
+    get xxww(): Node<NumberToVec4<TNumber>>;
+    set xxww(value: Vec4OrLessOrNumber<TNumber>);
+    get rraa(): Node<NumberToVec4<TNumber>>;
+    set rraa(value: Vec4OrLessOrNumber<TNumber>);
+    get ssqq(): Node<NumberToVec4<TNumber>>;
+    set ssqq(value: Vec4OrLessOrNumber<TNumber>);
+    get xyxw(): Node<NumberToVec4<TNumber>>;
+    set xyxw(value: Vec4OrLessOrNumber<TNumber>);
+    get rgra(): Node<NumberToVec4<TNumber>>;
+    set rgra(value: Vec4OrLessOrNumber<TNumber>);
+    get stsq(): Node<NumberToVec4<TNumber>>;
+    set stsq(value: Vec4OrLessOrNumber<TNumber>);
+    get xyyw(): Node<NumberToVec4<TNumber>>;
+    set xyyw(value: Vec4OrLessOrNumber<TNumber>);
+    get rgga(): Node<NumberToVec4<TNumber>>;
+    set rgga(value: Vec4OrLessOrNumber<TNumber>);
+    get sttq(): Node<NumberToVec4<TNumber>>;
+    set sttq(value: Vec4OrLessOrNumber<TNumber>);
+    get xyzw(): Node<NumberToVec4<TNumber>>;
+    set xyzw(value: Vec4OrLessOrNumber<TNumber>);
+    get rgba(): Node<NumberToVec4<TNumber>>;
+    set rgba(value: Vec4OrLessOrNumber<TNumber>);
+    get stpq(): Node<NumberToVec4<TNumber>>;
+    set stpq(value: Vec4OrLessOrNumber<TNumber>);
+    get xywx(): Node<NumberToVec4<TNumber>>;
+    set xywx(value: Vec4OrLessOrNumber<TNumber>);
+    get rgar(): Node<NumberToVec4<TNumber>>;
+    set rgar(value: Vec4OrLessOrNumber<TNumber>);
+    get stqs(): Node<NumberToVec4<TNumber>>;
+    set stqs(value: Vec4OrLessOrNumber<TNumber>);
+    get xywy(): Node<NumberToVec4<TNumber>>;
+    set xywy(value: Vec4OrLessOrNumber<TNumber>);
+    get rgag(): Node<NumberToVec4<TNumber>>;
+    set rgag(value: Vec4OrLessOrNumber<TNumber>);
+    get stqt(): Node<NumberToVec4<TNumber>>;
+    set stqt(value: Vec4OrLessOrNumber<TNumber>);
+    get xywz(): Node<NumberToVec4<TNumber>>;
+    set xywz(value: Vec4OrLessOrNumber<TNumber>);
+    get rgab(): Node<NumberToVec4<TNumber>>;
+    set rgab(value: Vec4OrLessOrNumber<TNumber>);
+    get stqp(): Node<NumberToVec4<TNumber>>;
+    set stqp(value: Vec4OrLessOrNumber<TNumber>);
+    get xyww(): Node<NumberToVec4<TNumber>>;
+    set xyww(value: Vec4OrLessOrNumber<TNumber>);
+    get rgaa(): Node<NumberToVec4<TNumber>>;
+    set rgaa(value: Vec4OrLessOrNumber<TNumber>);
+    get stqq(): Node<NumberToVec4<TNumber>>;
+    set stqq(value: Vec4OrLessOrNumber<TNumber>);
+    get xzxw(): Node<NumberToVec4<TNumber>>;
+    set xzxw(value: Vec4OrLessOrNumber<TNumber>);
+    get rbra(): Node<NumberToVec4<TNumber>>;
+    set rbra(value: Vec4OrLessOrNumber<TNumber>);
+    get spsq(): Node<NumberToVec4<TNumber>>;
+    set spsq(value: Vec4OrLessOrNumber<TNumber>);
+    get xzyw(): Node<NumberToVec4<TNumber>>;
+    set xzyw(value: Vec4OrLessOrNumber<TNumber>);
+    get rbga(): Node<NumberToVec4<TNumber>>;
+    set rbga(value: Vec4OrLessOrNumber<TNumber>);
+    get sptq(): Node<NumberToVec4<TNumber>>;
+    set sptq(value: Vec4OrLessOrNumber<TNumber>);
+    get xzzw(): Node<NumberToVec4<TNumber>>;
+    set xzzw(value: Vec4OrLessOrNumber<TNumber>);
+    get rbba(): Node<NumberToVec4<TNumber>>;
+    set rbba(value: Vec4OrLessOrNumber<TNumber>);
+    get sppq(): Node<NumberToVec4<TNumber>>;
+    set sppq(value: Vec4OrLessOrNumber<TNumber>);
+    get xzwx(): Node<NumberToVec4<TNumber>>;
+    set xzwx(value: Vec4OrLessOrNumber<TNumber>);
+    get rbar(): Node<NumberToVec4<TNumber>>;
+    set rbar(value: Vec4OrLessOrNumber<TNumber>);
+    get spqs(): Node<NumberToVec4<TNumber>>;
+    set spqs(value: Vec4OrLessOrNumber<TNumber>);
+    get xzwy(): Node<NumberToVec4<TNumber>>;
+    set xzwy(value: Vec4OrLessOrNumber<TNumber>);
+    get rbag(): Node<NumberToVec4<TNumber>>;
+    set rbag(value: Vec4OrLessOrNumber<TNumber>);
+    get spqt(): Node<NumberToVec4<TNumber>>;
+    set spqt(value: Vec4OrLessOrNumber<TNumber>);
+    get xzwz(): Node<NumberToVec4<TNumber>>;
+    set xzwz(value: Vec4OrLessOrNumber<TNumber>);
+    get rbab(): Node<NumberToVec4<TNumber>>;
+    set rbab(value: Vec4OrLessOrNumber<TNumber>);
+    get spqp(): Node<NumberToVec4<TNumber>>;
+    set spqp(value: Vec4OrLessOrNumber<TNumber>);
+    get xzww(): Node<NumberToVec4<TNumber>>;
+    set xzww(value: Vec4OrLessOrNumber<TNumber>);
+    get rbaa(): Node<NumberToVec4<TNumber>>;
+    set rbaa(value: Vec4OrLessOrNumber<TNumber>);
+    get spqq(): Node<NumberToVec4<TNumber>>;
+    set spqq(value: Vec4OrLessOrNumber<TNumber>);
+    get xwxx(): Node<NumberToVec4<TNumber>>;
+    set xwxx(value: Vec4OrLessOrNumber<TNumber>);
+    get rarr(): Node<NumberToVec4<TNumber>>;
+    set rarr(value: Vec4OrLessOrNumber<TNumber>);
+    get sqss(): Node<NumberToVec4<TNumber>>;
+    set sqss(value: Vec4OrLessOrNumber<TNumber>);
+    get xwxy(): Node<NumberToVec4<TNumber>>;
+    set xwxy(value: Vec4OrLessOrNumber<TNumber>);
+    get rarg(): Node<NumberToVec4<TNumber>>;
+    set rarg(value: Vec4OrLessOrNumber<TNumber>);
+    get sqst(): Node<NumberToVec4<TNumber>>;
+    set sqst(value: Vec4OrLessOrNumber<TNumber>);
+    get xwxz(): Node<NumberToVec4<TNumber>>;
+    set xwxz(value: Vec4OrLessOrNumber<TNumber>);
+    get rarb(): Node<NumberToVec4<TNumber>>;
+    set rarb(value: Vec4OrLessOrNumber<TNumber>);
+    get sqsp(): Node<NumberToVec4<TNumber>>;
+    set sqsp(value: Vec4OrLessOrNumber<TNumber>);
+    get xwxw(): Node<NumberToVec4<TNumber>>;
+    set xwxw(value: Vec4OrLessOrNumber<TNumber>);
+    get rara(): Node<NumberToVec4<TNumber>>;
+    set rara(value: Vec4OrLessOrNumber<TNumber>);
+    get sqsq(): Node<NumberToVec4<TNumber>>;
+    set sqsq(value: Vec4OrLessOrNumber<TNumber>);
+    get xwyx(): Node<NumberToVec4<TNumber>>;
+    set xwyx(value: Vec4OrLessOrNumber<TNumber>);
+    get ragr(): Node<NumberToVec4<TNumber>>;
+    set ragr(value: Vec4OrLessOrNumber<TNumber>);
+    get sqts(): Node<NumberToVec4<TNumber>>;
+    set sqts(value: Vec4OrLessOrNumber<TNumber>);
+    get xwyy(): Node<NumberToVec4<TNumber>>;
+    set xwyy(value: Vec4OrLessOrNumber<TNumber>);
+    get ragg(): Node<NumberToVec4<TNumber>>;
+    set ragg(value: Vec4OrLessOrNumber<TNumber>);
+    get sqtt(): Node<NumberToVec4<TNumber>>;
+    set sqtt(value: Vec4OrLessOrNumber<TNumber>);
+    get xwyz(): Node<NumberToVec4<TNumber>>;
+    set xwyz(value: Vec4OrLessOrNumber<TNumber>);
+    get ragb(): Node<NumberToVec4<TNumber>>;
+    set ragb(value: Vec4OrLessOrNumber<TNumber>);
+    get sqtp(): Node<NumberToVec4<TNumber>>;
+    set sqtp(value: Vec4OrLessOrNumber<TNumber>);
+    get xwyw(): Node<NumberToVec4<TNumber>>;
+    set xwyw(value: Vec4OrLessOrNumber<TNumber>);
+    get raga(): Node<NumberToVec4<TNumber>>;
+    set raga(value: Vec4OrLessOrNumber<TNumber>);
+    get sqtq(): Node<NumberToVec4<TNumber>>;
+    set sqtq(value: Vec4OrLessOrNumber<TNumber>);
+    get xwzx(): Node<NumberToVec4<TNumber>>;
+    set xwzx(value: Vec4OrLessOrNumber<TNumber>);
+    get rabr(): Node<NumberToVec4<TNumber>>;
+    set rabr(value: Vec4OrLessOrNumber<TNumber>);
+    get sqps(): Node<NumberToVec4<TNumber>>;
+    set sqps(value: Vec4OrLessOrNumber<TNumber>);
+    get xwzy(): Node<NumberToVec4<TNumber>>;
+    set xwzy(value: Vec4OrLessOrNumber<TNumber>);
+    get rabg(): Node<NumberToVec4<TNumber>>;
+    set rabg(value: Vec4OrLessOrNumber<TNumber>);
+    get sqpt(): Node<NumberToVec4<TNumber>>;
+    set sqpt(value: Vec4OrLessOrNumber<TNumber>);
+    get xwzz(): Node<NumberToVec4<TNumber>>;
+    set xwzz(value: Vec4OrLessOrNumber<TNumber>);
+    get rabb(): Node<NumberToVec4<TNumber>>;
+    set rabb(value: Vec4OrLessOrNumber<TNumber>);
+    get sqpp(): Node<NumberToVec4<TNumber>>;
+    set sqpp(value: Vec4OrLessOrNumber<TNumber>);
+    get xwzw(): Node<NumberToVec4<TNumber>>;
+    set xwzw(value: Vec4OrLessOrNumber<TNumber>);
+    get raba(): Node<NumberToVec4<TNumber>>;
+    set raba(value: Vec4OrLessOrNumber<TNumber>);
+    get sqpq(): Node<NumberToVec4<TNumber>>;
+    set sqpq(value: Vec4OrLessOrNumber<TNumber>);
+    get xwwx(): Node<NumberToVec4<TNumber>>;
+    set xwwx(value: Vec4OrLessOrNumber<TNumber>);
+    get raar(): Node<NumberToVec4<TNumber>>;
+    set raar(value: Vec4OrLessOrNumber<TNumber>);
+    get sqqs(): Node<NumberToVec4<TNumber>>;
+    set sqqs(value: Vec4OrLessOrNumber<TNumber>);
+    get xwwy(): Node<NumberToVec4<TNumber>>;
+    set xwwy(value: Vec4OrLessOrNumber<TNumber>);
+    get raag(): Node<NumberToVec4<TNumber>>;
+    set raag(value: Vec4OrLessOrNumber<TNumber>);
+    get sqqt(): Node<NumberToVec4<TNumber>>;
+    set sqqt(value: Vec4OrLessOrNumber<TNumber>);
+    get xwwz(): Node<NumberToVec4<TNumber>>;
+    set xwwz(value: Vec4OrLessOrNumber<TNumber>);
+    get raab(): Node<NumberToVec4<TNumber>>;
+    set raab(value: Vec4OrLessOrNumber<TNumber>);
+    get sqqp(): Node<NumberToVec4<TNumber>>;
+    set sqqp(value: Vec4OrLessOrNumber<TNumber>);
+    get xwww(): Node<NumberToVec4<TNumber>>;
+    set xwww(value: Vec4OrLessOrNumber<TNumber>);
+    get raaa(): Node<NumberToVec4<TNumber>>;
+    set raaa(value: Vec4OrLessOrNumber<TNumber>);
+    get sqqq(): Node<NumberToVec4<TNumber>>;
+    set sqqq(value: Vec4OrLessOrNumber<TNumber>);
+    get yxxw(): Node<NumberToVec4<TNumber>>;
+    set yxxw(value: Vec4OrLessOrNumber<TNumber>);
+    get grra(): Node<NumberToVec4<TNumber>>;
+    set grra(value: Vec4OrLessOrNumber<TNumber>);
+    get tssq(): Node<NumberToVec4<TNumber>>;
+    set tssq(value: Vec4OrLessOrNumber<TNumber>);
+    get yxyw(): Node<NumberToVec4<TNumber>>;
+    set yxyw(value: Vec4OrLessOrNumber<TNumber>);
+    get grga(): Node<NumberToVec4<TNumber>>;
+    set grga(value: Vec4OrLessOrNumber<TNumber>);
+    get tstq(): Node<NumberToVec4<TNumber>>;
+    set tstq(value: Vec4OrLessOrNumber<TNumber>);
+    get yxzw(): Node<NumberToVec4<TNumber>>;
+    set yxzw(value: Vec4OrLessOrNumber<TNumber>);
+    get grba(): Node<NumberToVec4<TNumber>>;
+    set grba(value: Vec4OrLessOrNumber<TNumber>);
+    get tspq(): Node<NumberToVec4<TNumber>>;
+    set tspq(value: Vec4OrLessOrNumber<TNumber>);
+    get yxwx(): Node<NumberToVec4<TNumber>>;
+    set yxwx(value: Vec4OrLessOrNumber<TNumber>);
+    get grar(): Node<NumberToVec4<TNumber>>;
+    set grar(value: Vec4OrLessOrNumber<TNumber>);
+    get tsqs(): Node<NumberToVec4<TNumber>>;
+    set tsqs(value: Vec4OrLessOrNumber<TNumber>);
+    get yxwy(): Node<NumberToVec4<TNumber>>;
+    set yxwy(value: Vec4OrLessOrNumber<TNumber>);
+    get grag(): Node<NumberToVec4<TNumber>>;
+    set grag(value: Vec4OrLessOrNumber<TNumber>);
+    get tsqt(): Node<NumberToVec4<TNumber>>;
+    set tsqt(value: Vec4OrLessOrNumber<TNumber>);
+    get yxwz(): Node<NumberToVec4<TNumber>>;
+    set yxwz(value: Vec4OrLessOrNumber<TNumber>);
+    get grab(): Node<NumberToVec4<TNumber>>;
+    set grab(value: Vec4OrLessOrNumber<TNumber>);
+    get tsqp(): Node<NumberToVec4<TNumber>>;
+    set tsqp(value: Vec4OrLessOrNumber<TNumber>);
+    get yxww(): Node<NumberToVec4<TNumber>>;
+    set yxww(value: Vec4OrLessOrNumber<TNumber>);
+    get graa(): Node<NumberToVec4<TNumber>>;
+    set graa(value: Vec4OrLessOrNumber<TNumber>);
+    get tsqq(): Node<NumberToVec4<TNumber>>;
+    set tsqq(value: Vec4OrLessOrNumber<TNumber>);
+    get yyxw(): Node<NumberToVec4<TNumber>>;
+    set yyxw(value: Vec4OrLessOrNumber<TNumber>);
+    get ggra(): Node<NumberToVec4<TNumber>>;
+    set ggra(value: Vec4OrLessOrNumber<TNumber>);
+    get ttsq(): Node<NumberToVec4<TNumber>>;
+    set ttsq(value: Vec4OrLessOrNumber<TNumber>);
+    get yyyw(): Node<NumberToVec4<TNumber>>;
+    set yyyw(value: Vec4OrLessOrNumber<TNumber>);
+    get ggga(): Node<NumberToVec4<TNumber>>;
+    set ggga(value: Vec4OrLessOrNumber<TNumber>);
+    get tttq(): Node<NumberToVec4<TNumber>>;
+    set tttq(value: Vec4OrLessOrNumber<TNumber>);
+    get yyzw(): Node<NumberToVec4<TNumber>>;
+    set yyzw(value: Vec4OrLessOrNumber<TNumber>);
+    get ggba(): Node<NumberToVec4<TNumber>>;
+    set ggba(value: Vec4OrLessOrNumber<TNumber>);
+    get ttpq(): Node<NumberToVec4<TNumber>>;
+    set ttpq(value: Vec4OrLessOrNumber<TNumber>);
+    get yywx(): Node<NumberToVec4<TNumber>>;
+    set yywx(value: Vec4OrLessOrNumber<TNumber>);
+    get ggar(): Node<NumberToVec4<TNumber>>;
+    set ggar(value: Vec4OrLessOrNumber<TNumber>);
+    get ttqs(): Node<NumberToVec4<TNumber>>;
+    set ttqs(value: Vec4OrLessOrNumber<TNumber>);
+    get yywy(): Node<NumberToVec4<TNumber>>;
+    set yywy(value: Vec4OrLessOrNumber<TNumber>);
+    get ggag(): Node<NumberToVec4<TNumber>>;
+    set ggag(value: Vec4OrLessOrNumber<TNumber>);
+    get ttqt(): Node<NumberToVec4<TNumber>>;
+    set ttqt(value: Vec4OrLessOrNumber<TNumber>);
+    get yywz(): Node<NumberToVec4<TNumber>>;
+    set yywz(value: Vec4OrLessOrNumber<TNumber>);
+    get ggab(): Node<NumberToVec4<TNumber>>;
+    set ggab(value: Vec4OrLessOrNumber<TNumber>);
+    get ttqp(): Node<NumberToVec4<TNumber>>;
+    set ttqp(value: Vec4OrLessOrNumber<TNumber>);
+    get yyww(): Node<NumberToVec4<TNumber>>;
+    set yyww(value: Vec4OrLessOrNumber<TNumber>);
+    get ggaa(): Node<NumberToVec4<TNumber>>;
+    set ggaa(value: Vec4OrLessOrNumber<TNumber>);
+    get ttqq(): Node<NumberToVec4<TNumber>>;
+    set ttqq(value: Vec4OrLessOrNumber<TNumber>);
+    get yzxw(): Node<NumberToVec4<TNumber>>;
+    set yzxw(value: Vec4OrLessOrNumber<TNumber>);
+    get gbra(): Node<NumberToVec4<TNumber>>;
+    set gbra(value: Vec4OrLessOrNumber<TNumber>);
+    get tpsq(): Node<NumberToVec4<TNumber>>;
+    set tpsq(value: Vec4OrLessOrNumber<TNumber>);
+    get yzyw(): Node<NumberToVec4<TNumber>>;
+    set yzyw(value: Vec4OrLessOrNumber<TNumber>);
+    get gbga(): Node<NumberToVec4<TNumber>>;
+    set gbga(value: Vec4OrLessOrNumber<TNumber>);
+    get tptq(): Node<NumberToVec4<TNumber>>;
+    set tptq(value: Vec4OrLessOrNumber<TNumber>);
+    get yzzw(): Node<NumberToVec4<TNumber>>;
+    set yzzw(value: Vec4OrLessOrNumber<TNumber>);
+    get gbba(): Node<NumberToVec4<TNumber>>;
+    set gbba(value: Vec4OrLessOrNumber<TNumber>);
+    get tppq(): Node<NumberToVec4<TNumber>>;
+    set tppq(value: Vec4OrLessOrNumber<TNumber>);
+    get yzwx(): Node<NumberToVec4<TNumber>>;
+    set yzwx(value: Vec4OrLessOrNumber<TNumber>);
+    get gbar(): Node<NumberToVec4<TNumber>>;
+    set gbar(value: Vec4OrLessOrNumber<TNumber>);
+    get tpqs(): Node<NumberToVec4<TNumber>>;
+    set tpqs(value: Vec4OrLessOrNumber<TNumber>);
+    get yzwy(): Node<NumberToVec4<TNumber>>;
+    set yzwy(value: Vec4OrLessOrNumber<TNumber>);
+    get gbag(): Node<NumberToVec4<TNumber>>;
+    set gbag(value: Vec4OrLessOrNumber<TNumber>);
+    get tpqt(): Node<NumberToVec4<TNumber>>;
+    set tpqt(value: Vec4OrLessOrNumber<TNumber>);
+    get yzwz(): Node<NumberToVec4<TNumber>>;
+    set yzwz(value: Vec4OrLessOrNumber<TNumber>);
+    get gbab(): Node<NumberToVec4<TNumber>>;
+    set gbab(value: Vec4OrLessOrNumber<TNumber>);
+    get tpqp(): Node<NumberToVec4<TNumber>>;
+    set tpqp(value: Vec4OrLessOrNumber<TNumber>);
+    get yzww(): Node<NumberToVec4<TNumber>>;
+    set yzww(value: Vec4OrLessOrNumber<TNumber>);
+    get gbaa(): Node<NumberToVec4<TNumber>>;
+    set gbaa(value: Vec4OrLessOrNumber<TNumber>);
+    get tpqq(): Node<NumberToVec4<TNumber>>;
+    set tpqq(value: Vec4OrLessOrNumber<TNumber>);
+    get ywxx(): Node<NumberToVec4<TNumber>>;
+    set ywxx(value: Vec4OrLessOrNumber<TNumber>);
+    get garr(): Node<NumberToVec4<TNumber>>;
+    set garr(value: Vec4OrLessOrNumber<TNumber>);
+    get tqss(): Node<NumberToVec4<TNumber>>;
+    set tqss(value: Vec4OrLessOrNumber<TNumber>);
+    get ywxy(): Node<NumberToVec4<TNumber>>;
+    set ywxy(value: Vec4OrLessOrNumber<TNumber>);
+    get garg(): Node<NumberToVec4<TNumber>>;
+    set garg(value: Vec4OrLessOrNumber<TNumber>);
+    get tqst(): Node<NumberToVec4<TNumber>>;
+    set tqst(value: Vec4OrLessOrNumber<TNumber>);
+    get ywxz(): Node<NumberToVec4<TNumber>>;
+    set ywxz(value: Vec4OrLessOrNumber<TNumber>);
+    get garb(): Node<NumberToVec4<TNumber>>;
+    set garb(value: Vec4OrLessOrNumber<TNumber>);
+    get tqsp(): Node<NumberToVec4<TNumber>>;
+    set tqsp(value: Vec4OrLessOrNumber<TNumber>);
+    get ywxw(): Node<NumberToVec4<TNumber>>;
+    set ywxw(value: Vec4OrLessOrNumber<TNumber>);
+    get gara(): Node<NumberToVec4<TNumber>>;
+    set gara(value: Vec4OrLessOrNumber<TNumber>);
+    get tqsq(): Node<NumberToVec4<TNumber>>;
+    set tqsq(value: Vec4OrLessOrNumber<TNumber>);
+    get ywyx(): Node<NumberToVec4<TNumber>>;
+    set ywyx(value: Vec4OrLessOrNumber<TNumber>);
+    get gagr(): Node<NumberToVec4<TNumber>>;
+    set gagr(value: Vec4OrLessOrNumber<TNumber>);
+    get tqts(): Node<NumberToVec4<TNumber>>;
+    set tqts(value: Vec4OrLessOrNumber<TNumber>);
+    get ywyy(): Node<NumberToVec4<TNumber>>;
+    set ywyy(value: Vec4OrLessOrNumber<TNumber>);
+    get gagg(): Node<NumberToVec4<TNumber>>;
+    set gagg(value: Vec4OrLessOrNumber<TNumber>);
+    get tqtt(): Node<NumberToVec4<TNumber>>;
+    set tqtt(value: Vec4OrLessOrNumber<TNumber>);
+    get ywyz(): Node<NumberToVec4<TNumber>>;
+    set ywyz(value: Vec4OrLessOrNumber<TNumber>);
+    get gagb(): Node<NumberToVec4<TNumber>>;
+    set gagb(value: Vec4OrLessOrNumber<TNumber>);
+    get tqtp(): Node<NumberToVec4<TNumber>>;
+    set tqtp(value: Vec4OrLessOrNumber<TNumber>);
+    get ywyw(): Node<NumberToVec4<TNumber>>;
+    set ywyw(value: Vec4OrLessOrNumber<TNumber>);
+    get gaga(): Node<NumberToVec4<TNumber>>;
+    set gaga(value: Vec4OrLessOrNumber<TNumber>);
+    get tqtq(): Node<NumberToVec4<TNumber>>;
+    set tqtq(value: Vec4OrLessOrNumber<TNumber>);
+    get ywzx(): Node<NumberToVec4<TNumber>>;
+    set ywzx(value: Vec4OrLessOrNumber<TNumber>);
+    get gabr(): Node<NumberToVec4<TNumber>>;
+    set gabr(value: Vec4OrLessOrNumber<TNumber>);
+    get tqps(): Node<NumberToVec4<TNumber>>;
+    set tqps(value: Vec4OrLessOrNumber<TNumber>);
+    get ywzy(): Node<NumberToVec4<TNumber>>;
+    set ywzy(value: Vec4OrLessOrNumber<TNumber>);
+    get gabg(): Node<NumberToVec4<TNumber>>;
+    set gabg(value: Vec4OrLessOrNumber<TNumber>);
+    get tqpt(): Node<NumberToVec4<TNumber>>;
+    set tqpt(value: Vec4OrLessOrNumber<TNumber>);
+    get ywzz(): Node<NumberToVec4<TNumber>>;
+    set ywzz(value: Vec4OrLessOrNumber<TNumber>);
+    get gabb(): Node<NumberToVec4<TNumber>>;
+    set gabb(value: Vec4OrLessOrNumber<TNumber>);
+    get tqpp(): Node<NumberToVec4<TNumber>>;
+    set tqpp(value: Vec4OrLessOrNumber<TNumber>);
+    get ywzw(): Node<NumberToVec4<TNumber>>;
+    set ywzw(value: Vec4OrLessOrNumber<TNumber>);
+    get gaba(): Node<NumberToVec4<TNumber>>;
+    set gaba(value: Vec4OrLessOrNumber<TNumber>);
+    get tqpq(): Node<NumberToVec4<TNumber>>;
+    set tqpq(value: Vec4OrLessOrNumber<TNumber>);
+    get ywwx(): Node<NumberToVec4<TNumber>>;
+    set ywwx(value: Vec4OrLessOrNumber<TNumber>);
+    get gaar(): Node<NumberToVec4<TNumber>>;
+    set gaar(value: Vec4OrLessOrNumber<TNumber>);
+    get tqqs(): Node<NumberToVec4<TNumber>>;
+    set tqqs(value: Vec4OrLessOrNumber<TNumber>);
+    get ywwy(): Node<NumberToVec4<TNumber>>;
+    set ywwy(value: Vec4OrLessOrNumber<TNumber>);
+    get gaag(): Node<NumberToVec4<TNumber>>;
+    set gaag(value: Vec4OrLessOrNumber<TNumber>);
+    get tqqt(): Node<NumberToVec4<TNumber>>;
+    set tqqt(value: Vec4OrLessOrNumber<TNumber>);
+    get ywwz(): Node<NumberToVec4<TNumber>>;
+    set ywwz(value: Vec4OrLessOrNumber<TNumber>);
+    get gaab(): Node<NumberToVec4<TNumber>>;
+    set gaab(value: Vec4OrLessOrNumber<TNumber>);
+    get tqqp(): Node<NumberToVec4<TNumber>>;
+    set tqqp(value: Vec4OrLessOrNumber<TNumber>);
+    get ywww(): Node<NumberToVec4<TNumber>>;
+    set ywww(value: Vec4OrLessOrNumber<TNumber>);
+    get gaaa(): Node<NumberToVec4<TNumber>>;
+    set gaaa(value: Vec4OrLessOrNumber<TNumber>);
+    get tqqq(): Node<NumberToVec4<TNumber>>;
+    set tqqq(value: Vec4OrLessOrNumber<TNumber>);
+    get zxxw(): Node<NumberToVec4<TNumber>>;
+    set zxxw(value: Vec4OrLessOrNumber<TNumber>);
+    get brra(): Node<NumberToVec4<TNumber>>;
+    set brra(value: Vec4OrLessOrNumber<TNumber>);
+    get pssq(): Node<NumberToVec4<TNumber>>;
+    set pssq(value: Vec4OrLessOrNumber<TNumber>);
+    get zxyw(): Node<NumberToVec4<TNumber>>;
+    set zxyw(value: Vec4OrLessOrNumber<TNumber>);
+    get brga(): Node<NumberToVec4<TNumber>>;
+    set brga(value: Vec4OrLessOrNumber<TNumber>);
+    get pstq(): Node<NumberToVec4<TNumber>>;
+    set pstq(value: Vec4OrLessOrNumber<TNumber>);
+    get zxzw(): Node<NumberToVec4<TNumber>>;
+    set zxzw(value: Vec4OrLessOrNumber<TNumber>);
+    get brba(): Node<NumberToVec4<TNumber>>;
+    set brba(value: Vec4OrLessOrNumber<TNumber>);
+    get pspq(): Node<NumberToVec4<TNumber>>;
+    set pspq(value: Vec4OrLessOrNumber<TNumber>);
+    get zxwx(): Node<NumberToVec4<TNumber>>;
+    set zxwx(value: Vec4OrLessOrNumber<TNumber>);
+    get brar(): Node<NumberToVec4<TNumber>>;
+    set brar(value: Vec4OrLessOrNumber<TNumber>);
+    get psqs(): Node<NumberToVec4<TNumber>>;
+    set psqs(value: Vec4OrLessOrNumber<TNumber>);
+    get zxwy(): Node<NumberToVec4<TNumber>>;
+    set zxwy(value: Vec4OrLessOrNumber<TNumber>);
+    get brag(): Node<NumberToVec4<TNumber>>;
+    set brag(value: Vec4OrLessOrNumber<TNumber>);
+    get psqt(): Node<NumberToVec4<TNumber>>;
+    set psqt(value: Vec4OrLessOrNumber<TNumber>);
+    get zxwz(): Node<NumberToVec4<TNumber>>;
+    set zxwz(value: Vec4OrLessOrNumber<TNumber>);
+    get brab(): Node<NumberToVec4<TNumber>>;
+    set brab(value: Vec4OrLessOrNumber<TNumber>);
+    get psqp(): Node<NumberToVec4<TNumber>>;
+    set psqp(value: Vec4OrLessOrNumber<TNumber>);
+    get zxww(): Node<NumberToVec4<TNumber>>;
+    set zxww(value: Vec4OrLessOrNumber<TNumber>);
+    get braa(): Node<NumberToVec4<TNumber>>;
+    set braa(value: Vec4OrLessOrNumber<TNumber>);
+    get psqq(): Node<NumberToVec4<TNumber>>;
+    set psqq(value: Vec4OrLessOrNumber<TNumber>);
+    get zyxw(): Node<NumberToVec4<TNumber>>;
+    set zyxw(value: Vec4OrLessOrNumber<TNumber>);
+    get bgra(): Node<NumberToVec4<TNumber>>;
+    set bgra(value: Vec4OrLessOrNumber<TNumber>);
+    get ptsq(): Node<NumberToVec4<TNumber>>;
+    set ptsq(value: Vec4OrLessOrNumber<TNumber>);
+    get zyyw(): Node<NumberToVec4<TNumber>>;
+    set zyyw(value: Vec4OrLessOrNumber<TNumber>);
+    get bgga(): Node<NumberToVec4<TNumber>>;
+    set bgga(value: Vec4OrLessOrNumber<TNumber>);
+    get pttq(): Node<NumberToVec4<TNumber>>;
+    set pttq(value: Vec4OrLessOrNumber<TNumber>);
+    get zyzw(): Node<NumberToVec4<TNumber>>;
+    set zyzw(value: Vec4OrLessOrNumber<TNumber>);
+    get bgba(): Node<NumberToVec4<TNumber>>;
+    set bgba(value: Vec4OrLessOrNumber<TNumber>);
+    get ptpq(): Node<NumberToVec4<TNumber>>;
+    set ptpq(value: Vec4OrLessOrNumber<TNumber>);
+    get zywx(): Node<NumberToVec4<TNumber>>;
+    set zywx(value: Vec4OrLessOrNumber<TNumber>);
+    get bgar(): Node<NumberToVec4<TNumber>>;
+    set bgar(value: Vec4OrLessOrNumber<TNumber>);
+    get ptqs(): Node<NumberToVec4<TNumber>>;
+    set ptqs(value: Vec4OrLessOrNumber<TNumber>);
+    get zywy(): Node<NumberToVec4<TNumber>>;
+    set zywy(value: Vec4OrLessOrNumber<TNumber>);
+    get bgag(): Node<NumberToVec4<TNumber>>;
+    set bgag(value: Vec4OrLessOrNumber<TNumber>);
+    get ptqt(): Node<NumberToVec4<TNumber>>;
+    set ptqt(value: Vec4OrLessOrNumber<TNumber>);
+    get zywz(): Node<NumberToVec4<TNumber>>;
+    set zywz(value: Vec4OrLessOrNumber<TNumber>);
+    get bgab(): Node<NumberToVec4<TNumber>>;
+    set bgab(value: Vec4OrLessOrNumber<TNumber>);
+    get ptqp(): Node<NumberToVec4<TNumber>>;
+    set ptqp(value: Vec4OrLessOrNumber<TNumber>);
+    get zyww(): Node<NumberToVec4<TNumber>>;
+    set zyww(value: Vec4OrLessOrNumber<TNumber>);
+    get bgaa(): Node<NumberToVec4<TNumber>>;
+    set bgaa(value: Vec4OrLessOrNumber<TNumber>);
+    get ptqq(): Node<NumberToVec4<TNumber>>;
+    set ptqq(value: Vec4OrLessOrNumber<TNumber>);
+    get zzxw(): Node<NumberToVec4<TNumber>>;
+    set zzxw(value: Vec4OrLessOrNumber<TNumber>);
+    get bbra(): Node<NumberToVec4<TNumber>>;
+    set bbra(value: Vec4OrLessOrNumber<TNumber>);
+    get ppsq(): Node<NumberToVec4<TNumber>>;
+    set ppsq(value: Vec4OrLessOrNumber<TNumber>);
+    get zzyw(): Node<NumberToVec4<TNumber>>;
+    set zzyw(value: Vec4OrLessOrNumber<TNumber>);
+    get bbga(): Node<NumberToVec4<TNumber>>;
+    set bbga(value: Vec4OrLessOrNumber<TNumber>);
+    get pptq(): Node<NumberToVec4<TNumber>>;
+    set pptq(value: Vec4OrLessOrNumber<TNumber>);
+    get zzzw(): Node<NumberToVec4<TNumber>>;
+    set zzzw(value: Vec4OrLessOrNumber<TNumber>);
+    get bbba(): Node<NumberToVec4<TNumber>>;
+    set bbba(value: Vec4OrLessOrNumber<TNumber>);
+    get pppq(): Node<NumberToVec4<TNumber>>;
+    set pppq(value: Vec4OrLessOrNumber<TNumber>);
+    get zzwx(): Node<NumberToVec4<TNumber>>;
+    set zzwx(value: Vec4OrLessOrNumber<TNumber>);
+    get bbar(): Node<NumberToVec4<TNumber>>;
+    set bbar(value: Vec4OrLessOrNumber<TNumber>);
+    get ppqs(): Node<NumberToVec4<TNumber>>;
+    set ppqs(value: Vec4OrLessOrNumber<TNumber>);
+    get zzwy(): Node<NumberToVec4<TNumber>>;
+    set zzwy(value: Vec4OrLessOrNumber<TNumber>);
+    get bbag(): Node<NumberToVec4<TNumber>>;
+    set bbag(value: Vec4OrLessOrNumber<TNumber>);
+    get ppqt(): Node<NumberToVec4<TNumber>>;
+    set ppqt(value: Vec4OrLessOrNumber<TNumber>);
+    get zzwz(): Node<NumberToVec4<TNumber>>;
+    set zzwz(value: Vec4OrLessOrNumber<TNumber>);
+    get bbab(): Node<NumberToVec4<TNumber>>;
+    set bbab(value: Vec4OrLessOrNumber<TNumber>);
+    get ppqp(): Node<NumberToVec4<TNumber>>;
+    set ppqp(value: Vec4OrLessOrNumber<TNumber>);
+    get zzww(): Node<NumberToVec4<TNumber>>;
+    set zzww(value: Vec4OrLessOrNumber<TNumber>);
+    get bbaa(): Node<NumberToVec4<TNumber>>;
+    set bbaa(value: Vec4OrLessOrNumber<TNumber>);
+    get ppqq(): Node<NumberToVec4<TNumber>>;
+    set ppqq(value: Vec4OrLessOrNumber<TNumber>);
+    get zwxx(): Node<NumberToVec4<TNumber>>;
+    set zwxx(value: Vec4OrLessOrNumber<TNumber>);
+    get barr(): Node<NumberToVec4<TNumber>>;
+    set barr(value: Vec4OrLessOrNumber<TNumber>);
+    get pqss(): Node<NumberToVec4<TNumber>>;
+    set pqss(value: Vec4OrLessOrNumber<TNumber>);
+    get zwxy(): Node<NumberToVec4<TNumber>>;
+    set zwxy(value: Vec4OrLessOrNumber<TNumber>);
+    get barg(): Node<NumberToVec4<TNumber>>;
+    set barg(value: Vec4OrLessOrNumber<TNumber>);
+    get pqst(): Node<NumberToVec4<TNumber>>;
+    set pqst(value: Vec4OrLessOrNumber<TNumber>);
+    get zwxz(): Node<NumberToVec4<TNumber>>;
+    set zwxz(value: Vec4OrLessOrNumber<TNumber>);
+    get barb(): Node<NumberToVec4<TNumber>>;
+    set barb(value: Vec4OrLessOrNumber<TNumber>);
+    get pqsp(): Node<NumberToVec4<TNumber>>;
+    set pqsp(value: Vec4OrLessOrNumber<TNumber>);
+    get zwxw(): Node<NumberToVec4<TNumber>>;
+    set zwxw(value: Vec4OrLessOrNumber<TNumber>);
+    get bara(): Node<NumberToVec4<TNumber>>;
+    set bara(value: Vec4OrLessOrNumber<TNumber>);
+    get pqsq(): Node<NumberToVec4<TNumber>>;
+    set pqsq(value: Vec4OrLessOrNumber<TNumber>);
+    get zwyx(): Node<NumberToVec4<TNumber>>;
+    set zwyx(value: Vec4OrLessOrNumber<TNumber>);
+    get bagr(): Node<NumberToVec4<TNumber>>;
+    set bagr(value: Vec4OrLessOrNumber<TNumber>);
+    get pqts(): Node<NumberToVec4<TNumber>>;
+    set pqts(value: Vec4OrLessOrNumber<TNumber>);
+    get zwyy(): Node<NumberToVec4<TNumber>>;
+    set zwyy(value: Vec4OrLessOrNumber<TNumber>);
+    get bagg(): Node<NumberToVec4<TNumber>>;
+    set bagg(value: Vec4OrLessOrNumber<TNumber>);
+    get pqtt(): Node<NumberToVec4<TNumber>>;
+    set pqtt(value: Vec4OrLessOrNumber<TNumber>);
+    get zwyz(): Node<NumberToVec4<TNumber>>;
+    set zwyz(value: Vec4OrLessOrNumber<TNumber>);
+    get bagb(): Node<NumberToVec4<TNumber>>;
+    set bagb(value: Vec4OrLessOrNumber<TNumber>);
+    get pqtp(): Node<NumberToVec4<TNumber>>;
+    set pqtp(value: Vec4OrLessOrNumber<TNumber>);
+    get zwyw(): Node<NumberToVec4<TNumber>>;
+    set zwyw(value: Vec4OrLessOrNumber<TNumber>);
+    get baga(): Node<NumberToVec4<TNumber>>;
+    set baga(value: Vec4OrLessOrNumber<TNumber>);
+    get pqtq(): Node<NumberToVec4<TNumber>>;
+    set pqtq(value: Vec4OrLessOrNumber<TNumber>);
+    get zwzx(): Node<NumberToVec4<TNumber>>;
+    set zwzx(value: Vec4OrLessOrNumber<TNumber>);
+    get babr(): Node<NumberToVec4<TNumber>>;
+    set babr(value: Vec4OrLessOrNumber<TNumber>);
+    get pqps(): Node<NumberToVec4<TNumber>>;
+    set pqps(value: Vec4OrLessOrNumber<TNumber>);
+    get zwzy(): Node<NumberToVec4<TNumber>>;
+    set zwzy(value: Vec4OrLessOrNumber<TNumber>);
+    get babg(): Node<NumberToVec4<TNumber>>;
+    set babg(value: Vec4OrLessOrNumber<TNumber>);
+    get pqpt(): Node<NumberToVec4<TNumber>>;
+    set pqpt(value: Vec4OrLessOrNumber<TNumber>);
+    get zwzz(): Node<NumberToVec4<TNumber>>;
+    set zwzz(value: Vec4OrLessOrNumber<TNumber>);
+    get babb(): Node<NumberToVec4<TNumber>>;
+    set babb(value: Vec4OrLessOrNumber<TNumber>);
+    get pqpp(): Node<NumberToVec4<TNumber>>;
+    set pqpp(value: Vec4OrLessOrNumber<TNumber>);
+    get zwzw(): Node<NumberToVec4<TNumber>>;
+    set zwzw(value: Vec4OrLessOrNumber<TNumber>);
+    get baba(): Node<NumberToVec4<TNumber>>;
+    set baba(value: Vec4OrLessOrNumber<TNumber>);
+    get pqpq(): Node<NumberToVec4<TNumber>>;
+    set pqpq(value: Vec4OrLessOrNumber<TNumber>);
+    get zwwx(): Node<NumberToVec4<TNumber>>;
+    set zwwx(value: Vec4OrLessOrNumber<TNumber>);
+    get baar(): Node<NumberToVec4<TNumber>>;
+    set baar(value: Vec4OrLessOrNumber<TNumber>);
+    get pqqs(): Node<NumberToVec4<TNumber>>;
+    set pqqs(value: Vec4OrLessOrNumber<TNumber>);
+    get zwwy(): Node<NumberToVec4<TNumber>>;
+    set zwwy(value: Vec4OrLessOrNumber<TNumber>);
+    get baag(): Node<NumberToVec4<TNumber>>;
+    set baag(value: Vec4OrLessOrNumber<TNumber>);
+    get pqqt(): Node<NumberToVec4<TNumber>>;
+    set pqqt(value: Vec4OrLessOrNumber<TNumber>);
+    get zwwz(): Node<NumberToVec4<TNumber>>;
+    set zwwz(value: Vec4OrLessOrNumber<TNumber>);
+    get baab(): Node<NumberToVec4<TNumber>>;
+    set baab(value: Vec4OrLessOrNumber<TNumber>);
+    get pqqp(): Node<NumberToVec4<TNumber>>;
+    set pqqp(value: Vec4OrLessOrNumber<TNumber>);
+    get zwww(): Node<NumberToVec4<TNumber>>;
+    set zwww(value: Vec4OrLessOrNumber<TNumber>);
+    get baaa(): Node<NumberToVec4<TNumber>>;
+    set baaa(value: Vec4OrLessOrNumber<TNumber>);
+    get pqqq(): Node<NumberToVec4<TNumber>>;
+    set pqqq(value: Vec4OrLessOrNumber<TNumber>);
+    get wxxx(): Node<NumberToVec4<TNumber>>;
+    set wxxx(value: Vec4OrLessOrNumber<TNumber>);
+    get arrr(): Node<NumberToVec4<TNumber>>;
+    set arrr(value: Vec4OrLessOrNumber<TNumber>);
+    get qsss(): Node<NumberToVec4<TNumber>>;
+    set qsss(value: Vec4OrLessOrNumber<TNumber>);
+    get wxxy(): Node<NumberToVec4<TNumber>>;
+    set wxxy(value: Vec4OrLessOrNumber<TNumber>);
+    get arrg(): Node<NumberToVec4<TNumber>>;
+    set arrg(value: Vec4OrLessOrNumber<TNumber>);
+    get qsst(): Node<NumberToVec4<TNumber>>;
+    set qsst(value: Vec4OrLessOrNumber<TNumber>);
+    get wxxz(): Node<NumberToVec4<TNumber>>;
+    set wxxz(value: Vec4OrLessOrNumber<TNumber>);
+    get arrb(): Node<NumberToVec4<TNumber>>;
+    set arrb(value: Vec4OrLessOrNumber<TNumber>);
+    get qssp(): Node<NumberToVec4<TNumber>>;
+    set qssp(value: Vec4OrLessOrNumber<TNumber>);
+    get wxxw(): Node<NumberToVec4<TNumber>>;
+    set wxxw(value: Vec4OrLessOrNumber<TNumber>);
+    get arra(): Node<NumberToVec4<TNumber>>;
+    set arra(value: Vec4OrLessOrNumber<TNumber>);
+    get qssq(): Node<NumberToVec4<TNumber>>;
+    set qssq(value: Vec4OrLessOrNumber<TNumber>);
+    get wxyx(): Node<NumberToVec4<TNumber>>;
+    set wxyx(value: Vec4OrLessOrNumber<TNumber>);
+    get argr(): Node<NumberToVec4<TNumber>>;
+    set argr(value: Vec4OrLessOrNumber<TNumber>);
+    get qsts(): Node<NumberToVec4<TNumber>>;
+    set qsts(value: Vec4OrLessOrNumber<TNumber>);
+    get wxyy(): Node<NumberToVec4<TNumber>>;
+    set wxyy(value: Vec4OrLessOrNumber<TNumber>);
+    get argg(): Node<NumberToVec4<TNumber>>;
+    set argg(value: Vec4OrLessOrNumber<TNumber>);
+    get qstt(): Node<NumberToVec4<TNumber>>;
+    set qstt(value: Vec4OrLessOrNumber<TNumber>);
+    get wxyz(): Node<NumberToVec4<TNumber>>;
+    set wxyz(value: Vec4OrLessOrNumber<TNumber>);
+    get argb(): Node<NumberToVec4<TNumber>>;
+    set argb(value: Vec4OrLessOrNumber<TNumber>);
+    get qstp(): Node<NumberToVec4<TNumber>>;
+    set qstp(value: Vec4OrLessOrNumber<TNumber>);
+    get wxyw(): Node<NumberToVec4<TNumber>>;
+    set wxyw(value: Vec4OrLessOrNumber<TNumber>);
+    get arga(): Node<NumberToVec4<TNumber>>;
+    set arga(value: Vec4OrLessOrNumber<TNumber>);
+    get qstq(): Node<NumberToVec4<TNumber>>;
+    set qstq(value: Vec4OrLessOrNumber<TNumber>);
+    get wxzx(): Node<NumberToVec4<TNumber>>;
+    set wxzx(value: Vec4OrLessOrNumber<TNumber>);
+    get arbr(): Node<NumberToVec4<TNumber>>;
+    set arbr(value: Vec4OrLessOrNumber<TNumber>);
+    get qsps(): Node<NumberToVec4<TNumber>>;
+    set qsps(value: Vec4OrLessOrNumber<TNumber>);
+    get wxzy(): Node<NumberToVec4<TNumber>>;
+    set wxzy(value: Vec4OrLessOrNumber<TNumber>);
+    get arbg(): Node<NumberToVec4<TNumber>>;
+    set arbg(value: Vec4OrLessOrNumber<TNumber>);
+    get qspt(): Node<NumberToVec4<TNumber>>;
+    set qspt(value: Vec4OrLessOrNumber<TNumber>);
+    get wxzz(): Node<NumberToVec4<TNumber>>;
+    set wxzz(value: Vec4OrLessOrNumber<TNumber>);
+    get arbb(): Node<NumberToVec4<TNumber>>;
+    set arbb(value: Vec4OrLessOrNumber<TNumber>);
+    get qspp(): Node<NumberToVec4<TNumber>>;
+    set qspp(value: Vec4OrLessOrNumber<TNumber>);
+    get wxzw(): Node<NumberToVec4<TNumber>>;
+    set wxzw(value: Vec4OrLessOrNumber<TNumber>);
+    get arba(): Node<NumberToVec4<TNumber>>;
+    set arba(value: Vec4OrLessOrNumber<TNumber>);
+    get qspq(): Node<NumberToVec4<TNumber>>;
+    set qspq(value: Vec4OrLessOrNumber<TNumber>);
+    get wxwx(): Node<NumberToVec4<TNumber>>;
+    set wxwx(value: Vec4OrLessOrNumber<TNumber>);
+    get arar(): Node<NumberToVec4<TNumber>>;
+    set arar(value: Vec4OrLessOrNumber<TNumber>);
+    get qsqs(): Node<NumberToVec4<TNumber>>;
+    set qsqs(value: Vec4OrLessOrNumber<TNumber>);
+    get wxwy(): Node<NumberToVec4<TNumber>>;
+    set wxwy(value: Vec4OrLessOrNumber<TNumber>);
+    get arag(): Node<NumberToVec4<TNumber>>;
+    set arag(value: Vec4OrLessOrNumber<TNumber>);
+    get qsqt(): Node<NumberToVec4<TNumber>>;
+    set qsqt(value: Vec4OrLessOrNumber<TNumber>);
+    get wxwz(): Node<NumberToVec4<TNumber>>;
+    set wxwz(value: Vec4OrLessOrNumber<TNumber>);
+    get arab(): Node<NumberToVec4<TNumber>>;
+    set arab(value: Vec4OrLessOrNumber<TNumber>);
+    get qsqp(): Node<NumberToVec4<TNumber>>;
+    set qsqp(value: Vec4OrLessOrNumber<TNumber>);
+    get wxww(): Node<NumberToVec4<TNumber>>;
+    set wxww(value: Vec4OrLessOrNumber<TNumber>);
+    get araa(): Node<NumberToVec4<TNumber>>;
+    set araa(value: Vec4OrLessOrNumber<TNumber>);
+    get qsqq(): Node<NumberToVec4<TNumber>>;
+    set qsqq(value: Vec4OrLessOrNumber<TNumber>);
+    get wyxx(): Node<NumberToVec4<TNumber>>;
+    set wyxx(value: Vec4OrLessOrNumber<TNumber>);
+    get agrr(): Node<NumberToVec4<TNumber>>;
+    set agrr(value: Vec4OrLessOrNumber<TNumber>);
+    get qtss(): Node<NumberToVec4<TNumber>>;
+    set qtss(value: Vec4OrLessOrNumber<TNumber>);
+    get wyxy(): Node<NumberToVec4<TNumber>>;
+    set wyxy(value: Vec4OrLessOrNumber<TNumber>);
+    get agrg(): Node<NumberToVec4<TNumber>>;
+    set agrg(value: Vec4OrLessOrNumber<TNumber>);
+    get qtst(): Node<NumberToVec4<TNumber>>;
+    set qtst(value: Vec4OrLessOrNumber<TNumber>);
+    get wyxz(): Node<NumberToVec4<TNumber>>;
+    set wyxz(value: Vec4OrLessOrNumber<TNumber>);
+    get agrb(): Node<NumberToVec4<TNumber>>;
+    set agrb(value: Vec4OrLessOrNumber<TNumber>);
+    get qtsp(): Node<NumberToVec4<TNumber>>;
+    set qtsp(value: Vec4OrLessOrNumber<TNumber>);
+    get wyxw(): Node<NumberToVec4<TNumber>>;
+    set wyxw(value: Vec4OrLessOrNumber<TNumber>);
+    get agra(): Node<NumberToVec4<TNumber>>;
+    set agra(value: Vec4OrLessOrNumber<TNumber>);
+    get qtsq(): Node<NumberToVec4<TNumber>>;
+    set qtsq(value: Vec4OrLessOrNumber<TNumber>);
+    get wyyx(): Node<NumberToVec4<TNumber>>;
+    set wyyx(value: Vec4OrLessOrNumber<TNumber>);
+    get aggr(): Node<NumberToVec4<TNumber>>;
+    set aggr(value: Vec4OrLessOrNumber<TNumber>);
+    get qtts(): Node<NumberToVec4<TNumber>>;
+    set qtts(value: Vec4OrLessOrNumber<TNumber>);
+    get wyyy(): Node<NumberToVec4<TNumber>>;
+    set wyyy(value: Vec4OrLessOrNumber<TNumber>);
+    get aggg(): Node<NumberToVec4<TNumber>>;
+    set aggg(value: Vec4OrLessOrNumber<TNumber>);
+    get qttt(): Node<NumberToVec4<TNumber>>;
+    set qttt(value: Vec4OrLessOrNumber<TNumber>);
+    get wyyz(): Node<NumberToVec4<TNumber>>;
+    set wyyz(value: Vec4OrLessOrNumber<TNumber>);
+    get aggb(): Node<NumberToVec4<TNumber>>;
+    set aggb(value: Vec4OrLessOrNumber<TNumber>);
+    get qttp(): Node<NumberToVec4<TNumber>>;
+    set qttp(value: Vec4OrLessOrNumber<TNumber>);
+    get wyyw(): Node<NumberToVec4<TNumber>>;
+    set wyyw(value: Vec4OrLessOrNumber<TNumber>);
+    get agga(): Node<NumberToVec4<TNumber>>;
+    set agga(value: Vec4OrLessOrNumber<TNumber>);
+    get qttq(): Node<NumberToVec4<TNumber>>;
+    set qttq(value: Vec4OrLessOrNumber<TNumber>);
+    get wyzx(): Node<NumberToVec4<TNumber>>;
+    set wyzx(value: Vec4OrLessOrNumber<TNumber>);
+    get agbr(): Node<NumberToVec4<TNumber>>;
+    set agbr(value: Vec4OrLessOrNumber<TNumber>);
+    get qtps(): Node<NumberToVec4<TNumber>>;
+    set qtps(value: Vec4OrLessOrNumber<TNumber>);
+    get wyzy(): Node<NumberToVec4<TNumber>>;
+    set wyzy(value: Vec4OrLessOrNumber<TNumber>);
+    get agbg(): Node<NumberToVec4<TNumber>>;
+    set agbg(value: Vec4OrLessOrNumber<TNumber>);
+    get qtpt(): Node<NumberToVec4<TNumber>>;
+    set qtpt(value: Vec4OrLessOrNumber<TNumber>);
+    get wyzz(): Node<NumberToVec4<TNumber>>;
+    set wyzz(value: Vec4OrLessOrNumber<TNumber>);
+    get agbb(): Node<NumberToVec4<TNumber>>;
+    set agbb(value: Vec4OrLessOrNumber<TNumber>);
+    get qtpp(): Node<NumberToVec4<TNumber>>;
+    set qtpp(value: Vec4OrLessOrNumber<TNumber>);
+    get wyzw(): Node<NumberToVec4<TNumber>>;
+    set wyzw(value: Vec4OrLessOrNumber<TNumber>);
+    get agba(): Node<NumberToVec4<TNumber>>;
+    set agba(value: Vec4OrLessOrNumber<TNumber>);
+    get qtpq(): Node<NumberToVec4<TNumber>>;
+    set qtpq(value: Vec4OrLessOrNumber<TNumber>);
+    get wywx(): Node<NumberToVec4<TNumber>>;
+    set wywx(value: Vec4OrLessOrNumber<TNumber>);
+    get agar(): Node<NumberToVec4<TNumber>>;
+    set agar(value: Vec4OrLessOrNumber<TNumber>);
+    get qtqs(): Node<NumberToVec4<TNumber>>;
+    set qtqs(value: Vec4OrLessOrNumber<TNumber>);
+    get wywy(): Node<NumberToVec4<TNumber>>;
+    set wywy(value: Vec4OrLessOrNumber<TNumber>);
+    get agag(): Node<NumberToVec4<TNumber>>;
+    set agag(value: Vec4OrLessOrNumber<TNumber>);
+    get qtqt(): Node<NumberToVec4<TNumber>>;
+    set qtqt(value: Vec4OrLessOrNumber<TNumber>);
+    get wywz(): Node<NumberToVec4<TNumber>>;
+    set wywz(value: Vec4OrLessOrNumber<TNumber>);
+    get agab(): Node<NumberToVec4<TNumber>>;
+    set agab(value: Vec4OrLessOrNumber<TNumber>);
+    get qtqp(): Node<NumberToVec4<TNumber>>;
+    set qtqp(value: Vec4OrLessOrNumber<TNumber>);
+    get wyww(): Node<NumberToVec4<TNumber>>;
+    set wyww(value: Vec4OrLessOrNumber<TNumber>);
+    get agaa(): Node<NumberToVec4<TNumber>>;
+    set agaa(value: Vec4OrLessOrNumber<TNumber>);
+    get qtqq(): Node<NumberToVec4<TNumber>>;
+    set qtqq(value: Vec4OrLessOrNumber<TNumber>);
+    get wzxx(): Node<NumberToVec4<TNumber>>;
+    set wzxx(value: Vec4OrLessOrNumber<TNumber>);
+    get abrr(): Node<NumberToVec4<TNumber>>;
+    set abrr(value: Vec4OrLessOrNumber<TNumber>);
+    get qpss(): Node<NumberToVec4<TNumber>>;
+    set qpss(value: Vec4OrLessOrNumber<TNumber>);
+    get wzxy(): Node<NumberToVec4<TNumber>>;
+    set wzxy(value: Vec4OrLessOrNumber<TNumber>);
+    get abrg(): Node<NumberToVec4<TNumber>>;
+    set abrg(value: Vec4OrLessOrNumber<TNumber>);
+    get qpst(): Node<NumberToVec4<TNumber>>;
+    set qpst(value: Vec4OrLessOrNumber<TNumber>);
+    get wzxz(): Node<NumberToVec4<TNumber>>;
+    set wzxz(value: Vec4OrLessOrNumber<TNumber>);
+    get abrb(): Node<NumberToVec4<TNumber>>;
+    set abrb(value: Vec4OrLessOrNumber<TNumber>);
+    get qpsp(): Node<NumberToVec4<TNumber>>;
+    set qpsp(value: Vec4OrLessOrNumber<TNumber>);
+    get wzxw(): Node<NumberToVec4<TNumber>>;
+    set wzxw(value: Vec4OrLessOrNumber<TNumber>);
+    get abra(): Node<NumberToVec4<TNumber>>;
+    set abra(value: Vec4OrLessOrNumber<TNumber>);
+    get qpsq(): Node<NumberToVec4<TNumber>>;
+    set qpsq(value: Vec4OrLessOrNumber<TNumber>);
+    get wzyx(): Node<NumberToVec4<TNumber>>;
+    set wzyx(value: Vec4OrLessOrNumber<TNumber>);
+    get abgr(): Node<NumberToVec4<TNumber>>;
+    set abgr(value: Vec4OrLessOrNumber<TNumber>);
+    get qpts(): Node<NumberToVec4<TNumber>>;
+    set qpts(value: Vec4OrLessOrNumber<TNumber>);
+    get wzyy(): Node<NumberToVec4<TNumber>>;
+    set wzyy(value: Vec4OrLessOrNumber<TNumber>);
+    get abgg(): Node<NumberToVec4<TNumber>>;
+    set abgg(value: Vec4OrLessOrNumber<TNumber>);
+    get qptt(): Node<NumberToVec4<TNumber>>;
+    set qptt(value: Vec4OrLessOrNumber<TNumber>);
+    get wzyz(): Node<NumberToVec4<TNumber>>;
+    set wzyz(value: Vec4OrLessOrNumber<TNumber>);
+    get abgb(): Node<NumberToVec4<TNumber>>;
+    set abgb(value: Vec4OrLessOrNumber<TNumber>);
+    get qptp(): Node<NumberToVec4<TNumber>>;
+    set qptp(value: Vec4OrLessOrNumber<TNumber>);
+    get wzyw(): Node<NumberToVec4<TNumber>>;
+    set wzyw(value: Vec4OrLessOrNumber<TNumber>);
+    get abga(): Node<NumberToVec4<TNumber>>;
+    set abga(value: Vec4OrLessOrNumber<TNumber>);
+    get qptq(): Node<NumberToVec4<TNumber>>;
+    set qptq(value: Vec4OrLessOrNumber<TNumber>);
+    get wzzx(): Node<NumberToVec4<TNumber>>;
+    set wzzx(value: Vec4OrLessOrNumber<TNumber>);
+    get abbr(): Node<NumberToVec4<TNumber>>;
+    set abbr(value: Vec4OrLessOrNumber<TNumber>);
+    get qpps(): Node<NumberToVec4<TNumber>>;
+    set qpps(value: Vec4OrLessOrNumber<TNumber>);
+    get wzzy(): Node<NumberToVec4<TNumber>>;
+    set wzzy(value: Vec4OrLessOrNumber<TNumber>);
+    get abbg(): Node<NumberToVec4<TNumber>>;
+    set abbg(value: Vec4OrLessOrNumber<TNumber>);
+    get qppt(): Node<NumberToVec4<TNumber>>;
+    set qppt(value: Vec4OrLessOrNumber<TNumber>);
+    get wzzz(): Node<NumberToVec4<TNumber>>;
+    set wzzz(value: Vec4OrLessOrNumber<TNumber>);
+    get abbb(): Node<NumberToVec4<TNumber>>;
+    set abbb(value: Vec4OrLessOrNumber<TNumber>);
+    get qppp(): Node<NumberToVec4<TNumber>>;
+    set qppp(value: Vec4OrLessOrNumber<TNumber>);
+    get wzzw(): Node<NumberToVec4<TNumber>>;
+    set wzzw(value: Vec4OrLessOrNumber<TNumber>);
+    get abba(): Node<NumberToVec4<TNumber>>;
+    set abba(value: Vec4OrLessOrNumber<TNumber>);
+    get qppq(): Node<NumberToVec4<TNumber>>;
+    set qppq(value: Vec4OrLessOrNumber<TNumber>);
+    get wzwx(): Node<NumberToVec4<TNumber>>;
+    set wzwx(value: Vec4OrLessOrNumber<TNumber>);
+    get abar(): Node<NumberToVec4<TNumber>>;
+    set abar(value: Vec4OrLessOrNumber<TNumber>);
+    get qpqs(): Node<NumberToVec4<TNumber>>;
+    set qpqs(value: Vec4OrLessOrNumber<TNumber>);
+    get wzwy(): Node<NumberToVec4<TNumber>>;
+    set wzwy(value: Vec4OrLessOrNumber<TNumber>);
+    get abag(): Node<NumberToVec4<TNumber>>;
+    set abag(value: Vec4OrLessOrNumber<TNumber>);
+    get qpqt(): Node<NumberToVec4<TNumber>>;
+    set qpqt(value: Vec4OrLessOrNumber<TNumber>);
+    get wzwz(): Node<NumberToVec4<TNumber>>;
+    set wzwz(value: Vec4OrLessOrNumber<TNumber>);
+    get abab(): Node<NumberToVec4<TNumber>>;
+    set abab(value: Vec4OrLessOrNumber<TNumber>);
+    get qpqp(): Node<NumberToVec4<TNumber>>;
+    set qpqp(value: Vec4OrLessOrNumber<TNumber>);
+    get wzww(): Node<NumberToVec4<TNumber>>;
+    set wzww(value: Vec4OrLessOrNumber<TNumber>);
+    get abaa(): Node<NumberToVec4<TNumber>>;
+    set abaa(value: Vec4OrLessOrNumber<TNumber>);
+    get qpqq(): Node<NumberToVec4<TNumber>>;
+    set qpqq(value: Vec4OrLessOrNumber<TNumber>);
+    get wwxx(): Node<NumberToVec4<TNumber>>;
+    set wwxx(value: Vec4OrLessOrNumber<TNumber>);
+    get aarr(): Node<NumberToVec4<TNumber>>;
+    set aarr(value: Vec4OrLessOrNumber<TNumber>);
+    get qqss(): Node<NumberToVec4<TNumber>>;
+    set qqss(value: Vec4OrLessOrNumber<TNumber>);
+    get wwxy(): Node<NumberToVec4<TNumber>>;
+    set wwxy(value: Vec4OrLessOrNumber<TNumber>);
+    get aarg(): Node<NumberToVec4<TNumber>>;
+    set aarg(value: Vec4OrLessOrNumber<TNumber>);
+    get qqst(): Node<NumberToVec4<TNumber>>;
+    set qqst(value: Vec4OrLessOrNumber<TNumber>);
+    get wwxz(): Node<NumberToVec4<TNumber>>;
+    set wwxz(value: Vec4OrLessOrNumber<TNumber>);
+    get aarb(): Node<NumberToVec4<TNumber>>;
+    set aarb(value: Vec4OrLessOrNumber<TNumber>);
+    get qqsp(): Node<NumberToVec4<TNumber>>;
+    set qqsp(value: Vec4OrLessOrNumber<TNumber>);
+    get wwxw(): Node<NumberToVec4<TNumber>>;
+    set wwxw(value: Vec4OrLessOrNumber<TNumber>);
+    get aara(): Node<NumberToVec4<TNumber>>;
+    set aara(value: Vec4OrLessOrNumber<TNumber>);
+    get qqsq(): Node<NumberToVec4<TNumber>>;
+    set qqsq(value: Vec4OrLessOrNumber<TNumber>);
+    get wwyx(): Node<NumberToVec4<TNumber>>;
+    set wwyx(value: Vec4OrLessOrNumber<TNumber>);
+    get aagr(): Node<NumberToVec4<TNumber>>;
+    set aagr(value: Vec4OrLessOrNumber<TNumber>);
+    get qqts(): Node<NumberToVec4<TNumber>>;
+    set qqts(value: Vec4OrLessOrNumber<TNumber>);
+    get wwyy(): Node<NumberToVec4<TNumber>>;
+    set wwyy(value: Vec4OrLessOrNumber<TNumber>);
+    get aagg(): Node<NumberToVec4<TNumber>>;
+    set aagg(value: Vec4OrLessOrNumber<TNumber>);
+    get qqtt(): Node<NumberToVec4<TNumber>>;
+    set qqtt(value: Vec4OrLessOrNumber<TNumber>);
+    get wwyz(): Node<NumberToVec4<TNumber>>;
+    set wwyz(value: Vec4OrLessOrNumber<TNumber>);
+    get aagb(): Node<NumberToVec4<TNumber>>;
+    set aagb(value: Vec4OrLessOrNumber<TNumber>);
+    get qqtp(): Node<NumberToVec4<TNumber>>;
+    set qqtp(value: Vec4OrLessOrNumber<TNumber>);
+    get wwyw(): Node<NumberToVec4<TNumber>>;
+    set wwyw(value: Vec4OrLessOrNumber<TNumber>);
+    get aaga(): Node<NumberToVec4<TNumber>>;
+    set aaga(value: Vec4OrLessOrNumber<TNumber>);
+    get qqtq(): Node<NumberToVec4<TNumber>>;
+    set qqtq(value: Vec4OrLessOrNumber<TNumber>);
+    get wwzx(): Node<NumberToVec4<TNumber>>;
+    set wwzx(value: Vec4OrLessOrNumber<TNumber>);
+    get aabr(): Node<NumberToVec4<TNumber>>;
+    set aabr(value: Vec4OrLessOrNumber<TNumber>);
+    get qqps(): Node<NumberToVec4<TNumber>>;
+    set qqps(value: Vec4OrLessOrNumber<TNumber>);
+    get wwzy(): Node<NumberToVec4<TNumber>>;
+    set wwzy(value: Vec4OrLessOrNumber<TNumber>);
+    get aabg(): Node<NumberToVec4<TNumber>>;
+    set aabg(value: Vec4OrLessOrNumber<TNumber>);
+    get qqpt(): Node<NumberToVec4<TNumber>>;
+    set qqpt(value: Vec4OrLessOrNumber<TNumber>);
+    get wwzz(): Node<NumberToVec4<TNumber>>;
+    set wwzz(value: Vec4OrLessOrNumber<TNumber>);
+    get aabb(): Node<NumberToVec4<TNumber>>;
+    set aabb(value: Vec4OrLessOrNumber<TNumber>);
+    get qqpp(): Node<NumberToVec4<TNumber>>;
+    set qqpp(value: Vec4OrLessOrNumber<TNumber>);
+    get wwzw(): Node<NumberToVec4<TNumber>>;
+    set wwzw(value: Vec4OrLessOrNumber<TNumber>);
+    get aaba(): Node<NumberToVec4<TNumber>>;
+    set aaba(value: Vec4OrLessOrNumber<TNumber>);
+    get qqpq(): Node<NumberToVec4<TNumber>>;
+    set qqpq(value: Vec4OrLessOrNumber<TNumber>);
+    get wwwx(): Node<NumberToVec4<TNumber>>;
+    set wwwx(value: Vec4OrLessOrNumber<TNumber>);
+    get aaar(): Node<NumberToVec4<TNumber>>;
+    set aaar(value: Vec4OrLessOrNumber<TNumber>);
+    get qqqs(): Node<NumberToVec4<TNumber>>;
+    set qqqs(value: Vec4OrLessOrNumber<TNumber>);
+    get wwwy(): Node<NumberToVec4<TNumber>>;
+    set wwwy(value: Vec4OrLessOrNumber<TNumber>);
+    get aaag(): Node<NumberToVec4<TNumber>>;
+    set aaag(value: Vec4OrLessOrNumber<TNumber>);
+    get qqqt(): Node<NumberToVec4<TNumber>>;
+    set qqqt(value: Vec4OrLessOrNumber<TNumber>);
+    get wwwz(): Node<NumberToVec4<TNumber>>;
+    set wwwz(value: Vec4OrLessOrNumber<TNumber>);
+    get aaab(): Node<NumberToVec4<TNumber>>;
+    set aaab(value: Vec4OrLessOrNumber<TNumber>);
+    get qqqp(): Node<NumberToVec4<TNumber>>;
+    set qqqp(value: Vec4OrLessOrNumber<TNumber>);
+    get wwww(): Node<NumberToVec4<TNumber>>;
+    set wwww(value: Vec4OrLessOrNumber<TNumber>);
+    get aaaa(): Node<NumberToVec4<TNumber>>;
+    set aaaa(value: Vec4OrLessOrNumber<TNumber>);
+    get qqqq(): Node<NumberToVec4<TNumber>>;
+    set qqqq(value: Vec4OrLessOrNumber<TNumber>);
+}
+
+type X = 'x';
+type R = 'r';
+type S = 's';
+type NumberSwizzleMethods<TNumber extends NumberType> = {
+    [Key in X | R | S as `set${Uppercase<Key>}`]: (value: Vec4OrLessOrNumber<TNumber>) => Node<TNumber>;
+} & {
+    [Key in X | R | S as `flip${Uppercase<Key>}`]: () => Node<TNumber>;
+} & {
+    [Key in `${X}${X}` | `${R}${R}` | `${S}${S}` as `set${Uppercase<Key>}`]: (
+        value: Vec4OrLessOrNumber<TNumber>,
+    ) => Node<TNumber>;
+} & {
+    [Key in `${X}${X}` | `${R}${R}` | `${S}${S}` as `flip${Uppercase<Key>}`]: () => Node<TNumber>;
+} & {
+    [Key in `${X}${X}${X}` | `${R}${R}${R}` | `${S}${S}${S}` as `set${Uppercase<Key>}`]: (
+        value: Vec4OrLessOrNumber<TNumber>,
+    ) => Node<TNumber>;
+} & {
+    [Key in `${X}${X}${X}` | `${R}${R}${R}` | `${S}${S}${S}` as `flip${Uppercase<Key>}`]: () => Node<TNumber>;
+} & {
+    [Key in `${X}${X}${X}${X}` | `${R}${R}${R}${R}` | `${S}${S}${S}${S}` as `set${Uppercase<Key>}`]: (
+        value: Vec4OrLessOrNumber<TNumber>,
+    ) => Node<TNumber>;
+} & {
+    [Key in
+        | `${X}${X}${X}${X}`
+        | `${R}${R}${R}${R}`
+        | `${S}${S}${S}${S}` as `flip${Uppercase<Key>}`]: () => Node<TNumber>;
+};
+
+type XY = 'x' | 'y';
+type RG = 'r' | 'g';
+type ST = 's' | 't';
+type Vec2SwizzleMethods<TNumber extends NumberType> = {
+    [Key in XY | RG | ST as `set${Uppercase<Key>}`]: (
+        value: Vec4OrLessOrNumber<TNumber>,
+    ) => Node<NumberToVec2<TNumber>>;
+} & {
+    [Key in XY | RG | ST as `flip${Uppercase<Key>}`]: () => Node<NumberToVec2<TNumber>>;
+} & {
+    [Key in `${XY}${XY}` | `${RG}${RG}` | `${ST}${ST}` as `set${Uppercase<Key>}`]: (
+        value: Vec4OrLessOrNumber<TNumber>,
+    ) => Node<NumberToVec2<TNumber>>;
+} & {
+    [Key in `${XY}${XY}` | `${RG}${RG}` | `${ST}${ST}` as `flip${Uppercase<Key>}`]: () => Node<NumberToVec2<TNumber>>;
+} & {
+    [Key in `${XY}${XY}${XY}` | `${RG}${RG}${RG}` | `${ST}${ST}${ST}` as `set${Uppercase<Key>}`]: (
+        value: Vec4OrLessOrNumber<TNumber>,
+    ) => Node<NumberToVec2<TNumber>>;
+} & {
+    [Key in `${XY}${XY}${XY}` | `${RG}${RG}${RG}` | `${ST}${ST}${ST}` as `flip${Uppercase<Key>}`]: () => Node<
+        NumberToVec2<TNumber>
+    >;
+} & {
+    [Key in `${XY}${XY}${XY}${XY}` | `${RG}${RG}${RG}${RG}` | `${ST}${ST}${ST}${ST}` as `set${Uppercase<Key>}`]: (
+        value: Vec4OrLessOrNumber<TNumber>,
+    ) => Node<NumberToVec2<TNumber>>;
+} & {
+    [Key in
+        | `${XY}${XY}${XY}${XY}`
+        | `${RG}${RG}${RG}${RG}`
+        | `${ST}${ST}${ST}${ST}` as `flip${Uppercase<Key>}`]: () => Node<NumberToVec2<TNumber>>;
+};
+
+type XYZ = 'x' | 'y' | 'z';
+type RGB = 'r' | 'g' | 'b';
+type STP = 's' | 't' | 'p';
+
+type Vec3SwizzleMethods<TNumber extends NumberType> = {
+    [Key in XYZ | RGB | STP as `set${Uppercase<Key>}`]: (
+        value: Vec4OrLessOrNumber<TNumber>,
+    ) => Node<NumberToVec3<TNumber>>;
+} & {
+    [Key in XYZ | RGB | STP as `flip${Uppercase<Key>}`]: () => Node<NumberToVec3<TNumber>>;
+} & {
+    [Key in `${XYZ}${XYZ}` | `${RGB}${RGB}` | `${STP}${STP}` as `set${Uppercase<Key>}`]: (
+        value: Vec4OrLessOrNumber<TNumber>,
+    ) => Node<NumberToVec3<TNumber>>;
+} & {
+    [Key in `${XYZ}${XYZ}` | `${RGB}${RGB}` | `${STP}${STP}` as `flip${Uppercase<Key>}`]: () => Node<
+        NumberToVec3<TNumber>
+    >;
+} & {
+    [Key in `${XYZ}${XYZ}${XYZ}` | `${RGB}${RGB}${RGB}` | `${STP}${STP}${STP}` as `set${Uppercase<Key>}`]: (
+        value: Vec4OrLessOrNumber<TNumber>,
+    ) => Node<NumberToVec3<TNumber>>;
+} & {
+    [Key in `${XYZ}${XYZ}${XYZ}` | `${RGB}${RGB}${RGB}` | `${STP}${STP}${STP}` as `flip${Uppercase<Key>}`]: () => Node<
+        NumberToVec3<TNumber>
+    >;
+} & {
+    [Key in
+        | `${XYZ}${XYZ}${XYZ}${XYZ}`
+        | `${RGB}${RGB}${RGB}${RGB}`
+        | `${STP}${STP}${STP}${STP}` as `set${Uppercase<Key>}`]: (
+        value: Vec4OrLessOrNumber<TNumber>,
+    ) => Node<NumberToVec3<TNumber>>;
+} & {
+    [Key in
+        | `${XYZ}${XYZ}${XYZ}${XYZ}`
+        | `${RGB}${RGB}${RGB}${RGB}`
+        | `${STP}${STP}${STP}${STP}` as `flip${Uppercase<Key>}`]: () => Node<NumberToVec3<TNumber>>;
+};
+
+type XYZW = 'x' | 'y' | 'z' | 'w';
+type RGBA = 'r' | 'g' | 'b' | 'a';
+type STPQ = 's' | 't' | 'p' | 'q';
+
+type Vec4SwizzleMethods<TNumber extends NumberType> = {
+    [Key in XYZW | RGBA | STPQ as `set${Uppercase<Key>}`]: (
+        value: Vec4OrLessOrNumber<TNumber>,
+    ) => Node<NumberToVec4<TNumber>>;
+} & {
+    [Key in XYZW | RGBA | STPQ as `flip${Uppercase<Key>}`]: () => Node<NumberToVec4<TNumber>>;
+} & {
+    [Key in `${XYZW}${XYZW}` | `${RGBA}${RGBA}` | `${STPQ}${STPQ}` as `set${Uppercase<Key>}`]: (
+        value: Vec4OrLessOrNumber<TNumber>,
+    ) => Node<NumberToVec4<TNumber>>;
+} & {
+    [Key in `${XYZW}${XYZW}` | `${RGBA}${RGBA}` | `${STPQ}${STPQ}` as `flip${Uppercase<Key>}`]: () => Node<
+        NumberToVec4<TNumber>
+    >;
+} & {
+    [Key in `${XYZW}${XYZW}${XYZW}` | `${RGBA}${RGBA}${RGBA}` | `${STPQ}${STPQ}${STPQ}` as `set${Uppercase<Key>}`]: (
+        value: Vec4OrLessOrNumber<TNumber>,
+    ) => Node<NumberToVec4<TNumber>>;
+} & {
+    [Key in
+        | `${XYZW}${XYZW}${XYZW}`
+        | `${RGBA}${RGBA}${RGBA}`
+        | `${STPQ}${STPQ}${STPQ}` as `flip${Uppercase<Key>}`]: () => Node<NumberToVec4<TNumber>>;
+} & {
+    [Key in
+        | `${XYZW}${XYZW}${XYZW}${XYZW}`
+        | `${RGBA}${RGBA}${RGBA}${RGBA}`
+        | `${STPQ}${STPQ}${STPQ}${STPQ}` as `set${Uppercase<Key>}`]: (
+        value: Vec4OrLessOrNumber<TNumber>,
+    ) => Node<NumberToVec4<TNumber>>;
+} & {
+    [Key in
+        | `${XYZW}${XYZW}${XYZW}${XYZW}`
+        | `${RGBA}${RGBA}${RGBA}${RGBA}`
+        | `${STPQ}${STPQ}${STPQ}${STPQ}` as `flip${Uppercase<Key>}`]: () => Node<NumberToVec4<TNumber>>;
+};
+
+interface NumberSwizzle<TNumber extends NumberType>
+    extends Swizzle1In1Out<TNumber>,
+        Swizzle1In2Out<TNumber>,
+        Swizzle1In3Out<TNumber>,
+        Swizzle1In4Out<TNumber>,
+        NumberSwizzleMethods<TNumber> {}
+
+interface Vec2Swizzle<TNumber extends NumberType>
+    extends Swizzle2In1Out<TNumber>,
+        Swizzle2In2Out<TNumber>,
+        Swizzle2In3Out<TNumber>,
+        Swizzle2In4Out<TNumber>,
+        Vec2SwizzleMethods<TNumber> {}
+
+interface Vec3Swizzle<TNumber extends NumberType>
+    extends Swizzle3In1Out<TNumber>,
+        Swizzle3In2Out<TNumber>,
+        Swizzle3In3Out<TNumber>,
+        Swizzle3In4Out<TNumber>,
+        Vec3SwizzleMethods<TNumber> {}
+
+interface Vec4Swizzle<TNumber extends NumberType>
+    extends Swizzle4In1Out<TNumber>,
+        Swizzle4In2Out<TNumber>,
+        Swizzle4In3Out<TNumber>,
+        Swizzle4In4Out<TNumber>,
+        Vec4SwizzleMethods<TNumber> {}
+
+export type NumberType = 'float' | 'int' | 'uint';
+export type IntegerType = 'int' | 'uint';
+export type FloatVectorType = 'vec2' | 'vec3' | 'vec4';
+export type MatrixType = 'mat2' | 'mat3' | 'mat4';
+export interface NodeExtensions<TValue> {}
+export interface FloatExtensions {}
+export interface IntExtensions {}
+export interface UintExtensions {}
+export interface NumberExtensions<TNumber extends NumberType> {}
+export interface IntegerExtensions<TInteger extends IntegerType> {}
+export interface BoolExtensions {}
+export interface Vec2Extensions {}
+export interface Ivec2Extensions {}
+export interface Uvec2Extensions {}
+export interface Vector2Extensions<TNumber extends NumberType> {}
+export interface Vec3Extensions {}
+export interface Ivec3Extensions {}
+export interface Uvec3Extensions {}
+export interface Vector3Extensions<TNumber extends NumberType> {}
+export interface Vec4Extensions {}
+export interface Ivec4Extensions {}
+export interface Uvec4Extensions {}
+export interface Vector4Extensions<TNumber extends NumberType> {}
+export interface FloatVectorExtensions<TVec extends FloatVectorType> {}
+export interface BvecExtensions {}
+export interface Matrix2Extensions {}
+export interface Matrix3Extensions {}
+export interface Matrix4Extensions {}
+export interface MatrixExtensions<TMat extends MatrixType> {}
+export interface ColorExtensions {}
+type Node<TValue = unknown> = NodeClass &
+    NodeElements &
+    NodeExtensions<TValue> &
+    (TValue extends 'float'
+        ? NumberSwizzle<'float'> & FloatExtensions & NumberExtensions<'float'>
+        : TValue extends 'int'
+          ? NumberSwizzle<'int'> & IntExtensions & NumberExtensions<'int'> & IntegerExtensions<'int'>
+          : TValue extends 'uint'
+            ? NumberSwizzle<'uint'> & UintExtensions & NumberExtensions<'uint'> & IntegerExtensions<'uint'>
+            : TValue extends 'bool'
+              ? BoolExtensions
+              : TValue extends 'vec2'
+                ? Vec2Swizzle<'float'> & Vec2Extensions & Vector2Extensions<'float'> & FloatVectorExtensions<'vec2'>
+                : TValue extends 'ivec2'
+                  ? Vec2Swizzle<'int'> & Ivec2Extensions & Vector2Extensions<'int'>
+                  : TValue extends 'uvec2'
+                    ? Vec2Swizzle<'uint'> & Uvec2Extensions & Vector2Extensions<'uint'>
+                    : TValue extends 'bvec2'
+                      ? BvecExtensions
+                      : TValue extends 'vec3'
+                        ? Vec3Swizzle<'float'> &
+                              Vec3Extensions &
+                              Vector3Extensions<'float'> &
+                              FloatVectorExtensions<'vec3'>
+                        : TValue extends 'ivec3'
+                          ? Vec3Swizzle<'int'> & Ivec3Extensions & Vector3Extensions<'int'>
+                          : TValue extends 'uvec3'
+                            ? Vec3Swizzle<'uint'> & Uvec3Extensions & Vector3Extensions<'uint'>
+                            : TValue extends 'bvec3'
+                              ? BvecExtensions
+                              : TValue extends 'vec4'
+                                ? Vec4Swizzle<'float'> &
+                                      Vec4Extensions &
+                                      Vector4Extensions<'float'> &
+                                      FloatVectorExtensions<'vec4'>
+                                : TValue extends 'ivec4'
+                                  ? Vec4Swizzle<'int'> & Ivec4Extensions & Vector4Extensions<'int'>
+                                  : TValue extends 'uvec4'
+                                    ? Vec4Swizzle<'uint'> & Uvec4Extensions & Vector4Extensions<'uint'>
+                                    : TValue extends 'bvec4'
+                                      ? BvecExtensions
+                                      : TValue extends 'mat2'
+                                        ? Matrix2Extensions & MatrixExtensions<'mat2'>
+                                        : TValue extends 'mat3'
+                                          ? Matrix3Extensions & MatrixExtensions<'mat3'>
+                                          : TValue extends 'mat4'
+                                            ? Matrix4Extensions & MatrixExtensions<'mat4'>
+                                            : TValue extends 'color'
+                                              ? Vec3Swizzle<'float'> & ColorExtensions
+                                              : {}) & {
+        __TypeScript_VALUE__: TValue;
+    };
+
 export default Node;
diff --git a/src-testing/src/nodes/core/NodeAttribute.ts b/src-testing/src/nodes/core/NodeAttribute.ts
index 393325c3..5daf1095 100644
--- a/src-testing/src/nodes/core/NodeAttribute.ts
+++ b/src-testing/src/nodes/core/NodeAttribute.ts
@@ -1,3 +1,5 @@
+import Node from './Node.js';
+
 /**
  * {@link NodeBuilder} is going to create instances of this class during the build process
  * of nodes. They represent the final shader attributes that are going to be generated
@@ -5,6 +7,12 @@
  * and {@link NodeBuilder#bufferAttributes} for this purpose.
  */
 class NodeAttribute {
+    readonly isNodeAttribute: true;
+
+    name: string;
+    type: string | null;
+    node: Node | null;
+
     /**
      * Constructs a new node attribute.
      *
@@ -12,7 +20,7 @@ class NodeAttribute {
      * @param {string} type - The type of the attribute.
      * @param {?Node} node - An optional reference to the node.
      */
-    constructor(name, type, node = null) {
+    constructor(name: string, type: string | null, node: Node | null = null) {
         /**
          * This flag can be used for type testing.
          *
diff --git a/src-testing/src/nodes/core/NodeBuilder.ts b/src-testing/src/nodes/core/NodeBuilder.ts
index 15a27827..4bee878c 100644
--- a/src-testing/src/nodes/core/NodeBuilder.ts
+++ b/src-testing/src/nodes/core/NodeBuilder.ts
@@ -9,7 +9,7 @@ import StructType from './StructType.js';
 import FunctionNode from '../code/FunctionNode.js';
 import NodeMaterial from '../../materials/nodes/NodeMaterial.js';
 import { getTypeFromLength } from './NodeUtils.js';
-import { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';
+import { NodeUpdateType, defaultBuildStages, shaderStages, NodeShaderStage } from './constants.js';
 
 import {
     NumberNodeUniform,
@@ -22,8 +22,8 @@ import {
     Matrix4NodeUniform,
 } from '../../renderers/common/nodes/NodeUniform.js';
 
-import { stack } from './StackNode.js';
-import { getCurrentStack, setCurrentStack } from '../tsl/TSLBase.js';
+import StackNode, { stack } from './StackNode.js';
+import { getCurrentStack, setCurrentStack, ShaderNodeInternal } from '../tsl/TSLBase.js';
 
 import CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';
 import ChainMap from '../../renderers/common/ChainMap.js';
@@ -39,8 +39,10 @@ import {
     NearestMipmapLinearFilter,
     LinearMipmapLinearFilter,
     NormalBlending,
+    InterpolationSamplingType,
+    InterpolationSamplingMode,
 } from '../../constants.js';
-import { RenderTarget } from '../../core/RenderTarget.js';
+import { RenderTarget, RenderTargetOptions } from '../../core/RenderTarget.js';
 import { Color } from '../../math/Color.js';
 import { Vector2 } from '../../math/Vector2.js';
 import { Vector3 } from '../../math/Vector3.js';
@@ -48,13 +50,46 @@ import { Vector4 } from '../../math/Vector4.js';
 import { Float16BufferAttribute } from '../../core/BufferAttribute.js';
 import { warn, error } from '../../utils.js';
 
+import Renderer from '../../renderers/common/Renderer.js';
+import UniformNode from './UniformNode.js';
+import NodeUniformsGroup from '../../renderers/common/nodes/NodeUniformsGroup.js';
+import { Material } from '../../materials/Material.js';
+import { Object3D } from '../../core/Object3D.js';
+import { BufferGeometry } from '../../core/BufferGeometry.js';
+import NodeParser from './NodeParser.js';
+import { Scene } from '../../scenes/Scene.js';
+import { Camera } from '../../cameras/Camera.js';
+import Node from './Node.js';
+import ClippingContext from '../../renderers/common/ClippingContext.js';
+import { Mesh } from '../../objects/Mesh.js';
+import { Texture } from '../../textures/Texture.js';
+import { Matrix3 } from '../../math/Matrix3.js';
+import { Matrix4 } from '../../math/Matrix4.js';
+import { DataTexture } from '../../textures/DataTexture.js';
+import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
+import LightsNode from '../lighting/LightsNode.js';
+import StructTypeNode, { MemberLayout } from './StructTypeNode.js';
+import NodeMaterialObserver from '../../materials/nodes/manager/NodeMaterialObserver.js';
+
 let _id = 0;
 
 const sharedNodeData = new WeakMap();
 
-const rendererCache = new WeakMap();
-
-const typeFromArray = new Map([
+const rendererCache = new WeakMap<
+    Renderer,
+    ChainMap<UniformNode<unknown>[] | NodeUniformsGroup[], NodeUniformsGroup | BindGroup>
+>();
+
+type TypedArrayConstructor =
+    | typeof Int8Array
+    | typeof Int16Array
+    | typeof Int32Array
+    | typeof Uint8Array
+    | typeof Uint16Array
+    | typeof Uint32Array
+    | typeof Float32Array;
+
+const typeFromArray = new Map<TypedArrayConstructor, string>([
     [Int8Array, 'int'],
     [Int16Array, 'int'],
     [Int32Array, 'int'],
@@ -64,21 +99,98 @@ const typeFromArray = new Map([
     [Float32Array, 'float'],
 ]);
 
-const toFloat = value => {
+const toFloat = (value: unknown) => {
     if (/e/g.test(value)) {
         return String(value).replace(/\+/g, '');
     } else {
         value = Number(value);
 
-        return value + (value % 1 ? '' : '.0');
+        return value + ((value as number) % 1 ? '' : '.0');
     }
 };
 
+interface Flow {
+    code: string;
+    result?: string | null | undefined;
+    vars?: string | undefined;
+}
+
+interface Context {
+    material: Material | Material[] | null;
+    tempRead?: boolean;
+}
+
 /**
  * Base class for builders which generate a shader program based
  * on a 3D object and its node material definition.
  */
-class NodeBuilder {
+abstract class NodeBuilder {
+    object: Object3D | null;
+    material: Material | Material[] | null;
+    geometry: BufferGeometry | null;
+    renderer: Renderer;
+    parser: NodeParser;
+    scene: Scene | null;
+    camera: Camera | null;
+
+    nodes: Node[];
+    sequentialNodes: Node[];
+    updateNodes: Node[];
+    updateBeforeNodes: Node[];
+    updateAfterNodes: Node[];
+    hashNodes: { [hash: string]: Node };
+
+    observer: NodeMaterialObserver | null;
+
+    lightsNode: LightsNode | null;
+    environmentNode: Node | null;
+    fogNode: Node | null;
+
+    clippingContext: ClippingContext | null;
+
+    vertexShader: string | null;
+    fragmentShader: string | null;
+    computeShader: string | null;
+
+    flowNodes: { vertex: Node[]; fragment: Node[]; compute: Node[] };
+    flowCode: { vertex: string; fragment: string; compute: string };
+    uniforms: {
+        vertex: NodeUniform<unknown>[];
+        fragment: NodeUniform<unknown>[];
+        compute: NodeUniform<unknown>[];
+        index: number;
+    };
+    structs: { vertex: StructType[]; fragment: StructType[]; compute: StructType[]; index: number };
+    bindings: {
+        vertex: { [groupName: string]: NodeUniformsGroup[] | undefined };
+        fragment: { [groupName: string]: NodeUniformsGroup[] | undefined };
+        compute: { [groupName: string]: NodeUniformsGroup[] | undefined };
+    };
+    bindingsIndexes: { [groupName: string]: { binding: number; group: number } | undefined };
+    bindGroups: BindGroup[] | null;
+    attributes: NodeAttribute[];
+    bufferAttributes: NodeAttribute[];
+    varyings: NodeVarying[];
+    codes: { vertex?: NodeCode[] | undefined; fragment?: NodeCode[] | undefined; compute?: NodeCode[] | undefined };
+    vars: { vertex?: NodeVar[] | undefined; fragment?: NodeVar[] | undefined; compute?: NodeVar[] | undefined };
+    flow: Flow;
+    chaining: Node[];
+    stack: StackNode;
+    stacks: StackNode[];
+    tab: string;
+
+    currentFunctionNode: FunctionNode | null;
+
+    context: Context;
+
+    cache: NodeCache;
+    globalCache: NodeCache;
+
+    flowsData: WeakMap<Node, Flow>;
+
+    shaderStage: NodeShaderStage | null;
+    buildStage: string | null;
+
     /**
      * Constructs a new node builder.
      *
@@ -86,7 +198,7 @@ class NodeBuilder {
      * @param {Renderer} renderer - The current renderer.
      * @param {NodeParser} parser - A reference to a node parser.
      */
-    constructor(object, renderer, parser) {
+    constructor(object: Object3D | null, renderer: Renderer, parser: NodeParser) {
         /**
          * The 3D object.
          *
@@ -99,14 +211,14 @@ class NodeBuilder {
          *
          * @type {?Material}
          */
-        this.material = (object && object.material) || null;
+        this.material = (object && (object as Mesh).material) || null;
 
         /**
          * The geometry of the 3D object.
          *
          * @type {?BufferGeometry}
          */
-        this.geometry = (object && object.geometry) || null;
+        this.geometry = (object && (object as Mesh).geometry) || null;
 
         /**
          * The current renderer.
@@ -422,7 +534,7 @@ class NodeBuilder {
          */
         this.globalCache = this.cache;
 
-        this.flowsData = new WeakMap();
+        this.flowsData = new WeakMap<Node, Flow>();
 
         /**
          * The current shader stage.
@@ -511,7 +623,7 @@ class NodeBuilder {
      * @param {Object} options - The options of the render target.
      * @return {RenderTarget} The render target.
      */
-    createRenderTarget(width, height, options) {
+    createRenderTarget(width?: number, height?: number, options?: RenderTargetOptions) {
         return new RenderTarget(width, height, options);
     }
 
@@ -523,7 +635,7 @@ class NodeBuilder {
      * @param {Object} options - The options of the cube render target.
      * @return {CubeRenderTarget} The cube render target.
      */
-    createCubeRenderTarget(size, options) {
+    createCubeRenderTarget(size?: number, options?: RenderTargetOptions) {
         return new CubeRenderTarget(size, options);
     }
 
@@ -533,7 +645,7 @@ class NodeBuilder {
      * @param {Node} node - The node to test.
      * @return {boolean} Whether the given node is included in the internal array of nodes or not.
      */
-    includes(node) {
+    includes(node: Node) {
         return this.nodes.includes(node);
     }
 
@@ -554,12 +666,12 @@ class NodeBuilder {
      * @param {Array<NodeUniformsGroup>} bindings - List of bindings.
      * @return {BindGroup} The bind group
      */
-    _getBindGroup(groupName, bindings) {
+    _getBindGroup(groupName: string, bindings: NodeUniformsGroup[]) {
         const bindGroupsCache = this.getBindGroupsCache();
 
         //
 
-        const bindingsArray = [];
+        const bindingsArray: NodeUniformsGroup[] = [];
 
         let sharedGroup = true;
 
@@ -574,20 +686,20 @@ class NodeBuilder {
         let bindGroup;
 
         if (sharedGroup) {
-            bindGroup = bindGroupsCache.get(bindingsArray);
+            bindGroup = bindGroupsCache.get(bindingsArray) as BindGroup | undefined;
 
             if (bindGroup === undefined) {
                 bindGroup = new BindGroup(
                     groupName,
                     bindingsArray,
-                    this.bindingsIndexes[groupName].group,
+                    this.bindingsIndexes[groupName]!.group,
                     bindingsArray,
                 );
 
                 bindGroupsCache.set(bindingsArray, bindGroup);
             }
         } else {
-            bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);
+            bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName]!.group, bindingsArray);
         }
 
         return bindGroup;
@@ -600,7 +712,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {Array<NodeUniformsGroup>} The array of node uniform groups.
      */
-    getBindGroupArray(groupName, shaderStage) {
+    getBindGroupArray(groupName: string, shaderStage: NodeShaderStage) {
         const bindings = this.bindings[shaderStage];
 
         let bindGroup = bindings[groupName];
@@ -625,12 +737,12 @@ class NodeBuilder {
         let bindingsGroups = this.bindGroups;
 
         if (bindingsGroups === null) {
-            const groups = {};
+            const groups: { [groupName: string]: NodeUniformsGroup[] | undefined } = {};
             const bindings = this.bindings;
 
             for (const shaderStage of shaderStages) {
                 for (const groupName in bindings[shaderStage]) {
-                    const uniforms = bindings[shaderStage][groupName];
+                    const uniforms = bindings[shaderStage][groupName]!;
 
                     const groupUniforms = groups[groupName] || (groups[groupName] = []);
                     groupUniforms.push(...uniforms);
@@ -640,7 +752,7 @@ class NodeBuilder {
             bindingsGroups = [];
 
             for (const groupName in groups) {
-                const group = groups[groupName];
+                const group = groups[groupName]!;
 
                 const bindingsGroup = this._getBindGroup(groupName, group);
 
@@ -676,7 +788,7 @@ class NodeBuilder {
      * @param {Node} node - The node to add.
      * @param {number} hash - The hash of the node.
      */
-    setHashNode(node, hash) {
+    setHashNode(node: Node, hash: string) {
         this.hashNodes[hash] = node;
     }
 
@@ -685,7 +797,7 @@ class NodeBuilder {
      *
      * @param {Node} node - The node to add.
      */
-    addNode(node) {
+    addNode(node: Node) {
         if (this.nodes.includes(node) === false) {
             this.nodes.push(node);
 
@@ -748,7 +860,7 @@ class NodeBuilder {
      * @param {Texture} texture - The texture to check.
      * @return {boolean} Whether the given texture is filtered or not.
      */
-    isFilteredTexture(texture) {
+    isFilteredTexture(texture: Texture) {
         return (
             texture.magFilter === LinearFilter ||
             texture.magFilter === LinearMipmapNearestFilter ||
@@ -767,7 +879,7 @@ class NodeBuilder {
      *
      * @param {Node} node - The node to add.
      */
-    addChain(node) {
+    addChain(node: Node) {
         /*
 		if ( this.chaining.indexOf( node ) !== - 1 ) {
 
@@ -784,7 +896,7 @@ class NodeBuilder {
      *
      * @param {Node} node - The node to remove.
      */
-    removeChain(node) {
+    removeChain(node: Node) {
         const lastChain = this.chaining.pop();
 
         if (lastChain !== node) {
@@ -801,7 +913,7 @@ class NodeBuilder {
      * @param {string} method - The method name to resolve.
      * @return {string} The resolved method name.
      */
-    getMethod(method) {
+    getMethod(method: string) {
         return method;
     }
 
@@ -825,7 +937,7 @@ class NodeBuilder {
      * @param {number} hash - The hash of the node.
      * @return {Node} The found node.
      */
-    getNodeFromHash(hash) {
+    getNodeFromHash(hash: string) {
         return this.hashNodes[hash];
     }
 
@@ -836,7 +948,7 @@ class NodeBuilder {
      * @param {Node} node - The node to add.
      * @return {Node} The node.
      */
-    addFlow(shaderStage, node) {
+    addFlow(shaderStage: NodeShaderStage, node: Node) {
         this.flowNodes[shaderStage].push(node);
 
         return node;
@@ -847,7 +959,7 @@ class NodeBuilder {
      *
      * @param {Object} context - The context to set.
      */
-    setContext(context) {
+    setContext(context: Context) {
         this.context = context;
     }
 
@@ -893,7 +1005,7 @@ class NodeBuilder {
      *
      * @param {NodeCache} cache - The cache to set.
      */
-    setCache(cache) {
+    setCache(cache: NodeCache) {
         this.cache = cache;
     }
 
@@ -913,7 +1025,7 @@ class NodeBuilder {
      * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
      * @return {NodeCache} The cache.
      */
-    getCacheFromNode(node, parent = true) {
+    getCacheFromNode(node: Node, parent = true) {
         const data = this.getDataFromNode(node);
         if (data.cache === undefined) data.cache = new NodeCache(parent ? this.getCache() : null);
 
@@ -927,7 +1039,7 @@ class NodeBuilder {
      * @param {string} name - The requested feature.
      * @return {boolean} Whether the requested feature is supported or not.
      */
-    isAvailable(/*name*/) {
+    isAvailable(name: string) {
         return false;
     }
 
@@ -1016,9 +1128,12 @@ class NodeBuilder {
      * @param {string} uvSnippet - Snippet defining the texture coordinates.
      * @return {string} The generated shader string.
      */
-    generateTexture(/* texture, textureProperty, uvSnippet */) {
-        warn('Abstract function.');
-    }
+    abstract generateTexture(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        depthSnippet: string | null,
+    ): string;
 
     /**
      * Generates a texture LOD shader string for the given texture data.
@@ -1031,9 +1146,29 @@ class NodeBuilder {
      * @param {string} levelSnippet - Snippet defining the mip level.
      * @return {string} The generated shader string.
      */
-    generateTextureLod(/* texture, textureProperty, uvSnippet, depthSnippet, levelSnippet */) {
-        warn('Abstract function.');
-    }
+    abstract generateTextureLod(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        depthSnippet: string | null,
+        levelSnippet: string | null,
+    ): string;
+
+    abstract generateTextureGrad(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        gradSnippet: [string, string] | null,
+        depthSnippet: string | null,
+    ): string;
+
+    abstract generateTextureCompare(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        compareSnippet: string | null,
+        depthSnippet: string | null,
+    ): string;
 
     /**
      * Generates the array declaration string.
@@ -1105,7 +1240,7 @@ class NodeBuilder {
      * @param {?any} [value=null] - The value.
      * @return {string} The generated value as a shader string.
      */
-    generateConst(type, value = null) {
+    generateConst(type: string | null, value: unknown = null): string {
         if (value === null) {
             if (type === 'float' || type === 'int' || type === 'uint') value = 0;
             else if (type === 'bool') value = false;
@@ -1116,20 +1251,20 @@ class NodeBuilder {
         }
 
         if (type === 'float') return toFloat(value);
-        if (type === 'int') return `${Math.round(value)}`;
-        if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';
+        if (type === 'int') return `${Math.round(value as number)}`;
+        if (type === 'uint') return (value as number) >= 0 ? `${Math.round(value as number)}u` : '0u';
         if (type === 'bool') return value ? 'true' : 'false';
         if (type === 'color')
-            return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
+            return `${this.getType('vec3')}( ${toFloat((value as Color).r)}, ${toFloat((value as Color).g)}, ${toFloat((value as Color).b)} )`;
 
         const typeLength = this.getTypeLength(type);
 
         const componentType = this.getComponentType(type);
 
-        const generateConst = value => this.generateConst(componentType, value);
+        const generateConst = (value: unknown) => this.generateConst(componentType, value);
 
         if (typeLength === 2) {
-            return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;
+            return `${this.getType(type)}( ${generateConst((value as Vector2).x)}, ${generateConst((value as Vector2).y)} )`;
         } else if (typeLength === 3) {
             return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;
         } else if (typeLength === 4 && type !== 'mat2') {
@@ -1150,7 +1285,7 @@ class NodeBuilder {
      * @param {string} type - The type.
      * @return {string} The updated type.
      */
-    getType(type) {
+    getType(type: string | null) {
         if (type === 'color') return 'vec3';
 
         return type;
@@ -1162,7 +1297,7 @@ class NodeBuilder {
      * @param {string} name - The attribute name.
      * @return {boolean} Whether the given attribute name is defined in the geometry.
      */
-    hasGeometryAttribute(name) {
+    hasGeometryAttribute(name: string) {
         return this.geometry && this.geometry.getAttribute(name) !== undefined;
     }
 
@@ -1173,7 +1308,7 @@ class NodeBuilder {
      * @param {string} type - The attribute's type.
      * @return {NodeAttribute} The node attribute.
      */
-    getAttribute(name, type) {
+    getAttribute(name: string, type: string | null) {
         const attributes = this.attributes;
 
         // find attribute
@@ -1202,8 +1337,8 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The property name.
      */
-    getPropertyName(node /*, shaderStage*/) {
-        return node.name;
+    getPropertyName(node: unknown, shaderStage?: NodeShaderStage) {
+        return (node as { name?: string }).name;
     }
 
     /**
@@ -1212,8 +1347,8 @@ class NodeBuilder {
      * @param {string} type - The type to check.
      * @return {boolean} Whether the given type is a vector type or not.
      */
-    isVector(type) {
-        return /vec\d/.test(type);
+    isVector(type: string | null) {
+        return /vec\d/.test(type!);
     }
 
     /**
@@ -1222,8 +1357,8 @@ class NodeBuilder {
      * @param {string} type - The type to check.
      * @return {boolean} Whether the given type is a matrix type or not.
      */
-    isMatrix(type) {
-        return /mat\d/.test(type);
+    isMatrix(type: string | null) {
+        return /mat\d/.test(type!);
     }
 
     /**
@@ -1232,7 +1367,7 @@ class NodeBuilder {
      * @param {string} type - The type to check.
      * @return {boolean} Whether the given type is a reference type or not.
      */
-    isReference(type) {
+    isReference(type: string | null) {
         return (
             type === 'void' ||
             type === 'property' ||
@@ -1263,10 +1398,10 @@ class NodeBuilder {
      * @param {Texture} texture - The texture.
      * @return {string} The component type.
      */
-    getComponentTypeFromTexture(texture) {
+    getComponentTypeFromTexture(texture: Texture) {
         const type = texture.type;
 
-        if (texture.isDataTexture) {
+        if ((texture as DataTexture).isDataTexture) {
             if (type === IntType) return 'int';
             if (type === UnsignedIntType) return 'uint';
         }
@@ -1280,7 +1415,7 @@ class NodeBuilder {
      * @param {string} type - The type.
      * @return {string} The element type.
      */
-    getElementType(type) {
+    getElementType(type: string | null) {
         if (type === 'mat2') return 'vec2';
         if (type === 'mat3') return 'vec3';
         if (type === 'mat4') return 'vec4';
@@ -1294,7 +1429,7 @@ class NodeBuilder {
      * @param {string} type - The type.
      * @return {string} The component type.
      */
-    getComponentType(type) {
+    getComponentType(type: string | null) {
         type = this.getVectorType(type);
 
         if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;
@@ -1316,7 +1451,7 @@ class NodeBuilder {
      * @param {string} type - The type.
      * @return {string} The vector type.
      */
-    getVectorType(type) {
+    getVectorType(type: string | null) {
         if (type === 'color') return 'vec3';
         if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D')
             return 'vec4';
@@ -1331,11 +1466,11 @@ class NodeBuilder {
      * @param {string} [componentType='float'] - The component type.
      * @return {string} The type.
      */
-    getTypeFromLength(length, componentType = 'float') {
+    getTypeFromLength(length: number, componentType: string | null = 'float') {
         if (length === 1) return componentType;
 
         let baseType = getTypeFromLength(length);
-        const prefix = componentType === 'float' ? '' : componentType[0];
+        const prefix = componentType === 'float' ? '' : componentType![0];
 
         // fix edge case for mat2x2 being same size as vec4
         if (/mat2/.test(componentType) === true) {
@@ -1351,7 +1486,7 @@ class NodeBuilder {
      * @param {TypedArray} array - The typed array.
      * @return {string} The type.
      */
-    getTypeFromArray(array) {
+    getTypeFromArray(array: TypedArray) {
         return typeFromArray.get(array.constructor);
     }
 
@@ -1371,10 +1506,10 @@ class NodeBuilder {
      * @param {BufferAttribute} attribute - The buffer attribute.
      * @return {string} The type.
      */
-    getTypeFromAttribute(attribute) {
-        let dataAttribute = attribute;
-
-        if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;
+    getTypeFromAttribute(attribute: BufferAttribute | InterleavedBufferAttribute) {
+        const dataAttribute = (attribute as InterleavedBufferAttribute).isInterleavedBufferAttribute
+            ? (attribute as InterleavedBufferAttribute).data
+            : attribute;
 
         const array = dataAttribute.array;
         const itemSize = attribute.itemSize;
@@ -1395,15 +1530,15 @@ class NodeBuilder {
      * @param {string} type - The data type.
      * @return {number} The length.
      */
-    getTypeLength(type) {
+    getTypeLength(type: string | null) {
         const vecType = this.getVectorType(type);
-        const vecNum = /vec([2-4])/.exec(vecType);
+        const vecNum = /vec([2-4])/.exec(vecType!);
 
         if (vecNum !== null) return Number(vecNum[1]);
         if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;
-        if (/mat2/.test(type) === true) return 4;
-        if (/mat3/.test(type) === true) return 9;
-        if (/mat4/.test(type) === true) return 16;
+        if (/mat2/.test(type!) === true) return 4;
+        if (/mat3/.test(type!) === true) return 9;
+        if (/mat4/.test(type!) === true) return 16;
 
         return 0;
     }
@@ -1414,7 +1549,7 @@ class NodeBuilder {
      * @param {string} type - The matrix type.
      * @return {string} The vector type.
      */
-    getVectorFromMatrix(type) {
+    getVectorFromMatrix(type: string) {
         return type.replace('mat', 'vec');
     }
 
@@ -1427,7 +1562,7 @@ class NodeBuilder {
      * @param {string} newComponentType - The new component type.
      * @return {string} The new type.
      */
-    changeComponentType(type, newComponentType) {
+    changeComponentType(type: string, newComponentType: string) {
         return this.getTypeFromLength(this.getTypeLength(type), newComponentType);
     }
 
@@ -1437,7 +1572,7 @@ class NodeBuilder {
      * @param {string} type - The type.
      * @return {string} The integer type.
      */
-    getIntegerType(type) {
+    getIntegerType(type: string) {
         const componentType = this.getComponentType(type);
 
         if (componentType === 'int' || componentType === 'uint') return type;
@@ -1530,7 +1665,11 @@ class NodeBuilder {
      * @param {?NodeCache} cache - An optional cache.
      * @return {Object} The node data.
      */
-    getDataFromNode(node, shaderStage = this.shaderStage, cache = null) {
+    getDataFromNode(
+        node: Node,
+        shaderStage: NodeShaderStage | 'any' = this.shaderStage!,
+        cache: NodeCache | null = null,
+    ) {
         cache = cache === null ? (node.isGlobal(this) ? this.globalCache : this.cache) : cache;
 
         let nodeData = cache.getData(node);
@@ -1545,7 +1684,7 @@ class NodeBuilder {
 
         //
 
-        let data = nodeData[shaderStage];
+        let data = nodeData[shaderStage]!;
 
         const subBuilds = nodeData.any ? nodeData.any.subBuilds : null;
         const subBuild = this.getClosestSubBuild(subBuilds);
@@ -1572,7 +1711,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.
      * @return {Object} The node properties.
      */
-    getNodeProperties(node, shaderStage = 'any') {
+    getNodeProperties(node: Node, shaderStage: NodeShaderStage | 'any' = 'any') {
         const nodeData = this.getDataFromNode(node, shaderStage);
 
         return nodeData.properties || (nodeData.properties = { outputNode: null });
@@ -1585,7 +1724,7 @@ class NodeBuilder {
      * @param {string} type - The node type.
      * @return {NodeAttribute} The node attribute.
      */
-    getBufferAttributeFromNode(node, type) {
+    getBufferAttributeFromNode(node: Node, type: string | null) {
         const nodeData = this.getDataFromNode(node, 'vertex');
 
         let bufferAttribute = nodeData.bufferAttribute;
@@ -1624,7 +1763,12 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
      * @return {StructType} The struct type attribute.
      */
-    getStructTypeFromNode(node, membersLayout, name = null, shaderStage = this.shaderStage) {
+    getStructTypeFromNode(
+        node: StructTypeNode,
+        membersLayout: MemberLayout[],
+        name: string | null = null,
+        shaderStage = this.shaderStage!,
+    ) {
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
         let structType = nodeData.structType;
@@ -1668,7 +1812,12 @@ class NodeBuilder {
      * @param {?string} name - The name of the uniform.
      * @return {NodeUniform} The node uniform.
      */
-    getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {
+    getUniformFromNode(
+        node: UniformNode<unknown>,
+        type: string | null,
+        shaderStage = this.shaderStage!,
+        name: string | null = null,
+    ) {
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
         let nodeUniform = nodeData.uniform;
@@ -1699,7 +1848,13 @@ class NodeBuilder {
      *
      * @return {NodeVar} The node variable.
      */
-    getVarFromNode(node, name = null, type = node.getNodeType(this), shaderStage = this.shaderStage, readOnly = false) {
+    getVarFromNode(
+        node: Node,
+        name: string | null = null,
+        type = node.getNodeType(this),
+        shaderStage = this.shaderStage!,
+        readOnly = false,
+    ) {
         const nodeData = this.getDataFromNode(node, shaderStage);
         const subBuildVariable = this.getSubBuildProperty('variable', nodeData.subBuilds);
 
@@ -1784,11 +1939,11 @@ class NodeBuilder {
      * @return {NodeVar} The node varying.
      */
     getVaryingFromNode(
-        node,
-        name = null,
+        node: Node,
+        name: string | null = null,
         type = node.getNodeType(this),
-        interpolationType = null,
-        interpolationSampling = null,
+        interpolationType: InterpolationSamplingType | null = null,
+        interpolationSampling: InterpolationSamplingMode | null = null,
     ) {
         const nodeData = this.getDataFromNode(node, 'any');
         const subBuildVarying = this.getSubBuildProperty('varying', nodeData.subBuilds);
@@ -1858,7 +2013,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
      * @return {NodeCode} The node code.
      */
-    getCodeFromNode(node, type, shaderStage = this.shaderStage) {
+    getCodeFromNode(node: Node, type: string | null, shaderStage = this.shaderStage!) {
         const nodeData = this.getDataFromNode(node);
 
         let nodeCode = nodeData.code;
@@ -1931,7 +2086,7 @@ class NodeBuilder {
      * @param {?Node} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.
      * @return {NodeBuilder} A reference to this node builder.
      */
-    addLineFlowCode(code, node = null) {
+    addLineFlowCode(code: string, node = null) {
         if (code === '') return this;
 
         if (node !== null && this.context.nodeBlock) {
@@ -1955,7 +2110,7 @@ class NodeBuilder {
      * @param {string} code - Shader code.
      * @return {NodeBuilder} A reference to this node builder.
      */
-    addFlowCode(code) {
+    addFlowCode(code: string) {
         this.flow.code += code;
 
         return this;
@@ -1991,7 +2146,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {Object} The flow data.
      */
-    getFlowData(node /*, shaderStage*/) {
+    getFlowData(node: Node /*, shaderStage*/) {
         return this.flowsData.get(node);
     }
 
@@ -2001,7 +2156,7 @@ class NodeBuilder {
      * @param {Node} node - The node to execute.
      * @return {Object} The code flow.
      */
-    flowNode(node) {
+    flowNode(node: Node) {
         const output = node.getNodeType(this);
 
         const flowData = this.flowChildNode(node, output);
@@ -2017,12 +2172,14 @@ class NodeBuilder {
      * @param {Node} node - The node to include.
      * @returns {void}
      */
-    addInclude(node) {
+    addInclude(node: Node) {
         if (this.currentFunctionNode !== null) {
             this.currentFunctionNode.includes.push(node);
         }
     }
 
+    abstract buildFunctionCode(shaderNode: ShaderNodeInternal): string;
+
     /**
      * Returns the native shader operator name for a given generic name.
      * It is a similar type of method like {@link NodeBuilder#getMethod}.
@@ -2030,7 +2187,7 @@ class NodeBuilder {
      * @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.
      * @return {FunctionNode} The build function node.
      */
-    buildFunctionNode(shaderNode) {
+    buildFunctionNode(shaderNode: ShaderNodeInternal) {
         const fn = new FunctionNode();
 
         const previous = this.currentFunctionNode;
@@ -2050,7 +2207,7 @@ class NodeBuilder {
      * @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.
      * @return {Object}
      */
-    flowShaderNode(shaderNode) {
+    flowShaderNode(shaderNode: ShaderNodeInternal) {
         const layout = shaderNode.layout;
 
         const inputs = {
@@ -2066,7 +2223,7 @@ class NodeBuilder {
             },
         };
 
-        for (const input of layout.inputs) {
+        for (const input of layout!.inputs) {
             inputs[input.name] = new ParameterNode(input.type, input.name);
         }
 
@@ -2115,7 +2272,7 @@ class NodeBuilder {
      * @param {?string} output - Expected output type. For example 'vec3'.
      * @return {Object}
      */
-    flowStagesNode(node, output = null) {
+    flowStagesNode(node: Node, output: string | null = null) {
         const previousFlow = this.flow;
         const previousVars = this.vars;
         const previousDeclarations = this.declarations;
@@ -2123,7 +2280,7 @@ class NodeBuilder {
         const previousBuildStage = this.buildStage;
         const previousStack = this.stack;
 
-        const flow = {
+        const flow: Flow = {
             code: '',
         };
 
@@ -2139,7 +2296,7 @@ class NodeBuilder {
             flow.result = node.build(this, output);
         }
 
-        flow.vars = this.getVars(this.shaderStage);
+        flow.vars = this.getVars(this.shaderStage!);
 
         this.flow = previousFlow;
         this.vars = previousVars;
@@ -2182,10 +2339,10 @@ class NodeBuilder {
      * @param {?string} output - Expected output type. For example 'vec3'.
      * @return {Object} The code flow.
      */
-    flowChildNode(node, output = null) {
+    flowChildNode(node: Node, output: string | null = null) {
         const previousFlow = this.flow;
 
-        const flow = {
+        const flow: Flow = {
             code: '',
         };
 
@@ -2210,7 +2367,12 @@ class NodeBuilder {
      * @param {?string} propertyName - The property name to assign the result.
      * @return {?(Object|Node)} The code flow or node.build() result.
      */
-    flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {
+    flowNodeFromShaderStage(
+        shaderStage: 'vertex' | 'fragment' | 'compute',
+        node: Node,
+        output: string | null = null,
+        propertyName: string | null = null,
+    ) {
         const previousTab = this.tab;
         const previousCache = this.cache;
         const previousShaderStage = this.shaderStage;
@@ -2266,9 +2428,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The attribute code section.
      */
-    getAttributes(/*shaderStage*/) {
-        warn('Abstract function.');
-    }
+    abstract getAttributes(shaderStage: NodeShaderStage): string;
 
     /**
      * Returns the varying definitions as a shader string for the given shader stage.
@@ -2277,9 +2437,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The varying code section.
      */
-    getVaryings(/*shaderStage*/) {
-        warn('Abstract function.');
-    }
+    abstract getVaryings(shaderStage: NodeShaderStage): string;
 
     /**
      * Returns a single variable definition as a shader string for the given variable type and name.
@@ -2289,7 +2447,7 @@ class NodeBuilder {
      * @param {?number} [count=null] - The array length.
      * @return {string} The shader string.
      */
-    getVar(type, name, count = null) {
+    getVar(type: string, name: string, count: number | null = null) {
         return `${count !== null ? this.generateArrayDeclaration(type, count) : this.getType(type)} ${name}`;
     }
 
@@ -2299,7 +2457,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The variable code section.
      */
-    getVars(shaderStage) {
+    getVars(shaderStage: 'vertex' | 'fragment' | 'compute') {
         let snippet = '';
 
         const vars = this.vars[shaderStage];
@@ -2320,9 +2478,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The uniform code section.
      */
-    getUniforms(/*shaderStage*/) {
-        warn('Abstract function.');
-    }
+    abstract getUniforms(shaderStage: NodeShaderStage): string;
 
     /**
      * Returns the native code definitions as a shader string for the given shader stage.
@@ -2330,7 +2486,7 @@ class NodeBuilder {
      * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
      * @return {string} The native code section.
      */
-    getCodes(shaderStage) {
+    getCodes(shaderStage: 'vertex' | 'fragment' | 'compute') {
         const codes = this.codes[shaderStage];
 
         let code = '';
@@ -2350,7 +2506,7 @@ class NodeBuilder {
      * @return {string} The hash.
      */
     getHash() {
-        return this.vertexShader + this.fragmentShader + this.computeShader;
+        return this.vertexShader! + this.fragmentShader + this.computeShader;
     }
 
     /**
@@ -2358,7 +2514,7 @@ class NodeBuilder {
      *
      * @param {?('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage to set.
      */
-    setShaderStage(shaderStage) {
+    setShaderStage(shaderStage: NodeShaderStage | null) {
         this.shaderStage = shaderStage;
     }
 
@@ -2376,7 +2532,7 @@ class NodeBuilder {
      *
      * @param {?('setup'|'analyze'|'generate')} buildStage - The build stage to set.
      */
-    setBuildStage(buildStage) {
+    setBuildStage(buildStage: string | null) {
         this.buildStage = buildStage;
     }
 
@@ -2582,7 +2738,7 @@ class NodeBuilder {
      * @param {string} type - The requested type.
      * @return {Uniform} The uniform.
      */
-    getNodeUniform(uniformNode, type) {
+    getNodeUniform(uniformNode: NodeUniform<unknown>, type: string | null) {
         const nodeData = this.getSharedDataFromNode(uniformNode);
 
         let node = nodeData.cache;
@@ -2619,7 +2775,7 @@ class NodeBuilder {
      * @param {string} toType - The target type.
      * @return {string} The updated shader string.
      */
-    format(snippet, fromType, toType) {
+    format(snippet: string, fromType: string | null, toType: string | null): string {
         fromType = this.getVectorType(fromType);
         toType = this.getVectorType(toType);
 
diff --git a/src-testing/src/nodes/core/NodeCache.ts b/src-testing/src/nodes/core/NodeCache.ts
index 60ca0039..180c7e3b 100644
--- a/src-testing/src/nodes/core/NodeCache.ts
+++ b/src-testing/src/nodes/core/NodeCache.ts
@@ -1,16 +1,64 @@
+import NodeAttribute from './NodeAttribute.js';
+import NodeUniform from './NodeUniform.js';
+import NodeVar from './NodeVar.js';
+import NodeVarying from './NodeVarying.js';
+import NodeCode from './NodeCode.js';
+import Node from './Node.js';
+import BufferAttributeNode from '../accessors/BufferAttributeNode.js';
+import { BufferAttribute, TypedArray } from '../../core/BufferAttribute.js';
+import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
+import StructType from './StructType.js';
+
 let _id = 0;
 
+export interface ShaderStageNodeData {
+    properties?:
+        | ({
+              outputNode: Node | null;
+              initialized?: boolean | undefined;
+          } & {
+              [K in `node${string}`]?: Node | undefined;
+          })
+        | undefined;
+    bufferAttribute?: NodeAttribute | undefined;
+    structType?: StructType | undefined;
+    uniform?: NodeUniform<unknown> | undefined;
+    variable?: NodeVar | undefined;
+    varying?: NodeVarying | undefined;
+    code?: NodeCode | undefined;
+    usageCount?: number | undefined;
+    snippet?: string | undefined;
+    propertyName?: string | undefined;
+    propertySizeName?: string | undefined;
+}
+
+interface NodeData {
+    vertex?: ShaderStageNodeData | undefined;
+    fragment?: ShaderStageNodeData | undefined;
+    compute?: ShaderStageNodeData | undefined;
+    any?: ShaderStageNodeData | undefined;
+}
+
+interface BufferAttributeData {
+    node: BufferAttributeNode;
+}
+
 /**
  * This utility class is used in {@link NodeBuilder} as an internal
  * cache data structure for node data.
  */
 class NodeCache {
+    id: number;
+    nodesData: WeakMap<Node | TypedArray | InterleavedBuffer | BufferAttribute, NodeData | BufferAttributeData>;
+
+    parent: NodeCache | null;
+
     /**
      * Constructs a new node cache.
      *
      * @param {?NodeCache} parent - A reference to a parent cache.
      */
-    constructor(parent = null) {
+    constructor(parent: NodeCache | null = null) {
         /**
          * The id of the cache.
          *
@@ -41,11 +89,13 @@ class NodeCache {
      * @param {Node} node - The node.
      * @return {?Object} The data for the node.
      */
-    getData(node) {
+    getData(node: Node): NodeData | undefined;
+    getData(node: TypedArray | InterleavedBuffer | BufferAttribute): BufferAttributeData | undefined;
+    getData(node: Node | TypedArray | InterleavedBuffer | BufferAttribute): NodeData | BufferAttributeData | undefined {
         let data = this.nodesData.get(node);
 
         if (data === undefined && this.parent !== null) {
-            data = this.parent.getData(node);
+            data = this.parent.getData(node as Node);
         }
 
         return data;
@@ -57,7 +107,9 @@ class NodeCache {
      * @param {Node} node - The node.
      * @param {Object} data - The data that should be cached.
      */
-    setData(node, data) {
+    setData(node: Node, data: NodeData): void;
+    setData(node: TypedArray | InterleavedBuffer | BufferAttribute, data: BufferAttributeData): void;
+    setData(node: Node | TypedArray | InterleavedBuffer | BufferAttribute, data: NodeData | BufferAttributeData) {
         this.nodesData.set(node, data);
     }
 }
diff --git a/src-testing/src/nodes/core/NodeCode.ts b/src-testing/src/nodes/core/NodeCode.ts
index 7cf21cda..08eb89d0 100644
--- a/src-testing/src/nodes/core/NodeCode.ts
+++ b/src-testing/src/nodes/core/NodeCode.ts
@@ -5,6 +5,10 @@
  * for this purpose.
  */
 class NodeCode {
+    name: string;
+    type: string | null;
+    code: string;
+
     /**
      * Constructs a new code node.
      *
@@ -12,7 +16,7 @@ class NodeCode {
      * @param {string} type - The node type.
      * @param {string} [code=''] - The native shader code.
      */
-    constructor(name, type, code = '') {
+    constructor(name: string, type: string | null, code = '') {
         /**
          * The name of the code.
          *
diff --git a/src-testing/src/nodes/core/NodeFrame.ts b/src-testing/src/nodes/core/NodeFrame.ts
index 43f9bde2..1be6c1e4 100644
--- a/src-testing/src/nodes/core/NodeFrame.ts
+++ b/src-testing/src/nodes/core/NodeFrame.ts
@@ -1,4 +1,7 @@
 import { NodeUpdateType } from './constants.js';
+import Node from './Node.js';
+import Renderer from '../../renderers/common/Renderer.js';
+import { Camera, Material, Object3D, Scene } from 'three';
 
 /**
  * Management class for updating nodes. The module tracks metrics like
@@ -7,6 +10,23 @@ import { NodeUpdateType } from './constants.js';
  * and {@link Node#updateAfter} depending on the node's configuration.
  */
 class NodeFrame {
+    time: number;
+    deltaTime: number;
+
+    frameId: number;
+    renderId: number;
+
+    // TODO startTime
+
+    // TODO updateMap
+    // TODO updateBeforeMap
+
+    renderer: Renderer | null;
+    material: Material | null;
+    camera: Camera | null;
+    object: Object3D | null;
+    scene: Scene | null;
+
     /**
      * Constructs a new node fame.
      */
@@ -137,7 +157,7 @@ class NodeFrame {
      *
      * @param {Node} node - The node that should be updated.
      */
-    updateBeforeNode(node) {
+    updateBeforeNode(node: Node) {
         const updateType = node.getUpdateBeforeType();
         const reference = node.updateReference(this);
 
@@ -211,7 +231,7 @@ class NodeFrame {
      *
      * @param {Node} node - The node that should be updated.
      */
-    updateNode(node) {
+    updateNode(node: Node) {
         const updateType = node.getUpdateType();
         const reference = node.updateReference(this);
 
diff --git a/src-testing/src/nodes/core/NodeParser.ts b/src-testing/src/nodes/core/NodeParser.ts
index ae664a23..65e57edd 100644
--- a/src-testing/src/nodes/core/NodeParser.ts
+++ b/src-testing/src/nodes/core/NodeParser.ts
@@ -1,9 +1,10 @@
-import { warn } from '../../utils.js';
+import NodeFunction from './NodeFunction.js';
+
 /**
  * Base class for node parsers. A derived parser must be implemented
  * for each supported native shader language.
  */
-class NodeParser {
+abstract class NodeParser {
     /**
      * The method parses the given native code an returns a node function.
      *
@@ -11,9 +12,7 @@ class NodeParser {
      * @param {string} source - The native shader code.
      * @return {NodeFunction} A node function.
      */
-    parseFunction(/*source*/) {
-        warn('Abstract function.');
-    }
+    abstract parseFunction(source: string): NodeFunction;
 }
 
 export default NodeParser;
diff --git a/src-testing/src/nodes/core/NodeUniform.ts b/src-testing/src/nodes/core/NodeUniform.ts
index 09ff8b51..9a5b8384 100644
--- a/src-testing/src/nodes/core/NodeUniform.ts
+++ b/src-testing/src/nodes/core/NodeUniform.ts
@@ -1,10 +1,19 @@
+import UniformNode from './UniformNode.js';
+
 /**
  * {@link NodeBuilder} is going to create instances of this class during the build process
  * of nodes. They represent the final shader uniforms that are going to be generated
  * by the builder. A dictionary of node uniforms is maintained in {@link NodeBuilder#uniforms}
  * for this purpose.
  */
-class NodeUniform {
+class NodeUniform<TValue> {
+    readonly isNodeUniform: true;
+
+    name: string;
+    type: string | null;
+    node: UniformNode<TValue>;
+    needsUpdate: boolean | undefined;
+
     /**
      * Constructs a new node uniform.
      *
@@ -12,7 +21,7 @@ class NodeUniform {
      * @param {string} type - The type of the uniform.
      * @param {UniformNode} node - An reference to the node.
      */
-    constructor(name, type, node) {
+    constructor(name: string, type: string | null, node: UniformNode<TValue>) {
         /**
          * This flag can be used for type testing.
          *
diff --git a/src-testing/src/nodes/core/NodeUtils.ts b/src-testing/src/nodes/core/NodeUtils.ts
index 243a1d38..fd5c59f2 100644
--- a/src-testing/src/nodes/core/NodeUtils.ts
+++ b/src-testing/src/nodes/core/NodeUtils.ts
@@ -6,13 +6,14 @@ import { Vector2 } from '../../math/Vector2.js';
 import { Vector3 } from '../../math/Vector3.js';
 import { Vector4 } from '../../math/Vector4.js';
 import { error } from '../../utils.js';
+import Node from './Node.js';
 
 // cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.
 // A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.
 // Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.
 // See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480
 // https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js
-function cyrb53(value, seed = 0) {
+function cyrb53(value: number[] | string, seed = 0) {
     let h1 = 0xdeadbeef ^ seed,
         h2 = 0x41c6ce57 ^ seed;
 
@@ -46,7 +47,7 @@ function cyrb53(value, seed = 0) {
  * @param {string} str - The string to be hashed.
  * @return {number} The hash.
  */
-export const hashString = str => cyrb53(str);
+export const hashString = (str: string) => cyrb53(str);
 
 /**
  * Computes a hash for the given array.
@@ -56,7 +57,7 @@ export const hashString = str => cyrb53(str);
  * @param {Array<number>} array - The array to be hashed.
  * @return {number} The hash.
  */
-export const hashArray = array => cyrb53(array);
+export const hashArray = (array: number[]) => cyrb53(array);
 
 /**
  * Computes a hash for the given list of parameters.
@@ -66,7 +67,7 @@ export const hashArray = array => cyrb53(array);
  * @param {...number} params - A list of parameters.
  * @return {number} The hash.
  */
-export const hash = (...params) => cyrb53(params);
+export const hash = (...params: number[]) => cyrb53(params);
 
 const typeFromLength = /*@__PURE__*/ new Map([
     [1, 'float'],
@@ -189,7 +190,7 @@ export function getByteBoundaryFromType(type) {
  * @param {any} value - The value.
  * @return {?string} The data type.
  */
-export function getValueType(value) {
+export function getValueType(value: unknown) {
     if (value === undefined || value === null) return null;
 
     const typeOf = typeof value;
diff --git a/src-testing/src/nodes/core/NodeVar.ts b/src-testing/src/nodes/core/NodeVar.ts
index 1bc2f6d1..07624271 100644
--- a/src-testing/src/nodes/core/NodeVar.ts
+++ b/src-testing/src/nodes/core/NodeVar.ts
@@ -5,6 +5,16 @@
  * this purpose.
  */
 class NodeVar {
+    readonly isNodeVar: true;
+
+    name: string;
+
+    type: string;
+
+    readOnly: boolean;
+
+    count: number | null;
+
     /**
      * Constructs a new node variable.
      *
@@ -13,7 +23,7 @@ class NodeVar {
      * @param {boolean} [readOnly=false] - The read-only flag.
      * @param {?number} [count=null] - The size.
      */
-    constructor(name, type, readOnly = false, count = null) {
+    constructor(name: string, type: string, readOnly = false, count: number | null = null) {
         /**
          * This flag can be used for type testing.
          *
diff --git a/src-testing/src/nodes/core/NodeVarying.ts b/src-testing/src/nodes/core/NodeVarying.ts
index d434bea5..baaec68f 100644
--- a/src-testing/src/nodes/core/NodeVarying.ts
+++ b/src-testing/src/nodes/core/NodeVarying.ts
@@ -1,4 +1,5 @@
 import NodeVar from './NodeVar.js';
+import { InterpolationSamplingMode, InterpolationSamplingType } from '../../constants.js';
 
 /**
  * {@link NodeBuilder} is going to create instances of this class during the build process
@@ -9,6 +10,13 @@ import NodeVar from './NodeVar.js';
  * @augments NodeVar
  */
 class NodeVarying extends NodeVar {
+    needsInterpolation: boolean;
+
+    readonly isNodeVarying: true;
+
+    interpolationType: InterpolationSamplingType | null;
+    interpolationSampling: InterpolationSamplingMode | null;
+
     /**
      * Constructs a new node varying.
      *
@@ -17,7 +25,12 @@ class NodeVarying extends NodeVar {
      * @param {?string} interpolationType - The interpolation type of the varying.
      * @param {?string} interpolationSampling - The interpolation sampling type of the varying.
      */
-    constructor(name, type, interpolationType = null, interpolationSampling = null) {
+    constructor(
+        name: string,
+        type: string,
+        interpolationType: InterpolationSamplingType | null = null,
+        interpolationSampling: InterpolationSamplingMode | null = null,
+    ) {
         super(name, type);
 
         /**
diff --git a/src-testing/src/nodes/core/StackNode.ts b/src-testing/src/nodes/core/StackNode.ts
index 3a5e40b1..3bd76b5d 100644
--- a/src-testing/src/nodes/core/StackNode.ts
+++ b/src-testing/src/nodes/core/StackNode.ts
@@ -2,6 +2,7 @@ import Node from './Node.js';
 import { select } from '../math/ConditionalNode.js';
 import { ShaderNode, nodeProxy, getCurrentStack, setCurrentStack, nodeObject } from '../tsl/TSLBase.js';
 import { error } from '../../utils.js';
+import NodeBuilder from './NodeBuilder.js';
 
 /**
  * Stack is a helper for Nodes that need to produce stack-based code instead of continuous flow.
@@ -14,6 +15,16 @@ class StackNode extends Node {
         return 'StackNode';
     }
 
+    nodes: Node[];
+    outputNode: Node | null;
+
+    parent: StackNode | null;
+
+    _currentCond: Node | null;
+    _expressionNode: Node | null;
+
+    readonly isStackNode: true;
+
     /**
      * Constructs a new stack node.
      *
@@ -78,7 +89,7 @@ class StackNode extends Node {
         return this.hasOutput ? this.outputNode.getElementType(builder) : 'void';
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.hasOutput ? this.outputNode.getNodeType(builder) : 'void';
     }
 
@@ -92,7 +103,7 @@ class StackNode extends Node {
      * @param {Node} node - The node to add.
      * @return {StackNode} A reference to this stack node.
      */
-    addToStack(node) {
+    addToStack(node: Node) {
         if (node.isNode !== true) {
             error('TSL: Invalid node added to stack.');
             return this;
@@ -110,7 +121,7 @@ class StackNode extends Node {
      * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
      * @return {StackNode} A reference to this stack node.
      */
-    If(boolNode, method) {
+    If(boolNode: Node, method: () => void) {
         const methodNode = new ShaderNode(method);
         this._currentCond = select(boolNode, methodNode);
 
@@ -124,7 +135,7 @@ class StackNode extends Node {
      * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
      * @return {StackNode} A reference to this stack node.
      */
-    ElseIf(boolNode, method) {
+    ElseIf(boolNode: Node, method: () => void) {
         const methodNode = new ShaderNode(method);
         const ifNode = select(boolNode, methodNode);
 
@@ -140,7 +151,7 @@ class StackNode extends Node {
      * @param {Function} method - TSL code which is executed in the `else` case.
      * @return {StackNode} A reference to this stack node.
      */
-    Else(method) {
+    Else(method: () => void) {
         this._currentCond.elseNode = new ShaderNode(method);
 
         return this;
@@ -244,7 +255,7 @@ class StackNode extends Node {
         return this.outputNode && this.outputNode.isNode;
     }
 
-    build(builder, ...params) {
+    build(builder: NodeBuilder, ...params) {
         const previousStack = getCurrentStack();
 
         setCurrentStack(this);
diff --git a/src-testing/src/nodes/core/StructType.ts b/src-testing/src/nodes/core/StructType.ts
index b06830b4..27e70330 100644
--- a/src-testing/src/nodes/core/StructType.ts
+++ b/src-testing/src/nodes/core/StructType.ts
@@ -1,5 +1,11 @@
+import { MemberLayout } from './StructTypeNode.js';
+
 class StructType {
-    constructor(name, members) {
+    name: string;
+    members: MemberLayout[];
+    output: boolean;
+
+    constructor(name: string, members: MemberLayout[]) {
         this.name = name;
         this.members = members;
         this.output = false;
diff --git a/src-testing/src/nodes/core/StructTypeNode.ts b/src-testing/src/nodes/core/StructTypeNode.ts
index f0ec33d7..996b2c5e 100644
--- a/src-testing/src/nodes/core/StructTypeNode.ts
+++ b/src-testing/src/nodes/core/StructTypeNode.ts
@@ -1,5 +1,16 @@
 import Node from './Node.js';
 import { getByteBoundaryFromType, getMemoryLengthFromType } from './NodeUtils.js';
+import NodeBuilder from './NodeBuilder.js';
+
+export interface MembersLayout {
+    [name: string]: string | { type: string; atomic?: boolean };
+}
+
+export interface MemberLayout {
+    name: string;
+    type: string;
+    atomic: boolean;
+}
 
 /**
  * Generates a layout for struct members.
@@ -9,7 +20,7 @@ import { getByteBoundaryFromType, getMemoryLengthFromType } from './NodeUtils.js
  * @param {Object.<string, string|Object>} members - An object where keys are member names and values are either types (as strings) or objects with type and atomic properties.
  * @returns {Array.<{name: string, type: string, atomic: boolean}>} An array of member layouts.
  */
-function getMembersLayout(members) {
+function getMembersLayout(members: MembersLayout) {
     return Object.entries(members).map(([name, value]) => {
         if (typeof value === 'string') {
             return { name, type: value, atomic: false };
@@ -32,13 +43,18 @@ class StructTypeNode extends Node {
         return 'StructTypeNode';
     }
 
+    membersLayout: MemberLayout[];
+    name: string | null;
+
+    readonly isStructLayoutNode: true;
+
     /**
      * Creates an instance of StructTypeNode.
      *
      * @param {Object} membersLayout - The layout of the members for the struct.
      * @param {?string} [name=null] - The optional name of the struct.
      */
-    constructor(membersLayout, name = null) {
+    constructor(membersLayout: MembersLayout, name: string | null = null) {
         super('struct');
 
         /**
@@ -81,8 +97,8 @@ class StructTypeNode extends Node {
         for (const member of this.membersLayout) {
             const type = member.type;
 
-            const itemSize = getMemoryLengthFromType(type) * BYTES_PER_ELEMENT;
-            const boundary = getByteBoundaryFromType(type);
+            const itemSize = getMemoryLengthFromType(type)! * BYTES_PER_ELEMENT;
+            const boundary = getByteBoundaryFromType(type)!;
 
             const chunkOffset = offset % GPU_CHUNK_BYTES; // offset in the current chunk
             const chunkPadding = chunkOffset % boundary; // required padding to match boundary
@@ -102,24 +118,24 @@ class StructTypeNode extends Node {
         return (Math.ceil(offset / GPU_CHUNK_BYTES) * GPU_CHUNK_BYTES) / BYTES_PER_ELEMENT;
     }
 
-    getMemberType(builder, name) {
+    getMemberType(builder: NodeBuilder, name: string) {
         const member = this.membersLayout.find(m => m.name === name);
 
         return member ? member.type : 'void';
     }
 
-    getNodeType(builder) {
-        const structType = builder.getStructTypeFromNode(this, this.membersLayout, this.name);
+    getNodeType(builder: NodeBuilder) {
+        const structType = builder.getStructTypeFromNode(this, this.membersLayout, this.name)!;
 
         return structType.name;
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         builder.getStructTypeFromNode(this, this.membersLayout, this.name);
         builder.addInclude(this);
     }
 
-    generate(builder) {
+    generate(builder: NodeBuilder) {
         return this.getNodeType(builder);
     }
 }
diff --git a/src-testing/src/nodes/core/UniformGroupNode.ts b/src-testing/src/nodes/core/UniformGroupNode.ts
index 94299fca..125e9ad4 100644
--- a/src-testing/src/nodes/core/UniformGroupNode.ts
+++ b/src-testing/src/nodes/core/UniformGroupNode.ts
@@ -1,4 +1,4 @@
-import Node from './Node.js';
+import Node, { NodeJSONInputData, NodeJSONIntermediateOutputData } from './Node.js';
 
 /**
  * This node can be used to group single instances of {@link UniformNode}
@@ -18,6 +18,10 @@ class UniformGroupNode extends Node {
         return 'UniformGroupNode';
     }
 
+    shared: boolean;
+    order: number;
+    readonly isUniformGroup: true;
+
     /**
      * Constructs a new uniform group node.
      *
@@ -62,7 +66,7 @@ class UniformGroupNode extends Node {
         this.isUniformGroup = true;
     }
 
-    serialize(data) {
+    serialize(data: NodeJSONIntermediateOutputData) {
         super.serialize(data);
 
         data.name = this.name;
@@ -70,7 +74,7 @@ class UniformGroupNode extends Node {
         data.shared = this.shared;
     }
 
-    deserialize(data) {
+    deserialize(data: NodeJSONInputData) {
         super.deserialize(data);
 
         this.name = data.name;
diff --git a/src-testing/src/nodes/core/UniformNode.ts b/src-testing/src/nodes/core/UniformNode.ts
index 19e6487a..b674b9df 100644
--- a/src-testing/src/nodes/core/UniformNode.ts
+++ b/src-testing/src/nodes/core/UniformNode.ts
@@ -1,26 +1,36 @@
 import InputNode from './InputNode.js';
-import { objectGroup } from './UniformGroupNode.js';
+import UniformGroupNode, { objectGroup } from './UniformGroupNode.js';
 import { nodeObject, getConstNodeType } from '../tsl/TSLCore.js';
 import { getValueFromType } from './NodeUtils.js';
 import { warn } from '../../utils.js';
+import Node from './Node.js';
+import NodeBuilder from './NodeBuilder.js';
+import NodeFrame from './NodeFrame.js';
+import { NodeUpdateType } from './constants.js';
+import ConstNode from './ConstNode.js';
 
 /**
  * Class for representing a uniform.
  *
  * @augments InputNode
  */
-class UniformNode extends InputNode {
+class UniformNode<TValue> extends InputNode<TValue> {
     static get type() {
         return 'UniformNode';
     }
 
+    readonly isUniformNode: true;
+
+    name: string;
+    groupNode: UniformGroupNode;
+
     /**
      * Constructs a new uniform node.
      *
      * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
      * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
      */
-    constructor(value, nodeType = null) {
+    constructor(value: TValue, nodeType: string | null = null) {
         super(value, nodeType);
 
         /**
@@ -56,11 +66,11 @@ class UniformNode extends InputNode {
      * @param {string} name - The name of the uniform.
      * @return {UniformNode} A reference to this node.
      */
-    setName(name) {
+    setName = (name: string) => {
         this.name = name;
 
         return this;
-    }
+    };
 
     /**
      * Sets the {@link UniformNode#name} property.
@@ -69,11 +79,11 @@ class UniformNode extends InputNode {
      * @param {string} name - The name of the uniform.
      * @return {UniformNode} A reference to this node.
      */
-    label(name) {
+    label = (name: string) => {
         warn('TSL: "label()" has been deprecated. Use "setName()" instead.'); // @deprecated r179
 
         return this.setName(name);
-    }
+    };
 
     /**
      * Sets the {@link UniformNode#groupNode} property.
@@ -81,7 +91,7 @@ class UniformNode extends InputNode {
      * @param {UniformGroupNode} group - The uniform group.
      * @return {UniformNode} A reference to this node.
      */
-    setGroup(group) {
+    setGroup(group: UniformGroupNode) {
         this.groupNode = group;
 
         return this;
@@ -103,11 +113,11 @@ class UniformNode extends InputNode {
      * @param {NodeBuilder} builder - The current node builder.
      * @return {string} The uniform hash.
      */
-    getUniformHash(builder) {
+    getUniformHash(builder: NodeBuilder) {
         return this.getHash(builder);
     }
 
-    onUpdate(callback, updateType) {
+    onUpdate(callback: (frame: NodeFrame, self: this) => TValue | undefined, updateType: NodeUpdateType) {
         callback = callback.bind(this);
 
         return super.onUpdate(frame => {
@@ -119,7 +129,7 @@ class UniformNode extends InputNode {
         }, updateType);
     }
 
-    getInputType(builder) {
+    getInputType(builder: NodeBuilder) {
         let type = super.getInputType(builder);
 
         if (type === 'bool') {
@@ -129,12 +139,12 @@ class UniformNode extends InputNode {
         return type;
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output: string | null) {
         const type = this.getNodeType(builder);
 
         const hash = this.getUniformHash(builder);
 
-        let sharedNode = builder.getNodeFromHash(hash);
+        let sharedNode = builder.getNodeFromHash(hash) as this;
 
         if (sharedNode === undefined) {
             builder.setHashNode(this, hash);
@@ -147,7 +157,7 @@ class UniformNode extends InputNode {
         const nodeUniform = builder.getUniformFromNode(
             sharedNode,
             sharedNodeType,
-            builder.shaderStage,
+            builder.shaderStage!,
             this.name || builder.context.nodeName,
         );
         const uniformName = builder.getPropertyName(nodeUniform);
@@ -194,7 +204,7 @@ export default UniformNode;
  * @param {string} [type] - The node type. If no explicit type is defined, the node tries to derive the type from its value.
  * @returns {UniformNode}
  */
-export const uniform = (value, type) => {
+export const uniform = <TValue>(value: InputNode<TValue> | TValue, type?: Node | string): UniformNode<TValue> => {
     const nodeType = getConstNodeType(type || value);
 
     if (nodeType === value) {
@@ -203,17 +213,17 @@ export const uniform = (value, type) => {
         value = getValueFromType(nodeType);
     }
 
-    if (value && value.isNode === true) {
-        let v = value.value;
+    if (value && (value as Node).isNode === true) {
+        let v = (value as Node).value;
 
-        value.traverse(n => {
-            if (n.isConstNode === true) {
-                v = n.value;
+        (value as Node).traverse(n => {
+            if ((n as ConstNode<unknown>).isConstNode === true) {
+                v = (n as ConstNode<unknown>).value;
             }
         });
 
         value = v;
     }
 
-    return nodeObject(new UniformNode(value, nodeType));
+    return nodeObject(new UniformNode(value as TValue, nodeType));
 };
diff --git a/src-testing/src/nodes/core/constants.ts b/src-testing/src/nodes/core/constants.ts
index 1fe2dbbd..a431897f 100644
--- a/src-testing/src/nodes/core/constants.ts
+++ b/src-testing/src/nodes/core/constants.ts
@@ -7,7 +7,7 @@
 export const NodeShaderStage = {
     VERTEX: 'vertex',
     FRAGMENT: 'fragment',
-};
+} as const;
 
 /**
  * Update types of a node.
@@ -22,7 +22,7 @@ export const NodeUpdateType = {
     FRAME: 'frame',
     RENDER: 'render',
     OBJECT: 'object',
-};
+} as const;
 
 /**
  * Data types of a node.
@@ -47,7 +47,7 @@ export const NodeType = {
     MATRIX2: 'mat2',
     MATRIX3: 'mat3',
     MATRIX4: 'mat4',
-};
+} as const;
 
 /**
  * Access types of a node. These are relevant for compute and storage usage.
@@ -60,9 +60,13 @@ export const NodeAccess = {
     READ_ONLY: 'readOnly',
     WRITE_ONLY: 'writeOnly',
     READ_WRITE: 'readWrite',
-};
+} as const;
 
-export const defaultShaderStages = ['fragment', 'vertex'];
+export type NodeShaderStage = 'vertex' | 'fragment' | 'compute';
+export type NodeUpdateType = 'none' | 'frame' | 'render' | 'object';
+export type NodeAccess = 'readOnly' | 'writeOnly' | 'readWrite';
+
+export const defaultShaderStages: NodeShaderStage[] = ['fragment', 'vertex'];
 export const defaultBuildStages = ['setup', 'analyze', 'generate'];
-export const shaderStages = [...defaultShaderStages, 'compute'];
+export const shaderStages: NodeShaderStage[] = [...defaultShaderStages, 'compute'];
 export const vectorComponents = ['x', 'y', 'z', 'w'];
diff --git a/src-testing/src/nodes/lighting/LightingContextNode.ts b/src-testing/src/nodes/lighting/LightingContextNode.ts
index ee5cf92a..7240bb88 100644
--- a/src-testing/src/nodes/lighting/LightingContextNode.ts
+++ b/src-testing/src/nodes/lighting/LightingContextNode.ts
@@ -1,5 +1,23 @@
 import ContextNode from '../core/ContextNode.js';
 import { nodeProxy, float, vec3 } from '../tsl/TSLBase.js';
+import Node from '../core/Node.js';
+import NodeBuilder from '../core/NodeBuilder.js';
+import LightingModel from '../core/LightingModel.js';
+
+interface LightingContext {
+    radiance: Node;
+    irradiance: Node;
+    iblIrradiance: Node;
+    ambientOcclusion: Node;
+    reflectedLight: {
+        directDiffuse: Node;
+        directSpecular: Node;
+        indirectDiffuse: Node;
+        indirectSpecular: Node;
+    };
+    backdrop: Node | null;
+    backdropAlpha: Node | null;
+}
 
 /**
  * `LightingContextNode` represents an extension of the {@link ContextNode} module
@@ -8,11 +26,17 @@ import { nodeProxy, float, vec3 } from '../tsl/TSLBase.js';
  *
  * @augments ContextNode
  */
-class LightingContextNode extends ContextNode {
+class LightingContextNode extends ContextNode<LightingContext> {
     static get type() {
         return 'LightingContextNode';
     }
 
+    lightingModel: LightingModel | null;
+    backdropNode: Node | null;
+    backdropAlphaNode: Node | null;
+
+    _value: LightingContext | null;
+
     /**
      * Constructs a new lighting context node.
      *
@@ -21,8 +45,13 @@ class LightingContextNode extends ContextNode {
      * @param {?Node<vec3>} [backdropNode=null] - A backdrop node.
      * @param {?Node<float>} [backdropAlphaNode=null] - A backdrop alpha node.
      */
-    constructor(lightsNode, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
-        super(lightsNode);
+    constructor(
+        lightsNode: Node,
+        lightingModel: LightingModel | null = null,
+        backdropNode: Node | null = null,
+        backdropAlphaNode: Node | null = null,
+    ) {
+        super(node);
 
         /**
          * The current lighting model.
@@ -79,7 +108,7 @@ class LightingContextNode extends ContextNode {
             indirectSpecular,
         };
 
-        const context = {
+        const context: LightingContext = {
             radiance: vec3().toVar('radiance'),
             irradiance: vec3().toVar('irradiance'),
             iblIrradiance: vec3().toVar('iblIrradiance'),
@@ -92,7 +121,7 @@ class LightingContextNode extends ContextNode {
         return context;
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         this.value = this._value || (this._value = this.getContext());
         this.value.lightingModel = this.lightingModel || builder.context.lightingModel;
 
diff --git a/src-testing/src/nodes/tsl/TSLCore.ts b/src-testing/src/nodes/tsl/TSLCore.ts
index 614df3fa..9c8bd09c 100644
--- a/src-testing/src/nodes/tsl/TSLCore.ts
+++ b/src-testing/src/nodes/tsl/TSLCore.ts
@@ -9,9 +9,38 @@ import ConstNode from '../core/ConstNode.js';
 import MemberNode from '../utils/MemberNode.js';
 import { getValueFromType, getValueType } from '../core/NodeUtils.js';
 import { warn, error } from '../../utils.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 let currentStack = null;
 
+export interface NodeElements {
+    append: typeof append;
+
+    toColor: typeof color;
+    toFloat: typeof float;
+    toInt: typeof int;
+    toUint: typeof uint;
+    toBool: typeof bool;
+    toVec2: typeof vec2;
+    toIvec2: typeof ivec2;
+    toUvec2: typeof uvec2;
+    toBvec2: typeof bvec2;
+    toVec3: typeof vec3;
+    toIvec3: typeof ivec3;
+    toUvec3: typeof uvec3;
+    toBvec3: typeof bvec3;
+    toVec4: typeof vec4;
+    toIvec4: typeof ivec4;
+    toUvec4: typeof uvec4;
+    toBvec4: typeof bvec4;
+    toMat2: typeof mat2;
+    toMat3: typeof mat3;
+    toMat4: typeof mat4;
+
+    element: typeof element;
+    convert: typeof convert;
+}
+
 const NodeElements = new Map();
 
 // Extend Node Class for TSL using prototype
@@ -45,6 +74,144 @@ export function addMethodChaining(name, nodeElement) {
     }
 }
 
+type XYZWCharacter = 'x' | 'y' | 'z' | 'w';
+type RGBACharacter = 'r' | 'g' | 'b' | 'a';
+type STPQCharacter = 's' | 't' | 'p' | 'q';
+
+type XYZWSwizzle =
+    | `${XYZWCharacter}`
+    | `${XYZWCharacter}${XYZWCharacter}`
+    | `${XYZWCharacter}${XYZWCharacter}${XYZWCharacter}`
+    | `${XYZWCharacter}${XYZWCharacter}${XYZWCharacter}${XYZWCharacter}`;
+
+type RGBASwizzle =
+    | `${RGBACharacter}`
+    | `${RGBACharacter}${RGBACharacter}`
+    | `${RGBACharacter}${RGBACharacter}${RGBACharacter}`
+    | `${RGBACharacter}${RGBACharacter}${RGBACharacter}${RGBACharacter}`;
+
+type STPQSwizzle =
+    | `${STPQCharacter}`
+    | `${STPQCharacter}${STPQCharacter}`
+    | `${STPQCharacter}${STPQCharacter}${STPQCharacter}`
+    | `${STPQCharacter}${STPQCharacter}${STPQCharacter}${STPQCharacter}`;
+
+export type SwizzleOption = XYZWSwizzle | RGBASwizzle | STPQSwizzle;
+
+export type Swizzable = {
+    [Key in SwizzleOption | number]: Node;
+} & {
+    [Key in SwizzleOption as `set${Uppercase<Key>}`]: (value: Node) => Node;
+} & {
+    [Key in SwizzleOption as `flip${Uppercase<Key>}`]: () => Node;
+};
+
+declare module '../Nodes.js' {
+    interface Node extends Swizzable {
+        assign: (sourceNode: Node | number) => Node;
+    }
+}
+
+/** anything that can be passed to {@link nodeObject} */
+export type NodeObjectOption = Node | number | string;
+
+// same logic as in ShaderNodeObject: number,boolean,node->node, otherwise do nothing
+export type NodeObject<T> = T extends Node ? T : T extends number | boolean ? ConstNode<number | boolean> : T;
+
+// opposite of NodeObject: node -> node|boolean|number, otherwise do nothing
+type Proxied<T> = T extends Node | number ? Node | number : T;
+// https://github.com/microsoft/TypeScript/issues/42435#issuecomment-765557874
+export type ProxiedTuple<T extends readonly [...unknown[]]> = [...{ [index in keyof T]: Proxied<T[index]> }];
+export type ProxiedObject<T> = { [index in keyof T]: Proxied<T[index]> };
+type RemoveTail<T extends readonly [...unknown[]]> = T extends [unknown, ...infer X] ? X : [];
+type RemoveHeadAndTail<T extends readonly [...unknown[]]> = T extends [unknown, ...infer X, unknown] ? X : [];
+
+/**
+ * Temporary type to save signatures of 4 constructors. Each element may be tuple or undefined.
+ *
+ * We use an object instead of tuple or union as it makes stuff easier, especially in Typescript 4.0.
+ */
+interface Construtors<
+    A extends undefined | [...unknown[]],
+    B extends undefined | [...unknown[]],
+    C extends undefined | [...unknown[]],
+    D extends undefined | [...unknown[]],
+> {
+    a: A;
+    b: B;
+    c: C;
+    d: D;
+}
+
+/**
+ * Returns all constructors
+ *
+ * <https://github.com/microsoft/TypeScript/issues/37079>
+ * <https://stackoverflow.com/a/52761156/1623826>
+ */
+type OverloadedConstructorsOf<T> = T extends {
+    new (...args: infer A1): unknown;
+    new (...args: infer A2): unknown;
+    new (...args: infer A3): unknown;
+    new (...args: infer A4): unknown;
+}
+    ? Construtors<A1, A2, A3, A4>
+    : T extends {
+            new (...args: infer A1): unknown;
+            new (...args: infer A2): unknown;
+            new (...args: infer A3): unknown;
+        }
+      ? Construtors<A1, A2, A3, undefined>
+      : T extends {
+              new (...args: infer A1): unknown;
+              new (...args: infer A2): unknown;
+          }
+        ? Construtors<A1, A2, undefined, undefined>
+        : T extends new (...args: infer A) => unknown
+          ? Construtors<A, undefined, undefined, undefined>
+          : Construtors<undefined, undefined, undefined, undefined>;
+
+type AnyConstructors = Construtors<any, any, any, any>;
+
+/**
+ * Returns all constructors where the first parameter is assignable to given "scope"
+ */
+// eslint-disable-next-line @typescript-eslint/consistent-type-definitions
+type FilterConstructorsByScope<T extends AnyConstructors, S> = {
+    a: S extends T['a'][0] ? T['a'] : undefined;
+    b: S extends T['b'][0] ? T['b'] : undefined;
+    c: S extends T['c'][0] ? T['c'] : undefined;
+    d: S extends T['d'][0] ? T['d'] : undefined;
+};
+/**
+ * "flattens" the tuple into an union type
+ */
+type ConstructorUnion<T extends AnyConstructors> =
+    | Exclude<T['a'], undefined>
+    | Exclude<T['b'], undefined>
+    | Exclude<T['c'], undefined>
+    | Exclude<T['d'], undefined>;
+
+/**
+ * Extract list of possible scopes - union of the first parameter
+ * of all constructors, should it be string
+ */
+type ExtractScopes<T extends AnyConstructors> =
+    | (T['a'][0] extends string ? T['a'][0] : never)
+    | (T['b'][0] extends string ? T['b'][0] : never)
+    | (T['c'][0] extends string ? T['c'][0] : never)
+    | (T['d'][0] extends string ? T['d'][0] : never);
+
+type GetConstructorsByScope<T, S> = ConstructorUnion<FilterConstructorsByScope<OverloadedConstructorsOf<T>, S>>;
+type GetConstructors<T> = ConstructorUnion<OverloadedConstructorsOf<T>>;
+type GetPossibleScopes<T> = ExtractScopes<OverloadedConstructorsOf<T>>;
+
+export type ConvertType = (...params: unknown[]) => Node;
+
+type NodeArray<T extends NodeObjectOption[]> = { [index in keyof T]: NodeObject<T[index]> };
+type NodeObjects<T> = { [key in keyof T]: T[key] extends NodeObjectOption ? NodeObject<T[key]> : T[key] };
+type ConstructedNode<T> = T extends new (...args: any[]) => infer R ? (R extends Node ? R : never) : never;
+
 const parseSwizzle = props => props.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');
 const parseSwizzleAndSort = props => parseSwizzle(props).split('').sort().join('');
 
@@ -245,7 +412,7 @@ Object.defineProperties(Node.prototype, proto);
 
 const nodeBuilderFunctionsCacheMap = new WeakMap();
 
-const ShaderNodeObject = function (obj, altType = null) {
+const ShaderNodeObject = function <T extends NodeObjectOption>(obj: T, altType: string | null = null) {
     const type = getValueType(obj);
 
     if (type === 'node') {
@@ -356,7 +523,9 @@ const ShaderNodeImmutable = function (NodeClass, ...params) {
 };
 
 class ShaderCallNodeInternal extends Node {
-    constructor(shaderNode, rawInputs) {
+    shaderNode: ShaderNodeInternal;
+
+    constructor(shaderNode: ShaderNodeInternal, rawInputs) {
         super();
 
         this.shaderNode = shaderNode;
@@ -365,7 +534,7 @@ class ShaderCallNodeInternal extends Node {
         this.isShaderCallNodeInternal = true;
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.shaderNode.nodeType || this.getOutputNode(builder).getNodeType(builder);
     }
 
@@ -377,7 +546,7 @@ class ShaderCallNodeInternal extends Node {
         return this.getOutputNode(builder).getMemberType(builder, name);
     }
 
-    call(builder) {
+    call(builder: NodeBuilder) {
         const { shaderNode, rawInputs } = this;
 
         const properties = builder.getNodeProperties(shaderNode);
@@ -599,7 +768,15 @@ function getProxyParameters(params) {
     });
 }
 
+interface Layout {
+    name: string;
+    type: string;
+    inputs: { name: string; type: string }[];
+}
+
 class ShaderNodeInternal extends Node {
+    layout: Layout | null;
+
     constructor(jsFunc, nodeType) {
         super(nodeType);
 
@@ -611,7 +788,7 @@ class ShaderNodeInternal extends Node {
         this.once = false;
     }
 
-    setLayout(layout) {
+    setLayout(layout: Layout | null) {
         this.layout = layout;
 
         return this;
@@ -630,6 +807,8 @@ class ShaderNodeInternal extends Node {
     }
 }
 
+export type { ShaderNodeInternal };
+
 const bools = [false, true];
 const uints = [0, 1, 2, 3];
 const ints = [-1, -2];
@@ -728,11 +907,26 @@ export function ShaderNode(jsFunc, nodeType) {
     return new ShaderNodeInternal(jsFunc, nodeType);
 }
 
-export const nodeObject = (val, altType = null) => /* new */ ShaderNodeObject(val, altType);
+export const nodeObject = <T extends NodeObjectOption>(val: T, altType: string | null = null): NodeObject<T> =>
+    /* new */ ShaderNodeObject(val, altType);
 export const nodeObjectIntent = (val, altType = null) => /* new */ nodeObject(val, altType).toVarIntent();
 export const nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);
 export const nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
-export const nodeProxy = (NodeClass, scope = null, factor = null, settings = null) =>
+
+interface NodeProxy {
+    <T>(nodeClass: T): (...params: ProxiedTuple<GetConstructors<T>>) => ConstructedNode<T>;
+    <T, S extends GetPossibleScopes<T>>(
+        nodeClass: T,
+        scope: S,
+    ): (...params: ProxiedTuple<RemoveTail<GetConstructorsByScope<T, S>>>) => ConstructedNode<T>;
+    <T, S extends GetPossibleScopes<T>>(
+        nodeClass: T,
+        scope: S,
+        factor: NodeObjectOption,
+    ): (...params: ProxiedTuple<RemoveHeadAndTail<GetConstructorsByScope<T, S>>>) => ConstructedNode<T>;
+}
+
+export const nodeProxy: NodeProxy = (NodeClass, scope = null, factor = null, settings = null) =>
     new ShaderNodeProxy(NodeClass, scope, factor, settings);
 export const nodeImmutable = (NodeClass, ...params) => new ShaderNodeImmutable(NodeClass, ...params);
 export const nodeProxyIntent = (NodeClass, scope = null, factor = null, settings = {}) =>
diff --git a/src-testing/src/renderers/common/Animation.ts b/src-testing/src/renderers/common/Animation.ts
index 28092a92..099c5467 100644
--- a/src-testing/src/renderers/common/Animation.ts
+++ b/src-testing/src/renderers/common/Animation.ts
@@ -1,9 +1,26 @@
+import Nodes from './nodes/Nodes.js';
+import Info from './Info.js';
+import Renderer from './Renderer.js';
+
+export interface AnimationContext {
+    requestAnimationFrame(callback: FrameRequestCallback, xrFrame?: XRFrame): number;
+    cancelAnimationFrame(handle: number): void;
+}
+
 /**
  * This module manages the internal animation loop of the renderer.
  *
  * @private
  */
 class Animation {
+    renderer: Renderer;
+    nodes: Nodes;
+    info: Info;
+
+    _context: AnimationContext | null;
+    _animationLoop: ((time: DOMHighResTimeStamp, xrFrame?: XRFrame) => void) | null;
+    _requestId: number | null;
+
     /**
      * Constructs a new animation loop management component.
      *
@@ -11,14 +28,13 @@ class Animation {
      * @param {Nodes} nodes - Renderer component for managing nodes related logic.
      * @param {Info} info - Renderer component for managing metrics and monitoring data.
      */
-    constructor(renderer, nodes, info) {
+    constructor(renderer: Renderer, nodes: Nodes, info: Info) {
         /**
          * A reference to the main renderer.
          *
          * @type {Renderer}
          */
         this.renderer = renderer;
-
         /**
          * Renderer component for managing nodes related logic.
          *
@@ -63,8 +79,8 @@ class Animation {
      * Starts the internal animation loop.
      */
     start() {
-        const update = (time, xrFrame) => {
-            this._requestId = this._context.requestAnimationFrame(update);
+        const update = (time?: DOMHighResTimeStamp, xrFrame?: XRFrame) => {
+            this._requestId = this._context!.requestAnimationFrame(update);
 
             if (this.info.autoReset === true) this.info.reset();
 
@@ -74,7 +90,7 @@ class Animation {
 
             this.renderer._inspector.begin();
 
-            if (this._animationLoop !== null) this._animationLoop(time, xrFrame);
+            if (this._animationLoop !== null) this._animationLoop(time!, xrFrame);
 
             this.renderer._inspector.finish();
         };
@@ -86,7 +102,7 @@ class Animation {
      * Stops the internal animation loop.
      */
     stop() {
-        this._context.cancelAnimationFrame(this._requestId);
+        this._context!.cancelAnimationFrame(this._requestId!);
 
         this._requestId = null;
     }
@@ -105,7 +121,7 @@ class Animation {
      *
      * @param {?Function} callback - The animation loop.
      */
-    setAnimationLoop(callback) {
+    setAnimationLoop(callback: ((time: DOMHighResTimeStamp, xrFrame?: XRFrame) => void) | null) {
         this._animationLoop = callback;
     }
 
@@ -123,7 +139,7 @@ class Animation {
      *
      * @param {Window|XRSession} context - The context to set.
      */
-    setContext(context) {
+    setContext(context: AnimationContext) {
         this._context = context;
     }
 
diff --git a/src-testing/src/renderers/common/Attributes.ts b/src-testing/src/renderers/common/Attributes.ts
index 59ca2d5a..46160831 100644
--- a/src-testing/src/renderers/common/Attributes.ts
+++ b/src-testing/src/renderers/common/Attributes.ts
@@ -2,6 +2,14 @@ import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
 
 import { DynamicDrawUsage } from '../../constants.js';
+import { BufferAttribute } from '../../core/BufferAttribute.js';
+import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
+import Backend from './Backend.js';
+import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
+
+interface Data {
+    version?: number | undefined;
+}
 
 /**
  * This renderer module manages geometry attributes.
@@ -9,13 +17,15 @@ import { DynamicDrawUsage } from '../../constants.js';
  * @private
  * @augments DataMap
  */
-class Attributes extends DataMap {
+class Attributes extends DataMap<{ attribute: { key: BufferAttribute | InterleavedBufferAttribute; value: Data } }> {
+    backend: Backend;
+
     /**
      * Constructs a new attribute management component.
      *
      * @param {Backend} backend - The renderer's backend.
      */
-    constructor(backend) {
+    constructor(backend: Backend) {
         super();
 
         /**
@@ -32,7 +42,7 @@ class Attributes extends DataMap {
      * @param {BufferAttribute} attribute - The attribute.
      * @return {?Object} The deleted attribute data.
      */
-    delete(attribute) {
+    delete(attribute: BufferAttribute | InterleavedBufferAttribute) {
         const attributeData = super.delete(attribute);
 
         if (attributeData !== null) {
@@ -49,7 +59,7 @@ class Attributes extends DataMap {
      * @param {BufferAttribute} attribute - The attribute to update.
      * @param {number} type - The attribute type.
      */
-    update(attribute, type) {
+    update(attribute: BufferAttribute | InterleavedBufferAttribute, type: AttributeType) {
         const data = this.get(attribute);
 
         if (data.version === undefined) {
@@ -82,10 +92,11 @@ class Attributes extends DataMap {
      * @param {BufferAttribute} attribute - The attribute.
      * @return {BufferAttribute|InterleavedBuffer}
      */
-    _getBufferAttribute(attribute) {
-        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
+    _getBufferAttribute(attribute: BufferAttribute | InterleavedBufferAttribute) {
+        if ((attribute as InterleavedBufferAttribute).isInterleavedBufferAttribute)
+            (attribute as BufferAttribute | InterleavedBuffer) = (attribute as InterleavedBufferAttribute).data;
 
-        return attribute;
+        return attribute as BufferAttribute | InterleavedBuffer;
     }
 }
 
diff --git a/src-testing/src/renderers/common/Backend.ts b/src-testing/src/renderers/common/Backend.ts
index 7170229e..21f43820 100644
--- a/src-testing/src/renderers/common/Backend.ts
+++ b/src-testing/src/renderers/common/Backend.ts
@@ -1,10 +1,38 @@
-let _vector2 = null;
-let _color4 = null;
-
 import Color4 from './Color4.js';
 import { Vector2 } from '../../math/Vector2.js';
 import { createCanvasElement, warnOnce } from '../../utils.js';
-import { REVISION, TimestampQuery } from '../../constants.js';
+import { CoordinateSystem, REVISION, TimestampQuery } from '../../constants.js';
+import RenderObject from './RenderObject.js';
+import RenderContext from './RenderContext.js';
+import RenderBundle from './RenderBundle.js';
+import { Texture } from '../../textures/Texture.js';
+import Renderer from './Renderer.js';
+import { BufferAttribute, TypedArray } from '../../core/BufferAttribute.js';
+import { Object3D } from '../../core/Object3D.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import { Scene } from '../../scenes/Scene.js';
+import NodeBuilder from '../../nodes/core/NodeBuilder.js';
+import TimestampQueryPool from './TimestampQueryPool.js';
+
+let _vector2: Vector2 | null = null;
+let _color4: Color4 | null = null;
+
+export interface BackendParameters {
+    canvas?: HTMLCanvasElement | OffscreenCanvas | undefined;
+    antialias?: boolean;
+}
+
+interface RenderContextData {
+    renderObjects?: RenderObject[];
+}
+
+interface RenderBundleData {
+    renderContexts?: Set<RenderContext>;
+}
+
+interface RenderObjectData {}
+
+interface TextureData {}
 
 /**
  * Most of the rendering related logic is implemented in the
@@ -18,13 +46,25 @@ import { REVISION, TimestampQuery } from '../../constants.js';
  * @abstract
  * @private
  */
-class Backend {
+abstract class Backend {
+    parameters: BackendParameters;
+    data: WeakMap<
+        RenderContext | RenderBundle | RenderObject | Texture,
+        RenderContextData | RenderBundleData | RenderObjectData | TextureData
+    >;
+    renderer: Renderer | null;
+    domElement: HTMLCanvasElement | OffscreenCanvas | null;
+    timestampQueryPool: {
+        render: TimestampQueryPool | null;
+        compute: TimestampQueryPool | null;
+    };
+
     /**
      * Constructs a new backend.
      *
      * @param {Object} parameters - An object holding parameters for the backend.
      */
-    constructor(parameters = {}) {
+    constructor(parameters: BackendParameters = {}) {
         /**
          * The parameters of the backend.
          *
@@ -38,7 +78,10 @@ class Backend {
          *
          * @type {WeakMap<Object, Object>}
          */
-        this.data = new WeakMap();
+        this.data = new WeakMap<
+            RenderContext | RenderBundle | RenderObject | Texture,
+            RenderContextData | RenderBundleData | RenderObjectData | TextureData
+        >();
 
         /**
          * A reference to the renderer.
@@ -84,7 +127,7 @@ class Backend {
      * @param {Renderer} renderer - The renderer.
      * @return {Promise} A Promise that resolves when the backend has been initialized.
      */
-    async init(renderer) {
+    async init(renderer: Renderer) {
         this.renderer = renderer;
     }
 
@@ -95,7 +138,9 @@ class Backend {
      * @type {number}
      * @readonly
      */
-    get coordinateSystem() {}
+    abstract get coordinateSystem(): CoordinateSystem;
+
+    abstract getArrayBufferAsync(attribute: BufferAttribute): Promise<ArrayBuffer>;
 
     // render context
 
@@ -263,7 +308,11 @@ class Backend {
      * @param {Renderer} renderer - The renderer.
      * @return {NodeBuilder} The node builder.
      */
-    createNodeBuilder(/*renderObject, renderer*/) {}
+    abstract createNodeBuilder(
+        renderObject: Object3D | ComputeNode,
+        renderer: Renderer,
+        scene?: Scene | null,
+    ): NodeBuilder;
 
     // textures
 
@@ -333,7 +382,14 @@ class Backend {
      * @param {number} faceIndex - The face index.
      * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
      */
-    async copyTextureToBuffer(/*texture, x, y, width, height, faceIndex*/) {}
+    abstract copyTextureToBuffer(
+        texture: Texture,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+        faceIndex: number,
+    ): Promise<TypedArray>;
 
     /**
      * Copies data of the given source texture to the given destination texture.
@@ -519,7 +575,7 @@ class Backend {
      * @param {Object3D} object - The 3D object to test.
      * @return {boolean} Whether the 3D object is fully occluded or not.
      */
-    isOccluded(/*renderContext, object*/) {}
+    abstract isOccluded(/*renderContext, object*/): boolean;
 
     /**
      * Resolves the time stamp for the given render context and type.
@@ -529,7 +585,7 @@ class Backend {
      * @param {string} [type='render'] - The type of the time stamp.
      * @return {Promise<number>} A Promise that resolves with the time stamp.
      */
-    async resolveTimestampsAsync(type = 'render') {
+    async resolveTimestampsAsync(type: TimestampQuery = 'render') {
         if (!this.trackTimestamp) {
             warnOnce('WebGPURenderer: Timestamp tracking is disabled.');
             return;
@@ -543,7 +599,7 @@ class Backend {
 
         const duration = await queryPool.resolveQueriesAsync();
 
-        this.renderer.info[type].timestamp = duration;
+        this.renderer!.info[type].timestamp = duration;
 
         return duration;
     }
@@ -583,7 +639,7 @@ class Backend {
      * @abstract
      * @return {number} The maximum anisotropy texture filtering value.
      */
-    getMaxAnisotropy() {}
+    abstract getMaxAnisotropy(): number;
 
     /**
      * Returns the drawing buffer size.
@@ -593,7 +649,7 @@ class Backend {
     getDrawingBufferSize() {
         _vector2 = _vector2 || new Vector2();
 
-        return this.renderer.getDrawingBufferSize(_vector2);
+        return this.renderer!.getDrawingBufferSize(_vector2);
     }
 
     /**
@@ -615,7 +671,7 @@ class Backend {
 
         _color4 = _color4 || new Color4();
 
-        renderer.getClearColor(_color4);
+        renderer!.getClearColor(_color4);
 
         _color4.getRGB(_color4);
 
@@ -660,7 +716,11 @@ class Backend {
      * @param {Object} object - The object.
      * @return {Object} The object's dictionary.
      */
-    get(object) {
+    get(object: RenderContext): RenderContextData;
+    get(object: RenderBundle): RenderBundleData;
+    get(object: RenderObject): RenderObjectData;
+    get(object: Texture): TextureData;
+    get(object: RenderContext | RenderBundle | RenderObject | Texture) {
         let map = this.data.get(object);
 
         if (map === undefined) {
@@ -678,7 +738,7 @@ class Backend {
      * @param {Object} object - The object.
      * @return {boolean} Whether a dictionary for the given object as been defined or not.
      */
-    has(object) {
+    has(object: RenderContext) {
         return this.data.has(object);
     }
 
@@ -687,7 +747,7 @@ class Backend {
      *
      * @param {Object} object - The object to delete.
      */
-    delete(object) {
+    delete(object: RenderContext) {
         this.data.delete(object);
     }
 
diff --git a/src-testing/src/renderers/common/Background.ts b/src-testing/src/renderers/common/Background.ts
index 2a3192bf..77465a32 100644
--- a/src-testing/src/renderers/common/Background.ts
+++ b/src-testing/src/renderers/common/Background.ts
@@ -17,23 +17,38 @@ import { Mesh } from '../../objects/Mesh.js';
 import { SphereGeometry } from '../../geometries/SphereGeometry.js';
 import { BackSide } from '../../constants.js';
 import { error } from '../../utils.js';
+import { Scene } from '../../scenes/Scene.js';
+import Renderer from './Renderer.js';
+import Nodes from './nodes/Nodes.js';
+import RenderList from './RenderList.js';
+import RenderContext from './RenderContext.js';
 
 const _clearColor = /*@__PURE__*/ new Color4();
 
+interface SceneData {
+    backgroundMesh?: Mesh;
+    // TODO
+    // backgroundMeshNode?: Node;
+    backgroundCacheKey: string;
+}
+
 /**
  * This renderer module manages the background.
  *
  * @private
  * @augments DataMap
  */
-class Background extends DataMap {
+class Background extends DataMap<{ scene: { key: Scene; value: SceneData } }> {
+    renderer: Renderer;
+    nodes: Nodes;
+
     /**
      * Constructs a new background management component.
      *
      * @param {Renderer} renderer - The renderer.
      * @param {Nodes} nodes - Renderer component for managing nodes related logic.
      */
-    constructor(renderer, nodes) {
+    constructor(renderer: Renderer, nodes: Nodes) {
         super();
 
         /**
@@ -61,7 +76,7 @@ class Background extends DataMap {
      * @param {RenderList} renderList - The current render list.
      * @param {RenderContext} renderContext - The current render context.
      */
-    update(scene, renderList, renderContext) {
+    update(scene: Scene, renderList: RenderList, renderContext: RenderContext) {
         const renderer = this.renderer;
         const background = this.nodes.getBackgroundNode(scene) || scene.background;
 
diff --git a/src-testing/src/renderers/common/BindGroup.ts b/src-testing/src/renderers/common/BindGroup.ts
index 50e578f0..5e2b17b7 100644
--- a/src-testing/src/renderers/common/BindGroup.ts
+++ b/src-testing/src/renderers/common/BindGroup.ts
@@ -1,3 +1,6 @@
+import NodeUniformsGroup from './nodes/NodeUniformsGroup.js';
+import Binding from './Binding.js';
+
 let _id = 0;
 
 /**
@@ -8,6 +11,13 @@ let _id = 0;
  * @private
  */
 class BindGroup {
+    name: string;
+    bindings: NodeUniformsGroup[] | Binding[];
+    index: number;
+    bindingsReference: NodeUniformsGroup[] | BindGroup;
+
+    id: number;
+
     /**
      * Constructs a new bind group.
      *
@@ -16,7 +26,12 @@ class BindGroup {
      * @param {number} index - The group index.
      * @param {Array<Binding>} bindingsReference - An array of reference bindings.
      */
-    constructor(name = '', bindings = [], index = 0, bindingsReference = []) {
+    constructor(
+        name = '',
+        bindings: NodeUniformsGroup[] = [],
+        index = 0,
+        bindingsReference: NodeUniformsGroup[] | BindGroup = [],
+    ) {
         /**
          * The bind group's name.
          *
diff --git a/src-testing/src/renderers/common/Binding.ts b/src-testing/src/renderers/common/Binding.ts
index 6b5da502..3830ea5f 100644
--- a/src-testing/src/renderers/common/Binding.ts
+++ b/src-testing/src/renderers/common/Binding.ts
@@ -8,6 +8,10 @@
  * @private
  */
 class Binding {
+    name: string;
+
+    visibility: number;
+
     /**
      * Constructs a new binding.
      *
@@ -35,7 +39,7 @@ class Binding {
      *
      * @param {number} visibility - The shader stage.
      */
-    setVisibility(visibility) {
+    setVisibility(visibility: number) {
         this.visibility |= visibility;
     }
 
@@ -54,7 +58,7 @@ class Binding {
      * @return {Binding} The cloned binding.
      */
     clone() {
-        return Object.assign(new this.constructor(), this);
+        return Object.assign(new (this.constructor as typeof Binding)(), this);
     }
 }
 
diff --git a/src-testing/src/renderers/common/Bindings.ts b/src-testing/src/renderers/common/Bindings.ts
index cd956d21..aedcca90 100644
--- a/src-testing/src/renderers/common/Bindings.ts
+++ b/src-testing/src/renderers/common/Bindings.ts
@@ -1,5 +1,23 @@
 import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
+import Backend from './Backend.js';
+import Nodes from './nodes/Nodes.js';
+import Textures from './Textures.js';
+import Attributes from './Attributes.js';
+import Pipelines from './Pipelines.js';
+import Info from './Info.js';
+import RenderObject from './RenderObject.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import { SampledTexture } from './SampledTexture.js';
+import StorageBuffer from './StorageBuffer.js';
+import NodeUniformsGroup from './nodes/NodeUniformsGroup.js';
+import UniformBuffer from './UniformBuffer.js';
+import Sampler from './Sampler.js';
+import BindGroup from './BindGroup.js';
+
+interface BindGroupData {
+    bindGroup?: BindGroup | undefined;
+}
 
 /**
  * This renderer module manages the bindings of the renderer.
@@ -7,7 +25,7 @@ import { AttributeType } from './Constants.js';
  * @private
  * @augments DataMap
  */
-class Bindings extends DataMap {
+class Bindings extends DataMap<{
     /**
      * Constructs a new bindings management component.
      *
@@ -18,7 +36,23 @@ class Bindings extends DataMap {
      * @param {Pipelines} pipelines - Renderer component for managing pipelines.
      * @param {Info} info - Renderer component for managing metrics and monitoring data.
      */
-    constructor(backend, nodes, textures, attributes, pipelines, info) {
+    bindGroup: { key: BindGroup; value: BindGroupData };
+}> {
+    backend: Backend;
+    textures: Textures;
+    pipelines: Pipelines;
+    attributes: Attributes;
+    nodes: Nodes;
+    info: Info;
+
+    constructor(
+        backend: Backend,
+        nodes: Nodes,
+        textures: Textures,
+        attributes: Attributes,
+        pipelines: Pipelines,
+        info: Info,
+    ) {
         super();
 
         /**
@@ -72,7 +106,7 @@ class Bindings extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {Array<BindGroup>} The bind groups.
      */
-    getForRender(renderObject) {
+    getForRender(renderObject: RenderObject) {
         const bindings = renderObject.getBindings();
 
         for (const bindGroup of bindings) {
@@ -98,7 +132,7 @@ class Bindings extends DataMap {
      * @param {Node} computeNode - The compute node.
      * @return {Array<BindGroup>} The bind groups.
      */
-    getForCompute(computeNode) {
+    getForCompute(computeNode: ComputeNode) {
         const bindings = this.nodes.getForCompute(computeNode).bindings;
 
         for (const bindGroup of bindings) {
@@ -121,7 +155,7 @@ class Bindings extends DataMap {
      *
      * @param {Node} computeNode - The compute node.
      */
-    updateForCompute(computeNode) {
+    updateForCompute(computeNode: ComputeNode) {
         this._updateBindings(this.getForCompute(computeNode));
     }
 
@@ -130,7 +164,7 @@ class Bindings extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         this._updateBindings(this.getForRender(renderObject));
     }
 
@@ -139,7 +173,7 @@ class Bindings extends DataMap {
      *
      * @param {Node} computeNode - The compute node.
      */
-    deleteForCompute(computeNode) {
+    deleteForCompute(computeNode: ComputeNode) {
         const bindings = this.nodes.getForCompute(computeNode).bindings;
 
         for (const bindGroup of bindings) {
@@ -152,7 +186,7 @@ class Bindings extends DataMap {
      *
      * @param {RenderObject} renderObject - The renderObject.
      */
-    deleteForRender(renderObject) {
+    deleteForRender(renderObject: RenderObject) {
         const bindings = renderObject.getBindings();
 
         for (const bindGroup of bindings) {
@@ -165,7 +199,7 @@ class Bindings extends DataMap {
      *
      * @param {Array<BindGroup>} bindings - The bind groups.
      */
-    _updateBindings(bindings) {
+    _updateBindings(bindings: BindGroup[]) {
         for (const bindGroup of bindings) {
             this._update(bindGroup, bindings);
         }
@@ -176,14 +210,14 @@ class Bindings extends DataMap {
      *
      * @param {BindGroup} bindGroup - The bind group to initialize.
      */
-    _init(bindGroup) {
+    _init(bindGroup: BindGroup) {
         for (const binding of bindGroup.bindings) {
-            if (binding.isSampledTexture) {
-                this.textures.updateTexture(binding.texture);
-            } else if (binding.isSampler) {
-                this.textures.updateSampler(binding.texture);
-            } else if (binding.isStorageBuffer) {
-                const attribute = binding.attribute;
+            if ((binding as SampledTexture).isSampledTexture) {
+                this.textures.updateTexture((binding as SampledTexture).texture);
+            } else if ((binding as Sampler).isSampler) {
+                this.textures.updateSampler((binding as Sampler).texture);
+            } else if ((binding as StorageBuffer).isStorageBuffer) {
+                const attribute = (binding as StorageBuffer).attribute;
                 const attributeType = attribute.isIndirectStorageBufferAttribute
                     ? AttributeType.INDIRECT
                     : AttributeType.STORAGE;
@@ -199,7 +233,7 @@ class Bindings extends DataMap {
      * @param {BindGroup} bindGroup - The bind group to update.
      * @param {Array<BindGroup>} bindings - The bind groups.
      */
-    _update(bindGroup, bindings) {
+    _update(bindGroup: BindGroup, bindings: BindGroup[]) {
         const { backend } = this;
 
         let needsBindingsUpdate = false;
@@ -228,18 +262,18 @@ class Bindings extends DataMap {
                 this.attributes.update(attribute, attributeType);
             }
 
-            if (binding.isUniformBuffer) {
-                const updated = binding.update();
+            if ((binding as UniformBuffer).isUniformBuffer) {
+                const updated = (binding as UniformBuffer).update();
 
                 if (updated) {
-                    backend.updateBinding(binding);
+                    backend.updateBinding(binding as UniformBuffer);
                 }
-            } else if (binding.isSampledTexture) {
-                const updated = binding.update();
+            } else if ((binding as SampledTexture).isSampledTexture) {
+                const updated = (binding as SampledTexture).update();
 
                 // get the texture data after the update, to sync the texture reference from node
 
-                const texture = binding.texture;
+                const texture = (binding as SampledTexture).texture;
                 const texturesTextureData = this.textures.get(texture);
 
                 if (updated) {
@@ -270,7 +304,7 @@ class Bindings extends DataMap {
                 if (texture.isStorageTexture === true && texture.mipmapsAutoUpdate === true) {
                     const textureData = this.get(texture);
 
-                    if (binding.store === true) {
+                    if ((binding as SampledTexture).store === true) {
                         textureData.needsMipmap = true;
                     } else if (this.textures.needsMipmaps(texture) && textureData.needsMipmap === true) {
                         this.backend.generateMipmaps(texture);
diff --git a/src-testing/src/renderers/common/Buffer.ts b/src-testing/src/renderers/common/Buffer.ts
index 9b33a9f0..db682bc4 100644
--- a/src-testing/src/renderers/common/Buffer.ts
+++ b/src-testing/src/renderers/common/Buffer.ts
@@ -9,13 +9,21 @@ import { getFloatLength } from './BufferUtils.js';
  * @augments Binding
  */
 class Buffer extends Binding {
+    readonly isBuffer: true;
+
+    bytesPerElement: number;
+
+    _buffer: Float32Array | null;
+
+    _updateRanges: { start: number; count: number }[];
+
     /**
      * Constructs a new buffer.
      *
      * @param {string} name - The buffer's name.
      * @param {TypedArray} [buffer=null] - The buffer.
      */
-    constructor(name, buffer = null) {
+    constructor(name?: string, buffer: Float32Array | null = null) {
         super(name);
 
         /**
@@ -66,7 +74,7 @@ class Buffer extends Binding {
      * @param {number} start - The start index.
      * @param {number} count - The number of elements.
      */
-    addUpdateRange(start, count) {
+    addUpdateRange(start: number, count: number) {
         this.updateRanges.push({ start, count });
     }
 
@@ -84,7 +92,7 @@ class Buffer extends Binding {
      * @readonly
      */
     get byteLength() {
-        return getFloatLength(this._buffer.byteLength);
+        return getFloatLength(this._buffer!.byteLength);
     }
 
     /**
@@ -93,7 +101,7 @@ class Buffer extends Binding {
      * @type {Float32Array}
      * @readonly
      */
-    get buffer() {
+    get buffer(): Float32Array | null {
         return this._buffer;
     }
 
diff --git a/src-testing/src/renderers/common/BufferUtils.ts b/src-testing/src/renderers/common/BufferUtils.ts
index 80f441ef..244f30b2 100644
--- a/src-testing/src/renderers/common/BufferUtils.ts
+++ b/src-testing/src/renderers/common/BufferUtils.ts
@@ -8,7 +8,7 @@ import { GPU_CHUNK_BYTES } from './Constants.js';
  * @param {number} floatLength - The buffer length.
  * @return {number} The padded length.
  */
-function getFloatLength(floatLength) {
+function getFloatLength(floatLength: number) {
     // ensure chunk size alignment (STD140 layout)
 
     return floatLength + ((GPU_CHUNK_BYTES - (floatLength % GPU_CHUNK_BYTES)) % GPU_CHUNK_BYTES);
@@ -23,7 +23,7 @@ function getFloatLength(floatLength) {
  * @param {number} [vectorLength=4] - The vector length.
  * @return {number} The padded length.
  */
-function getVectorLength(count, vectorLength = 4) {
+function getVectorLength(count: number, vectorLength = 4) {
     const strideLength = getStrideLength(vectorLength);
 
     const floatLength = strideLength * count;
@@ -39,7 +39,7 @@ function getVectorLength(count, vectorLength = 4) {
  * @param {number} vectorLength - The vector length.
  * @return {number} The padded length.
  */
-function getStrideLength(vectorLength) {
+function getStrideLength(vectorLength: number) {
     const strideLength = 4;
 
     return vectorLength + ((strideLength - (vectorLength % strideLength)) % strideLength);
diff --git a/src-testing/src/renderers/common/BundleGroup.ts b/src-testing/src/renderers/common/BundleGroup.ts
index c684ced9..52f90d47 100644
--- a/src-testing/src/renderers/common/BundleGroup.ts
+++ b/src-testing/src/renderers/common/BundleGroup.ts
@@ -13,6 +13,13 @@ import { Group } from '../../objects/Group.js';
  * @augments Group
  */
 class BundleGroup extends Group {
+    readonly isBundleGroup: true;
+
+    readonly type: string;
+
+    static: boolean;
+    version: number;
+
     /**
      * Constructs a new bundle group.
      */
@@ -69,7 +76,7 @@ class BundleGroup extends Group {
      * @default false
      * @param {boolean} value
      */
-    set needsUpdate(value) {
+    set needsUpdate(value: boolean) {
         if (value === true) this.version++;
     }
 }
diff --git a/src-testing/src/renderers/common/CanvasTarget.ts b/src-testing/src/renderers/common/CanvasTarget.ts
index 8d9495cd..ae945fa8 100644
--- a/src-testing/src/renderers/common/CanvasTarget.ts
+++ b/src-testing/src/renderers/common/CanvasTarget.ts
@@ -2,19 +2,37 @@ import { EventDispatcher } from '../../core/EventDispatcher.js';
 import { Vector4 } from '../../math/Vector4.js';
 import { FramebufferTexture } from '../../textures/FramebufferTexture.js';
 import { DepthTexture } from '../../textures/DepthTexture.js';
+import { Vector2 } from '../../math/Vector2.js';
+
+export interface CanvasTargetEventMap {
+    resize: {};
+    dispose: {};
+}
 
 /**
  * CanvasTarget is a class that represents the final output destination of the renderer.
  *
  * @augments EventDispatcher
  */
-class CanvasTarget extends EventDispatcher {
+class CanvasTarget extends EventDispatcher<CanvasTargetEventMap> {
+    domElement: HTMLCanvasElement;
+
+    _pixelRatio: number;
+    _width: number;
+    _height: number;
+    _viewport: Vector4;
+    _scissor: Vector4;
+    _scissorTest: boolean;
+
+    colorTexture: FramebufferTexture;
+    depthTexture: DepthTexture;
+
     /**
      * Constructs a new CanvasTarget.
      *
      * @param {HTMLCanvasElement|OffscreenCanvas} domElement - The canvas element to render to.
      */
-    constructor(domElement) {
+    constructor(domElement: HTMLCanvasElement) {
         super();
 
         /**
@@ -105,7 +123,7 @@ class CanvasTarget extends EventDispatcher {
      * @param {Vector2} target - The method writes the result in this target object.
      * @return {Vector2} The drawing buffer size.
      */
-    getDrawingBufferSize(target) {
+    getDrawingBufferSize(target: Vector2) {
         return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
     }
 
@@ -115,7 +133,7 @@ class CanvasTarget extends EventDispatcher {
      * @param {Vector2} target - The method writes the result in this target object.
      * @return {Vector2} The renderer's size in logical pixels.
      */
-    getSize(target) {
+    getSize(target: Vector2) {
         return target.set(this._width, this._height);
     }
 
@@ -145,7 +163,7 @@ class CanvasTarget extends EventDispatcher {
      * @param {number} height - The height in logical pixels.
      * @param {number} pixelRatio - The pixel ratio.
      */
-    setDrawingBufferSize(width, height, pixelRatio) {
+    setDrawingBufferSize(width: number, height: number, pixelRatio: number) {
         // Renderer can't be resized while presenting in XR.
         if (this.xr && this.xr.isPresenting) return;
 
@@ -169,7 +187,7 @@ class CanvasTarget extends EventDispatcher {
      * @param {number} height - The height in logical pixels.
      * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
      */
-    setSize(width, height, updateStyle = true) {
+    setSize(width: number, height: number, updateStyle = true) {
         // Renderer can't be resized while presenting in XR.
         if (this.xr && this.xr.isPresenting) return;
 
@@ -195,7 +213,7 @@ class CanvasTarget extends EventDispatcher {
      * @param {Vector4} target - The method writes the result in this target object.
      * @return {Vector4} The scissor rectangle.
      */
-    getScissor(target) {
+    getScissor(target: Vector4) {
         const scissor = this._scissor;
 
         target.x = scissor.x;
@@ -215,13 +233,15 @@ class CanvasTarget extends EventDispatcher {
      * @param {number} width - The width of the scissor box in logical pixel unit.
      * @param {number} height - The height of the scissor box in logical pixel unit.
      */
-    setScissor(x, y, width, height) {
+    setScissor(x: Vector4): void;
+    setScissor(x: number, y: number, width: number, height: number): void;
+    setScissor(x: number | Vector4, y?: number, width?: number, height?: number) {
         const scissor = this._scissor;
 
-        if (x.isVector4) {
-            scissor.copy(x);
+        if ((x as Vector4).isVector4) {
+            scissor.copy(x as Vector4);
         } else {
-            scissor.set(x, y, width, height);
+            scissor.set(x as number, y!, width!, height!);
         }
     }
 
@@ -239,7 +259,7 @@ class CanvasTarget extends EventDispatcher {
      *
      * @param {boolean} boolean - Whether the scissor test should be enabled or not.
      */
-    setScissorTest(boolean) {
+    setScissorTest(boolean: boolean) {
         this._scissorTest = boolean;
     }
 
@@ -249,7 +269,7 @@ class CanvasTarget extends EventDispatcher {
      * @param {Vector4} target - The method writes the result in this target object.
      * @return {Vector4} The viewport definition.
      */
-    getViewport(target) {
+    getViewport(target: Vector4) {
         return target.copy(this._viewport);
     }
 
@@ -263,13 +283,15 @@ class CanvasTarget extends EventDispatcher {
      * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.
      * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.
      */
-    setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {
+    setViewport(x: Vector4): void;
+    setViewport(x: number, y: number, width: number, height: number, minDepth?: number, maxDepth?: number): void;
+    setViewport(x: number | Vector4, y?: number, width?: number, height?: number, minDepth = 0, maxDepth = 1) {
         const viewport = this._viewport;
 
-        if (x.isVector4) {
-            viewport.copy(x);
+        if ((x as Vector4).isVector4) {
+            viewport.copy(x as Vector4);
         } else {
-            viewport.set(x, y, width, height);
+            viewport.set(x as number, y!, width!, height!);
         }
 
         viewport.minDepth = minDepth;
diff --git a/src-testing/src/renderers/common/ChainMap.ts b/src-testing/src/renderers/common/ChainMap.ts
index bed4d6c2..96c476a2 100644
--- a/src-testing/src/renderers/common/ChainMap.ts
+++ b/src-testing/src/renderers/common/ChainMap.ts
@@ -1,3 +1,5 @@
+type RecursiveWeakMap<K extends readonly object[], V> = WeakMap<K[number], V | RecursiveWeakMap<K, V>>;
+
 /**
  * Data structure for the renderer. It allows defining values
  * with chained, hierarchical keys. Keys are meant to be
@@ -6,7 +8,8 @@
  *
  * @private
  */
-class ChainMap {
+class ChainMap<K extends readonly object[], V> {
+    weakMap: RecursiveWeakMap<K, V>;
     /**
      * Constructs a new Chain Map.
      */
@@ -16,7 +19,7 @@ class ChainMap {
          *
          * @type {WeakMap<Object, WeakMap>}
          */
-        this.weakMap = new WeakMap();
+        this.weakMap = new WeakMap<K[number], V | RecursiveWeakMap<K, V>>();
     }
 
     /**
@@ -25,16 +28,16 @@ class ChainMap {
      * @param {Array<Object>} keys - List of keys.
      * @return {any} The value. Returns `undefined` if no value was found.
      */
-    get(keys) {
-        let map = this.weakMap;
+    get(keys: K): V | undefined {
+        let map: RecursiveWeakMap<K, V> | undefined = this.weakMap;
 
         for (let i = 0; i < keys.length - 1; i++) {
-            map = map.get(keys[i]);
+            map = map.get(keys[i]) as RecursiveWeakMap<K, V> | undefined;
 
             if (map === undefined) return undefined;
         }
 
-        return map.get(keys[keys.length - 1]);
+        return map.get(keys[keys.length - 1]) as V | undefined;
     }
 
     /**
@@ -44,18 +47,18 @@ class ChainMap {
      * @param {any} value - The value to set.
      * @return {ChainMap} A reference to this Chain Map.
      */
-    set(keys, value) {
-        let map = this.weakMap;
+    set(keys: K, value: V) {
+        let map: RecursiveWeakMap<K, V> = this.weakMap;
 
         for (let i = 0; i < keys.length - 1; i++) {
             const key = keys[i];
 
-            if (map.has(key) === false) map.set(key, new WeakMap());
+            if (map.has(key) === false) map.set(key, new WeakMap<K[number], V | RecursiveWeakMap<K, V>>());
 
-            map = map.get(key);
+            map = map.get(key) as RecursiveWeakMap<K, V>;
         }
 
-        map.set(keys[keys.length - 1], value);
+        map.set(keys[keys.length - 1], value) as V;
 
         return this;
     }
@@ -66,11 +69,11 @@ class ChainMap {
      * @param {Array<Object>} keys - The keys.
      * @return {boolean} Returns `true` if the value has been removed successfully and `false` if the value has not be found.
      */
-    delete(keys) {
-        let map = this.weakMap;
+    delete(keys: K) {
+        let map: RecursiveWeakMap<K, V> | undefined = this.weakMap;
 
         for (let i = 0; i < keys.length - 1; i++) {
-            map = map.get(keys[i]);
+            map = map.get(keys[i]) as RecursiveWeakMap<K, V> | undefined;
 
             if (map === undefined) return false;
         }
diff --git a/src-testing/src/renderers/common/ClippingContext.ts b/src-testing/src/renderers/common/ClippingContext.ts
index 41243208..33f82c41 100644
--- a/src-testing/src/renderers/common/ClippingContext.ts
+++ b/src-testing/src/renderers/common/ClippingContext.ts
@@ -1,6 +1,10 @@
 import { Matrix3 } from '../../math/Matrix3.js';
 import { Plane } from '../../math/Plane.js';
 import { Vector4 } from '../../math/Vector4.js';
+import { Matrix4 } from '../../math/Matrix4.js';
+import { Camera } from '../../cameras/Camera.js';
+import { Scene } from '../../scenes/Scene.js';
+import { ClippingGroup } from '../../objects/ClippingGroup.js';
 
 const _plane = /*@__PURE__*/ new Plane();
 
@@ -13,12 +17,29 @@ const _plane = /*@__PURE__*/ new Plane();
  * @private
  */
 class ClippingContext {
+    version: number;
+
+    clipIntersection: boolean | null;
+    cacheKey: string;
+
+    intersectionPlanes?: Plane[];
+    unionPlanes?: Plane[];
+
+    viewNormalMatrix: Matrix3;
+    clippingGroupContexts: WeakMap<ClippingGroup, ClippingContext>;
+
+    shadowPass: boolean;
+
+    viewMatrix?: Matrix4;
+
+    parentVersion: number | null;
+
     /**
      * Constructs a new clipping context.
      *
      * @param {?ClippingContext} [parentContext=null] - A reference to the parent clipping context.
      */
-    constructor(parentContext = null) {
+    constructor(parentContext: ClippingContext | null = null) {
         /**
          * The clipping context's version.
          *
@@ -103,11 +124,11 @@ class ClippingContext {
      * @param {Array<Vector4>} destination - The destination.
      * @param {number} offset - The offset.
      */
-    projectPlanes(source, destination, offset) {
+    projectPlanes(source: readonly Plane[], destination: readonly Vector4[], offset: number) {
         const l = source.length;
 
         for (let i = 0; i < l; i++) {
-            _plane.copy(source[i]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
+            _plane.copy(source[i]).applyMatrix4(this.viewMatrix!, this.viewNormalMatrix);
 
             const v = destination[offset + i];
             const normal = _plane.normal;
@@ -125,7 +146,7 @@ class ClippingContext {
      * @param {Scene} scene - The scene.
      * @param {Camera} camera - The camera that is used to render the scene.
      */
-    updateGlobal(scene, camera) {
+    updateGlobal(scene: Scene, camera: Camera) {
         this.shadowPass = scene.overrideMaterial !== null && scene.overrideMaterial.isShadowPassMaterial;
         this.viewMatrix = camera.matrixWorldInverse;
 
@@ -138,12 +159,12 @@ class ClippingContext {
      * @param {ClippingContext} parentContext - The parent context.
      * @param {ClippingGroup} clippingGroup - The clipping group this context belongs to.
      */
-    update(parentContext, clippingGroup) {
+    update(parentContext: ClippingContext, clippingGroup: ClippingGroup) {
         let update = false;
 
         if (parentContext.version !== this.parentVersion) {
-            this.intersectionPlanes = Array.from(parentContext.intersectionPlanes);
-            this.unionPlanes = Array.from(parentContext.unionPlanes);
+            this.intersectionPlanes = Array.from(parentContext.intersectionPlanes!);
+            this.unionPlanes = Array.from(parentContext.unionPlanes!);
             this.parentVersion = parentContext.version;
         }
 
@@ -151,24 +172,24 @@ class ClippingContext {
             this.clipIntersection = clippingGroup.clipIntersection;
 
             if (this.clipIntersection) {
-                this.unionPlanes.length = parentContext.unionPlanes.length;
+                this.unionPlanes!.length = parentContext.unionPlanes!.length;
             } else {
-                this.intersectionPlanes.length = parentContext.intersectionPlanes.length;
+                this.intersectionPlanes!.length = parentContext.intersectionPlanes!.length;
             }
         }
 
         const srcClippingPlanes = clippingGroup.clippingPlanes;
         const l = srcClippingPlanes.length;
 
-        let dstClippingPlanes;
+        let dstClippingPlanes: (Plane | Vector4)[];
         let offset;
 
         if (this.clipIntersection) {
-            dstClippingPlanes = this.intersectionPlanes;
-            offset = parentContext.intersectionPlanes.length;
+            dstClippingPlanes = this.intersectionPlanes!;
+            offset = parentContext.intersectionPlanes!.length;
         } else {
-            dstClippingPlanes = this.unionPlanes;
-            offset = parentContext.unionPlanes.length;
+            dstClippingPlanes = this.unionPlanes!;
+            offset = parentContext.unionPlanes!.length;
         }
 
         if (dstClippingPlanes.length !== offset + l) {
@@ -181,11 +202,11 @@ class ClippingContext {
             update = true;
         }
 
-        this.projectPlanes(srcClippingPlanes, dstClippingPlanes, offset);
+        this.projectPlanes(srcClippingPlanes, dstClippingPlanes as Vector4[], offset);
 
         if (update) {
             this.version++;
-            this.cacheKey = `${this.intersectionPlanes.length}:${this.unionPlanes.length}`;
+            this.cacheKey = `${this.intersectionPlanes!.length}:${this.unionPlanes!.length}`;
         }
     }
 
@@ -195,7 +216,7 @@ class ClippingContext {
      * @param {ClippingGroup} clippingGroup - The clipping group.
      * @return {ClippingContext} The clipping context.
      */
-    getGroupContext(clippingGroup) {
+    getGroupContext(clippingGroup: ClippingGroup) {
         if (this.shadowPass && !clippingGroup.clipShadows) return this;
 
         let context = this.clippingGroupContexts.get(clippingGroup);
@@ -217,7 +238,7 @@ class ClippingContext {
      * @readonly
      */
     get unionClippingCount() {
-        return this.unionPlanes.length;
+        return this.unionPlanes!.length;
     }
 }
 
diff --git a/src-testing/src/renderers/common/Color4.ts b/src-testing/src/renderers/common/Color4.ts
index 6bb6739d..1e073e79 100644
--- a/src-testing/src/renderers/common/Color4.ts
+++ b/src-testing/src/renderers/common/Color4.ts
@@ -1,4 +1,4 @@
-import { Color } from '../../math/Color.js';
+import { Color, ColorRepresentation } from '../../math/Color.js';
 
 /**
  * A four-component version of {@link Color} which is internally
@@ -9,6 +9,8 @@ import { Color } from '../../math/Color.js';
  * @augments Color
  */
 class Color4 extends Color {
+    a: number;
+
     /**
      * Constructs a new four-component color.
      * You can also pass a single THREE.Color, hex or
@@ -19,8 +21,10 @@ class Color4 extends Color {
      * @param {number} [b=1] - The blue value.
      * @param {number} [a=1] - The alpha value.
      */
-    constructor(r, g, b, a = 1) {
-        super(r, g, b);
+    constructor(color?: ColorRepresentation);
+    constructor(r: number, g: number, b: number, a?: number);
+    constructor(r?: number, g?: number, b?: number, a = 1) {
+        super(r as number, g!, b!);
 
         this.a = a;
     }
@@ -36,7 +40,8 @@ class Color4 extends Color {
      * @param {number} [a=1] - The alpha value.
      * @return {Color4} A reference to this object.
      */
-    set(r, g, b, a = 1) {
+    set(...args: [color: ColorRepresentation] | [r: number, g: number, b: number, a?: number]): this;
+    set(r: number, g: number, b: number, a = 1) {
         this.a = a;
 
         return super.set(r, g, b);
@@ -48,8 +53,8 @@ class Color4 extends Color {
      * @param {Color4} color - The color to copy.
      * @return {Color4} A reference to this object.
      */
-    copy(color) {
-        if (color.a !== undefined) this.a = color.a;
+    copy(color: Color) {
+        if ((color as Color4).a !== undefined) this.a = (color as Color4).a;
 
         return super.copy(color);
     }
@@ -59,8 +64,8 @@ class Color4 extends Color {
      *
      * @return {Color4} The cloned color.
      */
-    clone() {
-        return new this.constructor(this.r, this.g, this.b, this.a);
+    clone(): this {
+        return new (this.constructor as typeof Color4)(this.r, this.g, this.b, this.a) as this;
     }
 }
 
diff --git a/src-testing/src/renderers/common/ComputePipeline.ts b/src-testing/src/renderers/common/ComputePipeline.ts
index f48a81f6..0cac27d8 100644
--- a/src-testing/src/renderers/common/ComputePipeline.ts
+++ b/src-testing/src/renderers/common/ComputePipeline.ts
@@ -1,4 +1,5 @@
 import Pipeline from './Pipeline.js';
+import ProgrammableStage from './ProgrammableStage.js';
 
 /**
  * Class for representing compute pipelines.
@@ -7,13 +8,17 @@ import Pipeline from './Pipeline.js';
  * @augments Pipeline
  */
 class ComputePipeline extends Pipeline {
+    computeProgram: ProgrammableStage;
+
+    readonly isComputePipeline: true;
+
     /**
      * Constructs a new render pipeline.
      *
      * @param {string} cacheKey - The pipeline's cache key.
      * @param {ProgrammableStage} computeProgram - The pipeline's compute shader.
      */
-    constructor(cacheKey, computeProgram) {
+    constructor(cacheKey: string, computeProgram: ProgrammableStage) {
         super(cacheKey);
 
         /**
diff --git a/src-testing/src/renderers/common/Constants.ts b/src-testing/src/renderers/common/Constants.ts
index c2dfad4c..02330947 100644
--- a/src-testing/src/renderers/common/Constants.ts
+++ b/src-testing/src/renderers/common/Constants.ts
@@ -3,7 +3,9 @@ export const AttributeType = {
     INDEX: 2,
     STORAGE: 3,
     INDIRECT: 4,
-};
+} as const;
+
+export type AttributeType = (typeof AttributeType)[keyof typeof AttributeType];
 
 // size of a chunk in bytes (STD140 layout)
 
diff --git a/src-testing/src/renderers/common/CubeRenderTarget.ts b/src-testing/src/renderers/common/CubeRenderTarget.ts
index 21bea83b..883eadb8 100644
--- a/src-testing/src/renderers/common/CubeRenderTarget.ts
+++ b/src-testing/src/renderers/common/CubeRenderTarget.ts
@@ -9,6 +9,9 @@ import { CubeCamera } from '../../cameras/CubeCamera.js';
 import { BoxGeometry } from '../../geometries/BoxGeometry.js';
 import { Mesh } from '../../objects/Mesh.js';
 import { BackSide, NoBlending, LinearFilter, LinearMipmapLinearFilter } from '../../constants.js';
+import { RenderTargetOptions } from '../../core/RenderTarget.js';
+import { WebGLRenderer } from '../WebGLRenderer.js';
+import { Texture } from '../../textures/Texture.js';
 
 // @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget
 
@@ -19,13 +22,15 @@ import { BackSide, NoBlending, LinearFilter, LinearMipmapLinearFilter } from '..
  * @augments WebGLCubeRenderTarget
  */
 class CubeRenderTarget extends WebGLCubeRenderTarget {
+    readonly isCubeRenderTarget: true;
+
     /**
      * Constructs a new cube render target.
      *
      * @param {number} [size=1] - The size of the render target.
      * @param {RenderTarget~Options} [options] - The configuration object.
      */
-    constructor(size = 1, options = {}) {
+    constructor(size = 1, options: RenderTargetOptions = {}) {
         super(size, options);
 
         /**
@@ -45,7 +50,7 @@ class CubeRenderTarget extends WebGLCubeRenderTarget {
      * @param {Texture} texture - The equirectangular texture.
      * @return {CubeRenderTarget} A reference to this cube render target.
      */
-    fromEquirectangularTexture(renderer, texture) {
+    fromEquirectangularTexture(renderer: WebGLRenderer, texture: Texture) {
         const currentMinFilter = texture.minFilter;
         const currentGenerateMipmaps = texture.generateMipmaps;
 
diff --git a/src-testing/src/renderers/common/DataMap.ts b/src-testing/src/renderers/common/DataMap.ts
index b751ce9c..2de61938 100644
--- a/src-testing/src/renderers/common/DataMap.ts
+++ b/src-testing/src/renderers/common/DataMap.ts
@@ -4,7 +4,9 @@
  *
  * @private
  */
-class DataMap {
+class DataMap<M extends { [key: string]: { key: object; value: unknown } }> {
+    data: WeakMap<M[keyof M]['key'], M[keyof M]['value']>;
+
     /**
      * Constructs a new data map.
      */
@@ -15,7 +17,7 @@ class DataMap {
          *
          * @type {WeakMap<Object, Object>}
          */
-        this.data = new WeakMap();
+        this.data = new WeakMap<M[keyof M]['key'], M[keyof M]['value']>();
     }
 
     /**
@@ -24,7 +26,7 @@ class DataMap {
      * @param {Object} object - The object.
      * @return {Object} The dictionary.
      */
-    get(object) {
+    get<K extends M[keyof M]['key']>(object: K): Extract<M[keyof M], { key: K }>['value'] {
         let map = this.data.get(object);
 
         if (map === undefined) {
@@ -41,7 +43,7 @@ class DataMap {
      * @param {Object} object - The object.
      * @return {?Object} The deleted dictionary.
      */
-    delete(object) {
+    delete<K extends M[keyof M]['key']>(object: K): Extract<M[keyof M], { key: K }>['value'] {
         let map = null;
 
         if (this.data.has(object)) {
@@ -59,7 +61,7 @@ class DataMap {
      * @param {Object} object - The object to test.
      * @return {boolean} Whether a dictionary is defined or not.
      */
-    has(object) {
+    has(object: M[keyof M]['key']) {
         return this.data.has(object);
     }
 
diff --git a/src-testing/src/renderers/common/Geometries.ts b/src-testing/src/renderers/common/Geometries.ts
index 085b1980..69664324 100644
--- a/src-testing/src/renderers/common/Geometries.ts
+++ b/src-testing/src/renderers/common/Geometries.ts
@@ -2,7 +2,13 @@ import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
 import { arrayNeedsUint32 } from '../../utils.js';
 
-import { Uint16BufferAttribute, Uint32BufferAttribute } from '../../core/BufferAttribute.js';
+import { BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from '../../core/BufferAttribute.js';
+import { BufferGeometry } from '../../core/BufferGeometry.js';
+import Attributes from './Attributes.js';
+import Info from './Info.js';
+import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
+import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
+import RenderObject from './RenderObject.js';
 
 /**
  * Returns the wireframe version for the given geometry.
@@ -12,8 +18,8 @@ import { Uint16BufferAttribute, Uint32BufferAttribute } from '../../core/BufferA
  * @param {BufferGeometry} geometry - The geometry.
  * @return {number} The version.
  */
-function getWireframeVersion(geometry) {
-    return geometry.index !== null ? geometry.index.version : geometry.attributes.position.version;
+function getWireframeVersion(geometry: BufferGeometry) {
+    return geometry.index !== null ? geometry.index.version : (geometry.attributes.position as BufferAttribute).version;
 }
 
 /**
@@ -24,7 +30,7 @@ function getWireframeVersion(geometry) {
  * @param {BufferGeometry} geometry - The geometry.
  * @return {BufferAttribute} The wireframe index attribute.
  */
-function getWireframeIndex(geometry) {
+function getWireframeIndex(geometry: BufferGeometry) {
     const indices = [];
 
     const geometryIndex = geometry.index;
@@ -58,20 +64,30 @@ function getWireframeIndex(geometry) {
     return attribute;
 }
 
+interface GeometryData {
+    initialized?: boolean | undefined;
+}
+
 /**
  * This renderer module manages geometries.
  *
  * @private
  * @augments DataMap
  */
-class Geometries extends DataMap {
+class Geometries extends DataMap<{ geometry: { key: BufferGeometry; value: GeometryData } }> {
+    attributes: Attributes;
+    info: Info;
+
+    wireframes: WeakMap<BufferGeometry, BufferAttribute>;
+    attributeCall: WeakMap<BufferAttribute | InterleavedBufferAttribute | InterleavedBuffer, number>;
+
     /**
      * Constructs a new geometry management component.
      *
      * @param {Attributes} attributes - Renderer component for managing attributes.
      * @param {Info} info - Renderer component for managing metrics and monitoring data.
      */
-    constructor(attributes, info) {
+    constructor(attributes: Attributes, info: Info) {
         super();
 
         /**
@@ -93,7 +109,7 @@ class Geometries extends DataMap {
          *
          * @type {WeakMap<BufferGeometry,BufferAttribute>}
          */
-        this.wireframes = new WeakMap();
+        this.wireframes = new WeakMap<BufferGeometry, BufferAttribute>();
 
         /**
          * This Weak Map is used to make sure buffer attributes are
@@ -101,7 +117,7 @@ class Geometries extends DataMap {
          *
          * @type {WeakMap<BufferAttribute,number>}
          */
-        this.attributeCall = new WeakMap();
+        this.attributeCall = new WeakMap<BufferAttribute | InterleavedBufferAttribute, number>();
 
         /**
          * Stores the event listeners attached to geometries.
@@ -118,8 +134,8 @@ class Geometries extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {boolean} Whether if the given render object has an initialized geometry or not.
      */
-    has(renderObject) {
-        const geometry = renderObject.geometry;
+    has(renderObject: RenderObject | BufferGeometry) {
+        const geometry = (renderObject as RenderObject).geometry;
 
         return super.has(geometry) && this.get(geometry).initialized === true;
     }
@@ -129,7 +145,7 @@ class Geometries extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         if (this.has(renderObject) === false) this.initGeometry(renderObject);
 
         this.updateAttributes(renderObject);
@@ -140,7 +156,7 @@ class Geometries extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    initGeometry(renderObject) {
+    initGeometry(renderObject: RenderObject) {
         const geometry = renderObject.geometry;
         const geometryData = this.get(geometry);
 
@@ -185,9 +201,8 @@ class Geometries extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateAttributes(renderObject) {
+    updateAttributes(renderObject: RenderObject) {
         // attributes
-
         const attributes = renderObject.getAttributes();
 
         for (const attribute of attributes) {
@@ -221,10 +236,10 @@ class Geometries extends DataMap {
      * @param {BufferAttribute} attribute - The attribute to update.
      * @param {number} type - The attribute type.
      */
-    updateAttribute(attribute, type) {
+    updateAttribute(attribute: BufferAttribute | InterleavedBufferAttribute, type: AttributeType) {
         const callId = this.info.render.calls;
 
-        if (!attribute.isInterleavedBufferAttribute) {
+        if (!(attribute as InterleavedBufferAttribute).isInterleavedBufferAttribute) {
             if (this.attributeCall.get(attribute) !== callId) {
                 this.attributes.update(attribute, type);
 
@@ -235,10 +250,10 @@ class Geometries extends DataMap {
                 this.attributes.update(attribute, type);
 
                 this.attributeCall.set(attribute, callId);
-            } else if (this.attributeCall.get(attribute.data) !== callId) {
+            } else if (this.attributeCall.get((attribute as InterleavedBufferAttribute).data) !== callId) {
                 this.attributes.update(attribute, type);
 
-                this.attributeCall.set(attribute.data, callId);
+                this.attributeCall.set((attribute as InterleavedBufferAttribute).data, callId);
 
                 this.attributeCall.set(attribute, callId);
             }
@@ -251,7 +266,7 @@ class Geometries extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
      */
-    getIndirect(renderObject) {
+    getIndirect(renderObject: RenderObject) {
         return renderObject.geometry.indirect;
     }
 
@@ -262,7 +277,7 @@ class Geometries extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
      */
-    getIndex(renderObject) {
+    getIndex(renderObject: RenderObject) {
         const { geometry, material } = renderObject;
 
         let index = geometry.index;
diff --git a/src-testing/src/renderers/common/Info.ts b/src-testing/src/renderers/common/Info.ts
index 17e7f872..b22127bd 100644
--- a/src-testing/src/renderers/common/Info.ts
+++ b/src-testing/src/renderers/common/Info.ts
@@ -1,4 +1,10 @@
 import { error } from '../../utils.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Mesh } from '../../objects/Mesh.js';
+import { Sprite } from '../../objects/Sprite.js';
+import { Points } from '../../objects/Points.js';
+import { LineSegments } from '../../objects/LineSegments.js';
+import { Line } from '../../objects/Line.js';
 
 /**
  * This renderer module provides a series of statistical information
@@ -6,6 +12,32 @@ import { error } from '../../utils.js';
  * and monitoring.
  */
 class Info {
+    autoReset: boolean;
+
+    frame: number;
+    calls: number;
+
+    render: {
+        calls: number;
+        frameCalls: number;
+        drawCalls: number;
+        triangles: number;
+        points: number;
+        lines: number;
+        timestamp: number;
+    };
+
+    compute: {
+        calls: number;
+        frameCalls: number;
+        timestamp: number;
+    };
+
+    memory: {
+        geometries: number;
+        textures: number;
+    };
+
     /**
      * Constructs a new info component.
      */
@@ -100,16 +132,16 @@ class Info {
      * @param {number} count - The vertex or index count.
      * @param {number} instanceCount - The instance count.
      */
-    update(object, count, instanceCount) {
+    update(object: Object3D, count: number, instanceCount: number) {
         this.render.drawCalls++;
 
-        if (object.isMesh || object.isSprite) {
+        if ((object as Mesh).isMesh || (object as Sprite).isSprite) {
             this.render.triangles += instanceCount * (count / 3);
-        } else if (object.isPoints) {
+        } else if ((object as Points).isPoints) {
             this.render.points += instanceCount * count;
-        } else if (object.isLineSegments) {
+        } else if ((object as LineSegments).isLineSegments) {
             this.render.lines += instanceCount * (count / 2);
-        } else if (object.isLine) {
+        } else if ((object as Line).isLine) {
             this.render.lines += instanceCount * (count - 1);
         } else {
             error('WebGPUInfo: Unknown object type.');
diff --git a/src-testing/src/renderers/common/InspectorBase.ts b/src-testing/src/renderers/common/InspectorBase.ts
index 5219fa00..3d776052 100644
--- a/src-testing/src/renderers/common/InspectorBase.ts
+++ b/src-testing/src/renderers/common/InspectorBase.ts
@@ -1,9 +1,18 @@
+import Renderer from './Renderer.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import { Scene } from '../../scenes/Scene.js';
+import { Camera } from '../../cameras/Camera.js';
+import { RenderTarget } from '../../core/RenderTarget.js';
+import { Texture } from '../../textures/Texture.js';
+
 /**
  * InspectorBase is the base class for all inspectors.
  *
  * @class InspectorBase
  */
 class InspectorBase {
+    _renderer: Renderer | null;
+
     /**
      * Creates a new InspectorBase.
      */
@@ -30,7 +39,7 @@ class InspectorBase {
      * @return {Object} The node frame.
      */
     get nodeFrame() {
-        return this._renderer._nodes.nodeFrame;
+        return this._renderer!._nodes!.nodeFrame;
     }
 
     /**
@@ -39,7 +48,7 @@ class InspectorBase {
      * @param {WebGLRenderer} renderer - The renderer to associate with this inspector.
      * @return {InspectorBase} This inspector instance.
      */
-    setRenderer(renderer) {
+    setRenderer(renderer: Renderer | null) {
         this._renderer = renderer;
 
         return this;
@@ -82,7 +91,7 @@ class InspectorBase {
      * @param {ComputeNode} computeNode - The compute node being executed.
      * @param {number|Array<number>} dispatchSizeOrCount - The dispatch size or count.
      */
-    computeAsync(/*computeNode, dispatchSizeOrCount*/) {}
+    computeAsync(computeNode: ComputeNode, dispatchSizeOrCount: number | number[]) {}
 
     /**
      * Called when a compute operation begins.
@@ -90,7 +99,7 @@ class InspectorBase {
      * @param {string} uid - A unique identifier for the render context.
      * @param {ComputeNode} computeNode - The compute node being executed.
      */
-    beginCompute(/*uid, computeNode*/) {}
+    beginCompute(uid: string, computeNode: ComputeNode) {}
 
     /**
      * Called when a compute operation ends.
@@ -98,7 +107,7 @@ class InspectorBase {
      * @param {string} uid - A unique identifier for the render context.
      * @param {ComputeNode} computeNode - The compute node being executed.
      */
-    finishCompute(/*uid*/) {}
+    finishCompute(uid: string) {}
 
     /**
      * Called when a render operation begins.
@@ -108,14 +117,14 @@ class InspectorBase {
      * @param {Camera} camera - The camera being used for rendering.
      * @param {?WebGLRenderTarget} renderTarget - The render target, if any.
      */
-    beginRender(/*uid, scene, camera, renderTarget*/) {}
+    beginRender(uid: string, scene: Scene, camera: Camera, renderTarget: RenderTarget) {}
 
     /**
      * Called when an animation loop ends.
      *
      * @param {string} uid - A unique identifier for the render context.
      */
-    finishRender(/*uid*/) {}
+    finishRender(uid: string) {}
 
     /**
      * Called when a texture copy operation is performed.
@@ -123,14 +132,14 @@ class InspectorBase {
      * @param {Texture} srcTexture - The source texture.
      * @param {Texture} dstTexture - The destination texture.
      */
-    copyTextureToTexture(/*srcTexture, dstTexture*/) {}
+    copyTextureToTexture(srcTexture: Texture, dstTexture: Texture) {}
 
     /**
      * Called when a framebuffer copy operation is performed.
      *
      * @param {Texture} framebufferTexture - The texture associated with the framebuffer.
      */
-    copyFramebufferToTexture(/*framebufferTexture*/) {}
+    copyFramebufferToTexture(framebufferTexture: Texture) {}
 }
 
 export default InspectorBase;
diff --git a/src-testing/src/renderers/common/Pipeline.ts b/src-testing/src/renderers/common/Pipeline.ts
index ea931b7e..4bfaa3c1 100644
--- a/src-testing/src/renderers/common/Pipeline.ts
+++ b/src-testing/src/renderers/common/Pipeline.ts
@@ -5,12 +5,16 @@
  * @abstract
  */
 class Pipeline {
+    cacheKey: string;
+
+    usedTimes: number;
+
     /**
      * Constructs a new pipeline.
      *
      * @param {string} cacheKey - The pipeline's cache key.
      */
-    constructor(cacheKey) {
+    constructor(cacheKey: string) {
         /**
          * The pipeline's cache key.
          *
diff --git a/src-testing/src/renderers/common/Pipelines.ts b/src-testing/src/renderers/common/Pipelines.ts
index e5172899..7232f360 100644
--- a/src-testing/src/renderers/common/Pipelines.ts
+++ b/src-testing/src/renderers/common/Pipelines.ts
@@ -2,6 +2,22 @@ import DataMap from './DataMap.js';
 import RenderPipeline from './RenderPipeline.js';
 import ComputePipeline from './ComputePipeline.js';
 import ProgrammableStage from './ProgrammableStage.js';
+import Backend from './Backend.js';
+import Nodes from './nodes/Nodes.js';
+import Bindings from './Bindings.js';
+import RenderObject from './RenderObject.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import Binding from './Binding.js';
+import Pipeline from './Pipeline.js';
+
+interface ComputeNodeData {
+    version: number;
+    pipeline: ComputePipeline;
+}
+
+interface RenderObjectData {
+    pipeline: RenderPipeline;
+}
 
 /**
  * This renderer module manages the pipelines of the renderer.
@@ -9,14 +25,29 @@ import ProgrammableStage from './ProgrammableStage.js';
  * @private
  * @augments DataMap
  */
-class Pipelines extends DataMap {
+class Pipelines extends DataMap<{
+    computeNode: { key: ComputeNode; value: ComputeNodeData };
+    renderObject: { key: RenderObject; value: RenderObjectData };
+}> {
+    backend: Backend;
+    nodes: Nodes;
+
+    bindings: Bindings | null;
+
+    caches: Map<string, Pipeline>;
+    programs: {
+        vertex: Map<string, ProgrammableStage>;
+        fragment: Map<string, ProgrammableStage>;
+        compute: Map<string, ProgrammableStage>;
+    };
+
     /**
      * Constructs a new pipeline management component.
      *
      * @param {Backend} backend - The renderer's backend.
      * @param {Nodes} nodes - Renderer component for managing nodes related logic.
      */
-    constructor(backend, nodes) {
+    constructor(backend: Backend, nodes: Nodes) {
         super();
 
         /**
@@ -49,7 +80,7 @@ class Pipelines extends DataMap {
          *
          * @type {Map<string,Pipeline>}
          */
-        this.caches = new Map();
+        this.caches = new Map<string, Pipeline>();
 
         /**
          * This dictionary maintains for each shader stage type (vertex,
@@ -59,9 +90,9 @@ class Pipelines extends DataMap {
          * @type {Object<string,Map<string, ProgrammableStage>>}
          */
         this.programs = {
-            vertex: new Map(),
-            fragment: new Map(),
-            compute: new Map(),
+            vertex: new Map<string, ProgrammableStage>(),
+            fragment: new Map<string, ProgrammableStage>(),
+            compute: new Map<string, ProgrammableStage>(),
         };
     }
 
@@ -72,7 +103,7 @@ class Pipelines extends DataMap {
      * @param {Array<BindGroup>} bindings - The bindings.
      * @return {ComputePipeline} The compute pipeline.
      */
-    getForCompute(computeNode, bindings) {
+    getForCompute(computeNode: ComputeNode, bindings: Binding[]) {
         const { backend } = this;
 
         const data = this.get(computeNode);
@@ -91,20 +122,20 @@ class Pipelines extends DataMap {
 
             // programmable stage
 
-            let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader);
+            let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader!);
 
             if (stageCompute === undefined) {
                 if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0)
                     this._releaseProgram(previousPipeline.computeProgram);
 
                 stageCompute = new ProgrammableStage(
-                    nodeBuilderState.computeShader,
+                    nodeBuilderState.computeShader!,
                     'compute',
                     computeNode.name,
                     nodeBuilderState.transforms,
                     nodeBuilderState.nodeAttributes,
                 );
-                this.programs.compute.set(nodeBuilderState.computeShader, stageCompute);
+                this.programs.compute.set(nodeBuilderState.computeShader!, stageCompute);
 
                 backend.createProgram(stageCompute);
             }
@@ -113,7 +144,7 @@ class Pipelines extends DataMap {
 
             const cacheKey = this._getComputeCacheKey(computeNode, stageCompute);
 
-            let pipeline = this.caches.get(cacheKey);
+            let pipeline = this.caches.get(cacheKey) as ComputePipeline | undefined;
 
             if (pipeline === undefined) {
                 if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
@@ -142,7 +173,7 @@ class Pipelines extends DataMap {
      * @param {?Array<Promise>} [promises=null] - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
      * @return {RenderPipeline} The render pipeline.
      */
-    getForRender(renderObject, promises = null) {
+    getForRender(renderObject: RenderObject, promises: Promise<void>[] | null = null) {
         const { backend } = this;
 
         const data = this.get(renderObject);
@@ -164,26 +195,26 @@ class Pipelines extends DataMap {
 
             // programmable stages
 
-            let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);
+            let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader!);
 
             if (stageVertex === undefined) {
                 if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0)
                     this._releaseProgram(previousPipeline.vertexProgram);
 
-                stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader, 'vertex', name);
-                this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);
+                stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader!, 'vertex', name);
+                this.programs.vertex.set(nodeBuilderState.vertexShader!, stageVertex);
 
                 backend.createProgram(stageVertex);
             }
 
-            let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader);
+            let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader!);
 
             if (stageFragment === undefined) {
                 if (previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0)
                     this._releaseProgram(previousPipeline.fragmentProgram);
 
-                stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader, 'fragment', name);
-                this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);
+                stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader!, 'fragment', name);
+                this.programs.fragment.set(nodeBuilderState.fragmentShader!, stageFragment);
 
                 backend.createProgram(stageFragment);
             }
@@ -192,7 +223,7 @@ class Pipelines extends DataMap {
 
             const cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
 
-            let pipeline = this.caches.get(cacheKey);
+            let pipeline = this.caches.get(cacheKey) as RenderPipeline | undefined;
 
             if (pipeline === undefined) {
                 if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
@@ -222,7 +253,7 @@ class Pipelines extends DataMap {
      * @param {RenderObject} object - The render object.
      * @return {?Object} The deleted dictionary.
      */
-    delete(object) {
+    delete(object: ComputeNode | RenderObject): never {
         const pipeline = this.get(object).pipeline;
 
         if (pipeline) {
@@ -234,20 +265,23 @@ class Pipelines extends DataMap {
 
             // programs
 
-            if (pipeline.isComputePipeline) {
-                pipeline.computeProgram.usedTimes--;
+            if ((pipeline as ComputePipeline).isComputePipeline) {
+                (pipeline as ComputePipeline).computeProgram.usedTimes--;
 
-                if (pipeline.computeProgram.usedTimes === 0) this._releaseProgram(pipeline.computeProgram);
+                if ((pipeline as ComputePipeline).computeProgram.usedTimes === 0)
+                    this._releaseProgram((pipeline as ComputePipeline).computeProgram);
             } else {
-                pipeline.fragmentProgram.usedTimes--;
-                pipeline.vertexProgram.usedTimes--;
+                (pipeline as RenderPipeline).fragmentProgram.usedTimes--;
+                (pipeline as RenderPipeline).vertexProgram.usedTimes--;
 
-                if (pipeline.vertexProgram.usedTimes === 0) this._releaseProgram(pipeline.vertexProgram);
-                if (pipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(pipeline.fragmentProgram);
+                if ((pipeline as RenderPipeline).vertexProgram.usedTimes === 0)
+                    this._releaseProgram((pipeline as RenderPipeline).vertexProgram);
+                if ((pipeline as RenderPipeline).fragmentProgram.usedTimes === 0)
+                    this._releaseProgram((pipeline as RenderPipeline).fragmentProgram);
             }
         }
 
-        return super.delete(object);
+        return super.delete(object) as never;
     }
 
     /**
@@ -269,7 +303,7 @@ class Pipelines extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         this.getForRender(renderObject);
     }
 
@@ -283,12 +317,17 @@ class Pipelines extends DataMap {
      * @param {Array<BindGroup>} bindings - The bindings.
      * @return {ComputePipeline} The compute pipeline.
      */
-    _getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {
+    _getComputePipeline(
+        computeNode: ComputeNode,
+        stageCompute: ProgrammableStage,
+        cacheKey: string,
+        bindings: Binding[],
+    ) {
         // check for existing pipeline
 
         cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);
 
-        let pipeline = this.caches.get(cacheKey);
+        let pipeline = this.caches.get(cacheKey) as ComputePipeline | undefined;
 
         if (pipeline === undefined) {
             pipeline = new ComputePipeline(cacheKey, stageCompute);
@@ -312,12 +351,18 @@ class Pipelines extends DataMap {
      * @param {?Array<Promise>} promises - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
      * @return {ComputePipeline} The compute pipeline.
      */
-    _getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises) {
+    _getRenderPipeline(
+        renderObject: RenderObject,
+        stageVertex: ProgrammableStage,
+        stageFragment: ProgrammableStage,
+        cacheKey: string,
+        promises: Promise<void>[] | null,
+    ) {
         // check for existing pipeline
 
         cacheKey = cacheKey || this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
 
-        let pipeline = this.caches.get(cacheKey);
+        let pipeline = this.caches.get(cacheKey) as RenderPipeline | undefined;
 
         if (pipeline === undefined) {
             pipeline = new RenderPipeline(cacheKey, stageVertex, stageFragment);
@@ -344,7 +389,7 @@ class Pipelines extends DataMap {
      * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
      * @return {string} The cache key.
      */
-    _getComputeCacheKey(computeNode, stageCompute) {
+    _getComputeCacheKey(computeNode: ComputeNode, stageCompute: ProgrammableStage) {
         return computeNode.id + ',' + stageCompute.id;
     }
 
@@ -357,7 +402,7 @@ class Pipelines extends DataMap {
      * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
      * @return {string} The cache key.
      */
-    _getRenderCacheKey(renderObject, stageVertex, stageFragment) {
+    _getRenderCacheKey(renderObject: RenderObject, stageVertex: ProgrammableStage, stageFragment: ProgrammableStage) {
         return stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey(renderObject);
     }
 
@@ -367,7 +412,7 @@ class Pipelines extends DataMap {
      * @private
      * @param {Pipeline} pipeline - The pipeline to release.
      */
-    _releasePipeline(pipeline) {
+    _releasePipeline(pipeline: Pipeline) {
         this.caches.delete(pipeline.cacheKey);
     }
 
@@ -377,7 +422,7 @@ class Pipelines extends DataMap {
      * @private
      * @param {Object} program - The shader program to release.
      */
-    _releaseProgram(program) {
+    _releaseProgram(program: ProgrammableStage) {
         const code = program.code;
         const stage = program.stage;
 
@@ -391,7 +436,7 @@ class Pipelines extends DataMap {
      * @param {Node} computeNode - The compute node.
      * @return {boolean} Whether the compute pipeline for the given compute node requires an update or not.
      */
-    _needsComputeUpdate(computeNode) {
+    _needsComputeUpdate(computeNode: ComputeNode) {
         const data = this.get(computeNode);
 
         return data.pipeline === undefined || data.version !== computeNode.version;
@@ -404,7 +449,7 @@ class Pipelines extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {boolean} Whether the render object for the given render object requires an update or not.
      */
-    _needsRenderUpdate(renderObject) {
+    _needsRenderUpdate(renderObject: RenderObject) {
         const data = this.get(renderObject);
 
         return data.pipeline === undefined || this.backend.needsRenderUpdate(renderObject);
diff --git a/src-testing/src/renderers/common/ProgrammableStage.ts b/src-testing/src/renderers/common/ProgrammableStage.ts
index 0dc5923e..64092893 100644
--- a/src-testing/src/renderers/common/ProgrammableStage.ts
+++ b/src-testing/src/renderers/common/ProgrammableStage.ts
@@ -1,3 +1,5 @@
+import NodeAttribute from '../../nodes/core/NodeAttribute.js';
+
 let _id = 0;
 
 /**
@@ -8,6 +10,17 @@ let _id = 0;
  * @private
  */
 class ProgrammableStage {
+    id: number;
+
+    code: string;
+    stage: 'compute' | 'vertex' | 'fragment';
+    name: string;
+    // TODO
+    // transforms
+    attributes: NodeAttribute[] | null;
+
+    usedTimes: number;
+
     /**
      * Constructs a new programmable stage.
      *
@@ -17,7 +30,13 @@ class ProgrammableStage {
      * @param {?Array<Object>} [transforms=null] - The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
      * @param {?Array<Object>} [attributes=null] - The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
      */
-    constructor(code, stage, name, transforms = null, attributes = null) {
+    constructor(
+        code: string,
+        stage: 'compute' | 'vertex' | 'fragment',
+        name: string,
+        transforms = null,
+        attributes: NodeAttribute[] | null = null,
+    ) {
         /**
          * The id of the programmable stage.
          *
diff --git a/src-testing/src/renderers/common/RenderBundle.ts b/src-testing/src/renderers/common/RenderBundle.ts
index ffa28996..f690315a 100644
--- a/src-testing/src/renderers/common/RenderBundle.ts
+++ b/src-testing/src/renderers/common/RenderBundle.ts
@@ -1,3 +1,6 @@
+import { Camera } from '../../cameras/Camera.js';
+import BundleGroup from './BundleGroup.js';
+
 /**
  * This module is used to represent render bundles inside the renderer
  * for further processing.
@@ -5,13 +8,16 @@
  * @private
  */
 class RenderBundle {
+    bundleGroup: BundleGroup;
+    camera: Camera;
+
     /**
      * Constructs a new bundle group.
      *
      * @param {BundleGroup} bundleGroup - The bundle group.
      * @param {Camera} camera - The camera the bundle group is rendered with.
      */
-    constructor(bundleGroup, camera) {
+    constructor(bundleGroup: BundleGroup, camera: Camera) {
         this.bundleGroup = bundleGroup;
         this.camera = camera;
     }
diff --git a/src-testing/src/renderers/common/RenderBundles.ts b/src-testing/src/renderers/common/RenderBundles.ts
index d6c72696..3ae4005b 100644
--- a/src-testing/src/renderers/common/RenderBundles.ts
+++ b/src-testing/src/renderers/common/RenderBundles.ts
@@ -1,7 +1,9 @@
 import ChainMap from './ChainMap.js';
 import RenderBundle from './RenderBundle.js';
+import { Camera } from '../../cameras/Camera.js';
+import BundleGroup from './BundleGroup.js';
 
-const _chainKeys = [];
+const _chainKeys = [] as unknown as [BundleGroup, Camera];
 
 /**
  * This renderer module manages render bundles.
@@ -9,6 +11,8 @@ const _chainKeys = [];
  * @private
  */
 class RenderBundles {
+    bundles: ChainMap<readonly [BundleGroup, Camera], RenderBundle>;
+
     /**
      * Constructs a new render bundle management component.
      */
@@ -28,7 +32,7 @@ class RenderBundles {
      * @param {Camera} camera - The camera the bundle group is rendered with.
      * @return {RenderBundle} The render bundle.
      */
-    get(bundleGroup, camera) {
+    get(bundleGroup: BundleGroup, camera: Camera) {
         const bundles = this.bundles;
 
         _chainKeys[0] = bundleGroup;
diff --git a/src-testing/src/renderers/common/RenderContext.ts b/src-testing/src/renderers/common/RenderContext.ts
index 0ac531cc..2d2c669f 100644
--- a/src-testing/src/renderers/common/RenderContext.ts
+++ b/src-testing/src/renderers/common/RenderContext.ts
@@ -1,5 +1,9 @@
 import { Vector4 } from '../../math/Vector4.js';
 import { hashArray } from '../../nodes/core/NodeUtils.js';
+import { Texture } from '../../textures/Texture.js';
+import { DepthTexture } from '../../textures/DepthTexture.js';
+import ClippingContext from './ClippingContext.js';
+import { RenderTarget } from '../../core/RenderTarget.js';
 
 let _id = 0;
 
@@ -12,6 +16,43 @@ let _id = 0;
  * @private
  */
 class RenderContext {
+    id: number;
+
+    color: boolean;
+    clearColor: boolean;
+    clearColorValue: { r: number; g: number; b: number; a: number };
+
+    depth: boolean;
+    clearDepth: boolean;
+    clearDepthValue: number;
+
+    stencil: boolean;
+    clearStencil: boolean;
+    clearStencilValue: number;
+
+    viewport: boolean;
+    viewportValue: Vector4;
+    scissor: boolean;
+    scissorValue: Vector4;
+    renderTarget: RenderTarget | null;
+
+    textures: Texture[] | null;
+    depthTexture: DepthTexture | null;
+    activeCubeFace: number;
+    sampleCount: number;
+
+    width: number;
+    height: number;
+    occlusionQueryCount: number;
+    clippingContext: ClippingContext | null;
+
+    readonly isRenderContext: true;
+
+    depthClearValue?: number | undefined;
+    stencilClearValue?: number | undefined;
+
+    activeMipmapLevel?: number | undefined;
+
     /**
      * Constructs a new render context.
      */
@@ -240,12 +281,12 @@ class RenderContext {
  * @param {RenderContext} renderContext - The render context.
  * @return {number} The cache key.
  */
-export function getCacheKey(renderContext) {
+export function getCacheKey(renderContext: RenderContext) {
     const { textures, activeCubeFace, activeMipmapLevel } = renderContext;
 
     const values = [activeCubeFace, activeMipmapLevel];
 
-    for (const texture of textures) {
+    for (const texture of textures!) {
         values.push(texture.id);
     }
 
diff --git a/src-testing/src/renderers/common/RenderContexts.ts b/src-testing/src/renderers/common/RenderContexts.ts
index b62711a5..4633e242 100644
--- a/src-testing/src/renderers/common/RenderContexts.ts
+++ b/src-testing/src/renderers/common/RenderContexts.ts
@@ -2,8 +2,10 @@ import ChainMap from './ChainMap.js';
 import RenderContext from './RenderContext.js';
 import { Scene } from '../../scenes/Scene.js';
 import { Camera } from '../../cameras/Camera.js';
+import { RenderTarget } from '../../core/RenderTarget.js';
+import MRTNode from '../../nodes/core/MRTNode.js';
 
-const _chainKeys = [];
+const _chainKeys = [] as unknown as [Scene, Camera];
 const _defaultScene = /*@__PURE__*/ new Scene();
 const _defaultCamera = /*@__PURE__*/ new Camera();
 
@@ -13,6 +15,10 @@ const _defaultCamera = /*@__PURE__*/ new Camera();
  * @private
  */
 class RenderContexts {
+    chainMaps: {
+        [attachmentState: string]: ChainMap<readonly [Scene, Camera], RenderContext> | undefined;
+    };
+
     /**
      * Constructs a new render context management component.
      */
@@ -35,7 +41,7 @@ class RenderContexts {
      * @param {?MRT} [mrt=null] - The active multiple render target.
      * @return {RenderContext} The render context.
      */
-    get(scene, camera, renderTarget = null, mrt = null) {
+    get(scene: Scene, camera: Camera, renderTarget: RenderTarget | null = null, mrt: MRTNode | null = null) {
         let index = 0;
 
         if (mrt !== null) {
@@ -82,7 +88,7 @@ class RenderContexts {
      * @param {?RenderTarget} [renderTarget=null] - The active render target.
      * @return {RenderContext} The render context.
      */
-    getForClear(renderTarget = null) {
+    getForClear(renderTarget: RenderTarget | null = null) {
         return this.get(_defaultScene, _defaultCamera, renderTarget);
     }
 
@@ -93,8 +99,11 @@ class RenderContexts {
      * @param {string} attachmentState - The attachment state.
      * @return {ChainMap} The chain map.
      */
-    _getChainMap(attachmentState) {
-        return this.chainMaps[attachmentState] || (this.chainMaps[attachmentState] = new ChainMap());
+    _getChainMap(attachmentState: string) {
+        return (
+            this.chainMaps[attachmentState] ||
+            (this.chainMaps[attachmentState] = new ChainMap<readonly [Object3D, Camera], RenderContext>())
+        );
     }
 
     /**
diff --git a/src-testing/src/renderers/common/RenderList.ts b/src-testing/src/renderers/common/RenderList.ts
index a4cfe35f..70cb3867 100644
--- a/src-testing/src/renderers/common/RenderList.ts
+++ b/src-testing/src/renderers/common/RenderList.ts
@@ -1,4 +1,13 @@
 import { DoubleSide } from '../../constants.js';
+import { LightsNode } from '../../nodes/Nodes.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Camera } from '../../cameras/Camera.js';
+import { BufferGeometry, GeometryGroup } from '../../core/BufferGeometry.js';
+import { Material } from '../../materials/Material.js';
+import { Light } from '../../lights/Light.js';
+import BundleGroup from './BundleGroup.js';
+import Lighting from './Lighting.js';
+import ClippingContext from './ClippingContext.js';
 
 /**
  * Default sorting function for opaque render items.
@@ -9,15 +18,15 @@ import { DoubleSide } from '../../constants.js';
  * @param {Object} b - The second render item.
  * @return {number} A numeric value which defines the sort order.
  */
-function painterSortStable(a, b) {
+function painterSortStable(a: RenderItem, b: RenderItem) {
     if (a.groupOrder !== b.groupOrder) {
-        return a.groupOrder - b.groupOrder;
+        return a.groupOrder! - b.groupOrder!;
     } else if (a.renderOrder !== b.renderOrder) {
-        return a.renderOrder - b.renderOrder;
+        return a.renderOrder! - b.renderOrder!;
     } else if (a.z !== b.z) {
-        return a.z - b.z;
+        return a.z! - b.z!;
     } else {
-        return a.id - b.id;
+        return a.id! - b.id!;
     }
 }
 
@@ -30,18 +39,36 @@ function painterSortStable(a, b) {
  * @param {Object} b - The second render item.
  * @return {number} A numeric value which defines the sort order.
  */
-function reversePainterSortStable(a, b) {
+function reversePainterSortStable(a: RenderItem, b: RenderItem) {
     if (a.groupOrder !== b.groupOrder) {
-        return a.groupOrder - b.groupOrder;
+        return a.groupOrder! - b.groupOrder!;
     } else if (a.renderOrder !== b.renderOrder) {
-        return a.renderOrder - b.renderOrder;
+        return a.renderOrder! - b.renderOrder!;
     } else if (a.z !== b.z) {
-        return b.z - a.z;
+        return b.z! - a.z!;
     } else {
-        return a.id - b.id;
+        return a.id! - b.id!;
     }
 }
 
+export interface Bundle {
+    bundleGroup: BundleGroup;
+    camera: Camera;
+    renderList: RenderList;
+}
+
+export interface RenderItem {
+    id: number | null;
+    object: Object3D | null;
+    geometry: BufferGeometry | null;
+    material: Material | null;
+    groupOrder: number | null;
+    renderOrder: number | null;
+    z: number | null;
+    group: GeometryGroup | null;
+    clippingContext: ClippingContext | null;
+}
+
 /**
  * Returns `true` if the given transparent material requires a double pass.
  *
@@ -50,7 +77,7 @@ function reversePainterSortStable(a, b) {
  * @param {Material} material - The transparent material.
  * @return {boolean} Whether the given material requires a double pass or not.
  */
-function needsDoublePass(material) {
+function needsDoublePass(material: Material) {
     const hasTransmission =
         material.transmission > 0 || (material.transmissionNode && material.transmissionNode.isNode);
 
@@ -69,6 +96,22 @@ function needsDoublePass(material) {
  * @augments Pipeline
  */
 class RenderList {
+    renderItems: RenderItem[];
+    renderItemsIndex: number;
+
+    opaque: RenderItem[];
+    transparentDoublePass: RenderItem[];
+    transparent: RenderItem[];
+    bundles: Bundle[];
+
+    lightsNode: LightsNode;
+    lightsArray: Light[];
+
+    scene: Object3D;
+    camera: Camera;
+
+    occlusionQueryCount: number;
+
     /**
      * Constructs a render list.
      *
@@ -76,7 +119,7 @@ class RenderList {
      * @param {Scene} scene - The scene.
      * @param {Camera} camera - The camera the scene is rendered with.
      */
-    constructor(lighting, scene, camera) {
+    constructor(lighting: Lighting, scene: Object3D, camera: Camera) {
         /**
          * 3D objects are transformed into render items and stored in this array.
          *
@@ -199,7 +242,15 @@ class RenderList {
      * @param {ClippingContext} clippingContext - The current clipping context.
      * @return {Object} The render item.
      */
-    getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext) {
+    getNextRenderItem(
+        object: Object3D,
+        geometry: BufferGeometry,
+        material: Material,
+        groupOrder: number,
+        z: number,
+        group: GeometryGroup | null,
+        clippingContext: ClippingContext | null,
+    ) {
         let renderItem = this.renderItems[this.renderItemsIndex];
 
         if (renderItem === undefined) {
@@ -245,7 +296,15 @@ class RenderList {
      * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
      * @param {ClippingContext} clippingContext - The current clipping context.
      */
-    push(object, geometry, material, groupOrder, z, group, clippingContext) {
+    push(
+        object: Object3D,
+        geometry: BufferGeometry,
+        material: Material,
+        groupOrder: number,
+        z: number,
+        group: GeometryGroup | null,
+        clippingContext: ClippingContext | null,
+    ) {
         const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);
 
         if (object.occlusionTest === true) this.occlusionQueryCount++;
@@ -276,7 +335,15 @@ class RenderList {
      * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
      * @param {ClippingContext} clippingContext - The current clipping context.
      */
-    unshift(object, geometry, material, groupOrder, z, group, clippingContext) {
+    unshift(
+        object: Object3D,
+        geometry: BufferGeometry,
+        material: Material,
+        groupOrder: number,
+        z: number,
+        group: GeometryGroup | null,
+        clippingContext: ClippingContext | null,
+    ) {
         const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);
 
         if (
@@ -298,7 +365,7 @@ class RenderList {
      *
      * @param {Object} group - Bundle group data.
      */
-    pushBundle(group) {
+    pushBundle(group: Bundle) {
         this.bundles.push(group);
     }
 
@@ -307,7 +374,7 @@ class RenderList {
      *
      * @param {Light} light - The light.
      */
-    pushLight(light) {
+    pushLight(light: Light) {
         this.lightsArray.push(light);
     }
 
@@ -317,7 +384,10 @@ class RenderList {
      * @param {?function(any, any): number} customOpaqueSort - A custom sort function for opaque objects.
      * @param {?function(any, any): number} customTransparentSort -  A custom sort function for transparent objects.
      */
-    sort(customOpaqueSort, customTransparentSort) {
+    sort(
+        customOpaqueSort: ((a: RenderItem, b: RenderItem) => number) | null,
+        customTransparentSort: ((a: RenderItem, b: RenderItem) => number) | null,
+    ) {
         if (this.opaque.length > 1) this.opaque.sort(customOpaqueSort || painterSortStable);
         if (this.transparentDoublePass.length > 1)
             this.transparentDoublePass.sort(customTransparentSort || reversePainterSortStable);
diff --git a/src-testing/src/renderers/common/RenderLists.ts b/src-testing/src/renderers/common/RenderLists.ts
index d12ad583..ef6e14ec 100644
--- a/src-testing/src/renderers/common/RenderLists.ts
+++ b/src-testing/src/renderers/common/RenderLists.ts
@@ -1,7 +1,10 @@
 import ChainMap from './ChainMap.js';
 import RenderList from './RenderList.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Camera } from '../../cameras/Camera.js';
+import Lighting from './Lighting.js';
 
-const _chainKeys = [];
+const _chainKeys = [] as unknown as [Object3D, Camera];
 
 /**
  * This renderer module manages the render lists which are unique
@@ -10,12 +13,16 @@ const _chainKeys = [];
  * @private
  */
 class RenderLists {
+    lighting: Lighting;
+
+    lists: ChainMap<readonly [Object3D, Camera], RenderList>;
+
     /**
      * Constructs a render lists management component.
      *
      * @param {Lighting} lighting - The lighting management component.
      */
-    constructor(lighting) {
+    constructor(lighting: Lighting) {
         /**
          * The lighting management component.
          *
@@ -28,7 +35,7 @@ class RenderLists {
          *
          * @type {ChainMap}
          */
-        this.lists = new ChainMap();
+        this.lists = new ChainMap<readonly [Object3D, Camera], RenderList>();
     }
 
     /**
@@ -38,7 +45,7 @@ class RenderLists {
      * @param {Camera} camera - The camera.
      * @return {RenderList} The render list.
      */
-    get(scene, camera) {
+    get(scene: Object3D, camera: Camera) {
         const lists = this.lists;
 
         _chainKeys[0] = scene;
@@ -60,7 +67,7 @@ class RenderLists {
      * Frees all internal resources.
      */
     dispose() {
-        this.lists = new ChainMap();
+        this.lists = new ChainMap<readonly [Object3D, Camera], RenderList>();
     }
 }
 
diff --git a/src-testing/src/renderers/common/RenderObject.ts b/src-testing/src/renderers/common/RenderObject.ts
index 0190191f..79027135 100644
--- a/src-testing/src/renderers/common/RenderObject.ts
+++ b/src-testing/src/renderers/common/RenderObject.ts
@@ -1,8 +1,27 @@
 import { hash, hashString } from '../../nodes/core/NodeUtils.js';
+import ClippingContext from './ClippingContext.js';
+import { Material } from '../../materials/Material.js';
+import Nodes from './nodes/Nodes.js';
+import Geometries from './Geometries.js';
+import Renderer from './Renderer.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Scene } from '../../scenes/Scene.js';
+import { Camera } from '../../cameras/Camera.js';
+import { LightsNode } from '../../nodes/Nodes.js';
+import RenderContext from './RenderContext.js';
+import { BufferGeometry } from '../../core/BufferGeometry.js';
+import { BufferAttribute } from '../../core/BufferAttribute.js';
+import { InterleavedBufferAttribute } from '../../core/InterleavedBufferAttribute.js';
+import RenderPipeline from './RenderPipeline.js';
+import { InterleavedBuffer } from '../../core/InterleavedBuffer.js';
+import NodeBuilderState from './nodes/NodeBuilderState.js';
+import BindGroup from './BindGroup.js';
+import NodeMaterialObserver from '../../materials/nodes/manager/NodeMaterialObserver.js';
+import BundleGroup from './BundleGroup.js';
 
 let _id = 0;
 
-function getKeys(obj) {
+function getKeys(obj: Material) {
     const keys = Object.keys(obj);
 
     let proto = Object.getPrototypeOf(obj);
@@ -45,6 +64,51 @@ function getKeys(obj) {
  * @private
  */
 class RenderObject {
+    _nodes: Nodes;
+    _geometries: Geometries;
+
+    id: number;
+
+    renderer: Renderer;
+    object: Object3D;
+    material: Material;
+    scene: Scene;
+    camera: Camera;
+    lightsNode: LightsNode;
+    context: RenderContext;
+
+    geometry: BufferGeometry;
+    version: number;
+
+    drawRange: { start: number; count: number } | null;
+
+    attributes: Array<BufferAttribute | InterleavedBufferAttribute> | null;
+    attributesId: { [attributeName: string]: number } | null;
+    pipeline: RenderPipeline | null;
+    group: { start: number; count: number } | null;
+    vertexBuffers: Array<BufferAttribute | InterleavedBuffer> | null;
+    drawParams: { vertexCount: number; firstVertex: number; instanceCount: number; firstInstance: number } | null;
+
+    bundle: BundleGroup | null;
+
+    clippingContext: ClippingContext | null;
+
+    clippingContextCacheKey: string;
+
+    initialNodesCacheKey: number;
+    initialCacheKey: number;
+
+    _nodeBuilderState: NodeBuilderState | null;
+    _bindings: BindGroup[] | null;
+    _monitor: NodeMaterialObserver | null;
+
+    onDispose: (() => void) | null;
+
+    readonly isRenderObject: true;
+
+    onMaterialDispose: () => void;
+    onGeometryDispose: () => void;
+
     /**
      * Constructs a new render object.
      *
@@ -60,16 +124,16 @@ class RenderObject {
      * @param {ClippingContext} clippingContext - The clipping context.
      */
     constructor(
-        nodes,
-        geometries,
-        renderer,
-        object,
-        material,
-        scene,
-        camera,
-        lightsNode,
-        renderContext,
-        clippingContext,
+        nodes: Nodes,
+        geometries: Geometries,
+        renderer: Renderer,
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+        clippingContext: ClippingContext | null,
     ) {
         this.id = _id++;
 
@@ -329,7 +393,7 @@ class RenderObject {
      *
      * @param {ClippingContext} context - The clipping context to set.
      */
-    updateClipping(context) {
+    updateClipping(context: ClippingContext) {
         this.clippingContext = context;
     }
 
@@ -343,7 +407,7 @@ class RenderObject {
         if (this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey)
             return false;
 
-        this.clippingContextCacheKey = this.clippingContext.cacheKey;
+        this.clippingContextCacheKey = this.clippingContext!.cacheKey;
 
         return true;
     }
@@ -355,7 +419,7 @@ class RenderObject {
      * @readonly
      */
     get hardwareClippingPlanes() {
-        return this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;
+        return this.material.hardwareClipping === true ? this.clippingContext!.unionClippingCount : 0;
     }
 
     /**
@@ -391,7 +455,7 @@ class RenderObject {
      * @param {string} name - The name of the binding group.
      * @return {?BindGroup} The bindings.
      */
-    getBindingGroup(name) {
+    getBindingGroup(name: string) {
         for (const bindingGroup of this.getBindings()) {
             if (bindingGroup.name === name) {
                 return bindingGroup;
@@ -423,7 +487,7 @@ class RenderObject {
      * @return {Array<Object>} An array with object references.
      */
     getChainArray() {
-        return [this.object, this.material, this.context, this.lightsNode];
+        return [this.object, this.material, this.context, this.lightsNode] as const;
     }
 
     /**
@@ -432,7 +496,7 @@ class RenderObject {
      *
      * @param {BufferGeometry} geometry - The geometry to set.
      */
-    setGeometry(geometry) {
+    setGeometry(geometry: BufferGeometry) {
         this.geometry = geometry;
         this.attributes = null;
         this.attributesId = null;
@@ -450,8 +514,8 @@ class RenderObject {
         const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
         const geometry = this.geometry;
 
-        const attributes = [];
-        const vertexBuffers = new Set();
+        const attributes: Array<BufferAttribute | InterleavedBufferAttribute> = [];
+        const vertexBuffers = new Set<BufferAttribute | InterleavedBuffer>();
 
         const attributesId = {};
 
@@ -793,7 +857,7 @@ class RenderObject {
         this.material.removeEventListener('dispose', this.onMaterialDispose);
         this.geometry.removeEventListener('dispose', this.onGeometryDispose);
 
-        this.onDispose();
+        this.onDispose!();
     }
 }
 
diff --git a/src-testing/src/renderers/common/RenderObjects.ts b/src-testing/src/renderers/common/RenderObjects.ts
index ede42958..b18adb08 100644
--- a/src-testing/src/renderers/common/RenderObjects.ts
+++ b/src-testing/src/renderers/common/RenderObjects.ts
@@ -1,7 +1,20 @@
 import ChainMap from './ChainMap.js';
 import RenderObject from './RenderObject.js';
+import Renderer from './Renderer.js';
+import Nodes from './nodes/Nodes.js';
+import Geometries from './Geometries.js';
+import Pipelines from './Pipelines.js';
+import Bindings from './Bindings.js';
+import Info from './Info.js';
+import LightsNode from '../../nodes/lighting/LightsNode.js';
+import RenderContext from './RenderContext.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Material } from '../../materials/Material.js';
+import { Scene } from '../../scenes/Scene.js';
+import { Camera } from '../../cameras/Camera.js';
+import ClippingContext from './ClippingContext.js';
 
-const _chainKeys = [];
+const _chainKeys = [] as unknown as [Object3D, Material, RenderContext, LightsNode];
 
 /**
  * This module manages the render objects of the renderer.
@@ -9,6 +22,15 @@ const _chainKeys = [];
  * @private
  */
 class RenderObjects {
+    renderer: Renderer;
+    nodes: Nodes;
+    geometries: Geometries;
+    pipelines: Pipelines;
+    bindings: Bindings;
+    info: Info;
+
+    chainMaps: { [passId: string]: ChainMap<readonly [Object3D, Material, RenderContext, LightsNode], RenderObject> };
+
     /**
      * Constructs a new render object management component.
      *
@@ -19,7 +41,14 @@ class RenderObjects {
      * @param {Bindings} bindings - Renderer component for managing bindings.
      * @param {Info} info - Renderer component for managing metrics and monitoring data.
      */
-    constructor(renderer, nodes, geometries, pipelines, bindings, info) {
+    constructor(
+        renderer: Renderer,
+        nodes: Nodes,
+        geometries: Geometries,
+        pipelines: Pipelines,
+        bindings: Bindings,
+        info: Info,
+    ) {
         /**
          * The renderer.
          *
@@ -84,7 +113,16 @@ class RenderObjects {
      * @param {string} [passId] - An optional ID for identifying the pass.
      * @return {RenderObject} The render object.
      */
-    get(object, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {
+    get(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+        clippingContext: ClippingContext | null,
+        passId?: string | undefined,
+    ): RenderObject {
         const chainMap = this.getChainMap(passId);
 
         // reuse chainArray
@@ -112,7 +150,7 @@ class RenderObjects {
 
             chainMap.set(_chainKeys, renderObject);
         } else {
-            renderObject.updateClipping(clippingContext);
+            renderObject.updateClipping(clippingContext!);
 
             if (renderObject.needsGeometryUpdate) {
                 renderObject.setGeometry(object.geometry);
@@ -150,7 +188,13 @@ class RenderObjects {
      * @return {ChainMap} The chain map.
      */
     getChainMap(passId = 'default') {
-        return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());
+        return (
+            this.chainMaps[passId] ||
+            (this.chainMaps[passId] = new ChainMap<
+                readonly [Object3D, Material, RenderContext, LightsNode],
+                RenderObject
+            >())
+        );
     }
 
     /**
@@ -177,17 +221,17 @@ class RenderObjects {
      * @return {RenderObject} The render object.
      */
     createRenderObject(
-        nodes,
-        geometries,
-        renderer,
-        object,
-        material,
-        scene,
-        camera,
-        lightsNode,
-        renderContext,
-        clippingContext,
-        passId,
+        nodes: Nodes,
+        geometries: Geometries,
+        renderer: Renderer,
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+        clippingContext: ClippingContext | null,
+        passId: string | undefined,
     ) {
         const chainMap = this.getChainMap(passId);
 
diff --git a/src-testing/src/renderers/common/RenderPipeline.ts b/src-testing/src/renderers/common/RenderPipeline.ts
index 7527627e..c0fcddf9 100644
--- a/src-testing/src/renderers/common/RenderPipeline.ts
+++ b/src-testing/src/renderers/common/RenderPipeline.ts
@@ -1,4 +1,5 @@
 import Pipeline from './Pipeline.js';
+import ProgrammableStage from './ProgrammableStage.js';
 
 /**
  * Class for representing render pipelines.
@@ -7,6 +8,9 @@ import Pipeline from './Pipeline.js';
  * @augments Pipeline
  */
 class RenderPipeline extends Pipeline {
+    vertexProgram: ProgrammableStage;
+    fragmentProgram: ProgrammableStage;
+
     /**
      * Constructs a new render pipeline.
      *
@@ -14,7 +18,7 @@ class RenderPipeline extends Pipeline {
      * @param {ProgrammableStage} vertexProgram - The pipeline's vertex shader.
      * @param {ProgrammableStage} fragmentProgram - The pipeline's fragment shader.
      */
-    constructor(cacheKey, vertexProgram, fragmentProgram) {
+    constructor(cacheKey: string, vertexProgram: ProgrammableStage, fragmentProgram: ProgrammableStage) {
         super(cacheKey);
 
         /**
diff --git a/src-testing/src/renderers/common/Renderer.ts b/src-testing/src/renderers/common/Renderer.ts
index ff28205b..494ab59b 100644
--- a/src-testing/src/renderers/common/Renderer.ts
+++ b/src-testing/src/renderers/common/Renderer.ts
@@ -28,6 +28,7 @@ import { Frustum } from '../../math/Frustum.js';
 import { FrustumArray } from '../../math/FrustumArray.js';
 import { Matrix4 } from '../../math/Matrix4.js';
 import { Vector2 } from '../../math/Vector2.js';
+import { Vector3 } from '../../math/Vector3.js';
 import { Vector4 } from '../../math/Vector4.js';
 import { RenderTarget } from '../../core/RenderTarget.js';
 import {
@@ -40,13 +41,44 @@ import {
     HalfFloatType,
     RGBAFormat,
     PCFShadowMap,
+    ToneMapping,
+    ShadowMapType,
+    TimestampQuery,
+    TextureDataType,
 } from '../../constants.js';
+import Backend from './Backend.js';
+import RenderContext from './RenderContext.js';
+import RenderList, { Bundle, RenderItem } from './RenderList.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Camera } from '../../cameras/Camera.js';
+import { BufferGeometry, GeometryGroup } from '../../core/BufferGeometry.js';
+import { Material } from '../../materials/Material.js';
+import RenderBundle from './RenderBundle.js';
+import { Light } from '../../lights/Light.js';
+import { BufferAttribute } from '../../core/BufferAttribute.js';
+import { Texture } from '../../textures/Texture.js';
+import { FramebufferTexture } from '../../textures/FramebufferTexture.js';
+import { Box2 } from '../../math/Box2.js';
+import { Box3 } from '../../math/Box3.js';
+import { ColorRepresentation } from '../../math/Color.js';
+import { Group } from '../../objects/Group.js';
+import { LOD } from '../../objects/LOD.js';
+import { Sprite } from '../../objects/Sprite.js';
+import { LineLoop } from '../../objects/LineLoop.js';
+import { Mesh } from '../../objects/Mesh.js';
+import { Line } from '../../objects/Line.js';
+import { Points } from '../../objects/Points.js';
+import MRTNode from '../../nodes/core/MRTNode.js';
+import LightsNode from '../../nodes/lighting/LightsNode.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import { ArrayCamera } from '../../cameras/ArrayCamera.js';
 
 import { float, vec3, vec4 } from '../../nodes/tsl/TSLCore.js';
 import { reference } from '../../nodes/accessors/ReferenceNode.js';
 import { highpModelNormalViewMatrix, highpModelViewMatrix } from '../../nodes/accessors/ModelNode.js';
 import { context } from '../../nodes/core/ContextNode.js';
 import { error, warn, warnOnce } from '../../utils.js';
+import IndirectStorageBufferAttribute from './IndirectStorageBufferAttribute.js';
 
 const _scene = /*@__PURE__*/ new Scene();
 const _drawingBufferSize = /*@__PURE__*/ new Vector2();
@@ -57,10 +89,180 @@ const _frustumArray = /*@__PURE__*/ new FrustumArray();
 const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
 const _vector4 = /*@__PURE__*/ new Vector4();
 
+interface Rectangle {
+    x: number;
+    y: number;
+    z: number;
+    w: number;
+}
+
+interface DeviceLostInfo {
+    api: 'WebGL' | 'WebGPU';
+    message: string;
+    reason: string | null;
+    originalEvent: unknown;
+}
+
+export interface RendererParameters {
+    logarithmicDepthBuffer?: boolean | undefined;
+    alpha?: boolean | undefined;
+    depth?: boolean | undefined;
+    stencil?: boolean | undefined;
+    antialias?: boolean | undefined;
+    samples?: number | undefined;
+    getFallback?: ((error: unknown) => Backend) | null | undefined;
+    colorBufferType?: TextureDataType | undefined;
+    multiview?: boolean | undefined;
+}
+
 /**
  * Base class for renderers.
  */
 class Renderer {
+    readonly isRenderer: true;
+
+    backend: Backend;
+
+    autoClear: boolean;
+    autoClearColor: boolean;
+    autoClearDepth: boolean;
+    autoClearStencil: boolean;
+
+    alpha: boolean;
+
+    logarithmicDepthBuffer: boolean;
+
+    outputColorSpace: string;
+
+    toneMapping: ToneMapping;
+    toneMappingExposure: number;
+
+    sortObjects: boolean;
+
+    depth: boolean;
+    stencil: boolean;
+
+    info: Info;
+
+    library: NodeLibrary;
+    lighting: Lighting;
+
+    _samples: number;
+
+    _canvasTarget: CanvasTarget;
+
+    _inspector: InspectorBase;
+
+    _getFallback: ((error: unknown) => Backend) | null;
+
+    _attributes: Attributes | null;
+    _geometries: Geometries | null;
+    _nodes: Nodes | null;
+    _animation: Animation | null;
+    _bindings: Bindings | null;
+    _objects: RenderObjects | null;
+    _pipelines: Pipelines | null;
+    _bundles: RenderBundles | null;
+    _renderLists: RenderLists | null;
+    _renderContexts: RenderContexts | null;
+    _textures: Textures | null;
+    _background: Background | null;
+
+    _quad: QuadMesh;
+
+    _currentRenderContext: RenderContext | null;
+
+    _opaqueSort: ((a: RenderItem, b: RenderItem) => number) | null;
+    _transparentSort: ((a: RenderItem, b: RenderItem) => number) | null;
+
+    _frameBufferTarget: RenderTarget | null;
+
+    _clearColor: Color4;
+    _clearDepth: number;
+    _clearStencil: number;
+
+    _renderTarget: RenderTarget | null;
+    _activeCubeFace: number;
+    _activeMipmapLevel: number;
+    _outputRenderTarget: RenderTarget | null;
+
+    _mrt: MRTNode | null;
+
+    _renderObjectFunction:
+        | ((
+              object: Object3D,
+              scene: Scene,
+              camera: Camera,
+              geometry: BufferGeometry,
+              material: Material,
+              group: GeometryGroup,
+              lightsNode: LightsNode,
+              clippingContext: ClippingContext | null,
+              passId: string | null,
+          ) => void)
+        | null;
+    _currentRenderObjectFunction:
+        | ((
+              object: Object3D,
+              scene: Scene,
+              camera: Camera,
+              geometry: BufferGeometry,
+              material: Material,
+              group: GeometryGroup,
+              lightsNode: LightsNode,
+              clippingContext: ClippingContext | null,
+              passId: string | null,
+          ) => void)
+        | null;
+    _currentRenderBundle: RenderBundle | null;
+
+    _handleObjectFunction: (
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: GeometryGroup,
+        clippingContext: ClippingContext | null,
+        passId?: string,
+    ) => void;
+
+    _isDeviceLost: boolean;
+    onDeviceLost: (info: DeviceLostInfo) => void;
+
+    _colorBufferType: TextureDataType;
+
+    _initialized: boolean;
+    _initPromise: Promise<this> | null;
+
+    _compilationPromises: Promise<void>[] | null;
+
+    transparent: boolean;
+    opaque: boolean;
+
+    shadowMap: { enabled: boolean; type: ShadowMapType | null };
+
+    xr: XRManager;
+
+    debug: {
+        checkShaderErrors: boolean;
+        onShaderError:
+            | ((
+                  gl: WebGL2RenderingContext,
+                  programGPU: WebGLProgram,
+                  glVertexShader: WebGLShader,
+                  glFragmentShader: WebGLShader,
+              ) => void)
+            | null;
+        getShaderAsync: (
+            scene: Scene,
+            camera: Camera,
+            object: Object3D,
+        ) => Promise<{ fragmentShader: string | null; vertexShader: string | null }>;
+    };
+
+    localClippingEnabled?: boolean | undefined;
+
     /**
      * Renderer options.
      *
@@ -85,7 +287,7 @@ class Renderer {
 	 * @param {Renderer~Options} [parameters] - The configuration parameter.
 
 	 */
-    constructor(backend, parameters = {}) {
+    constructor(backend: Backend, parameters: RendererParameters = {}) {
         /**
          * This flag can be used for type testing.
          *
@@ -702,12 +904,12 @@ class Renderer {
             getShaderAsync: async (scene, camera, object) => {
                 await this.compileAsync(scene, camera);
 
-                const renderList = this._renderLists.get(scene, camera);
-                const renderContext = this._renderContexts.get(scene, camera, this._renderTarget, this._mrt);
+                const renderList = this._renderLists!.get(scene, camera);
+                const renderContext = this._renderContexts!.get(scene, camera, this._renderTarget, this._mrt);
 
-                const material = scene.overrideMaterial || object.material;
+                const material = scene.overrideMaterial || (object as Mesh<BufferGeometry, Material>).material;
 
-                const renderObject = this._objects.get(
+                const renderObject = this._objects!.get(
                     object,
                     material,
                     scene,
@@ -735,7 +937,7 @@ class Renderer {
             return this._initPromise;
         }
 
-        this._initPromise = new Promise(async (resolve, reject) => {
+        this._initPromise = new Promise<this>(async (resolve, reject) => {
             let backend = this.backend;
 
             try {
@@ -839,14 +1041,14 @@ class Renderer {
      * @param {?Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
      * @return {Promise} A Promise that resolves when the compile has been finished.
      */
-    async compileAsync(scene, camera, targetScene = null) {
+    async compileAsync(scene: Object3D, camera: Camera, targetScene: Scene | null = null) {
         if (this._isDeviceLost === true) return;
 
         if (this._initialized === false) await this.init();
 
         // preserve render tree
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
         const previousRenderContext = this._currentRenderContext;
@@ -855,15 +1057,15 @@ class Renderer {
 
         //
 
-        const sceneRef = scene.isScene === true ? scene : _scene;
+        const sceneRef = (scene as Scene).isScene === true ? (scene as Scene) : _scene;
 
         if (targetScene === null) targetScene = scene;
 
         const renderTarget = this._renderTarget;
-        const renderContext = this._renderContexts.get(targetScene, camera, renderTarget, this._mrt);
+        const renderContext = this._renderContexts!.get(targetScene, camera, renderTarget, this._mrt);
         const activeMipmapLevel = this._activeMipmapLevel;
 
-        const compilationPromises = [];
+        const compilationPromises: Promise<void>[] = [];
 
         this._currentRenderContext = renderContext;
         this._currentRenderObjectFunction = this.renderObject;
@@ -892,7 +1094,7 @@ class Renderer {
 
         //
 
-        const renderList = this._renderLists.get(scene, camera);
+        const renderList = this._renderLists!.get(scene, camera);
         renderList.begin();
 
         this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);
@@ -900,8 +1102,8 @@ class Renderer {
         // include lights from target scene
         if (targetScene !== scene) {
             targetScene.traverseVisible(function (object) {
-                if (object.isLight && object.layers.test(camera.layers)) {
-                    renderList.pushLight(object);
+                if ((object as Light).isLight && object.layers.test(camera.layers)) {
+                    renderList.pushLight(object as Light);
                 }
             });
         }
@@ -911,12 +1113,12 @@ class Renderer {
         //
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
+            this._textures!.updateRenderTarget(renderTarget, activeMipmapLevel);
 
-            const renderTargetData = this._textures.get(renderTarget);
+            const renderTargetData = this._textures!.get(renderTarget);
 
-            renderContext.textures = renderTargetData.textures;
-            renderContext.depthTexture = renderTargetData.depthTexture;
+            renderContext.textures = renderTargetData.textures!;
+            renderContext.depthTexture = renderTargetData.depthTexture!;
         } else {
             renderContext.textures = null;
             renderContext.depthTexture = null;
@@ -924,7 +1126,7 @@ class Renderer {
 
         //
 
-        this._background.update(sceneRef, renderList, renderContext);
+        this._background!.update(sceneRef, renderList, renderContext);
 
         // process render lists
 
@@ -962,7 +1164,7 @@ class Renderer {
      * @param {Camera} camera - The camera.
      * @return {Promise} A Promise that resolves when the render has been finished.
      */
-    async renderAsync(scene, camera) {
+    async renderAsync(scene: Object3D, camera: Camera) {
         warnOnce(
             'Renderer: "renderAsync()" has been deprecated. Use "render()" and "await renderer.init();" when creating the renderer.',
         ); // @deprecated r181
@@ -988,7 +1190,7 @@ class Renderer {
 
     //
 
-    set inspector(value) {
+    set inspector(value: InspectorBase) {
         if (this._inspector !== null) {
             this._inspector.setRenderer(null);
         }
@@ -1015,9 +1217,8 @@ class Renderer {
      * @param {boolean} value - Whether to enable or disable high precision.
      * @type {boolean}
      */
-    set highPrecision(value) {
+    set highPrecision(value: boolean) {
         const contextNodeData = this.contextNode.value;
-
         if (value === true) {
             contextNodeData.modelViewMatrix = highpModelViewMatrix;
             contextNodeData.modelNormalViewMatrix = highpModelNormalViewMatrix;
@@ -1048,7 +1249,7 @@ class Renderer {
      * @param {MRTNode} mrt - The MRT node to set.
      * @return {Renderer} A reference to this renderer.
      */
-    setMRT(mrt) {
+    setMRT(mrt: MRTNode | null) {
         this._mrt = mrt;
 
         return this;
@@ -1078,7 +1279,7 @@ class Renderer {
      * @private
      * @param {Object} info - Information about the context lost.
      */
-    _onDeviceLost(info) {
+    _onDeviceLost(info: DeviceLostInfo) {
         let errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\n\nMessage: ${info.message}`;
 
         if (info.reason) {
@@ -1098,14 +1299,14 @@ class Renderer {
      * @param {Scene} sceneRef - The scene the render bundle belongs to.
      * @param {LightsNode} lightsNode - The lights node.
      */
-    _renderBundle(bundle, sceneRef, lightsNode) {
+    _renderBundle(bundle: Bundle, sceneRef: Scene, lightsNode: LightsNode) {
         const { bundleGroup, camera, renderList } = bundle;
 
-        const renderContext = this._currentRenderContext;
+        const renderContext = this._currentRenderContext!;
 
         //
 
-        const renderBundle = this._bundles.get(bundleGroup, camera);
+        const renderBundle = this._bundles!.get(bundleGroup, camera);
         const renderBundleData = this.backend.get(renderBundle);
 
         if (renderBundleData.renderContexts === undefined) renderBundleData.renderContexts = new Set();
@@ -1156,13 +1357,13 @@ class Renderer {
             for (let i = 0, l = renderObjects.length; i < l; i++) {
                 const renderObject = renderObjects[i];
 
-                if (this._nodes.needsRefresh(renderObject)) {
-                    this._nodes.updateBefore(renderObject);
+                if (this._nodes!.needsRefresh(renderObject)) {
+                    this._nodes!.updateBefore(renderObject);
 
-                    this._nodes.updateForRender(renderObject);
-                    this._bindings.updateForRender(renderObject);
+                    this._nodes!.updateForRender(renderObject);
+                    this._bindings!.updateForRender(renderObject);
 
-                    this._nodes.updateAfter(renderObject);
+                    this._nodes!.updateAfter(renderObject);
                 }
             }
         }
@@ -1185,7 +1386,7 @@ class Renderer {
      * @param {Object3D} scene - The scene or 3D object to render.
      * @param {Camera} camera - The camera to render the scene with.
      */
-    render(scene, camera) {
+    render(scene: Object3D, camera: Camera) {
         if (this._initialized === false) {
             throw new Error(
                 'Renderer: .render() called before the backend is initialized. Use "await renderer.init();" before rendering.',
@@ -1279,7 +1480,7 @@ class Renderer {
      * @param {boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.
      * @return {RenderContext} The current render context.
      */
-    _renderScene(scene, camera, useFrameBufferTarget = true) {
+    _renderScene(scene: Object3D, camera: Camera, useFrameBufferTarget = true) {
         if (this._isDeviceLost === true) return;
 
         //
@@ -1288,7 +1489,7 @@ class Renderer {
 
         // preserve render tree
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
         const previousRenderContext = this._currentRenderContext;
@@ -1317,7 +1518,7 @@ class Renderer {
 
         //
 
-        const renderContext = this._renderContexts.get(scene, camera, renderTarget, this._mrt);
+        const renderContext = this._renderContexts!.get(scene, camera, renderTarget, this._mrt);
 
         this._currentRenderContext = renderContext;
         this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;
@@ -1413,7 +1614,7 @@ class Renderer {
             frustum.setFromProjectionMatrix(_projScreenMatrix, camera.coordinateSystem, camera.reversedDepth);
         }
 
-        const renderList = this._renderLists.get(scene, camera);
+        const renderList = this._renderLists!.get(scene, camera);
         renderList.begin();
 
         this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);
@@ -1427,14 +1628,14 @@ class Renderer {
         //
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
+            this._textures!.updateRenderTarget(renderTarget, activeMipmapLevel);
 
-            const renderTargetData = this._textures.get(renderTarget);
+            const renderTargetData = this._textures!.get(renderTarget);
 
-            renderContext.textures = renderTargetData.textures;
-            renderContext.depthTexture = renderTargetData.depthTexture;
-            renderContext.width = renderTargetData.width;
-            renderContext.height = renderTargetData.height;
+            renderContext.textures = renderTargetData.textures!;
+            renderContext.depthTexture = renderTargetData.depthTexture!;
+            renderContext.width = renderTargetData.width!;
+            renderContext.height = renderTargetData.height!;
             renderContext.renderTarget = renderTarget;
             renderContext.depth = renderTarget.depthBuffer;
             renderContext.stencil = renderTarget.stencilBuffer;
@@ -1467,7 +1668,7 @@ class Renderer {
 
         //
 
-        this._background.update(sceneRef, renderList, renderContext);
+        this._background!.update(sceneRef, renderList, renderContext);
 
         //
 
@@ -1522,7 +1723,7 @@ class Renderer {
         return renderContext;
     }
 
-    _setXRLayerSize(width, height) {
+    _setXRLayerSize(width: number, height: number) {
         // TODO: Find a better solution to resize the canvas when in XR.
 
         this._canvasTarget._width = width;
@@ -1537,11 +1738,11 @@ class Renderer {
      * @private
      * @param {RenderTarget} renderTarget - The current render target.
      */
-    _renderOutput(renderTarget) {
+    _renderOutput(renderTarget: RenderTarget) {
         const quad = this._quad;
 
-        if (this._nodes.hasOutputChange(renderTarget.texture)) {
-            quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);
+        if (this._nodes!.hasOutputChange(renderTarget!.texture)) {
+            quad.material.fragmentNode = this._nodes!.getOutputNode(renderTarget!.texture);
             quad.material.needsUpdate = true;
         }
 
@@ -1595,10 +1796,10 @@ class Renderer {
      * @param {?onAnimationCallback} callback - The application's animation loop.
      * @return {Promise} A Promise that resolves when the set has been executed.
      */
-    async setAnimationLoop(callback) {
+    async setAnimationLoop(callback: ((time: DOMHighResTimeStamp, frame?: XRFrame) => void) | null) {
         if (this._initialized === false) await this.init();
 
-        this._animation.setAnimationLoop(callback);
+        this._animation!.setAnimationLoop(callback);
     }
 
     /**
@@ -1618,7 +1819,7 @@ class Renderer {
      * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
      * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
      */
-    async getArrayBufferAsync(attribute) {
+    async getArrayBufferAsync(attribute: BufferAttribute) {
         return await this.backend.getArrayBufferAsync(attribute);
     }
 
@@ -1646,7 +1847,7 @@ class Renderer {
      * @param {Vector2} target - The method writes the result in this target object.
      * @return {Vector2} The drawing buffer size.
      */
-    getDrawingBufferSize(target) {
+    getDrawingBufferSize(target: Vector2) {
         return this._canvasTarget.getDrawingBufferSize(target);
     }
 
@@ -1656,7 +1857,7 @@ class Renderer {
      * @param {Vector2} target - The method writes the result in this target object.
      * @return {Vector2} The renderer's size in logical pixels.
      */
-    getSize(target) {
+    getSize(target: Vector2) {
         return this._canvasTarget.getSize(target);
     }
 
@@ -1682,7 +1883,7 @@ class Renderer {
      * @param {number} height - The height in logical pixels.
      * @param {number} pixelRatio - The pixel ratio.
      */
-    setDrawingBufferSize(width, height, pixelRatio) {
+    setDrawingBufferSize(width: number, height: number, pixelRatio: number) {
         // Renderer can't be resized while presenting in XR.
         if (this.xr && this.xr.isPresenting) return;
 
@@ -1696,7 +1897,7 @@ class Renderer {
      * @param {number} height - The height in logical pixels.
      * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
      */
-    setSize(width, height, updateStyle = true) {
+    setSize(width: number, height: number, updateStyle = true) {
         // Renderer can't be resized while presenting in XR.
         if (this.xr && this.xr.isPresenting) return;
 
@@ -1709,7 +1910,7 @@ class Renderer {
      *
      * @param {Function} method - The sort function.
      */
-    setOpaqueSort(method) {
+    setOpaqueSort(method: ((a: RenderItem, b: RenderItem) => number) | null) {
         this._opaqueSort = method;
     }
 
@@ -1719,7 +1920,7 @@ class Renderer {
      *
      * @param {Function} method - The sort function.
      */
-    setTransparentSort(method) {
+    setTransparentSort(method: ((a: RenderItem, b: RenderItem) => number) | null) {
         this._transparentSort = method;
     }
 
@@ -1729,7 +1930,7 @@ class Renderer {
      * @param {Vector4} target - The method writes the result in this target object.
      * @return {Vector4} The scissor rectangle.
      */
-    getScissor(target) {
+    getScissor(target: Vector4) {
         return this._canvasTarget.getScissor(target);
     }
 
@@ -1742,8 +1943,10 @@ class Renderer {
      * @param {number} width - The width of the scissor box in logical pixel unit.
      * @param {number} height - The height of the scissor box in logical pixel unit.
      */
-    setScissor(x, y, width, height) {
-        this._canvasTarget.setScissor(x, y, width, height);
+    setScissor(x: Vector4): void;
+    setScissor(x: number, y: number, width: number, height: number): void;
+    setScissor(x: Vector4 | number, y?: number, width?: number, height?: number) {
+        this._canvasTarget.setScissor(x as number, y!, width!, height!);
     }
 
     /**
@@ -1760,7 +1963,7 @@ class Renderer {
      *
      * @param {boolean} boolean - Whether the scissor test should be enabled or not.
      */
-    setScissorTest(boolean) {
+    setScissorTest(boolean: boolean) {
         this._canvasTarget.setScissorTest(boolean);
 
         // TODO: Move it to CanvasTarget event listener.
@@ -1774,7 +1977,7 @@ class Renderer {
      * @param {Vector4} target - The method writes the result in this target object.
      * @return {Vector4} The viewport definition.
      */
-    getViewport(target) {
+    getViewport(target: Vector4) {
         return this._canvasTarget.getViewport(target);
     }
 
@@ -1788,8 +1991,10 @@ class Renderer {
      * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.
      * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.
      */
-    setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {
-        this._canvasTarget.setViewport(x, y, width, height, minDepth, maxDepth);
+    setViewport(x: Vector4): void;
+    setViewport(x: number, y: number, width: number, height: number, minDepth?: number, maxDepth?: number): void;
+    setViewport(x: Vector4 | number, y?: number, width?: number, height?: number, minDepth = 0, maxDepth = 1) {
+        this._canvasTarget.setViewport(x as number, y!, width!, height!, minDepth, maxDepth);
     }
 
     /**
@@ -1798,7 +2003,7 @@ class Renderer {
      * @param {Color} target - The method writes the result in this target object.
      * @return {Color} The clear color.
      */
-    getClearColor(target) {
+    getClearColor(target: Color4) {
         return target.copy(this._clearColor);
     }
 
@@ -1808,7 +2013,7 @@ class Renderer {
      * @param {Color} color - The clear color.
      * @param {number} [alpha=1] - The clear alpha.
      */
-    setClearColor(color, alpha = 1) {
+    setClearColor(color: ColorRepresentation, alpha = 1) {
         this._clearColor.set(color);
         this._clearColor.a = alpha;
     }
@@ -1827,7 +2032,7 @@ class Renderer {
      *
      * @param {number} alpha - The clear alpha.
      */
-    setClearAlpha(alpha) {
+    setClearAlpha(alpha: number) {
         this._clearColor.a = alpha;
     }
 
@@ -1845,7 +2050,7 @@ class Renderer {
      *
      * @param {number} depth - The clear depth.
      */
-    setClearDepth(depth) {
+    setClearDepth(depth: number) {
         this._clearDepth = depth;
     }
 
@@ -1863,7 +2068,7 @@ class Renderer {
      *
      * @param {number} stencil - The clear stencil.
      */
-    setClearStencil(stencil) {
+    setClearStencil(stencil: number) {
         this._clearStencil = stencil;
     }
 
@@ -1875,7 +2080,7 @@ class Renderer {
      * @param {Object3D} object - The 3D object to test.
      * @return {boolean} Whether the 3D object is fully occluded or not.
      */
-    isOccluded(object) {
+    isOccluded(object: Object3D) {
         const renderContext = this._currentRenderContext;
 
         return renderContext && this.backend.isOccluded(renderContext, object);
@@ -1900,9 +2105,9 @@ class Renderer {
         let renderContext = null;
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget);
+            this._textures!.updateRenderTarget(renderTarget);
 
-            const renderTargetData = this._textures.get(renderTarget);
+            const renderTargetData = this._textures!.get(renderTarget);
 
             renderContext = this._renderContexts.getForClear(renderTarget);
             renderContext.textures = renderTargetData.textures;
@@ -2092,15 +2297,15 @@ class Renderer {
             this.info.dispose();
             this.backend.dispose();
 
-            this._animation.dispose();
-            this._objects.dispose();
+            this._animation!.dispose();
+            this._objects!.dispose();
             this._geometries.dispose();
-            this._pipelines.dispose();
-            this._nodes.dispose();
-            this._bindings.dispose();
-            this._renderLists.dispose();
-            this._renderContexts.dispose();
-            this._textures.dispose();
+            this._pipelines!.dispose();
+            this._nodes!.dispose();
+            this._bindings!.dispose();
+            this._renderLists!.dispose();
+            this._renderContexts!.dispose();
+            this._textures!.dispose();
 
             if (this._frameBufferTarget !== null) this._frameBufferTarget.dispose();
 
@@ -2122,7 +2327,7 @@ class Renderer {
      * @param {number} [activeCubeFace=0] - The active cube face.
      * @param {number} [activeMipmapLevel=0] - The active mipmap level.
      */
-    setRenderTarget(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
+    setRenderTarget(renderTarget: RenderTarget | null, activeCubeFace = 0, activeMipmapLevel = 0) {
         this._renderTarget = renderTarget;
         this._activeCubeFace = activeCubeFace;
         this._activeMipmapLevel = activeMipmapLevel;
@@ -2142,7 +2347,7 @@ class Renderer {
      *
      * @param {Object} renderTarget - The render target to set as the output target.
      */
-    setOutputRenderTarget(renderTarget) {
+    setOutputRenderTarget(renderTarget: RenderTarget | null) {
         this._outputRenderTarget = renderTarget;
     }
 
@@ -2161,7 +2366,7 @@ class Renderer {
      *
      * @param {CanvasTarget} canvasTarget - The canvas target.
      */
-    setCanvasTarget(canvasTarget) {
+    setCanvasTarget(canvasTarget: CanvasTarget) {
         this._canvasTarget.removeEventListener('resize', this._onCanvasTargetResize);
 
         this._canvasTarget = canvasTarget;
@@ -2217,7 +2422,19 @@ class Renderer {
      *
      * @param {?renderObjectFunction} renderObjectFunction - The render object function.
      */
-    setRenderObjectFunction(renderObjectFunction) {
+    setRenderObjectFunction(
+        renderObjectFunction:
+            | ((
+                  object: Object3D,
+                  scene: Scene,
+                  camera: Camera,
+                  geometry: BufferGeometry,
+                  material: Material,
+                  group: GeometryGroup,
+                  lightsNode: LightsNode,
+              ) => void)
+            | null,
+    ) {
         this._renderObjectFunction = renderObjectFunction;
     }
 
@@ -2241,7 +2458,10 @@ class Renderer {
      * - A IndirectStorageBufferAttribute for indirect dispatch size.
      * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
      */
-    compute(computeNodes, dispatchSize = null) {
+    compute(
+        computeNodes: ComputeNode | ComputeNode[],
+        dispatchSize: number[] | number | IndirectStorageBufferAttribute | null = null,
+    ) {
         if (this._isDeviceLost === true) return;
 
         if (this._initialized === false) {
@@ -2252,7 +2472,7 @@ class Renderer {
 
         //
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
 
@@ -2273,9 +2493,9 @@ class Renderer {
         //
 
         const backend = this.backend;
-        const pipelines = this._pipelines;
-        const bindings = this._bindings;
-        const nodes = this._nodes;
+        const pipelines = this._pipelines!;
+        const bindings = this._bindings!;
+        const nodes = this._nodes!;
 
         const computeList = Array.isArray(computeNodes) ? computeNodes : [computeNodes];
 
@@ -2339,7 +2559,10 @@ class Renderer {
      * - A IndirectStorageBufferAttribute for indirect dispatch size.
      * @return {Promise} A Promise that resolve when the compute has finished.
      */
-    async computeAsync(computeNodes, dispatchSize = null) {
+    async computeAsync(
+        computeNodes: ComputeNode | ComputeNode[],
+        dispatchSize: number[] | number | IndirectStorageBufferAttribute | null = null,
+    ) {
         if (this._initialized === false) await this.init();
 
         this.compute(computeNodes, dispatchSize);
@@ -2353,7 +2576,7 @@ class Renderer {
      * @param {string} name - The feature's name.
      * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
      */
-    async hasFeatureAsync(name) {
+    async hasFeatureAsync(name: string) {
         warnOnce(
             'Renderer: "hasFeatureAsync()" has been deprecated. Use "hasFeature()" and "await renderer.init();" when creating the renderer.',
         ); // @deprecated r181
@@ -2363,7 +2586,7 @@ class Renderer {
         return this.hasFeature(name);
     }
 
-    async resolveTimestampsAsync(type = 'render') {
+    async resolveTimestampsAsync(type: TimestampQuery = 'render') {
         if (this._initialized === false) await this.init();
 
         return this.backend.resolveTimestampsAsync(type);
@@ -2376,7 +2599,7 @@ class Renderer {
      * @param {string} name - The feature's name.
      * @return {boolean} Whether the feature is supported or not.
      */
-    hasFeature(name) {
+    hasFeature(name: string) {
         if (this._initialized === false) {
             throw new Error(
                 'Renderer: .hasFeature() called before the backend is initialized. Use "await renderer.init();" before before using this method.',
@@ -2404,7 +2627,7 @@ class Renderer {
      * @param {Texture} texture - The texture.
      * @return {Promise} A Promise that resolves when the texture has been initialized.
      */
-    async initTextureAsync(texture) {
+    async initTextureAsync(texture: Texture) {
         warnOnce(
             'Renderer: "initTextureAsync()" has been deprecated. Use "initTexture()" and "await renderer.init();" when creating the renderer.',
         ); // @deprecated r181
@@ -2422,14 +2645,14 @@ class Renderer {
      *
      * @param {Texture} texture - The texture.
      */
-    initTexture(texture) {
+    initTexture(texture: Texture) {
         if (this._initialized === false) {
             throw new Error(
                 'Renderer: .initTexture() called before the backend is initialized. Use "await renderer.init();" before before using this method.',
             );
         }
 
-        this._textures.updateTexture(texture);
+        this._textures!.updateTexture(texture);
     }
 
     /**
@@ -2438,7 +2661,7 @@ class Renderer {
      * @param {FramebufferTexture} framebufferTexture - The texture.
      * @param {?(Vector2|Vector4)} [rectangle=null] - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.
      */
-    copyFramebufferToTexture(framebufferTexture, rectangle = null) {
+    copyFramebufferToTexture(framebufferTexture: FramebufferTexture, rectangle: Rectangle | null = null) {
         if (rectangle !== null) {
             if (rectangle.isVector2) {
                 rectangle = _vector4
@@ -2491,7 +2714,14 @@ class Renderer {
      * @param {number} [srcLevel=0] - The source mip level to copy from.
      * @param {number} [dstLevel=0] - The destination mip level to copy to.
      */
-    copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
+    copyTextureToTexture(
+        srcTexture: Texture,
+        dstTexture: Texture,
+        srcRegion: Box2 | Box3 | null = null,
+        dstPosition: Vector2 | Vector3 | null = null,
+        srcLevel = 0,
+        dstLevel = 0,
+    ) {
         this._textures.updateTexture(srcTexture);
         this._textures.updateTexture(dstTexture);
 
@@ -2513,7 +2743,15 @@ class Renderer {
      * @param {number} [faceIndex=0] - The active cube face index.
      * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
      */
-    async readRenderTargetPixelsAsync(renderTarget, x, y, width, height, textureIndex = 0, faceIndex = 0) {
+    async readRenderTargetPixelsAsync(
+        renderTarget: RenderTarget,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+        textureIndex = 0,
+        faceIndex = 0,
+    ) {
         return this.backend.copyTextureToBuffer(renderTarget.textures[textureIndex], x, y, width, height, faceIndex);
     }
 
@@ -2528,49 +2766,63 @@ class Renderer {
      * @param {RenderList} renderList - The current render list.
      * @param {ClippingContext} clippingContext - The current clipping context.
      */
-    _projectObject(object, camera, groupOrder, renderList, clippingContext) {
+    _projectObject(
+        object: Object3D,
+        camera: Camera,
+        groupOrder: number,
+        renderList: RenderList,
+        clippingContext: ClippingContext | null,
+    ) {
         if (object.visible === false) return;
 
         const visible = object.layers.test(camera.layers);
 
         if (visible) {
-            if (object.isGroup) {
-                groupOrder = object.renderOrder;
+            if ((object as Group).isGroup) {
+                groupOrder = (object as Group).renderOrder;
 
                 if (object.isClippingGroup && object.enabled) clippingContext = clippingContext.getGroupContext(object);
-            } else if (object.isLOD) {
-                if (object.autoUpdate === true) object.update(camera);
-            } else if (object.isLight) {
-                renderList.pushLight(object);
-            } else if (object.isSprite) {
-                const frustum = camera.isArrayCamera ? _frustumArray : _frustum;
-
-                if (!object.frustumCulled || frustum.intersectsSprite(object, camera)) {
+            } else if ((object as LOD).isLOD) {
+                if ((object as LOD).autoUpdate === true) (object as LOD).update(camera);
+            } else if ((object as Light).isLight) {
+                renderList.pushLight(object as Light);
+            } else if ((object as Sprite).isSprite) {
+                const frustum = (camera as ArrayCamera).isArrayCamera ? _frustumArray : _frustum;
+
+                if (!object.frustumCulled || frustum.intersectsSprite(object as Sprite, camera)) {
                     if (this.sortObjects === true) {
                         _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                     }
 
-                    const { geometry, material } = object;
+                    const { geometry, material } = object as Sprite;
 
                     if (material.visible) {
-                        renderList.push(object, geometry, material, groupOrder, _vector4.z, null, clippingContext);
+                        renderList.push(
+                            object as Sprite,
+                            geometry,
+                            material,
+                            groupOrder,
+                            _vector4.z,
+                            null,
+                            clippingContext,
+                        );
                     }
                 }
-            } else if (object.isLineLoop) {
+            } else if ((object as LineLoop).isLineLoop) {
                 error(
                     'Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.',
                 );
-            } else if (object.isMesh || object.isLine || object.isPoints) {
+            } else if ((object as Mesh).isMesh || (object as Line).isLine || (object as Points).isPoints) {
                 const frustum = camera.isArrayCamera ? _frustumArray : _frustum;
 
                 if (!object.frustumCulled || frustum.intersectsObject(object, camera)) {
-                    const { geometry, material } = object;
+                    const { geometry, material } = object as Mesh | Line | Points;
 
                     if (this.sortObjects === true) {
                         if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
 
                         _vector4
-                            .copy(geometry.boundingSphere.center)
+                            .copy(geometry.boundingSphere!.center)
                             .applyMatrix4(object.matrixWorld)
                             .applyMatrix4(_projScreenMatrix);
                     }
@@ -2580,7 +2832,7 @@ class Renderer {
 
                         for (let i = 0, l = groups.length; i < l; i++) {
                             const group = groups[i];
-                            const groupMaterial = material[group.materialIndex];
+                            const groupMaterial = material[group.materialIndex!];
 
                             if (groupMaterial && groupMaterial.visible) {
                                 renderList.push(
@@ -2605,7 +2857,7 @@ class Renderer {
             const baseRenderList = renderList;
 
             // replace render list
-            renderList = this._renderLists.get(object, camera);
+            renderList = this._renderLists!.get(object, camera);
 
             renderList.begin();
 
@@ -2633,7 +2885,7 @@ class Renderer {
      * @param {Scene} sceneRef - The scene the render bundles belong to.
      * @param {LightsNode} lightsNode - The current lights node.
      */
-    _renderBundles(bundles, sceneRef, lightsNode) {
+    _renderBundles(bundles: Bundle[], sceneRef: Scene, lightsNode: LightsNode) {
         for (const bundle of bundles) {
             this._renderBundle(bundle, sceneRef, lightsNode);
         }
@@ -2649,7 +2901,13 @@ class Renderer {
      * @param {Scene} scene - The scene the render list belongs to.
      * @param {LightsNode} lightsNode - The current lights node.
      */
-    _renderTransparents(renderList, doublePassList, camera, scene, lightsNode) {
+    _renderTransparents(
+        renderList: RenderItem[],
+        doublePassList: RenderItem[],
+        camera: Camera,
+        scene: Scene,
+        lightsNode: LightsNode,
+    ) {
         if (doublePassList.length > 0) {
             // render back side
 
@@ -2687,17 +2945,23 @@ class Renderer {
      * @param {LightsNode} lightsNode - The current lights node.
      * @param {?string} [passId=null] - An optional ID for identifying the pass.
      */
-    _renderObjects(renderList, camera, scene, lightsNode, passId = null) {
+    _renderObjects(
+        renderList: RenderItem[],
+        camera: Camera,
+        scene: Scene,
+        lightsNode: LightsNode,
+        passId: string | null = null,
+    ) {
         for (let i = 0, il = renderList.length; i < il; i++) {
             const { object, geometry, material, group, clippingContext } = renderList[i];
 
-            this._currentRenderObjectFunction(
-                object,
+            this._currentRenderObjectFunction!(
+                object!,
                 scene,
                 camera,
-                geometry,
-                material,
-                group,
+                geometry!,
+                material!,
+                group!,
                 lightsNode,
                 clippingContext,
                 passId,
@@ -2713,7 +2977,7 @@ class Renderer {
      * @param {Material} material
      * @returns {Object} - The shadow nodes for the material.
      */
-    _getShadowNodes(material) {
+    _getShadowNodes(material: Material) {
         const version = material.version;
 
         let cache = this._cacheShadowNodes.get(material);
@@ -2787,7 +3051,17 @@ class Renderer {
      * @param {?ClippingContext} clippingContext - The clipping context.
      * @param {?string} [passId=null] - An optional ID for identifying the pass.
      */
-    renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null) {
+    renderObject(
+        object: Object3D,
+        scene: Scene,
+        camera: Camera,
+        geometry: BufferGeometry,
+        material: Material,
+        group: GeometryGroup,
+        lightsNode: LightsNode,
+        clippingContext: ClippingContext | null = null,
+        passId: string | null = null,
+    ) {
         let materialOverride = false;
         let materialColorNode;
         let materialDepthNode;
@@ -2878,14 +3152,23 @@ class Renderer {
      * @param {ClippingContext} clippingContext - The clipping context.
      * @param {string} [passId] - An optional ID for identifying the pass.
      */
-    _renderObjectDirect(object, material, scene, camera, lightsNode, group, clippingContext, passId) {
-        const renderObject = this._objects.get(
+    _renderObjectDirect(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: GeometryGroup,
+        clippingContext: ClippingContext | null,
+        passId?: string,
+    ) {
+        const renderObject = this._objects!.get(
             object,
             material,
             scene,
             camera,
             lightsNode,
-            this._currentRenderContext,
+            this._currentRenderContext!,
             clippingContext,
             passId,
         );
@@ -2894,18 +3177,18 @@ class Renderer {
 
         //
 
-        const needsRefresh = this._nodes.needsRefresh(renderObject);
+        const needsRefresh = this._nodes!.needsRefresh(renderObject);
 
         if (needsRefresh) {
-            this._nodes.updateBefore(renderObject);
+            this._nodes!.updateBefore(renderObject);
 
-            this._geometries.updateForRender(renderObject);
+            this._geometries!.updateForRender(renderObject);
 
-            this._nodes.updateForRender(renderObject);
-            this._bindings.updateForRender(renderObject);
+            this._nodes!.updateForRender(renderObject);
+            this._bindings!.updateForRender(renderObject);
         }
 
-        this._pipelines.updateForRender(renderObject);
+        this._pipelines!.updateForRender(renderObject);
 
         //
 
@@ -2919,7 +3202,7 @@ class Renderer {
 
         this.backend.draw(renderObject, this.info);
 
-        if (needsRefresh) this._nodes.updateAfter(renderObject);
+        if (needsRefresh) this._nodes!.updateAfter(renderObject);
     }
 
     /**
@@ -2936,14 +3219,23 @@ class Renderer {
      * @param {ClippingContext} clippingContext - The clipping context.
      * @param {string} [passId] - An optional ID for identifying the pass.
      */
-    _createObjectPipeline(object, material, scene, camera, lightsNode, group, clippingContext, passId) {
-        const renderObject = this._objects.get(
+    _createObjectPipeline(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: Group,
+        clippingContext: ClippingContext | null,
+        passId?: string,
+    ) {
+        const renderObject = this._objects!.get(
             object,
             material,
             scene,
             camera,
             lightsNode,
-            this._currentRenderContext,
+            this._currentRenderContext!,
             clippingContext,
             passId,
         );
@@ -2952,16 +3244,16 @@ class Renderer {
 
         //
 
-        this._nodes.updateBefore(renderObject);
+        this._nodes!.updateBefore(renderObject);
 
-        this._geometries.updateForRender(renderObject);
+        this._geometries!.updateForRender(renderObject);
 
-        this._nodes.updateForRender(renderObject);
-        this._bindings.updateForRender(renderObject);
+        this._nodes!.updateForRender(renderObject);
+        this._bindings!.updateForRender(renderObject);
 
-        this._pipelines.getForRender(renderObject, this._compilationPromises);
+        this._pipelines!.getForRender(renderObject, this._compilationPromises);
 
-        this._nodes.updateAfter(renderObject);
+        this._nodes!.updateAfter(renderObject);
     }
 
     /**
diff --git a/src-testing/src/renderers/common/SampledTexture.ts b/src-testing/src/renderers/common/SampledTexture.ts
index 70282d04..fd7dc5a1 100644
--- a/src-testing/src/renderers/common/SampledTexture.ts
+++ b/src-testing/src/renderers/common/SampledTexture.ts
@@ -1,4 +1,5 @@
 import Sampler from './Sampler.js';
+import { Texture } from '../../textures/Texture.js';
 
 let _id = 0;
 
@@ -9,13 +10,19 @@ let _id = 0;
  * @augments Sampler
  */
 class SampledTexture extends Sampler {
+    id: number;
+
+    store: boolean;
+
+    readonly isSampledTexture: true;
+
     /**
      * Constructs a new sampled texture.
      *
      * @param {string} name - The sampled texture's name.
      * @param {?Texture} texture - The texture this binding is referring to.
      */
-    constructor(name, texture) {
+    constructor(name: string, texture: Texture) {
         super(name, texture);
 
         /**
@@ -59,13 +66,15 @@ class SampledTexture extends Sampler {
  * @augments SampledTexture
  */
 class SampledArrayTexture extends SampledTexture {
+    readonly isSampledArrayTexture: true;
+
     /**
      * Constructs a new sampled array texture.
      *
      * @param {string} name - The sampled array texture's name.
      * @param {?(DataArrayTexture|CompressedArrayTexture)} texture - The texture this binding is referring to.
      */
-    constructor(name, texture) {
+    constructor(name: string, texture) {
         super(name, texture);
 
         /**
@@ -86,13 +95,15 @@ class SampledArrayTexture extends SampledTexture {
  * @augments SampledTexture
  */
 class Sampled3DTexture extends SampledTexture {
+    readonly isSampled3DTexture: true;
+
     /**
      * Constructs a new sampled 3D texture.
      *
      * @param {string} name - The sampled 3D texture's name.
      * @param {?Data3DTexture} texture - The texture this binding is referring to.
      */
-    constructor(name, texture) {
+    constructor(name: string, texture) {
         super(name, texture);
 
         /**
@@ -113,13 +124,15 @@ class Sampled3DTexture extends SampledTexture {
  * @augments SampledTexture
  */
 class SampledCubeTexture extends SampledTexture {
+    readonly isSampledCubeTexture: true;
+
     /**
      * Constructs a new sampled cube texture.
      *
      * @param {string} name - The sampled cube texture's name.
      * @param {?(CubeTexture|CompressedCubeTexture)} texture - The texture this binding is referring to.
      */
-    constructor(name, texture) {
+    constructor(name: string, texture) {
         super(name, texture);
 
         /**
diff --git a/src-testing/src/renderers/common/Sampler.ts b/src-testing/src/renderers/common/Sampler.ts
index 7c12c508..9fb4858d 100644
--- a/src-testing/src/renderers/common/Sampler.ts
+++ b/src-testing/src/renderers/common/Sampler.ts
@@ -7,13 +7,19 @@ import Binding from './Binding.js';
  * @augments Binding
  */
 class Sampler extends Binding {
+    // TODO
+    // texture
+    version: number;
+
+    readonly isSampler: true;
+
     /**
      * Constructs a new sampler.
      *
      * @param {string} name - The samplers's name.
      * @param {?Texture} texture - The texture this binding is referring to.
      */
-    constructor(name, texture) {
+    constructor(name: string, texture) {
         super(name);
 
         /**
diff --git a/src-testing/src/renderers/common/StorageBuffer.ts b/src-testing/src/renderers/common/StorageBuffer.ts
index 4b7c259d..96cda7ef 100644
--- a/src-testing/src/renderers/common/StorageBuffer.ts
+++ b/src-testing/src/renderers/common/StorageBuffer.ts
@@ -7,13 +7,18 @@ import Buffer from './Buffer.js';
  * @augments Buffer
  */
 class StorageBuffer extends Buffer {
+    // TODO
+    // attribute
+
+    readonly isStorageBuffer: true;
+
     /**
      * Constructs a new uniform buffer.
      *
      * @param {string} name - The buffer's name.
      * @param {BufferAttribute} attribute - The buffer attribute.
      */
-    constructor(name, attribute) {
+    constructor(name: string, attribute) {
         super(name, attribute ? attribute.array : null);
 
         /**
diff --git a/src-testing/src/renderers/common/Textures.ts b/src-testing/src/renderers/common/Textures.ts
index 345d32ba..130609c6 100644
--- a/src-testing/src/renderers/common/Textures.ts
+++ b/src-testing/src/renderers/common/Textures.ts
@@ -12,8 +12,46 @@ import {
 } from '../../constants.js';
 import { ColorManagement } from '../../math/ColorManagement.js';
 import { warn } from '../../utils.js';
+import { Texture } from '../../textures/Texture.js';
+import { RenderTarget } from '../../core/RenderTarget.js';
+import Renderer from './Renderer.js';
+import Backend from './Backend.js';
+import Info from './Info.js';
+import { CubeTexture } from '../../textures/CubeTexture.js';
+import { CompressedTexture } from '../../textures/CompressedTexture.js';
+
+type SizeVector3Uninitialized = Vector3 & { width?: number; height?: number; depth?: number };
+type SizeVector3 = Vector3 & { width: number; height: number; depth: number };
+
+const _size: SizeVector3Uninitialized = /*@__PURE__*/ new Vector3();
+
+interface RenderTargetData {
+    depthTextureMips?: { [activeMipmapLevel: number]: DepthTexture };
+    width?: number;
+    height?: number;
+    textures?: Texture[];
+    depthTexture?: DepthTexture;
+    depth?: boolean;
+    stencil?: boolean;
+    renderTarget?: RenderTarget;
+    sampleCount?: number;
+    initialized?: boolean;
+}
 
-const _size = /*@__PURE__*/ new Vector3();
+interface TextureData {
+    initialized?: boolean;
+    version?: number;
+    isDefaultTexture?: boolean;
+    generation?: number;
+}
+
+interface TextureOptions {
+    width?: number;
+    height?: number;
+    depth?: number;
+    needsMipmaps?: boolean;
+    levels?: number;
+}
 
 /**
  * This module manages the textures of the renderer.
@@ -21,7 +59,14 @@ const _size = /*@__PURE__*/ new Vector3();
  * @private
  * @augments DataMap
  */
-class Textures extends DataMap {
+class Textures extends DataMap<{
+    renderTarget: { key: RenderTarget; value: RenderTargetData };
+    texture: { key: Texture; value: TextureData };
+}> {
+    renderer: Renderer;
+    backend: Backend;
+    info: Info;
+
     /**
      * Constructs a new texture management component.
      *
@@ -29,7 +74,7 @@ class Textures extends DataMap {
      * @param {Backend} backend - The renderer's backend.
      * @param {Info} info - Renderer component for managing metrics and monitoring data.
      */
-    constructor(renderer, backend, info) {
+    constructor(renderer: Renderer, backend: Backend, info: Info) {
         super();
 
         /**
@@ -61,7 +106,7 @@ class Textures extends DataMap {
      * @param {RenderTarget} renderTarget - The render target to update.
      * @param {number} [activeMipmapLevel=0] - The active mipmap level.
      */
-    updateRenderTarget(renderTarget, activeMipmapLevel = 0) {
+    updateRenderTarget(renderTarget: RenderTarget, activeMipmapLevel = 0) {
         const renderTargetData = this.get(renderTarget);
 
         const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
@@ -165,7 +210,7 @@ class Textures extends DataMap {
      * @param {Texture} texture - The texture to update.
      * @param {Object} [options={}] - The options.
      */
-    updateTexture(texture, options = {}) {
+    updateTexture(texture: Texture, options: TextureOptions = {}) {
         const textureData = this.get(texture);
         if (textureData.initialized === true && textureData.version === texture.version) return;
 
@@ -304,7 +349,7 @@ class Textures extends DataMap {
      * @param {Texture} texture - The texture to update the sampler for.
      * @return {string} The current sampler key.
      */
-    updateSampler(texture) {
+    updateSampler(texture: Texture) {
         return this.backend.updateSampler(texture);
     }
 
@@ -320,7 +365,7 @@ class Textures extends DataMap {
      * @param {Vector3} target - The target vector.
      * @return {Vector3} The target vector.
      */
-    getSize(texture, target = _size) {
+    getSize(texture: Texture, target = _size) {
         let image = texture.images ? texture.images[0] : texture.image;
 
         if (image) {
@@ -337,13 +382,13 @@ class Textures extends DataMap {
             } else {
                 target.width = image.width || 1;
                 target.height = image.height || 1;
-                target.depth = texture.isCubeTexture ? 6 : image.depth || 1;
+                target.depth = (texture as CubeTexture).isCubeTexture ? 6 : image.depth || 1;
             }
         } else {
             target.width = target.height = target.depth = 1;
         }
 
-        return target;
+        return target as SizeVector3;
     }
 
     /**
@@ -354,13 +399,13 @@ class Textures extends DataMap {
      * @param {number} height - The texture's height.
      * @return {number} The number of mipmap levels.
      */
-    getMipLevels(texture, width, height) {
+    getMipLevels(texture: Texture, width: number, height: number) {
         let mipLevelCount;
 
-        if (texture.mipmaps.length > 0) {
-            mipLevelCount = texture.mipmaps.length;
+        if (texture.mipmaps!.length > 0) {
+            mipLevelCount = texture.mipmaps!.length;
         } else {
-            if (texture.isCompressedTexture === true) {
+            if ((texture as CompressedTexture).isCompressedTexture === true) {
                 // it is not possible to compute mipmaps for compressed textures. So
                 // when no mipmaps are defined in "texture.mipmaps", force a texture
                 // level of 1
@@ -380,8 +425,8 @@ class Textures extends DataMap {
      * @param {Texture} texture - The texture.
      * @return {boolean} Whether mipmaps are required or not.
      */
-    needsMipmaps(texture) {
-        return texture.generateMipmaps === true || texture.mipmaps.length > 0;
+    needsMipmaps(texture: Texture) {
+        return texture.generateMipmaps === true || texture.mipmaps!.length > 0;
     }
 
     /**
@@ -390,7 +435,7 @@ class Textures extends DataMap {
      *
      * @param {RenderTarget} renderTarget - The render target to destroy.
      */
-    _destroyRenderTarget(renderTarget) {
+    _destroyRenderTarget(renderTarget: RenderTarget) {
         if (this.has(renderTarget) === true) {
             const renderTargetData = this.get(renderTarget);
 
@@ -422,7 +467,7 @@ class Textures extends DataMap {
      *
      * @param {Texture} texture - The texture to destroy.
      */
-    _destroyTexture(texture) {
+    _destroyTexture(texture: Texture) {
         if (this.has(texture) === true) {
             const textureData = this.get(texture);
 
diff --git a/src-testing/src/renderers/common/TimestampQueryPool.ts b/src-testing/src/renderers/common/TimestampQueryPool.ts
index a2e65be3..e32dd793 100644
--- a/src-testing/src/renderers/common/TimestampQueryPool.ts
+++ b/src-testing/src/renderers/common/TimestampQueryPool.ts
@@ -5,7 +5,17 @@ import { warn } from '../../utils.js';
  *
  * @abstract
  */
-class TimestampQueryPool {
+abstract class TimestampQueryPool {
+    trackTimestamp: boolean;
+    maxQueries: number;
+    currentQueryIndex: number;
+    queryOffsets: Map<number, number>;
+    isDisposed: boolean;
+    lastValue: number;
+    frames: number[];
+    pendingResolve: boolean;
+    timestamps: Map<string, number>;
+
     /**
      * Creates a new timestamp query pool.
      *
@@ -97,7 +107,7 @@ class TimestampQueryPool {
      * @param {string} uid - A unique identifier for the render context.
      * @return {?number} The timestamp, or undefined if not available.
      */
-    getTimestamp(uid) {
+    getTimestamp(uid: string) {
         let timestamp = this.timestamps.get(uid);
 
         if (timestamp === undefined) {
@@ -115,7 +125,7 @@ class TimestampQueryPool {
      * @param {string} uid - A unique identifier for the render context.
      * @return {boolean} True if a timestamp is available, false otherwise.
      */
-    hasTimestamp(uid) {
+    hasTimestamp(uid: string) {
         return this.timestamps.has(uid);
     }
 
@@ -127,7 +137,7 @@ class TimestampQueryPool {
      * @param {number} frameId - The current frame identifier.
      * @returns {?number}
      */
-    allocateQueriesForContext(/* uid, frameId */) {}
+    abstract allocateQueriesForContext(uid: string, frameId: number): number | null;
 
     /**
      * Resolve all timestamps and return data (or process them).
@@ -136,14 +146,14 @@ class TimestampQueryPool {
      * @async
      * @returns {Promise<number>|number} The resolved timestamp value.
      */
-    async resolveQueriesAsync() {}
+    abstract resolveQueriesAsync(): Promise<number>;
 
     /**
      * Dispose of the query pool.
      *
      * @abstract
      */
-    dispose() {}
+    abstract dispose(): void;
 }
 
 export default TimestampQueryPool;
diff --git a/src-testing/src/renderers/common/Uniform.ts b/src-testing/src/renderers/common/Uniform.ts
index 85fe79e3..f1d0b8e8 100644
--- a/src-testing/src/renderers/common/Uniform.ts
+++ b/src-testing/src/renderers/common/Uniform.ts
@@ -12,14 +12,22 @@ import { Vector4 } from '../../math/Vector4.js';
  * @abstract
  * @private
  */
-class Uniform {
+class Uniform<TValue> {
+    name: string;
+    value: TValue;
+
+    boundary: number;
+    itemSize: number;
+
+    offset: number;
+
     /**
      * Constructs a new uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {any} value - The uniform's value.
      */
-    constructor(name, value) {
+    constructor(name: string, value: TValue) {
         /**
          * The uniform's name.
          *
@@ -65,7 +73,7 @@ class Uniform {
      *
      * @param {any} value - The value to set.
      */
-    setValue(value) {
+    setValue(value: TValue) {
         this.value = value;
     }
 
@@ -85,14 +93,16 @@ class Uniform {
  * @private
  * @augments Uniform
  */
-class NumberUniform extends Uniform {
+class NumberUniform extends Uniform<number> {
+    readonly isNumberUniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {number} value - The uniform's value.
      */
-    constructor(name, value = 0) {
+    constructor(name: string, value = 0) {
         super(name, value);
 
         /**
@@ -115,14 +125,16 @@ class NumberUniform extends Uniform {
  * @private
  * @augments Uniform
  */
-class Vector2Uniform extends Uniform {
+class Vector2Uniform extends Uniform<Vector2> {
+    readonly isVector2Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Vector2} value - The uniform's value.
      */
-    constructor(name, value = new Vector2()) {
+    constructor(name: string, value = new Vector2()) {
         super(name, value);
 
         /**
@@ -145,14 +157,16 @@ class Vector2Uniform extends Uniform {
  * @private
  * @augments Uniform
  */
-class Vector3Uniform extends Uniform {
+class Vector3Uniform extends Uniform<Vector3> {
+    readonly isVector3Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Vector3} value - The uniform's value.
      */
-    constructor(name, value = new Vector3()) {
+    constructor(name: string, value = new Vector3()) {
         super(name, value);
 
         /**
@@ -175,14 +189,16 @@ class Vector3Uniform extends Uniform {
  * @private
  * @augments Uniform
  */
-class Vector4Uniform extends Uniform {
+class Vector4Uniform extends Uniform<Vector4> {
+    readonly isVector4Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Vector4} value - The uniform's value.
      */
-    constructor(name, value = new Vector4()) {
+    constructor(name: string, value = new Vector4()) {
         super(name, value);
 
         /**
@@ -205,14 +221,16 @@ class Vector4Uniform extends Uniform {
  * @private
  * @augments Uniform
  */
-class ColorUniform extends Uniform {
+class ColorUniform extends Uniform<Color> {
+    readonly isColorUniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Color} value - The uniform's value.
      */
-    constructor(name, value = new Color()) {
+    constructor(name: string, value = new Color()) {
         super(name, value);
 
         /**
@@ -235,14 +253,16 @@ class ColorUniform extends Uniform {
  * @private
  * @augments Uniform
  */
-class Matrix2Uniform extends Uniform {
+class Matrix2Uniform extends Uniform<Matrix2> {
+    readonly isMatrix2Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Matrix2} value - The uniform's value.
      */
-    constructor(name, value = new Matrix2()) {
+    constructor(name: string, value = new Matrix2()) {
         super(name, value);
 
         /**
@@ -265,14 +285,16 @@ class Matrix2Uniform extends Uniform {
  * @private
  * @augments Uniform
  */
-class Matrix3Uniform extends Uniform {
+class Matrix3Uniform extends Uniform<Matrix3> {
+    readonly isMatrix3Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Matrix3} value - The uniform's value.
      */
-    constructor(name, value = new Matrix3()) {
+    constructor(name: string, value = new Matrix3()) {
         super(name, value);
 
         /**
@@ -295,14 +317,16 @@ class Matrix3Uniform extends Uniform {
  * @private
  * @augments Uniform
  */
-class Matrix4Uniform extends Uniform {
+class Matrix4Uniform extends Uniform<Matrix4> {
+    readonly isMatrix4Uniform: true;
+
     /**
      * Constructs a new Number uniform.
      *
      * @param {string} name - The uniform's name.
      * @param {Matrix4} value - The uniform's value.
      */
-    constructor(name, value = new Matrix4()) {
+    constructor(name: string, value = new Matrix4()) {
         super(name, value);
 
         /**
diff --git a/src-testing/src/renderers/common/UniformBuffer.ts b/src-testing/src/renderers/common/UniformBuffer.ts
index 93c9419f..aa5b6b4b 100644
--- a/src-testing/src/renderers/common/UniformBuffer.ts
+++ b/src-testing/src/renderers/common/UniformBuffer.ts
@@ -7,13 +7,15 @@ import Buffer from './Buffer.js';
  * @augments Buffer
  */
 class UniformBuffer extends Buffer {
+    readonly isUniformBuffer: true;
+
     /**
      * Constructs a new uniform buffer.
      *
      * @param {string} name - The buffer's name.
      * @param {TypedArray} [buffer=null] - The buffer.
      */
-    constructor(name, buffer = null) {
+    constructor(name?: string, buffer = null) {
         super(name, buffer);
 
         /**
diff --git a/src-testing/src/renderers/common/UniformsGroup.ts b/src-testing/src/renderers/common/UniformsGroup.ts
index e5354d6c..4871cd0b 100644
--- a/src-testing/src/renderers/common/UniformsGroup.ts
+++ b/src-testing/src/renderers/common/UniformsGroup.ts
@@ -1,6 +1,16 @@
 import UniformBuffer from './UniformBuffer.js';
 import { GPU_CHUNK_BYTES } from './Constants.js';
 import { error } from '../../utils.js';
+import {
+    ColorNodeUniform,
+    Matrix3NodeUniform,
+    Matrix4NodeUniform,
+    NodeUniformGPU,
+    NumberNodeUniform,
+    Vector2NodeUniform,
+    Vector3NodeUniform,
+    Vector4NodeUniform,
+} from './nodes/NodeUniform.js';
 
 /**
  * This class represents a uniform buffer binding but with
@@ -10,12 +20,18 @@ import { error } from '../../utils.js';
  * @augments UniformBuffer
  */
 class UniformsGroup extends UniformBuffer {
+    readonly isUniformsGroup: true;
+
+    _values: number[] | null;
+
+    uniforms: NodeUniformGPU[];
+
     /**
      * Constructs a new uniforms group.
      *
      * @param {string} name - The group's name.
      */
-    constructor(name) {
+    constructor(name?: string) {
         super(name);
 
         /**
@@ -52,7 +68,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Uniform} uniform - The uniform to add.
      * @return {UniformsGroup} A reference to this group.
      */
-    addUniform(uniform) {
+    addUniform(uniform: NodeUniformGPU) {
         this.uniforms.push(uniform);
 
         return this;
@@ -64,7 +80,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Uniform} uniform - The uniform to remove.
      * @return {UniformsGroup} A reference to this group.
      */
-    removeUniform(uniform) {
+    removeUniform(uniform: NodeUniformGPU) {
         const index = this.uniforms.indexOf(uniform);
 
         if (index !== -1) {
@@ -92,7 +108,7 @@ class UniformsGroup extends UniformBuffer {
      *
      * @type {Float32Array}
      */
-    get buffer() {
+    get buffer(): Float32Array {
         let buffer = this._buffer;
 
         if (buffer === null) {
@@ -170,14 +186,14 @@ class UniformsGroup extends UniformBuffer {
      * @param {Uniform} uniform - The uniform to update.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateByType(uniform) {
-        if (uniform.isNumberUniform) return this.updateNumber(uniform);
-        if (uniform.isVector2Uniform) return this.updateVector2(uniform);
-        if (uniform.isVector3Uniform) return this.updateVector3(uniform);
-        if (uniform.isVector4Uniform) return this.updateVector4(uniform);
-        if (uniform.isColorUniform) return this.updateColor(uniform);
-        if (uniform.isMatrix3Uniform) return this.updateMatrix3(uniform);
-        if (uniform.isMatrix4Uniform) return this.updateMatrix4(uniform);
+    updateByType(uniform: NodeUniformGPU) {
+        if ((uniform as NumberNodeUniform).isNumberUniform) return this.updateNumber(uniform as NumberNodeUniform);
+        if ((uniform as Vector2NodeUniform).isVector2Uniform) return this.updateVector2(uniform as Vector2NodeUniform);
+        if ((uniform as Vector3NodeUniform).isVector3Uniform) return this.updateVector3(uniform as Vector3NodeUniform);
+        if ((uniform as Vector4NodeUniform).isVector4Uniform) return this.updateVector4(uniform as Vector4NodeUniform);
+        if ((uniform as ColorNodeUniform).isColorUniform) return this.updateColor(uniform as ColorNodeUniform);
+        if ((uniform as Matrix3NodeUniform).isMatrix3Uniform) return this.updateMatrix3(uniform as Matrix3NodeUniform);
+        if ((uniform as Matrix4NodeUniform).isMatrix4Uniform) return this.updateMatrix4(uniform as Matrix4NodeUniform);
 
         error('WebGPUUniformsGroup: Unsupported uniform type.', uniform);
     }
@@ -188,7 +204,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {NumberUniform} uniform - The Number uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateNumber(uniform) {
+    updateNumber(uniform: NumberNodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -212,7 +228,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Vector2Uniform} uniform - The Vector2 uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateVector2(uniform) {
+    updateVector2(uniform: Vector2NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -238,7 +254,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Vector3Uniform} uniform - The Vector3 uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateVector3(uniform) {
+    updateVector3(uniform: Vector3NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -265,7 +281,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Vector4Uniform} uniform - The Vector4 uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateVector4(uniform) {
+    updateVector4(uniform: Vector4NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -293,7 +309,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {ColorUniform} uniform - The Color uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateColor(uniform) {
+    updateColor(uniform: ColorNodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -319,7 +335,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Matrix3Uniform} uniform - The Matrix3 uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateMatrix3(uniform) {
+    updateMatrix3(uniform: Matrix3NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -361,7 +377,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {Matrix4Uniform} uniform - The Matrix4 uniform.
      * @return {boolean} Whether the uniform has been updated or not.
      */
-    updateMatrix4(uniform) {
+    updateMatrix4(uniform: Matrix4NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -385,7 +401,7 @@ class UniformsGroup extends UniformBuffer {
      * @param {string} type - The data type.
      * @return {TypedArray} The typed array.
      */
-    _getBufferForType(type) {
+    _getBufferForType(type: string | null): Int32Array | Uint32Array | Float32Array {
         if (type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4')
             return new Int32Array(this.buffer.buffer);
         if (type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4')
@@ -402,7 +418,7 @@ class UniformsGroup extends UniformBuffer {
  * @param {TypedArray} b - The second array.
  * @param {number} offset - An index offset for the first array.
  */
-function setArray(a, b, offset) {
+function setArray(a: number[], b: number[], offset: number) {
     for (let i = 0, l = b.length; i < l; i++) {
         a[offset + i] = b[i];
     }
@@ -417,7 +433,7 @@ function setArray(a, b, offset) {
  * @param {number} offset - An index offset for the first array.
  * @return {boolean} Whether the given arrays are equal or not.
  */
-function arraysEqual(a, b, offset) {
+function arraysEqual(a: number[], b: number[], offset: number) {
     for (let i = 0, l = b.length; i < l; i++) {
         if (a[offset + i] !== b[i]) return false;
     }
diff --git a/src-testing/src/renderers/common/XRManager.ts b/src-testing/src/renderers/common/XRManager.ts
index 7a93f539..e7921a93 100644
--- a/src-testing/src/renderers/common/XRManager.ts
+++ b/src-testing/src/renderers/common/XRManager.ts
@@ -29,10 +29,61 @@ import { PlaneGeometry } from '../../geometries/PlaneGeometry.js';
 import { MeshBasicMaterial } from '../../materials/MeshBasicMaterial.js';
 import { Mesh } from '../../objects/Mesh.js';
 import { warn } from '../../utils.js';
+import Renderer from './Renderer.js';
+import { AnimationContext } from './Animation.js';
+import { Camera } from '../../cameras/Camera.js';
+import { Object3D } from '../../core/Object3D.js';
+import { Material } from '../../materials/Material.js';
+import { RenderTarget } from '../../core/RenderTarget.js';
 
 const _cameraLPos = /*@__PURE__*/ new Vector3();
 const _cameraRPos = /*@__PURE__*/ new Vector3();
 
+export interface XRManagerEventMap {
+    sessionstart: {};
+    sessionend: {};
+    planesdetected: { data: XRFrame };
+}
+
+export interface XRQuadLayerObject {
+    type: 'quad';
+    width: number;
+    height: number;
+    translation: Vector3;
+    quaternion: Quaternion;
+    pixelwidth: number;
+    pixelheight: number;
+    plane: Mesh;
+    material: Material;
+    rendercall: () => void;
+    renderTarget: XRRenderTarget;
+
+    xrlayer?: XRLayer;
+}
+
+export interface XRCylinderLayerObject {
+    type: 'cylinder';
+    radius: number;
+    centralAngle: number;
+    aspectratio: number;
+    translation: Vector3;
+    quaternion: Quaternion;
+    pixelwidth: number;
+    pixelheight: number;
+    plane: Mesh;
+    material: Material;
+    rendercall: () => void;
+    renderTarget: XRRenderTarget;
+
+    xrlayer?: XRLayer;
+}
+
+export type XRLayerObject = XRQuadLayerObject | XRCylinderLayerObject;
+
+export interface LayerAttributes {
+    stencil?: boolean | undefined;
+}
+
 /**
  * The XR manager is built on top of the WebXR Device API to
  * manage XR sessions with `WebGPURenderer`.
@@ -41,14 +92,96 @@ const _cameraRPos = /*@__PURE__*/ new Vector3();
  *
  * @augments EventDispatcher
  */
-class XRManager extends EventDispatcher {
+class XRManager extends EventDispatcher<XRManagerEventMap> {
+    enabled: boolean;
+
+    isPresenting: boolean;
+
+    cameraAutoUpdate: boolean;
+
+    _renderer: Renderer;
+
+    _cameraL: PerspectiveCamera;
+
+    _cameraR: PerspectiveCamera;
+
+    _cameras: PerspectiveCamera[];
+
+    _cameraXR: ArrayCamera;
+
+    _currentDepthNear: number | null;
+
+    _currentDepthFar: number | null;
+
+    _controllers: WebXRController[];
+
+    _controllerInputSources: (XRInputSource | null)[];
+
+    _xrRenderTarget: XRRenderTarget | null;
+
+    _layers: XRLayerObject[];
+
+    _sessionUsesLayers: boolean;
+
+    _supportsLayers: boolean;
+
+    _supportsGlBinding: boolean;
+
+    _frameBufferTargets: WeakMap<XRRenderTarget, { frameBufferTarget: RenderTarget | null; quad: QuadMesh }> | null;
+
+    _createXRLayer: (layer: XRLayerObject) => XRLayer;
+
+    _gl: WebGL2RenderingContext | null;
+
+    _currentAnimationContext: AnimationContext | null;
+
+    _currentAnimationLoop: ((time: DOMHighResTimeStamp, frame?: XRFrame) => void) | null;
+
+    _currentPixelRatio: number | null;
+
+    _currentSize: Vector2;
+
+    _onSessionEvent: (event: XRInputSourceEvent) => void;
+
+    _onSessionEnd: () => void;
+
+    _onInputSourcesChange: (event: XRInputSourcesChangeEvent) => void;
+
+    _onAnimationFrame: (time: DOMHighResTimeStamp, frame?: XRFrame) => void;
+
+    _referenceSpace: XRReferenceSpace | null;
+
+    _referenceSpaceType: XRReferenceSpaceType;
+
+    _customReferenceSpace: XRReferenceSpace | null;
+
+    _framebufferScaleFactor: number;
+
+    _foveation: number;
+
+    _session: XRSession | null;
+
+    _glBaseLayer: XRWebGLLayer | null;
+
+    _glBinding: XRWebGLBinding | null;
+
+    _glProjLayer: XRProjectionLayer | null;
+
+    _xrFrame: XRFrame | null;
+
+    _useLayers: boolean;
+
+    _useMultiviewIfPossible: boolean;
+
+    _useMultiview: boolean;
+
     /**
      * Constructs a new XR manager.
      *
      * @param {Renderer} renderer - The renderer.
      * @param {boolean} [multiview=false] - Enables multiview if the device supports it.
      */
-    constructor(renderer, multiview = false) {
+    constructor(renderer: Renderer, multiview = false) {
         super();
 
         /**
@@ -412,7 +545,7 @@ class XRManager extends EventDispatcher {
      * @param {number} index - The index of the XR controller.
      * @return {Group} A group that represents the controller's transformation.
      */
-    getController(index) {
+    getController(index: number) {
         const controller = this._getController(index);
 
         return controller.getTargetRaySpace();
@@ -426,7 +559,7 @@ class XRManager extends EventDispatcher {
      * @param {number} index - The index of the XR controller.
      * @return {Group} A group that represents the controller's transformation.
      */
-    getControllerGrip(index) {
+    getControllerGrip(index: number) {
         const controller = this._getController(index);
 
         return controller.getGripSpace();
@@ -440,7 +573,7 @@ class XRManager extends EventDispatcher {
      * @param {number} index - The index of the XR controller.
      * @return {Group} A group that represents the controller's transformation.
      */
-    getHand(index) {
+    getHand(index: number) {
         const controller = this._getController(index);
 
         return controller.getHandSpace();
@@ -465,7 +598,7 @@ class XRManager extends EventDispatcher {
      * @param {number} foveation - A number in the range `[0,1]` where `0` means no foveation (full resolution)
      * and `1` means maximum foveation (the edges render at lower resolution).
      */
-    setFoveation(foveation) {
+    setFoveation(foveation: number) {
         this._foveation = foveation;
 
         if (this._glProjLayer !== null) {
@@ -493,7 +626,7 @@ class XRManager extends EventDispatcher {
      *
      * @param {number} factor - The framebuffer scale factor.
      */
-    setFramebufferScaleFactor(factor) {
+    setFramebufferScaleFactor(factor: number) {
         this._framebufferScaleFactor = factor;
 
         if (this.isPresenting === true) {
@@ -517,7 +650,7 @@ class XRManager extends EventDispatcher {
      *
      * @param {XRReferenceSpaceType} type - The reference space type.
      */
-    setReferenceSpaceType(type) {
+    setReferenceSpaceType(type: XRReferenceSpaceType) {
         this._referenceSpaceType = type;
 
         if (this.isPresenting === true) {
@@ -539,7 +672,7 @@ class XRManager extends EventDispatcher {
      *
      * @param {XRReferenceSpace} space - The XR reference space.
      */
-    setReferenceSpace(space) {
+    setReferenceSpace(space: XRReferenceSpace) {
         this._customReferenceSpace = space;
     }
 
@@ -573,7 +706,7 @@ class XRManager extends EventDispatcher {
      */
     getBinding() {
         if (this._glBinding === null && this._supportsGlBinding) {
-            this._glBinding = new XRWebGLBinding(this._session, this._gl);
+            this._glBinding = new XRWebGLBinding(this._session!, this._gl);
         }
 
         return this._glBinding;
@@ -612,7 +745,16 @@ class XRManager extends EventDispatcher {
      * @param {Object} [attributes={}] - Allows to configure the layer's render target.
      * @return {Mesh} A mesh representing the quadratic XR layer. This mesh should be added to the XR scene.
      */
-    createQuadLayer(width, height, translation, quaternion, pixelwidth, pixelheight, rendercall, attributes = {}) {
+    createQuadLayer(
+        width: number,
+        height: number,
+        translation: Vector3,
+        quaternion: Quaternion,
+        pixelwidth: number,
+        pixelheight: number,
+        rendercall: () => void,
+        attributes: LayerAttributes = {},
+    ) {
         const geometry = new PlaneGeometry(width, height);
         const renderTarget = new XRRenderTarget(pixelwidth, pixelheight, {
             format: RGBAFormat,
@@ -644,7 +786,7 @@ class XRManager extends EventDispatcher {
         plane.position.copy(translation);
         plane.quaternion.copy(quaternion);
 
-        const layer = {
+        const layer: XRQuadLayerObject = {
             type: 'quad',
             width: width,
             height: height,
@@ -669,7 +811,7 @@ class XRManager extends EventDispatcher {
 
             layer.xrlayer = this._createXRLayer(layer);
 
-            const xrlayers = this._session.renderState.layers;
+            const xrlayers = this._session.renderState.layers!;
             xrlayers.unshift(layer.xrlayer);
             this._session.updateRenderState({ layers: xrlayers });
         } else {
@@ -696,15 +838,15 @@ class XRManager extends EventDispatcher {
      * @return {Mesh} A mesh representing the cylindrical XR layer. This mesh should be added to the XR scene.
      */
     createCylinderLayer(
-        radius,
-        centralAngle,
-        aspectratio,
-        translation,
-        quaternion,
-        pixelwidth,
-        pixelheight,
-        rendercall,
-        attributes = {},
+        radius: number,
+        centralAngle: number,
+        aspectratio: number,
+        translation: Vector3,
+        quaternion: Quaternion,
+        pixelwidth: number,
+        pixelheight: number,
+        rendercall: () => void,
+        attributes: LayerAttributes = {},
     ) {
         const geometry = new CylinderGeometry(
             radius,
@@ -746,7 +888,7 @@ class XRManager extends EventDispatcher {
         plane.position.copy(translation);
         plane.quaternion.copy(quaternion);
 
-        const layer = {
+        const layer: XRCylinderLayerObject = {
             type: 'cylinder',
             radius: radius,
             centralAngle: centralAngle,
@@ -772,7 +914,7 @@ class XRManager extends EventDispatcher {
 
             layer.xrlayer = this._createXRLayer(layer);
 
-            const xrlayers = this._session.renderState.layers;
+            const xrlayers = this._session.renderState.layers!;
             xrlayers.unshift(layer.xrlayer);
             this._session.updateRenderState({ layers: xrlayers });
         } else {
@@ -807,12 +949,12 @@ class XRManager extends EventDispatcher {
             layer.renderTarget._hasExternalTextures = layer.renderTarget.isXRRenderTarget;
 
             if (layer.renderTarget.isXRRenderTarget && this._sessionUsesLayers) {
-                layer.xrlayer.transform = new XRRigidTransform(
+                layer.xrlayer!.transform = new XRRigidTransform(
                     layer.plane.getWorldPosition(translationObject),
                     layer.plane.getWorldQuaternion(quaternionObject),
                 );
 
-                const glSubImage = this._glBinding.getSubImage(layer.xrlayer, this._xrFrame);
+                const glSubImage = this._glBinding!.getSubImage(layer.xrlayer, this._xrFrame);
                 renderer.backend.setXRRenderTargetTextures(layer.renderTarget, glSubImage.colorTexture, undefined);
 
                 renderer._setXRLayerSize(layer.renderTarget.width, layer.renderTarget.height);
@@ -871,7 +1013,7 @@ class XRManager extends EventDispatcher {
      * @param {XRSession} session - The XR session to set.
      * @return {Promise} A Promise that resolves when the session has been set.
      */
-    async setSession(session) {
+    async setSession(session: XRSession) {
         const renderer = this._renderer;
         const backend = renderer.backend;
 
@@ -901,9 +1043,9 @@ class XRManager extends EventDispatcher {
             this._currentPixelRatio = renderer.getPixelRatio();
             renderer.getSize(this._currentSize);
 
-            this._currentAnimationContext = renderer._animation.getContext();
-            this._currentAnimationLoop = renderer._animation.getAnimationLoop();
-            renderer._animation.stop();
+            this._currentAnimationContext = renderer._animation!.getContext();
+            this._currentAnimationLoop = renderer._animation!.getAnimationLoop();
+            renderer._animation!.stop();
 
             //
 
@@ -1030,11 +1172,11 @@ class XRManager extends EventDispatcher {
 
             //
 
-            this.setFoveation(this.getFoveation());
+            this.setFoveation(this.getFoveation()!);
 
-            renderer._animation.setAnimationLoop(this._onAnimationFrame);
-            renderer._animation.setContext(session);
-            renderer._animation.start();
+            renderer._animation!.setAnimationLoop(this._onAnimationFrame);
+            renderer._animation!.setContext(session);
+            renderer._animation!.start();
 
             this.isPresenting = true;
 
@@ -1049,7 +1191,7 @@ class XRManager extends EventDispatcher {
      *
      * @param {PerspectiveCamera} camera - The camera.
      */
-    updateCamera(camera) {
+    updateCamera(camera: PerspectiveCamera) {
         const session = this._session;
 
         if (session === null) return;
@@ -1082,7 +1224,7 @@ class XRManager extends EventDispatcher {
         cameraL.layers.mask = cameraXR.layers.mask & 0b011;
         cameraR.layers.mask = cameraXR.layers.mask & 0b101;
 
-        const parent = camera.parent;
+        const parent = camera.parent!;
         const cameras = cameraXR.cameras;
 
         updateCamera(cameraXR, parent);
@@ -1113,7 +1255,7 @@ class XRManager extends EventDispatcher {
      * @param {number} index - The controller index.
      * @return {WebXRController} The XR controller.
      */
-    _getController(index) {
+    _getController(index: number) {
         let controller = this._controllers[index];
 
         if (controller === undefined) {
@@ -1135,7 +1277,7 @@ class XRManager extends EventDispatcher {
  * @param {PerspectiveCamera} cameraL - The left camera.
  * @param {PerspectiveCamera} cameraR - The right camera.
  */
-function setProjectionFromUnion(camera, cameraL, cameraR) {
+function setProjectionFromUnion(camera: ArrayCamera, cameraL: PerspectiveCamera, cameraR: PerspectiveCamera) {
     _cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
     _cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
 
@@ -1199,7 +1341,7 @@ function setProjectionFromUnion(camera, cameraL, cameraR) {
  * @param {Camera} camera - The camera to update.
  * @param {Object3D} parent - The parent 3D object.
  */
-function updateCamera(camera, parent) {
+function updateCamera(camera: Camera, parent: Object3D) {
     if (parent === null) {
         camera.matrixWorld.copy(camera.matrix);
     } else {
@@ -1217,7 +1359,7 @@ function updateCamera(camera, parent) {
  * @param {ArrayCamera} cameraXR - The XR camera.
  * @param {Object3D} parent - The parent 3D object.
  */
-function updateUserCamera(camera, cameraXR, parent) {
+function updateUserCamera(camera: Camera, cameraXR: ArrayCamera, parent: Object3D) {
     if (parent === null) {
         camera.matrix.copy(cameraXR.matrixWorld);
     } else {
@@ -1232,13 +1374,14 @@ function updateUserCamera(camera, cameraXR, parent) {
     camera.projectionMatrix.copy(cameraXR.projectionMatrix);
     camera.projectionMatrixInverse.copy(cameraXR.projectionMatrixInverse);
 
-    if (camera.isPerspectiveCamera) {
-        camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
-        camera.zoom = 1;
+    if ((camera as PerspectiveCamera).isPerspectiveCamera) {
+        (camera as PerspectiveCamera).fov =
+            RAD2DEG * 2 * Math.atan(1 / (camera as PerspectiveCamera).projectionMatrix.elements[5]);
+        (camera as PerspectiveCamera).zoom = 1;
     }
 }
 
-function onSessionEvent(event) {
+function onSessionEvent(this: XRManager, event: XRInputSourceEvent) {
     const controllerIndex = this._controllerInputSources.indexOf(event.inputSource);
 
     if (controllerIndex === -1) {
@@ -1248,15 +1391,15 @@ function onSessionEvent(event) {
     const controller = this._controllers[controllerIndex];
 
     if (controller !== undefined) {
-        const referenceSpace = this.getReferenceSpace();
+        const referenceSpace = this.getReferenceSpace()!;
 
         controller.update(event.inputSource, event.frame, referenceSpace);
         controller.dispatchEvent({ type: event.type, data: event.inputSource });
     }
 }
 
-function onSessionEnd() {
-    const session = this._session;
+function onSessionEnd(this: XRManager) {
+    const session = this._session!;
     const renderer = this._renderer;
 
     session.removeEventListener('select', this._onSessionEvent);
@@ -1330,18 +1473,18 @@ function onSessionEnd() {
     this.isPresenting = false;
     this._useMultiview = false;
 
-    renderer._animation.stop();
-    renderer._animation.setAnimationLoop(this._currentAnimationLoop);
-    renderer._animation.setContext(this._currentAnimationContext);
-    renderer._animation.start();
+    renderer._animation!.stop();
+    renderer._animation!.setAnimationLoop(this._currentAnimationLoop);
+    renderer._animation!.setContext(this._currentAnimationContext!);
+    renderer._animation!.start();
 
-    renderer.setPixelRatio(this._currentPixelRatio);
+    renderer.setPixelRatio(this._currentPixelRatio!);
     renderer.setSize(this._currentSize.width, this._currentSize.height, false);
 
     this.dispatchEvent({ type: 'sessionend' });
 }
 
-function onInputSourcesChange(event) {
+function onInputSourcesChange(this: XRManager, event: XRInputSourcesChangeEvent) {
     const controllers = this._controllers;
     const controllerInputSources = this._controllerInputSources;
 
@@ -1393,24 +1536,24 @@ function onInputSourcesChange(event) {
 }
 
 // Creation method for native WebXR layers
-function createXRLayer(layer) {
+function createXRLayer(this: XRManager, layer: XRLayerObject) {
     if (layer.type === 'quad') {
-        return this._glBinding.createQuadLayer({
+        return this._glBinding!.createQuadLayer({
             transform: new XRRigidTransform(layer.translation, layer.quaternion),
             width: layer.width / 2,
             height: layer.height / 2,
-            space: this._referenceSpace,
+            space: this._referenceSpace!,
             viewPixelWidth: layer.pixelwidth,
             viewPixelHeight: layer.pixelheight,
             clearOnAccess: false,
         });
     } else {
-        return this._glBinding.createCylinderLayer({
+        return this._glBinding!.createCylinderLayer({
             transform: new XRRigidTransform(layer.translation, layer.quaternion),
             radius: layer.radius,
             centralAngle: layer.centralAngle,
             aspectRatio: layer.aspectRatio,
-            space: this._referenceSpace,
+            space: this._referenceSpace!,
             viewPixelWidth: layer.pixelwidth,
             viewPixelHeight: layer.pixelheight,
             clearOnAccess: false,
@@ -1420,7 +1563,7 @@ function createXRLayer(layer) {
 
 // Animation Loop
 
-function onAnimationFrame(time, frame) {
+function onAnimationFrame(this: XRManager, time: DOMHighResTimeStamp, frame?: XRFrame) {
     if (frame === undefined) return;
 
     const cameraXR = this._cameraXR;
@@ -1429,16 +1572,16 @@ function onAnimationFrame(time, frame) {
 
     const glBaseLayer = this._glBaseLayer;
 
-    const referenceSpace = this.getReferenceSpace();
+    const referenceSpace = this.getReferenceSpace()!;
     const pose = frame.getViewerPose(referenceSpace);
 
     this._xrFrame = frame;
 
     if (pose !== null) {
-        const views = pose.views;
+        const views = pose!.views;
 
         if (this._glBaseLayer !== null) {
-            backend.setXRTarget(glBaseLayer.framebuffer);
+            backend.setXRTarget(glBaseLayer!.framebuffer);
         }
 
         let cameraXRNeedsUpdate = false;
@@ -1456,7 +1599,7 @@ function onAnimationFrame(time, frame) {
             let viewport;
 
             if (this._supportsLayers === true) {
-                const glSubImage = this._glBinding.getViewSubImage(this._glProjLayer, view);
+                const glSubImage = this._glBinding!.getViewSubImage(this._glProjLayer!, view);
                 viewport = glSubImage.viewport;
 
                 // For side-by-side projection, we only produce a single texture for both eyes.
@@ -1464,13 +1607,13 @@ function onAnimationFrame(time, frame) {
                     backend.setXRRenderTargetTextures(
                         this._xrRenderTarget,
                         glSubImage.colorTexture,
-                        this._glProjLayer.ignoreDepthValues && !this._useMultiview
+                        this._glProjLayer!.ignoreDepthValues && !this._useMultiview
                             ? undefined
                             : glSubImage.depthStencilTexture,
                     );
                 }
             } else {
-                viewport = glBaseLayer.getViewport(view);
+                viewport = glBaseLayer!.getViewport(view)!;
             }
 
             let camera = this._cameras[i];
@@ -1486,7 +1629,7 @@ function onAnimationFrame(time, frame) {
             camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
             camera.projectionMatrix.fromArray(view.projectionMatrix);
             camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
-            camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
+            camera.viewport!.set(viewport.x, viewport.y, viewport.width, viewport.height);
 
             if (i === 0) {
                 cameraXR.matrix.copy(camera.matrix);
diff --git a/src-testing/src/renderers/common/XRRenderTarget.ts b/src-testing/src/renderers/common/XRRenderTarget.ts
index c10c9850..7fff94ff 100644
--- a/src-testing/src/renderers/common/XRRenderTarget.ts
+++ b/src-testing/src/renderers/common/XRRenderTarget.ts
@@ -1,4 +1,4 @@
-import { RenderTarget } from '../../core/RenderTarget.js';
+import { RenderTarget, RenderTargetOptions } from '../../core/RenderTarget.js';
 
 /**
  * A special type of render target that is used when rendering
@@ -8,6 +8,14 @@ import { RenderTarget } from '../../core/RenderTarget.js';
  * @augments RenderTarget
  */
 class XRRenderTarget extends RenderTarget {
+    readonly isXRRenderTarget: true;
+
+    _hasExternalTextures: boolean;
+
+    _autoAllocateDepthBuffer: boolean;
+
+    _isOpaqueFramebuffer: boolean;
+
     /**
      * Constructs a new XR render target.
      *
@@ -15,7 +23,7 @@ class XRRenderTarget extends RenderTarget {
      * @param {number} [height=1] - The height of the render target.
      * @param {Object} [options={}] - The configuration options.
      */
-    constructor(width = 1, height = 1, options = {}) {
+    constructor(width = 1, height = 1, options: RenderTargetOptions = {}) {
         super(width, height, options);
 
         /**
@@ -70,7 +78,7 @@ class XRRenderTarget extends RenderTarget {
         this._isOpaqueFramebuffer = false;
     }
 
-    copy(source) {
+    copy(source: XRRenderTarget) {
         super.copy(source);
 
         this._hasExternalTextures = source._hasExternalTextures;
diff --git a/src-testing/src/renderers/common/nodes/NodeBuilderState.ts b/src-testing/src/renderers/common/nodes/NodeBuilderState.ts
index 5fe2b322..2013d057 100644
--- a/src-testing/src/renderers/common/nodes/NodeBuilderState.ts
+++ b/src-testing/src/renderers/common/nodes/NodeBuilderState.ts
@@ -1,4 +1,8 @@
 import BindGroup from '../BindGroup.js';
+import NodeAttribute from '../../../nodes/core/NodeAttribute.js';
+import Node from '../../../nodes/core/Node.js';
+import NodeUniformsGroup from './NodeUniformsGroup.js';
+import NodeMaterialObserver from '../../../materials/nodes/manager/NodeMaterialObserver.js';
 
 /**
  * This module represents the state of a node builder after it was
@@ -10,6 +14,22 @@ import BindGroup from '../BindGroup.js';
  * @private
  */
 class NodeBuilderState {
+    vertexShader: string | null;
+    fragmentShader: string | null;
+    computeShader: string | null;
+    transforms: never[];
+
+    nodeAttributes: NodeAttribute[];
+    bindings: BindGroup[];
+
+    updateNodes: Node[];
+    updateBeforeNodes: Node[];
+    updateAfterNodes: Node[];
+
+    observer: NodeMaterialObserver;
+
+    usedTimes: number;
+
     /**
      * Constructs a new node builder state.
      *
@@ -25,16 +45,16 @@ class NodeBuilderState {
      * @param {Array<Object>} transforms - An array with transform attribute objects. Only relevant when using compute shaders with WebGL 2.
      */
     constructor(
-        vertexShader,
-        fragmentShader,
-        computeShader,
-        nodeAttributes,
-        bindings,
-        updateNodes,
-        updateBeforeNodes,
-        updateAfterNodes,
-        observer,
-        transforms = [],
+        vertexShader: string | null,
+        fragmentShader: string | null,
+        computeShader: string | null,
+        nodeAttributes: NodeAttribute[],
+        bindings: BindGroup[],
+        updateNodes: Node[],
+        updateBeforeNodes: Node[],
+        updateAfterNodes: Node[],
+        observer: NodeMaterialObserver,
+        transforms: never[] = [],
     ) {
         /**
          * The native vertex shader code.
@@ -128,7 +148,7 @@ class NodeBuilderState {
         const bindings = [];
 
         for (const instanceGroup of this.bindings) {
-            const shared = instanceGroup.bindings[0].groupNode.shared; // All bindings in the group must have the same groupNode.
+            const shared = (instanceGroup.bindings[0] as NodeUniformsGroup).groupNode.shared; // All bindings in the group must have the same groupNode.
 
             if (shared !== true) {
                 const bindingsGroup = new BindGroup(
@@ -140,7 +160,7 @@ class NodeBuilderState {
                 bindings.push(bindingsGroup);
 
                 for (const instanceBinding of instanceGroup.bindings) {
-                    bindingsGroup.bindings.push(instanceBinding.clone());
+                    bindingsGroup.bindings.push((instanceBinding as NodeUniformsGroup).clone());
                 }
             } else {
                 bindings.push(instanceGroup);
diff --git a/src-testing/src/renderers/common/nodes/NodeLibrary.ts b/src-testing/src/renderers/common/nodes/NodeLibrary.ts
index 7c61c35c..04e6eb0d 100644
--- a/src-testing/src/renderers/common/nodes/NodeLibrary.ts
+++ b/src-testing/src/renderers/common/nodes/NodeLibrary.ts
@@ -1,4 +1,10 @@
 import { warn } from '../../../utils.js';
+import { Material } from '../../../materials/Material.js';
+import NodeMaterial from '../../../materials/nodes/NodeMaterial.js';
+import { ToneMapping } from '../../../constants.js';
+import Node from '../../../nodes/core/Node.js';
+import { Light } from '../../../lights/Light.js';
+import AnalyticLightNode from '../../../nodes/lighting/AnalyticLightNode.js';
 
 /**
  * The purpose of a node library is to assign node implementations
@@ -9,6 +15,10 @@ import { warn } from '../../../utils.js';
  * @private
  */
 class NodeLibrary {
+    lightNodes: WeakMap<{ new (): Light }, { new (light: Light): AnalyticLightNode<Light> }>;
+    materialNodes: Map<string, { new (): NodeMaterial }>;
+    toneMappingNodes: Map<ToneMapping, (color: Node, exposure: Node) => Node>;
+
     /**
      * Constructs a new node library.
      */
@@ -46,8 +56,8 @@ class NodeLibrary {
      * @param {Material} material - A material.
      * @return {NodeMaterial} The corresponding node material.
      */
-    fromMaterial(material) {
-        if (material.isNodeMaterial) return material;
+    fromMaterial(material: Material) {
+        if ((material as NodeMaterial).isNodeMaterial) return material;
 
         let nodeMaterial = null;
 
@@ -70,7 +80,7 @@ class NodeLibrary {
      * @param {Function} toneMappingNode - The tone mapping node function.
      * @param {number} toneMapping - The tone mapping.
      */
-    addToneMapping(toneMappingNode, toneMapping) {
+    addToneMapping(toneMappingNode: (color: Node, exposure: Node) => Node, toneMapping: ToneMapping) {
         this.addType(toneMappingNode, toneMapping, this.toneMappingNodes);
     }
 
@@ -80,7 +90,7 @@ class NodeLibrary {
      * @param {number} toneMapping - The tone mapping.
      * @return {?Function} The tone mapping node function. Returns `null` if no node function is found.
      */
-    getToneMappingFunction(toneMapping) {
+    getToneMappingFunction(toneMapping: ToneMapping) {
         return this.toneMappingNodes.get(toneMapping) || null;
     }
 
@@ -90,7 +100,7 @@ class NodeLibrary {
      * @param {string} materialType - The material type.
      * @return {?NodeMaterial.constructor} The node material class definition. Returns `null` if no node material is found.
      */
-    getMaterialNodeClass(materialType) {
+    getMaterialNodeClass(materialType: string) {
         return this.materialNodes.get(materialType) || null;
     }
 
@@ -100,7 +110,7 @@ class NodeLibrary {
      * @param {NodeMaterial.constructor} materialNodeClass - The node material class definition.
      * @param {string} materialClassType - The material type.
      */
-    addMaterial(materialNodeClass, materialClassType) {
+    addMaterial(materialNodeClass: { new (): NodeMaterial }, materialClassType: string) {
         this.addType(materialNodeClass, materialClassType, this.materialNodes);
     }
 
@@ -110,7 +120,7 @@ class NodeLibrary {
      * @param {Light.constructor} light - The light class definition.
      * @return {?AnalyticLightNode.constructor} The light node class definition. Returns `null` if no light node is found.
      */
-    getLightNodeClass(light) {
+    getLightNodeClass(light: Light) {
         return this.lightNodes.get(light) || null;
     }
 
@@ -120,8 +130,18 @@ class NodeLibrary {
      * @param {AnalyticLightNode.constructor} lightNodeClass - The light node class definition.
      * @param {Light.constructor} lightClass - The light class definition.
      */
-    addLight(lightNodeClass, lightClass) {
-        this.addClass(lightNodeClass, lightClass, this.lightNodes);
+    addLight<TLight extends Light>(
+        lightNodeClass: { new (light: TLight): AnalyticLightNode<TLight> },
+        lightClass: { new (): TLight },
+    ) {
+        this.addClass(
+            lightNodeClass,
+            lightClass,
+            this.lightNodes as unknown as WeakMap<
+                { new (): TLight },
+                { new (light: TLight): AnalyticLightNode<TLight> }
+            >,
+        );
     }
 
     /**
@@ -131,7 +151,7 @@ class NodeLibrary {
      * @param {number|string} type - The object type.
      * @param {Map<number|string,Node.constructor>} library - The type library.
      */
-    addType(nodeClass, type, library) {
+    addType<TNodeClass, TType>(nodeClass: TNodeClass, type: TType, library: Map<TType, TNodeClass>) {
         if (library.has(type)) {
             warn(`Redefinition of node ${type}`);
             return;
@@ -151,7 +171,11 @@ class NodeLibrary {
      * @param {Node.constructor} baseClass - The class definition.
      * @param {WeakMap<Node.constructor, Node.constructor>} library - The type library.
      */
-    addClass(nodeClass, baseClass, library) {
+    addClass<TNodeClass, TBaseClass extends object>(
+        nodeClass: TNodeClass,
+        baseClass: TBaseClass,
+        library: WeakMap<TBaseClass, TNodeClass>,
+    ) {
         if (library.has(baseClass)) {
             warn(`Redefinition of node ${baseClass.name}`);
             return;
diff --git a/src-testing/src/renderers/common/nodes/NodeUniform.ts b/src-testing/src/renderers/common/nodes/NodeUniform.ts
index 81d9f2ce..f4c0431c 100644
--- a/src-testing/src/renderers/common/nodes/NodeUniform.ts
+++ b/src-testing/src/renderers/common/nodes/NodeUniform.ts
@@ -8,6 +8,14 @@ import {
     Matrix3Uniform,
     Matrix4Uniform,
 } from '../Uniform.js';
+import NodeUniform from '../../../nodes/core/NodeUniform.js';
+import { Vector2 } from '../../../math/Vector2.js';
+import { Vector3 } from '../../../math/Vector3.js';
+import { Vector4 } from '../../../math/Vector4.js';
+import { Color } from '../../../math/Color.js';
+import { Matrix2 } from '../../../math/Matrix2.js';
+import { Matrix3 } from '../../../math/Matrix3.js';
+import { Matrix4 } from '../../../math/Matrix4.js';
 
 /**
  * A special form of Number uniform binding type.
@@ -17,12 +25,14 @@ import {
  * @augments NumberUniform
  */
 class NumberNodeUniform extends NumberUniform {
+    nodeUniform: NodeUniform<number>;
+
     /**
      * Constructs a new node-based Number uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<number>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -60,12 +70,14 @@ class NumberNodeUniform extends NumberUniform {
  * @augments Vector2Uniform
  */
 class Vector2NodeUniform extends Vector2Uniform {
+    nodeUniform: NodeUniform<Vector2>;
+
     /**
      * Constructs a new node-based Vector2 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<Vector2>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -103,12 +115,14 @@ class Vector2NodeUniform extends Vector2Uniform {
  * @augments Vector3Uniform
  */
 class Vector3NodeUniform extends Vector3Uniform {
+    nodeUniform: NodeUniform<Vector3>;
+
     /**
      * Constructs a new node-based Vector3 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<Vector3>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -146,12 +160,14 @@ class Vector3NodeUniform extends Vector3Uniform {
  * @augments Vector4Uniform
  */
 class Vector4NodeUniform extends Vector4Uniform {
+    nodeUniform: NodeUniform<Vector4>;
+
     /**
      * Constructs a new node-based Vector4 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<Vector4>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -189,12 +205,14 @@ class Vector4NodeUniform extends Vector4Uniform {
  * @augments ColorUniform
  */
 class ColorNodeUniform extends ColorUniform {
+    nodeUniform: NodeUniform<Color>;
+
     /**
      * Constructs a new node-based Color uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<Color>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -232,12 +250,14 @@ class ColorNodeUniform extends ColorUniform {
  * @augments Matrix2Uniform
  */
 class Matrix2NodeUniform extends Matrix2Uniform {
+    nodeUniform: NodeUniform<Matrix2>;
+
     /**
      * Constructs a new node-based Matrix2 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<Matrix2>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -275,12 +295,14 @@ class Matrix2NodeUniform extends Matrix2Uniform {
  * @augments Matrix3Uniform
  */
 class Matrix3NodeUniform extends Matrix3Uniform {
+    nodeUniform: NodeUniform<Matrix3>;
+
     /**
      * Constructs a new node-based Matrix3 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<Matrix3>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -318,12 +340,14 @@ class Matrix3NodeUniform extends Matrix3Uniform {
  * @augments Matrix4Uniform
  */
 class Matrix4NodeUniform extends Matrix4Uniform {
+    nodeUniform: NodeUniform<Matrix4>;
+
     /**
      * Constructs a new node-based Matrix4 uniform.
      *
      * @param {NodeUniform} nodeUniform - The node uniform.
      */
-    constructor(nodeUniform) {
+    constructor(nodeUniform: NodeUniform<Matrix4>) {
         super(nodeUniform.name, nodeUniform.value);
 
         /**
@@ -363,3 +387,11 @@ export {
     Matrix3NodeUniform,
     Matrix4NodeUniform,
 };
+export type NodeUniformGPU =
+    | NumberNodeUniform
+    | Vector2NodeUniform
+    | Vector3NodeUniform
+    | Vector4NodeUniform
+    | ColorNodeUniform
+    | Matrix3NodeUniform
+    | Matrix4NodeUniform;
diff --git a/src-testing/src/renderers/common/nodes/NodeUniformsGroup.ts b/src-testing/src/renderers/common/nodes/NodeUniformsGroup.ts
index 19a8dd2a..26f39bf2 100644
--- a/src-testing/src/renderers/common/nodes/NodeUniformsGroup.ts
+++ b/src-testing/src/renderers/common/nodes/NodeUniformsGroup.ts
@@ -1,4 +1,5 @@
 import UniformsGroup from '../UniformsGroup.js';
+import { UniformGroupNode, UniformNode } from '../../../nodes/Nodes.js';
 
 let _id = 0;
 
@@ -10,13 +11,18 @@ let _id = 0;
  * @augments UniformsGroup
  */
 class NodeUniformsGroup extends UniformsGroup {
+    id: number;
+    groupNode: UniformGroupNode;
+
+    readonly isNodeUniformsGroup: true;
+
     /**
      * Constructs a new node-based uniforms group.
      *
      * @param {string} name - The group's name.
      * @param {UniformGroupNode} groupNode - The uniform group node.
      */
-    constructor(name, groupNode) {
+    constructor(name: string, groupNode: UniformGroupNode) {
         super(name);
 
         /**
diff --git a/src-testing/src/renderers/common/nodes/Nodes.ts b/src-testing/src/renderers/common/nodes/Nodes.ts
index 34f4121f..0c7b983e 100644
--- a/src-testing/src/renderers/common/nodes/Nodes.ts
+++ b/src-testing/src/renderers/common/nodes/Nodes.ts
@@ -28,10 +28,63 @@ import {
 } from '../../../constants.js';
 import { hashArray } from '../../../nodes/core/NodeUtils.js';
 import { error } from '../../../utils.js';
+import { Color } from '../../../math/Color.js';
+import { Texture } from '../../../textures/Texture.js';
+import { CubeTexture } from '../../../textures/CubeTexture.js';
+import { Fog } from '../../../scenes/Fog.js';
+import { FogExp2 } from '../../../scenes/FogExp2.js';
+import NodeUniformsGroup from './NodeUniformsGroup.js';
+import RenderObject from '../RenderObject.js';
+import { Scene } from '../../../scenes/Scene.js';
+import Renderer from '../Renderer.js';
+import Backend from '../Backend.js';
+import { Object3D } from '../../../core/Object3D.js';
+import { Camera } from '../../../cameras/Camera.js';
+import { Material } from '../../../materials/Material.js';
+import Node from '../../../nodes/core/Node.js';
+import ComputeNode from '../../../nodes/gpgpu/ComputeNode.js';
+import LightsNode from '../../../nodes/lighting/LightsNode.js';
+import UniformGroupNode from '../../../nodes/core/UniformGroupNode.js';
+import NodeBuilder from '../../../nodes/core/NodeBuilder.js';
+
+interface NodeUniformsGroupData {
+    renderId?: number | undefined;
+    frameId?: number | undefined;
+}
+
+interface RenderObjectData {
+    nodeBuilderState?: NodeBuilderState | undefined;
+}
+
+interface ComputeNodeData {
+    nodeBuilderState?: NodeBuilderState | undefined;
+}
+
+interface SceneData {
+    background?: Color | Texture | CubeTexture | undefined;
+    backgroundNode?: Node | undefined;
+    fog?: Fog | FogExp2 | undefined;
+    fogNode?: Node | undefined;
+    environment?: Texture | undefined;
+    environmentNode?: Node | undefined;
+}
+
+interface CacheKeyData {
+    callId: number;
+    cacheKey: number;
+}
+
+declare module '../../../scenes/Scene.js' {
+    interface Scene {
+        environmentNode?: Node | null | undefined;
+        backgroundNode?: Node | null | undefined;
+        fogNode?: Node | null | undefined;
+    }
+}
 
 const _outputNodeMap = new WeakMap();
-const _chainKeys = [];
-const _cacheKeyValues = [];
+const _chainKeys = [] as unknown as [UniformGroupNode, NodeUniformsGroup] | [Scene, LightsNode];
+const _cacheKeyValues: number[] = [];
 
 /**
  * This renderer module manages node-related objects and is the
@@ -40,14 +93,27 @@ const _cacheKeyValues = [];
  * @private
  * @augments DataMap
  */
-class Nodes extends DataMap {
+class Nodes extends DataMap<{
     /**
      * Constructs a new nodes management component.
      *
      * @param {Renderer} renderer - The renderer.
      * @param {Backend} backend - The renderer's backend.
      */
-    constructor(renderer, backend) {
+    nodeUniformsGroup: { key: NodeUniformsGroup; value: NodeUniformsGroupData };
+    renderObject: { key: RenderObject; value: RenderObjectData };
+    computeNode: { key: ComputeNode; value: ComputeNodeData };
+    scene: { key: Scene; value: SceneData };
+}> {
+    renderer: Renderer;
+    backend: Backend;
+    nodeFrame: NodeFrame;
+    nodeBuilderCache: Map<string, NodeBuilderState>;
+    callHashCache: ChainMap<readonly [Scene, LightsNode], CacheKeyData>;
+    groupsData: ChainMap<readonly [UniformGroupNode, NodeUniformsGroup], { version?: number }>;
+    cacheLib: { [type: string]: WeakMap<object, Node | undefined> };
+
+    constructor(renderer: Renderer, backend: Backend) {
         super();
 
         /**
@@ -107,7 +173,7 @@ class Nodes extends DataMap {
      * @param {NodeUniformsGroup} nodeUniformsGroup - The node uniforms group.
      * @return {boolean} Whether the node uniforms group requires an update or not.
      */
-    updateGroup(nodeUniformsGroup) {
+    updateGroup(nodeUniformsGroup: NodeUniformsGroup) {
         const groupNode = nodeUniformsGroup.groupNode;
         const name = groupNode.name;
 
@@ -170,7 +236,7 @@ class Nodes extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {number} The cache key.
      */
-    getForRenderCacheKey(renderObject) {
+    getForRenderCacheKey(renderObject: RenderObject) {
         return renderObject.initialCacheKey;
     }
 
@@ -180,7 +246,7 @@ class Nodes extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {NodeBuilderState} The node builder state.
      */
-    getForRender(renderObject) {
+    getForRender(renderObject: RenderObject) {
         const renderObjectData = this.get(renderObject);
 
         let nodeBuilderState = renderObjectData.nodeBuilderState;
@@ -242,13 +308,13 @@ class Nodes extends DataMap {
      * @param {any} object - The object to delete.
      * @return {?Object} The deleted dictionary.
      */
-    delete(object) {
-        if (object.isRenderObject) {
-            const nodeBuilderState = this.get(object).nodeBuilderState;
+    delete(object: NodeUniformsGroup | RenderObject | ComputeNode | Scene) {
+        if ((object as RenderObject).isRenderObject) {
+            const nodeBuilderState = this.get(object as RenderObject).nodeBuilderState!;
             nodeBuilderState.usedTimes--;
 
             if (nodeBuilderState.usedTimes === 0) {
-                this.nodeBuilderCache.delete(this.getForRenderCacheKey(object));
+                this.nodeBuilderCache.delete(this.getForRenderCacheKey(object as RenderObject));
             }
         }
 
@@ -261,7 +327,7 @@ class Nodes extends DataMap {
      * @param {Node} computeNode - The compute node.
      * @return {NodeBuilderState} The node builder state.
      */
-    getForCompute(computeNode) {
+    getForCompute(computeNode: ComputeNode) {
         const computeData = this.get(computeNode);
 
         let nodeBuilderState = computeData.nodeBuilderState;
@@ -285,7 +351,7 @@ class Nodes extends DataMap {
      * @param {NodeBuilder} nodeBuilder - The node builder.
      * @return {NodeBuilderState} The node builder state.
      */
-    _createNodeBuilderState(nodeBuilder) {
+    _createNodeBuilderState(nodeBuilder: NodeBuilder) {
         return new NodeBuilderState(
             nodeBuilder.vertexShader,
             nodeBuilder.fragmentShader,
@@ -307,9 +373,8 @@ class Nodes extends DataMap {
      * @param {Scene} scene - The scene.
      * @return {Node} A node representing the current scene environment.
      */
-    getEnvironmentNode(scene) {
+    getEnvironmentNode(scene: Scene) {
         this.updateEnvironment(scene);
-
         let environmentNode = null;
 
         if (scene.environmentNode && scene.environmentNode.isNode) {
@@ -332,9 +397,8 @@ class Nodes extends DataMap {
      * @param {Scene} scene - The scene.
      * @return {Node} A node representing the current scene background.
      */
-    getBackgroundNode(scene) {
+    getBackgroundNode(scene: Scene) {
         this.updateBackground(scene);
-
         let backgroundNode = null;
 
         if (scene.backgroundNode && scene.backgroundNode.isNode) {
@@ -356,9 +420,8 @@ class Nodes extends DataMap {
      * @param {Scene} scene - The scene.
      * @return {Node} A node representing the current scene fog.
      */
-    getFogNode(scene) {
+    getFogNode(scene: Scene) {
         this.updateFog(scene);
-
         return scene.fogNode || this.get(scene).fogNode || null;
     }
 
@@ -372,13 +435,13 @@ class Nodes extends DataMap {
      * @param {LightsNode} lightsNode - The lights node.
      * @return {number} The cache key.
      */
-    getCacheKey(scene, lightsNode) {
+    getCacheKey(scene: Scene, lightsNode: LightsNode) {
         _chainKeys[0] = scene;
         _chainKeys[1] = lightsNode;
 
         const callId = this.renderer.info.calls;
 
-        const cacheKeyData = this.callHashCache.get(_chainKeys) || {};
+        const cacheKeyData = this.callHashCache.get(_chainKeys as readonly [Scene, LightsNode]) || ({} as CacheKeyData);
 
         if (cacheKeyData.callId !== callId) {
             const environmentNode = this.getEnvironmentNode(scene);
@@ -397,7 +460,7 @@ class Nodes extends DataMap {
             cacheKeyData.callId = callId;
             cacheKeyData.cacheKey = hashArray(_cacheKeyValues);
 
-            this.callHashCache.set(_chainKeys, cacheKeyData);
+            this.callHashCache.set(_chainKeys as readonly [Scene, LightsNode], cacheKeyData);
 
             _cacheKeyValues.length = 0;
         }
@@ -423,7 +486,7 @@ class Nodes extends DataMap {
      *
      * @param {Scene} scene - The scene.
      */
-    updateBackground(scene) {
+    updateBackground(scene: Scene) {
         const sceneData = this.get(scene);
         const background = scene.background;
 
@@ -438,7 +501,7 @@ class Nodes extends DataMap {
                     background,
                     () => {
                         if (
-                            background.isCubeTexture === true ||
+                            (background as CubeTexture).isCubeTexture === true ||
                             background.mapping === EquirectangularReflectionMapping ||
                             background.mapping === EquirectangularRefractionMapping ||
                             background.mapping === CubeUVReflectionMapping
@@ -448,18 +511,18 @@ class Nodes extends DataMap {
                             } else {
                                 let envMap;
 
-                                if (background.isCubeTexture === true) {
-                                    envMap = cubeTexture(background);
+                                if ((background as CubeTexture).isCubeTexture === true) {
+                                    envMap = cubeTexture(background as CubeTexture);
                                 } else {
                                     envMap = texture(background);
                                 }
 
                                 return cubeMapNode(envMap);
                             }
-                        } else if (background.isTexture === true) {
-                            return texture(background, screenUV.flipY()).setUpdateMatrix(true);
-                        } else if (background.isColor !== true) {
-                            error('WebGPUNodes: Unsupported background configuration.', background);
+                        } else if ((background as Texture).isTexture === true) {
+                            return texture(background as Texture, screenUV.flipY()).setUpdateMatrix(true);
+                        } else if ((background as Color).isColor !== true) {
+                            error('WebGPUNodes: Unsupported background configuration.', background as Color);
                         }
                     },
                     forceUpdate,
@@ -485,7 +548,7 @@ class Nodes extends DataMap {
      * @param {boolean} [forceUpdate=false] - Whether an update should be enforced or not.
      * @return {Node} The node representation.
      */
-    getCacheNode(type, object, callback, forceUpdate = false) {
+    getCacheNode(type: string, object: object, callback: () => Node | undefined, forceUpdate = false) {
         const nodeCache = this.cacheLib[type] || (this.cacheLib[type] = new WeakMap());
 
         let node = nodeCache.get(object);
@@ -504,22 +567,22 @@ class Nodes extends DataMap {
      *
      * @param {Scene} scene - The scene.
      */
-    updateFog(scene) {
+    updateFog(scene: Scene) {
         const sceneData = this.get(scene);
         const sceneFog = scene.fog;
 
         if (sceneFog) {
             if (sceneData.fog !== sceneFog) {
                 const fogNode = this.getCacheNode('fog', sceneFog, () => {
-                    if (sceneFog.isFogExp2) {
-                        const color = reference('color', 'color', sceneFog).setGroup(renderGroup);
-                        const density = reference('density', 'float', sceneFog).setGroup(renderGroup);
+                    if ((sceneFog as FogExp2).isFogExp2) {
+                        const color = reference('color', 'color', sceneFog as FogExp2).setGroup(renderGroup);
+                        const density = reference('density', 'float', sceneFog as FogExp2).setGroup(renderGroup);
 
                         return fog(color, densityFogFactor(density));
-                    } else if (sceneFog.isFog) {
-                        const color = reference('color', 'color', sceneFog).setGroup(renderGroup);
-                        const near = reference('near', 'float', sceneFog).setGroup(renderGroup);
-                        const far = reference('far', 'float', sceneFog).setGroup(renderGroup);
+                    } else if ((sceneFog as Fog).isFog) {
+                        const color = reference('color', 'color', sceneFog as Fog).setGroup(renderGroup);
+                        const near = reference('near', 'float', sceneFog as Fog).setGroup(renderGroup);
+                        const far = reference('far', 'float', sceneFog as Fog).setGroup(renderGroup);
 
                         return fog(color, rangeFogFactor(near, far));
                     } else {
@@ -542,14 +605,14 @@ class Nodes extends DataMap {
      *
      * @param {Scene} scene - The scene.
      */
-    updateEnvironment(scene) {
+    updateEnvironment(scene: Scene) {
         const sceneData = this.get(scene);
         const environment = scene.environment;
 
         if (environment) {
             if (sceneData.environment !== environment) {
                 const environmentNode = this.getCacheNode('environment', environment, () => {
-                    if (environment.isCubeTexture === true) {
+                    if ((environment as CubeTexture).isCubeTexture === true) {
                         return cubeTexture(environment);
                     } else if (environment.isTexture === true) {
                         return texture(environment);
@@ -567,7 +630,13 @@ class Nodes extends DataMap {
         }
     }
 
-    getNodeFrame(renderer = this.renderer, scene = null, object = null, camera = null, material = null) {
+    getNodeFrame(
+        renderer = this.renderer,
+        scene: Scene | null = null,
+        object: Object3D | null = null,
+        camera: Camera | null = null,
+        material: Material | null = null,
+    ) {
         const nodeFrame = this.nodeFrame;
         nodeFrame.renderer = renderer;
         nodeFrame.scene = scene;
@@ -578,7 +647,7 @@ class Nodes extends DataMap {
         return nodeFrame;
     }
 
-    getNodeFrameForRender(renderObject) {
+    getNodeFrameForRender(renderObject: RenderObject) {
         return this.getNodeFrame(
             renderObject.renderer,
             renderObject.scene,
@@ -606,7 +675,7 @@ class Nodes extends DataMap {
      * @param {Texture} outputTarget - The output target.
      * @return {boolean} Whether the output configuration has changed or not.
      */
-    hasOutputChange(outputTarget) {
+    hasOutputChange(outputTarget: Texture) {
         const cacheKey = _outputNodeMap.get(outputTarget);
 
         return cacheKey !== this.getOutputCacheKey();
@@ -619,11 +688,11 @@ class Nodes extends DataMap {
      * @param {Texture} outputTarget - The output target.
      * @return {Node} The output node.
      */
-    getOutputNode(outputTarget) {
+    getOutputNode(outputTarget: Texture) {
         const renderer = this.renderer;
         const cacheKey = this.getOutputCacheKey();
 
-        const output = outputTarget.isArrayTexture
+        const output: Node = outputTarget.isArrayTexture
             ? texture3D(outputTarget, vec3(screenUV, builtin('gl_ViewID_OVR'))).renderOutput(
                   renderer.toneMapping,
                   renderer.currentColorSpace,
@@ -641,7 +710,7 @@ class Nodes extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateBefore(renderObject) {
+    updateBefore(renderObject: RenderObject) {
         const nodeBuilder = renderObject.getNodeBuilderState();
 
         for (const node of nodeBuilder.updateBeforeNodes) {
@@ -657,7 +726,7 @@ class Nodes extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateAfter(renderObject) {
+    updateAfter(renderObject: RenderObject) {
         const nodeBuilder = renderObject.getNodeBuilderState();
 
         for (const node of nodeBuilder.updateAfterNodes) {
@@ -673,7 +742,7 @@ class Nodes extends DataMap {
      *
      * @param {Node} computeNode - The compute node.
      */
-    updateForCompute(computeNode) {
+    updateForCompute(computeNode: ComputeNode) {
         const nodeFrame = this.getNodeFrame();
         const nodeBuilder = this.getForCompute(computeNode);
 
@@ -688,7 +757,7 @@ class Nodes extends DataMap {
      *
      * @param {RenderObject} renderObject - The render object.
      */
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         const nodeFrame = this.getNodeFrameForRender(renderObject);
         const nodeBuilder = renderObject.getNodeBuilderState();
 
@@ -703,7 +772,7 @@ class Nodes extends DataMap {
      * @param {RenderObject} renderObject - The render object.
      * @return {boolean} Whether the given render object requires a refresh or not.
      */
-    needsRefresh(renderObject) {
+    needsRefresh(renderObject: RenderObject) {
         const nodeFrame = this.getNodeFrameForRender(renderObject);
         const monitor = renderObject.getMonitor();
 
diff --git a/src-testing/src/renderers/webgl-fallback/WebGLBackend.ts b/src-testing/src/renderers/webgl-fallback/WebGLBackend.ts
index d429693b..35f109ae 100644
--- a/src-testing/src/renderers/webgl-fallback/WebGLBackend.ts
+++ b/src-testing/src/renderers/webgl-fallback/WebGLBackend.ts
@@ -14,6 +14,7 @@ import { WebGLBufferRenderer } from './WebGLBufferRenderer.js';
 import { isTypedArray, warnOnce, warn, error } from '../../utils.js';
 import { WebGLCoordinateSystem, TimestampQuery } from '../../constants.js';
 import WebGLTimestampQueryPool from './utils/WebGLTimestampQueryPool.js';
+import { Texture } from '../../textures/Texture.js';
 
 /**
  * A backend implementation targeting WebGL 2.
@@ -1129,7 +1130,14 @@ class WebGLBackend extends Backend {
      * @param {number} faceIndex - The face index.
      * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
      */
-    async copyTextureToBuffer(texture, x, y, width, height, faceIndex) {
+    async copyTextureToBuffer(
+        texture: Texture,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+        faceIndex: number,
+    ) {
         return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);
     }
 
diff --git a/src-testing/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.ts b/src-testing/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.ts
index ff0221a3..30cee25a 100644
--- a/src-testing/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.ts
+++ b/src-testing/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.ts
@@ -1,4 +1,11 @@
-import { GLSLNodeParser, NodeBuilder, TextureNode, vectorComponents, CodeNode } from '../../../nodes/Nodes.js';
+import {
+    GLSLNodeParser,
+    NodeBuilder,
+    NodeShaderStage,
+    TextureNode,
+    vectorComponents,
+    CodeNode,
+} from '../../../nodes/Nodes.js';
 
 import NodeUniformBuffer from '../../common/nodes/NodeUniformBuffer.js';
 import NodeUniformsGroup from '../../common/nodes/NodeUniformsGroup.js';
@@ -29,6 +36,17 @@ import {
 } from '../../../constants.js';
 import { DataTexture } from '../../../textures/DataTexture.js';
 import { error } from '../../../utils.js';
+import Renderer from '../../common/Renderer.js';
+import StructTypeNode from '../../../nodes/core/StructTypeNode.js';
+import BufferAttributeNode from '../../../nodes/accessors/BufferAttributeNode.js';
+import UniformNode from '../../../nodes/core/UniformNode.js';
+import { Object3D } from '../../../core/Object3D.js';
+import { Texture } from '../../../textures/Texture.js';
+import { BufferAttribute } from '../../../core/BufferAttribute.js';
+import { InterleavedBufferAttribute } from '../../../core/InterleavedBufferAttribute.js';
+import { ShaderNodeInternal } from '../../../nodes/tsl/TSLCore.js';
+import StorageBufferNode from '../../../nodes/accessors/StorageBufferNode.js';
+import StorageArrayElementNode from '../../../nodes/utils/StorageArrayElementNode.js';
 
 const glslPolyfills = {
     bitcast_int_uint: new CodeNode(
@@ -39,7 +57,7 @@ const glslPolyfills = {
     ),
 };
 
-const glslMethods = {
+const glslMethods: { [method: string]: string } = {
     textureDimensions: 'textureSize',
     equals: 'equal',
     bitcast_float_int: 'floatBitsToInt',
@@ -93,6 +111,23 @@ precision lowp sampler2DArrayShadow;
 precision lowp samplerCubeShadow;
 `;
 
+export interface Transform {
+    varyingName: string | null | undefined;
+    attributeNode: BufferAttributeNode;
+}
+
+interface StageData {
+    extensions?: string | undefined;
+    uniforms?: string | undefined;
+    attributes?: string | undefined;
+    varyings?: string | undefined;
+    vars?: string | undefined;
+    structs?: string | undefined;
+    codes?: string | undefined;
+    transforms?: string | undefined;
+    flow?: string | undefined;
+}
+
 /**
  * A node builder targeting GLSL.
  *
@@ -104,13 +139,25 @@ precision lowp samplerCubeShadow;
  * @augments NodeBuilder
  */
 class GLSLNodeBuilder extends NodeBuilder {
+    uniformGroups: {
+        vertex?: { [groupName: string]: NodeUniformsGroup | undefined };
+        fragment?: { [groupName: string]: NodeUniformsGroup | undefined };
+        compute?: { [groupName: string]: NodeUniformsGroup | undefined };
+    };
+    transforms: Transform[];
+    extensions: {
+        vertex?: Map<string, string>;
+        fragment?: Map<string, string>;
+        compute?: Map<string, string>;
+    };
+
     /**
      * Constructs a new GLSL node builder renderer.
      *
      * @param {Object3D} object - The 3D object.
      * @param {Renderer} renderer - The renderer.
      */
-    constructor(object, renderer) {
+    constructor(object: Object3D, renderer: Renderer) {
         super(object, renderer, new GLSLNodeParser());
 
         /**
@@ -177,11 +224,10 @@ class GLSLNodeBuilder extends NodeBuilder {
      * @param {string} method - The method name to resolve.
      * @return {string} The resolved GLSL method name.
      */
-    getMethod(method) {
+    getMethod(method: string) {
         if (glslPolyfills[method] !== undefined) {
             this._include(method);
         }
-
         return glslMethods[method] || method;
     }
 
@@ -223,7 +269,7 @@ class GLSLNodeBuilder extends NodeBuilder {
      * @param {ShaderNodeInternal} shaderNode - The shader node.
      * @return {string} The GLSL function code.
      */
-    buildFunctionCode(shaderNode) {
+    buildFunctionCode(shaderNode: ShaderNodeInternal) {
         const layout = shaderNode.layout;
         const flowData = this.flowShaderNode(shaderNode);
 
@@ -255,7 +301,7 @@ ${flowData.code}
      *
      * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
      */
-    setupPBO(storageBufferNode) {
+    setupPBO(storageBufferNode: StorageBufferNode) {
         const attribute = storageBufferNode.value;
 
         if (attribute.pbo === undefined) {
@@ -326,7 +372,7 @@ ${flowData.code}
      * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
      * @return {string} The property name.
      */
-    getPropertyName(node, shaderStage = this.shaderStage) {
+    getPropertyName(node: unknown, shaderStage = this.shaderStage) {
         if (node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true) {
             return shaderStage.charAt(0) + '_' + node.name;
         }
@@ -341,7 +387,7 @@ ${flowData.code}
      * @param {StorageArrayElementNode} storageArrayElementNode - The storage array element node.
      * @return {string} The property name.
      */
-    generatePBO(storageArrayElementNode) {
+    generatePBO(storageArrayElementNode: StorageArrayElementNode) {
         const { node, indexNode } = storageArrayElementNode;
         const attribute = node.value;
 
@@ -429,7 +475,14 @@ ${flowData.code}
      * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
      * @return {string} The GLSL snippet.
      */
-    generateTextureLoad(texture, textureProperty, uvIndexSnippet, levelSnippet, depthSnippet, offsetSnippet) {
+    generateTextureLoad(
+        texture: Texture | null,
+        textureProperty: string | undefined,
+        uvIndexSnippet: string,
+        depthSnippet: string | null,
+        offsetSnippet: string,
+        levelSnippet = '0',
+    ) {
         if (levelSnippet === null) levelSnippet = '0';
 
         let snippet;
@@ -465,9 +518,14 @@ ${flowData.code}
      * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
      * @return {string} The GLSL snippet.
      */
-    generateTexture(texture, textureProperty, uvSnippet, depthSnippet, offsetSnippet) {
+    generateTexture(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string,
+        depthSnippet: string | null,
+        offsetSnippet: string | null,
+    ) {
         if (depthSnippet) uvSnippet = `vec3( ${uvSnippet}, ${depthSnippet} )`;
-
         if (texture.isDepthTexture) {
             if (offsetSnippet) return `textureOffset( ${textureProperty}, ${uvSnippet}, ${offsetSnippet} ).x`;
 
@@ -489,7 +547,13 @@ ${flowData.code}
      * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
      * @return {string} The GLSL snippet.
      */
-    generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, offsetSnippet) {
+    generateTextureLevel(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string,
+        levelSnippet: string,
+        offsetSnippet: string | null,
+    ) {
         if (offsetSnippet) {
             return `textureLodOffset( ${textureProperty}, ${uvSnippet}, ${levelSnippet}, ${offsetSnippet} )`;
         }
@@ -507,7 +571,13 @@ ${flowData.code}
      * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
      * @return {string} The GLSL snippet.
      */
-    generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet, offsetSnippet) {
+    generateTextureBias(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string,
+        biasSnippet: string,
+        offsetSnippet: string | null,
+    ) {
         if (offsetSnippet) {
             return `textureOffset( ${textureProperty}, ${uvSnippet}, ${offsetSnippet}, ${biasSnippet} )`;
         }
@@ -525,7 +595,13 @@ ${flowData.code}
      * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
      * @return {string} The GLSL snippet.
      */
-    generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, offsetSnippet) {
+    generateTextureGrad(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string,
+        gradSnippet: [string, string] | null,
+        offsetSnippet: string | null,
+    ) {
         if (offsetSnippet) {
             return `textureGradOffset( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]}, ${offsetSnippet} )`;
         }
@@ -547,11 +623,11 @@ ${flowData.code}
      * @return {string} The GLSL snippet.
      */
     generateTextureCompare(
-        texture,
-        textureProperty,
-        uvSnippet,
-        compareSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        compareSnippet: string | null,
+        depthSnippet: string | null,
         offsetSnippet,
         shaderStage = this.shaderStage,
     ) {
@@ -571,6 +647,7 @@ ${flowData.code}
             return `texture( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ) )`;
         } else {
             error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);
+            return undefined as unknown as string;
         }
     }
 
@@ -580,8 +657,8 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the variables.
      */
-    getVars(shaderStage) {
-        const snippets = [];
+    getVars(shaderStage: 'vertex' | 'fragment' | 'compute') {
+        const snippets: string[] = [];
 
         const vars = this.vars[shaderStage];
 
@@ -600,7 +677,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the uniforms.
      */
-    getUniforms(shaderStage) {
+    getUniforms(shaderStage: 'vertex' | 'fragment' | 'compute') {
         const uniforms = this.uniforms[shaderStage];
 
         const bindingSnippets = [];
@@ -696,7 +773,7 @@ ${flowData.code}
      * @param {BufferAttribute} attribute - The buffer attribute.
      * @return {string} The type.
      */
-    getTypeFromAttribute(attribute) {
+    getTypeFromAttribute(attribute: BufferAttribute | InterleavedBufferAttribute) {
         let nodeType = super.getTypeFromAttribute(attribute);
 
         if (/^[iu]/.test(nodeType) && attribute.gpuType !== IntType) {
@@ -720,7 +797,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the shader attributes.
      */
-    getAttributes(shaderStage) {
+    getAttributes(shaderStage: NodeShaderStage) {
         let snippet = '';
 
         if (shaderStage === 'vertex' || shaderStage === 'compute') {
@@ -742,8 +819,8 @@ ${flowData.code}
      * @param {StructTypeNode} struct - The struct type node.
      * @return {string} The GLSL snippet that defines the struct members.
      */
-    getStructMembers(struct) {
-        const snippets = [];
+    getStructMembers(struct: StructTypeNode) {
+        const snippets: string[] = [];
 
         for (const member of struct.members) {
             snippets.push(`\t${member.type} ${member.name};`);
@@ -758,7 +835,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the structs.
      */
-    getStructs(shaderStage) {
+    getStructs(shaderStage: NodeShaderStage) {
         const snippets = [];
         const structs = this.structs[shaderStage];
 
@@ -791,7 +868,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the varyings.
      */
-    getVaryings(shaderStage) {
+    getVaryings(shaderStage: NodeShaderStage) {
         let snippet = '';
 
         const varyings = this.varyings;
@@ -947,7 +1024,7 @@ ${flowData.code}
      * @param {string} behavior - The extension behavior.
      * @param {string} [shaderStage=this.shaderStage] - The shader stage.
      */
-    enableExtension(name, behavior, shaderStage = this.shaderStage) {
+    enableExtension(name: string, behavior: string, shaderStage = this.shaderStage!) {
         const map = this.extensions[shaderStage] || (this.extensions[shaderStage] = new Map());
 
         if (map.has(name) === false) {
@@ -964,7 +1041,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the enabled extensions.
      */
-    getExtensions(shaderStage) {
+    getExtensions(shaderStage: NodeShaderStage) {
         const snippets = [];
 
         if (shaderStage === 'vertex') {
@@ -1002,7 +1079,7 @@ ${flowData.code}
      * @param {string} name - The requested feature.
      * @return {boolean} Whether the requested feature is supported or not.
      */
-    isAvailable(name) {
+    isAvailable(name: string) {
         let result = supports[name];
 
         if (result === undefined) {
@@ -1071,7 +1148,7 @@ ${flowData.code}
      * @param {string} varyingName - The varying name.
      * @param {AttributeNode} attributeNode - The attribute node.
      */
-    registerTransform(varyingName, attributeNode) {
+    registerTransform(varyingName: string | null | undefined, attributeNode: BufferAttributeNode) {
         this.transforms.push({ varyingName, attributeNode });
     }
 
@@ -1081,7 +1158,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The GLSL snippet that defines the transforms.
      */
-    getTransforms(/* shaderStage  */) {
+    getTransforms(shaderStage: NodeShaderStage) {
         const transforms = this.transforms;
 
         let snippet = '';
@@ -1104,7 +1181,7 @@ ${flowData.code}
      * @param {string} vars - The struct variables.
      * @return {string} The GLSL snippet representing a struct.
      */
-    _getGLSLUniformStruct(name, vars) {
+    _getGLSLUniformStruct(name: string, vars: string) {
         return `
 layout( std140 ) uniform ${name} {
 ${vars}
@@ -1118,7 +1195,7 @@ ${vars}
      * @param {Object} shaderData - The shader data.
      * @return {string} The vertex shader.
      */
-    _getGLSLVertexCode(shaderData) {
+    _getGLSLVertexCode(shaderData: StageData) {
         return `#version 300 es
 
 ${this.getSignature()}
@@ -1165,7 +1242,7 @@ void main() {
      * @param {Object} shaderData - The shader data.
      * @return {string} The vertex shader.
      */
-    _getGLSLFragmentCode(shaderData) {
+    _getGLSLFragmentCode(shaderData: StageData) {
         return `#version 300 es
 
 ${this.getSignature()}
@@ -1204,19 +1281,20 @@ void main() {
      * Controls the code build of the shader stages.
      */
     buildCode() {
-        const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
+        const shadersData: { fragment?: StageData; vertex?: StageData; compute?: StageData } =
+            this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
 
         this.sortBindingGroups();
 
         for (const shaderStage in shadersData) {
             let flow = '// code\n\n';
-            flow += this.flowCode[shaderStage];
+            flow += this.flowCode[shaderStage as NodeShaderStage];
 
-            const flowNodes = this.flowNodes[shaderStage];
+            const flowNodes = this.flowNodes[shaderStage as NodeShaderStage];
             const mainNode = flowNodes[flowNodes.length - 1];
 
             for (const node of flowNodes) {
-                const flowSlotData = this.getFlowData(node /*, shaderStage*/);
+                const flowSlotData = this.getFlowData(node /*, shaderStage*/)!;
                 const slotName = node.name;
 
                 if (slotName) {
@@ -1242,24 +1320,24 @@ void main() {
                 }
             }
 
-            const stageData = shadersData[shaderStage];
+            const stageData = shadersData[shaderStage as NodeShaderStage]!;
 
-            stageData.extensions = this.getExtensions(shaderStage);
-            stageData.uniforms = this.getUniforms(shaderStage);
-            stageData.attributes = this.getAttributes(shaderStage);
-            stageData.varyings = this.getVaryings(shaderStage);
-            stageData.vars = this.getVars(shaderStage);
-            stageData.structs = this.getStructs(shaderStage);
-            stageData.codes = this.getCodes(shaderStage);
-            stageData.transforms = this.getTransforms(shaderStage);
+            stageData.extensions = this.getExtensions(shaderStage as NodeShaderStage);
+            stageData.uniforms = this.getUniforms(shaderStage as NodeShaderStage);
+            stageData.attributes = this.getAttributes(shaderStage as NodeShaderStage);
+            stageData.varyings = this.getVaryings(shaderStage as NodeShaderStage);
+            stageData.vars = this.getVars(shaderStage as NodeShaderStage);
+            stageData.structs = this.getStructs(shaderStage as NodeShaderStage);
+            stageData.codes = this.getCodes(shaderStage as NodeShaderStage);
+            stageData.transforms = this.getTransforms(shaderStage as NodeShaderStage);
             stageData.flow = flow;
         }
 
         if (this.material !== null) {
-            this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);
-            this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);
+            this.vertexShader = this._getGLSLVertexCode(shadersData.vertex!);
+            this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment!);
         } else {
-            this.computeShader = this._getGLSLVertexCode(shadersData.compute);
+            this.computeShader = this._getGLSLVertexCode(shadersData.compute!);
         }
     }
 
@@ -1276,7 +1354,12 @@ void main() {
      * @param {?string} [name=null] - An optional uniform name.
      * @return {NodeUniform} The node uniform object.
      */
-    getUniformFromNode(node, type, shaderStage, name = null) {
+    getUniformFromNode(
+        node: UniformNode<unknown>,
+        type: string | null,
+        shaderStage: 'vertex' | 'fragment' | 'compute',
+        name: string | null = null,
+    ) {
         const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
diff --git a/src-testing/src/renderers/webgpu/WebGPUBackend.ts b/src-testing/src/renderers/webgpu/WebGPUBackend.ts
index 0a7155b2..24fc21a3 100644
--- a/src-testing/src/renderers/webgpu/WebGPUBackend.ts
+++ b/src-testing/src/renderers/webgpu/WebGPUBackend.ts
@@ -1670,7 +1670,14 @@ class WebGPUBackend extends Backend {
      * @param {number} faceIndex - The face index.
      * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
      */
-    async copyTextureToBuffer(texture, x, y, width, height, faceIndex) {
+    async copyTextureToBuffer(
+        texture: Texture,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+        faceIndex: number,
+    ) {
         return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);
     }
 
diff --git a/src-testing/src/renderers/webgpu/nodes/StandardNodeLibrary.ts b/src-testing/src/renderers/webgpu/nodes/StandardNodeLibrary.ts
index 37784a05..7b08961a 100644
--- a/src-testing/src/renderers/webgpu/nodes/StandardNodeLibrary.ts
+++ b/src-testing/src/renderers/webgpu/nodes/StandardNodeLibrary.ts
@@ -59,6 +59,20 @@ import {
     neutralToneMapping,
 } from '../../../nodes/display/ToneMappingFunctions.js';
 
+import { MeshPhongNodeMaterialNodeProperties } from '../../../materials/nodes/MeshPhongNodeMaterial.js';
+import { MeshStandardNodeMaterialNodeProperties } from '../../../materials/nodes/MeshStandardNodeMaterial.js';
+import { MeshPhysicalNodeMaterialNodeProperties } from '../../../materials/nodes/MeshPhysicalNodeMaterial.js';
+import { MeshToonNodeMaterialNodeProperties } from '../../../materials/nodes/MeshToonNodeMaterial.js';
+import { MeshBasicNodeMaterialNodeProperties } from '../../../materials/nodes/MeshBasicNodeMaterial.js';
+import { MeshLambertNodeMaterialNodeProperties } from '../../../materials/nodes/MeshLambertNodeMaterial.js';
+import { MeshNormalNodeMaterialNodeProperties } from '../../../materials/nodes/MeshNormalNodeMaterial.js';
+import { MeshMatcapNodeMaterialNodeProperties } from '../../../materials/nodes/MeshMatcapNodeMaterial.js';
+import { LineBasicNodeMaterialNodeProperties } from '../../../materials/nodes/LineBasicNodeMaterial.js';
+import { LineDashedNodeMaterialNodeProperties } from '../../../materials/nodes/LineDashedNodeMaterial.js';
+import { PointsNodeMaterialNodeProperties } from '../../../materials/nodes/PointsNodeMaterial.js';
+import { SpriteNodeMaterialNodeProperties } from '../../../materials/nodes/SpriteNodeMaterial.js';
+import { ShadowNodeMaterialNodeProperties } from '../../../materials/nodes/ShadowNodeMaterial.js';
+
 /**
  * This version of a node library represents the standard version
  * used in {@link WebGPURenderer}. It maps lights, tone mapping
@@ -107,4 +121,56 @@ class StandardNodeLibrary extends NodeLibrary {
     }
 }
 
+declare module '../../../materials/MeshPhongMaterial.js' {
+    export interface MeshPhongMaterialProperties extends MeshPhongNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/MeshStandardMaterial.js' {
+    export interface MeshStandardMaterialProperties extends MeshStandardNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/MeshPhysicalMaterial.js' {
+    export interface MeshPhysicalMaterialProperties extends MeshPhysicalNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/MeshToonMaterial.js' {
+    export interface MeshToonMaterialProperties extends MeshToonNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/MeshBasicMaterial.js' {
+    export interface MeshBasicMaterialProperties extends MeshBasicNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/MeshLambertMaterial.js' {
+    export interface MeshLambertMaterialProperties extends MeshLambertNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/MeshNormalMaterial.js' {
+    export interface MeshNormalMaterialProperties extends MeshNormalNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/MeshMatcapMaterial.js' {
+    export interface MeshMatcapMaterialProperties extends MeshMatcapNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/LineBasicMaterial.js' {
+    export interface LineBasicMaterialProperties extends LineBasicNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/LineDashedMaterial.js' {
+    export interface LineDashedMaterialProperties extends LineDashedNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/PointsMaterial.js' {
+    export interface PointsMaterialProperties extends PointsNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/SpriteMaterial.js' {
+    export interface SpriteMaterialProperties extends SpriteNodeMaterialNodeProperties {}
+}
+
+declare module '../../../materials/ShadowMaterial.js' {
+    export interface ShadowMaterialProperties extends ShadowNodeMaterialNodeProperties {}
+}
+
 export default StandardNodeLibrary;
diff --git a/src-testing/src/renderers/webgpu/nodes/WGSLNodeBuilder.ts b/src-testing/src/renderers/webgpu/nodes/WGSLNodeBuilder.ts
index 80532df0..0d1f7e67 100644
--- a/src-testing/src/renderers/webgpu/nodes/WGSLNodeBuilder.ts
+++ b/src-testing/src/renderers/webgpu/nodes/WGSLNodeBuilder.ts
@@ -10,7 +10,7 @@ import {
 import NodeUniformBuffer from '../../common/nodes/NodeUniformBuffer.js';
 import NodeStorageBuffer from '../../common/nodes/NodeStorageBuffer.js';
 
-import { NodeBuilder, CodeNode } from '../../../nodes/Nodes.js';
+import { NodeBuilder, CodeNode, NodeShaderStage, ShaderNodeInternal } from '../../../nodes/Nodes.js';
 
 import { getFormat } from '../utils/WebGPUTextureUtils.js';
 
@@ -28,6 +28,8 @@ import {
     NearestFilter,
 } from '../../../constants.js';
 import { warn, error } from '../../../utils.js';
+import { Texture } from '../../../textures/Texture.js';
+import UniformNode from '../../../nodes/core/UniformNode.js';
 
 import { GPUShaderStage } from '../utils/WebGPUConstants.js';
 
@@ -223,11 +225,11 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @return {string} The WGSL snippet.
      */
     _generateTextureSample(
-        texture,
-        textureProperty,
-        uvSnippet,
-        depthSnippet,
-        offsetSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string,
+        depthSnippet: string | null,
+        offsetSnippet: string | null,
         shaderStage = this.shaderStage,
     ) {
         if (shaderStage === 'fragment') {
@@ -451,7 +453,14 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
      * @return {string} The WGSL snippet.
      */
-    generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, offsetSnippet, levelSnippet = '0u') {
+    generateTextureLod(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string,
+        depthSnippet: string | null,
+        offsetSnippet: string | null,
+        levelSnippet: string = '0u',
+    ) {
         const wrapFunction = this.generateWrapFunction(texture);
         const textureDimension = this.generateTextureDimension(texture, textureProperty, levelSnippet);
 
@@ -477,7 +486,14 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
      * @return {string} The WGSL snippet.
      */
-    generateTextureLoad(texture, textureProperty, uvIndexSnippet, levelSnippet, depthSnippet, offsetSnippet) {
+    generateTextureLoad(
+        texture: Texture,
+        textureProperty: string,
+        uvIndexSnippet: string,
+        depthSnippet: string | null,
+        offsetSnippet: string | null,
+        levelSnippet: string = '0u',
+    ) {
         if (levelSnippet === null) levelSnippet = '0u';
 
         if (offsetSnippet) {
@@ -599,11 +615,11 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @return {string} The WGSL snippet.
      */
     generateTextureGrad(
-        texture,
-        textureProperty,
-        uvSnippet,
-        gradSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        gradSnippet: [string, string] | null,
+        depthSnippet: string | null,
         offsetSnippet,
         shaderStage = this.shaderStage,
     ) {
@@ -633,11 +649,11 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @return {string} The WGSL snippet.
      */
     generateTextureCompare(
-        texture,
-        textureProperty,
-        uvSnippet,
-        compareSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        compareSnippet: string | null,
+        depthSnippet: string | null,
         offsetSnippet,
         shaderStage = this.shaderStage,
     ) {
@@ -672,7 +688,14 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
      * @return {string} The WGSL snippet.
      */
-    generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet) {
+    generateTextureLevel(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string,
+        levelSnippet: string,
+        depthSnippet: string | null,
+        offsetSnippet: string | null,
+    ) {
         if (this.isUnfilterable(texture) === false) {
             if (offsetSnippet) {
                 return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet}, ${offsetSnippet} )`;
@@ -706,11 +729,11 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @return {string} The WGSL snippet.
      */
     generateTextureBias(
-        texture,
-        textureProperty,
-        uvSnippet,
-        biasSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        biasSnippet: string | null,
+        depthSnippet: string | null,
         offsetSnippet,
         shaderStage = this.shaderStage,
     ) {
@@ -732,7 +755,7 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
      * @return {string} The property name.
      */
-    getPropertyName(node, shaderStage = this.shaderStage) {
+    getPropertyName(node: unknown, shaderStage = this.shaderStage) {
         if (node.isNodeVarying === true && node.needsInterpolation === true) {
             if (shaderStage === 'vertex') {
                 return `varyings.${node.name}`;
@@ -829,7 +852,12 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {?string} [name=null] - An optional uniform name.
      * @return {NodeUniform} The node uniform object.
      */
-    getUniformFromNode(node, type, shaderStage, name = null) {
+    getUniformFromNode(
+        node: UniformNode<unknown>,
+        type: string | null,
+        shaderStage: NodeShaderStage,
+        name: string | null = null,
+    ) {
         const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
@@ -974,7 +1002,7 @@ class WGSLNodeBuilder extends NodeBuilder {
      * @param {ShaderNodeInternal} shaderNode - The shader node.
      * @return {string} The WGSL function code.
      */
-    buildFunctionCode(shaderNode) {
+    buildFunctionCode(shaderNode: ShaderNodeInternal) {
         const layout = shaderNode.layout;
         const flowData = this.flowShaderNode(shaderNode);
 
@@ -1259,8 +1287,8 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The WGSL snippet that defines the shader attributes.
      */
-    getAttributes(shaderStage) {
-        const snippets = [];
+    getAttributes(shaderStage: NodeShaderStage) {
+        const snippets: string[] = [];
 
         if (shaderStage === 'compute') {
             this.getBuiltin('global_invocation_id', 'globalId', 'vec3<u32>', 'attribute');
@@ -1394,8 +1422,8 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The WGSL snippet that defines the varyings.
      */
-    getVaryings(shaderStage) {
-        const snippets = [];
+    getVaryings(shaderStage: NodeShaderStage) {
+        const snippets: string[] = [];
 
         if (shaderStage === 'vertex') {
             this.getBuiltin('position', 'Vertex', 'vec4<f32>', 'vertex');
@@ -1460,7 +1488,7 @@ ${flowData.code}
      * @param {string} shaderStage - The shader stage.
      * @return {string} The WGSL snippet that defines the uniforms.
      */
-    getUniforms(shaderStage) {
+    getUniforms(shaderStage: NodeShaderStage) {
         const uniforms = this.uniforms[shaderStage];
 
         const bindingSnippets = [];
diff --git a/src-testing/src/renderers/webgpu/nodes/WGSLNodeFunction.ts b/src-testing/src/renderers/webgpu/nodes/WGSLNodeFunction.ts
index 34a93355..6e5e4a86 100644
--- a/src-testing/src/renderers/webgpu/nodes/WGSLNodeFunction.ts
+++ b/src-testing/src/renderers/webgpu/nodes/WGSLNodeFunction.ts
@@ -138,7 +138,7 @@ class WGSLNodeFunction extends NodeFunction {
      *
      * @param {string} source - The WGSL source.
      */
-    constructor(source) {
+    constructor(source: string) {
         const { type, inputs, name, inputsCode, blockCode, outputType } = parse(source);
 
         super(type, inputs, name);
diff --git a/src-testing/src/renderers/webgpu/nodes/WGSLNodeParser.ts b/src-testing/src/renderers/webgpu/nodes/WGSLNodeParser.ts
index d52f7500..97fbffe0 100644
--- a/src-testing/src/renderers/webgpu/nodes/WGSLNodeParser.ts
+++ b/src-testing/src/renderers/webgpu/nodes/WGSLNodeParser.ts
@@ -13,7 +13,7 @@ class WGSLNodeParser extends NodeParser {
      * @param {string} source - The WGSL code.
      * @return {WGSLNodeFunction} A node function.
      */
-    parseFunction(source) {
+    parseFunction(source: string) {
         return new WGSLNodeFunction(source);
     }
 }
