diff --git a/examples-testing/examples/css2d_label.ts b/examples-testing/examples/css2d_label.ts
index 48a2d1f..e726021 100644
--- a/examples-testing/examples/css2d_label.ts
+++ b/examples-testing/examples/css2d_label.ts
@@ -7,7 +7,7 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 let gui;
 
-let camera, scene, renderer, labelRenderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, labelRenderer: CSS2DRenderer;
 
 const layers = {
     'Toggle Name': function () {
@@ -28,7 +28,7 @@ const layers = {
 const clock = new THREE.Clock();
 const textureLoader = new THREE.TextureLoader();
 
-let moon;
+let moon: THREE.Mesh;
 
 init();
 animate();
@@ -63,7 +63,7 @@ function init() {
         normalMap: textureLoader.load('textures/planets/earth_normal_2048.jpg'),
         normalScale: new THREE.Vector2(0.85, 0.85),
     });
-    earthMaterial.map.colorSpace = THREE.SRGBColorSpace;
+    earthMaterial.map!.colorSpace = THREE.SRGBColorSpace;
     const earth = new THREE.Mesh(earthGeometry, earthMaterial);
     scene.add(earth);
 
@@ -72,7 +72,7 @@ function init() {
         shininess: 5,
         map: textureLoader.load('textures/planets/moon_1024.jpg'),
     });
-    moonMaterial.map.colorSpace = THREE.SRGBColorSpace;
+    moonMaterial.map!.colorSpace = THREE.SRGBColorSpace;
     moon = new THREE.Mesh(moonGeometry, moonMaterial);
     scene.add(moon);
 
diff --git a/examples-testing/examples/css3d_molecules.ts b/examples-testing/examples/css3d_molecules.ts
index 5384726..f08bb34 100644
--- a/examples-testing/examples/css3d_molecules.ts
+++ b/examples-testing/examples/css3d_molecules.ts
@@ -5,11 +5,11 @@ import { PDBLoader } from 'three/addons/loaders/PDBLoader.js';
 import { CSS3DRenderer, CSS3DObject, CSS3DSprite } from 'three/addons/renderers/CSS3DRenderer.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
-let controls;
-let root;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: CSS3DRenderer;
+let controls: TrackballControls;
+let root: THREE.Object3D;
 
-const objects = [];
+const objects: Array<CSS3DObject | CSS3DSprite> = [];
 const tmpVec1 = new THREE.Vector3();
 const tmpVec2 = new THREE.Vector3();
 const tmpVec3 = new THREE.Vector3();
@@ -49,7 +49,7 @@ const params = {
 };
 
 const loader = new PDBLoader();
-const colorSpriteMap = {};
+const colorSpriteMap: { [element: string]: string | undefined } = {};
 const baseSprite = document.createElement('img');
 
 init();
@@ -68,7 +68,7 @@ function init() {
 
     renderer = new CSS3DRenderer();
     renderer.setSize(window.innerWidth, window.innerHeight);
-    document.getElementById('container').appendChild(renderer.domElement);
+    document.getElementById('container')!.appendChild(renderer.domElement);
 
     //
 
@@ -96,7 +96,7 @@ function init() {
     gui.open();
 }
 
-function changeVizType(value) {
+function changeVizType(value: number) {
     if (value === 0) showAtoms();
     else if (value === 1) showBonds();
     else showAtomsBonds();
@@ -148,7 +148,7 @@ function showAtomsBonds() {
 
 //
 
-function colorify(ctx, width, height, color) {
+function colorify(ctx: CanvasRenderingContext2D, width: number, height: number, color: THREE.Color) {
     const r = color.r,
         g = color.g,
         b = color.b;
@@ -165,7 +165,7 @@ function colorify(ctx, width, height, color) {
     ctx.putImageData(imageData, 0, 0);
 }
 
-function imageToCanvas(image) {
+function imageToCanvas(image: HTMLImageElement) {
     const width = image.width;
     const height = image.height;
 
@@ -174,7 +174,7 @@ function imageToCanvas(image) {
     canvas.width = width;
     canvas.height = height;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     context.drawImage(image, 0, 0, width, height);
 
     return canvas;
@@ -182,12 +182,12 @@ function imageToCanvas(image) {
 
 //
 
-function loadMolecule(model) {
+function loadMolecule(model: string) {
     const url = 'models/pdb/' + model;
 
     for (let i = 0; i < objects.length; i++) {
         const object = objects[i];
-        object.parent.remove(object);
+        object.parent!.remove(object);
     }
 
     objects.length = 0;
@@ -198,7 +198,7 @@ function loadMolecule(model) {
         const json = pdb.json;
 
         geometryAtoms.computeBoundingBox();
-        geometryAtoms.boundingBox.getCenter(offset).negate();
+        geometryAtoms.boundingBox!.getCenter(offset).negate();
 
         geometryAtoms.translate(offset.x, offset.y, offset.z);
         geometryBonds.translate(offset.x, offset.y, offset.z);
@@ -218,7 +218,7 @@ function loadMolecule(model) {
 
             if (!colorSpriteMap[element]) {
                 const canvas = imageToCanvas(baseSprite);
-                const context = canvas.getContext('2d');
+                const context = canvas.getContext('2d')!;
 
                 colorify(context, canvas.width, canvas.height, color);
 
@@ -227,7 +227,7 @@ function loadMolecule(model) {
                 colorSpriteMap[element] = dataUrl;
             }
 
-            const colorSprite = colorSpriteMap[element];
+            const colorSprite = colorSpriteMap[element]!;
 
             const atom = document.createElement('img');
             atom.src = colorSprite;
diff --git a/examples-testing/examples/css3d_orthographic.ts b/examples-testing/examples/css3d_orthographic.ts
index 4aabbed..67e41fd 100644
--- a/examples-testing/examples/css3d_orthographic.ts
+++ b/examples-testing/examples/css3d_orthographic.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
-import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
+import { Controller, GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let scene2, renderer2;
+let scene2: THREE.Scene, renderer2: CSS3DRenderer;
 
 const frustumSize = 500;
 
@@ -75,18 +75,18 @@ function init() {
     renderer2 = new CSS3DRenderer();
     renderer2.setSize(window.innerWidth, window.innerHeight);
     renderer2.domElement.style.position = 'absolute';
-    renderer2.domElement.style.top = 0;
+    renderer2.domElement.style.top = '0';
     document.body.appendChild(renderer2.domElement);
 
     const controls = new OrbitControls(camera, renderer2.domElement);
     controls.minZoom = 0.5;
     controls.maxZoom = 2;
 
-    function createPlane(width, height, cssColor, pos, rot) {
+    function createPlane(width: number, height: number, cssColor: string, pos: THREE.Vector3, rot: THREE.Euler) {
         const element = document.createElement('div');
         element.style.width = width + 'px';
         element.style.height = height + 'px';
-        element.style.opacity = 0.75;
+        element.style.opacity = '0.75';
         element.style.background = cssColor;
 
         const object = new CSS3DObject(element);
@@ -133,12 +133,12 @@ function createPanel() {
 
     const settings = {
         setViewOffset() {
-            folder1.children[1].enable().setValue(window.innerWidth);
-            folder1.children[2].enable().setValue(window.innerHeight);
-            folder1.children[3].enable().setValue(0);
-            folder1.children[4].enable().setValue(0);
-            folder1.children[5].enable().setValue(window.innerWidth);
-            folder1.children[6].enable().setValue(window.innerHeight);
+            (folder1.children[1] as Controller).enable().setValue(window.innerWidth);
+            (folder1.children[2] as Controller).enable().setValue(window.innerHeight);
+            (folder1.children[3] as Controller).enable().setValue(0);
+            (folder1.children[4] as Controller).enable().setValue(0);
+            (folder1.children[5] as Controller).enable().setValue(window.innerWidth);
+            (folder1.children[6] as Controller).enable().setValue(window.innerHeight);
         },
         fullWidth: 0,
         fullHeight: 0,
@@ -147,12 +147,12 @@ function createPanel() {
         width: 0,
         height: 0,
         clearViewOffset() {
-            folder1.children[1].setValue(0).disable();
-            folder1.children[2].setValue(0).disable();
-            folder1.children[3].setValue(0).disable();
-            folder1.children[4].setValue(0).disable();
-            folder1.children[5].setValue(0).disable();
-            folder1.children[6].setValue(0).disable();
+            (folder1.children[1] as Controller).setValue(0).disable();
+            (folder1.children[2] as Controller).setValue(0).disable();
+            (folder1.children[3] as Controller).setValue(0).disable();
+            (folder1.children[4] as Controller).setValue(0).disable();
+            (folder1.children[5] as Controller).setValue(0).disable();
+            (folder1.children[6] as Controller).setValue(0).disable();
             camera.clearViewOffset();
         },
     };
@@ -185,7 +185,21 @@ function createPanel() {
     folder1.add(settings, 'clearViewOffset');
 }
 
-function updateCameraViewOffset({ fullWidth, fullHeight, x, y, width, height }) {
+function updateCameraViewOffset({
+    fullWidth,
+    fullHeight,
+    x,
+    y,
+    width,
+    height,
+}: {
+    fullWidth?: number;
+    fullHeight?: number;
+    x?: number;
+    y?: number;
+    width?: number;
+    height?: number;
+}) {
     if (!camera.view) {
         camera.setViewOffset(
             fullWidth || window.innerWidth,
diff --git a/examples-testing/examples/css3d_periodictable.ts b/examples-testing/examples/css3d_periodictable.ts
index e3a33f7..516df46 100644
--- a/examples-testing/examples/css3d_periodictable.ts
+++ b/examples-testing/examples/css3d_periodictable.ts
@@ -597,11 +597,16 @@ const table = [
     7,
 ];
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: CSS3DRenderer;
+let controls: TrackballControls;
 
-const objects = [];
-const targets = { table: [], sphere: [], helix: [], grid: [] };
+const objects: CSS3DObject[] = [];
+const targets: {
+    table: THREE.Object3D[];
+    sphere: THREE.Object3D[];
+    helix: THREE.Object3D[];
+    grid: THREE.Object3D[];
+} = { table: [], sphere: [], helix: [], grid: [] };
 
 init();
 animate();
@@ -621,12 +626,12 @@ function init() {
 
         const number = document.createElement('div');
         number.className = 'number';
-        number.textContent = i / 5 + 1;
+        number.textContent = `${i / 5 + 1}`;
         element.appendChild(number);
 
         const symbol = document.createElement('div');
         symbol.className = 'symbol';
-        symbol.textContent = table[i];
+        symbol.textContent = table[i] as string;
         element.appendChild(symbol);
 
         const details = document.createElement('div');
@@ -645,8 +650,8 @@ function init() {
         //
 
         const object = new THREE.Object3D();
-        object.position.x = table[i + 3] * 140 - 1330;
-        object.position.y = -(table[i + 4] * 180) + 990;
+        object.position.x = (table[i + 3] as number) * 140 - 1330;
+        object.position.y = -((table[i + 4] as number) * 180) + 990;
 
         targets.table.push(object);
     }
@@ -705,7 +710,7 @@ function init() {
 
     renderer = new CSS3DRenderer();
     renderer.setSize(window.innerWidth, window.innerHeight);
-    document.getElementById('container').appendChild(renderer.domElement);
+    document.getElementById('container')!.appendChild(renderer.domElement);
 
     //
 
@@ -714,22 +719,22 @@ function init() {
     controls.maxDistance = 6000;
     controls.addEventListener('change', render);
 
-    const buttonTable = document.getElementById('table');
+    const buttonTable = document.getElementById('table')!;
     buttonTable.addEventListener('click', function () {
         transform(targets.table, 2000);
     });
 
-    const buttonSphere = document.getElementById('sphere');
+    const buttonSphere = document.getElementById('sphere')!;
     buttonSphere.addEventListener('click', function () {
         transform(targets.sphere, 2000);
     });
 
-    const buttonHelix = document.getElementById('helix');
+    const buttonHelix = document.getElementById('helix')!;
     buttonHelix.addEventListener('click', function () {
         transform(targets.helix, 2000);
     });
 
-    const buttonGrid = document.getElementById('grid');
+    const buttonGrid = document.getElementById('grid')!;
     buttonGrid.addEventListener('click', function () {
         transform(targets.grid, 2000);
     });
@@ -741,7 +746,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function transform(targets, duration) {
+function transform(targets: THREE.Object3D[], duration: number) {
     TWEEN.removeAll();
 
     for (let i = 0; i < objects.length; i++) {
@@ -765,7 +770,7 @@ function transform(targets, duration) {
             .start();
     }
 
-    new TWEEN.Tween(this)
+    new TWEEN.Tween({})
         .to({}, duration * 2)
         .onUpdate(render)
         .start();
diff --git a/examples-testing/examples/css3d_sandbox.ts b/examples-testing/examples/css3d_sandbox.ts
index 1088b84..02f1fa7 100644
--- a/examples-testing/examples/css3d_sandbox.ts
+++ b/examples-testing/examples/css3d_sandbox.ts
@@ -2,13 +2,13 @@ import * as THREE from 'three';
 
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
-import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
+import { Controller, GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let scene2, renderer2;
+let scene2: THREE.Scene, renderer2: CSS3DRenderer;
 
-let controls;
+let controls: TrackballControls;
 
 init();
 animate();
@@ -35,7 +35,7 @@ function init() {
         const element = document.createElement('div');
         element.style.width = '100px';
         element.style.height = '100px';
-        element.style.opacity = i < 5 ? 0.5 : 1;
+        element.style.opacity = `${i < 5 ? 0.5 : 1}`;
         element.style.background = new THREE.Color(Math.random() * 0xffffff).getStyle();
 
         const object = new CSS3DObject(element);
@@ -67,7 +67,7 @@ function init() {
     renderer2 = new CSS3DRenderer();
     renderer2.setSize(window.innerWidth, window.innerHeight);
     renderer2.domElement.style.position = 'absolute';
-    renderer2.domElement.style.top = 0;
+    renderer2.domElement.style.top = '0';
     document.body.appendChild(renderer2.domElement);
 
     controls = new TrackballControls(camera, renderer2.domElement);
@@ -101,12 +101,12 @@ function createPanel() {
 
     const settings = {
         setViewOffset() {
-            folder1.children[1].enable().setValue(window.innerWidth);
-            folder1.children[2].enable().setValue(window.innerHeight);
-            folder1.children[3].enable().setValue(0);
-            folder1.children[4].enable().setValue(0);
-            folder1.children[5].enable().setValue(window.innerWidth);
-            folder1.children[6].enable().setValue(window.innerHeight);
+            (folder1.children[1] as Controller).enable().setValue(window.innerWidth);
+            (folder1.children[2] as Controller).enable().setValue(window.innerHeight);
+            (folder1.children[3] as Controller).enable().setValue(0);
+            (folder1.children[4] as Controller).enable().setValue(0);
+            (folder1.children[5] as Controller).enable().setValue(window.innerWidth);
+            (folder1.children[6] as Controller).enable().setValue(window.innerHeight);
         },
         fullWidth: 0,
         fullHeight: 0,
@@ -115,12 +115,12 @@ function createPanel() {
         width: 0,
         height: 0,
         clearViewOffset() {
-            folder1.children[1].setValue(0).disable();
-            folder1.children[2].setValue(0).disable();
-            folder1.children[3].setValue(0).disable();
-            folder1.children[4].setValue(0).disable();
-            folder1.children[5].setValue(0).disable();
-            folder1.children[6].setValue(0).disable();
+            (folder1.children[1] as Controller).setValue(0).disable();
+            (folder1.children[2] as Controller).setValue(0).disable();
+            (folder1.children[3] as Controller).setValue(0).disable();
+            (folder1.children[4] as Controller).setValue(0).disable();
+            (folder1.children[5] as Controller).setValue(0).disable();
+            (folder1.children[6] as Controller).setValue(0).disable();
             camera.clearViewOffset();
         },
     };
@@ -153,7 +153,21 @@ function createPanel() {
     folder1.add(settings, 'clearViewOffset');
 }
 
-function updateCameraViewOffset({ fullWidth, fullHeight, x, y, width, height }) {
+function updateCameraViewOffset({
+    fullWidth,
+    fullHeight,
+    x,
+    y,
+    width,
+    height,
+}: {
+    fullWidth?: number;
+    fullHeight?: number;
+    x?: number;
+    y?: number;
+    width?: number;
+    height?: number;
+}) {
     if (!camera.view) {
         camera.setViewOffset(
             fullWidth || window.innerWidth,
diff --git a/examples-testing/examples/css3d_sprites.ts b/examples-testing/examples/css3d_sprites.ts
index dfe24e7..93f2c07 100644
--- a/examples-testing/examples/css3d_sprites.ts
+++ b/examples-testing/examples/css3d_sprites.ts
@@ -4,12 +4,12 @@ import TWEEN from 'three/addons/libs/tween.module.js';
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import { CSS3DRenderer, CSS3DSprite } from 'three/addons/renderers/CSS3DRenderer.js';
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: CSS3DRenderer;
+let controls: TrackballControls;
 
 const particlesTotal = 512;
-const positions = [];
-const objects = [];
+const positions: number[] = [];
+const objects: CSS3DSprite[] = [];
 let current = 0;
 
 init();
@@ -25,7 +25,7 @@ function init() {
     const image = document.createElement('img');
     image.addEventListener('load', function () {
         for (let i = 0; i < particlesTotal; i++) {
-            const object = new CSS3DSprite(image.cloneNode());
+            const object = new CSS3DSprite(image.cloneNode() as typeof image);
             (object.position.x = Math.random() * 4000 - 2000),
                 (object.position.y = Math.random() * 4000 - 2000),
                 (object.position.z = Math.random() * 4000 - 2000);
@@ -93,7 +93,7 @@ function init() {
 
     renderer = new CSS3DRenderer();
     renderer.setSize(window.innerWidth, window.innerHeight);
-    document.getElementById('container').appendChild(renderer.domElement);
+    document.getElementById('container')!.appendChild(renderer.domElement);
 
     //
 
@@ -131,7 +131,7 @@ function transition() {
             .start();
     }
 
-    new TWEEN.Tween(this)
+    new TWEEN.Tween({})
         .to({}, duration * 3)
         .onComplete(transition)
         .start();
diff --git a/examples-testing/examples/css3d_youtube.ts b/examples-testing/examples/css3d_youtube.ts
index 62652f8..3dcc2f1 100644
--- a/examples-testing/examples/css3d_youtube.ts
+++ b/examples-testing/examples/css3d_youtube.ts
@@ -3,10 +3,10 @@ import * as THREE from 'three';
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: CSS3DRenderer;
+let controls: TrackballControls;
 
-function Element(id, x, y, z, ry) {
+function Element(id: string, x: number, y: number, z: number, ry: number) {
     const div = document.createElement('div');
     div.style.width = '480px';
     div.style.height = '360px';
@@ -30,7 +30,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 5000);
     camera.position.set(500, 350, 750);
@@ -42,10 +42,10 @@ function init() {
     container.appendChild(renderer.domElement);
 
     const group = new THREE.Group();
-    group.add(new Element('SJOz3qjfQXU', 0, 0, 240, 0));
-    group.add(new Element('Y2-xZ-1HE-Q', 240, 0, 0, Math.PI / 2));
-    group.add(new Element('IrydklNpcFI', 0, 0, -240, Math.PI));
-    group.add(new Element('9ubytEsCaS0', -240, 0, 0, -Math.PI / 2));
+    group.add(Element('SJOz3qjfQXU', 0, 0, 240, 0));
+    group.add(Element('Y2-xZ-1HE-Q', 240, 0, 0, Math.PI / 2));
+    group.add(Element('IrydklNpcFI', 0, 0, -240, Math.PI));
+    group.add(Element('9ubytEsCaS0', -240, 0, 0, -Math.PI / 2));
     scene.add(group);
 
     controls = new TrackballControls(camera, renderer.domElement);
@@ -55,7 +55,7 @@ function init() {
 
     // Block iframe events when dragging camera
 
-    const blocker = document.getElementById('blocker');
+    const blocker = document.getElementById('blocker')!;
     blocker.style.display = 'none';
 
     controls.addEventListener('start', function () {
diff --git a/examples-testing/examples/games_fps.ts b/examples-testing/examples/games_fps.ts
index 49d31e7..0ede5e7 100644
--- a/examples-testing/examples/games_fps.ts
+++ b/examples-testing/examples/games_fps.ts
@@ -39,7 +39,7 @@ directionalLight.shadow.radius = 4;
 directionalLight.shadow.bias = -0.00006;
 scene.add(directionalLight);
 
-const container = document.getElementById('container');
+const container = document.getElementById('container')!;
 
 const renderer = new THREE.WebGLRenderer({ antialias: true });
 renderer.setPixelRatio(window.devicePixelRatio);
@@ -50,9 +50,9 @@ renderer.toneMapping = THREE.ACESFilmicToneMapping;
 container.appendChild(renderer.domElement);
 
 const stats = new Stats();
-stats.domElement.style.position = 'absolute';
-stats.domElement.style.top = '0px';
-container.appendChild(stats.domElement);
+stats.dom.style.position = 'absolute';
+stats.dom.style.top = '0px';
+container.appendChild(stats.dom);
 
 const GRAVITY = 30;
 
@@ -64,7 +64,13 @@ const STEPS_PER_FRAME = 5;
 const sphereGeometry = new THREE.IcosahedronGeometry(SPHERE_RADIUS, 5);
 const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0xdede8d });
 
-const spheres = [];
+interface Sphere {
+    mesh: THREE.Mesh;
+    collider: THREE.Sphere;
+    velocity: THREE.Vector3;
+}
+
+const spheres: Sphere[] = [];
 let sphereIdx = 0;
 
 for (let i = 0; i < NUM_SPHERES; i++) {
@@ -91,7 +97,7 @@ const playerDirection = new THREE.Vector3();
 let playerOnFloor = false;
 let mouseTime = 0;
 
-const keyStates = {};
+const keyStates: { [eventCode: string]: boolean | undefined } = {};
 
 const vector1 = new THREE.Vector3();
 const vector2 = new THREE.Vector3();
@@ -164,7 +170,7 @@ function playerCollisions() {
     }
 }
 
-function updatePlayer(deltaTime) {
+function updatePlayer(deltaTime: number) {
     let damping = Math.exp(-4 * deltaTime) - 1;
 
     if (!playerOnFloor) {
@@ -184,7 +190,7 @@ function updatePlayer(deltaTime) {
     camera.position.copy(playerCollider.end);
 }
 
-function playerSphereCollision(sphere) {
+function playerSphereCollision(sphere: Sphere) {
     const center = vector1.addVectors(playerCollider.start, playerCollider.end).multiplyScalar(0.5);
 
     const sphere_center = sphere.collider.center;
@@ -239,7 +245,7 @@ function spheresCollisions() {
     }
 }
 
-function updateSpheres(deltaTime) {
+function updateSpheres(deltaTime: number) {
     spheres.forEach(sphere => {
         sphere.collider.center.addScaledVector(sphere.velocity, deltaTime);
 
@@ -282,7 +288,7 @@ function getSideVector() {
     return playerDirection;
 }
 
-function controls(deltaTime) {
+function controls(deltaTime: number) {
     // gives a bit of air control
     const speedDelta = deltaTime * (playerOnFloor ? 25 : 8);
 
@@ -317,12 +323,12 @@ loader.load('collision-world.glb', gltf => {
     worldOctree.fromGraphNode(gltf.scene);
 
     gltf.scene.traverse(child => {
-        if (child.isMesh) {
+        if ((child as THREE.Mesh).isMesh) {
             child.castShadow = true;
             child.receiveShadow = true;
 
-            if (child.material.map) {
-                child.material.map.anisotropy = 4;
+            if (((child as THREE.Mesh).material as THREE.MeshStandardMaterial).map) {
+                ((child as THREE.Mesh).material as THREE.MeshStandardMaterial).map!.anisotropy = 4;
             }
         }
     });
diff --git a/examples-testing/examples/misc_animation_groups.ts b/examples-testing/examples/misc_animation_groups.ts
index 19d263f..f8d0bed 100644
--- a/examples-testing/examples/misc_animation_groups.ts
+++ b/examples-testing/examples/misc_animation_groups.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let stats, clock;
-let scene, camera, renderer, mixer;
+let stats: Stats, clock: THREE.Clock;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, mixer: THREE.AnimationMixer;
 
 init();
 animate();
diff --git a/examples-testing/examples/misc_animation_keys.ts b/examples-testing/examples/misc_animation_keys.ts
index 4a80898..d2613d0 100644
--- a/examples-testing/examples/misc_animation_keys.ts
+++ b/examples-testing/examples/misc_animation_keys.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let stats, clock;
-let scene, camera, renderer, mixer;
+let stats: Stats, clock: THREE.Clock;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, mixer: THREE.AnimationMixer;
 
 init();
 animate();
@@ -25,7 +25,10 @@ function init() {
     //
 
     const geometry = new THREE.BoxGeometry(5, 5, 5);
-    const material = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true });
+    const material = new THREE.MeshBasicMaterial({
+        color: 0xffffff,
+        transparent: true,
+    });
     const mesh = new THREE.Mesh(geometry, material);
     scene.add(mesh);
 
diff --git a/examples-testing/examples/misc_boxselection.ts b/examples-testing/examples/misc_boxselection.ts
index 8766c55..f70f4fc 100644
--- a/examples-testing/examples/misc_boxselection.ts
+++ b/examples-testing/examples/misc_boxselection.ts
@@ -5,8 +5,8 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { SelectionBox } from 'three/addons/interactive/SelectionBox.js';
 import { SelectionHelper } from 'three/addons/interactive/SelectionHelper.js';
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -92,12 +92,12 @@ function render() {
     renderer.render(scene, camera);
 }
 
-const selectionBox = new SelectionBox(camera, scene);
-const helper = new SelectionHelper(renderer, 'selectBox');
+const selectionBox = new SelectionBox(camera!, scene!);
+const helper = new SelectionHelper(renderer!, 'selectBox');
 
 document.addEventListener('pointerdown', function (event) {
     for (const item of selectionBox.collection) {
-        item.material.emissive.set(0x000000);
+        (item.material as THREE.MeshLambertMaterial).emissive.set(0x000000);
     }
 
     selectionBox.startPoint.set(
@@ -110,7 +110,7 @@ document.addEventListener('pointerdown', function (event) {
 document.addEventListener('pointermove', function (event) {
     if (helper.isDown) {
         for (let i = 0; i < selectionBox.collection.length; i++) {
-            selectionBox.collection[i].material.emissive.set(0x000000);
+            (selectionBox.collection[i].material as THREE.MeshLambertMaterial).emissive.set(0x000000);
         }
 
         selectionBox.endPoint.set(
@@ -122,7 +122,7 @@ document.addEventListener('pointermove', function (event) {
         const allSelected = selectionBox.select();
 
         for (let i = 0; i < allSelected.length; i++) {
-            allSelected[i].material.emissive.set(0xffffff);
+            (allSelected[i].material as THREE.MeshLambertMaterial).emissive.set(0xffffff);
         }
     }
 });
@@ -137,6 +137,6 @@ document.addEventListener('pointerup', function (event) {
     const allSelected = selectionBox.select();
 
     for (let i = 0; i < allSelected.length; i++) {
-        allSelected[i].material.emissive.set(0xffffff);
+        (allSelected[i].material as THREE.MeshLambertMaterial).emissive.set(0xffffff);
     }
 });
diff --git a/examples-testing/examples/misc_controls_arcball.ts b/examples-testing/examples/misc_controls_arcball.ts
index fbef331..be69ca7 100644
--- a/examples-testing/examples/misc_controls_arcball.ts
+++ b/examples-testing/examples/misc_controls_arcball.ts
@@ -12,8 +12,12 @@ const cameraType = { type: 'Perspective' };
 
 const perspectiveDistance = 2.5;
 const orthographicDistance = 120;
-let camera, controls, scene, renderer, gui;
-let folderOptions, folderAnimations;
+let camera: THREE.OrthographicCamera | THREE.PerspectiveCamera,
+    controls: ArcballControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    gui: GUI;
+let folderOptions: GUI, folderAnimations: GUI;
 
 const arcballGui = {
     gizmoVisible: true,
@@ -97,8 +101,8 @@ function init() {
         material.normalMap.wrapS = THREE.RepeatWrapping;
 
         group.traverse(function (child) {
-            if (child.isMesh) {
-                child.material = material;
+            if ((child as THREE.Mesh).isMesh) {
+                (child as THREE.Mesh).material = material;
             }
         });
 
@@ -164,12 +168,12 @@ function onWindowResize() {
 
         const halfW = perspectiveDistance * Math.tan(halfFovH);
         const halfH = perspectiveDistance * Math.tan(halfFovV);
-        camera.left = -halfW;
-        camera.right = halfW;
-        camera.top = halfH;
-        camera.bottom = -halfH;
+        (camera as THREE.OrthographicCamera).left = -halfW;
+        (camera as THREE.OrthographicCamera).right = halfW;
+        (camera as THREE.OrthographicCamera).top = halfH;
+        (camera as THREE.OrthographicCamera).bottom = -halfH;
     } else if (camera.type == 'PerspectiveCamera') {
-        camera.aspect = window.innerWidth / window.innerHeight;
+        (camera as THREE.PerspectiveCamera).aspect = window.innerWidth / window.innerHeight;
     }
 
     camera.updateProjectionMatrix();
@@ -183,7 +187,7 @@ function render() {
     renderer.render(scene, camera);
 }
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     if (event.key === 'c') {
         if (event.ctrlKey || event.metaKey) {
             controls.copyState();
@@ -195,7 +199,7 @@ function onKeyDown(event) {
     }
 }
 
-function setCamera(type) {
+function setCamera(type: string) {
     if (type == 'Orthographic') {
         camera = makeOrthographicCamera();
         camera.position.set(0, 0, orthographicDistance);
diff --git a/examples-testing/examples/misc_controls_drag.ts b/examples-testing/examples/misc_controls_drag.ts
index 5036ab7..8522f7d 100644
--- a/examples-testing/examples/misc_controls_drag.ts
+++ b/examples-testing/examples/misc_controls_drag.ts
@@ -2,12 +2,12 @@ import * as THREE from 'three';
 
 import { DragControls } from 'three/addons/controls/DragControls.js';
 
-let container;
-let camera, scene, renderer;
-let controls, group;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controls: DragControls, group: THREE.Group;
 let enableSelection = false;
 
-const objects = [];
+const objects: THREE.Object3D[] = [];
 
 const mouse = new THREE.Vector2(),
     raycaster = new THREE.Raycaster();
@@ -97,7 +97,7 @@ function onWindowResize() {
     render();
 }
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     enableSelection = event.keyCode === 16 ? true : false;
 }
 
@@ -105,7 +105,7 @@ function onKeyUp() {
     enableSelection = false;
 }
 
-function onClick(event) {
+function onClick(event: MouseEvent) {
     event.preventDefault();
 
     if (enableSelection === true) {
@@ -123,10 +123,10 @@ function onClick(event) {
             const object = intersections[0].object;
 
             if (group.children.includes(object) === true) {
-                object.material.emissive.set(0x000000);
+                ((object as THREE.Mesh).material as THREE.MeshLambertMaterial).emissive.set(0x000000);
                 scene.attach(object);
             } else {
-                object.material.emissive.set(0xaaaaaa);
+                ((object as THREE.Mesh).material as THREE.MeshLambertMaterial).emissive.set(0xaaaaaa);
                 group.attach(object);
             }
 
diff --git a/examples-testing/examples/misc_controls_fly.ts b/examples-testing/examples/misc_controls_fly.ts
index 9d6a56a..28d59fb 100644
--- a/examples-testing/examples/misc_controls_fly.ts
+++ b/examples-testing/examples/misc_controls_fly.ts
@@ -19,11 +19,15 @@ const MARGIN = 0;
 let SCREEN_HEIGHT = window.innerHeight - MARGIN * 2;
 let SCREEN_WIDTH = window.innerWidth;
 
-let camera, controls, scene, renderer, stats;
-let geometry, meshPlanet, meshClouds, meshMoon;
-let dirLight;
+let camera: THREE.PerspectiveCamera,
+    controls: FlyControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats;
+let geometry: THREE.SphereGeometry, meshPlanet: THREE.Mesh, meshClouds: THREE.Mesh, meshMoon: THREE.Mesh;
+let dirLight: THREE.DirectionalLight;
 
-let composer;
+let composer: EffectComposer;
 
 const textureLoader = new THREE.TextureLoader();
 
@@ -56,7 +60,7 @@ function init() {
         // y scale is negated to compensate for normal map handedness.
         normalScale: new THREE.Vector2(0.85, -0.85),
     });
-    materialNormalMap.map.colorSpace = THREE.SRGBColorSpace;
+    materialNormalMap.map!.colorSpace = THREE.SRGBColorSpace;
 
     // planet
 
@@ -73,7 +77,7 @@ function init() {
         map: textureLoader.load('textures/planets/earth_clouds_1024.png'),
         transparent: true,
     });
-    materialClouds.map.colorSpace = THREE.SRGBColorSpace;
+    materialClouds.map!.colorSpace = THREE.SRGBColorSpace;
 
     meshClouds = new THREE.Mesh(geometry, materialClouds);
     meshClouds.scale.set(cloudsScale, cloudsScale, cloudsScale);
@@ -85,7 +89,7 @@ function init() {
     const materialMoon = new THREE.MeshPhongMaterial({
         map: textureLoader.load('textures/planets/moon_1024.jpg'),
     });
-    materialMoon.map.colorSpace = THREE.SRGBColorSpace;
+    materialMoon.map!.colorSpace = THREE.SRGBColorSpace;
 
     meshMoon = new THREE.Mesh(geometry, materialMoon);
     meshMoon.position.set(radius * 5, 0, 0);
diff --git a/examples-testing/examples/misc_controls_map.ts b/examples-testing/examples/misc_controls_map.ts
index d0d6279..7ed0ea4 100644
--- a/examples-testing/examples/misc_controls_map.ts
+++ b/examples-testing/examples/misc_controls_map.ts
@@ -4,7 +4,7 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { MapControls } from 'three/addons/controls/MapControls.js';
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: MapControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 //render(); // remove when using next line for animation loop (requestAnimationFrame)
diff --git a/examples-testing/examples/misc_controls_orbit.ts b/examples-testing/examples/misc_controls_orbit.ts
index fc29383..9f4a806 100644
--- a/examples-testing/examples/misc_controls_orbit.ts
+++ b/examples-testing/examples/misc_controls_orbit.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 //render(); // remove when using next line for animation loop (requestAnimationFrame)
diff --git a/examples-testing/examples/misc_controls_pointerlock.ts b/examples-testing/examples/misc_controls_pointerlock.ts
index 72ea08f..cf0142d 100644
--- a/examples-testing/examples/misc_controls_pointerlock.ts
+++ b/examples-testing/examples/misc_controls_pointerlock.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: PointerLockControls;
 
-const objects = [];
+const objects: THREE.Mesh[] = [];
 
-let raycaster;
+let raycaster: THREE.Raycaster;
 
 let moveForward = false;
 let moveBackward = false;
@@ -37,8 +37,8 @@ function init() {
 
     controls = new PointerLockControls(camera, document.body);
 
-    const blocker = document.getElementById('blocker');
-    const instructions = document.getElementById('instructions');
+    const blocker = document.getElementById('blocker')!;
+    const instructions = document.getElementById('instructions')!;
 
     instructions.addEventListener('click', function () {
         controls.lock();
@@ -56,7 +56,7 @@ function init() {
 
     scene.add(controls.getObject());
 
-    const onKeyDown = function (event) {
+    const onKeyDown = function (event: KeyboardEvent) {
         switch (event.code) {
             case 'ArrowUp':
             case 'KeyW':
@@ -85,7 +85,7 @@ function init() {
         }
     };
 
-    const onKeyUp = function (event) {
+    const onKeyUp = function (event: KeyboardEvent) {
         switch (event.code) {
             case 'ArrowUp':
             case 'KeyW':
@@ -116,7 +116,7 @@ function init() {
 
     // floor
 
-    let floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
+    let floorGeometry: THREE.BufferGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
     floorGeometry.rotateX(-Math.PI / 2);
 
     // vertex displacement
@@ -165,7 +165,11 @@ function init() {
     boxGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colorsBox, 3));
 
     for (let i = 0; i < 500; i++) {
-        const boxMaterial = new THREE.MeshPhongMaterial({ specular: 0xffffff, flatShading: true, vertexColors: true });
+        const boxMaterial = new THREE.MeshPhongMaterial({
+            specular: 0xffffff,
+            flatShading: true,
+            vertexColors: true,
+        });
         boxMaterial.color.setHSL(Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75, THREE.SRGBColorSpace);
 
         const box = new THREE.Mesh(boxGeometry, boxMaterial);
diff --git a/examples-testing/examples/misc_controls_trackball.ts b/examples-testing/examples/misc_controls_trackball.ts
index 88d0541..fdd703f 100644
--- a/examples-testing/examples/misc_controls_trackball.ts
+++ b/examples-testing/examples/misc_controls_trackball.ts
@@ -5,7 +5,12 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 
-let perspectiveCamera, orthographicCamera, controls, scene, renderer, stats;
+let perspectiveCamera: THREE.PerspectiveCamera,
+    orthographicCamera: THREE.OrthographicCamera,
+    controls: TrackballControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats;
 
 const params = {
     orthographicCamera: false,
@@ -92,7 +97,7 @@ function init() {
     createControls(perspectiveCamera);
 }
 
-function createControls(camera) {
+function createControls(camera: THREE.Camera) {
     controls = new TrackballControls(camera, renderer.domElement);
 
     controls.rotateSpeed = 1.0;
diff --git a/examples-testing/examples/misc_controls_transform.ts b/examples-testing/examples/misc_controls_transform.ts
index abc4657..4254e08 100644
--- a/examples-testing/examples/misc_controls_transform.ts
+++ b/examples-testing/examples/misc_controls_transform.ts
@@ -3,8 +3,8 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { TransformControls } from 'three/addons/controls/TransformControls.js';
 
-let cameraPersp, cameraOrtho, currentCamera;
-let scene, renderer, control, orbit;
+let cameraPersp: THREE.PerspectiveCamera, cameraOrtho: THREE.OrthographicCamera, currentCamera: THREE.Camera;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer, control: TransformControls, orbit: OrbitControls;
 
 init();
 render();
@@ -86,7 +86,9 @@ function init() {
             case 67: // C
                 const position = currentCamera.position.clone();
 
-                currentCamera = currentCamera.isPerspectiveCamera ? cameraOrtho : cameraPersp;
+                currentCamera = (currentCamera as THREE.PerspectiveCamera).isPerspectiveCamera
+                    ? cameraOrtho
+                    : cameraPersp;
                 currentCamera.position.copy(position);
 
                 orbit.object = currentCamera;
diff --git a/examples-testing/examples/misc_exporter_draco.ts b/examples-testing/examples/misc_exporter_draco.ts
index d6a4535..63dab8d 100644
--- a/examples-testing/examples/misc_exporter_draco.ts
+++ b/examples-testing/examples/misc_exporter_draco.ts
@@ -4,7 +4,11 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { DRACOExporter } from 'three/addons/exporters/DRACOExporter.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, renderer, exporter, mesh;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGLRenderer,
+    exporter: DRACOExporter,
+    mesh: THREE.Mesh;
 
 const params = {
     export: exportFile,
@@ -107,12 +111,12 @@ const link = document.createElement('a');
 link.style.display = 'none';
 document.body.appendChild(link);
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: BufferSource, filename: string) {
     save(new Blob([buffer], { type: 'application/octet-stream' }), filename);
 }
diff --git a/examples-testing/examples/misc_exporter_gltf.ts b/examples-testing/examples/misc_exporter_gltf.ts
index 47c8712..7c7ff78 100644
--- a/examples-testing/examples/misc_exporter_gltf.ts
+++ b/examples-testing/examples/misc_exporter_gltf.ts
@@ -6,7 +6,7 @@ import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
 import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-function exportGLTF(input) {
+function exportGLTF(input: THREE.Object3D | THREE.Object3D[]) {
     const gltfExporter = new GLTFExporter();
 
     const options = {
@@ -37,7 +37,7 @@ const link = document.createElement('a');
 link.style.display = 'none';
 document.body.appendChild(link); // Firefox workaround, see #6594
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
@@ -45,18 +45,25 @@ function save(blob, filename) {
     // URL.revokeObjectURL( url ); breaks Firefox...
 }
 
-function saveString(text, filename) {
+function saveString(text: string, filename: string) {
     save(new Blob([text], { type: 'text/plain' }), filename);
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: BufferSource, filename: string) {
     save(new Blob([buffer], { type: 'application/octet-stream' }), filename);
 }
 
-let container;
-
-let camera, object, object2, material, geometry, scene1, scene2, renderer;
-let gridHelper, sphere, model, coffeemat;
+let container: HTMLDivElement;
+
+let camera: THREE.PerspectiveCamera,
+    object: THREE.Object3D,
+    object2: THREE.Mesh,
+    material: THREE.MeshBasicMaterial | THREE.MeshStandardMaterial,
+    geometry: THREE.BufferGeometry,
+    scene1: THREE.Scene,
+    scene2: THREE.Scene,
+    renderer: THREE.WebGLRenderer;
+let gridHelper: THREE.GridHelper, sphere: THREE.Mesh, model: THREE.Group, coffeemat: THREE.Group;
 
 const params = {
     trs: false,
diff --git a/examples-testing/examples/misc_exporter_obj.ts b/examples-testing/examples/misc_exporter_obj.ts
index c315294..384af61 100644
--- a/examples-testing/examples/misc_exporter_obj.ts
+++ b/examples-testing/examples/misc_exporter_obj.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const params = {
     addTriangle: addTriangle,
@@ -66,12 +66,12 @@ function exportToObj() {
     saveString(result, 'object.obj');
 }
 
-function addGeometry(type) {
+function addGeometry(type: number) {
     for (let i = 0; i < scene.children.length; i++) {
         const child = scene.children[i];
 
-        if (child.isMesh || child.isPoints) {
-            child.geometry.dispose();
+        if ((child as THREE.Mesh).isMesh || (child as THREE.Points).isPoints) {
+            (child as THREE.Mesh | THREE.Points).geometry.dispose();
             scene.remove(child);
             i--;
         }
@@ -156,13 +156,13 @@ const link = document.createElement('a');
 link.style.display = 'none';
 document.body.appendChild(link);
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
 }
 
-function saveString(text, filename) {
+function saveString(text: string, filename: string) {
     save(new Blob([text], { type: 'text/plain' }), filename);
 }
 
diff --git a/examples-testing/examples/misc_exporter_ply.ts b/examples-testing/examples/misc_exporter_ply.ts
index 997c4f1..b860682 100644
--- a/examples-testing/examples/misc_exporter_ply.ts
+++ b/examples-testing/examples/misc_exporter_ply.ts
@@ -4,7 +4,11 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { PLYExporter } from 'three/addons/exporters/PLYExporter.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, renderer, exporter, mesh;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGLRenderer,
+    exporter: PLYExporter,
+    mesh: THREE.Mesh;
 
 const params = {
     exportASCII: exportASCII,
@@ -142,16 +146,16 @@ const link = document.createElement('a');
 link.style.display = 'none';
 document.body.appendChild(link);
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
 }
 
-function saveString(text, filename) {
+function saveString(text: string, filename: string) {
     save(new Blob([text], { type: 'text/plain' }), filename);
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: BufferSource, filename: string) {
     save(new Blob([buffer], { type: 'application/octet-stream' }), filename);
 }
diff --git a/examples-testing/examples/misc_exporter_stl.ts b/examples-testing/examples/misc_exporter_stl.ts
index ad6e3f5..3eec71e 100644
--- a/examples-testing/examples/misc_exporter_stl.ts
+++ b/examples-testing/examples/misc_exporter_stl.ts
@@ -4,7 +4,11 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { STLExporter } from 'three/addons/exporters/STLExporter.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, renderer, exporter, mesh;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGLRenderer,
+    exporter: STLExporter,
+    mesh: THREE.Mesh;
 
 const params = {
     exportASCII: exportASCII,
@@ -115,16 +119,16 @@ const link = document.createElement('a');
 link.style.display = 'none';
 document.body.appendChild(link);
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
 }
 
-function saveString(text, filename) {
+function saveString(text: string, filename: string) {
     save(new Blob([text], { type: 'text/plain' }), filename);
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: BufferSource, filename: string) {
     save(new Blob([buffer], { type: 'application/octet-stream' }), filename);
 }
diff --git a/examples-testing/examples/misc_exporter_usdz.ts b/examples-testing/examples/misc_exporter_usdz.ts
index 7a0e782..db8aee7 100644
--- a/examples-testing/examples/misc_exporter_usdz.ts
+++ b/examples-testing/examples/misc_exporter_usdz.ts
@@ -7,7 +7,7 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { USDZExporter } from 'three/addons/exporters/USDZExporter.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const params = {
     exportUSDZ: exportUSDZ,
@@ -50,7 +50,7 @@ function init() {
         const arraybuffer = await exporter.parse(gltf.scene);
         const blob = new Blob([arraybuffer], { type: 'application/octet-stream' });
 
-        const link = document.getElementById('link');
+        const link = document.getElementById('link') as HTMLAnchorElement;
         link.href = URL.createObjectURL(blob);
     });
 
@@ -78,7 +78,7 @@ function createSpotShadowMesh() {
     canvas.width = 128;
     canvas.height = 128;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     const gradient = context.createRadialGradient(
         canvas.width / 2,
         canvas.height / 2,
@@ -118,7 +118,7 @@ function onWindowResize() {
 }
 
 function exportUSDZ() {
-    const link = document.getElementById('link');
+    const link = document.getElementById('link')!;
     link.click();
 }
 
diff --git a/examples-testing/examples/misc_lookat.ts b/examples-testing/examples/misc_lookat.ts
index f6241b9..93e8340 100644
--- a/examples-testing/examples/misc_lookat.ts
+++ b/examples-testing/examples/misc_lookat.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
-let sphere;
+let sphere: THREE.Mesh;
 
 let mouseX = 0,
     mouseY = 0;
@@ -64,7 +64,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) * 10;
     mouseY = (event.clientY - windowHalfY) * 10;
 }
diff --git a/examples-testing/examples/misc_uv_tests.ts b/examples-testing/examples/misc_uv_tests.ts
index 4f782d4..0759cfc 100644
--- a/examples-testing/examples/misc_uv_tests.ts
+++ b/examples-testing/examples/misc_uv_tests.ts
@@ -7,7 +7,7 @@ import { UVsDebug } from 'three/addons/utils/UVsDebug.js';
  * as well as allow a new user to visualize what UVs are about.
  */
 
-function test(name, geometry) {
+function test(name: string, geometry: THREE.BufferGeometry) {
     const d = document.createElement('div');
 
     d.innerHTML = '<h3>' + name + '</h3>';
diff --git a/examples-testing/examples/physics_ammo_instancing.ts b/examples-testing/examples/physics_ammo_instancing.ts
index fdfc815..1eede4e 100644
--- a/examples-testing/examples/physics_ammo_instancing.ts
+++ b/examples-testing/examples/physics_ammo_instancing.ts
@@ -1,12 +1,12 @@
 import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { AmmoPhysics } from 'three/addons/physics/AmmoPhysics.js';
+import { AmmoPhysics, AmmoPhysicsObject } from 'three/addons/physics/AmmoPhysics.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
-let physics, position;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let physics: AmmoPhysicsObject, position: THREE.Vector3;
 
-let boxes, spheres;
+let boxes: THREE.InstancedMesh, spheres: THREE.InstancedMesh;
 
 init();
 
diff --git a/examples-testing/examples/physics_rapier_instancing.ts b/examples-testing/examples/physics_rapier_instancing.ts
index 42116a6..1e9811b 100644
--- a/examples-testing/examples/physics_rapier_instancing.ts
+++ b/examples-testing/examples/physics_rapier_instancing.ts
@@ -1,12 +1,12 @@
 import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { RapierPhysics } from 'three/addons/physics/RapierPhysics.js';
+import { RapierPhysics, RapierPhysicsObject } from 'three/addons/physics/RapierPhysics.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
-let physics, position;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let physics: RapierPhysicsObject, position: THREE.Vector3;
 
-let boxes, spheres;
+let boxes: THREE.InstancedMesh, spheres: THREE.InstancedMesh;
 
 init();
 
diff --git a/examples-testing/examples/svg_lines.ts b/examples-testing/examples/svg_lines.ts
index 99b74c4..65aaf28 100644
--- a/examples-testing/examples/svg_lines.ts
+++ b/examples-testing/examples/svg_lines.ts
@@ -4,7 +4,7 @@ import { SVGRenderer } from 'three/addons/renderers/SVGRenderer.js';
 
 THREE.ColorManagement.enabled = false;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: SVGRenderer;
 
 init();
 animate();
diff --git a/examples-testing/examples/svg_sandbox.ts b/examples-testing/examples/svg_sandbox.ts
index e6be838..faea9a7 100644
--- a/examples-testing/examples/svg_sandbox.ts
+++ b/examples-testing/examples/svg_sandbox.ts
@@ -6,9 +6,9 @@ import { SVGRenderer, SVGObject } from 'three/addons/renderers/SVGRenderer.js';
 
 THREE.ColorManagement.enabled = false;
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: SVGRenderer, stats: Stats;
 
-let group;
+let group: THREE.Mesh;
 
 init();
 animate();
@@ -33,9 +33,13 @@ function init() {
 
     const boxGeometry = new THREE.BoxGeometry(100, 100, 100);
 
-    let mesh = new THREE.Mesh(
+    let mesh: THREE.Mesh = new THREE.Mesh(
         boxGeometry,
-        new THREE.MeshBasicMaterial({ color: 0x0000ff, opacity: 0.5, transparent: true }),
+        new THREE.MeshBasicMaterial({
+            color: 0x0000ff,
+            opacity: 0.5,
+            transparent: true,
+        }),
     );
     mesh.position.x = 500;
     mesh.rotation.x = Math.random();
@@ -55,7 +59,10 @@ function init() {
 
     mesh = new THREE.Mesh(
         new THREE.PlaneGeometry(100, 100),
-        new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff, side: THREE.DoubleSide }),
+        new THREE.MeshBasicMaterial({
+            color: Math.random() * 0xffffff,
+            side: THREE.DoubleSide,
+        }),
     );
     mesh.position.y = -500;
     mesh.scale.x = mesh.scale.y = mesh.scale.z = 2;
@@ -75,7 +82,10 @@ function init() {
     // POLYFIELD
 
     const geometry = new THREE.BufferGeometry();
-    const material = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide });
+    const material = new THREE.MeshBasicMaterial({
+        vertexColors: true,
+        side: THREE.DoubleSide,
+    });
 
     const v = new THREE.Vector3();
     const v0 = new THREE.Vector3();
@@ -122,7 +132,9 @@ function init() {
     // SPRITES
 
     for (let i = 0; i < 50; i++) {
-        const material = new THREE.SpriteMaterial({ color: Math.random() * 0xffffff });
+        const material = new THREE.SpriteMaterial({
+            color: Math.random() * 0xffffff,
+        });
         const sprite = new THREE.Sprite(material);
         sprite.position.x = Math.random() * 1000 - 500;
         sprite.position.y = Math.random() * 1000 - 500;
@@ -139,7 +151,7 @@ function init() {
     node.setAttribute('r', '40');
 
     for (let i = 0; i < 50; i++) {
-        const object = new SVGObject(node.cloneNode());
+        const object = new SVGObject(node.cloneNode() as SVGCircleElement);
         object.position.x = Math.random() * 1000 - 500;
         object.position.y = Math.random() * 1000 - 500;
         object.position.z = Math.random() * 1000 - 500;
@@ -152,7 +164,7 @@ function init() {
     fileLoader.load('models/svg/hexagon.svg', function (svg) {
         const node = document.createElementNS('http://www.w3.org/2000/svg', 'g');
         const parser = new DOMParser();
-        const doc = parser.parseFromString(svg, 'image/svg+xml');
+        const doc = parser.parseFromString(svg as string, 'image/svg+xml');
 
         node.appendChild(doc.documentElement);
 
diff --git a/examples-testing/examples/webaudio_orientation.ts b/examples-testing/examples/webaudio_orientation.ts
index d5cff39..06315a2 100644
--- a/examples-testing/examples/webaudio_orientation.ts
+++ b/examples-testing/examples/webaudio_orientation.ts
@@ -4,16 +4,16 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { PositionalAudioHelper } from 'three/addons/helpers/PositionalAudioHelper.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let scene, camera, renderer;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer;
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', init);
 
 function init() {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     //
 
@@ -65,7 +65,7 @@ function init() {
     const listener = new THREE.AudioListener();
     camera.add(listener);
 
-    const audioElement = document.getElementById('music');
+    const audioElement = document.getElementById('music') as HTMLAudioElement;
     audioElement.play();
 
     const positionalAudio = new THREE.PositionalAudio(listener);
@@ -85,10 +85,10 @@ function init() {
         boomBox.scale.set(20, 20, 20);
 
         boomBox.traverse(function (object) {
-            if (object.isMesh) {
-                object.material.envMap = reflectionCube;
-                object.geometry.rotateY(-Math.PI);
-                object.castShadow = true;
+            if ((object as THREE.Mesh).isMesh) {
+                ((object as THREE.Mesh).material as THREE.MeshStandardMaterial).envMap = reflectionCube;
+                (object as THREE.Mesh).geometry.rotateY(-Math.PI);
+                (object as THREE.Mesh).castShadow = true;
             }
         });
 
@@ -100,7 +100,11 @@ function init() {
     // sound is damped behind this wall
 
     const wallGeometry = new THREE.BoxGeometry(2, 1, 0.1);
-    const wallMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
+    const wallMaterial = new THREE.MeshBasicMaterial({
+        color: 0xff0000,
+        transparent: true,
+        opacity: 0.5,
+    });
 
     const wall = new THREE.Mesh(wallGeometry, wallMaterial);
     wall.position.set(0, 0.5, -0.5);
diff --git a/examples-testing/examples/webaudio_sandbox.ts b/examples-testing/examples/webaudio_sandbox.ts
index 56bd042..b200423 100644
--- a/examples-testing/examples/webaudio_sandbox.ts
+++ b/examples-testing/examples/webaudio_sandbox.ts
@@ -4,19 +4,23 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
 
-let camera, controls, scene, renderer, light;
+let camera: THREE.PerspectiveCamera,
+    controls: FirstPersonControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    light: THREE.DirectionalLight;
 
-let material1, material2, material3;
+let material1: THREE.MeshPhongMaterial, material2: THREE.MeshPhongMaterial, material3: THREE.MeshPhongMaterial;
 
-let analyser1, analyser2, analyser3;
+let analyser1: THREE.AudioAnalyser, analyser2: THREE.AudioAnalyser, analyser3: THREE.AudioAnalyser;
 
 const clock = new THREE.Clock();
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', init);
 
 function init() {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
@@ -45,7 +49,7 @@ function init() {
     scene.add(mesh1);
 
     const sound1 = new THREE.PositionalAudio(listener);
-    const songElement = document.getElementById('song');
+    const songElement = document.getElementById('song') as HTMLAudioElement;
     sound1.setMediaElementSource(songElement);
     sound1.setRefDistance(20);
     songElement.play();
@@ -58,7 +62,7 @@ function init() {
     scene.add(mesh2);
 
     const sound2 = new THREE.PositionalAudio(listener);
-    const skullbeatzElement = document.getElementById('skullbeatz');
+    const skullbeatzElement = document.getElementById('skullbeatz') as HTMLAudioElement;
     sound2.setMediaElementSource(skullbeatzElement);
     sound2.setRefDistance(20);
     skullbeatzElement.play();
@@ -89,7 +93,7 @@ function init() {
     // global ambient audio
 
     const sound4 = new THREE.Audio(listener);
-    const utopiaElement = document.getElementById('utopia');
+    const utopiaElement = document.getElementById('utopia') as HTMLAudioElement;
     sound4.setMediaElementSource(utopiaElement);
     sound4.setVolume(0.5);
     utopiaElement.play();
@@ -102,18 +106,31 @@ function init() {
 
     //
 
-    const SoundControls = function () {
-        this.master = listener.getMasterVolume();
-        this.firstSphere = sound1.getVolume();
-        this.secondSphere = sound2.getVolume();
-        this.thirdSphere = sound3.getVolume();
-        this.Ambient = sound4.getVolume();
-    };
-
-    const GeneratorControls = function () {
-        this.frequency = oscillator.frequency.value;
-        this.wavetype = oscillator.type;
-    };
+    class SoundControls {
+        master: number;
+        firstSphere: number;
+        secondSphere: number;
+        thirdSphere: number;
+        Ambient: number;
+
+        constructor() {
+            this.master = listener.getMasterVolume();
+            this.firstSphere = sound1.getVolume();
+            this.secondSphere = sound2.getVolume();
+            this.thirdSphere = sound3.getVolume();
+            this.Ambient = sound4.getVolume();
+        }
+    }
+
+    class GeneratorControls {
+        frequency: number;
+        wavetype: OscillatorType;
+
+        constructor() {
+            this.frequency = oscillator.frequency.value;
+            this.wavetype = oscillator.type;
+        }
+    }
 
     const gui = new GUI();
     const soundControls = new SoundControls();
diff --git a/examples-testing/examples/webaudio_timing.ts b/examples-testing/examples/webaudio_timing.ts
index bab79dd..2d6c621 100644
--- a/examples-testing/examples/webaudio_timing.ts
+++ b/examples-testing/examples/webaudio_timing.ts
@@ -2,22 +2,22 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let scene, camera, renderer, clock;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
 
-const objects = [];
+const objects: THREE.Mesh[] = [];
 
 const speed = 2.5;
 const height = 3;
 const offset = 0.5;
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', init);
 
 function init() {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
 
@@ -147,7 +147,7 @@ function render() {
             if (ball.userData.down === true) {
                 // ball changed direction from down to up
 
-                const audio = ball.children[0];
+                const audio = ball.children[0] as THREE.Audio;
                 audio.play(); // play audio with perfect timing when ball hits the surface
                 ball.userData.down = false;
             }
diff --git a/examples-testing/examples/webaudio_visualizer.ts b/examples-testing/examples/webaudio_visualizer.ts
index 6c4244f..857d8f1 100644
--- a/examples-testing/examples/webaudio_visualizer.ts
+++ b/examples-testing/examples/webaudio_visualizer.ts
@@ -1,8 +1,13 @@
 import * as THREE from 'three';
+import { IUniform } from 'three';
 
-let scene, camera, renderer, analyser, uniforms;
+let scene: THREE.Scene,
+    camera: THREE.Camera,
+    renderer: THREE.WebGLRenderer,
+    analyser: THREE.AudioAnalyser,
+    uniforms: { [uniform: string]: IUniform };
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', init);
 
 function init() {
@@ -10,12 +15,12 @@ function init() {
 
     //
 
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
     //
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -58,8 +63,8 @@ function init() {
 
     const material = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
     });
 
     const geometry = new THREE.PlaneGeometry(1, 1);
@@ -87,7 +92,7 @@ function animate() {
 function render() {
     analyser.getFrequencyData();
 
-    uniforms.tAudioData.value.needsUpdate = true;
+    (uniforms.tAudioData.value as THREE.DataTexture).needsUpdate = true;
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl2_buffergeometry_attributes_integer.ts b/examples-testing/examples/webgl2_buffergeometry_attributes_integer.ts
index 848814c..ca05c89 100644
--- a/examples-testing/examples/webgl2_buffergeometry_attributes_integer.ts
+++ b/examples-testing/examples/webgl2_buffergeometry_attributes_integer.ts
@@ -6,7 +6,7 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let camera, scene, renderer, mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mesh: THREE.Mesh;
 
 init();
 animate();
@@ -72,7 +72,7 @@ function init() {
     geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
     geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
     geometry.setAttribute('textureIndex', new THREE.Int16BufferAttribute(textureIndices, 1));
-    geometry.attributes.textureIndex.gpuType = THREE.IntType;
+    (geometry.attributes.textureIndex as THREE.BufferAttribute).gpuType = THREE.IntType;
 
     geometry.computeBoundingSphere();
 
@@ -90,8 +90,8 @@ function init() {
                 value: [map1, map2, map3],
             },
         },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
         side: THREE.DoubleSide,
         glslVersion: THREE.GLSL3,
     });
diff --git a/examples-testing/examples/webgl2_buffergeometry_attributes_none.ts b/examples-testing/examples/webgl2_buffergeometry_attributes_none.ts
index a77b973..d24a458 100644
--- a/examples-testing/examples/webgl2_buffergeometry_attributes_none.ts
+++ b/examples-testing/examples/webgl2_buffergeometry_attributes_none.ts
@@ -6,7 +6,7 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let camera, scene, renderer, mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mesh: THREE.Mesh;
 
 init();
 animate();
@@ -34,8 +34,8 @@ function init() {
         uniforms: {
             seed: { value: 42 },
         },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
         side: THREE.DoubleSide,
         glslVersion: THREE.GLSL3,
     });
@@ -54,11 +54,11 @@ function init() {
     document.body.appendChild(renderer.domElement);
 }
 
-function animate(time) {
+function animate(time?: number) {
     requestAnimationFrame(animate);
 
-    mesh.rotation.x = (time / 1000.0) * 0.25;
-    mesh.rotation.y = (time / 1000.0) * 0.5;
+    mesh.rotation.x = time != null ? (time / 1000.0) * 0.25 : NaN;
+    mesh.rotation.y = time != null ? (time / 1000.0) * 0.5 : NaN;
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl2_materials_texture3d.ts b/examples-testing/examples/webgl2_materials_texture3d.ts
index b746daf..581c97a 100644
--- a/examples-testing/examples/webgl2_materials_texture3d.ts
+++ b/examples-testing/examples/webgl2_materials_texture3d.ts
@@ -10,7 +10,15 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let renderer, scene, camera, controls, material, volconfig, cmtextures;
+type ColorMap = 'gray' | 'viridis';
+
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.OrthographicCamera,
+    controls: OrbitControls,
+    material: THREE.ShaderMaterial,
+    volconfig: { clim1: number; clim2: number; renderstyle: string; isothreshold: number; colormap: ColorMap },
+    cmtextures: { [K in ColorMap]: THREE.Texture };
 
 init();
 
@@ -105,7 +113,7 @@ function init() {
 }
 
 function updateUniforms() {
-    material.uniforms['u_clim'].value.set(volconfig.clim1, volconfig.clim2);
+    (material.uniforms['u_clim'].value as THREE.Vector2).set(volconfig.clim1, volconfig.clim2);
     material.uniforms['u_renderstyle'].value = volconfig.renderstyle == 'mip' ? 0 : 1; // 0: MIP, 1: ISO
     material.uniforms['u_renderthreshold'].value = volconfig.isothreshold; // For ISO renderstyle
     material.uniforms['u_cmdata'].value = cmtextures[volconfig.colormap];
diff --git a/examples-testing/examples/webgl2_materials_texture3d_partialupdate.ts b/examples-testing/examples/webgl2_materials_texture3d_partialupdate.ts
index 0268130..0e78ed5 100644
--- a/examples-testing/examples/webgl2_materials_texture3d_partialupdate.ts
+++ b/examples-testing/examples/webgl2_materials_texture3d_partialupdate.ts
@@ -11,15 +11,15 @@ if (WebGL.isWebGL2Available() === false) {
 
 const INITIAL_CLOUD_SIZE = 128;
 
-let renderer, scene, camera;
-let mesh;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let mesh: THREE.Mesh<THREE.BoxGeometry, THREE.RawShaderMaterial>;
 let prevTime = performance.now();
-let cloudTexture = null;
+let cloudTexture: THREE.Data3DTexture | null = null;
 
 init();
 animate();
 
-function generateCloudTexture(size, scaleFactor = 1.0) {
+function generateCloudTexture(size: number, scaleFactor = 1.0) {
     const data = new Uint8Array(size * size * size);
     const scale = (scaleFactor * 10.0) / size;
 
@@ -65,7 +65,7 @@ function init() {
     canvas.width = 1;
     canvas.height = 32;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     const gradient = context.createLinearGradient(0, 0, 0, 32);
     gradient.addColorStop(0.0, '#014a84');
     gradient.addColorStop(0.5, '#0561a0');
@@ -317,17 +317,17 @@ function animate() {
         const scaleFactor = (Math.random() + 0.5) * 0.5;
         const source = generateCloudTexture(perElementPaddedSize, scaleFactor);
 
-        renderer.copyTextureToTexture3D(box, position, source, cloudTexture);
+        renderer.copyTextureToTexture3D(box, position, source, cloudTexture!);
 
         prevTime = time;
 
         curr++;
     }
 
-    mesh.material.uniforms.cameraPos.value.copy(camera.position);
+    (mesh.material.uniforms.cameraPos.value as THREE.Vector3).copy(camera.position);
     // mesh.rotation.y = - performance.now() / 7500;
 
-    mesh.material.uniforms.frame.value++;
+    (mesh.material.uniforms.frame.value as number)++;
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl2_multiple_rendertargets.ts b/examples-testing/examples/webgl2_multiple_rendertargets.ts
index cc10827..217ec13 100644
--- a/examples-testing/examples/webgl2_multiple_rendertargets.ts
+++ b/examples-testing/examples/webgl2_multiple_rendertargets.ts
@@ -4,9 +4,9 @@ import WebGL from 'three/addons/capabilities/WebGL.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, controls;
-let renderTarget;
-let postScene, postCamera;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
+let renderTarget: THREE.WebGLMultipleRenderTargets;
+let postScene: THREE.Scene, postCamera: THREE.OrthographicCamera;
 
 const parameters = {
     samples: 4,
@@ -68,8 +68,8 @@ function init() {
         new THREE.Mesh(
             new THREE.TorusKnotGeometry(1, 0.3, 128, 32),
             new THREE.RawShaderMaterial({
-                vertexShader: document.querySelector('#gbuffer-vert').textContent.trim(),
-                fragmentShader: document.querySelector('#gbuffer-frag').textContent.trim(),
+                vertexShader: document.querySelector('#gbuffer-vert')!.textContent!.trim(),
+                fragmentShader: document.querySelector('#gbuffer-frag')!.textContent!.trim(),
                 uniforms: {
                     tDiffuse: { value: diffuse },
                     repeat: { value: new THREE.Vector2(5, 0.5) },
@@ -88,8 +88,8 @@ function init() {
         new THREE.Mesh(
             new THREE.PlaneGeometry(2, 2),
             new THREE.RawShaderMaterial({
-                vertexShader: document.querySelector('#render-vert').textContent.trim(),
-                fragmentShader: document.querySelector('#render-frag').textContent.trim(),
+                vertexShader: document.querySelector('#render-vert')!.textContent!.trim(),
+                fragmentShader: document.querySelector('#render-frag')!.textContent!.trim(),
                 uniforms: {
                     tDiffuse: { value: renderTarget.texture[0] },
                     tNormal: { value: renderTarget.texture[1] },
@@ -124,8 +124,8 @@ function render() {
     renderTarget.samples = parameters.samples;
 
     scene.traverse(function (child) {
-        if (child.material !== undefined) {
-            child.material.wireframe = parameters.wireframe;
+        if ((child as THREE.Mesh).material !== undefined) {
+            ((child as THREE.Mesh).material as THREE.RawShaderMaterial).wireframe = parameters.wireframe;
         }
     });
 
diff --git a/examples-testing/examples/webgl2_multisampled_renderbuffers.ts b/examples-testing/examples/webgl2_multisampled_renderbuffers.ts
index c3197be..e795c79 100644
--- a/examples-testing/examples/webgl2_multisampled_renderbuffers.ts
+++ b/examples-testing/examples/webgl2_multisampled_renderbuffers.ts
@@ -6,9 +6,9 @@ import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import WebGL from 'three/addons/capabilities/WebGL.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, renderer, group, container;
+let camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, group: THREE.Group, container: HTMLElement;
 
-let composer1, composer2;
+let composer1: EffectComposer, composer2: EffectComposer;
 
 const params = {
     animate: true,
@@ -22,7 +22,7 @@ function init() {
         return;
     }
 
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 10, 2000);
     camera.position.z = 500;
diff --git a/examples-testing/examples/webgl2_texture2darray_compressed.ts b/examples-testing/examples/webgl2_texture2darray_compressed.ts
index bf86320..5294a1f 100644
--- a/examples-testing/examples/webgl2_texture2darray_compressed.ts
+++ b/examples-testing/examples/webgl2_texture2darray_compressed.ts
@@ -9,7 +9,12 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let camera, scene, mesh, renderer, stats, clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    mesh: THREE.Mesh<THREE.PlaneGeometry, THREE.ShaderMaterial>,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    clock: THREE.Clock;
 
 const planeWidth = 50;
 const planeHeight = 25;
@@ -49,8 +54,8 @@ function init() {
                 depth: { value: 55 },
                 size: { value: new THREE.Vector2(planeWidth, planeHeight) },
             },
-            vertexShader: document.getElementById('vs').textContent.trim(),
-            fragmentShader: document.getElementById('fs').textContent.trim(),
+            vertexShader: document.getElementById('vs')!.textContent!.trim(),
+            fragmentShader: document.getElementById('fs')!.textContent!.trim(),
             glslVersion: THREE.GLSL3,
         });
 
diff --git a/examples-testing/examples/webgl2_ubo.ts b/examples-testing/examples/webgl2_ubo.ts
index e296fdc..527b9a7 100644
--- a/examples-testing/examples/webgl2_ubo.ts
+++ b/examples-testing/examples/webgl2_ubo.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 
 import WebGL from 'three/addons/capabilities/WebGL.js';
 
-let camera, scene, renderer, clock;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
 
 init();
 animate();
@@ -13,7 +13,7 @@ function init() {
         return;
     }
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
     camera.position.set(0, 0, 25);
@@ -59,8 +59,8 @@ function init() {
             normalMatrix: { value: null },
             color: { value: null },
         },
-        vertexShader: document.getElementById('vertexShader1').textContent,
-        fragmentShader: document.getElementById('fragmentShader1').textContent,
+        vertexShader: document.getElementById('vertexShader1')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader1')!.textContent!,
         glslVersion: THREE.GLSL3,
     });
 
@@ -69,8 +69,8 @@ function init() {
             modelMatrix: { value: null },
             diffuseMap: { value: null },
         },
-        vertexShader: document.getElementById('vertexShader2').textContent,
-        fragmentShader: document.getElementById('fragmentShader2').textContent,
+        vertexShader: document.getElementById('vertexShader2')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader2')!.textContent!,
         glslVersion: THREE.GLSL3,
     });
 
@@ -136,7 +136,7 @@ function animate() {
     const delta = clock.getDelta();
 
     scene.traverse(function (child) {
-        if (child.isMesh) {
+        if ((child as THREE.Mesh).isMesh) {
             child.rotation.x += delta * 0.5;
             child.rotation.y += delta * 0.3;
         }
diff --git a/examples-testing/examples/webgl2_volume_cloud.ts b/examples-testing/examples/webgl2_volume_cloud.ts
index bc54732..7fe4043 100644
--- a/examples-testing/examples/webgl2_volume_cloud.ts
+++ b/examples-testing/examples/webgl2_volume_cloud.ts
@@ -9,8 +9,8 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let renderer, scene, camera;
-let mesh;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let mesh: THREE.Mesh<THREE.BoxGeometry, THREE.RawShaderMaterial>;
 
 init();
 animate();
@@ -34,7 +34,7 @@ function init() {
     canvas.width = 1;
     canvas.height = 32;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     const gradient = context.createLinearGradient(0, 0, 0, 32);
     gradient.addColorStop(0.0, '#014a84');
     gradient.addColorStop(0.5, '#0561a0');
@@ -277,10 +277,10 @@ function onWindowResize() {
 function animate() {
     requestAnimationFrame(animate);
 
-    mesh.material.uniforms.cameraPos.value.copy(camera.position);
+    (mesh.material.uniforms.cameraPos.value as THREE.Vector3).copy(camera.position);
     mesh.rotation.y = -performance.now() / 7500;
 
-    mesh.material.uniforms.frame.value++;
+    (mesh.material.uniforms.frame.value as number)++;
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl2_volume_instancing.ts b/examples-testing/examples/webgl2_volume_instancing.ts
index 09e1e58..3afdda9 100644
--- a/examples-testing/examples/webgl2_volume_instancing.ts
+++ b/examples-testing/examples/webgl2_volume_instancing.ts
@@ -8,7 +8,11 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let renderer, scene, camera, controls, clock;
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    controls: OrbitControls,
+    clock: THREE.Clock;
 
 init();
 animate();
@@ -161,7 +165,7 @@ function init() {
 
             const mesh = new THREE.InstancedMesh(geometry, material, 50000);
             mesh.onBeforeRender = function () {
-                this.material.uniforms.cameraPos.value.copy(camera.position);
+                (this.material.uniforms.cameraPos.value as THREE.Vector3).copy(camera.position);
             };
 
             const transform = new THREE.Object3D();
diff --git a/examples-testing/examples/webgl2_volume_perlin.ts b/examples-testing/examples/webgl2_volume_perlin.ts
index a75328f..35a0321 100644
--- a/examples-testing/examples/webgl2_volume_perlin.ts
+++ b/examples-testing/examples/webgl2_volume_perlin.ts
@@ -9,8 +9,8 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let renderer, scene, camera;
-let mesh;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let mesh: THREE.Mesh<THREE.BoxGeometry, THREE.RawShaderMaterial>;
 
 init();
 animate();
@@ -209,7 +209,7 @@ function onWindowResize() {
 function animate() {
     requestAnimationFrame(animate);
 
-    mesh.material.uniforms.cameraPos.value.copy(camera.position);
+    (mesh.material.uniforms.cameraPos.value as THREE.Vector3).copy(camera.position);
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl_animation_keyframes.ts b/examples-testing/examples/webgl_animation_keyframes.ts
index 22dd961..fbe392b 100644
--- a/examples-testing/examples/webgl_animation_keyframes.ts
+++ b/examples-testing/examples/webgl_animation_keyframes.ts
@@ -8,10 +8,10 @@ import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 
-let mixer;
+let mixer: THREE.AnimationMixer;
 
 const clock = new THREE.Clock();
-const container = document.getElementById('container');
+const container = document.getElementById('container')!;
 
 const stats = new Stats();
 container.appendChild(stats.dom);
diff --git a/examples-testing/examples/webgl_animation_multiple.ts b/examples-testing/examples/webgl_animation_multiple.ts
index 8f99340..4f3fafa 100644
--- a/examples-testing/examples/webgl_animation_multiple.ts
+++ b/examples-testing/examples/webgl_animation_multiple.ts
@@ -3,10 +3,10 @@ import * as THREE from 'three';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
 
-let camera, scene, renderer;
-let clock;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let clock: THREE.Clock;
 
-const mixers = [];
+const mixers: THREE.AnimationMixer[] = [];
 
 init();
 animate();
@@ -52,7 +52,7 @@ function init() {
     const loader = new GLTFLoader();
     loader.load('models/gltf/Soldier.glb', function (gltf) {
         gltf.scene.traverse(function (object) {
-            if (object.isMesh) object.castShadow = true;
+            if ((object as THREE.Mesh).isMesh) object.castShadow = true;
         });
 
         const model1 = SkeletonUtils.clone(gltf.scene);
diff --git a/examples-testing/examples/webgl_animation_skinning_morph.ts b/examples-testing/examples/webgl_animation_skinning_morph.ts
index 6aa1368..4eaea5d 100644
--- a/examples-testing/examples/webgl_animation_skinning_morph.ts
+++ b/examples-testing/examples/webgl_animation_skinning_morph.ts
@@ -5,10 +5,29 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let container, stats, clock, gui, mixer, actions, activeAction, previousAction;
-let camera, scene, renderer, model, face;
-
-const api = { state: 'Walking' };
+let container: HTMLDivElement,
+    stats: Stats,
+    clock: THREE.Clock,
+    gui: GUI,
+    mixer: THREE.AnimationMixer,
+    actions: Record<string, THREE.AnimationAction>,
+    activeAction: THREE.AnimationAction,
+    previousAction: THREE.AnimationAction;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    model: THREE.Group,
+    face: THREE.Mesh;
+
+const api: {
+    state: string;
+    Jump?: () => void;
+    Yes?: () => void;
+    No?: () => void;
+    Wave?: () => void;
+    Punch?: () => void;
+    ThumbsUp?: () => void;
+} = { state: 'Walking' };
 
 init();
 animate();
@@ -80,9 +99,9 @@ function init() {
     container.appendChild(stats.dom);
 }
 
-function createGUI(model, animations) {
+function createGUI(model: THREE.Group, animations: THREE.AnimationClip[]) {
     const states = ['Idle', 'Walking', 'Running', 'Dance', 'Death', 'Sitting', 'Standing'];
-    const emotes = ['Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp'];
+    const emotes = ['Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp'] as const;
 
     gui = new GUI();
 
@@ -95,7 +114,7 @@ function createGUI(model, animations) {
         const action = mixer.clipAction(clip);
         actions[clip.name] = action;
 
-        if (emotes.indexOf(clip.name) >= 0 || states.indexOf(clip.name) >= 4) {
+        if (emotes.indexOf(clip.name as (typeof emotes)[number]) >= 0 || states.indexOf(clip.name) >= 4) {
             action.clampWhenFinished = true;
             action.loop = THREE.LoopOnce;
         }
@@ -117,14 +136,14 @@ function createGUI(model, animations) {
 
     const emoteFolder = gui.addFolder('Emotes');
 
-    function createEmoteCallback(name) {
+    function createEmoteCallback(name: (typeof emotes)[number]) {
         api[name] = function () {
             fadeToAction(name, 0.2);
 
             mixer.addEventListener('finished', restoreState);
         };
 
-        emoteFolder.add(api, name);
+        emoteFolder.add(api as Required<typeof api>, name);
     }
 
     function restoreState() {
@@ -141,13 +160,13 @@ function createGUI(model, animations) {
 
     // expressions
 
-    face = model.getObjectByName('Head_4');
+    face = model.getObjectByName('Head_4') as THREE.Mesh;
 
-    const expressions = Object.keys(face.morphTargetDictionary);
+    const expressions = Object.keys(face.morphTargetDictionary!);
     const expressionFolder = gui.addFolder('Expressions');
 
     for (let i = 0; i < expressions.length; i++) {
-        expressionFolder.add(face.morphTargetInfluences, i, 0, 1, 0.01).name(expressions[i]);
+        expressionFolder.add(face.morphTargetInfluences!, i, 0, 1, 0.01).name(expressions[i]);
     }
 
     activeAction = actions['Walking'];
@@ -156,7 +175,7 @@ function createGUI(model, animations) {
     expressionFolder.open();
 }
 
-function fadeToAction(name, duration) {
+function fadeToAction(name: string, duration: number) {
     previousAction = activeAction;
     activeAction = actions[name];
 
diff --git a/examples-testing/examples/webgl_buffergeometry.ts b/examples-testing/examples/webgl_buffergeometry.ts
index 5f9bb39..03d2644 100644
--- a/examples-testing/examples/webgl_buffergeometry.ts
+++ b/examples-testing/examples/webgl_buffergeometry.ts
@@ -2,17 +2,17 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh;
+let mesh: THREE.Mesh;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -117,8 +117,8 @@ function init() {
         colors.push(color.r, color.g, color.b, alpha);
     }
 
-    function disposeArray() {
-        this.array = null;
+    function disposeArray(this: THREE.BufferAttribute) {
+        this.array = null as unknown as THREE.TypedArray;
     }
 
     geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3).onUpload(disposeArray));
diff --git a/examples-testing/examples/webgl_buffergeometry_custom_attributes_particles.ts b/examples-testing/examples/webgl_buffergeometry_custom_attributes_particles.ts
index e9e115d..65b7563 100644
--- a/examples-testing/examples/webgl_buffergeometry_custom_attributes_particles.ts
+++ b/examples-testing/examples/webgl_buffergeometry_custom_attributes_particles.ts
@@ -2,9 +2,11 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let particleSystem, uniforms, geometry;
+let particleSystem: THREE.Points,
+    uniforms: { pointTexture: THREE.IUniform<THREE.Texture> },
+    geometry: THREE.BufferGeometry;
 
 const particles = 100000;
 
@@ -23,8 +25,8 @@ function init() {
 
     const shaderMaterial = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
 
         blending: THREE.AdditiveBlending,
         depthTest: false,
@@ -66,7 +68,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_buffergeometry_drawrange.ts b/examples-testing/examples/webgl_buffergeometry_drawrange.ts
index 41f364d..347d455 100644
--- a/examples-testing/examples/webgl_buffergeometry_drawrange.ts
+++ b/examples-testing/examples/webgl_buffergeometry_drawrange.ts
@@ -5,15 +5,15 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let group;
-let container, stats;
-const particlesData = [];
-let camera, scene, renderer;
-let positions, colors;
-let particles;
-let pointCloud;
-let particlePositions;
-let linesMesh;
+let group: THREE.Group;
+let container: HTMLElement, stats: Stats;
+const particlesData: { velocity: THREE.Vector3; numConnections: number }[] = [];
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let positions: Float32Array, colors: Float32Array;
+let particles: THREE.BufferGeometry;
+let pointCloud: THREE.Points;
+let particlePositions: Float32Array;
+let linesMesh: THREE.LineSegments;
 
 const maxParticleCount = 1000;
 let particleCount = 500;
@@ -53,7 +53,7 @@ function initGUI() {
 function init() {
     initGUI();
 
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 4000);
     camera.position.z = 1750;
diff --git a/examples-testing/examples/webgl_buffergeometry_glbufferattribute.ts b/examples-testing/examples/webgl_buffergeometry_glbufferattribute.ts
index daf8a06..0624ea0 100644
--- a/examples-testing/examples/webgl_buffergeometry_glbufferattribute.ts
+++ b/examples-testing/examples/webgl_buffergeometry_glbufferattribute.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let points;
+let points: THREE.Points<THREE.BufferGeometry<THREE.NormalOrGLBufferAttributes>, THREE.PointsMaterial>;
 
 const particles = 300000;
 let drawCount = 10000;
@@ -15,7 +15,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -36,7 +36,7 @@ function init() {
 
     //
 
-    const geometry = new THREE.BufferGeometry();
+    const geometry = new THREE.BufferGeometry<THREE.NormalOrGLBufferAttributes>();
 
     const positions = [];
     const positions2 = [];
@@ -70,15 +70,15 @@ function init() {
 
     const gl = renderer.getContext();
 
-    const pos = gl.createBuffer();
+    const pos = gl.createBuffer()!;
     gl.bindBuffer(gl.ARRAY_BUFFER, pos);
     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
 
-    const pos2 = gl.createBuffer();
+    const pos2 = gl.createBuffer()!;
     gl.bindBuffer(gl.ARRAY_BUFFER, pos2);
     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions2), gl.STATIC_DRAW);
 
-    const rgb = gl.createBuffer();
+    const rgb = gl.createBuffer()!;
     gl.bindBuffer(gl.ARRAY_BUFFER, rgb);
     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
 
diff --git a/examples-testing/examples/webgl_buffergeometry_indexed.ts b/examples-testing/examples/webgl_buffergeometry_indexed.ts
index 1e9f668..ec64598 100644
--- a/examples-testing/examples/webgl_buffergeometry_indexed.ts
+++ b/examples-testing/examples/webgl_buffergeometry_indexed.ts
@@ -3,9 +3,9 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
-let mesh;
+let mesh: THREE.Mesh;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_buffergeometry_instancing.ts b/examples-testing/examples/webgl_buffergeometry_instancing.ts
index adff12a..fb9267f 100644
--- a/examples-testing/examples/webgl_buffergeometry_instancing.ts
+++ b/examples-testing/examples/webgl_buffergeometry_instancing.ts
@@ -3,15 +3,15 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10);
     camera.position.z = 2;
@@ -80,8 +80,8 @@ function init() {
             time: { value: 1.0 },
             sineTime: { value: 1.0 },
         },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
         side: THREE.DoubleSide,
         forceSinglePass: true,
         transparent: true,
@@ -100,7 +100,7 @@ function init() {
     container.appendChild(renderer.domElement);
 
     if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has('ANGLE_instanced_arrays') === false) {
-        document.getElementById('notSupported').style.display = '';
+        document.getElementById('notSupported')!.style.display = '';
         return;
     }
 
@@ -138,7 +138,7 @@ function animate() {
 function render() {
     const time = performance.now();
 
-    const object = scene.children[0];
+    const object = scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.RawShaderMaterial>;
 
     object.rotation.y = time * 0.0005;
     object.material.uniforms['time'].value = time * 0.005;
diff --git a/examples-testing/examples/webgl_buffergeometry_instancing_billboards.ts b/examples-testing/examples/webgl_buffergeometry_instancing_billboards.ts
index 785389c..64b3ee1 100644
--- a/examples-testing/examples/webgl_buffergeometry_instancing_billboards.ts
+++ b/examples-testing/examples/webgl_buffergeometry_instancing_billboards.ts
@@ -2,16 +2,16 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
-let geometry, material, mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let geometry: THREE.InstancedBufferGeometry, material: THREE.RawShaderMaterial, mesh: THREE.Mesh;
 
 function init() {
     renderer = new THREE.WebGLRenderer();
 
     if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has('ANGLE_instanced_arrays') === false) {
-        document.getElementById('notSupported').style.display = '';
+        document.getElementById('notSupported')!.style.display = '';
         return false;
     }
 
@@ -46,8 +46,8 @@ function init() {
             map: { value: new THREE.TextureLoader().load('textures/sprites/circle.png') },
             time: { value: 0.0 },
         },
-        vertexShader: document.getElementById('vshader').textContent,
-        fragmentShader: document.getElementById('fshader').textContent,
+        vertexShader: document.getElementById('vshader')!.textContent!,
+        fragmentShader: document.getElementById('fshader')!.textContent!,
         depthTest: true,
         depthWrite: true,
     });
diff --git a/examples-testing/examples/webgl_buffergeometry_instancing_interleaved.ts b/examples-testing/examples/webgl_buffergeometry_instancing_interleaved.ts
index 132e1e6..77ce657 100644
--- a/examples-testing/examples/webgl_buffergeometry_instancing_interleaved.ts
+++ b/examples-testing/examples/webgl_buffergeometry_instancing_interleaved.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
-let camera, scene, renderer, mesh;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mesh: THREE.InstancedMesh;
 
 const instances = 5000;
 let lastTime = 0;
@@ -17,7 +17,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
 
@@ -112,7 +112,7 @@ function init() {
     container.appendChild(renderer.domElement);
 
     if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has('ANGLE_instanced_arrays') === false) {
-        document.getElementById('notSupported').style.display = '';
+        document.getElementById('notSupported')!.style.display = '';
         return;
     }
 
diff --git a/examples-testing/examples/webgl_buffergeometry_lines.ts b/examples-testing/examples/webgl_buffergeometry_lines.ts
index c23ea0c..705d08f 100644
--- a/examples-testing/examples/webgl_buffergeometry_lines.ts
+++ b/examples-testing/examples/webgl_buffergeometry_lines.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats, clock;
+let container: HTMLElement, stats: Stats, clock: THREE.Clock;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let line;
+let line: THREE.Line;
 
 const segments = 10000;
 const r = 800;
@@ -16,7 +16,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -100,12 +100,12 @@ function render() {
     line.rotation.y = time * 0.5;
 
     t += delta * 0.5;
-    line.morphTargetInfluences[0] = Math.abs(Math.sin(t));
+    line.morphTargetInfluences![0] = Math.abs(Math.sin(t));
 
     renderer.render(scene, camera);
 }
 
-function generateMorphTargets(geometry) {
+function generateMorphTargets(geometry: THREE.BufferGeometry) {
     const data = [];
 
     for (let i = 0; i < segments; i++) {
diff --git a/examples-testing/examples/webgl_buffergeometry_lines_indexed.ts b/examples-testing/examples/webgl_buffergeometry_lines_indexed.ts
index d81c173..209454f 100644
--- a/examples-testing/examples/webgl_buffergeometry_lines_indexed.ts
+++ b/examples-testing/examples/webgl_buffergeometry_lines_indexed.ts
@@ -2,17 +2,17 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let parent_node;
+let parent_node: THREE.Object3D;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 9000;
@@ -22,9 +22,9 @@ function init() {
     const geometry = new THREE.BufferGeometry();
     const material = new THREE.LineBasicMaterial({ vertexColors: true });
 
-    const indices = [];
-    const positions = [];
-    const colors = [];
+    const indices: number[] = [];
+    const positions: number[] = [];
+    const colors: number[] = [];
 
     let next_positions_index = 0;
 
@@ -33,7 +33,7 @@ function init() {
     const iteration_count = 4;
     const rangle = (60 * Math.PI) / 180.0;
 
-    function add_vertex(v) {
+    function add_vertex(v: THREE.Vector3) {
         if (next_positions_index == 0xffff) console.error('Too many points.');
 
         positions.push(v.x, v.y, v.z);
@@ -44,7 +44,7 @@ function init() {
 
     // simple Koch curve
 
-    function snowflake_iteration(p0, p4, depth) {
+    function snowflake_iteration(p0: THREE.Vector3, p4: THREE.Vector3, depth: number) {
         if (--depth < 0) {
             const i = next_positions_index - 1; // p0 already there
             add_vertex(p4);
@@ -71,7 +71,7 @@ function init() {
         snowflake_iteration(p3, p4, depth);
     }
 
-    function snowflake(points, loop, x_offset) {
+    function snowflake(points: THREE.Vector3[], loop: boolean, x_offset: number) {
         for (let iteration = 0; iteration != iteration_count; iteration++) {
             add_vertex(points[0]);
 
diff --git a/examples-testing/examples/webgl_buffergeometry_points.ts b/examples-testing/examples/webgl_buffergeometry_points.ts
index fdfd957..b05a609 100644
--- a/examples-testing/examples/webgl_buffergeometry_points.ts
+++ b/examples-testing/examples/webgl_buffergeometry_points.ts
@@ -2,17 +2,17 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let points;
+let points: THREE.Points;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
diff --git a/examples-testing/examples/webgl_buffergeometry_points_interleaved.ts b/examples-testing/examples/webgl_buffergeometry_points_interleaved.ts
index 9d1ac41..e26b9a1 100644
--- a/examples-testing/examples/webgl_buffergeometry_points_interleaved.ts
+++ b/examples-testing/examples/webgl_buffergeometry_points_interleaved.ts
@@ -2,17 +2,17 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let points;
+let points: THREE.Points;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 5, 3500);
     camera.position.z = 2750;
diff --git a/examples-testing/examples/webgl_buffergeometry_rawshader.ts b/examples-testing/examples/webgl_buffergeometry_rawshader.ts
index 0d05339..cd5fe8c 100644
--- a/examples-testing/examples/webgl_buffergeometry_rawshader.ts
+++ b/examples-testing/examples/webgl_buffergeometry_rawshader.ts
@@ -2,15 +2,15 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10);
     camera.position.z = 2;
@@ -54,8 +54,8 @@ function init() {
         uniforms: {
             time: { value: 1.0 },
         },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
         side: THREE.DoubleSide,
         transparent: true,
     });
@@ -93,7 +93,7 @@ function animate() {
 function render() {
     const time = performance.now();
 
-    const object = scene.children[0];
+    const object = scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.RawShaderMaterial>;
 
     object.rotation.y = time * 0.0005;
     object.material.uniforms.time.value = time * 0.005;
diff --git a/examples-testing/examples/webgl_buffergeometry_selective_draw.ts b/examples-testing/examples/webgl_buffergeometry_selective_draw.ts
index f0752a2..8e8a44f 100644
--- a/examples-testing/examples/webgl_buffergeometry_selective_draw.ts
+++ b/examples-testing/examples/webgl_buffergeometry_selective_draw.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
-let geometry, mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let geometry: THREE.BufferGeometry, mesh: THREE.LineSegments;
 const numLat = 100;
 const numLng = 200;
 let numLinesCulled = 0;
@@ -29,14 +29,14 @@ function init() {
 
     addLines(1.0);
 
-    const hideLinesButton = document.getElementById('hideLines');
+    const hideLinesButton = document.getElementById('hideLines')!;
     hideLinesButton.addEventListener('click', hideLines);
 
-    const showAllLinesButton = document.getElementById('showAllLines');
+    const showAllLinesButton = document.getElementById('showAllLines')!;
     showAllLinesButton.addEventListener('click', showAllLines);
 }
 
-function addLines(radius) {
+function addLines(radius: number) {
     geometry = new THREE.BufferGeometry();
     const linePositions = new Float32Array(numLat * numLng * 3 * 2);
     const lineColors = new Float32Array(numLat * numLng * 3 * 2);
@@ -81,8 +81,8 @@ function addLines(radius) {
     geometry.computeBoundingSphere();
 
     const shaderMaterial = new THREE.ShaderMaterial({
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
     });
 
     mesh = new THREE.LineSegments(geometry, shaderMaterial);
@@ -98,7 +98,7 @@ function updateCount() {
         ' lines, ' +
         numLinesCulled +
         ' culled (<a target="_blank" href="http://callum.com">author</a>)';
-    document.getElementById('title').innerHTML = str.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
+    document.getElementById('title')!.innerHTML = str.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
 }
 
 function hideLines() {
diff --git a/examples-testing/examples/webgl_buffergeometry_uint.ts b/examples-testing/examples/webgl_buffergeometry_uint.ts
index d248a0d..16a111b 100644
--- a/examples-testing/examples/webgl_buffergeometry_uint.ts
+++ b/examples-testing/examples/webgl_buffergeometry_uint.ts
@@ -2,17 +2,17 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh;
+let mesh: THREE.Mesh;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
diff --git a/examples-testing/examples/webgl_camera.ts b/examples-testing/examples/webgl_camera.ts
index d8319ec..8f8b515 100644
--- a/examples-testing/examples/webgl_camera.ts
+++ b/examples-testing/examples/webgl_camera.ts
@@ -6,11 +6,11 @@ let SCREEN_WIDTH = window.innerWidth;
 let SCREEN_HEIGHT = window.innerHeight;
 let aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
 
-let container, stats;
-let camera, scene, renderer, mesh;
-let cameraRig, activeCamera, activeHelper;
-let cameraPerspective, cameraOrtho;
-let cameraPerspectiveHelper, cameraOrthoHelper;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mesh: THREE.Mesh;
+let cameraRig: THREE.Group, activeCamera: THREE.Camera, activeHelper: THREE.CameraHelper;
+let cameraPerspective: THREE.PerspectiveCamera, cameraOrtho: THREE.OrthographicCamera;
+let cameraPerspectiveHelper: THREE.CameraHelper, cameraOrthoHelper: THREE.CameraHelper;
 const frustumSize = 600;
 
 init();
@@ -122,7 +122,7 @@ function init() {
 
 //
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     switch (event.keyCode) {
         case 79 /*O*/:
             activeCamera = cameraOrtho;
diff --git a/examples-testing/examples/webgl_camera_logarithmicdepthbuffer.ts b/examples-testing/examples/webgl_camera_logarithmicdepthbuffer.ts
index a80cc19..4d1f2c8 100644
--- a/examples-testing/examples/webgl_camera_logarithmicdepthbuffer.ts
+++ b/examples-testing/examples/webgl_camera_logarithmicdepthbuffer.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three';
 
-import { FontLoader } from 'three/addons/loaders/FontLoader.js';
+import { Font, FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
 import Stats from 'three/addons/libs/stats.module.js';
@@ -17,8 +17,16 @@ let zoompos = -100,
     minzoomspeed = 0.015;
 let zoomspeed = minzoomspeed;
 
-let container, border, stats;
-const objects = {};
+let container: HTMLElement, border: HTMLElement, stats: Stats;
+
+interface ObjectView {
+    container: HTMLElement;
+    renderer: THREE.WebGLRenderer;
+    scene: THREE.Scene;
+    camera: THREE.PerspectiveCamera;
+}
+
+const objects: { normal?: ObjectView; logzbuf?: ObjectView } = {};
 
 // Generate a number of text labels, from 1µm in size up to 100,000,000 light years
 // Try to use some descriptive real-world examples of objects at each scale
@@ -44,7 +52,7 @@ const labeldata = [
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     const loader = new FontLoader();
     loader.load('fonts/helvetiker_regular.typeface.json', function (font) {
@@ -61,7 +69,7 @@ function init() {
     container.appendChild(stats.dom);
 
     // Resize border allows the user to easily compare effects of logarithmic depth buffer over the whole scene
-    border = document.getElementById('renderer_border');
+    border = document.getElementById('renderer_border')!;
     border.addEventListener('pointerdown', onBorderPointerDown);
 
     window.addEventListener('mousemove', onMouseMove);
@@ -69,8 +77,8 @@ function init() {
     window.addEventListener('wheel', onMouseWheel);
 }
 
-function initView(scene, name, logDepthBuf) {
-    const framecontainer = document.getElementById('container_' + name);
+function initView(scene: THREE.Scene, name: string, logDepthBuf: boolean) {
+    const framecontainer = document.getElementById('container_' + name)!;
 
     const camera = new THREE.PerspectiveCamera(50, (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT, NEAR, FAR);
     scene.add(camera);
@@ -85,7 +93,7 @@ function initView(scene, name, logDepthBuf) {
     return { container: framecontainer, renderer: renderer, scene: scene, camera: camera };
 }
 
-function initScene(font) {
+function initScene(font: Font) {
     const scene = new THREE.Scene();
 
     scene.add(new THREE.AmbientLight(0x777777));
@@ -94,7 +102,7 @@ function initScene(font) {
     light.position.set(100, 100, 100);
     scene.add(light);
 
-    const materialargs = {
+    const materialargs: { color: THREE.ColorRepresentation; specular: number; shininess: number; emissive: number } = {
         color: 0xffffff,
         specular: 0x050505,
         shininess: 50,
@@ -115,7 +123,7 @@ function initScene(font) {
         labelgeo.computeBoundingSphere();
 
         // center text
-        labelgeo.translate(-labelgeo.boundingSphere.radius, 0, 0);
+        labelgeo.translate(-labelgeo.boundingSphere!.radius, 0, 0);
 
         materialargs.color = new THREE.Color().setHSL(Math.random(), 0.5, 0.5);
 
@@ -148,16 +156,16 @@ function updateRendererSizes() {
 
     screensplit_right = 1 - screensplit;
 
-    objects.normal.renderer.setSize(screensplit * SCREEN_WIDTH, SCREEN_HEIGHT);
-    objects.normal.camera.aspect = (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT;
-    objects.normal.camera.updateProjectionMatrix();
-    objects.normal.camera.setViewOffset(SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT);
-    objects.normal.container.style.width = screensplit * 100 + '%';
+    objects.normal!.renderer.setSize(screensplit * SCREEN_WIDTH, SCREEN_HEIGHT);
+    objects.normal!.camera.aspect = (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT;
+    objects.normal!.camera.updateProjectionMatrix();
+    objects.normal!.camera.setViewOffset(SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT);
+    objects.normal!.container.style.width = screensplit * 100 + '%';
 
-    objects.logzbuf.renderer.setSize(screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT);
-    objects.logzbuf.camera.aspect = (screensplit_right * SCREEN_WIDTH) / SCREEN_HEIGHT;
-    objects.logzbuf.camera.updateProjectionMatrix();
-    objects.logzbuf.camera.setViewOffset(
+    objects.logzbuf!.renderer.setSize(screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT);
+    objects.logzbuf!.camera.aspect = (screensplit_right * SCREEN_WIDTH) / SCREEN_HEIGHT;
+    objects.logzbuf!.camera.updateProjectionMatrix();
+    objects.logzbuf!.camera.setViewOffset(
         SCREEN_WIDTH,
         SCREEN_HEIGHT,
         SCREEN_WIDTH * screensplit,
@@ -165,7 +173,7 @@ function updateRendererSizes() {
         SCREEN_WIDTH * screensplit_right,
         SCREEN_HEIGHT,
     );
-    objects.logzbuf.container.style.width = screensplit_right * 100 + '%';
+    objects.logzbuf!.container.style.width = screensplit_right * 100 + '%';
 
     border.style.left = screensplit * 100 + '%';
 }
@@ -193,22 +201,22 @@ function render() {
     zoompos += zoomspeed;
     zoomspeed *= damping;
 
-    objects.normal.camera.position.x = Math.sin(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
-    objects.normal.camera.position.y = Math.sin(0.25 * Math.PI * (mouse[1] - 0.5)) * zoom;
-    objects.normal.camera.position.z = Math.cos(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
-    objects.normal.camera.lookAt(objects.normal.scene.position);
+    objects.normal!.camera.position.x = Math.sin(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
+    objects.normal!.camera.position.y = Math.sin(0.25 * Math.PI * (mouse[1] - 0.5)) * zoom;
+    objects.normal!.camera.position.z = Math.cos(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
+    objects.normal!.camera.lookAt(objects.normal!.scene.position);
 
     // Clone camera settings across both scenes
-    objects.logzbuf.camera.position.copy(objects.normal.camera.position);
-    objects.logzbuf.camera.quaternion.copy(objects.normal.camera.quaternion);
+    objects.logzbuf!.camera.position.copy(objects.normal!.camera.position);
+    objects.logzbuf!.camera.quaternion.copy(objects.normal!.camera.quaternion);
 
     // Update renderer sizes if the split has changed
     if (screensplit_right != 1 - screensplit) {
         updateRendererSizes();
     }
 
-    objects.normal.renderer.render(objects.normal.scene, objects.normal.camera);
-    objects.logzbuf.renderer.render(objects.logzbuf.scene, objects.logzbuf.camera);
+    objects.normal!.renderer.render(objects.normal!.scene, objects.normal!.camera);
+    objects.logzbuf!.renderer.render(objects.logzbuf!.scene, objects.logzbuf!.camera);
 
     stats.update();
 }
@@ -223,7 +231,7 @@ function onBorderPointerDown() {
     window.addEventListener('pointerup', onBorderPointerUp);
 }
 
-function onBorderPointerMove(ev) {
+function onBorderPointerMove(ev: PointerEvent) {
     screensplit = Math.max(0, Math.min(1, ev.clientX / window.innerWidth));
 }
 
@@ -232,12 +240,12 @@ function onBorderPointerUp() {
     window.removeEventListener('pointerup', onBorderPointerUp);
 }
 
-function onMouseMove(ev) {
+function onMouseMove(ev: MouseEvent) {
     mouse[0] = ev.clientX / window.innerWidth;
     mouse[1] = ev.clientY / window.innerHeight;
 }
 
-function onMouseWheel(ev) {
+function onMouseWheel(ev: WheelEvent) {
     const amount = ev.deltaY;
     if (amount === 0) return;
     const dir = amount / Math.abs(amount);
diff --git a/examples-testing/examples/webgl_clipping.ts b/examples-testing/examples/webgl_clipping.ts
index f0a18f3..754f7ce 100644
--- a/examples-testing/examples/webgl_clipping.ts
+++ b/examples-testing/examples/webgl_clipping.ts
@@ -5,7 +5,12 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, startTime, object, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    startTime: number,
+    object: THREE.Mesh,
+    stats: Stats;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_clipping_advanced.ts b/examples-testing/examples/webgl_clipping_advanced.ts
index d60532c..ccc98e6 100644
--- a/examples-testing/examples/webgl_clipping_advanced.ts
+++ b/examples-testing/examples/webgl_clipping_advanced.ts
@@ -5,7 +5,7 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-function planesFromMesh(vertices, indices) {
+function planesFromMesh(vertices: THREE.Vector3[], indices: number[]) {
     // creates a clipping volume from a convex triangular mesh
     // specified by the arrays 'vertices' and 'indices'
 
@@ -23,23 +23,23 @@ function planesFromMesh(vertices, indices) {
     return result;
 }
 
-function createPlanes(n) {
+function createPlanes(n: number) {
     // creates an array of n uninitialized plane objects
 
-    const result = new Array(n);
+    const result = new Array<THREE.Plane>(n);
 
     for (let i = 0; i !== n; ++i) result[i] = new THREE.Plane();
 
     return result;
 }
 
-function assignTransformedPlanes(planesOut, planesIn, matrix) {
+function assignTransformedPlanes(planesOut: THREE.Plane[], planesIn: THREE.Plane[], matrix: THREE.Matrix4) {
     // sets an array of existing planes to transformed 'planesIn'
 
     for (let i = 0, n = planesIn.length; i !== n; ++i) planesOut[i].copy(planesIn[i]).applyMatrix4(matrix);
 }
 
-function cylindricalPlanes(n, innerRadius) {
+function cylindricalPlanes(n: number, innerRadius: number) {
     const result = createPlanes(n);
 
     for (let i = 0; i !== n; ++i) {
@@ -62,7 +62,7 @@ const planeToMatrix = (function () {
         yAxis = new THREE.Vector3(),
         trans = new THREE.Vector3();
 
-    return function planeToMatrix(plane) {
+    return function planeToMatrix(plane: THREE.Plane) {
         const zAxis = plane.normal,
             matrix = new THREE.Matrix4();
 
@@ -113,7 +113,15 @@ const Vertices = [
     GlobalClippingPlanes = cylindricalPlanes(5, 2.5),
     Empty = Object.freeze([]);
 
-let camera, scene, renderer, startTime, stats, object, clipMaterial, volumeVisualization, globalClippingPlanes;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    startTime: number,
+    stats: Stats,
+    object: THREE.Group,
+    clipMaterial: THREE.MeshPhongMaterial,
+    volumeVisualization: THREE.Group,
+    globalClippingPlanes: THREE.Plane[];
 
 function init() {
     camera = new THREE.PerspectiveCamera(36, window.innerWidth / window.innerHeight, 0.25, 16);
@@ -306,12 +314,12 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function setObjectWorldMatrix(object, matrix) {
+function setObjectWorldMatrix(object: THREE.Object3D, matrix: THREE.Matrix4) {
     // set the orientation of an object based on a world matrix
 
     const parent = object.parent;
     scene.updateMatrixWorld();
-    object.matrix.copy(parent.matrixWorld).invert();
+    object.matrix.copy(parent!.matrixWorld).invert();
     object.applyMatrix4(matrix);
 }
 
diff --git a/examples-testing/examples/webgl_clipping_intersection.ts b/examples-testing/examples/webgl_clipping_intersection.ts
index 74022d7..6835776 100644
--- a/examples-testing/examples/webgl_clipping_intersection.ts
+++ b/examples-testing/examples/webgl_clipping_intersection.ts
@@ -4,7 +4,7 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const params = {
     clipIntersection: true,
@@ -82,7 +82,7 @@ function init() {
             const children = group.children;
 
             for (let i = 0; i < children.length; i++) {
-                children[i].material.clipIntersection = value;
+                ((children[i] as THREE.Mesh).material as THREE.Material).clipIntersection = value;
             }
 
             render();
diff --git a/examples-testing/examples/webgl_clipping_stencil.ts b/examples-testing/examples/webgl_clipping_stencil.ts
index 365087d..9dd56a1 100644
--- a/examples-testing/examples/webgl_clipping_stencil.ts
+++ b/examples-testing/examples/webgl_clipping_stencil.ts
@@ -3,9 +3,13 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, object, stats;
-let planes, planeObjects, planeHelpers;
-let clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    object: THREE.Group,
+    stats: Stats;
+let planes: THREE.Plane[], planeObjects: THREE.Mesh[], planeHelpers: THREE.PlaneHelper[];
+let clock: THREE.Clock;
 
 const params = {
     animate: true,
@@ -29,7 +33,7 @@ const params = {
 init();
 animate();
 
-function createPlaneStencilGroup(geometry, plane, renderOrder) {
+function createPlaneStencilGroup(geometry: THREE.TorusKnotGeometry, plane: THREE.Plane, renderOrder: number) {
     const group = new THREE.Group();
     const baseMat = new THREE.MeshBasicMaterial();
     baseMat.depthWrite = false;
diff --git a/examples-testing/examples/webgl_custom_attributes.ts b/examples-testing/examples/webgl_custom_attributes.ts
index 648e097..98d024c 100644
--- a/examples-testing/examples/webgl_custom_attributes.ts
+++ b/examples-testing/examples/webgl_custom_attributes.ts
@@ -2,11 +2,16 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let sphere, uniforms;
+let sphere: THREE.Mesh,
+    uniforms: {
+        amplitude: THREE.IUniform<number>;
+        color: THREE.IUniform<THREE.Color>;
+        colorTexture: THREE.IUniform<THREE.Texture>;
+    };
 
-let displacement, noise;
+let displacement: Float32Array, noise: Float32Array;
 
 init();
 animate();
@@ -28,8 +33,8 @@ function init() {
 
     const shaderMaterial = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
     });
 
     const radius = 50,
@@ -54,7 +59,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_custom_attributes_lines.ts b/examples-testing/examples/webgl_custom_attributes_lines.ts
index 29b8a06..9217e11 100644
--- a/examples-testing/examples/webgl_custom_attributes_lines.ts
+++ b/examples-testing/examples/webgl_custom_attributes_lines.ts
@@ -1,13 +1,18 @@
 import * as THREE from 'three';
 
-import { FontLoader } from 'three/addons/loaders/FontLoader.js';
+import { Font, FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let line, uniforms;
+let line: THREE.Line,
+    uniforms: {
+        amplitude: THREE.IUniform<number>;
+        opacity: THREE.IUniform<number>;
+        color: THREE.IUniform<THREE.Color>;
+    };
 
 const loader = new FontLoader();
 loader.load('fonts/helvetiker_bold.typeface.json', function (font) {
@@ -15,7 +20,7 @@ loader.load('fonts/helvetiker_bold.typeface.json', function (font) {
     animate();
 });
 
-function init(font) {
+function init(font: Font) {
     camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 400;
 
@@ -30,8 +35,8 @@ function init(font) {
 
     const shaderMaterial = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
         blending: THREE.AdditiveBlending,
         depthTest: false,
         transparent: true,
@@ -75,7 +80,7 @@ function init(font) {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_custom_attributes_points.ts b/examples-testing/examples/webgl_custom_attributes_points.ts
index f1cfedc..a6ec206 100644
--- a/examples-testing/examples/webgl_custom_attributes_points.ts
+++ b/examples-testing/examples/webgl_custom_attributes_points.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let sphere;
+let sphere: THREE.Points;
 
 const WIDTH = window.innerWidth;
 const HEIGHT = window.innerHeight;
@@ -57,8 +57,8 @@ function init() {
             color: { value: new THREE.Color(0xffffff) },
             pointTexture: { value: new THREE.TextureLoader().load('textures/sprites/spark1.png') },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
 
         blending: THREE.AdditiveBlending,
         depthTest: false,
@@ -76,7 +76,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(WIDTH, HEIGHT);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_custom_attributes_points2.ts b/examples-testing/examples/webgl_custom_attributes_points2.ts
index f744a1e..d3b5cc2 100644
--- a/examples-testing/examples/webgl_custom_attributes_points2.ts
+++ b/examples-testing/examples/webgl_custom_attributes_points2.ts
@@ -4,8 +4,8 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let renderer, scene, camera, stats;
-let sphere, length1;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
+let sphere: THREE.Points, length1: number;
 
 const WIDTH = window.innerWidth;
 const HEIGHT = window.innerHeight;
@@ -23,8 +23,8 @@ function init() {
         segments = 68,
         rings = 38;
 
-    let sphereGeometry = new THREE.SphereGeometry(radius, segments, rings);
-    let boxGeometry = new THREE.BoxGeometry(0.8 * radius, 0.8 * radius, 0.8 * radius, 10, 10, 10);
+    let sphereGeometry: THREE.BufferGeometry = new THREE.SphereGeometry(radius, segments, rings);
+    let boxGeometry: THREE.BufferGeometry = new THREE.BoxGeometry(0.8 * radius, 0.8 * radius, 0.8 * radius, 10, 10, 10);
 
     // if normal and uv attributes are not removed, mergeVertices() can't consolidate identical vertices with different normal/uv data
 
@@ -40,8 +40,8 @@ function init() {
     const combinedGeometry = BufferGeometryUtils.mergeGeometries([sphereGeometry, boxGeometry]);
     const positionAttribute = combinedGeometry.getAttribute('position');
 
-    const colors = [];
-    const sizes = [];
+    const colors: number[] = [];
+    const sizes: number[] = [];
 
     const color = new THREE.Color();
     const vertex = new THREE.Vector3();
@@ -78,8 +78,8 @@ function init() {
             color: { value: new THREE.Color(0xffffff) },
             pointTexture: { value: texture },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
         transparent: true,
     });
 
@@ -94,7 +94,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(WIDTH, HEIGHT);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
@@ -150,7 +150,7 @@ function sortPoints() {
         sortArray.push([vector.z, i]);
     }
 
-    function numericalSort(a, b) {
+    function numericalSort(a: number[], b: number[]) {
         return b[0] - a[0];
     }
 
@@ -162,7 +162,7 @@ function sortPoints() {
         indices[i] = sortArray[i][1];
     }
 
-    geometry.index.needsUpdate = true;
+    geometry.index!.needsUpdate = true;
 }
 
 function animate() {
diff --git a/examples-testing/examples/webgl_custom_attributes_points3.ts b/examples-testing/examples/webgl_custom_attributes_points3.ts
index 1ef2f1f..fc34046 100644
--- a/examples-testing/examples/webgl_custom_attributes_points3.ts
+++ b/examples-testing/examples/webgl_custom_attributes_points3.ts
@@ -4,11 +4,11 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let object;
+let object: THREE.Points;
 
-let vertices1;
+let vertices1: number;
 
 const WIDTH = window.innerWidth;
 const HEIGHT = window.innerHeight;
@@ -48,7 +48,7 @@ function init() {
 
     radius = 200;
 
-    let boxGeometry1 = new THREE.BoxGeometry(radius, 0.1 * radius, 0.1 * radius, 50, 5, 5);
+    let boxGeometry1: THREE.BufferGeometry = new THREE.BoxGeometry(radius, 0.1 * radius, 0.1 * radius, 50, 5, 5);
 
     // if normal and uv attributes are not removed, mergeVertices() can't consolidate indentical vertices with different normal/uv data
 
@@ -63,7 +63,7 @@ function init() {
     const quaternion = new THREE.Quaternion();
     const scale = new THREE.Vector3(1, 1, 1);
 
-    function addGeo(geo, x, y, z, ry) {
+    function addGeo(geo: THREE.BufferGeometry, x: number, y: number, z: number, ry: number) {
         position.set(x, y, z);
         rotation.set(0, ry, 0);
 
@@ -94,7 +94,7 @@ function init() {
 
     // corner edges
 
-    let boxGeometry2 = new THREE.BoxGeometry(0.1 * radius, radius * 1.2, 0.1 * radius, 5, 60, 5);
+    let boxGeometry2: THREE.BufferGeometry = new THREE.BoxGeometry(0.1 * radius, radius * 1.2, 0.1 * radius, 5, 60, 5);
 
     boxGeometry2.deleteAttribute('normal');
     boxGeometry2.deleteAttribute('uv');
@@ -108,8 +108,8 @@ function init() {
 
     const positionAttribute = new THREE.Float32BufferAttribute(vertices, 3);
 
-    const colors = [];
-    const sizes = [];
+    const colors: number[] = [];
+    const sizes: number[] = [];
 
     const color = new THREE.Color();
 
@@ -142,8 +142,8 @@ function init() {
             color: { value: new THREE.Color(0xffffff) },
             pointTexture: { value: texture },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
     });
 
     //
@@ -157,7 +157,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(WIDTH, HEIGHT);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_decals.ts b/examples-testing/examples/webgl_decals.ts
index 975463c..d1ffa77 100644
--- a/examples-testing/examples/webgl_decals.ts
+++ b/examples-testing/examples/webgl_decals.ts
@@ -7,12 +7,12 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';
 
-const container = document.getElementById('container');
+const container = document.getElementById('container')!;
 
-let renderer, scene, camera, stats;
-let mesh;
-let raycaster;
-let line;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
+let mesh: THREE.Mesh;
+let raycaster: THREE.Raycaster;
+let line: THREE.Line;
 
 const intersection = {
     intersects: false,
@@ -20,7 +20,7 @@ const intersection = {
     normal: new THREE.Vector3(),
 };
 const mouse = new THREE.Vector2();
-const intersects = [];
+const intersects: THREE.Intersection[] = [];
 
 const textureLoader = new THREE.TextureLoader();
 const decalDiffuse = textureLoader.load('textures/decal/decal-diffuse.png');
@@ -41,8 +41,8 @@ const decalMaterial = new THREE.MeshPhongMaterial({
     wireframe: false,
 });
 
-const decals = [];
-let mouseHelper;
+const decals: THREE.Mesh[] = [];
+let mouseHelper: THREE.Mesh;
 const position = new THREE.Vector3();
 const orientation = new THREE.Euler();
 const size = new THREE.Vector3(10, 10, 10);
@@ -123,13 +123,13 @@ function init() {
 
     window.addEventListener('pointermove', onPointerMove);
 
-    function onPointerMove(event) {
+    function onPointerMove(event: PointerEvent) {
         if (event.isPrimary) {
             checkIntersection(event.clientX, event.clientY);
         }
     }
 
-    function checkIntersection(x, y) {
+    function checkIntersection(x: number, y: number) {
         if (mesh === undefined) return;
 
         mouse.x = (x / window.innerWidth) * 2 - 1;
@@ -143,12 +143,12 @@ function init() {
             mouseHelper.position.copy(p);
             intersection.point.copy(p);
 
-            const n = intersects[0].face.normal.clone();
+            const n = intersects[0].face!.normal.clone();
             n.transformDirection(mesh.matrixWorld);
             n.multiplyScalar(10);
             n.add(intersects[0].point);
 
-            intersection.normal.copy(intersects[0].face.normal);
+            intersection.normal.copy(intersects[0].face!.normal);
             mouseHelper.lookAt(n);
 
             const positions = line.geometry.attributes.position;
@@ -182,7 +182,7 @@ function loadLeePerrySmith() {
     const loader = new GLTFLoader();
 
     loader.load('models/gltf/LeePerrySmith/LeePerrySmith.glb', function (gltf) {
-        mesh = gltf.scene.children[0];
+        mesh = gltf.scene.children[0] as THREE.Mesh;
         mesh.material = new THREE.MeshPhongMaterial({
             specular: 0x111111,
             map: map,
diff --git a/examples-testing/examples/webgl_effects_anaglyph.ts b/examples-testing/examples/webgl_effects_anaglyph.ts
index 5132963..af1bb7f 100644
--- a/examples-testing/examples/webgl_effects_anaglyph.ts
+++ b/examples-testing/examples/webgl_effects_anaglyph.ts
@@ -2,9 +2,13 @@ import * as THREE from 'three';
 
 import { AnaglyphEffect } from 'three/addons/effects/AnaglyphEffect.js';
 
-let container, camera, scene, renderer, effect;
+let container: HTMLDivElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    effect: AnaglyphEffect;
 
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
 let mouseX = 0;
 let mouseY = 0;
@@ -84,7 +88,7 @@ function onWindowResize() {
     effect.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) / 100;
     mouseY = (event.clientY - windowHalfY) / 100;
 }
diff --git a/examples-testing/examples/webgl_effects_ascii.ts b/examples-testing/examples/webgl_effects_ascii.ts
index 60b7de8..6e546c4 100644
--- a/examples-testing/examples/webgl_effects_ascii.ts
+++ b/examples-testing/examples/webgl_effects_ascii.ts
@@ -3,9 +3,13 @@ import * as THREE from 'three';
 import { AsciiEffect } from 'three/addons/effects/AsciiEffect.js';
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 
-let camera, controls, scene, renderer, effect;
+let camera: THREE.PerspectiveCamera,
+    controls: TrackballControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    effect: AsciiEffect;
 
-let sphere, plane;
+let sphere: THREE.Mesh, plane: THREE.Mesh;
 
 const start = Date.now();
 
diff --git a/examples-testing/examples/webgl_effects_parallaxbarrier.ts b/examples-testing/examples/webgl_effects_parallaxbarrier.ts
index 45e7491..f6ed13c 100644
--- a/examples-testing/examples/webgl_effects_parallaxbarrier.ts
+++ b/examples-testing/examples/webgl_effects_parallaxbarrier.ts
@@ -2,9 +2,13 @@ import * as THREE from 'three';
 
 import { ParallaxBarrierEffect } from 'three/addons/effects/ParallaxBarrierEffect.js';
 
-let container, camera, scene, renderer, effect;
+let container: HTMLDivElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    effect: ParallaxBarrierEffect;
 
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
 let mouseX = 0;
 let mouseY = 0;
@@ -84,7 +88,7 @@ function onWindowResize() {
     effect.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) / 100;
     mouseY = (event.clientY - windowHalfY) / 100;
 }
diff --git a/examples-testing/examples/webgl_effects_peppersghost.ts b/examples-testing/examples/webgl_effects_peppersghost.ts
index 90cfe01..314b24c 100644
--- a/examples-testing/examples/webgl_effects_peppersghost.ts
+++ b/examples-testing/examples/webgl_effects_peppersghost.ts
@@ -2,10 +2,10 @@ import * as THREE from 'three';
 
 import { PeppersGhostEffect } from 'three/addons/effects/PeppersGhostEffect.js';
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer, effect;
-let group;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, effect: PeppersGhostEffect;
+let group: THREE.Group;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_effects_stereo.ts b/examples-testing/examples/webgl_effects_stereo.ts
index 4db7184..a5457e3 100644
--- a/examples-testing/examples/webgl_effects_stereo.ts
+++ b/examples-testing/examples/webgl_effects_stereo.ts
@@ -2,9 +2,13 @@ import * as THREE from 'three';
 
 import { StereoEffect } from 'three/addons/effects/StereoEffect.js';
 
-let container, camera, scene, renderer, effect;
+let container: HTMLDivElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    effect: StereoEffect;
 
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
 let mouseX = 0,
     mouseY = 0;
@@ -73,7 +77,7 @@ function onWindowResize() {
     effect.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) * 10;
     mouseY = (event.clientY - windowHalfY) * 10;
 }
diff --git a/examples-testing/examples/webgl_framebuffer_texture.ts b/examples-testing/examples/webgl_framebuffer_texture.ts
index 379737f..5f4095f 100644
--- a/examples-testing/examples/webgl_framebuffer_texture.ts
+++ b/examples-testing/examples/webgl_framebuffer_texture.ts
@@ -3,10 +3,10 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';
 
-let camera, scene, renderer;
-let line, sprite, texture;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let line: THREE.Line, sprite: THREE.Sprite, texture: THREE.FramebufferTexture;
 
-let cameraOrtho, sceneOrtho;
+let cameraOrtho: THREE.OrthographicCamera, sceneOrtho: THREE.Scene;
 
 let offset = 0;
 
@@ -76,7 +76,7 @@ function init() {
 
     //
 
-    const selection = document.getElementById('selection');
+    const selection = document.getElementById('selection')!;
     const controls = new OrbitControls(camera, selection);
     controls.enablePan = false;
 
@@ -135,7 +135,7 @@ function animate() {
     renderer.render(sceneOrtho, cameraOrtho);
 }
 
-function updateColors(colorAttribute) {
+function updateColors(colorAttribute: THREE.BufferAttribute | THREE.InterleavedBufferAttribute) {
     const l = colorAttribute.count;
 
     for (let i = 0; i < l; i++) {
diff --git a/examples-testing/examples/webgl_furnace_test.ts b/examples-testing/examples/webgl_furnace_test.ts
index a819541..46230b4 100644
--- a/examples-testing/examples/webgl_furnace_test.ts
+++ b/examples-testing/examples/webgl_furnace_test.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three';
 
-let scene, camera, renderer, radianceMap;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, radianceMap: THREE.Texture;
 
 const COLOR = 0xcccccc;
 
@@ -20,7 +20,8 @@ function init() {
 
     document.body.addEventListener('mouseover', function () {
         scene.traverse(function (child) {
-            if (child.isMesh) child.material.color.setHex(0xffffff);
+            if ((child as THREE.Mesh).isMesh)
+                ((child as THREE.Mesh).material as THREE.MeshStandardMaterial).color.setHex(0xffffff);
         });
 
         render();
@@ -28,7 +29,8 @@ function init() {
 
     document.body.addEventListener('mouseout', function () {
         scene.traverse(function (child) {
-            if (child.isMesh) child.material.color.setHex(0xccccff); // tinted for visibility
+            if ((child as THREE.Mesh).isMesh)
+                ((child as THREE.Mesh).material as THREE.MeshStandardMaterial).color.setHex(0xccccff); // tinted for visibility
         });
 
         render();
diff --git a/examples-testing/examples/webgl_geometries.ts b/examples-testing/examples/webgl_geometries.ts
index 154164e..ab4961b 100644
--- a/examples-testing/examples/webgl_geometries.ts
+++ b/examples-testing/examples/webgl_geometries.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 animate();
@@ -129,7 +129,7 @@ function render() {
     camera.lookAt(scene.position);
 
     scene.traverse(function (object) {
-        if (object.isMesh === true) {
+        if ((object as THREE.Mesh).isMesh === true) {
             object.rotation.x = timer * 5;
             object.rotation.y = timer * 2.5;
         }
diff --git a/examples-testing/examples/webgl_geometries_parametric.ts b/examples-testing/examples/webgl_geometries_parametric.ts
index 8aa86c3..ea8662c 100644
--- a/examples-testing/examples/webgl_geometries_parametric.ts
+++ b/examples-testing/examples/webgl_geometries_parametric.ts
@@ -6,13 +6,13 @@ import * as Curves from 'three/addons/curves/CurveExtras.js';
 import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';
 import { ParametricGeometries } from 'three/addons/geometries/ParametricGeometries.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
     camera.position.y = 400;
@@ -116,7 +116,7 @@ function render() {
     camera.lookAt(scene.position);
 
     scene.traverse(function (object) {
-        if (object.isMesh === true) {
+        if ((object as THREE.Mesh).isMesh === true) {
             object.rotation.x = timer * 5;
             object.rotation.y = timer * 2.5;
         }
diff --git a/examples-testing/examples/webgl_geometry_colors.ts b/examples-testing/examples/webgl_geometry_colors.ts
index 7acc60f..836e466 100644
--- a/examples-testing/examples/webgl_geometry_colors.ts
+++ b/examples-testing/examples/webgl_geometry_colors.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let mouseX = 0,
     mouseY = 0;
@@ -16,7 +16,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 1800;
@@ -34,7 +34,7 @@ function init() {
     canvas.width = 128;
     canvas.height = 128;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     const gradient = context.createRadialGradient(
         canvas.width / 2,
         canvas.height / 2,
@@ -154,7 +154,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgl_geometry_colors_lookuptable.ts b/examples-testing/examples/webgl_geometry_colors_lookuptable.ts
index 6b01385..382a9b7 100644
--- a/examples-testing/examples/webgl_geometry_colors_lookuptable.ts
+++ b/examples-testing/examples/webgl_geometry_colors_lookuptable.ts
@@ -5,19 +5,19 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Lut } from 'three/addons/math/Lut.js';
 
-let container;
+let container: HTMLElement;
 
-let perpCamera, orthoCamera, renderer, lut;
+let perpCamera: THREE.PerspectiveCamera, orthoCamera: THREE.OrthographicCamera, renderer: THREE.WebGLRenderer, lut: Lut;
 
-let mesh, sprite;
-let scene, uiScene;
+let mesh: THREE.Mesh, sprite: THREE.Sprite;
+let scene: THREE.Scene, uiScene: THREE.Scene;
 
-let params;
+let params: { colorMap: string };
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
     scene.background = new THREE.Color(0xffffff);
@@ -41,7 +41,7 @@ function init() {
             map: new THREE.CanvasTexture(lut.createCanvas()),
         }),
     );
-    sprite.material.map.colorSpace = THREE.SRGBColorSpace;
+    sprite.material.map!.colorSpace = THREE.SRGBColorSpace;
     sprite.scale.x = 0.125;
     uiScene.add(sprite);
 
@@ -142,7 +142,7 @@ function updateColors() {
 
     colors.needsUpdate = true;
 
-    const map = sprite.material.map;
+    const map = sprite.material.map!;
     lut.updateCanvas(map.image);
     map.needsUpdate = true;
 }
diff --git a/examples-testing/examples/webgl_geometry_convex.ts b/examples-testing/examples/webgl_geometry_convex.ts
index b033036..38eecb8 100644
--- a/examples-testing/examples/webgl_geometry_convex.ts
+++ b/examples-testing/examples/webgl_geometry_convex.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let group, camera, scene, renderer;
+let group: THREE.Group, camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -54,7 +54,7 @@ function init() {
 
     // points
 
-    let dodecahedronGeometry = new THREE.DodecahedronGeometry(10);
+    let dodecahedronGeometry: THREE.BufferGeometry = new THREE.DodecahedronGeometry(10);
 
     // if normal and uv attributes are not removed, mergeVertices() can't consolidate indentical vertices with different normal/uv data
 
diff --git a/examples-testing/examples/webgl_geometry_cube.ts b/examples-testing/examples/webgl_geometry_cube.ts
index bf22fcb..71a3610 100644
--- a/examples-testing/examples/webgl_geometry_cube.ts
+++ b/examples-testing/examples/webgl_geometry_cube.ts
@@ -1,7 +1,7 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
-let mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mesh: THREE.Mesh;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_geometry_dynamic.ts b/examples-testing/examples/webgl_geometry_dynamic.ts
index ccbaa6b..b9307ac 100644
--- a/examples-testing/examples/webgl_geometry_dynamic.ts
+++ b/examples-testing/examples/webgl_geometry_dynamic.ts
@@ -4,9 +4,13 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
 
-let camera, controls, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera,
+    controls: FirstPersonControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats;
 
-let mesh, geometry, material, clock;
+let mesh: THREE.Mesh, geometry: THREE.PlaneGeometry, material: THREE.MeshBasicMaterial, clock: THREE.Clock;
 
 const worldWidth = 128,
     worldDepth = 128;
@@ -27,7 +31,7 @@ function init() {
     geometry = new THREE.PlaneGeometry(20000, 20000, worldWidth - 1, worldDepth - 1);
     geometry.rotateX(-Math.PI / 2);
 
-    const position = geometry.attributes.position;
+    const position = geometry.attributes.position as THREE.BufferAttribute;
     position.usage = THREE.DynamicDrawUsage;
 
     for (let i = 0; i < position.count; i++) {
diff --git a/examples-testing/examples/webgl_geometry_extrude_shapes.ts b/examples-testing/examples/webgl_geometry_extrude_shapes.ts
index 099b425..a2de450 100644
--- a/examples-testing/examples/webgl_geometry_extrude_shapes.ts
+++ b/examples-testing/examples/webgl_geometry_extrude_shapes.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: TrackballControls;
 
 init();
 animate();
@@ -14,7 +14,7 @@ function init() {
     info.style.width = '100%';
     info.style.textAlign = 'center';
     info.style.color = '#fff';
-    info.style.link = '#f80';
+    (info.style as any).link = '#f80';
     info.innerHTML =
         '<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - geometry extrude shapes';
     document.body.appendChild(info);
diff --git a/examples-testing/examples/webgl_geometry_extrude_splines.ts b/examples-testing/examples/webgl_geometry_extrude_splines.ts
index 370a4d9..bbb481f 100644
--- a/examples-testing/examples/webgl_geometry_extrude_splines.ts
+++ b/examples-testing/examples/webgl_geometry_extrude_splines.ts
@@ -6,9 +6,14 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import * as Curves from 'three/addons/curves/CurveExtras.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer, splineCamera, cameraHelper, cameraEye;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    splineCamera: THREE.PerspectiveCamera,
+    cameraHelper: THREE.CameraHelper,
+    cameraEye: THREE.Mesh;
 
 const direction = new THREE.Vector3();
 const binormal = new THREE.Vector3();
@@ -78,9 +83,18 @@ const splines = {
     SampleClosedSpline: sampleClosedSpline,
 };
 
-let parent, tubeGeometry, mesh;
-
-const params = {
+let parent: THREE.Object3D, tubeGeometry: THREE.TubeGeometry, mesh: THREE.Mesh;
+
+const params: {
+    spline: keyof typeof splines;
+    scale: number;
+    extrusionSegments: number;
+    radiusSegments: number;
+    closed: boolean;
+    animationView: boolean;
+    lookAhead: boolean;
+    cameraHelper: boolean;
+} = {
     spline: 'GrannyKnot',
     scale: 4,
     extrusionSegments: 100,
@@ -125,7 +139,7 @@ function setScale() {
     mesh.scale.set(params.scale, params.scale, params.scale);
 }
 
-function addGeometry(geometry) {
+function addGeometry(geometry: THREE.BufferGeometry) {
     // 3D shape
 
     mesh = new THREE.Mesh(geometry, material);
@@ -144,7 +158,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     // camera
 
@@ -202,7 +216,7 @@ function init() {
     const gui = new GUI({ width: 285 });
 
     const folderGeometry = gui.addFolder('Geometry');
-    folderGeometry.add(params, 'spline', Object.keys(splines)).onChange(function () {
+    folderGeometry.add(params, 'spline', Object.keys(splines) as (keyof typeof splines)[]).onChange(function () {
         addTube();
     });
     folderGeometry
diff --git a/examples-testing/examples/webgl_geometry_minecraft.ts b/examples-testing/examples/webgl_geometry_minecraft.ts
index 537d8d5..bfa97ba 100644
--- a/examples-testing/examples/webgl_geometry_minecraft.ts
+++ b/examples-testing/examples/webgl_geometry_minecraft.ts
@@ -6,9 +6,9 @@ import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.j
 import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: FirstPersonControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const worldWidth = 128,
     worldDepth = 128;
@@ -22,7 +22,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);
     camera.position.y = getY(worldHalfWidth, worldHalfDepth) * 100 + 100;
@@ -143,7 +143,7 @@ function onWindowResize() {
     controls.handleResize();
 }
 
-function generateHeight(width, height) {
+function generateHeight(width: number, height: number) {
     const data = [],
         perlin = new ImprovedNoise(),
         size = width * height,
@@ -166,7 +166,7 @@ function generateHeight(width, height) {
     return data;
 }
 
-function getY(x, z) {
+function getY(x: number, z: number) {
     return (data[x + z * worldWidth] * 0.15) | 0;
 }
 
diff --git a/examples-testing/examples/webgl_geometry_nurbs.ts b/examples-testing/examples/webgl_geometry_nurbs.ts
index 8336ef0..d9c564d 100644
--- a/examples-testing/examples/webgl_geometry_nurbs.ts
+++ b/examples-testing/examples/webgl_geometry_nurbs.ts
@@ -6,10 +6,10 @@ import { NURBSCurve } from 'three/addons/curves/NURBSCurve.js';
 import { NURBSSurface } from 'three/addons/curves/NURBSSurface.js';
 import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
-let group;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let group: THREE.Group;
 
 let targetRotation = 0;
 let targetRotationOnPointerDown = 0;
@@ -78,7 +78,7 @@ function init() {
     group.add(nurbsLine);
 
     const nurbsControlPointsGeometry = new THREE.BufferGeometry();
-    nurbsControlPointsGeometry.setFromPoints(nurbsCurve.controlPoints);
+    nurbsControlPointsGeometry.setFromPoints(nurbsCurve.controlPoints as THREE.Vector3[]);
 
     const nurbsControlPointsMaterial = new THREE.LineBasicMaterial({
         color: 0x333333,
@@ -123,7 +123,7 @@ function init() {
     map.anisotropy = 16;
     map.colorSpace = THREE.SRGBColorSpace;
 
-    function getSurfacePoint(u, v, target) {
+    function getSurfacePoint(u: number, v: number, target: THREE.Vector3) {
         return nurbsSurface.getPoint(u, v, target);
     }
 
@@ -163,7 +163,7 @@ function onWindowResize() {
 
 //
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerXOnPointerDown = event.clientX - windowHalfX;
@@ -173,7 +173,7 @@ function onPointerDown(event) {
     document.addEventListener('pointerup', onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerX = event.clientX - windowHalfX;
@@ -181,7 +181,7 @@ function onPointerMove(event) {
     targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
 }
 
-function onPointerUp() {
+function onPointerUp(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     document.removeEventListener('pointermove', onPointerMove);
diff --git a/examples-testing/examples/webgl_geometry_shapes.ts b/examples-testing/examples/webgl_geometry_shapes.ts
index c3ff3a7..ff3abca 100644
--- a/examples-testing/examples/webgl_geometry_shapes.ts
+++ b/examples-testing/examples/webgl_geometry_shapes.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let group;
+let group: THREE.Group;
 
 let targetRotation = 0;
 let targetRotationOnPointerDown = 0;
@@ -46,11 +46,22 @@ function init() {
     texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
     texture.repeat.set(0.008, 0.008);
 
-    function addShape(shape, extrudeSettings, color, x, y, z, rx, ry, rz, s) {
+    function addShape(
+        shape: THREE.Shape,
+        extrudeSettings: THREE.ExtrudeGeometryOptions,
+        color: number,
+        x: number,
+        y: number,
+        z: number,
+        rx: number,
+        ry: number,
+        rz: number,
+        s: number,
+    ) {
         // flat shape with texture
         // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices
 
-        let geometry = new THREE.ShapeGeometry(shape);
+        let geometry: THREE.BufferGeometry = new THREE.ShapeGeometry(shape);
 
         let mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ side: THREE.DoubleSide, map: texture }));
         mesh.position.set(x, y, z - 175);
@@ -81,7 +92,17 @@ function init() {
         addLineShape(shape, color, x, y, z, rx, ry, rz, s);
     }
 
-    function addLineShape(shape, color, x, y, z, rx, ry, rz, s) {
+    function addLineShape(
+        shape: THREE.Path,
+        color: number,
+        x: number,
+        y: number,
+        z: number,
+        rx: number,
+        ry: number,
+        rz: number,
+        s: number,
+    ) {
         // lines
 
         shape.autoClose = true;
@@ -325,7 +346,7 @@ function onWindowResize() {
 
 //
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerXOnPointerDown = event.clientX - windowHalfX;
@@ -335,7 +356,7 @@ function onPointerDown(event) {
     document.addEventListener('pointerup', onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerX = event.clientX - windowHalfX;
@@ -343,7 +364,7 @@ function onPointerMove(event) {
     targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
 }
 
-function onPointerUp() {
+function onPointerUp(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     document.removeEventListener('pointermove', onPointerMove);
diff --git a/examples-testing/examples/webgl_geometry_teapot.ts b/examples-testing/examples/webgl_geometry_teapot.ts
index 4c884a5..b94b16d 100644
--- a/examples-testing/examples/webgl_geometry_teapot.ts
+++ b/examples-testing/examples/webgl_geometry_teapot.ts
@@ -5,22 +5,30 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 let cameraControls;
-let effectController;
+let effectController: {
+    newTess: number;
+    bottom: boolean;
+    lid: boolean;
+    body: boolean;
+    fitLid: boolean;
+    nonblinn: boolean;
+    newShading: string;
+};
 const teapotSize = 300;
-let ambientLight, light;
+let ambientLight: THREE.AmbientLight, light: THREE.DirectionalLight;
 
 let tess = -1; // force initialization
-let bBottom;
-let bLid;
-let bBody;
-let bFitLid;
-let bNonBlinn;
-let shading;
-
-let teapot, textureCube;
-const materials = {};
+let bBottom: boolean;
+let bLid: boolean;
+let bBody: boolean;
+let bFitLid: boolean;
+let bNonBlinn: boolean;
+let shading: string;
+
+let teapot: THREE.Mesh, textureCube: THREE.CubeTexture;
+const materials: Record<string, THREE.Material> = {};
 
 init();
 render();
diff --git a/examples-testing/examples/webgl_geometry_terrain.ts b/examples-testing/examples/webgl_geometry_terrain.ts
index b63a363..965d70a 100644
--- a/examples-testing/examples/webgl_geometry_terrain.ts
+++ b/examples-testing/examples/webgl_geometry_terrain.ts
@@ -5,9 +5,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
 import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
 
-let container, stats;
-let camera, controls, scene, renderer;
-let mesh, texture;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, controls: FirstPersonControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mesh: THREE.Mesh, texture: THREE.CanvasTexture;
 
 const worldWidth = 256,
     worldDepth = 256;
@@ -17,7 +17,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
 
@@ -73,7 +73,7 @@ function onWindowResize() {
     controls.handleResize();
 }
 
-function generateHeight(width, height) {
+function generateHeight(width: number, height: number) {
     let seed = Math.PI / 4;
     window.Math.random = function () {
         const x = Math.sin(seed++) * 10000;
@@ -100,7 +100,7 @@ function generateHeight(width, height) {
     return data;
 }
 
-function generateTexture(data, width, height) {
+function generateTexture(data: Uint8Array, width: number, height: number) {
     let context, image, imageData, shade;
 
     const vector3 = new THREE.Vector3(0, 0, 0);
@@ -112,7 +112,7 @@ function generateTexture(data, width, height) {
     canvas.width = width;
     canvas.height = height;
 
-    context = canvas.getContext('2d');
+    context = canvas.getContext('2d')!;
     context.fillStyle = '#000';
     context.fillRect(0, 0, width, height);
 
@@ -140,7 +140,7 @@ function generateTexture(data, width, height) {
     canvasScaled.width = width * 4;
     canvasScaled.height = height * 4;
 
-    context = canvasScaled.getContext('2d');
+    context = canvasScaled.getContext('2d')!;
     context.scale(4, 4);
     context.drawImage(canvas, 0, 0);
 
diff --git a/examples-testing/examples/webgl_geometry_terrain_raycast.ts b/examples-testing/examples/webgl_geometry_terrain_raycast.ts
index 4e9a7d3..86071e3 100644
--- a/examples-testing/examples/webgl_geometry_terrain_raycast.ts
+++ b/examples-testing/examples/webgl_geometry_terrain_raycast.ts
@@ -5,18 +5,18 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh, texture;
+let mesh: THREE.Mesh, texture: THREE.CanvasTexture;
 
 const worldWidth = 256,
     worldDepth = 256,
     worldHalfWidth = worldWidth / 2,
     worldHalfDepth = worldDepth / 2;
 
-let helper;
+let helper: THREE.Mesh;
 
 const raycaster = new THREE.Raycaster();
 const pointer = new THREE.Vector2();
@@ -25,7 +25,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
     container.innerHTML = '';
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -94,7 +94,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function generateHeight(width, height) {
+function generateHeight(width: number, height: number) {
     const size = width * height,
         data = new Uint8Array(size),
         perlin = new ImprovedNoise(),
@@ -115,7 +115,7 @@ function generateHeight(width, height) {
     return data;
 }
 
-function generateTexture(data, width, height) {
+function generateTexture(data: Uint8Array, width: number, height: number) {
     // bake lighting into texture
 
     let context, image, imageData, shade;
@@ -129,7 +129,7 @@ function generateTexture(data, width, height) {
     canvas.width = width;
     canvas.height = height;
 
-    context = canvas.getContext('2d');
+    context = canvas.getContext('2d')!;
     context.fillStyle = '#000';
     context.fillRect(0, 0, width, height);
 
@@ -157,7 +157,7 @@ function generateTexture(data, width, height) {
     canvasScaled.width = width * 4;
     canvasScaled.height = height * 4;
 
-    context = canvasScaled.getContext('2d');
+    context = canvasScaled.getContext('2d')!;
     context.scale(4, 4);
     context.drawImage(canvas, 0, 0);
 
@@ -190,7 +190,7 @@ function render() {
     renderer.render(scene, camera);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
     pointer.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
     raycaster.setFromCamera(pointer, camera);
@@ -201,7 +201,7 @@ function onPointerMove(event) {
     // Toggle rotation bool for meshes that we clicked
     if (intersects.length > 0) {
         helper.position.set(0, 0, 0);
-        helper.lookAt(intersects[0].face.normal);
+        helper.lookAt(intersects[0].face!.normal);
 
         helper.position.copy(intersects[0].point);
     }
diff --git a/examples-testing/examples/webgl_geometry_text.ts b/examples-testing/examples/webgl_geometry_text.ts
index 51a639b..90087e4 100644
--- a/examples-testing/examples/webgl_geometry_text.ts
+++ b/examples-testing/examples/webgl_geometry_text.ts
@@ -1,23 +1,23 @@
 import * as THREE from 'three';
 
-import { FontLoader } from 'three/addons/loaders/FontLoader.js';
+import { Font, FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 THREE.Cache.enabled = true;
 
-let container;
+let container: HTMLDivElement;
 
-let camera, cameraTarget, scene, renderer;
+let camera: THREE.PerspectiveCamera, cameraTarget: THREE.Vector3, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let group, textMesh1, textMesh2, textGeo, materials;
+let group: THREE.Group, textMesh1: THREE.Mesh, textMesh2: THREE.Mesh, textGeo, materials: THREE.MeshPhongMaterial[];
 
 let firstLetter = true;
 
 let text = 'three.js',
     bevelEnabled = true,
-    font = undefined,
+    font: Font | undefined = undefined,
     fontName = 'optimer', // helvetiker, optimer, gentilis, droid sans, droid serif
     fontWeight = 'bold'; // normal bold
 
@@ -43,11 +43,11 @@ const weightMap = {
     bold: 1,
 };
 
-const reverseFontMap = [];
-const reverseWeightMap = [];
+const reverseFontMap: string[] = [];
+const reverseWeightMap: string[] = [];
 
-for (const i in fontMap) reverseFontMap[fontMap[i]] = i;
-for (const i in weightMap) reverseWeightMap[weightMap[i]] = i;
+for (const i in fontMap) reverseFontMap[fontMap[i as keyof typeof fontMap]] = i;
+for (const i in weightMap) reverseWeightMap[weightMap[i as keyof typeof weightMap]] = i;
 
 let targetRotation = 0;
 let targetRotationOnPointerDown = 0;
@@ -180,7 +180,7 @@ function onWindowResize() {
 
 //
 
-function onDocumentKeyDown(event) {
+function onDocumentKeyDown(event: KeyboardEvent) {
     if (firstLetter) {
         firstLetter = false;
         text = '';
@@ -200,7 +200,7 @@ function onDocumentKeyDown(event) {
     }
 }
 
-function onDocumentKeyPress(event) {
+function onDocumentKeyPress(event: KeyboardEvent) {
     const keyCode = event.which;
 
     // backspace
@@ -226,7 +226,7 @@ function loadFont() {
 
 function createText() {
     textGeo = new TextGeometry(text, {
-        font: font,
+        font: font!,
 
         size: size,
         height: height,
@@ -239,7 +239,7 @@ function createText() {
 
     textGeo.computeBoundingBox();
 
-    const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
+    const centerOffset = -0.5 * (textGeo.boundingBox!.max.x - textGeo.boundingBox!.min.x);
 
     textMesh1 = new THREE.Mesh(textGeo, materials);
 
@@ -275,7 +275,7 @@ function refreshText() {
     createText();
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerXOnPointerDown = event.clientX - windowHalfX;
@@ -285,7 +285,7 @@ function onPointerDown(event) {
     document.addEventListener('pointerup', onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerX = event.clientX - windowHalfX;
@@ -293,7 +293,7 @@ function onPointerMove(event) {
     targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
 }
 
-function onPointerUp() {
+function onPointerUp(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     document.removeEventListener('pointermove', onPointerMove);
diff --git a/examples-testing/examples/webgl_geometry_text_shapes.ts b/examples-testing/examples/webgl_geometry_text_shapes.ts
index adfb600..141b618 100644
--- a/examples-testing/examples/webgl_geometry_text_shapes.ts
+++ b/examples-testing/examples/webgl_geometry_text_shapes.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { FontLoader } from 'three/addons/loaders/FontLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -32,13 +32,13 @@ function init() {
 
         const message = '   Three.js\nSimple text.';
 
-        const shapes = font.generateShapes(message, 100);
+        const shapes: THREE.Path[] = font.generateShapes(message, 100);
 
-        const geometry = new THREE.ShapeGeometry(shapes);
+        const geometry = new THREE.ShapeGeometry(shapes as THREE.Shape[]);
 
         geometry.computeBoundingBox();
 
-        const xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
+        const xMid = -0.5 * (geometry.boundingBox!.max.x - geometry.boundingBox!.min.x);
 
         geometry.translate(xMid, 0, 0);
 
@@ -50,10 +50,10 @@ function init() {
 
         // make line shape ( N.B. edge view remains visible )
 
-        const holeShapes = [];
+        const holeShapes: THREE.Path[] = [];
 
         for (let i = 0; i < shapes.length; i++) {
-            const shape = shapes[i];
+            const shape = shapes[i] as THREE.Shape;
 
             if (shape.holes && shape.holes.length > 0) {
                 for (let j = 0; j < shape.holes.length; j++) {
diff --git a/examples-testing/examples/webgl_geometry_text_stroke.ts b/examples-testing/examples/webgl_geometry_text_stroke.ts
index 9a19832..e47d7b6 100644
--- a/examples-testing/examples/webgl_geometry_text_stroke.ts
+++ b/examples-testing/examples/webgl_geometry_text_stroke.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
 import { FontLoader } from 'three/addons/loaders/FontLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -33,13 +33,13 @@ function init() {
 
         const message = '   Three.js\nStroke text.';
 
-        const shapes = font.generateShapes(message, 100);
+        const shapes: THREE.Path[] = font.generateShapes(message, 100);
 
-        const geometry = new THREE.ShapeGeometry(shapes);
+        const geometry = new THREE.ShapeGeometry(shapes as THREE.Shape[]);
 
         geometry.computeBoundingBox();
 
-        const xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
+        const xMid = -0.5 * (geometry.boundingBox!.max.x - geometry.boundingBox!.min.x);
 
         geometry.translate(xMid, 0, 0);
 
@@ -51,10 +51,10 @@ function init() {
 
         // make line shape ( N.B. edge view remains visible )
 
-        const holeShapes = [];
+        const holeShapes: THREE.Path[] = [];
 
         for (let i = 0; i < shapes.length; i++) {
-            const shape = shapes[i];
+            const shape = shapes[i] as THREE.Shape;
 
             if (shape.holes && shape.holes.length > 0) {
                 for (let j = 0; j < shape.holes.length; j++) {
diff --git a/examples-testing/examples/webgl_gpgpu_birds.ts b/examples-testing/examples/webgl_gpgpu_birds.ts
index ecf53eb..4f865bd 100644
--- a/examples-testing/examples/webgl_gpgpu_birds.ts
+++ b/examples-testing/examples/webgl_gpgpu_birds.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
+import { GPUComputationRenderer, Variable } from 'three/addons/misc/GPUComputationRenderer.js';
 
 /* TEXTURE WIDTH FOR SIMULATION */
 const WIDTH = 32;
@@ -33,9 +33,9 @@ class BirdGeometry extends THREE.BufferGeometry {
 
         let v = 0;
 
-        function verts_push() {
-            for (let i = 0; i < arguments.length; i++) {
-                vertices.array[v++] = arguments[i];
+        function verts_push(...args: number[]) {
+            for (let i = 0; i < args.length; i++) {
+                vertices.array[v++] = args[i];
             }
         }
 
@@ -77,8 +77,8 @@ class BirdGeometry extends THREE.BufferGeometry {
 
 //
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 let mouseX = 0,
     mouseY = 0;
 
@@ -90,12 +90,12 @@ const BOUNDS = 800,
 
 let last = performance.now();
 
-let gpuCompute;
-let velocityVariable;
-let positionVariable;
-let positionUniforms;
-let velocityUniforms;
-let birdUniforms;
+let gpuCompute: GPUComputationRenderer;
+let velocityVariable: Variable;
+let positionVariable: Variable;
+let positionUniforms: Record<string, THREE.IUniform>;
+let velocityUniforms: Record<string, THREE.IUniform>;
+let birdUniforms: Record<string, THREE.IUniform>;
 
 init();
 animate();
@@ -168,12 +168,12 @@ function initComputeRenderer() {
 
     velocityVariable = gpuCompute.addVariable(
         'textureVelocity',
-        document.getElementById('fragmentShaderVelocity').textContent,
+        document.getElementById('fragmentShaderVelocity')!.textContent!,
         dtVelocity,
     );
     positionVariable = gpuCompute.addVariable(
         'texturePosition',
-        document.getElementById('fragmentShaderPosition').textContent,
+        document.getElementById('fragmentShaderPosition')!.textContent!,
         dtPosition,
     );
 
@@ -222,8 +222,8 @@ function initBirds() {
     // THREE.ShaderMaterial
     const material = new THREE.ShaderMaterial({
         uniforms: birdUniforms,
-        vertexShader: document.getElementById('birdVS').textContent,
-        fragmentShader: document.getElementById('birdFS').textContent,
+        vertexShader: document.getElementById('birdVS')!.textContent!,
+        fragmentShader: document.getElementById('birdFS')!.textContent!,
         side: THREE.DoubleSide,
     });
 
@@ -235,7 +235,7 @@ function initBirds() {
     scene.add(birdMesh);
 }
 
-function fillPositionTexture(texture) {
+function fillPositionTexture(texture: THREE.DataTexture) {
     const theArray = texture.image.data;
 
     for (let k = 0, kl = theArray.length; k < kl; k += 4) {
@@ -250,7 +250,7 @@ function fillPositionTexture(texture) {
     }
 }
 
-function fillVelocityTexture(texture) {
+function fillVelocityTexture(texture: THREE.DataTexture) {
     const theArray = texture.image.data;
 
     for (let k = 0, kl = theArray.length; k < kl; k += 4) {
@@ -275,7 +275,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
diff --git a/examples-testing/examples/webgl_gpgpu_birds_gltf.ts b/examples-testing/examples/webgl_gpgpu_birds_gltf.ts
index 58aee4f..dfec2ec 100644
--- a/examples-testing/examples/webgl_gpgpu_birds_gltf.ts
+++ b/examples-testing/examples/webgl_gpgpu_birds_gltf.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
-import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
+import { GPUComputationRenderer, Variable } from 'three/addons/misc/GPUComputationRenderer.js';
 
 /* TEXTURE WIDTH FOR SIMULATION */
 const WIDTH = 64;
@@ -10,16 +10,20 @@ const BIRDS = WIDTH * WIDTH;
 
 /* BAKE ANIMATION INTO TEXTURE and CREATE GEOMETRY FROM BASE MODEL */
 const BirdGeometry = new THREE.BufferGeometry();
-let textureAnimation, durationAnimation, birdMesh, materialShader, indicesPerBird;
+let textureAnimation: THREE.DataTexture,
+    durationAnimation: number,
+    birdMesh: THREE.Mesh,
+    materialShader: THREE.Shader,
+    indicesPerBird: number;
 
-function nextPowerOf2(n) {
+function nextPowerOf2(n: number) {
     return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)));
 }
 
-Math.lerp = function (value1, value2, amount) {
+function lerp(value1: number, value2: number, amount: number) {
     amount = Math.max(Math.min(amount, 1), 0);
     return value1 + (value2 - value1) * amount;
-};
+}
 
 const gltfs = ['models/gltf/Parrot.glb', 'models/gltf/Flamingo.glb'];
 const colors = [0xccffff, 0xffdeff];
@@ -28,11 +32,11 @@ const selectModel = Math.floor(Math.random() * gltfs.length);
 new GLTFLoader().load(gltfs[selectModel], function (gltf) {
     const animations = gltf.animations;
     durationAnimation = Math.round(animations[0].duration * 60);
-    const birdGeo = gltf.scene.children[0].geometry;
+    const birdGeo = (gltf.scene.children[0] as THREE.Mesh).geometry;
     const morphAttributes = birdGeo.morphAttributes.position;
     const tHeight = nextPowerOf2(durationAnimation);
     const tWidth = nextPowerOf2(birdGeo.getAttribute('position').count);
-    indicesPerBird = birdGeo.index.count;
+    indicesPerBird = birdGeo.index!.count;
     const tData = new Float32Array(4 * tWidth * tHeight);
 
     for (let i = 0; i < tWidth; i++) {
@@ -50,17 +54,17 @@ new GLTFLoader().load(gltfs[selectModel], function (gltf) {
                 d0 = morphAttributes[curMorph].array[i * 3];
                 d1 = morphAttributes[nextMorph].array[i * 3];
 
-                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4] = Math.lerp(d0, d1, lerpAmount);
+                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4] = lerp(d0, d1, lerpAmount);
 
                 d0 = morphAttributes[curMorph].array[i * 3 + 1];
                 d1 = morphAttributes[nextMorph].array[i * 3 + 1];
 
-                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4 + 1] = Math.lerp(d0, d1, lerpAmount);
+                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4 + 1] = lerp(d0, d1, lerpAmount);
 
                 d0 = morphAttributes[curMorph].array[i * 3 + 2];
                 d1 = morphAttributes[nextMorph].array[i * 3 + 2];
 
-                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4 + 2] = Math.lerp(d0, d1, lerpAmount);
+                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4 + 2] = lerp(d0, d1, lerpAmount);
 
                 tData[offset + i * 4 + 3] = 1;
             }
@@ -94,9 +98,9 @@ new GLTFLoader().load(gltfs[selectModel], function (gltf) {
         seeds.push(bird, r, Math.random(), Math.random());
     }
 
-    for (let i = 0; i < birdGeo.index.array.length * BIRDS; i++) {
-        const offset = Math.floor(i / birdGeo.index.array.length) * birdGeo.getAttribute('position').count;
-        indices.push(birdGeo.index.array[i % birdGeo.index.array.length] + offset);
+    for (let i = 0; i < birdGeo.index!.array.length * BIRDS; i++) {
+        const offset = Math.floor(i / birdGeo.index!.array.length) * birdGeo.getAttribute('position').count;
+        indices.push(birdGeo.index!.array[i % birdGeo.index!.array.length] + offset);
     }
 
     BirdGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
@@ -111,8 +115,8 @@ new GLTFLoader().load(gltfs[selectModel], function (gltf) {
     animate();
 });
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 let mouseX = 0,
     mouseY = 0;
 
@@ -124,11 +128,20 @@ const BOUNDS = 800,
 
 let last = performance.now();
 
-let gpuCompute;
-let velocityVariable;
-let positionVariable;
-let positionUniforms;
-let velocityUniforms;
+let gpuCompute: GPUComputationRenderer;
+let velocityVariable: Variable;
+let positionVariable: Variable;
+let positionUniforms: Record<string, THREE.IUniform>;
+let velocityUniforms: Record<string, THREE.IUniform>;
+
+interface EffectController {
+    separation: number;
+    alignment: number;
+    cohesion: number;
+    freedom: number;
+    size: number;
+    count: number;
+}
 
 function init() {
     container = document.createElement('div');
@@ -216,12 +229,12 @@ function initComputeRenderer() {
 
     velocityVariable = gpuCompute.addVariable(
         'textureVelocity',
-        document.getElementById('fragmentShaderVelocity').textContent,
+        document.getElementById('fragmentShaderVelocity')!.textContent!,
         dtVelocity,
     );
     positionVariable = gpuCompute.addVariable(
         'texturePosition',
-        document.getElementById('fragmentShaderPosition').textContent,
+        document.getElementById('fragmentShaderPosition')!.textContent!,
         dtPosition,
     );
 
@@ -255,7 +268,7 @@ function initComputeRenderer() {
     }
 }
 
-function initBirds(effectController) {
+function initBirds(effectController: EffectController) {
     const geometry = BirdGeometry;
 
     const m = new THREE.MeshStandardMaterial({
@@ -335,7 +348,7 @@ function initBirds(effectController) {
     scene.add(birdMesh);
 }
 
-function fillPositionTexture(texture) {
+function fillPositionTexture(texture: THREE.DataTexture) {
     const theArray = texture.image.data;
 
     for (let k = 0, kl = theArray.length; k < kl; k += 4) {
@@ -350,7 +363,7 @@ function fillPositionTexture(texture) {
     }
 }
 
-function fillVelocityTexture(texture) {
+function fillVelocityTexture(texture: THREE.DataTexture) {
     const theArray = texture.image.data;
 
     for (let k = 0, kl = theArray.length; k < kl; k += 4) {
@@ -375,7 +388,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
diff --git a/examples-testing/examples/webgl_gpgpu_protoplanet.ts b/examples-testing/examples/webgl_gpgpu_protoplanet.ts
index b1a7e02..35fb039 100644
--- a/examples-testing/examples/webgl_gpgpu_protoplanet.ts
+++ b/examples-testing/examples/webgl_gpgpu_protoplanet.ts
@@ -4,22 +4,32 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
+import { GPUComputationRenderer, Variable } from 'three/addons/misc/GPUComputationRenderer.js';
 
 // Texture width for simulation (each texel is a debris particle)
 const WIDTH = 64;
 
-let container, stats;
-let camera, scene, renderer, geometry;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, geometry;
 
 const PARTICLES = WIDTH * WIDTH;
 
-let gpuCompute;
-let velocityVariable;
-let positionVariable;
-let velocityUniforms;
-let particleUniforms;
-let effectController;
+let gpuCompute: GPUComputationRenderer;
+let velocityVariable: Variable;
+let positionVariable: Variable;
+let velocityUniforms: Record<string, THREE.IUniform>;
+let particleUniforms: Record<string, THREE.IUniform>;
+let effectController: {
+    gravityConstant: number;
+    density: number;
+    radius: number;
+    height: number;
+    exponent: number;
+    maxMass: number;
+    velocity: number;
+    velocityExponent: number;
+    randVelocity: number;
+};
 
 init();
 animate();
@@ -86,12 +96,12 @@ function initComputeRenderer() {
 
     velocityVariable = gpuCompute.addVariable(
         'textureVelocity',
-        document.getElementById('computeShaderVelocity').textContent,
+        document.getElementById('computeShaderVelocity')!.textContent!,
         dtVelocity,
     );
     positionVariable = gpuCompute.addVariable(
         'texturePosition',
-        document.getElementById('computeShaderPosition').textContent,
+        document.getElementById('computeShaderPosition')!.textContent!,
         dtPosition,
     );
 
@@ -157,8 +167,8 @@ function initProtoplanets() {
     // THREE.ShaderMaterial
     const material = new THREE.ShaderMaterial({
         uniforms: particleUniforms,
-        vertexShader: document.getElementById('particleVertexShader').textContent,
-        fragmentShader: document.getElementById('particleFragmentShader').textContent,
+        vertexShader: document.getElementById('particleVertexShader')!.textContent!,
+        fragmentShader: document.getElementById('particleFragmentShader')!.textContent!,
     });
 
     material.extensions.drawBuffers = true;
@@ -170,7 +180,7 @@ function initProtoplanets() {
     scene.add(particles);
 }
 
-function fillTextures(texturePosition, textureVelocity) {
+function fillTextures(texturePosition: THREE.DataTexture, textureVelocity: THREE.DataTexture) {
     const posArray = texturePosition.image.data;
     const velArray = textureVelocity.image.data;
 
@@ -267,7 +277,7 @@ function initGUI() {
     folder2.open();
 }
 
-function getCameraConstant(camera) {
+function getCameraConstant(camera: THREE.PerspectiveCamera) {
     return window.innerHeight / (Math.tan(THREE.MathUtils.DEG2RAD * 0.5 * camera.fov) / camera.zoom);
 }
 
diff --git a/examples-testing/examples/webgl_gpgpu_water.ts b/examples-testing/examples/webgl_gpgpu_water.ts
index f9cce64..66cf7a7 100644
--- a/examples-testing/examples/webgl_gpgpu_water.ts
+++ b/examples-testing/examples/webgl_gpgpu_water.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
+import { GPUComputationRenderer, Variable } from 'three/addons/misc/GPUComputationRenderer.js';
 import { SimplexNoise } from 'three/addons/math/SimplexNoise.js';
 
 // Texture width for simulation
@@ -13,25 +13,25 @@ const WIDTH = 128;
 const BOUNDS = 512;
 const BOUNDS_HALF = BOUNDS * 0.5;
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 let mouseMoved = false;
 const mouseCoords = new THREE.Vector2();
 const raycaster = new THREE.Raycaster();
 
-let waterMesh;
-let meshRay;
-let gpuCompute;
-let heightmapVariable;
-let waterUniforms;
-let smoothShader;
-let readWaterLevelShader;
-let readWaterLevelRenderTarget;
-let readWaterLevelImage;
+let waterMesh: THREE.Mesh<THREE.PlaneGeometry, THREE.ShaderMaterial>;
+let meshRay: THREE.Mesh;
+let gpuCompute: GPUComputationRenderer;
+let heightmapVariable: Variable;
+let waterUniforms: Record<string, THREE.IUniform>;
+let smoothShader: THREE.ShaderMaterial;
+let readWaterLevelShader: THREE.ShaderMaterial;
+let readWaterLevelRenderTarget: THREE.WebGLRenderTarget;
+let readWaterLevelImage: Uint8Array;
 const waterNormal = new THREE.Vector3();
 
 const NUM_SPHERES = 5;
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 let spheresEnabled = true;
 
 const simplex = new SimplexNoise();
@@ -127,7 +127,7 @@ function initWater() {
                 heightmap: { value: null },
             },
         ]),
-        vertexShader: document.getElementById('waterVertexShader').textContent,
+        vertexShader: document.getElementById('waterVertexShader')!.textContent!,
         fragmentShader: THREE.ShaderChunk['meshphong_frag'],
     });
 
@@ -175,7 +175,7 @@ function initWater() {
 
     heightmapVariable = gpuCompute.addVariable(
         'heightmap',
-        document.getElementById('heightmapFragmentShader').textContent,
+        document.getElementById('heightmapFragmentShader')!.textContent!,
         heightmap0,
     );
 
@@ -193,13 +193,13 @@ function initWater() {
     }
 
     // Create compute shader to smooth the water surface and velocity
-    smoothShader = gpuCompute.createShaderMaterial(document.getElementById('smoothFragmentShader').textContent, {
+    smoothShader = gpuCompute.createShaderMaterial(document.getElementById('smoothFragmentShader')!.textContent!, {
         smoothTexture: { value: null },
     });
 
     // Create compute shader to read water level
     readWaterLevelShader = gpuCompute.createShaderMaterial(
-        document.getElementById('readWaterLevelFragmentShader').textContent,
+        document.getElementById('readWaterLevelFragmentShader')!.textContent!,
         {
             point1: { value: new THREE.Vector2() },
             levelTexture: { value: null },
@@ -222,10 +222,10 @@ function initWater() {
     });
 }
 
-function fillTexture(texture) {
+function fillTexture(texture: THREE.DataTexture) {
     const waterMaxHeight = 10;
 
-    function noise(x, y) {
+    function noise(x: number, y: number) {
         let multR = waterMaxHeight;
         let mult = 0.025;
         let r = 0;
@@ -350,12 +350,12 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function setMouseCoords(x, y) {
+function setMouseCoords(x: number, y: number) {
     mouseCoords.set((x / renderer.domElement.clientWidth) * 2 - 1, -(y / renderer.domElement.clientHeight) * 2 + 1);
     mouseMoved = true;
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     setMouseCoords(event.clientX, event.clientY);
diff --git a/examples-testing/examples/webgl_helpers.ts b/examples-testing/examples/webgl_helpers.ts
index 5d75326..65c573d 100644
--- a/examples-testing/examples/webgl_helpers.ts
+++ b/examples-testing/examples/webgl_helpers.ts
@@ -5,10 +5,10 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { VertexNormalsHelper } from 'three/addons/helpers/VertexNormalsHelper.js';
 import { VertexTangentsHelper } from 'three/addons/helpers/VertexTangentsHelper.js';
 
-let scene, renderer;
-let camera, light;
-let vnh;
-let vth;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let camera: THREE.PerspectiveCamera, light: THREE.PointLight;
+let vnh: VertexNormalsHelper;
+let vth: VertexTangentsHelper;
 
 init();
 animate();
@@ -44,7 +44,7 @@ function init() {
 
     const loader = new GLTFLoader();
     loader.load('models/gltf/LeePerrySmith/LeePerrySmith.glb', function (gltf) {
-        const mesh = gltf.scene.children[0];
+        const mesh = gltf.scene.children[0] as THREE.Mesh;
 
         mesh.geometry.computeTangents(); // generates bad data due to degenerate UVs
 
@@ -66,7 +66,7 @@ function init() {
         scene.add(new THREE.BoxHelper(mesh));
 
         const wireframe = new THREE.WireframeGeometry(mesh.geometry);
-        let line = new THREE.LineSegments(wireframe);
+        let line: THREE.LineSegments<THREE.BufferGeometry, THREE.LineBasicMaterial> = new THREE.LineSegments(wireframe);
         line.material.depthTest = false;
         line.material.opacity = 0.25;
         line.material.transparent = true;
diff --git a/examples-testing/examples/webgl_instancing_dynamic.ts b/examples-testing/examples/webgl_instancing_dynamic.ts
index 8c94528..b0e453e 100644
--- a/examples-testing/examples/webgl_instancing_dynamic.ts
+++ b/examples-testing/examples/webgl_instancing_dynamic.ts
@@ -3,9 +3,9 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
-let mesh;
+let mesh: THREE.InstancedMesh;
 const amount = parseInt(window.location.search.slice(1)) || 10;
 const count = Math.pow(amount, 3);
 const dummy = new THREE.Object3D();
diff --git a/examples-testing/examples/webgl_instancing_performance.ts b/examples-testing/examples/webgl_instancing_performance.ts
index 62ed935..b34abd6 100644
--- a/examples-testing/examples/webgl_instancing_performance.ts
+++ b/examples-testing/examples/webgl_instancing_performance.ts
@@ -6,8 +6,12 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let container, stats, gui, guiStatsEl;
-let camera, controls, scene, renderer, material;
+let container: HTMLElement, stats: Stats, gui: GUI, guiStatsEl: HTMLDivElement;
+let camera: THREE.PerspectiveCamera,
+    controls: OrbitControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    material: THREE.MeshNormalMaterial;
 
 // gui
 
@@ -31,15 +35,15 @@ animate();
 //
 
 function clean() {
-    const meshes = [];
+    const meshes: THREE.Mesh[] = [];
 
     scene.traverse(function (object) {
-        if (object.isMesh) meshes.push(object);
+        if ((object as THREE.Mesh).isMesh) meshes.push(object as THREE.Mesh);
     });
 
     for (let i = 0; i < meshes.length; i++) {
         const mesh = meshes[i];
-        mesh.material.dispose();
+        (mesh.material as THREE.Material).dispose();
         mesh.geometry.dispose();
 
         scene.remove(mesh);
@@ -51,7 +55,7 @@ const randomizeMatrix = (function () {
     const quaternion = new THREE.Quaternion();
     const scale = new THREE.Vector3();
 
-    return function (matrix) {
+    return function (matrix: THREE.Matrix4) {
         position.x = Math.random() * 40 - 20;
         position.y = Math.random() * 40 - 20;
         position.z = Math.random() * 40 - 20;
@@ -93,7 +97,7 @@ function initMesh() {
     });
 }
 
-function makeInstanced(geometry) {
+function makeInstanced(geometry: THREE.BufferGeometry) {
     const matrix = new THREE.Matrix4();
     const mesh = new THREE.InstancedMesh(geometry, material, api.count);
 
@@ -114,7 +118,7 @@ function makeInstanced(geometry) {
     ].join('<br/>');
 }
 
-function makeMerged(geometry) {
+function makeMerged(geometry: THREE.BufferGeometry) {
     const geometries = [];
     const matrix = new THREE.Matrix4();
 
@@ -139,7 +143,7 @@ function makeMerged(geometry) {
     ].join('<br/>');
 }
 
-function makeNaive(geometry) {
+function makeNaive(geometry: THREE.BufferGeometry) {
     const matrix = new THREE.Matrix4();
 
     for (let i = 0; i < api.count; i++) {
@@ -175,7 +179,7 @@ function init() {
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(width, height);
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     // scene
@@ -241,7 +245,7 @@ function render() {
 
 //
 
-function getGeometryByteLength(geometry) {
+function getGeometryByteLength(geometry: THREE.BufferGeometry) {
     let total = 0;
 
     if (geometry.index) total += geometry.index.array.byteLength;
@@ -254,7 +258,7 @@ function getGeometryByteLength(geometry) {
 }
 
 // Source: https://stackoverflow.com/a/18650828/1314762
-function formatBytes(bytes, decimals) {
+function formatBytes(bytes: number, decimals: number) {
     if (bytes === 0) return '0 bytes';
 
     const k = 1024;
diff --git a/examples-testing/examples/webgl_instancing_raycast.ts b/examples-testing/examples/webgl_instancing_raycast.ts
index 71f0d6e..ba3ebb0 100644
--- a/examples-testing/examples/webgl_instancing_raycast.ts
+++ b/examples-testing/examples/webgl_instancing_raycast.ts
@@ -4,9 +4,13 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, controls, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    controls: OrbitControls,
+    stats: Stats;
 
-let mesh;
+let mesh: THREE.InstancedMesh;
 const amount = parseInt(window.location.search.slice(1)) || 10;
 const count = Math.pow(amount, 3);
 
@@ -84,7 +88,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onMouseMove(event) {
+function onMouseMove(event: MouseEvent) {
     event.preventDefault();
 
     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
@@ -101,14 +105,14 @@ function animate() {
     const intersection = raycaster.intersectObject(mesh);
 
     if (intersection.length > 0) {
-        const instanceId = intersection[0].instanceId;
+        const instanceId = intersection[0].instanceId!;
 
         mesh.getColorAt(instanceId, color);
 
         if (color.equals(white)) {
             mesh.setColorAt(instanceId, color.setHex(Math.random() * 0xffffff));
 
-            mesh.instanceColor.needsUpdate = true;
+            mesh.instanceColor!.needsUpdate = true;
         }
     }
 
diff --git a/examples-testing/examples/webgl_instancing_scatter.ts b/examples-testing/examples/webgl_instancing_scatter.ts
index af7f39d..574f5c7 100644
--- a/examples-testing/examples/webgl_instancing_scatter.ts
+++ b/examples-testing/examples/webgl_instancing_scatter.ts
@@ -5,7 +5,7 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 const api = {
     count: 2000,
@@ -15,11 +15,11 @@ const api = {
     backgroundColor: 0xe39469,
 };
 
-let stemMesh, blossomMesh;
-let stemGeometry, blossomGeometry;
-let stemMaterial, blossomMaterial;
+let stemMesh: THREE.InstancedMesh, blossomMesh: THREE.InstancedMesh;
+let stemGeometry: THREE.BufferGeometry, blossomGeometry: THREE.BufferGeometry;
+let stemMaterial: THREE.Material | THREE.Material[], blossomMaterial: THREE.Material | THREE.Material[];
 
-let sampler;
+let sampler: MeshSurfaceSampler;
 const count = api.count;
 const ages = new Float32Array(count);
 const scales = new Float32Array(count);
@@ -35,21 +35,21 @@ const surfaceMaterial = new THREE.MeshLambertMaterial({ color: api.surfaceColor,
 const surface = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
 
 // Source: https://gist.github.com/gre/1650294
-const easeOutCubic = function (t) {
+const easeOutCubic = function (t: number) {
     return --t * t * t + 1;
 };
 
 // Scaling curve causes particles to grow quickly, ease gradually into full scale, then
 // disappear quickly. More of the particle's lifetime is spent around full scale.
-const scaleCurve = function (t) {
+const scaleCurve = function (t: number) {
     return Math.abs(easeOutCubic((t > 0.5 ? 1 - t : t) * 2));
 };
 
 const loader = new GLTFLoader();
 
 loader.load('./models/gltf/Flower/Flower.glb', function (gltf) {
-    const _stemMesh = gltf.scene.getObjectByName('Stem');
-    const _blossomMesh = gltf.scene.getObjectByName('Blossom');
+    const _stemMesh = gltf.scene.getObjectByName('Stem') as THREE.Mesh;
+    const _blossomMesh = gltf.scene.getObjectByName('Blossom') as THREE.Mesh;
 
     stemGeometry = _stemMesh.geometry.clone();
     blossomGeometry = _blossomMesh.geometry.clone();
@@ -179,7 +179,7 @@ function resample() {
     blossomMesh.instanceMatrix.needsUpdate = true;
 }
 
-function resampleParticle(i) {
+function resampleParticle(i: number) {
     sampler.sample(_position, _normal);
     _normal.add(_position);
 
@@ -192,7 +192,7 @@ function resampleParticle(i) {
     blossomMesh.setMatrixAt(i, dummy.matrix);
 }
 
-function updateParticle(i) {
+function updateParticle(i: number) {
     // Update lifecycle.
 
     ages[i] += 0.005;
diff --git a/examples-testing/examples/webgl_interactive_buffergeometry.ts b/examples-testing/examples/webgl_interactive_buffergeometry.ts
index fafa7a1..98a202c 100644
--- a/examples-testing/examples/webgl_interactive_buffergeometry.ts
+++ b/examples-testing/examples/webgl_interactive_buffergeometry.ts
@@ -2,19 +2,19 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let raycaster, pointer;
+let raycaster: THREE.Raycaster, pointer: THREE.Vector2;
 
-let mesh, line;
+let mesh: THREE.Mesh, line: THREE.Line;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -147,7 +147,7 @@ function init() {
 
     geometry.computeBoundingSphere();
 
-    let material = new THREE.MeshPhongMaterial({
+    let material: THREE.Material = new THREE.MeshPhongMaterial({
         color: 0xaaaaaa,
         specular: 0xffffff,
         shininess: 250,
@@ -197,7 +197,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -223,10 +223,10 @@ function render() {
 
     if (intersects.length > 0) {
         const intersect = intersects[0];
-        const face = intersect.face;
+        const face = intersect.face!;
 
-        const linePosition = line.geometry.attributes.position;
-        const meshPosition = mesh.geometry.attributes.position;
+        const linePosition = line.geometry.attributes.position as THREE.BufferAttribute;
+        const meshPosition = mesh.geometry.attributes.position as THREE.BufferAttribute;
 
         linePosition.copyAt(0, meshPosition, face.a);
         linePosition.copyAt(1, meshPosition, face.b);
diff --git a/examples-testing/examples/webgl_interactive_cubes.ts b/examples-testing/examples/webgl_interactive_cubes.ts
index c082289..a126b56 100644
--- a/examples-testing/examples/webgl_interactive_cubes.ts
+++ b/examples-testing/examples/webgl_interactive_cubes.ts
@@ -2,10 +2,10 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let stats;
-let camera, scene, raycaster, renderer;
+let stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, raycaster: THREE.Raycaster, renderer: THREE.WebGLRenderer;
 
-let INTERSECTED;
+let INTERSECTED: (THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial> & { currentHex?: number }) | null;
 let theta = 0;
 
 const pointer = new THREE.Vector2();
@@ -68,7 +68,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: MouseEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -100,14 +100,14 @@ function render() {
 
     if (intersects.length > 0) {
         if (INTERSECTED != intersects[0].object) {
-            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
+            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex!);
 
-            INTERSECTED = intersects[0].object;
+            INTERSECTED = intersects[0].object as THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial>;
             INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
             INTERSECTED.material.emissive.setHex(0xff0000);
         }
     } else {
-        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
+        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex!);
 
         INTERSECTED = null;
     }
diff --git a/examples-testing/examples/webgl_interactive_cubes_gpu.ts b/examples-testing/examples/webgl_interactive_cubes_gpu.ts
index f80c89f..59c40eb 100644
--- a/examples-testing/examples/webgl_interactive_cubes_gpu.ts
+++ b/examples-testing/examples/webgl_interactive_cubes_gpu.ts
@@ -5,12 +5,12 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let container, stats;
-let camera, controls, scene, renderer;
-let pickingTexture, pickingScene;
-let highlightBox;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, controls: TrackballControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let pickingTexture: THREE.WebGLRenderTarget, pickingScene: THREE.Scene;
+let highlightBox: THREE.Mesh;
 
-const pickingData = [];
+const pickingData: { position: THREE.Vector3; rotation: THREE.Euler; scale: THREE.Vector3 }[] = [];
 
 const pointer = new THREE.Vector2();
 const offset = new THREE.Vector3(10, 10, 10);
@@ -20,7 +20,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 1000;
@@ -74,7 +74,7 @@ function init() {
 					`,
     });
 
-    function applyId(geometry, id) {
+    function applyId(geometry: THREE.BoxGeometry, id: number) {
         const position = geometry.attributes.position;
         const array = new Int16Array(position.count);
         array.fill(id);
@@ -84,7 +84,7 @@ function init() {
         geometry.setAttribute('id', bufferAttribute);
     }
 
-    function applyVertexColors(geometry, color) {
+    function applyVertexColors(geometry: THREE.BoxGeometry, color: THREE.Color) {
         const position = geometry.attributes.position;
         const colors = [];
 
@@ -166,7 +166,7 @@ function init() {
 
 //
 
-function onPointerMove(e) {
+function onPointerMove(e: PointerEvent) {
     pointer.x = e.clientX;
     pointer.y = e.clientY;
 }
diff --git a/examples-testing/examples/webgl_interactive_cubes_ortho.ts b/examples-testing/examples/webgl_interactive_cubes_ortho.ts
index 92396d7..4639221 100644
--- a/examples-testing/examples/webgl_interactive_cubes_ortho.ts
+++ b/examples-testing/examples/webgl_interactive_cubes_ortho.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let stats;
-let camera, scene, raycaster, renderer;
+let stats: Stats;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, raycaster: THREE.Raycaster, renderer: THREE.WebGLRenderer;
 
 let theta = 0;
-let INTERSECTED;
+let INTERSECTED: (THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial> & { currentHex?: number }) | null;
 
 const pointer = new THREE.Vector2();
 const radius = 25;
@@ -83,7 +83,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -115,14 +115,14 @@ function render() {
 
     if (intersects.length > 0) {
         if (INTERSECTED != intersects[0].object) {
-            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
+            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex!);
 
-            INTERSECTED = intersects[0].object;
+            INTERSECTED = intersects[0].object as THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial>;
             INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
             INTERSECTED.material.emissive.setHex(0xff0000);
         }
     } else {
-        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
+        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex!);
 
         INTERSECTED = null;
     }
diff --git a/examples-testing/examples/webgl_interactive_lines.ts b/examples-testing/examples/webgl_interactive_lines.ts
index 69a1916..18bc732 100644
--- a/examples-testing/examples/webgl_interactive_lines.ts
+++ b/examples-testing/examples/webgl_interactive_lines.ts
@@ -2,8 +2,13 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
-let camera, scene, raycaster, renderer, parentTransform, sphereInter;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    raycaster: THREE.Raycaster,
+    renderer: THREE.WebGLRenderer,
+    parentTransform: THREE.Object3D,
+    sphereInter: THREE.Mesh;
 
 const pointer = new THREE.Vector2();
 const radius = 100;
@@ -121,7 +126,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
diff --git a/examples-testing/examples/webgl_interactive_points.ts b/examples-testing/examples/webgl_interactive_points.ts
index 99bad4a..eb62bf3 100644
--- a/examples-testing/examples/webgl_interactive_points.ts
+++ b/examples-testing/examples/webgl_interactive_points.ts
@@ -4,20 +4,20 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let particles;
+let particles: THREE.Points;
 
 const PARTICLE_SIZE = 20;
 
-let raycaster, intersects;
-let pointer, INTERSECTED;
+let raycaster: THREE.Raycaster, intersects;
+let pointer: THREE.Vector2, INTERSECTED: number | null;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
 
@@ -26,7 +26,7 @@ function init() {
 
     //
 
-    let boxGeometry = new THREE.BoxGeometry(200, 200, 200, 16, 16, 16);
+    let boxGeometry: THREE.BufferGeometry = new THREE.BoxGeometry(200, 200, 200, 16, 16, 16);
 
     // if normal and uv attributes are not removed, mergeVertices() can't consolidate indentical vertices with different normal/uv data
 
@@ -39,8 +39,8 @@ function init() {
 
     const positionAttribute = boxGeometry.getAttribute('position');
 
-    const colors = [];
-    const sizes = [];
+    const colors: number[] = [];
+    const sizes: number[] = [];
 
     const color = new THREE.Color();
 
@@ -64,8 +64,8 @@ function init() {
             pointTexture: { value: new THREE.TextureLoader().load('textures/sprites/disc.png') },
             alphaTest: { value: 0.9 },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
     });
 
     //
@@ -96,7 +96,7 @@ function init() {
     document.addEventListener('pointermove', onPointerMove);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -128,9 +128,9 @@ function render() {
 
     if (intersects.length > 0) {
         if (INTERSECTED != intersects[0].index) {
-            attributes.size.array[INTERSECTED] = PARTICLE_SIZE;
+            attributes.size.array[INTERSECTED!] = PARTICLE_SIZE;
 
-            INTERSECTED = intersects[0].index;
+            INTERSECTED = intersects[0].index!;
 
             attributes.size.array[INTERSECTED] = PARTICLE_SIZE * 1.25;
             attributes.size.needsUpdate = true;
diff --git a/examples-testing/examples/webgl_interactive_raycasting_points.ts b/examples-testing/examples/webgl_interactive_raycasting_points.ts
index ac4c0ba..a985151 100644
--- a/examples-testing/examples/webgl_interactive_raycasting_points.ts
+++ b/examples-testing/examples/webgl_interactive_raycasting_points.ts
@@ -2,16 +2,16 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let renderer, scene, camera, stats;
-let pointclouds;
-let raycaster;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
+let pointclouds: THREE.Points[];
+let raycaster: THREE.Raycaster;
 let intersection = null;
 let spheresIndex = 0;
-let clock;
+let clock: THREE.Clock;
 let toggle = 0;
 
 const pointer = new THREE.Vector2();
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
 const threshold = 0.1;
 const pointSize = 0.05;
@@ -22,7 +22,7 @@ const rotateY = new THREE.Matrix4().makeRotationY(0.005);
 init();
 animate();
 
-function generatePointCloudGeometry(color, width, length) {
+function generatePointCloudGeometry(color: THREE.Color, width: number, length: number) {
     const geometry = new THREE.BufferGeometry();
     const numPoints = width * length;
 
@@ -59,14 +59,14 @@ function generatePointCloudGeometry(color, width, length) {
     return geometry;
 }
 
-function generatePointcloud(color, width, length) {
+function generatePointcloud(color: THREE.Color, width: number, length: number) {
     const geometry = generatePointCloudGeometry(color, width, length);
     const material = new THREE.PointsMaterial({ size: pointSize, vertexColors: true });
 
     return new THREE.Points(geometry, material);
 }
 
-function generateIndexedPointcloud(color, width, length) {
+function generateIndexedPointcloud(color: THREE.Color, width: number, length: number) {
     const geometry = generatePointCloudGeometry(color, width, length);
     const numPoints = width * length;
     const indices = new Uint16Array(numPoints);
@@ -87,7 +87,7 @@ function generateIndexedPointcloud(color, width, length) {
     return new THREE.Points(geometry, material);
 }
 
-function generateIndexedWithOffsetPointcloud(color, width, length) {
+function generateIndexedWithOffsetPointcloud(color: THREE.Color, width: number, length: number) {
     const geometry = generatePointCloudGeometry(color, width, length);
     const numPoints = width * length;
     const indices = new Uint16Array(numPoints);
@@ -110,7 +110,7 @@ function generateIndexedWithOffsetPointcloud(color, width, length) {
 }
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
 
@@ -174,7 +174,7 @@ function init() {
     document.addEventListener('pointermove', onPointerMove);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
diff --git a/examples-testing/examples/webgl_interactive_voxelpainter.ts b/examples-testing/examples/webgl_interactive_voxelpainter.ts
index 48b16f3..dae1d75 100644
--- a/examples-testing/examples/webgl_interactive_voxelpainter.ts
+++ b/examples-testing/examples/webgl_interactive_voxelpainter.ts
@@ -1,15 +1,15 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
-let plane;
-let pointer,
-    raycaster,
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let plane: THREE.Mesh;
+let pointer: THREE.Vector2,
+    raycaster: THREE.Raycaster,
     isShiftDown = false;
 
-let rollOverMesh, rollOverMaterial;
-let cubeGeo, cubeMaterial;
+let rollOverMesh: THREE.Mesh, rollOverMaterial: THREE.MeshBasicMaterial;
+let cubeGeo: THREE.BoxGeometry, cubeMaterial: THREE.MeshLambertMaterial;
 
-const objects = [];
+const objects: THREE.Object3D[] = [];
 
 init();
 render();
@@ -87,7 +87,7 @@ function onWindowResize() {
     render();
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
 
     raycaster.setFromCamera(pointer, camera);
@@ -97,14 +97,14 @@ function onPointerMove(event) {
     if (intersects.length > 0) {
         const intersect = intersects[0];
 
-        rollOverMesh.position.copy(intersect.point).add(intersect.face.normal);
+        rollOverMesh.position.copy(intersect.point).add(intersect.face!.normal);
         rollOverMesh.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
 
         render();
     }
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     pointer.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
 
     raycaster.setFromCamera(pointer, camera);
@@ -126,7 +126,7 @@ function onPointerDown(event) {
             // create cube
         } else {
             const voxel = new THREE.Mesh(cubeGeo, cubeMaterial);
-            voxel.position.copy(intersect.point).add(intersect.face.normal);
+            voxel.position.copy(intersect.point).add(intersect.face!.normal);
             voxel.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
             scene.add(voxel);
 
@@ -137,7 +137,7 @@ function onPointerDown(event) {
     }
 }
 
-function onDocumentKeyDown(event) {
+function onDocumentKeyDown(event: KeyboardEvent) {
     switch (event.keyCode) {
         case 16:
             isShiftDown = true;
@@ -145,7 +145,7 @@ function onDocumentKeyDown(event) {
     }
 }
 
-function onDocumentKeyUp(event) {
+function onDocumentKeyUp(event: KeyboardEvent) {
     switch (event.keyCode) {
         case 16:
             isShiftDown = false;
diff --git a/examples-testing/examples/webgl_materials_modified.ts b/examples-testing/examples/webgl_materials_modified.ts
index 3708f65..4c1f793 100644
--- a/examples-testing/examples/webgl_materials_modified.ts
+++ b/examples-testing/examples/webgl_materials_modified.ts
@@ -5,7 +5,7 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 animate();
@@ -18,7 +18,7 @@ function init() {
 
     const loader = new GLTFLoader();
     loader.load('models/gltf/LeePerrySmith/LeePerrySmith.glb', function (gltf) {
-        const geometry = gltf.scene.children[0].geometry;
+        const geometry = (gltf.scene.children[0] as THREE.Mesh).geometry;
 
         let mesh = new THREE.Mesh(geometry, buildTwistMaterial(2.0));
         mesh.position.x = -3.5;
@@ -50,7 +50,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function buildTwistMaterial(amount) {
+function buildTwistMaterial(amount: number) {
     const material = new THREE.MeshNormalMaterial();
     material.onBeforeCompile = function (shader) {
         shader.uniforms.time = { value: 0 };
@@ -104,8 +104,8 @@ function animate() {
 
 function render() {
     scene.traverse(function (child) {
-        if (child.isMesh) {
-            const shader = child.material.userData.shader;
+        if ((child as THREE.Mesh).isMesh) {
+            const shader = ((child as THREE.Mesh).material as THREE.Material).userData.shader;
 
             if (shader) {
                 shader.uniforms.time.value = performance.now() / 1000;
diff --git a/examples-testing/examples/webgl_pmrem_test.ts b/examples-testing/examples/webgl_pmrem_test.ts
index b33e4e2..3f0ef81 100644
--- a/examples-testing/examples/webgl_pmrem_test.ts
+++ b/examples-testing/examples/webgl_pmrem_test.ts
@@ -5,7 +5,7 @@ import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, controls, renderer;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls, renderer: THREE.WebGLRenderer;
 
 function init() {
     const width = window.innerWidth;
@@ -68,8 +68,9 @@ function init() {
             directionalLight.intensity = value ? 0 : 1;
 
             scene.traverse(function (child) {
-                if (child.isMesh) {
-                    child.material.envMapIntensity = 1 - directionalLight.intensity;
+                if ((child as THREE.Mesh).isMesh) {
+                    ((child as THREE.Mesh).material as THREE.MeshStandardMaterial).envMapIntensity =
+                        1 - directionalLight.intensity;
                 }
             });
 
diff --git a/examples-testing/examples/webgl_postprocessing.ts b/examples-testing/examples/webgl_postprocessing.ts
index 944115b..d0afc09 100644
--- a/examples-testing/examples/webgl_postprocessing.ts
+++ b/examples-testing/examples/webgl_postprocessing.ts
@@ -8,8 +8,8 @@ import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';
 import { DotScreenShader } from 'three/addons/shaders/DotScreenShader.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, renderer, composer;
-let object;
+let camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let object: THREE.Object3D;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_postprocessing_advanced.ts b/examples-testing/examples/webgl_postprocessing_advanced.ts
index 976a443..2b29dd4 100644
--- a/examples-testing/examples/webgl_postprocessing_advanced.ts
+++ b/examples-testing/examples/webgl_postprocessing_advanced.ts
@@ -21,11 +21,21 @@ import { GammaCorrectionShader } from 'three/addons/shaders/GammaCorrectionShade
 
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let container, stats;
-
-let composerScene, composer1, composer2, composer3, composer4;
-
-let cameraOrtho, cameraPerspective, sceneModel, sceneBG, renderer, mesh, directionalLight;
+let container: HTMLElement, stats: Stats;
+
+let composerScene: EffectComposer,
+    composer1: EffectComposer,
+    composer2: EffectComposer,
+    composer3: EffectComposer,
+    composer4: EffectComposer;
+
+let cameraOrtho: THREE.OrthographicCamera,
+    cameraPerspective: THREE.PerspectiveCamera,
+    sceneModel: THREE.Scene,
+    sceneBG: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    mesh: THREE.Mesh,
+    directionalLight: THREE.DirectionalLight;
 
 const width = window.innerWidth || 2;
 const height = window.innerHeight || 2;
@@ -33,7 +43,7 @@ const height = window.innerHeight || 2;
 let halfWidth = width / 2;
 let halfHeight = height / 2;
 
-let quadBG, quadMask, renderScene;
+let quadBG: THREE.Mesh, quadMask: THREE.Mesh, renderScene: TexturePass;
 
 const delta = 0.01;
 
@@ -41,7 +51,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -64,7 +74,7 @@ function init() {
 
     const loader = new GLTFLoader();
     loader.load('models/gltf/LeePerrySmith/LeePerrySmith.glb', function (gltf) {
-        createMesh(gltf.scene.children[0].geometry, sceneModel, 100);
+        createMesh((gltf.scene.children[0] as THREE.Mesh).geometry, sceneModel, 100);
     });
 
     //
@@ -254,7 +264,7 @@ function onWindowResize() {
     quadMask.scale.set(window.innerWidth / 2, window.innerHeight / 2, 1);
 }
 
-function createMesh(geometry, scene, scale) {
+function createMesh(geometry: THREE.BufferGeometry, scene: THREE.Scene, scale: number) {
     const diffuseMap = new THREE.TextureLoader().load('models/gltf/LeePerrySmith/Map-COL.jpg');
     diffuseMap.colorSpace = THREE.SRGBColorSpace;
 
diff --git a/examples-testing/examples/webgl_postprocessing_afterimage.ts b/examples-testing/examples/webgl_postprocessing_afterimage.ts
index 2477c50..160e1a9 100644
--- a/examples-testing/examples/webgl_postprocessing_afterimage.ts
+++ b/examples-testing/examples/webgl_postprocessing_afterimage.ts
@@ -7,10 +7,10 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, scene, renderer, composer;
-let mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let mesh: THREE.Mesh;
 
-let afterimagePass;
+let afterimagePass: AfterimagePass;
 
 const params = {
     enable: true,
@@ -50,7 +50,7 @@ function init() {
 
     window.addEventListener('resize', onWindowResize);
 
-    if (typeof TESTING !== 'undefined') {
+    if (typeof (window as any).TESTING !== 'undefined') {
         for (let i = 0; i < 45; i++) {
             render();
         }
diff --git a/examples-testing/examples/webgl_postprocessing_backgrounds.ts b/examples-testing/examples/webgl_postprocessing_backgrounds.ts
index 0bfb655..89c4a5c 100644
--- a/examples-testing/examples/webgl_postprocessing_backgrounds.ts
+++ b/examples-testing/examples/webgl_postprocessing_backgrounds.ts
@@ -11,10 +11,10 @@ import { ClearPass } from 'three/addons/postprocessing/ClearPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let scene, renderer, composer;
-let clearPass, texturePass, renderPass;
-let cameraP, cubeTexturePassP;
-let gui, stats;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let clearPass: ClearPass, texturePass: TexturePass, renderPass: RenderPass;
+let cameraP: THREE.PerspectiveCamera, cubeTexturePassP: CubeTexturePass | null;
+let gui: GUI | undefined, stats: Stats;
 
 const params = {
     clearPass: true,
@@ -56,7 +56,7 @@ function clearGui() {
 }
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     const width = window.innerWidth || 1;
     const height = window.innerHeight || 1;
@@ -111,7 +111,7 @@ function init() {
 
     // postprocessing
 
-    const genCubeUrls = function (prefix, postfix) {
+    const genCubeUrls = function (prefix: string, postfix: string) {
         return [
             prefix + 'px' + postfix,
             prefix + 'nx' + postfix,
diff --git a/examples-testing/examples/webgl_postprocessing_crossfade.ts b/examples-testing/examples/webgl_postprocessing_crossfade.ts
index d3203e3..7b7f06f 100644
--- a/examples-testing/examples/webgl_postprocessing_crossfade.ts
+++ b/examples-testing/examples/webgl_postprocessing_crossfade.ts
@@ -4,9 +4,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import TWEEN from 'three/addons/libs/tween.module.js';
 
-let container, stats;
-let renderer;
-let transition;
+let container: HTMLElement, stats: Stats;
+let renderer: THREE.WebGLRenderer;
+let transition: Transition;
 
 const transitionParams = {
     useTexture: true,
@@ -25,7 +25,7 @@ animate();
 function init() {
     initGUI();
 
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -77,7 +77,7 @@ function render() {
     transition.render(clock.getDelta());
 }
 
-function generateInstancedMesh(geometry, material, count) {
+function generateInstancedMesh(geometry: THREE.BufferGeometry, material: THREE.MeshPhongMaterial, count: number) {
     const mesh = new THREE.InstancedMesh(geometry, material, count);
 
     const dummy = new THREE.Object3D();
@@ -111,192 +111,207 @@ function generateInstancedMesh(geometry, material, count) {
     return mesh;
 }
 
-function FXScene(geometry, rotationSpeed, clearColor) {
-    this.clearColor = clearColor;
+class FXScene {
+    clearColor: number;
+    rotationSpeed: THREE.Vector3;
+    fbo: THREE.WebGLRenderTarget;
+    render: (delta: number, rtt: boolean) => void;
 
-    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
-    camera.position.z = 20;
+    constructor(geometry: THREE.BufferGeometry, rotationSpeed: THREE.Vector3, clearColor: number) {
+        this.clearColor = clearColor;
 
-    // Setup scene
-    const scene = new THREE.Scene();
-    scene.add(new THREE.AmbientLight(0xaaaaaa, 3));
+        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
+        camera.position.z = 20;
 
-    const light = new THREE.DirectionalLight(0xffffff, 3);
-    light.position.set(0, 1, 4);
-    scene.add(light);
+        // Setup scene
+        const scene = new THREE.Scene();
+        scene.add(new THREE.AmbientLight(0xaaaaaa, 3));
 
-    this.rotationSpeed = rotationSpeed;
+        const light = new THREE.DirectionalLight(0xffffff, 3);
+        light.position.set(0, 1, 4);
+        scene.add(light);
 
-    const color = geometry.type === 'BoxGeometry' ? 0x0000ff : 0xff0000;
-    const material = new THREE.MeshPhongMaterial({ color: color, flatShading: true });
-    const mesh = generateInstancedMesh(geometry, material, 500);
-    scene.add(mesh);
+        this.rotationSpeed = rotationSpeed;
 
-    this.fbo = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { type: THREE.HalfFloatType });
+        const color = geometry.type === 'BoxGeometry' ? 0x0000ff : 0xff0000;
+        const material = new THREE.MeshPhongMaterial({ color: color, flatShading: true });
+        const mesh = generateInstancedMesh(geometry, material, 500);
+        scene.add(mesh);
 
-    this.render = function (delta, rtt) {
-        mesh.rotation.x += delta * this.rotationSpeed.x;
-        mesh.rotation.y += delta * this.rotationSpeed.y;
-        mesh.rotation.z += delta * this.rotationSpeed.z;
+        this.fbo = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { type: THREE.HalfFloatType });
 
-        renderer.setClearColor(this.clearColor);
+        this.render = function (delta, rtt) {
+            mesh.rotation.x += delta * this.rotationSpeed.x;
+            mesh.rotation.y += delta * this.rotationSpeed.y;
+            mesh.rotation.z += delta * this.rotationSpeed.z;
 
-        if (rtt) {
-            renderer.setRenderTarget(this.fbo);
-            renderer.clear();
-            renderer.render(scene, camera);
-        } else {
-            renderer.setRenderTarget(null);
-            renderer.render(scene, camera);
-        }
-    };
+            renderer.setClearColor(this.clearColor);
+
+            if (rtt) {
+                renderer.setRenderTarget(this.fbo);
+                renderer.clear();
+                renderer.render(scene, camera);
+            } else {
+                renderer.setRenderTarget(null);
+                renderer.render(scene, camera);
+            }
+        };
+    }
 }
 
-function Transition(sceneA, sceneB) {
-    const scene = new THREE.Scene();
+class Transition {
+    needsTextureChange: boolean;
+    setTextureThreshold: (value: number) => void;
+    useTexture: (value: boolean) => void;
+    setTexture: (value: number) => void;
+    render: (delta: number) => void;
 
-    const width = window.innerWidth;
-    const height = window.innerHeight;
+    constructor(sceneA: FXScene, sceneB: FXScene) {
+        const scene = new THREE.Scene();
 
-    const camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, -10, 10);
+        const width = window.innerWidth;
+        const height = window.innerHeight;
 
-    const textures = [];
+        const camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, -10, 10);
 
-    const loader = new THREE.TextureLoader();
+        const textures: THREE.Texture[] = [];
 
-    for (let i = 0; i < 6; i++) {
-        textures[i] = loader.load('textures/transition/transition' + (i + 1) + '.png');
-    }
+        const loader = new THREE.TextureLoader();
 
-    const material = new THREE.ShaderMaterial({
-        uniforms: {
-            tDiffuse1: {
-                value: null,
-            },
-            tDiffuse2: {
-                value: null,
-            },
-            mixRatio: {
-                value: 0.0,
-            },
-            threshold: {
-                value: 0.1,
-            },
-            useTexture: {
-                value: 1,
-            },
-            tMixTexture: {
-                value: textures[0],
+        for (let i = 0; i < 6; i++) {
+            textures[i] = loader.load('textures/transition/transition' + (i + 1) + '.png');
+        }
+
+        const material = new THREE.ShaderMaterial({
+            uniforms: {
+                tDiffuse1: {
+                    value: null,
+                },
+                tDiffuse2: {
+                    value: null,
+                },
+                mixRatio: {
+                    value: 0.0,
+                },
+                threshold: {
+                    value: 0.1,
+                },
+                useTexture: {
+                    value: 1,
+                },
+                tMixTexture: {
+                    value: textures[0],
+                },
             },
-        },
-        vertexShader: [
-            'varying vec2 vUv;',
+            vertexShader: [
+                'varying vec2 vUv;',
 
-            'void main() {',
+                'void main() {',
 
-            'vUv = vec2( uv.x, uv.y );',
-            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
+                'vUv = vec2( uv.x, uv.y );',
+                'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
 
-            '}',
-        ].join('\n'),
-        fragmentShader: [
-            'uniform float mixRatio;',
+                '}',
+            ].join('\n'),
+            fragmentShader: [
+                'uniform float mixRatio;',
 
-            'uniform sampler2D tDiffuse1;',
-            'uniform sampler2D tDiffuse2;',
-            'uniform sampler2D tMixTexture;',
+                'uniform sampler2D tDiffuse1;',
+                'uniform sampler2D tDiffuse2;',
+                'uniform sampler2D tMixTexture;',
 
-            'uniform int useTexture;',
-            'uniform float threshold;',
+                'uniform int useTexture;',
+                'uniform float threshold;',
 
-            'varying vec2 vUv;',
+                'varying vec2 vUv;',
 
-            'void main() {',
+                'void main() {',
 
-            '	vec4 texel1 = texture2D( tDiffuse1, vUv );',
-            '	vec4 texel2 = texture2D( tDiffuse2, vUv );',
+                '	vec4 texel1 = texture2D( tDiffuse1, vUv );',
+                '	vec4 texel2 = texture2D( tDiffuse2, vUv );',
 
-            '	if (useTexture==1) {',
+                '	if (useTexture==1) {',
 
-            '		vec4 transitionTexel = texture2D( tMixTexture, vUv );',
-            '		float r = mixRatio * (1.0 + threshold * 2.0) - threshold;',
-            '		float mixf=clamp((transitionTexel.r - r)*(1.0/threshold), 0.0, 1.0);',
+                '		vec4 transitionTexel = texture2D( tMixTexture, vUv );',
+                '		float r = mixRatio * (1.0 + threshold * 2.0) - threshold;',
+                '		float mixf=clamp((transitionTexel.r - r)*(1.0/threshold), 0.0, 1.0);',
 
-            '		gl_FragColor = mix( texel1, texel2, mixf );',
+                '		gl_FragColor = mix( texel1, texel2, mixf );',
 
-            '	} else {',
+                '	} else {',
 
-            '		gl_FragColor = mix( texel2, texel1, mixRatio );',
+                '		gl_FragColor = mix( texel2, texel1, mixRatio );',
 
-            '	}',
+                '	}',
 
-            '	#include <tonemapping_fragment>',
-            '	#include <colorspace_fragment>',
+                '	#include <tonemapping_fragment>',
+                '	#include <colorspace_fragment>',
 
-            '}',
-        ].join('\n'),
-    });
+                '}',
+            ].join('\n'),
+        });
 
-    const geometry = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
-    const mesh = new THREE.Mesh(geometry, material);
-    scene.add(mesh);
+        const geometry = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
+        const mesh = new THREE.Mesh(geometry, material);
+        scene.add(mesh);
 
-    material.uniforms.tDiffuse1.value = sceneA.fbo.texture;
-    material.uniforms.tDiffuse2.value = sceneB.fbo.texture;
+        material.uniforms.tDiffuse1.value = sceneA.fbo.texture;
+        material.uniforms.tDiffuse2.value = sceneB.fbo.texture;
 
-    new TWEEN.Tween(transitionParams).to({ transition: 1 }, 1500).repeat(Infinity).delay(2000).yoyo(true).start();
+        new TWEEN.Tween(transitionParams).to({ transition: 1 }, 1500).repeat(Infinity).delay(2000).yoyo(true).start();
 
-    this.needsTextureChange = false;
+        this.needsTextureChange = false;
 
-    this.setTextureThreshold = function (value) {
-        material.uniforms.threshold.value = value;
-    };
+        this.setTextureThreshold = function (value) {
+            material.uniforms.threshold.value = value;
+        };
 
-    this.useTexture = function (value) {
-        material.uniforms.useTexture.value = value ? 1 : 0;
-    };
+        this.useTexture = function (value) {
+            material.uniforms.useTexture.value = value ? 1 : 0;
+        };
 
-    this.setTexture = function (i) {
-        material.uniforms.tMixTexture.value = textures[i];
-    };
+        this.setTexture = function (i) {
+            material.uniforms.tMixTexture.value = textures[i];
+        };
 
-    this.render = function (delta) {
-        // Transition animation
-        if (transitionParams.animate) {
-            TWEEN.update();
+        this.render = function (delta) {
+            // Transition animation
+            if (transitionParams.animate) {
+                TWEEN.update();
 
-            // Change the current alpha texture after each transition
-            if (transitionParams.cycle) {
-                if (transitionParams.transition == 0 || transitionParams.transition == 1) {
-                    if (this.needsTextureChange) {
-                        transitionParams.texture = (transitionParams.texture + 1) % textures.length;
-                        material.uniforms.tMixTexture.value = textures[transitionParams.texture];
-                        this.needsTextureChange = false;
+                // Change the current alpha texture after each transition
+                if (transitionParams.cycle) {
+                    if (transitionParams.transition == 0 || transitionParams.transition == 1) {
+                        if (this.needsTextureChange) {
+                            transitionParams.texture = (transitionParams.texture + 1) % textures.length;
+                            material.uniforms.tMixTexture.value = textures[transitionParams.texture];
+                            this.needsTextureChange = false;
+                        }
+                    } else {
+                        this.needsTextureChange = true;
                     }
                 } else {
                     this.needsTextureChange = true;
                 }
-            } else {
-                this.needsTextureChange = true;
             }
-        }
 
-        material.uniforms.mixRatio.value = transitionParams.transition;
+            material.uniforms.mixRatio.value = transitionParams.transition;
 
-        // Prevent render both scenes when it's not necessary
-        if (transitionParams.transition == 0) {
-            sceneB.render(delta, false);
-        } else if (transitionParams.transition == 1) {
-            sceneA.render(delta, false);
-        } else {
-            // When 0<transition<1 render transition between two scenes
+            // Prevent render both scenes when it's not necessary
+            if (transitionParams.transition == 0) {
+                sceneB.render(delta, false);
+            } else if (transitionParams.transition == 1) {
+                sceneA.render(delta, false);
+            } else {
+                // When 0<transition<1 render transition between two scenes
 
-            sceneA.render(delta, true);
-            sceneB.render(delta, true);
+                sceneA.render(delta, true);
+                sceneB.render(delta, true);
 
-            renderer.setRenderTarget(null);
-            renderer.clear();
-            renderer.render(scene, camera);
-        }
-    };
+                renderer.setRenderTarget(null);
+                renderer.clear();
+                renderer.render(scene, camera);
+            }
+        };
+    }
 }
diff --git a/examples-testing/examples/webgl_postprocessing_fxaa.ts b/examples-testing/examples/webgl_postprocessing_fxaa.ts
index 18ae7b7..83fb702 100644
--- a/examples-testing/examples/webgl_postprocessing_fxaa.ts
+++ b/examples-testing/examples/webgl_postprocessing_fxaa.ts
@@ -6,15 +6,20 @@ import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
 import { ColorCorrectionShader } from 'three/addons/shaders/ColorCorrectionShader.js';
 import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
 
-let camera, scene, renderer, clock, group, container;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    group: THREE.Group,
+    container: HTMLElement;
 
-let composer1, composer2, fxaaPass;
+let composer1: EffectComposer, composer2: EffectComposer, fxaaPass: ShaderPass;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 1, 2000);
     camera.position.z = 500;
diff --git a/examples-testing/examples/webgl_postprocessing_glitch.ts b/examples-testing/examples/webgl_postprocessing_glitch.ts
index 343f2b1..9c6d3f5 100644
--- a/examples-testing/examples/webgl_postprocessing_glitch.ts
+++ b/examples-testing/examples/webgl_postprocessing_glitch.ts
@@ -5,14 +5,14 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, scene, renderer, composer;
-let object, light;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let object: THREE.Object3D, light: THREE.DirectionalLight;
 
-let glitchPass;
+let glitchPass: GlitchPass;
 
-const button = document.querySelector('#startButton');
+const button = document.querySelector('#startButton')!;
 button.addEventListener('click', function () {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
     init();
@@ -20,7 +20,7 @@ button.addEventListener('click', function () {
 });
 
 function updateOptions() {
-    const wildGlitch = document.getElementById('wildGlitch');
+    const wildGlitch = document.getElementById('wildGlitch') as HTMLInputElement;
     glitchPass.goWild = wildGlitch.checked;
 }
 
@@ -75,7 +75,7 @@ function init() {
 
     window.addEventListener('resize', onWindowResize);
 
-    const wildGlitchOption = document.getElementById('wildGlitch');
+    const wildGlitchOption = document.getElementById('wildGlitch')!;
     wildGlitchOption.addEventListener('change', updateOptions);
 
     updateOptions();
diff --git a/examples-testing/examples/webgl_postprocessing_godrays.ts b/examples-testing/examples/webgl_postprocessing_godrays.ts
index 47e89f6..4329bfe 100644
--- a/examples-testing/examples/webgl_postprocessing_godrays.ts
+++ b/examples-testing/examples/webgl_postprocessing_godrays.ts
@@ -11,16 +11,37 @@ import {
     GodRaysGenerateShader,
 } from 'three/addons/shaders/GodRaysShader.js';
 
-let container, stats;
-let camera, scene, renderer, materialDepth;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    materialDepth: THREE.MeshDepthMaterial;
 
-let sphereMesh;
+let sphereMesh: THREE.Mesh;
 
 const sunPosition = new THREE.Vector3(0, 1000, -1000);
 const clipPosition = new THREE.Vector4();
 const screenSpacePosition = new THREE.Vector3();
 
-const postprocessing = { enabled: true };
+const postprocessing: {
+    enabled: boolean;
+    scene?: THREE.Scene;
+    camera?: THREE.OrthographicCamera;
+    rtTextureColors?: THREE.WebGLRenderTarget;
+    rtTextureDepth?: THREE.WebGLRenderTarget;
+    rtTextureDepthMask?: THREE.WebGLRenderTarget;
+    rtTextureGodRays1?: THREE.WebGLRenderTarget;
+    rtTextureGodRays2?: THREE.WebGLRenderTarget;
+    godrayMaskUniforms?: (typeof GodRaysDepthMaskShader)['uniforms'];
+    materialGodraysDepthMask?: THREE.ShaderMaterial;
+    godrayGenUniforms?: (typeof GodRaysGenerateShader)['uniforms'];
+    materialGodraysGenerate?: THREE.ShaderMaterial;
+    godrayCombineUniforms?: (typeof GodRaysCombineShader)['uniforms'];
+    materialGodraysCombine?: THREE.ShaderMaterial;
+    godraysFakeSunUniforms?: (typeof GodRaysFakeSunShader)['uniforms'];
+    materialGodraysFakeSun?: THREE.ShaderMaterial;
+    quad?: THREE.Mesh;
+} = { enabled: true };
 
 const orbitRadius = 200;
 
@@ -102,17 +123,17 @@ function onWindowResize() {
     camera.updateProjectionMatrix();
 
     renderer.setSize(renderTargetWidth, renderTargetHeight);
-    postprocessing.rtTextureColors.setSize(renderTargetWidth, renderTargetHeight);
-    postprocessing.rtTextureDepth.setSize(renderTargetWidth, renderTargetHeight);
-    postprocessing.rtTextureDepthMask.setSize(renderTargetWidth, renderTargetHeight);
+    postprocessing.rtTextureColors!.setSize(renderTargetWidth, renderTargetHeight);
+    postprocessing.rtTextureDepth!.setSize(renderTargetWidth, renderTargetHeight);
+    postprocessing.rtTextureDepthMask!.setSize(renderTargetWidth, renderTargetHeight);
 
     const adjustedWidth = renderTargetWidth * godrayRenderTargetResolutionMultiplier;
     const adjustedHeight = renderTargetHeight * godrayRenderTargetResolutionMultiplier;
-    postprocessing.rtTextureGodRays1.setSize(adjustedWidth, adjustedHeight);
-    postprocessing.rtTextureGodRays2.setSize(adjustedWidth, adjustedHeight);
+    postprocessing.rtTextureGodRays1!.setSize(adjustedWidth, adjustedHeight);
+    postprocessing.rtTextureGodRays2!.setSize(adjustedWidth, adjustedHeight);
 }
 
-function initPostprocessing(renderTargetWidth, renderTargetHeight) {
+function initPostprocessing(renderTargetWidth: number, renderTargetHeight: number) {
     postprocessing.scene = new THREE.Scene();
 
     postprocessing.camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);
@@ -183,10 +204,10 @@ function initPostprocessing(renderTargetWidth, renderTargetHeight) {
         fragmentShader: godraysFakeSunShader.fragmentShader,
     });
 
-    postprocessing.godraysFakeSunUniforms.bgColor.value.setHex(bgColor);
-    postprocessing.godraysFakeSunUniforms.sunColor.value.setHex(sunColor);
+    postprocessing.godraysFakeSunUniforms!.bgColor.value.setHex(bgColor);
+    postprocessing.godraysFakeSunUniforms!.sunColor.value.setHex(sunColor);
 
-    postprocessing.godrayCombineUniforms.fGodRayIntensity.value = 0.75;
+    postprocessing.godrayCombineUniforms!.fGodRayIntensity.value = 0.75;
 
     postprocessing.quad = new THREE.Mesh(new THREE.PlaneGeometry(1.0, 1.0), postprocessing.materialGodraysGenerate);
     postprocessing.quad.position.z = -9900;
@@ -201,19 +222,19 @@ function animate() {
     stats.end();
 }
 
-function getStepSize(filterLen, tapsPerPass, pass) {
+function getStepSize(filterLen: number, tapsPerPass: number, pass: number) {
     return filterLen * Math.pow(tapsPerPass, -pass);
 }
 
-function filterGodRays(inputTex, renderTarget, stepSize) {
-    postprocessing.scene.overrideMaterial = postprocessing.materialGodraysGenerate;
+function filterGodRays(inputTex: THREE.Texture, renderTarget: THREE.WebGLRenderTarget, stepSize: number) {
+    postprocessing.scene!.overrideMaterial = postprocessing.materialGodraysGenerate!;
 
-    postprocessing.godrayGenUniforms['fStepSize'].value = stepSize;
-    postprocessing.godrayGenUniforms['tInput'].value = inputTex;
+    postprocessing.godrayGenUniforms!['fStepSize'].value = stepSize;
+    postprocessing.godrayGenUniforms!['tInput'].value = inputTex;
 
     renderer.setRenderTarget(renderTarget);
-    renderer.render(postprocessing.scene, postprocessing.camera);
-    postprocessing.scene.overrideMaterial = null;
+    renderer.render(postprocessing.scene!, postprocessing.camera!);
+    postprocessing.scene!.overrideMaterial = null;
 }
 
 function render() {
@@ -241,14 +262,14 @@ function render() {
 
         // Give it to the god-ray and sun shaders
 
-        postprocessing.godrayGenUniforms['vSunPositionScreenSpace'].value.copy(screenSpacePosition);
-        postprocessing.godraysFakeSunUniforms['vSunPositionScreenSpace'].value.copy(screenSpacePosition);
+        postprocessing.godrayGenUniforms!['vSunPositionScreenSpace'].value.copy(screenSpacePosition);
+        postprocessing.godraysFakeSunUniforms!['vSunPositionScreenSpace'].value.copy(screenSpacePosition);
 
         // -- Draw sky and sun --
 
         // Clear colors and depths, will clear to sky color
 
-        renderer.setRenderTarget(postprocessing.rtTextureColors);
+        renderer.setRenderTarget(postprocessing.rtTextureColors!);
         renderer.clear(true, true, false);
 
         // Sun render. Runs a shader that gives a brightness based on the screen
@@ -264,11 +285,11 @@ function render() {
         renderer.setScissor(screenSpacePosition.x - sunsqW / 2, screenSpacePosition.y - sunsqH / 2, sunsqW, sunsqH);
         renderer.setScissorTest(true);
 
-        postprocessing.godraysFakeSunUniforms['fAspect'].value = window.innerWidth / window.innerHeight;
+        postprocessing.godraysFakeSunUniforms!['fAspect'].value = window.innerWidth / window.innerHeight;
 
-        postprocessing.scene.overrideMaterial = postprocessing.materialGodraysFakeSun;
-        renderer.setRenderTarget(postprocessing.rtTextureColors);
-        renderer.render(postprocessing.scene, postprocessing.camera);
+        postprocessing.scene!.overrideMaterial = postprocessing.materialGodraysFakeSun!;
+        renderer.setRenderTarget(postprocessing.rtTextureColors!);
+        renderer.render(postprocessing.scene!, postprocessing.camera!);
 
         renderer.setScissorTest(false);
 
@@ -277,23 +298,23 @@ function render() {
         // Colors
 
         scene.overrideMaterial = null;
-        renderer.setRenderTarget(postprocessing.rtTextureColors);
+        renderer.setRenderTarget(postprocessing.rtTextureColors!);
         renderer.render(scene, camera);
 
         // Depth
 
         scene.overrideMaterial = materialDepth;
-        renderer.setRenderTarget(postprocessing.rtTextureDepth);
+        renderer.setRenderTarget(postprocessing.rtTextureDepth!);
         renderer.clear();
         renderer.render(scene, camera);
 
         //
 
-        postprocessing.godrayMaskUniforms['tInput'].value = postprocessing.rtTextureDepth.texture;
+        postprocessing.godrayMaskUniforms!['tInput'].value = postprocessing.rtTextureDepth!.texture;
 
-        postprocessing.scene.overrideMaterial = postprocessing.materialGodraysDepthMask;
-        renderer.setRenderTarget(postprocessing.rtTextureDepthMask);
-        renderer.render(postprocessing.scene, postprocessing.camera);
+        postprocessing.scene!.overrideMaterial = postprocessing.materialGodraysDepthMask!;
+        renderer.setRenderTarget(postprocessing.rtTextureDepthMask!);
+        renderer.render(postprocessing.scene!, postprocessing.camera!);
 
         // -- Render god-rays --
 
@@ -312,35 +333,35 @@ function render() {
 
         // pass 1 - render into first ping-pong target
         filterGodRays(
-            postprocessing.rtTextureDepthMask.texture,
-            postprocessing.rtTextureGodRays2,
+            postprocessing.rtTextureDepthMask!.texture,
+            postprocessing.rtTextureGodRays2!,
             getStepSize(filterLen, TAPS_PER_PASS, 1.0),
         );
 
         // pass 2 - render into second ping-pong target
         filterGodRays(
-            postprocessing.rtTextureGodRays2.texture,
-            postprocessing.rtTextureGodRays1,
+            postprocessing.rtTextureGodRays2!.texture,
+            postprocessing.rtTextureGodRays1!,
             getStepSize(filterLen, TAPS_PER_PASS, 2.0),
         );
 
         // pass 3 - 1st RT
         filterGodRays(
-            postprocessing.rtTextureGodRays1.texture,
-            postprocessing.rtTextureGodRays2,
+            postprocessing.rtTextureGodRays1!.texture,
+            postprocessing.rtTextureGodRays2!,
             getStepSize(filterLen, TAPS_PER_PASS, 3.0),
         );
 
         // final pass - composite god-rays onto colors
 
-        postprocessing.godrayCombineUniforms['tColors'].value = postprocessing.rtTextureColors.texture;
-        postprocessing.godrayCombineUniforms['tGodRays'].value = postprocessing.rtTextureGodRays2.texture;
+        postprocessing.godrayCombineUniforms!['tColors'].value = postprocessing.rtTextureColors!.texture;
+        postprocessing.godrayCombineUniforms!['tGodRays'].value = postprocessing.rtTextureGodRays2!.texture;
 
-        postprocessing.scene.overrideMaterial = postprocessing.materialGodraysCombine;
+        postprocessing.scene!.overrideMaterial = postprocessing.materialGodraysCombine!;
 
         renderer.setRenderTarget(null);
-        renderer.render(postprocessing.scene, postprocessing.camera);
-        postprocessing.scene.overrideMaterial = null;
+        renderer.render(postprocessing.scene!, postprocessing.camera!);
+        postprocessing.scene!.overrideMaterial = null;
     } else {
         renderer.setRenderTarget(null);
         renderer.clear();
diff --git a/examples-testing/examples/webgl_postprocessing_masking.ts b/examples-testing/examples/webgl_postprocessing_masking.ts
index 3650bfe..88a3d81 100644
--- a/examples-testing/examples/webgl_postprocessing_masking.ts
+++ b/examples-testing/examples/webgl_postprocessing_masking.ts
@@ -6,8 +6,8 @@ import { ClearPass } from 'three/addons/postprocessing/ClearPass.js';
 import { MaskPass, ClearMaskPass } from 'three/addons/postprocessing/MaskPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, composer, renderer;
-let box, torus;
+let camera: THREE.PerspectiveCamera, composer: EffectComposer, renderer: THREE.WebGLRenderer;
+let box: THREE.Mesh, torus: THREE.Mesh;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_postprocessing_outline.ts b/examples-testing/examples/webgl_postprocessing_outline.ts
index 60d8b01..daa0c75 100644
--- a/examples-testing/examples/webgl_postprocessing_outline.ts
+++ b/examples-testing/examples/webgl_postprocessing_outline.ts
@@ -12,11 +12,11 @@ import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
 
-let container, stats;
-let camera, scene, renderer, controls;
-let composer, effectFXAA, outlinePass;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
+let composer: EffectComposer, effectFXAA: ShaderPass, outlinePass: OutlinePass;
 
-let selectedObjects = [];
+let selectedObjects: THREE.Object3D[] = [];
 
 const raycaster = new THREE.Raycaster();
 const mouse = new THREE.Vector2();
@@ -59,9 +59,14 @@ gui.add(params, 'usePatternTexture').onChange(function (value) {
     outlinePass.usePatternTexture = value;
 });
 
-function Configuration() {
-    this.visibleEdgeColor = '#ffffff';
-    this.hiddenEdgeColor = '#190a05';
+class Configuration {
+    visibleEdgeColor: string;
+    hiddenEdgeColor: string;
+
+    constructor() {
+        this.visibleEdgeColor = '#ffffff';
+        this.hiddenEdgeColor = '#190a05';
+    }
 }
 
 const conf = new Configuration();
@@ -223,7 +228,7 @@ function init() {
     renderer.domElement.style.touchAction = 'none';
     renderer.domElement.addEventListener('pointermove', onPointerMove);
 
-    function onPointerMove(event) {
+    function onPointerMove(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
         mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
@@ -232,7 +237,7 @@ function init() {
         checkIntersection();
     }
 
-    function addSelectedObject(object) {
+    function addSelectedObject(object: THREE.Object3D) {
         selectedObjects = [];
         selectedObjects.push(object);
     }
diff --git a/examples-testing/examples/webgl_postprocessing_pixel.ts b/examples-testing/examples/webgl_postprocessing_pixel.ts
index fa76309..e9e4350 100644
--- a/examples-testing/examples/webgl_postprocessing_pixel.ts
+++ b/examples-testing/examples/webgl_postprocessing_pixel.ts
@@ -6,8 +6,14 @@ import { RenderPixelatedPass } from 'three/addons/postprocessing/RenderPixelated
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, composer, crystalMesh, clock;
-let gui, params;
+let camera: THREE.OrthographicCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    composer: EffectComposer,
+    crystalMesh: THREE.Mesh<THREE.IcosahedronGeometry, THREE.MeshPhongMaterial>,
+    clock: THREE.Clock;
+let gui: GUI,
+    params: { pixelSize: number; normalEdgeStrength: number; depthEdgeStrength: number; pixelAlignedPanning: boolean };
 
 init();
 animate();
@@ -53,8 +59,14 @@ function init() {
         .onChange(() => {
             renderPixelatedPass.setPixelSize(params.pixelSize);
         });
-    gui.add(renderPixelatedPass, 'normalEdgeStrength').min(0).max(2).step(0.05);
-    gui.add(renderPixelatedPass, 'depthEdgeStrength').min(0).max(1).step(0.05);
+    gui.add(renderPixelatedPass as { normalEdgeStrength: number }, 'normalEdgeStrength')
+        .min(0)
+        .max(2)
+        .step(0.05);
+    gui.add(renderPixelatedPass as { depthEdgeStrength: number }, 'depthEdgeStrength')
+        .min(0)
+        .max(1)
+        .step(0.05);
     gui.add(params, 'pixelAlignedPanning');
 
     // textures
@@ -69,7 +81,7 @@ function init() {
 
     const boxMaterial = new THREE.MeshPhongMaterial({ map: texChecker2 });
 
-    function addBox(boxSideLength, x, z, rotation) {
+    function addBox(boxSideLength: number, x: number, z: number, rotation: number) {
         const mesh = new THREE.Mesh(new THREE.BoxGeometry(boxSideLength, boxSideLength, boxSideLength), boxMaterial);
         mesh.castShadow = true;
         mesh.receiveShadow = true;
@@ -168,7 +180,7 @@ function animate() {
 
 // Helper functions
 
-function pixelTexture(texture) {
+function pixelTexture(texture: THREE.Texture) {
     texture.minFilter = THREE.NearestFilter;
     texture.magFilter = THREE.NearestFilter;
     texture.generateMipmaps = false;
@@ -178,25 +190,30 @@ function pixelTexture(texture) {
     return texture;
 }
 
-function easeInOutCubic(x) {
+function easeInOutCubic(x: number) {
     return x ** 2 * 3 - x ** 3 * 2;
 }
 
-function linearStep(x, edge0, edge1) {
+function linearStep(x: number, edge0: number, edge1: number) {
     const w = edge1 - edge0;
     const m = 1 / w;
     const y0 = -m * edge0;
     return THREE.MathUtils.clamp(y0 + m * x, 0, 1);
 }
 
-function stopGoEased(x, downtime, period) {
+function stopGoEased(x: number, downtime: number, period: number) {
     const cycle = (x / period) | 0;
     const tween = x - cycle * period;
     const linStep = easeInOutCubic(linearStep(tween, downtime, period));
     return cycle + linStep;
 }
 
-function pixelAlignFrustum(camera, aspectRatio, pixelsPerScreenWidth, pixelsPerScreenHeight) {
+function pixelAlignFrustum(
+    camera: THREE.OrthographicCamera,
+    aspectRatio: number,
+    pixelsPerScreenWidth: number,
+    pixelsPerScreenHeight: number,
+) {
     // 0. Get Pixel Grid Units
     const worldScreenWidth = (camera.right - camera.left) / camera.zoom;
     const worldScreenHeight = (camera.top - camera.bottom) / camera.zoom;
diff --git a/examples-testing/examples/webgl_postprocessing_procedural.ts b/examples-testing/examples/webgl_postprocessing_procedural.ts
index 860b1c4..e38910e 100644
--- a/examples-testing/examples/webgl_postprocessing_procedural.ts
+++ b/examples-testing/examples/webgl_postprocessing_procedural.ts
@@ -3,9 +3,13 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let postCamera, postScene, renderer;
-let postMaterial, noiseRandom1DMaterial, noiseRandom2DMaterial, noiseRandom3DMaterial, postQuad;
-let stats;
+let postCamera: THREE.OrthographicCamera, postScene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let postMaterial: THREE.ShaderMaterial,
+    noiseRandom1DMaterial: THREE.ShaderMaterial,
+    noiseRandom2DMaterial: THREE.ShaderMaterial,
+    noiseRandom3DMaterial: THREE.ShaderMaterial,
+    postQuad: THREE.Mesh;
+let stats: Stats;
 
 const params = { procedure: 'noiseRandom3D' };
 
@@ -20,7 +24,7 @@ function initGui() {
 }
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer();
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -33,16 +37,16 @@ function init() {
     // Setup post processing stage
     postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
     noiseRandom1DMaterial = new THREE.ShaderMaterial({
-        vertexShader: document.querySelector('#procedural-vert').textContent.trim(),
-        fragmentShader: document.querySelector('#noiseRandom1D-frag').textContent.trim(),
+        vertexShader: document.querySelector('#procedural-vert')!.textContent!.trim(),
+        fragmentShader: document.querySelector('#noiseRandom1D-frag')!.textContent!.trim(),
     });
     noiseRandom2DMaterial = new THREE.ShaderMaterial({
-        vertexShader: document.querySelector('#procedural-vert').textContent.trim(),
-        fragmentShader: document.querySelector('#noiseRandom2D-frag').textContent.trim(),
+        vertexShader: document.querySelector('#procedural-vert')!.textContent!.trim(),
+        fragmentShader: document.querySelector('#noiseRandom2D-frag')!.textContent!.trim(),
     });
     noiseRandom3DMaterial = new THREE.ShaderMaterial({
-        vertexShader: document.querySelector('#procedural-vert').textContent.trim(),
-        fragmentShader: document.querySelector('#noiseRandom3D-frag').textContent.trim(),
+        vertexShader: document.querySelector('#procedural-vert')!.textContent!.trim(),
+        fragmentShader: document.querySelector('#noiseRandom3D-frag')!.textContent!.trim(),
     });
     postMaterial = noiseRandom3DMaterial;
     const postPlane = new THREE.PlaneGeometry(2, 2);
diff --git a/examples-testing/examples/webgl_postprocessing_rgb_halftone.ts b/examples-testing/examples/webgl_postprocessing_rgb_halftone.ts
index e81303e..7d062b7 100644
--- a/examples-testing/examples/webgl_postprocessing_rgb_halftone.ts
+++ b/examples-testing/examples/webgl_postprocessing_rgb_halftone.ts
@@ -8,11 +8,11 @@ import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
 import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { HalftonePass } from 'three/addons/postprocessing/HalftonePass.js';
 
-let renderer, clock, camera, stats;
+let renderer: THREE.WebGLRenderer, clock: THREE.Clock, camera: THREE.PerspectiveCamera, stats: Stats;
 
 const rotationSpeed = Math.PI / 64;
 
-let composer, group;
+let composer: EffectComposer, group: THREE.Group;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_postprocessing_sao.ts b/examples-testing/examples/webgl_postprocessing_sao.ts
index 1e84217..da5730f 100644
--- a/examples-testing/examples/webgl_postprocessing_sao.ts
+++ b/examples-testing/examples/webgl_postprocessing_sao.ts
@@ -8,10 +8,10 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { SAOPass } from 'three/addons/postprocessing/SAOPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let container, stats;
-let camera, scene, renderer;
-let composer, renderPass, saoPass;
-let group;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let composer: EffectComposer, renderPass: RenderPass, saoPass: SAOPass;
+let group: THREE.Object3D;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_postprocessing_smaa.ts b/examples-testing/examples/webgl_postprocessing_smaa.ts
index 5eea466..011e6f4 100644
--- a/examples-testing/examples/webgl_postprocessing_smaa.ts
+++ b/examples-testing/examples/webgl_postprocessing_smaa.ts
@@ -7,13 +7,17 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, scene, renderer, composer, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    composer: EffectComposer,
+    stats: Stats;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer();
     renderer.setPixelRatio(window.devicePixelRatio);
diff --git a/examples-testing/examples/webgl_postprocessing_sobel.ts b/examples-testing/examples/webgl_postprocessing_sobel.ts
index 3266312..4712f25 100644
--- a/examples-testing/examples/webgl_postprocessing_sobel.ts
+++ b/examples-testing/examples/webgl_postprocessing_sobel.ts
@@ -11,9 +11,9 @@ import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
 import { LuminosityShader } from 'three/addons/shaders/LuminosityShader.js';
 import { SobelOperatorShader } from 'three/addons/shaders/SobelOperatorShader.js';
 
-let camera, scene, renderer, composer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
 
-let effectSobel;
+let effectSobel: ShaderPass;
 
 const params = {
     enable: true,
diff --git a/examples-testing/examples/webgl_postprocessing_ssaa.ts b/examples-testing/examples/webgl_postprocessing_ssaa.ts
index bca3b46..0aa0074 100644
--- a/examples-testing/examples/webgl_postprocessing_ssaa.ts
+++ b/examples-testing/examples/webgl_postprocessing_ssaa.ts
@@ -7,10 +7,10 @@ import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
 import { SSAARenderPass } from 'three/addons/postprocessing/SSAARenderPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let scene, renderer, composer;
-let cameraP, ssaaRenderPassP;
-let cameraO, ssaaRenderPassO;
-let gui, stats;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let cameraP: THREE.PerspectiveCamera, ssaaRenderPassP: SSAARenderPass;
+let cameraO: THREE.OrthographicCamera, ssaaRenderPassO: SSAARenderPass;
+let gui: GUI, stats: Stats;
 
 const params = {
     sampleLevel: 4,
@@ -51,7 +51,7 @@ function clearGui() {
 }
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     const width = window.innerWidth || 1;
     const height = window.innerHeight || 1;
@@ -200,7 +200,7 @@ function animate() {
     ssaaRenderPassP.enabled = params.camera === 'perspective';
     ssaaRenderPassO.enabled = params.camera === 'orthographic';
 
-    cameraP.view.offsetX = params.viewOffsetX;
+    cameraP.view!.offsetX = params.viewOffsetX;
 
     composer.render();
 
diff --git a/examples-testing/examples/webgl_postprocessing_ssao.ts b/examples-testing/examples/webgl_postprocessing_ssao.ts
index b4201ee..b3a308c 100644
--- a/examples-testing/examples/webgl_postprocessing_ssao.ts
+++ b/examples-testing/examples/webgl_postprocessing_ssao.ts
@@ -8,10 +8,10 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let container, stats;
-let camera, scene, renderer;
-let composer;
-let group;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let composer: EffectComposer;
+let group: THREE.Group;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_postprocessing_ssr.ts b/examples-testing/examples/webgl_postprocessing_ssr.ts
index 4af292e..bcf7969 100644
--- a/examples-testing/examples/webgl_postprocessing_ssr.ts
+++ b/examples-testing/examples/webgl_postprocessing_ssr.ts
@@ -18,17 +18,17 @@ const params = {
     otherMeshes: true,
     groundReflector: true,
 };
-let composer;
-let ssrPass;
-let gui;
-let stats;
-let controls;
-let camera, scene, renderer;
-const otherMeshes = [];
-let groundReflector;
-const selects = [];
-
-const container = document.querySelector('#container');
+let composer: EffectComposer;
+let ssrPass: SSRPass;
+let gui: GUI;
+let stats: Stats;
+let controls: OrbitControls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+const otherMeshes: THREE.Mesh[] = [];
+let groundReflector: ReflectorForSSRPass;
+const selects: THREE.Mesh[] = [];
+
+const container = document.querySelector('#container')!;
 
 // Configure and create Draco decoder.
 const dracoLoader = new DRACOLoader();
@@ -78,7 +78,7 @@ function init() {
         dracoLoader.dispose();
     });
 
-    let geometry, material, mesh;
+    let geometry: THREE.BufferGeometry, material: THREE.MeshStandardMaterial, mesh: THREE.Mesh;
 
     geometry = new THREE.BoxGeometry(0.05, 0.05, 0.05);
     material = new THREE.MeshStandardMaterial({ color: 'green' });
diff --git a/examples-testing/examples/webgl_postprocessing_taa.ts b/examples-testing/examples/webgl_postprocessing_taa.ts
index b2a12b5..b1efc76 100644
--- a/examples-testing/examples/webgl_postprocessing_taa.ts
+++ b/examples-testing/examples/webgl_postprocessing_taa.ts
@@ -8,8 +8,13 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { TAARenderPass } from 'three/addons/postprocessing/TAARenderPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, scene, renderer, composer, taaRenderPass, renderPass;
-let gui, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    composer: EffectComposer,
+    taaRenderPass: TAARenderPass,
+    renderPass: RenderPass;
+let gui: GUI | undefined, stats: Stats;
 let index = 0;
 
 const param = { TAAEnabled: '1', TAASampleLevel: 0 };
@@ -51,7 +56,7 @@ function clearGui() {
 }
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer();
     renderer.setPixelRatio(window.devicePixelRatio);
diff --git a/examples-testing/examples/webgl_postprocessing_unreal_bloom.ts b/examples-testing/examples/webgl_postprocessing_unreal_bloom.ts
index 886f77f..00666b2 100644
--- a/examples-testing/examples/webgl_postprocessing_unreal_bloom.ts
+++ b/examples-testing/examples/webgl_postprocessing_unreal_bloom.ts
@@ -10,8 +10,8 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, stats;
-let composer, renderer, mixer, clock;
+let camera: THREE.PerspectiveCamera, stats: Stats;
+let composer: EffectComposer, renderer: THREE.WebGLRenderer, mixer: THREE.AnimationMixer, clock: THREE.Clock;
 
 const params = {
     threshold: 0,
@@ -23,7 +23,7 @@ const params = {
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     stats = new Stats();
     container.appendChild(stats.dom);
diff --git a/examples-testing/examples/webgl_postprocessing_unreal_bloom_selective.ts b/examples-testing/examples/webgl_postprocessing_unreal_bloom_selective.ts
index d633806..a25f53b 100644
--- a/examples-testing/examples/webgl_postprocessing_unreal_bloom_selective.ts
+++ b/examples-testing/examples/webgl_postprocessing_unreal_bloom_selective.ts
@@ -22,7 +22,7 @@ const params = {
 };
 
 const darkMaterial = new THREE.MeshBasicMaterial({ color: 'black' });
-const materials = {};
+const materials: Record<string, THREE.Material | THREE.Material[]> = {};
 
 const renderer = new THREE.WebGLRenderer({ antialias: true });
 renderer.setPixelRatio(window.devicePixelRatio);
@@ -60,8 +60,8 @@ const mixPass = new ShaderPass(
             baseTexture: { value: null },
             bloomTexture: { value: bloomComposer.renderTarget2.texture },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
         defines: {},
     }),
     'baseTexture',
@@ -112,7 +112,7 @@ toneMappingFolder.add(params, 'exposure', 0.1, 2).onChange(function (value) {
 
 setupScene();
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
     mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
 
@@ -165,9 +165,9 @@ function setupScene() {
     render();
 }
 
-function disposeMaterial(obj) {
-    if (obj.material) {
-        obj.material.dispose();
+function disposeMaterial(obj: THREE.Object3D) {
+    if ((obj as THREE.Mesh).material) {
+        ((obj as THREE.Mesh).material as THREE.Material).dispose();
     }
 }
 
@@ -180,16 +180,16 @@ function render() {
     finalComposer.render();
 }
 
-function darkenNonBloomed(obj) {
-    if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
-        materials[obj.uuid] = obj.material;
-        obj.material = darkMaterial;
+function darkenNonBloomed(obj: THREE.Object3D) {
+    if ((obj as THREE.Mesh).isMesh && bloomLayer.test(obj.layers) === false) {
+        materials[obj.uuid] = (obj as THREE.Mesh).material;
+        (obj as THREE.Mesh).material = darkMaterial;
     }
 }
 
-function restoreMaterial(obj) {
+function restoreMaterial(obj: THREE.Object3D) {
     if (materials[obj.uuid]) {
-        obj.material = materials[obj.uuid];
+        (obj as THREE.Mesh).material = materials[obj.uuid];
         delete materials[obj.uuid];
     }
 }
diff --git a/examples-testing/examples/webgl_raymarching_reflect.ts b/examples-testing/examples/webgl_raymarching_reflect.ts
index 96f9a81..43bd75d 100644
--- a/examples-testing/examples/webgl_raymarching_reflect.ts
+++ b/examples-testing/examples/webgl_raymarching_reflect.ts
@@ -5,11 +5,11 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let dolly, camera, scene, renderer;
-let geometry, material, mesh;
-let stats, clock;
+let dolly: THREE.Group, camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let geometry: THREE.PlaneGeometry, material: THREE.RawShaderMaterial, mesh;
+let stats: Stats, clock: THREE.Clock;
 
-const canvas = document.querySelector('#canvas');
+const canvas = document.querySelector('#canvas') as HTMLCanvasElement;
 
 const config = {
     saveImage: function () {
@@ -48,8 +48,8 @@ function init() {
             cameraWorldMatrix: { value: camera.matrixWorld },
             cameraProjectionMatrixInverse: { value: camera.projectionMatrixInverse.clone() },
         },
-        vertexShader: document.getElementById('vertex_shader').textContent,
-        fragmentShader: document.getElementById('fragment_shader').textContent,
+        vertexShader: document.getElementById('vertex_shader')!.textContent!,
+        fragmentShader: document.getElementById('fragment_shader')!.textContent!,
     });
     mesh = new THREE.Mesh(geometry, material);
     mesh.frustumCulled = false;
diff --git a/examples-testing/examples/webgl_shadowmap_csm.ts b/examples-testing/examples/webgl_shadowmap_csm.ts
index f9df4ab..d2646fa 100644
--- a/examples-testing/examples/webgl_shadowmap_csm.ts
+++ b/examples-testing/examples/webgl_shadowmap_csm.ts
@@ -2,12 +2,31 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
-import { CSM } from 'three/addons/csm/CSM.js';
+import { CSM, CSMMode } from 'three/addons/csm/CSM.js';
 import { CSMHelper } from 'three/addons/csm/CSMHelper.js';
 
-let renderer, scene, camera, orthoCamera, controls, csm, csmHelper;
-
-const params = {
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    orthoCamera: THREE.OrthographicCamera,
+    controls: OrbitControls,
+    csm: CSM,
+    csmHelper: CSMHelper;
+
+const params: {
+    orthographic: boolean;
+    fade: boolean;
+    far: number;
+    mode: CSMMode;
+    lightX: number;
+    lightY: number;
+    lightZ: number;
+    margin: number;
+    lightFar: number;
+    lightNear: number;
+    autoUpdateHelper: boolean;
+    updateHelper: () => void;
+} = {
     orthographic: false,
     fade: false,
     far: 1000,
diff --git a/examples-testing/examples/webgl_shadowmap_pcss.ts b/examples-testing/examples/webgl_shadowmap_pcss.ts
index 91ba360..230059a 100644
--- a/examples-testing/examples/webgl_shadowmap_pcss.ts
+++ b/examples-testing/examples/webgl_shadowmap_pcss.ts
@@ -4,10 +4,10 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let stats;
-let camera, scene, renderer;
+let stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let group;
+let group: THREE.Group;
 
 init();
 animate();
@@ -96,12 +96,12 @@ function init() {
 
     shader = shader.replace(
         '#ifdef USE_SHADOWMAP',
-        '#ifdef USE_SHADOWMAP' + document.getElementById('PCSS').textContent,
+        '#ifdef USE_SHADOWMAP' + document.getElementById('PCSS')!.textContent,
     );
 
     shader = shader.replace(
         '#if defined( SHADOWMAP_TYPE_PCF )',
-        document.getElementById('PCSSGetShadow').textContent + '#if defined( SHADOWMAP_TYPE_PCF )',
+        document.getElementById('PCSSGetShadow')!.textContent + '#if defined( SHADOWMAP_TYPE_PCF )',
     );
 
     THREE.ShaderChunk.shadowmap_pars_fragment = shader;
diff --git a/examples-testing/examples/webgl_shadowmap_progressive.ts b/examples-testing/examples/webgl_shadowmap_progressive.ts
index eaf6e32..d3592c8 100644
--- a/examples-testing/examples/webgl_shadowmap_progressive.ts
+++ b/examples-testing/examples/webgl_shadowmap_progressive.ts
@@ -9,17 +9,17 @@ import { ProgressiveLightMap } from 'three/addons/misc/ProgressiveLightMap.js';
 const shadowMapRes = 512,
     lightMapRes = 1024,
     lightCount = 8;
-let camera,
-    scene,
-    renderer,
-    controls,
-    control,
-    control2,
-    object = new THREE.Mesh(),
-    lightOrigin = null,
-    progressiveSurfacemap;
-const dirLights = [],
-    lightmapObjects = [];
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    controls: OrbitControls,
+    control: TransformControls,
+    control2: TransformControls,
+    object: THREE.Object3D = new THREE.Mesh(),
+    lightOrigin: THREE.Group | null = null,
+    progressiveSurfacemap: ProgressiveLightMap;
+const dirLights: THREE.DirectionalLight[] = [],
+    lightmapObjects: THREE.Object3D[] = [];
 const params = {
     Enable: true,
     'Blur Edges': true,
@@ -98,11 +98,11 @@ function init() {
     // model
     function loadModel() {
         object.traverse(function (child) {
-            if (child.isMesh) {
+            if ((child as THREE.Mesh).isMesh) {
                 child.name = 'Loaded Mesh';
                 child.castShadow = true;
                 child.receiveShadow = true;
-                child.material = new THREE.MeshPhongMaterial();
+                (child as THREE.Mesh).material = new THREE.MeshPhongMaterial();
 
                 // This adds the model to the lightmap
                 lightmapObjects.push(child);
@@ -128,7 +128,7 @@ function init() {
 
         object.add(lightTarget);
 
-        if (typeof TESTING !== 'undefined') {
+        if (typeof (window as any).TESTING !== 'undefined') {
             for (let i = 0; i < 300; i++) {
                 render();
             }
@@ -188,9 +188,9 @@ function render() {
         // Sometimes they will be uniformly sampled from the upper hemisphere
         if (Math.random() > params['Ambient Weight']) {
             dirLights[l].position.set(
-                lightOrigin.position.x + Math.random() * params['Light Radius'],
-                lightOrigin.position.y + Math.random() * params['Light Radius'],
-                lightOrigin.position.z + Math.random() * params['Light Radius'],
+                lightOrigin!.position.x + Math.random() * params['Light Radius'],
+                lightOrigin!.position.y + Math.random() * params['Light Radius'],
+                lightOrigin!.position.z + Math.random() * params['Light Radius'],
             );
         } else {
             // Uniform Hemispherical Surface Distribution for Ambient Occlusion
diff --git a/examples-testing/examples/webgl_simple_gi.ts b/examples-testing/examples/webgl_simple_gi.ts
index cd5d567..12c30ec 100644
--- a/examples-testing/examples/webgl_simple_gi.ts
+++ b/examples-testing/examples/webgl_simple_gi.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 class GIMesh extends THREE.Mesh {
-    copy(source) {
+    copy(source: this) {
         super.copy(source);
 
         this.geometry = source.geometry.clone();
@@ -14,105 +14,107 @@ class GIMesh extends THREE.Mesh {
 
 //
 
-const SimpleGI = function (renderer, scene) {
-    const SIZE = 32,
-        SIZE2 = SIZE * SIZE;
+class SimpleGI {
+    constructor(renderer: THREE.WebGLRenderer, scene: THREE.Scene) {
+        const SIZE = 32,
+            SIZE2 = SIZE * SIZE;
 
-    const camera = new THREE.PerspectiveCamera(90, 1, 0.01, 100);
+        const camera = new THREE.PerspectiveCamera(90, 1, 0.01, 100);
 
-    scene.updateMatrixWorld(true);
+        scene.updateMatrixWorld(true);
 
-    let clone = scene.clone();
-    clone.matrixWorldAutoUpdate = false;
+        let clone = scene.clone();
+        clone.matrixWorldAutoUpdate = false;
 
-    const rt = new THREE.WebGLRenderTarget(SIZE, SIZE);
+        const rt = new THREE.WebGLRenderTarget(SIZE, SIZE);
 
-    const normalMatrix = new THREE.Matrix3();
+        const normalMatrix = new THREE.Matrix3();
 
-    const position = new THREE.Vector3();
-    const normal = new THREE.Vector3();
+        const position = new THREE.Vector3();
+        const normal = new THREE.Vector3();
 
-    let bounces = 0;
-    let currentVertex = 0;
+        let bounces = 0;
+        let currentVertex = 0;
 
-    const color = new Float32Array(3);
-    const buffer = new Uint8Array(SIZE2 * 4);
+        const color = new Float32Array(3);
+        const buffer = new Uint8Array(SIZE2 * 4);
 
-    function compute() {
-        if (bounces === 3) return;
+        function compute() {
+            if (bounces === 3) return;
 
-        const object = scene.children[0]; // torusKnot
-        const geometry = object.geometry;
+            const object = scene.children[0] as GIMesh; // torusKnot
+            const geometry = object.geometry;
 
-        const attributes = geometry.attributes;
-        const positions = attributes.position.array;
-        const normals = attributes.normal.array;
+            const attributes = geometry.attributes;
+            const positions = attributes.position.array;
+            const normals = attributes.normal.array;
 
-        if (attributes.color === undefined) {
-            const colors = new Float32Array(positions.length);
-            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));
-        }
+            if (attributes.color === undefined) {
+                const colors = new Float32Array(positions.length);
+                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));
+            }
 
-        const colors = attributes.color.array;
+            const colors = attributes.color.array;
 
-        const startVertex = currentVertex;
-        const totalVertex = positions.length / 3;
+            const startVertex = currentVertex;
+            const totalVertex = positions.length / 3;
 
-        for (let i = 0; i < 32; i++) {
-            if (currentVertex >= totalVertex) break;
+            for (let i = 0; i < 32; i++) {
+                if (currentVertex >= totalVertex) break;
 
-            position.fromArray(positions, currentVertex * 3);
-            position.applyMatrix4(object.matrixWorld);
+                position.fromArray(positions, currentVertex * 3);
+                position.applyMatrix4(object.matrixWorld);
 
-            normal.fromArray(normals, currentVertex * 3);
-            normal.applyMatrix3(normalMatrix.getNormalMatrix(object.matrixWorld)).normalize();
+                normal.fromArray(normals, currentVertex * 3);
+                normal.applyMatrix3(normalMatrix.getNormalMatrix(object.matrixWorld)).normalize();
 
-            camera.position.copy(position);
-            camera.lookAt(position.add(normal));
+                camera.position.copy(position);
+                camera.lookAt(position.add(normal));
 
-            renderer.setRenderTarget(rt);
-            renderer.render(clone, camera);
+                renderer.setRenderTarget(rt);
+                renderer.render(clone, camera);
 
-            renderer.readRenderTargetPixels(rt, 0, 0, SIZE, SIZE, buffer);
+                renderer.readRenderTargetPixels(rt, 0, 0, SIZE, SIZE, buffer);
 
-            color[0] = 0;
-            color[1] = 0;
-            color[2] = 0;
+                color[0] = 0;
+                color[1] = 0;
+                color[2] = 0;
 
-            for (let k = 0, kl = buffer.length; k < kl; k += 4) {
-                color[0] += buffer[k + 0];
-                color[1] += buffer[k + 1];
-                color[2] += buffer[k + 2];
-            }
+                for (let k = 0, kl = buffer.length; k < kl; k += 4) {
+                    color[0] += buffer[k + 0];
+                    color[1] += buffer[k + 1];
+                    color[2] += buffer[k + 2];
+                }
 
-            colors[currentVertex * 3 + 0] = color[0] / (SIZE2 * 255);
-            colors[currentVertex * 3 + 1] = color[1] / (SIZE2 * 255);
-            colors[currentVertex * 3 + 2] = color[2] / (SIZE2 * 255);
+                colors[currentVertex * 3 + 0] = color[0] / (SIZE2 * 255);
+                colors[currentVertex * 3 + 1] = color[1] / (SIZE2 * 255);
+                colors[currentVertex * 3 + 2] = color[2] / (SIZE2 * 255);
 
-            currentVertex++;
-        }
+                currentVertex++;
+            }
 
-        attributes.color.updateRange.offset = startVertex * 3;
-        attributes.color.updateRange.count = (currentVertex - startVertex) * 3;
-        attributes.color.needsUpdate = true;
+            (attributes.color as THREE.BufferAttribute).updateRange.offset = startVertex * 3;
+            (attributes.color as THREE.BufferAttribute).updateRange.count = (currentVertex - startVertex) * 3;
+            attributes.color.needsUpdate = true;
 
-        if (currentVertex >= totalVertex) {
-            clone = scene.clone();
-            clone.matrixWorldAutoUpdate = false;
+            if (currentVertex >= totalVertex) {
+                clone = scene.clone();
+                clone.matrixWorldAutoUpdate = false;
 
-            bounces++;
-            currentVertex = 0;
+                bounces++;
+                currentVertex = 0;
+            }
+
+            requestAnimationFrame(compute);
         }
 
         requestAnimationFrame(compute);
     }
-
-    requestAnimationFrame(compute);
-};
+}
 
 //
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
diff --git a/examples-testing/examples/webxr_ar_cones.ts b/examples-testing/examples/webxr_ar_cones.ts
index 996e41f..03af8ca 100644
--- a/examples-testing/examples/webxr_ar_cones.ts
+++ b/examples-testing/examples/webxr_ar_cones.ts
@@ -1,8 +1,8 @@
 import * as THREE from 'three';
 import { ARButton } from 'three/addons/webxr/ARButton.js';
 
-let camera, scene, renderer;
-let controller;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controller: THREE.XRTargetRaySpace;
 
 init();
 animate();
diff --git a/examples-testing/examples/webxr_ar_hittest.ts b/examples-testing/examples/webxr_ar_hittest.ts
index 5540c90..0cd8a4f 100644
--- a/examples-testing/examples/webxr_ar_hittest.ts
+++ b/examples-testing/examples/webxr_ar_hittest.ts
@@ -1,13 +1,13 @@
 import * as THREE from 'three';
 import { ARButton } from 'three/addons/webxr/ARButton.js';
 
-let container;
-let camera, scene, renderer;
-let controller;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controller: THREE.XRTargetRaySpace;
 
-let reticle;
+let reticle: THREE.Mesh;
 
-let hitTestSource = null;
+let hitTestSource: XRHitTestSource | null = null;
 let hitTestSourceRequested = false;
 
 init();
@@ -81,14 +81,14 @@ function animate() {
     renderer.setAnimationLoop(render);
 }
 
-function render(timestamp, frame) {
+function render(timestamp: DOMHighResTimeStamp, frame: XRFrame) {
     if (frame) {
         const referenceSpace = renderer.xr.getReferenceSpace();
-        const session = renderer.xr.getSession();
+        const session = renderer.xr.getSession()!;
 
         if (hitTestSourceRequested === false) {
             session.requestReferenceSpace('viewer').then(function (referenceSpace) {
-                session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
+                session.requestHitTestSource!({ space: referenceSpace })!.then(function (source) {
                     hitTestSource = source;
                 });
             });
@@ -108,7 +108,7 @@ function render(timestamp, frame) {
                 const hit = hitTestResults[0];
 
                 reticle.visible = true;
-                reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
+                reticle.matrix.fromArray(hit.getPose(referenceSpace!)!.transform.matrix);
             } else {
                 reticle.visible = false;
             }
diff --git a/examples-testing/examples/webxr_ar_lighting.ts b/examples-testing/examples/webxr_ar_lighting.ts
index 1a9c4de..53cb684 100644
--- a/examples-testing/examples/webxr_ar_lighting.ts
+++ b/examples-testing/examples/webxr_ar_lighting.ts
@@ -3,9 +3,9 @@ import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 import { ARButton } from 'three/addons/webxr/ARButton.js';
 import { XREstimatedLight } from 'three/addons/webxr/XREstimatedLight.js';
 
-let camera, scene, renderer;
-let controller;
-let defaultEnvironment;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controller: THREE.XRTargetRaySpace;
+let defaultEnvironment: THREE.DataTexture;
 
 init();
 animate();
diff --git a/examples-testing/examples/webxr_vr_handinput.ts b/examples-testing/examples/webxr_vr_handinput.ts
index a896103..797674f 100644
--- a/examples-testing/examples/webxr_vr_handinput.ts
+++ b/examples-testing/examples/webxr_vr_handinput.ts
@@ -4,13 +4,13 @@ import { VRButton } from 'three/addons/webxr/VRButton.js';
 import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
 import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';
 
-let container;
-let camera, scene, renderer;
-let hand1, hand2;
-let controller1, controller2;
-let controllerGrip1, controllerGrip2;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let hand1: THREE.XRHandSpace, hand2: THREE.XRHandSpace;
+let controller1: THREE.XRTargetRaySpace, controller2: THREE.XRTargetRaySpace;
+let controllerGrip1: THREE.XRGripSpace, controllerGrip2: THREE.XRGripSpace;
 
-let controls;
+let controls: OrbitControls;
 
 init();
 animate();
diff --git a/examples-testing/examples/webxr_vr_panorama.ts b/examples-testing/examples/webxr_vr_panorama.ts
index fdd23aa..bd103ef 100644
--- a/examples-testing/examples/webxr_vr_panorama.ts
+++ b/examples-testing/examples/webxr_vr_panorama.ts
@@ -1,9 +1,9 @@
 import * as THREE from 'three';
 import { VRButton } from 'three/addons/webxr/VRButton.js';
 
-let camera;
-let renderer;
-let scene;
+let camera: THREE.PerspectiveCamera;
+let renderer: THREE.WebGLRenderer;
+let scene: THREE.Scene;
 
 init();
 animate();
@@ -53,8 +53,8 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function getTexturesFromAtlasFile(atlasImgUrl, tilesNum) {
-    const textures = [];
+function getTexturesFromAtlasFile(atlasImgUrl: string, tilesNum: number) {
+    const textures: THREE.Texture[] = [];
 
     for (let i = 0; i < tilesNum; i++) {
         textures[i] = new THREE.Texture();
@@ -67,7 +67,7 @@ function getTexturesFromAtlasFile(atlasImgUrl, tilesNum) {
 
         for (let i = 0; i < textures.length; i++) {
             canvas = document.createElement('canvas');
-            context = canvas.getContext('2d');
+            context = canvas.getContext('2d')!;
             canvas.height = tileWidth;
             canvas.width = tileWidth;
             context.drawImage(imageObj, tileWidth * i, 0, tileWidth, tileWidth, 0, 0, tileWidth, tileWidth);
diff --git a/examples-testing/examples/webxr_vr_panorama_depth.ts b/examples-testing/examples/webxr_vr_panorama_depth.ts
index a09b733..292719d 100644
--- a/examples-testing/examples/webxr_vr_panorama_depth.ts
+++ b/examples-testing/examples/webxr_vr_panorama_depth.ts
@@ -1,13 +1,17 @@
 import * as THREE from 'three';
 import { VRButton } from 'three/addons/webxr/VRButton.js';
 
-let camera, scene, renderer, sphere, clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    sphere: THREE.Mesh<THREE.SphereGeometry, THREE.MeshStandardMaterial>,
+    clock: THREE.Clock;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     clock = new THREE.Clock();
 
diff --git a/examples-testing/examples/webxr_vr_rollercoaster.ts b/examples-testing/examples/webxr_vr_rollercoaster.ts
index b659652..a10b469 100644
--- a/examples-testing/examples/webxr_vr_rollercoaster.ts
+++ b/examples-testing/examples/webxr_vr_rollercoaster.ts
@@ -9,7 +9,7 @@ import {
 } from 'three/addons/misc/RollerCoaster.js';
 import { VRButton } from 'three/addons/webxr/VRButton.js';
 
-let mesh, material, geometry;
+let mesh: THREE.Mesh, material: THREE.MeshBasicMaterial, geometry: SkyGeometry;
 
 const renderer = new THREE.WebGLRenderer({ antialias: true });
 renderer.setPixelRatio(window.devicePixelRatio);
@@ -86,7 +86,7 @@ const curve = (function () {
     const vector2 = new THREE.Vector3();
 
     return {
-        getPointAt: function (t) {
+        getPointAt: function (t: number) {
             t = t * PI2;
 
             const x = Math.sin(t * 3) * Math.cos(t * 4) * 50;
@@ -96,7 +96,7 @@ const curve = (function () {
             return vector.set(x, y, z).multiplyScalar(2);
         },
 
-        getTangentAt: function (t) {
+        getTangentAt: function (t: number) {
             const delta = 0.0001;
             const t1 = Math.max(0, t - delta);
             const t2 = Math.min(1, t + delta);
@@ -129,7 +129,7 @@ mesh = new THREE.Mesh(geometry, material);
 mesh.position.y = 0.1;
 scene.add(mesh);
 
-const funfairs = [];
+const funfairs: THREE.Mesh[] = [];
 
 //
 
diff --git a/examples-testing/examples/webxr_vr_sandbox.ts b/examples-testing/examples/webxr_vr_sandbox.ts
index aa80cf7..e929206 100644
--- a/examples-testing/examples/webxr_vr_sandbox.ts
+++ b/examples-testing/examples/webxr_vr_sandbox.ts
@@ -12,9 +12,9 @@ import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFa
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer;
-let reflector;
-let stats, statsMesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let reflector: Reflector;
+let stats: Stats, statsMesh: HTMLMesh;
 
 const parameters = {
     radius: 0.6,
@@ -197,7 +197,7 @@ function animate() {
 
 function render() {
     const time = performance.now() * 0.0002;
-    const torus = scene.getObjectByName('torus');
+    const torus = scene.getObjectByName('torus')!;
     torus.rotation.x = time * 0.4;
     torus.rotation.y = time;
 
@@ -205,5 +205,9 @@ function render() {
     stats.update();
 
     // Canvas elements doesn't trigger DOM updates, so we have to update the texture
-    statsMesh.material.map.update();
+    (statsMesh.material.map as HTMLTexture).update();
+}
+
+interface HTMLTexture extends THREE.CanvasTexture {
+    update(): void;
 }
diff --git a/examples-testing/examples/webxr_vr_video.ts b/examples-testing/examples/webxr_vr_video.ts
index 2baded4..9c3f5e7 100644
--- a/examples-testing/examples/webxr_vr_video.ts
+++ b/examples-testing/examples/webxr_vr_video.ts
@@ -1,13 +1,13 @@
 import * as THREE from 'three';
 import { VRButton } from 'three/addons/webxr/VRButton.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.addEventListener('click', function () {
         video.play();
     });
@@ -17,7 +17,7 @@ function init() {
 
     // video
 
-    const video = document.getElementById('video');
+    const video = document.getElementById('video') as HTMLVideoElement;
     video.play();
 
     const texture = new THREE.VideoTexture(video);
