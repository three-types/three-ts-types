diff --git a/examples-testing/examples/css2d_label.ts b/examples-testing/examples/css2d_label.ts
index 48a2d1f..e726021 100644
--- a/examples-testing/examples/css2d_label.ts
+++ b/examples-testing/examples/css2d_label.ts
@@ -7,7 +7,7 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 let gui;
 
-let camera, scene, renderer, labelRenderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, labelRenderer: CSS2DRenderer;
 
 const layers = {
     'Toggle Name': function () {
@@ -28,7 +28,7 @@ const layers = {
 const clock = new THREE.Clock();
 const textureLoader = new THREE.TextureLoader();
 
-let moon;
+let moon: THREE.Mesh;
 
 init();
 animate();
@@ -63,7 +63,7 @@ function init() {
         normalMap: textureLoader.load('textures/planets/earth_normal_2048.jpg'),
         normalScale: new THREE.Vector2(0.85, 0.85),
     });
-    earthMaterial.map.colorSpace = THREE.SRGBColorSpace;
+    earthMaterial.map!.colorSpace = THREE.SRGBColorSpace;
     const earth = new THREE.Mesh(earthGeometry, earthMaterial);
     scene.add(earth);
 
@@ -72,7 +72,7 @@ function init() {
         shininess: 5,
         map: textureLoader.load('textures/planets/moon_1024.jpg'),
     });
-    moonMaterial.map.colorSpace = THREE.SRGBColorSpace;
+    moonMaterial.map!.colorSpace = THREE.SRGBColorSpace;
     moon = new THREE.Mesh(moonGeometry, moonMaterial);
     scene.add(moon);
 
diff --git a/examples-testing/examples/css3d_molecules.ts b/examples-testing/examples/css3d_molecules.ts
index 5384726..f08bb34 100644
--- a/examples-testing/examples/css3d_molecules.ts
+++ b/examples-testing/examples/css3d_molecules.ts
@@ -5,11 +5,11 @@ import { PDBLoader } from 'three/addons/loaders/PDBLoader.js';
 import { CSS3DRenderer, CSS3DObject, CSS3DSprite } from 'three/addons/renderers/CSS3DRenderer.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
-let controls;
-let root;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: CSS3DRenderer;
+let controls: TrackballControls;
+let root: THREE.Object3D;
 
-const objects = [];
+const objects: Array<CSS3DObject | CSS3DSprite> = [];
 const tmpVec1 = new THREE.Vector3();
 const tmpVec2 = new THREE.Vector3();
 const tmpVec3 = new THREE.Vector3();
@@ -49,7 +49,7 @@ const params = {
 };
 
 const loader = new PDBLoader();
-const colorSpriteMap = {};
+const colorSpriteMap: { [element: string]: string | undefined } = {};
 const baseSprite = document.createElement('img');
 
 init();
@@ -68,7 +68,7 @@ function init() {
 
     renderer = new CSS3DRenderer();
     renderer.setSize(window.innerWidth, window.innerHeight);
-    document.getElementById('container').appendChild(renderer.domElement);
+    document.getElementById('container')!.appendChild(renderer.domElement);
 
     //
 
@@ -96,7 +96,7 @@ function init() {
     gui.open();
 }
 
-function changeVizType(value) {
+function changeVizType(value: number) {
     if (value === 0) showAtoms();
     else if (value === 1) showBonds();
     else showAtomsBonds();
@@ -148,7 +148,7 @@ function showAtomsBonds() {
 
 //
 
-function colorify(ctx, width, height, color) {
+function colorify(ctx: CanvasRenderingContext2D, width: number, height: number, color: THREE.Color) {
     const r = color.r,
         g = color.g,
         b = color.b;
@@ -165,7 +165,7 @@ function colorify(ctx, width, height, color) {
     ctx.putImageData(imageData, 0, 0);
 }
 
-function imageToCanvas(image) {
+function imageToCanvas(image: HTMLImageElement) {
     const width = image.width;
     const height = image.height;
 
@@ -174,7 +174,7 @@ function imageToCanvas(image) {
     canvas.width = width;
     canvas.height = height;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     context.drawImage(image, 0, 0, width, height);
 
     return canvas;
@@ -182,12 +182,12 @@ function imageToCanvas(image) {
 
 //
 
-function loadMolecule(model) {
+function loadMolecule(model: string) {
     const url = 'models/pdb/' + model;
 
     for (let i = 0; i < objects.length; i++) {
         const object = objects[i];
-        object.parent.remove(object);
+        object.parent!.remove(object);
     }
 
     objects.length = 0;
@@ -198,7 +198,7 @@ function loadMolecule(model) {
         const json = pdb.json;
 
         geometryAtoms.computeBoundingBox();
-        geometryAtoms.boundingBox.getCenter(offset).negate();
+        geometryAtoms.boundingBox!.getCenter(offset).negate();
 
         geometryAtoms.translate(offset.x, offset.y, offset.z);
         geometryBonds.translate(offset.x, offset.y, offset.z);
@@ -218,7 +218,7 @@ function loadMolecule(model) {
 
             if (!colorSpriteMap[element]) {
                 const canvas = imageToCanvas(baseSprite);
-                const context = canvas.getContext('2d');
+                const context = canvas.getContext('2d')!;
 
                 colorify(context, canvas.width, canvas.height, color);
 
@@ -227,7 +227,7 @@ function loadMolecule(model) {
                 colorSpriteMap[element] = dataUrl;
             }
 
-            const colorSprite = colorSpriteMap[element];
+            const colorSprite = colorSpriteMap[element]!;
 
             const atom = document.createElement('img');
             atom.src = colorSprite;
diff --git a/examples-testing/examples/css3d_orthographic.ts b/examples-testing/examples/css3d_orthographic.ts
index 4aabbed..67e41fd 100644
--- a/examples-testing/examples/css3d_orthographic.ts
+++ b/examples-testing/examples/css3d_orthographic.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
-import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
+import { Controller, GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let scene2, renderer2;
+let scene2: THREE.Scene, renderer2: CSS3DRenderer;
 
 const frustumSize = 500;
 
@@ -75,18 +75,18 @@ function init() {
     renderer2 = new CSS3DRenderer();
     renderer2.setSize(window.innerWidth, window.innerHeight);
     renderer2.domElement.style.position = 'absolute';
-    renderer2.domElement.style.top = 0;
+    renderer2.domElement.style.top = '0';
     document.body.appendChild(renderer2.domElement);
 
     const controls = new OrbitControls(camera, renderer2.domElement);
     controls.minZoom = 0.5;
     controls.maxZoom = 2;
 
-    function createPlane(width, height, cssColor, pos, rot) {
+    function createPlane(width: number, height: number, cssColor: string, pos: THREE.Vector3, rot: THREE.Euler) {
         const element = document.createElement('div');
         element.style.width = width + 'px';
         element.style.height = height + 'px';
-        element.style.opacity = 0.75;
+        element.style.opacity = '0.75';
         element.style.background = cssColor;
 
         const object = new CSS3DObject(element);
@@ -133,12 +133,12 @@ function createPanel() {
 
     const settings = {
         setViewOffset() {
-            folder1.children[1].enable().setValue(window.innerWidth);
-            folder1.children[2].enable().setValue(window.innerHeight);
-            folder1.children[3].enable().setValue(0);
-            folder1.children[4].enable().setValue(0);
-            folder1.children[5].enable().setValue(window.innerWidth);
-            folder1.children[6].enable().setValue(window.innerHeight);
+            (folder1.children[1] as Controller).enable().setValue(window.innerWidth);
+            (folder1.children[2] as Controller).enable().setValue(window.innerHeight);
+            (folder1.children[3] as Controller).enable().setValue(0);
+            (folder1.children[4] as Controller).enable().setValue(0);
+            (folder1.children[5] as Controller).enable().setValue(window.innerWidth);
+            (folder1.children[6] as Controller).enable().setValue(window.innerHeight);
         },
         fullWidth: 0,
         fullHeight: 0,
@@ -147,12 +147,12 @@ function createPanel() {
         width: 0,
         height: 0,
         clearViewOffset() {
-            folder1.children[1].setValue(0).disable();
-            folder1.children[2].setValue(0).disable();
-            folder1.children[3].setValue(0).disable();
-            folder1.children[4].setValue(0).disable();
-            folder1.children[5].setValue(0).disable();
-            folder1.children[6].setValue(0).disable();
+            (folder1.children[1] as Controller).setValue(0).disable();
+            (folder1.children[2] as Controller).setValue(0).disable();
+            (folder1.children[3] as Controller).setValue(0).disable();
+            (folder1.children[4] as Controller).setValue(0).disable();
+            (folder1.children[5] as Controller).setValue(0).disable();
+            (folder1.children[6] as Controller).setValue(0).disable();
             camera.clearViewOffset();
         },
     };
@@ -185,7 +185,21 @@ function createPanel() {
     folder1.add(settings, 'clearViewOffset');
 }
 
-function updateCameraViewOffset({ fullWidth, fullHeight, x, y, width, height }) {
+function updateCameraViewOffset({
+    fullWidth,
+    fullHeight,
+    x,
+    y,
+    width,
+    height,
+}: {
+    fullWidth?: number;
+    fullHeight?: number;
+    x?: number;
+    y?: number;
+    width?: number;
+    height?: number;
+}) {
     if (!camera.view) {
         camera.setViewOffset(
             fullWidth || window.innerWidth,
diff --git a/examples-testing/examples/css3d_periodictable.ts b/examples-testing/examples/css3d_periodictable.ts
index e3a33f7..516df46 100644
--- a/examples-testing/examples/css3d_periodictable.ts
+++ b/examples-testing/examples/css3d_periodictable.ts
@@ -597,11 +597,16 @@ const table = [
     7,
 ];
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: CSS3DRenderer;
+let controls: TrackballControls;
 
-const objects = [];
-const targets = { table: [], sphere: [], helix: [], grid: [] };
+const objects: CSS3DObject[] = [];
+const targets: {
+    table: THREE.Object3D[];
+    sphere: THREE.Object3D[];
+    helix: THREE.Object3D[];
+    grid: THREE.Object3D[];
+} = { table: [], sphere: [], helix: [], grid: [] };
 
 init();
 animate();
@@ -621,12 +626,12 @@ function init() {
 
         const number = document.createElement('div');
         number.className = 'number';
-        number.textContent = i / 5 + 1;
+        number.textContent = `${i / 5 + 1}`;
         element.appendChild(number);
 
         const symbol = document.createElement('div');
         symbol.className = 'symbol';
-        symbol.textContent = table[i];
+        symbol.textContent = table[i] as string;
         element.appendChild(symbol);
 
         const details = document.createElement('div');
@@ -645,8 +650,8 @@ function init() {
         //
 
         const object = new THREE.Object3D();
-        object.position.x = table[i + 3] * 140 - 1330;
-        object.position.y = -(table[i + 4] * 180) + 990;
+        object.position.x = (table[i + 3] as number) * 140 - 1330;
+        object.position.y = -((table[i + 4] as number) * 180) + 990;
 
         targets.table.push(object);
     }
@@ -705,7 +710,7 @@ function init() {
 
     renderer = new CSS3DRenderer();
     renderer.setSize(window.innerWidth, window.innerHeight);
-    document.getElementById('container').appendChild(renderer.domElement);
+    document.getElementById('container')!.appendChild(renderer.domElement);
 
     //
 
@@ -714,22 +719,22 @@ function init() {
     controls.maxDistance = 6000;
     controls.addEventListener('change', render);
 
-    const buttonTable = document.getElementById('table');
+    const buttonTable = document.getElementById('table')!;
     buttonTable.addEventListener('click', function () {
         transform(targets.table, 2000);
     });
 
-    const buttonSphere = document.getElementById('sphere');
+    const buttonSphere = document.getElementById('sphere')!;
     buttonSphere.addEventListener('click', function () {
         transform(targets.sphere, 2000);
     });
 
-    const buttonHelix = document.getElementById('helix');
+    const buttonHelix = document.getElementById('helix')!;
     buttonHelix.addEventListener('click', function () {
         transform(targets.helix, 2000);
     });
 
-    const buttonGrid = document.getElementById('grid');
+    const buttonGrid = document.getElementById('grid')!;
     buttonGrid.addEventListener('click', function () {
         transform(targets.grid, 2000);
     });
@@ -741,7 +746,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function transform(targets, duration) {
+function transform(targets: THREE.Object3D[], duration: number) {
     TWEEN.removeAll();
 
     for (let i = 0; i < objects.length; i++) {
@@ -765,7 +770,7 @@ function transform(targets, duration) {
             .start();
     }
 
-    new TWEEN.Tween(this)
+    new TWEEN.Tween({})
         .to({}, duration * 2)
         .onUpdate(render)
         .start();
diff --git a/examples-testing/examples/css3d_sandbox.ts b/examples-testing/examples/css3d_sandbox.ts
index 1088b84..02f1fa7 100644
--- a/examples-testing/examples/css3d_sandbox.ts
+++ b/examples-testing/examples/css3d_sandbox.ts
@@ -2,13 +2,13 @@ import * as THREE from 'three';
 
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
-import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
+import { Controller, GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let scene2, renderer2;
+let scene2: THREE.Scene, renderer2: CSS3DRenderer;
 
-let controls;
+let controls: TrackballControls;
 
 init();
 animate();
@@ -35,7 +35,7 @@ function init() {
         const element = document.createElement('div');
         element.style.width = '100px';
         element.style.height = '100px';
-        element.style.opacity = i < 5 ? 0.5 : 1;
+        element.style.opacity = `${i < 5 ? 0.5 : 1}`;
         element.style.background = new THREE.Color(Math.random() * 0xffffff).getStyle();
 
         const object = new CSS3DObject(element);
@@ -67,7 +67,7 @@ function init() {
     renderer2 = new CSS3DRenderer();
     renderer2.setSize(window.innerWidth, window.innerHeight);
     renderer2.domElement.style.position = 'absolute';
-    renderer2.domElement.style.top = 0;
+    renderer2.domElement.style.top = '0';
     document.body.appendChild(renderer2.domElement);
 
     controls = new TrackballControls(camera, renderer2.domElement);
@@ -101,12 +101,12 @@ function createPanel() {
 
     const settings = {
         setViewOffset() {
-            folder1.children[1].enable().setValue(window.innerWidth);
-            folder1.children[2].enable().setValue(window.innerHeight);
-            folder1.children[3].enable().setValue(0);
-            folder1.children[4].enable().setValue(0);
-            folder1.children[5].enable().setValue(window.innerWidth);
-            folder1.children[6].enable().setValue(window.innerHeight);
+            (folder1.children[1] as Controller).enable().setValue(window.innerWidth);
+            (folder1.children[2] as Controller).enable().setValue(window.innerHeight);
+            (folder1.children[3] as Controller).enable().setValue(0);
+            (folder1.children[4] as Controller).enable().setValue(0);
+            (folder1.children[5] as Controller).enable().setValue(window.innerWidth);
+            (folder1.children[6] as Controller).enable().setValue(window.innerHeight);
         },
         fullWidth: 0,
         fullHeight: 0,
@@ -115,12 +115,12 @@ function createPanel() {
         width: 0,
         height: 0,
         clearViewOffset() {
-            folder1.children[1].setValue(0).disable();
-            folder1.children[2].setValue(0).disable();
-            folder1.children[3].setValue(0).disable();
-            folder1.children[4].setValue(0).disable();
-            folder1.children[5].setValue(0).disable();
-            folder1.children[6].setValue(0).disable();
+            (folder1.children[1] as Controller).setValue(0).disable();
+            (folder1.children[2] as Controller).setValue(0).disable();
+            (folder1.children[3] as Controller).setValue(0).disable();
+            (folder1.children[4] as Controller).setValue(0).disable();
+            (folder1.children[5] as Controller).setValue(0).disable();
+            (folder1.children[6] as Controller).setValue(0).disable();
             camera.clearViewOffset();
         },
     };
@@ -153,7 +153,21 @@ function createPanel() {
     folder1.add(settings, 'clearViewOffset');
 }
 
-function updateCameraViewOffset({ fullWidth, fullHeight, x, y, width, height }) {
+function updateCameraViewOffset({
+    fullWidth,
+    fullHeight,
+    x,
+    y,
+    width,
+    height,
+}: {
+    fullWidth?: number;
+    fullHeight?: number;
+    x?: number;
+    y?: number;
+    width?: number;
+    height?: number;
+}) {
     if (!camera.view) {
         camera.setViewOffset(
             fullWidth || window.innerWidth,
diff --git a/examples-testing/examples/css3d_sprites.ts b/examples-testing/examples/css3d_sprites.ts
index dfe24e7..93f2c07 100644
--- a/examples-testing/examples/css3d_sprites.ts
+++ b/examples-testing/examples/css3d_sprites.ts
@@ -4,12 +4,12 @@ import TWEEN from 'three/addons/libs/tween.module.js';
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import { CSS3DRenderer, CSS3DSprite } from 'three/addons/renderers/CSS3DRenderer.js';
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: CSS3DRenderer;
+let controls: TrackballControls;
 
 const particlesTotal = 512;
-const positions = [];
-const objects = [];
+const positions: number[] = [];
+const objects: CSS3DSprite[] = [];
 let current = 0;
 
 init();
@@ -25,7 +25,7 @@ function init() {
     const image = document.createElement('img');
     image.addEventListener('load', function () {
         for (let i = 0; i < particlesTotal; i++) {
-            const object = new CSS3DSprite(image.cloneNode());
+            const object = new CSS3DSprite(image.cloneNode() as typeof image);
             (object.position.x = Math.random() * 4000 - 2000),
                 (object.position.y = Math.random() * 4000 - 2000),
                 (object.position.z = Math.random() * 4000 - 2000);
@@ -93,7 +93,7 @@ function init() {
 
     renderer = new CSS3DRenderer();
     renderer.setSize(window.innerWidth, window.innerHeight);
-    document.getElementById('container').appendChild(renderer.domElement);
+    document.getElementById('container')!.appendChild(renderer.domElement);
 
     //
 
@@ -131,7 +131,7 @@ function transition() {
             .start();
     }
 
-    new TWEEN.Tween(this)
+    new TWEEN.Tween({})
         .to({}, duration * 3)
         .onComplete(transition)
         .start();
diff --git a/examples-testing/examples/css3d_youtube.ts b/examples-testing/examples/css3d_youtube.ts
index 62652f8..3dcc2f1 100644
--- a/examples-testing/examples/css3d_youtube.ts
+++ b/examples-testing/examples/css3d_youtube.ts
@@ -3,10 +3,10 @@ import * as THREE from 'three';
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: CSS3DRenderer;
+let controls: TrackballControls;
 
-function Element(id, x, y, z, ry) {
+function Element(id: string, x: number, y: number, z: number, ry: number) {
     const div = document.createElement('div');
     div.style.width = '480px';
     div.style.height = '360px';
@@ -30,7 +30,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 5000);
     camera.position.set(500, 350, 750);
@@ -42,10 +42,10 @@ function init() {
     container.appendChild(renderer.domElement);
 
     const group = new THREE.Group();
-    group.add(new Element('SJOz3qjfQXU', 0, 0, 240, 0));
-    group.add(new Element('Y2-xZ-1HE-Q', 240, 0, 0, Math.PI / 2));
-    group.add(new Element('IrydklNpcFI', 0, 0, -240, Math.PI));
-    group.add(new Element('9ubytEsCaS0', -240, 0, 0, -Math.PI / 2));
+    group.add(Element('SJOz3qjfQXU', 0, 0, 240, 0));
+    group.add(Element('Y2-xZ-1HE-Q', 240, 0, 0, Math.PI / 2));
+    group.add(Element('IrydklNpcFI', 0, 0, -240, Math.PI));
+    group.add(Element('9ubytEsCaS0', -240, 0, 0, -Math.PI / 2));
     scene.add(group);
 
     controls = new TrackballControls(camera, renderer.domElement);
@@ -55,7 +55,7 @@ function init() {
 
     // Block iframe events when dragging camera
 
-    const blocker = document.getElementById('blocker');
+    const blocker = document.getElementById('blocker')!;
     blocker.style.display = 'none';
 
     controls.addEventListener('start', function () {
diff --git a/examples-testing/examples/games_fps.ts b/examples-testing/examples/games_fps.ts
index 49d31e7..0ede5e7 100644
--- a/examples-testing/examples/games_fps.ts
+++ b/examples-testing/examples/games_fps.ts
@@ -39,7 +39,7 @@ directionalLight.shadow.radius = 4;
 directionalLight.shadow.bias = -0.00006;
 scene.add(directionalLight);
 
-const container = document.getElementById('container');
+const container = document.getElementById('container')!;
 
 const renderer = new THREE.WebGLRenderer({ antialias: true });
 renderer.setPixelRatio(window.devicePixelRatio);
@@ -50,9 +50,9 @@ renderer.toneMapping = THREE.ACESFilmicToneMapping;
 container.appendChild(renderer.domElement);
 
 const stats = new Stats();
-stats.domElement.style.position = 'absolute';
-stats.domElement.style.top = '0px';
-container.appendChild(stats.domElement);
+stats.dom.style.position = 'absolute';
+stats.dom.style.top = '0px';
+container.appendChild(stats.dom);
 
 const GRAVITY = 30;
 
@@ -64,7 +64,13 @@ const STEPS_PER_FRAME = 5;
 const sphereGeometry = new THREE.IcosahedronGeometry(SPHERE_RADIUS, 5);
 const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0xdede8d });
 
-const spheres = [];
+interface Sphere {
+    mesh: THREE.Mesh;
+    collider: THREE.Sphere;
+    velocity: THREE.Vector3;
+}
+
+const spheres: Sphere[] = [];
 let sphereIdx = 0;
 
 for (let i = 0; i < NUM_SPHERES; i++) {
@@ -91,7 +97,7 @@ const playerDirection = new THREE.Vector3();
 let playerOnFloor = false;
 let mouseTime = 0;
 
-const keyStates = {};
+const keyStates: { [eventCode: string]: boolean | undefined } = {};
 
 const vector1 = new THREE.Vector3();
 const vector2 = new THREE.Vector3();
@@ -164,7 +170,7 @@ function playerCollisions() {
     }
 }
 
-function updatePlayer(deltaTime) {
+function updatePlayer(deltaTime: number) {
     let damping = Math.exp(-4 * deltaTime) - 1;
 
     if (!playerOnFloor) {
@@ -184,7 +190,7 @@ function updatePlayer(deltaTime) {
     camera.position.copy(playerCollider.end);
 }
 
-function playerSphereCollision(sphere) {
+function playerSphereCollision(sphere: Sphere) {
     const center = vector1.addVectors(playerCollider.start, playerCollider.end).multiplyScalar(0.5);
 
     const sphere_center = sphere.collider.center;
@@ -239,7 +245,7 @@ function spheresCollisions() {
     }
 }
 
-function updateSpheres(deltaTime) {
+function updateSpheres(deltaTime: number) {
     spheres.forEach(sphere => {
         sphere.collider.center.addScaledVector(sphere.velocity, deltaTime);
 
@@ -282,7 +288,7 @@ function getSideVector() {
     return playerDirection;
 }
 
-function controls(deltaTime) {
+function controls(deltaTime: number) {
     // gives a bit of air control
     const speedDelta = deltaTime * (playerOnFloor ? 25 : 8);
 
@@ -317,12 +323,12 @@ loader.load('collision-world.glb', gltf => {
     worldOctree.fromGraphNode(gltf.scene);
 
     gltf.scene.traverse(child => {
-        if (child.isMesh) {
+        if ((child as THREE.Mesh).isMesh) {
             child.castShadow = true;
             child.receiveShadow = true;
 
-            if (child.material.map) {
-                child.material.map.anisotropy = 4;
+            if (((child as THREE.Mesh).material as THREE.MeshStandardMaterial).map) {
+                ((child as THREE.Mesh).material as THREE.MeshStandardMaterial).map!.anisotropy = 4;
             }
         }
     });
diff --git a/examples-testing/examples/misc_animation_groups.ts b/examples-testing/examples/misc_animation_groups.ts
index 19d263f..f8d0bed 100644
--- a/examples-testing/examples/misc_animation_groups.ts
+++ b/examples-testing/examples/misc_animation_groups.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let stats, clock;
-let scene, camera, renderer, mixer;
+let stats: Stats, clock: THREE.Clock;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, mixer: THREE.AnimationMixer;
 
 init();
 animate();
diff --git a/examples-testing/examples/misc_animation_keys.ts b/examples-testing/examples/misc_animation_keys.ts
index 4a80898..d2613d0 100644
--- a/examples-testing/examples/misc_animation_keys.ts
+++ b/examples-testing/examples/misc_animation_keys.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let stats, clock;
-let scene, camera, renderer, mixer;
+let stats: Stats, clock: THREE.Clock;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, mixer: THREE.AnimationMixer;
 
 init();
 animate();
@@ -25,7 +25,10 @@ function init() {
     //
 
     const geometry = new THREE.BoxGeometry(5, 5, 5);
-    const material = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true });
+    const material = new THREE.MeshBasicMaterial({
+        color: 0xffffff,
+        transparent: true,
+    });
     const mesh = new THREE.Mesh(geometry, material);
     scene.add(mesh);
 
diff --git a/examples-testing/examples/misc_boxselection.ts b/examples-testing/examples/misc_boxselection.ts
index 8766c55..f70f4fc 100644
--- a/examples-testing/examples/misc_boxselection.ts
+++ b/examples-testing/examples/misc_boxselection.ts
@@ -5,8 +5,8 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { SelectionBox } from 'three/addons/interactive/SelectionBox.js';
 import { SelectionHelper } from 'three/addons/interactive/SelectionHelper.js';
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -92,12 +92,12 @@ function render() {
     renderer.render(scene, camera);
 }
 
-const selectionBox = new SelectionBox(camera, scene);
-const helper = new SelectionHelper(renderer, 'selectBox');
+const selectionBox = new SelectionBox(camera!, scene!);
+const helper = new SelectionHelper(renderer!, 'selectBox');
 
 document.addEventListener('pointerdown', function (event) {
     for (const item of selectionBox.collection) {
-        item.material.emissive.set(0x000000);
+        (item.material as THREE.MeshLambertMaterial).emissive.set(0x000000);
     }
 
     selectionBox.startPoint.set(
@@ -110,7 +110,7 @@ document.addEventListener('pointerdown', function (event) {
 document.addEventListener('pointermove', function (event) {
     if (helper.isDown) {
         for (let i = 0; i < selectionBox.collection.length; i++) {
-            selectionBox.collection[i].material.emissive.set(0x000000);
+            (selectionBox.collection[i].material as THREE.MeshLambertMaterial).emissive.set(0x000000);
         }
 
         selectionBox.endPoint.set(
@@ -122,7 +122,7 @@ document.addEventListener('pointermove', function (event) {
         const allSelected = selectionBox.select();
 
         for (let i = 0; i < allSelected.length; i++) {
-            allSelected[i].material.emissive.set(0xffffff);
+            (allSelected[i].material as THREE.MeshLambertMaterial).emissive.set(0xffffff);
         }
     }
 });
@@ -137,6 +137,6 @@ document.addEventListener('pointerup', function (event) {
     const allSelected = selectionBox.select();
 
     for (let i = 0; i < allSelected.length; i++) {
-        allSelected[i].material.emissive.set(0xffffff);
+        (allSelected[i].material as THREE.MeshLambertMaterial).emissive.set(0xffffff);
     }
 });
diff --git a/examples-testing/examples/misc_controls_arcball.ts b/examples-testing/examples/misc_controls_arcball.ts
index fbef331..be69ca7 100644
--- a/examples-testing/examples/misc_controls_arcball.ts
+++ b/examples-testing/examples/misc_controls_arcball.ts
@@ -12,8 +12,12 @@ const cameraType = { type: 'Perspective' };
 
 const perspectiveDistance = 2.5;
 const orthographicDistance = 120;
-let camera, controls, scene, renderer, gui;
-let folderOptions, folderAnimations;
+let camera: THREE.OrthographicCamera | THREE.PerspectiveCamera,
+    controls: ArcballControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    gui: GUI;
+let folderOptions: GUI, folderAnimations: GUI;
 
 const arcballGui = {
     gizmoVisible: true,
@@ -97,8 +101,8 @@ function init() {
         material.normalMap.wrapS = THREE.RepeatWrapping;
 
         group.traverse(function (child) {
-            if (child.isMesh) {
-                child.material = material;
+            if ((child as THREE.Mesh).isMesh) {
+                (child as THREE.Mesh).material = material;
             }
         });
 
@@ -164,12 +168,12 @@ function onWindowResize() {
 
         const halfW = perspectiveDistance * Math.tan(halfFovH);
         const halfH = perspectiveDistance * Math.tan(halfFovV);
-        camera.left = -halfW;
-        camera.right = halfW;
-        camera.top = halfH;
-        camera.bottom = -halfH;
+        (camera as THREE.OrthographicCamera).left = -halfW;
+        (camera as THREE.OrthographicCamera).right = halfW;
+        (camera as THREE.OrthographicCamera).top = halfH;
+        (camera as THREE.OrthographicCamera).bottom = -halfH;
     } else if (camera.type == 'PerspectiveCamera') {
-        camera.aspect = window.innerWidth / window.innerHeight;
+        (camera as THREE.PerspectiveCamera).aspect = window.innerWidth / window.innerHeight;
     }
 
     camera.updateProjectionMatrix();
@@ -183,7 +187,7 @@ function render() {
     renderer.render(scene, camera);
 }
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     if (event.key === 'c') {
         if (event.ctrlKey || event.metaKey) {
             controls.copyState();
@@ -195,7 +199,7 @@ function onKeyDown(event) {
     }
 }
 
-function setCamera(type) {
+function setCamera(type: string) {
     if (type == 'Orthographic') {
         camera = makeOrthographicCamera();
         camera.position.set(0, 0, orthographicDistance);
diff --git a/examples-testing/examples/misc_controls_drag.ts b/examples-testing/examples/misc_controls_drag.ts
index eb7e7ca..4d327e3 100644
--- a/examples-testing/examples/misc_controls_drag.ts
+++ b/examples-testing/examples/misc_controls_drag.ts
@@ -2,12 +2,12 @@ import * as THREE from 'three';
 
 import { DragControls } from 'three/addons/controls/DragControls.js';
 
-let container;
-let camera, scene, renderer;
-let controls, group;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controls: DragControls, group: THREE.Group;
 let enableSelection = false;
 
-const objects = [];
+const objects: THREE.Object3D[] = [];
 
 const mouse = new THREE.Vector2(),
     raycaster = new THREE.Raycaster();
@@ -98,7 +98,7 @@ function onWindowResize() {
     render();
 }
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     enableSelection = event.keyCode === 16 ? true : false;
 
     if (event.keyCode === 77) {
@@ -110,7 +110,7 @@ function onKeyUp() {
     enableSelection = false;
 }
 
-function onClick(event) {
+function onClick(event: MouseEvent) {
     event.preventDefault();
 
     if (enableSelection === true) {
@@ -128,10 +128,10 @@ function onClick(event) {
             const object = intersections[0].object;
 
             if (group.children.includes(object) === true) {
-                object.material.emissive.set(0x000000);
+                ((object as THREE.Mesh).material as THREE.MeshLambertMaterial).emissive.set(0x000000);
                 scene.attach(object);
             } else {
-                object.material.emissive.set(0xaaaaaa);
+                ((object as THREE.Mesh).material as THREE.MeshLambertMaterial).emissive.set(0xaaaaaa);
                 group.attach(object);
             }
 
diff --git a/examples-testing/examples/misc_controls_fly.ts b/examples-testing/examples/misc_controls_fly.ts
index 9d6a56a..28d59fb 100644
--- a/examples-testing/examples/misc_controls_fly.ts
+++ b/examples-testing/examples/misc_controls_fly.ts
@@ -19,11 +19,15 @@ const MARGIN = 0;
 let SCREEN_HEIGHT = window.innerHeight - MARGIN * 2;
 let SCREEN_WIDTH = window.innerWidth;
 
-let camera, controls, scene, renderer, stats;
-let geometry, meshPlanet, meshClouds, meshMoon;
-let dirLight;
+let camera: THREE.PerspectiveCamera,
+    controls: FlyControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats;
+let geometry: THREE.SphereGeometry, meshPlanet: THREE.Mesh, meshClouds: THREE.Mesh, meshMoon: THREE.Mesh;
+let dirLight: THREE.DirectionalLight;
 
-let composer;
+let composer: EffectComposer;
 
 const textureLoader = new THREE.TextureLoader();
 
@@ -56,7 +60,7 @@ function init() {
         // y scale is negated to compensate for normal map handedness.
         normalScale: new THREE.Vector2(0.85, -0.85),
     });
-    materialNormalMap.map.colorSpace = THREE.SRGBColorSpace;
+    materialNormalMap.map!.colorSpace = THREE.SRGBColorSpace;
 
     // planet
 
@@ -73,7 +77,7 @@ function init() {
         map: textureLoader.load('textures/planets/earth_clouds_1024.png'),
         transparent: true,
     });
-    materialClouds.map.colorSpace = THREE.SRGBColorSpace;
+    materialClouds.map!.colorSpace = THREE.SRGBColorSpace;
 
     meshClouds = new THREE.Mesh(geometry, materialClouds);
     meshClouds.scale.set(cloudsScale, cloudsScale, cloudsScale);
@@ -85,7 +89,7 @@ function init() {
     const materialMoon = new THREE.MeshPhongMaterial({
         map: textureLoader.load('textures/planets/moon_1024.jpg'),
     });
-    materialMoon.map.colorSpace = THREE.SRGBColorSpace;
+    materialMoon.map!.colorSpace = THREE.SRGBColorSpace;
 
     meshMoon = new THREE.Mesh(geometry, materialMoon);
     meshMoon.position.set(radius * 5, 0, 0);
diff --git a/examples-testing/examples/misc_controls_map.ts b/examples-testing/examples/misc_controls_map.ts
index d0d6279..7ed0ea4 100644
--- a/examples-testing/examples/misc_controls_map.ts
+++ b/examples-testing/examples/misc_controls_map.ts
@@ -4,7 +4,7 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { MapControls } from 'three/addons/controls/MapControls.js';
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: MapControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 //render(); // remove when using next line for animation loop (requestAnimationFrame)
diff --git a/examples-testing/examples/misc_controls_orbit.ts b/examples-testing/examples/misc_controls_orbit.ts
index fc29383..9f4a806 100644
--- a/examples-testing/examples/misc_controls_orbit.ts
+++ b/examples-testing/examples/misc_controls_orbit.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 //render(); // remove when using next line for animation loop (requestAnimationFrame)
diff --git a/examples-testing/examples/misc_controls_pointerlock.ts b/examples-testing/examples/misc_controls_pointerlock.ts
index 72ea08f..cf0142d 100644
--- a/examples-testing/examples/misc_controls_pointerlock.ts
+++ b/examples-testing/examples/misc_controls_pointerlock.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: PointerLockControls;
 
-const objects = [];
+const objects: THREE.Mesh[] = [];
 
-let raycaster;
+let raycaster: THREE.Raycaster;
 
 let moveForward = false;
 let moveBackward = false;
@@ -37,8 +37,8 @@ function init() {
 
     controls = new PointerLockControls(camera, document.body);
 
-    const blocker = document.getElementById('blocker');
-    const instructions = document.getElementById('instructions');
+    const blocker = document.getElementById('blocker')!;
+    const instructions = document.getElementById('instructions')!;
 
     instructions.addEventListener('click', function () {
         controls.lock();
@@ -56,7 +56,7 @@ function init() {
 
     scene.add(controls.getObject());
 
-    const onKeyDown = function (event) {
+    const onKeyDown = function (event: KeyboardEvent) {
         switch (event.code) {
             case 'ArrowUp':
             case 'KeyW':
@@ -85,7 +85,7 @@ function init() {
         }
     };
 
-    const onKeyUp = function (event) {
+    const onKeyUp = function (event: KeyboardEvent) {
         switch (event.code) {
             case 'ArrowUp':
             case 'KeyW':
@@ -116,7 +116,7 @@ function init() {
 
     // floor
 
-    let floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
+    let floorGeometry: THREE.BufferGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
     floorGeometry.rotateX(-Math.PI / 2);
 
     // vertex displacement
@@ -165,7 +165,11 @@ function init() {
     boxGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colorsBox, 3));
 
     for (let i = 0; i < 500; i++) {
-        const boxMaterial = new THREE.MeshPhongMaterial({ specular: 0xffffff, flatShading: true, vertexColors: true });
+        const boxMaterial = new THREE.MeshPhongMaterial({
+            specular: 0xffffff,
+            flatShading: true,
+            vertexColors: true,
+        });
         boxMaterial.color.setHSL(Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75, THREE.SRGBColorSpace);
 
         const box = new THREE.Mesh(boxGeometry, boxMaterial);
diff --git a/examples-testing/examples/misc_controls_trackball.ts b/examples-testing/examples/misc_controls_trackball.ts
index 88d0541..fdd703f 100644
--- a/examples-testing/examples/misc_controls_trackball.ts
+++ b/examples-testing/examples/misc_controls_trackball.ts
@@ -5,7 +5,12 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 
-let perspectiveCamera, orthographicCamera, controls, scene, renderer, stats;
+let perspectiveCamera: THREE.PerspectiveCamera,
+    orthographicCamera: THREE.OrthographicCamera,
+    controls: TrackballControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats;
 
 const params = {
     orthographicCamera: false,
@@ -92,7 +97,7 @@ function init() {
     createControls(perspectiveCamera);
 }
 
-function createControls(camera) {
+function createControls(camera: THREE.Camera) {
     controls = new TrackballControls(camera, renderer.domElement);
 
     controls.rotateSpeed = 1.0;
diff --git a/examples-testing/examples/misc_controls_transform.ts b/examples-testing/examples/misc_controls_transform.ts
index abc4657..4254e08 100644
--- a/examples-testing/examples/misc_controls_transform.ts
+++ b/examples-testing/examples/misc_controls_transform.ts
@@ -3,8 +3,8 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { TransformControls } from 'three/addons/controls/TransformControls.js';
 
-let cameraPersp, cameraOrtho, currentCamera;
-let scene, renderer, control, orbit;
+let cameraPersp: THREE.PerspectiveCamera, cameraOrtho: THREE.OrthographicCamera, currentCamera: THREE.Camera;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer, control: TransformControls, orbit: OrbitControls;
 
 init();
 render();
@@ -86,7 +86,9 @@ function init() {
             case 67: // C
                 const position = currentCamera.position.clone();
 
-                currentCamera = currentCamera.isPerspectiveCamera ? cameraOrtho : cameraPersp;
+                currentCamera = (currentCamera as THREE.PerspectiveCamera).isPerspectiveCamera
+                    ? cameraOrtho
+                    : cameraPersp;
                 currentCamera.position.copy(position);
 
                 orbit.object = currentCamera;
diff --git a/examples-testing/examples/misc_exporter_draco.ts b/examples-testing/examples/misc_exporter_draco.ts
index d6a4535..63dab8d 100644
--- a/examples-testing/examples/misc_exporter_draco.ts
+++ b/examples-testing/examples/misc_exporter_draco.ts
@@ -4,7 +4,11 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { DRACOExporter } from 'three/addons/exporters/DRACOExporter.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, renderer, exporter, mesh;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGLRenderer,
+    exporter: DRACOExporter,
+    mesh: THREE.Mesh;
 
 const params = {
     export: exportFile,
@@ -107,12 +111,12 @@ const link = document.createElement('a');
 link.style.display = 'none';
 document.body.appendChild(link);
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: BufferSource, filename: string) {
     save(new Blob([buffer], { type: 'application/octet-stream' }), filename);
 }
diff --git a/examples-testing/examples/misc_exporter_exr.ts b/examples-testing/examples/misc_exporter_exr.ts
index fdd35d4..1b12050 100644
--- a/examples-testing/examples/misc_exporter_exr.ts
+++ b/examples-testing/examples/misc_exporter_exr.ts
@@ -5,7 +5,14 @@ import { EXRExporter, ZIP_COMPRESSION, ZIPS_COMPRESSION, NO_COMPRESSION } from '
 import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, renderer, exporter, mesh, controls, renderTarget, dataTexture;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGLRenderer,
+    exporter: EXRExporter,
+    mesh: THREE.Mesh,
+    controls: OrbitControls,
+    renderTarget: THREE.WebGLRenderTarget,
+    dataTexture: THREE.DataTexture;
 
 const params = {
     target: 'pmrem',
@@ -149,7 +156,7 @@ function exportFile() {
     saveArrayBuffer(result, params.target + '.exr');
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: Uint8Array, filename: string) {
     const blob = new Blob([buffer], { type: 'image/x-exr' });
     const link = document.createElement('a');
 
diff --git a/examples-testing/examples/misc_exporter_gltf.ts b/examples-testing/examples/misc_exporter_gltf.ts
index ceb964b..4a8e2be 100644
--- a/examples-testing/examples/misc_exporter_gltf.ts
+++ b/examples-testing/examples/misc_exporter_gltf.ts
@@ -6,7 +6,7 @@ import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
 import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-function exportGLTF(input) {
+function exportGLTF(input: THREE.Object3D | THREE.Object3D[]) {
     const gltfExporter = new GLTFExporter();
 
     const options = {
@@ -37,7 +37,7 @@ const link = document.createElement('a');
 link.style.display = 'none';
 document.body.appendChild(link); // Firefox workaround, see #6594
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
@@ -45,18 +45,25 @@ function save(blob, filename) {
     // URL.revokeObjectURL( url ); breaks Firefox...
 }
 
-function saveString(text, filename) {
+function saveString(text: string, filename: string) {
     save(new Blob([text], { type: 'text/plain' }), filename);
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: BufferSource, filename: string) {
     save(new Blob([buffer], { type: 'application/octet-stream' }), filename);
 }
 
-let container;
+let container: HTMLDivElement;
 
-let camera, object, object2, material, geometry, scene1, scene2, renderer;
-let gridHelper, sphere, model, coffeemat;
+let camera: THREE.PerspectiveCamera,
+    object: THREE.Object3D,
+    object2: THREE.Mesh,
+    material: THREE.MeshBasicMaterial | THREE.MeshLambertMaterial | THREE.MeshStandardMaterial,
+    geometry: THREE.BufferGeometry,
+    scene1: THREE.Scene,
+    scene2: THREE.Scene,
+    renderer: THREE.WebGLRenderer;
+let gridHelper: THREE.GridHelper, sphere: THREE.Mesh, model: THREE.Group, coffeemat: THREE.Group;
 
 const params = {
     trs: false,
@@ -389,8 +396,8 @@ function init() {
     const color = new THREE.Color();
     for (let i = 0; i < 50; i++) {
         matrix.setPosition(Math.random() * 100 - 50, Math.random() * 100 - 50, Math.random() * 100 - 50);
-        object.setMatrixAt(i, matrix);
-        object.setColorAt(i, color.setHSL(i / 50, 1, 0.5));
+        (object as THREE.InstancedMesh).setMatrixAt(i, matrix);
+        (object as THREE.InstancedMesh).setColorAt(i, color.setHSL(i / 50, 1, 0.5));
     }
 
     object.position.set(400, 0, 200);
diff --git a/examples-testing/examples/misc_exporter_obj.ts b/examples-testing/examples/misc_exporter_obj.ts
index c315294..384af61 100644
--- a/examples-testing/examples/misc_exporter_obj.ts
+++ b/examples-testing/examples/misc_exporter_obj.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const params = {
     addTriangle: addTriangle,
@@ -66,12 +66,12 @@ function exportToObj() {
     saveString(result, 'object.obj');
 }
 
-function addGeometry(type) {
+function addGeometry(type: number) {
     for (let i = 0; i < scene.children.length; i++) {
         const child = scene.children[i];
 
-        if (child.isMesh || child.isPoints) {
-            child.geometry.dispose();
+        if ((child as THREE.Mesh).isMesh || (child as THREE.Points).isPoints) {
+            (child as THREE.Mesh | THREE.Points).geometry.dispose();
             scene.remove(child);
             i--;
         }
@@ -156,13 +156,13 @@ const link = document.createElement('a');
 link.style.display = 'none';
 document.body.appendChild(link);
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
 }
 
-function saveString(text, filename) {
+function saveString(text: string, filename: string) {
     save(new Blob([text], { type: 'text/plain' }), filename);
 }
 
diff --git a/examples-testing/examples/misc_exporter_ply.ts b/examples-testing/examples/misc_exporter_ply.ts
index 997c4f1..b860682 100644
--- a/examples-testing/examples/misc_exporter_ply.ts
+++ b/examples-testing/examples/misc_exporter_ply.ts
@@ -4,7 +4,11 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { PLYExporter } from 'three/addons/exporters/PLYExporter.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, renderer, exporter, mesh;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGLRenderer,
+    exporter: PLYExporter,
+    mesh: THREE.Mesh;
 
 const params = {
     exportASCII: exportASCII,
@@ -142,16 +146,16 @@ const link = document.createElement('a');
 link.style.display = 'none';
 document.body.appendChild(link);
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
 }
 
-function saveString(text, filename) {
+function saveString(text: string, filename: string) {
     save(new Blob([text], { type: 'text/plain' }), filename);
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: BufferSource, filename: string) {
     save(new Blob([buffer], { type: 'application/octet-stream' }), filename);
 }
diff --git a/examples-testing/examples/misc_exporter_stl.ts b/examples-testing/examples/misc_exporter_stl.ts
index ad6e3f5..3eec71e 100644
--- a/examples-testing/examples/misc_exporter_stl.ts
+++ b/examples-testing/examples/misc_exporter_stl.ts
@@ -4,7 +4,11 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { STLExporter } from 'three/addons/exporters/STLExporter.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, renderer, exporter, mesh;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGLRenderer,
+    exporter: STLExporter,
+    mesh: THREE.Mesh;
 
 const params = {
     exportASCII: exportASCII,
@@ -115,16 +119,16 @@ const link = document.createElement('a');
 link.style.display = 'none';
 document.body.appendChild(link);
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
 }
 
-function saveString(text, filename) {
+function saveString(text: string, filename: string) {
     save(new Blob([text], { type: 'text/plain' }), filename);
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: BufferSource, filename: string) {
     save(new Blob([buffer], { type: 'application/octet-stream' }), filename);
 }
diff --git a/examples-testing/examples/misc_exporter_usdz.ts b/examples-testing/examples/misc_exporter_usdz.ts
index 7a0e782..db8aee7 100644
--- a/examples-testing/examples/misc_exporter_usdz.ts
+++ b/examples-testing/examples/misc_exporter_usdz.ts
@@ -7,7 +7,7 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { USDZExporter } from 'three/addons/exporters/USDZExporter.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const params = {
     exportUSDZ: exportUSDZ,
@@ -50,7 +50,7 @@ function init() {
         const arraybuffer = await exporter.parse(gltf.scene);
         const blob = new Blob([arraybuffer], { type: 'application/octet-stream' });
 
-        const link = document.getElementById('link');
+        const link = document.getElementById('link') as HTMLAnchorElement;
         link.href = URL.createObjectURL(blob);
     });
 
@@ -78,7 +78,7 @@ function createSpotShadowMesh() {
     canvas.width = 128;
     canvas.height = 128;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     const gradient = context.createRadialGradient(
         canvas.width / 2,
         canvas.height / 2,
@@ -118,7 +118,7 @@ function onWindowResize() {
 }
 
 function exportUSDZ() {
-    const link = document.getElementById('link');
+    const link = document.getElementById('link')!;
     link.click();
 }
 
diff --git a/examples-testing/examples/misc_lookat.ts b/examples-testing/examples/misc_lookat.ts
index f6241b9..93e8340 100644
--- a/examples-testing/examples/misc_lookat.ts
+++ b/examples-testing/examples/misc_lookat.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
-let sphere;
+let sphere: THREE.Mesh;
 
 let mouseX = 0,
     mouseY = 0;
@@ -64,7 +64,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) * 10;
     mouseY = (event.clientY - windowHalfY) * 10;
 }
diff --git a/examples-testing/examples/misc_uv_tests.ts b/examples-testing/examples/misc_uv_tests.ts
index 4f782d4..0759cfc 100644
--- a/examples-testing/examples/misc_uv_tests.ts
+++ b/examples-testing/examples/misc_uv_tests.ts
@@ -7,7 +7,7 @@ import { UVsDebug } from 'three/addons/utils/UVsDebug.js';
  * as well as allow a new user to visualize what UVs are about.
  */
 
-function test(name, geometry) {
+function test(name: string, geometry: THREE.BufferGeometry) {
     const d = document.createElement('div');
 
     d.innerHTML = '<h3>' + name + '</h3>';
diff --git a/examples-testing/examples/physics_ammo_instancing.ts b/examples-testing/examples/physics_ammo_instancing.ts
index fb0e9c4..6285a02 100644
--- a/examples-testing/examples/physics_ammo_instancing.ts
+++ b/examples-testing/examples/physics_ammo_instancing.ts
@@ -1,12 +1,12 @@
 import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { AmmoPhysics } from 'three/addons/physics/AmmoPhysics.js';
+import { AmmoPhysics, AmmoPhysicsObject } from 'three/addons/physics/AmmoPhysics.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
-let physics, position;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let physics: AmmoPhysicsObject, position: THREE.Vector3;
 
-let boxes, spheres;
+let boxes: THREE.InstancedMesh, spheres: THREE.InstancedMesh;
 
 init();
 
diff --git a/examples-testing/examples/physics_rapier_instancing.ts b/examples-testing/examples/physics_rapier_instancing.ts
index 169130b..7b2e6da 100644
--- a/examples-testing/examples/physics_rapier_instancing.ts
+++ b/examples-testing/examples/physics_rapier_instancing.ts
@@ -1,12 +1,12 @@
 import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { RapierPhysics } from 'three/addons/physics/RapierPhysics.js';
+import { RapierPhysics, RapierPhysicsObject } from 'three/addons/physics/RapierPhysics.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
-let physics, position;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let physics: RapierPhysicsObject, position: THREE.Vector3;
 
-let boxes, spheres;
+let boxes: THREE.InstancedMesh, spheres: THREE.InstancedMesh;
 
 init();
 
diff --git a/examples-testing/examples/svg_lines.ts b/examples-testing/examples/svg_lines.ts
index 99b74c4..65aaf28 100644
--- a/examples-testing/examples/svg_lines.ts
+++ b/examples-testing/examples/svg_lines.ts
@@ -4,7 +4,7 @@ import { SVGRenderer } from 'three/addons/renderers/SVGRenderer.js';
 
 THREE.ColorManagement.enabled = false;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: SVGRenderer;
 
 init();
 animate();
diff --git a/examples-testing/examples/svg_sandbox.ts b/examples-testing/examples/svg_sandbox.ts
index e6be838..faea9a7 100644
--- a/examples-testing/examples/svg_sandbox.ts
+++ b/examples-testing/examples/svg_sandbox.ts
@@ -6,9 +6,9 @@ import { SVGRenderer, SVGObject } from 'three/addons/renderers/SVGRenderer.js';
 
 THREE.ColorManagement.enabled = false;
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: SVGRenderer, stats: Stats;
 
-let group;
+let group: THREE.Mesh;
 
 init();
 animate();
@@ -33,9 +33,13 @@ function init() {
 
     const boxGeometry = new THREE.BoxGeometry(100, 100, 100);
 
-    let mesh = new THREE.Mesh(
+    let mesh: THREE.Mesh = new THREE.Mesh(
         boxGeometry,
-        new THREE.MeshBasicMaterial({ color: 0x0000ff, opacity: 0.5, transparent: true }),
+        new THREE.MeshBasicMaterial({
+            color: 0x0000ff,
+            opacity: 0.5,
+            transparent: true,
+        }),
     );
     mesh.position.x = 500;
     mesh.rotation.x = Math.random();
@@ -55,7 +59,10 @@ function init() {
 
     mesh = new THREE.Mesh(
         new THREE.PlaneGeometry(100, 100),
-        new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff, side: THREE.DoubleSide }),
+        new THREE.MeshBasicMaterial({
+            color: Math.random() * 0xffffff,
+            side: THREE.DoubleSide,
+        }),
     );
     mesh.position.y = -500;
     mesh.scale.x = mesh.scale.y = mesh.scale.z = 2;
@@ -75,7 +82,10 @@ function init() {
     // POLYFIELD
 
     const geometry = new THREE.BufferGeometry();
-    const material = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide });
+    const material = new THREE.MeshBasicMaterial({
+        vertexColors: true,
+        side: THREE.DoubleSide,
+    });
 
     const v = new THREE.Vector3();
     const v0 = new THREE.Vector3();
@@ -122,7 +132,9 @@ function init() {
     // SPRITES
 
     for (let i = 0; i < 50; i++) {
-        const material = new THREE.SpriteMaterial({ color: Math.random() * 0xffffff });
+        const material = new THREE.SpriteMaterial({
+            color: Math.random() * 0xffffff,
+        });
         const sprite = new THREE.Sprite(material);
         sprite.position.x = Math.random() * 1000 - 500;
         sprite.position.y = Math.random() * 1000 - 500;
@@ -139,7 +151,7 @@ function init() {
     node.setAttribute('r', '40');
 
     for (let i = 0; i < 50; i++) {
-        const object = new SVGObject(node.cloneNode());
+        const object = new SVGObject(node.cloneNode() as SVGCircleElement);
         object.position.x = Math.random() * 1000 - 500;
         object.position.y = Math.random() * 1000 - 500;
         object.position.z = Math.random() * 1000 - 500;
@@ -152,7 +164,7 @@ function init() {
     fileLoader.load('models/svg/hexagon.svg', function (svg) {
         const node = document.createElementNS('http://www.w3.org/2000/svg', 'g');
         const parser = new DOMParser();
-        const doc = parser.parseFromString(svg, 'image/svg+xml');
+        const doc = parser.parseFromString(svg as string, 'image/svg+xml');
 
         node.appendChild(doc.documentElement);
 
diff --git a/examples-testing/examples/webaudio_orientation.ts b/examples-testing/examples/webaudio_orientation.ts
index d5cff39..06315a2 100644
--- a/examples-testing/examples/webaudio_orientation.ts
+++ b/examples-testing/examples/webaudio_orientation.ts
@@ -4,16 +4,16 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { PositionalAudioHelper } from 'three/addons/helpers/PositionalAudioHelper.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let scene, camera, renderer;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer;
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', init);
 
 function init() {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     //
 
@@ -65,7 +65,7 @@ function init() {
     const listener = new THREE.AudioListener();
     camera.add(listener);
 
-    const audioElement = document.getElementById('music');
+    const audioElement = document.getElementById('music') as HTMLAudioElement;
     audioElement.play();
 
     const positionalAudio = new THREE.PositionalAudio(listener);
@@ -85,10 +85,10 @@ function init() {
         boomBox.scale.set(20, 20, 20);
 
         boomBox.traverse(function (object) {
-            if (object.isMesh) {
-                object.material.envMap = reflectionCube;
-                object.geometry.rotateY(-Math.PI);
-                object.castShadow = true;
+            if ((object as THREE.Mesh).isMesh) {
+                ((object as THREE.Mesh).material as THREE.MeshStandardMaterial).envMap = reflectionCube;
+                (object as THREE.Mesh).geometry.rotateY(-Math.PI);
+                (object as THREE.Mesh).castShadow = true;
             }
         });
 
@@ -100,7 +100,11 @@ function init() {
     // sound is damped behind this wall
 
     const wallGeometry = new THREE.BoxGeometry(2, 1, 0.1);
-    const wallMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
+    const wallMaterial = new THREE.MeshBasicMaterial({
+        color: 0xff0000,
+        transparent: true,
+        opacity: 0.5,
+    });
 
     const wall = new THREE.Mesh(wallGeometry, wallMaterial);
     wall.position.set(0, 0.5, -0.5);
diff --git a/examples-testing/examples/webaudio_sandbox.ts b/examples-testing/examples/webaudio_sandbox.ts
index 56bd042..b200423 100644
--- a/examples-testing/examples/webaudio_sandbox.ts
+++ b/examples-testing/examples/webaudio_sandbox.ts
@@ -4,19 +4,23 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
 
-let camera, controls, scene, renderer, light;
+let camera: THREE.PerspectiveCamera,
+    controls: FirstPersonControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    light: THREE.DirectionalLight;
 
-let material1, material2, material3;
+let material1: THREE.MeshPhongMaterial, material2: THREE.MeshPhongMaterial, material3: THREE.MeshPhongMaterial;
 
-let analyser1, analyser2, analyser3;
+let analyser1: THREE.AudioAnalyser, analyser2: THREE.AudioAnalyser, analyser3: THREE.AudioAnalyser;
 
 const clock = new THREE.Clock();
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', init);
 
 function init() {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
@@ -45,7 +49,7 @@ function init() {
     scene.add(mesh1);
 
     const sound1 = new THREE.PositionalAudio(listener);
-    const songElement = document.getElementById('song');
+    const songElement = document.getElementById('song') as HTMLAudioElement;
     sound1.setMediaElementSource(songElement);
     sound1.setRefDistance(20);
     songElement.play();
@@ -58,7 +62,7 @@ function init() {
     scene.add(mesh2);
 
     const sound2 = new THREE.PositionalAudio(listener);
-    const skullbeatzElement = document.getElementById('skullbeatz');
+    const skullbeatzElement = document.getElementById('skullbeatz') as HTMLAudioElement;
     sound2.setMediaElementSource(skullbeatzElement);
     sound2.setRefDistance(20);
     skullbeatzElement.play();
@@ -89,7 +93,7 @@ function init() {
     // global ambient audio
 
     const sound4 = new THREE.Audio(listener);
-    const utopiaElement = document.getElementById('utopia');
+    const utopiaElement = document.getElementById('utopia') as HTMLAudioElement;
     sound4.setMediaElementSource(utopiaElement);
     sound4.setVolume(0.5);
     utopiaElement.play();
@@ -102,18 +106,31 @@ function init() {
 
     //
 
-    const SoundControls = function () {
-        this.master = listener.getMasterVolume();
-        this.firstSphere = sound1.getVolume();
-        this.secondSphere = sound2.getVolume();
-        this.thirdSphere = sound3.getVolume();
-        this.Ambient = sound4.getVolume();
-    };
-
-    const GeneratorControls = function () {
-        this.frequency = oscillator.frequency.value;
-        this.wavetype = oscillator.type;
-    };
+    class SoundControls {
+        master: number;
+        firstSphere: number;
+        secondSphere: number;
+        thirdSphere: number;
+        Ambient: number;
+
+        constructor() {
+            this.master = listener.getMasterVolume();
+            this.firstSphere = sound1.getVolume();
+            this.secondSphere = sound2.getVolume();
+            this.thirdSphere = sound3.getVolume();
+            this.Ambient = sound4.getVolume();
+        }
+    }
+
+    class GeneratorControls {
+        frequency: number;
+        wavetype: OscillatorType;
+
+        constructor() {
+            this.frequency = oscillator.frequency.value;
+            this.wavetype = oscillator.type;
+        }
+    }
 
     const gui = new GUI();
     const soundControls = new SoundControls();
diff --git a/examples-testing/examples/webaudio_timing.ts b/examples-testing/examples/webaudio_timing.ts
index bab79dd..2d6c621 100644
--- a/examples-testing/examples/webaudio_timing.ts
+++ b/examples-testing/examples/webaudio_timing.ts
@@ -2,22 +2,22 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let scene, camera, renderer, clock;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
 
-const objects = [];
+const objects: THREE.Mesh[] = [];
 
 const speed = 2.5;
 const height = 3;
 const offset = 0.5;
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', init);
 
 function init() {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
 
@@ -147,7 +147,7 @@ function render() {
             if (ball.userData.down === true) {
                 // ball changed direction from down to up
 
-                const audio = ball.children[0];
+                const audio = ball.children[0] as THREE.Audio;
                 audio.play(); // play audio with perfect timing when ball hits the surface
                 ball.userData.down = false;
             }
diff --git a/examples-testing/examples/webaudio_visualizer.ts b/examples-testing/examples/webaudio_visualizer.ts
index 6c4244f..857d8f1 100644
--- a/examples-testing/examples/webaudio_visualizer.ts
+++ b/examples-testing/examples/webaudio_visualizer.ts
@@ -1,8 +1,13 @@
 import * as THREE from 'three';
+import { IUniform } from 'three';
 
-let scene, camera, renderer, analyser, uniforms;
+let scene: THREE.Scene,
+    camera: THREE.Camera,
+    renderer: THREE.WebGLRenderer,
+    analyser: THREE.AudioAnalyser,
+    uniforms: { [uniform: string]: IUniform };
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', init);
 
 function init() {
@@ -10,12 +15,12 @@ function init() {
 
     //
 
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
     //
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -58,8 +63,8 @@ function init() {
 
     const material = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
     });
 
     const geometry = new THREE.PlaneGeometry(1, 1);
@@ -87,7 +92,7 @@ function animate() {
 function render() {
     analyser.getFrequencyData();
 
-    uniforms.tAudioData.value.needsUpdate = true;
+    (uniforms.tAudioData.value as THREE.DataTexture).needsUpdate = true;
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl2_buffergeometry_attributes_integer.ts b/examples-testing/examples/webgl2_buffergeometry_attributes_integer.ts
index 848814c..ca05c89 100644
--- a/examples-testing/examples/webgl2_buffergeometry_attributes_integer.ts
+++ b/examples-testing/examples/webgl2_buffergeometry_attributes_integer.ts
@@ -6,7 +6,7 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let camera, scene, renderer, mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mesh: THREE.Mesh;
 
 init();
 animate();
@@ -72,7 +72,7 @@ function init() {
     geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
     geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
     geometry.setAttribute('textureIndex', new THREE.Int16BufferAttribute(textureIndices, 1));
-    geometry.attributes.textureIndex.gpuType = THREE.IntType;
+    (geometry.attributes.textureIndex as THREE.BufferAttribute).gpuType = THREE.IntType;
 
     geometry.computeBoundingSphere();
 
@@ -90,8 +90,8 @@ function init() {
                 value: [map1, map2, map3],
             },
         },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
         side: THREE.DoubleSide,
         glslVersion: THREE.GLSL3,
     });
diff --git a/examples-testing/examples/webgl2_buffergeometry_attributes_none.ts b/examples-testing/examples/webgl2_buffergeometry_attributes_none.ts
index a77b973..d24a458 100644
--- a/examples-testing/examples/webgl2_buffergeometry_attributes_none.ts
+++ b/examples-testing/examples/webgl2_buffergeometry_attributes_none.ts
@@ -6,7 +6,7 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let camera, scene, renderer, mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mesh: THREE.Mesh;
 
 init();
 animate();
@@ -34,8 +34,8 @@ function init() {
         uniforms: {
             seed: { value: 42 },
         },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
         side: THREE.DoubleSide,
         glslVersion: THREE.GLSL3,
     });
@@ -54,11 +54,11 @@ function init() {
     document.body.appendChild(renderer.domElement);
 }
 
-function animate(time) {
+function animate(time?: number) {
     requestAnimationFrame(animate);
 
-    mesh.rotation.x = (time / 1000.0) * 0.25;
-    mesh.rotation.y = (time / 1000.0) * 0.5;
+    mesh.rotation.x = time != null ? (time / 1000.0) * 0.25 : NaN;
+    mesh.rotation.y = time != null ? (time / 1000.0) * 0.5 : NaN;
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl2_clipculldistance.ts b/examples-testing/examples/webgl2_clipculldistance.ts
index bfa572c..fa75879 100644
--- a/examples-testing/examples/webgl2_clipculldistance.ts
+++ b/examples-testing/examples/webgl2_clipculldistance.ts
@@ -2,9 +2,14 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, controls, clock, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera,
+    controls: OrbitControls,
+    clock: THREE.Clock,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats;
 
-let material;
+let material: THREE.ShaderMaterial;
 
 init();
 animate();
@@ -25,7 +30,7 @@ function init() {
     document.body.appendChild(renderer.domElement);
 
     if (renderer.extensions.has('WEBGL_clip_cull_distance') === false) {
-        document.getElementById('notSupported').style.display = '';
+        document.getElementById('notSupported')!.style.display = '';
         return;
     }
 
@@ -69,8 +74,8 @@ function init() {
         uniforms: {
             time: { value: 1.0 },
         },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
         side: THREE.DoubleSide,
         transparent: true,
         vertexColors: true,
diff --git a/examples-testing/examples/webgl2_materials_texture3d.ts b/examples-testing/examples/webgl2_materials_texture3d.ts
index b746daf..581c97a 100644
--- a/examples-testing/examples/webgl2_materials_texture3d.ts
+++ b/examples-testing/examples/webgl2_materials_texture3d.ts
@@ -10,7 +10,15 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let renderer, scene, camera, controls, material, volconfig, cmtextures;
+type ColorMap = 'gray' | 'viridis';
+
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.OrthographicCamera,
+    controls: OrbitControls,
+    material: THREE.ShaderMaterial,
+    volconfig: { clim1: number; clim2: number; renderstyle: string; isothreshold: number; colormap: ColorMap },
+    cmtextures: { [K in ColorMap]: THREE.Texture };
 
 init();
 
@@ -105,7 +113,7 @@ function init() {
 }
 
 function updateUniforms() {
-    material.uniforms['u_clim'].value.set(volconfig.clim1, volconfig.clim2);
+    (material.uniforms['u_clim'].value as THREE.Vector2).set(volconfig.clim1, volconfig.clim2);
     material.uniforms['u_renderstyle'].value = volconfig.renderstyle == 'mip' ? 0 : 1; // 0: MIP, 1: ISO
     material.uniforms['u_renderthreshold'].value = volconfig.isothreshold; // For ISO renderstyle
     material.uniforms['u_cmdata'].value = cmtextures[volconfig.colormap];
diff --git a/examples-testing/examples/webgl2_materials_texture3d_partialupdate.ts b/examples-testing/examples/webgl2_materials_texture3d_partialupdate.ts
index 0268130..0e78ed5 100644
--- a/examples-testing/examples/webgl2_materials_texture3d_partialupdate.ts
+++ b/examples-testing/examples/webgl2_materials_texture3d_partialupdate.ts
@@ -11,15 +11,15 @@ if (WebGL.isWebGL2Available() === false) {
 
 const INITIAL_CLOUD_SIZE = 128;
 
-let renderer, scene, camera;
-let mesh;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let mesh: THREE.Mesh<THREE.BoxGeometry, THREE.RawShaderMaterial>;
 let prevTime = performance.now();
-let cloudTexture = null;
+let cloudTexture: THREE.Data3DTexture | null = null;
 
 init();
 animate();
 
-function generateCloudTexture(size, scaleFactor = 1.0) {
+function generateCloudTexture(size: number, scaleFactor = 1.0) {
     const data = new Uint8Array(size * size * size);
     const scale = (scaleFactor * 10.0) / size;
 
@@ -65,7 +65,7 @@ function init() {
     canvas.width = 1;
     canvas.height = 32;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     const gradient = context.createLinearGradient(0, 0, 0, 32);
     gradient.addColorStop(0.0, '#014a84');
     gradient.addColorStop(0.5, '#0561a0');
@@ -317,17 +317,17 @@ function animate() {
         const scaleFactor = (Math.random() + 0.5) * 0.5;
         const source = generateCloudTexture(perElementPaddedSize, scaleFactor);
 
-        renderer.copyTextureToTexture3D(box, position, source, cloudTexture);
+        renderer.copyTextureToTexture3D(box, position, source, cloudTexture!);
 
         prevTime = time;
 
         curr++;
     }
 
-    mesh.material.uniforms.cameraPos.value.copy(camera.position);
+    (mesh.material.uniforms.cameraPos.value as THREE.Vector3).copy(camera.position);
     // mesh.rotation.y = - performance.now() / 7500;
 
-    mesh.material.uniforms.frame.value++;
+    (mesh.material.uniforms.frame.value as number)++;
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl2_multiple_rendertargets.ts b/examples-testing/examples/webgl2_multiple_rendertargets.ts
index 59f70c9..9b622a5 100644
--- a/examples-testing/examples/webgl2_multiple_rendertargets.ts
+++ b/examples-testing/examples/webgl2_multiple_rendertargets.ts
@@ -4,9 +4,9 @@ import WebGL from 'three/addons/capabilities/WebGL.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, controls;
-let renderTarget;
-let postScene, postCamera;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
+let renderTarget: THREE.WebGLRenderTarget;
+let postScene: THREE.Scene, postCamera: THREE.OrthographicCamera;
 
 const parameters = {
     samples: 4,
@@ -68,8 +68,8 @@ function init() {
             new THREE.TorusKnotGeometry(1, 0.3, 128, 32),
             new THREE.RawShaderMaterial({
                 name: 'G-Buffer Shader',
-                vertexShader: document.querySelector('#gbuffer-vert').textContent.trim(),
-                fragmentShader: document.querySelector('#gbuffer-frag').textContent.trim(),
+                vertexShader: document.querySelector('#gbuffer-vert')!.textContent!.trim(),
+                fragmentShader: document.querySelector('#gbuffer-frag')!.textContent!.trim(),
                 uniforms: {
                     tDiffuse: { value: diffuse },
                     repeat: { value: new THREE.Vector2(5, 0.5) },
@@ -89,8 +89,8 @@ function init() {
             new THREE.PlaneGeometry(2, 2),
             new THREE.RawShaderMaterial({
                 name: 'Post-FX Shader',
-                vertexShader: document.querySelector('#render-vert').textContent.trim(),
-                fragmentShader: document.querySelector('#render-frag').textContent.trim(),
+                vertexShader: document.querySelector('#render-vert')!.textContent!.trim(),
+                fragmentShader: document.querySelector('#render-frag')!.textContent!.trim(),
                 uniforms: {
                     tDiffuse: { value: renderTarget.textures[0] },
                     tNormal: { value: renderTarget.textures[1] },
@@ -125,8 +125,8 @@ function render() {
     renderTarget.samples = parameters.samples;
 
     scene.traverse(function (child) {
-        if (child.material !== undefined) {
-            child.material.wireframe = parameters.wireframe;
+        if ((child as THREE.Mesh).material !== undefined) {
+            ((child as THREE.Mesh).material as THREE.RawShaderMaterial).wireframe = parameters.wireframe;
         }
     });
 
diff --git a/examples-testing/examples/webgl2_multisampled_renderbuffers.ts b/examples-testing/examples/webgl2_multisampled_renderbuffers.ts
index 30ae67e..695805b 100644
--- a/examples-testing/examples/webgl2_multisampled_renderbuffers.ts
+++ b/examples-testing/examples/webgl2_multisampled_renderbuffers.ts
@@ -6,9 +6,9 @@ import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import WebGL from 'three/addons/capabilities/WebGL.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, renderer, group, container;
+let camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, group: THREE.Group, container: HTMLElement;
 
-let composer1, composer2;
+let composer1: EffectComposer, composer2: EffectComposer;
 
 const params = {
     animate: true,
@@ -22,7 +22,7 @@ function init() {
         return;
     }
 
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 10, 2000);
     camera.position.z = 500;
diff --git a/examples-testing/examples/webgl2_texture2darray_compressed.ts b/examples-testing/examples/webgl2_texture2darray_compressed.ts
index bf86320..5294a1f 100644
--- a/examples-testing/examples/webgl2_texture2darray_compressed.ts
+++ b/examples-testing/examples/webgl2_texture2darray_compressed.ts
@@ -9,7 +9,12 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let camera, scene, mesh, renderer, stats, clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    mesh: THREE.Mesh<THREE.PlaneGeometry, THREE.ShaderMaterial>,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    clock: THREE.Clock;
 
 const planeWidth = 50;
 const planeHeight = 25;
@@ -49,8 +54,8 @@ function init() {
                 depth: { value: 55 },
                 size: { value: new THREE.Vector2(planeWidth, planeHeight) },
             },
-            vertexShader: document.getElementById('vs').textContent.trim(),
-            fragmentShader: document.getElementById('fs').textContent.trim(),
+            vertexShader: document.getElementById('vs')!.textContent!.trim(),
+            fragmentShader: document.getElementById('fs')!.textContent!.trim(),
             glslVersion: THREE.GLSL3,
         });
 
diff --git a/examples-testing/examples/webgl2_ubo.ts b/examples-testing/examples/webgl2_ubo.ts
index e296fdc..527b9a7 100644
--- a/examples-testing/examples/webgl2_ubo.ts
+++ b/examples-testing/examples/webgl2_ubo.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 
 import WebGL from 'three/addons/capabilities/WebGL.js';
 
-let camera, scene, renderer, clock;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
 
 init();
 animate();
@@ -13,7 +13,7 @@ function init() {
         return;
     }
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
     camera.position.set(0, 0, 25);
@@ -59,8 +59,8 @@ function init() {
             normalMatrix: { value: null },
             color: { value: null },
         },
-        vertexShader: document.getElementById('vertexShader1').textContent,
-        fragmentShader: document.getElementById('fragmentShader1').textContent,
+        vertexShader: document.getElementById('vertexShader1')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader1')!.textContent!,
         glslVersion: THREE.GLSL3,
     });
 
@@ -69,8 +69,8 @@ function init() {
             modelMatrix: { value: null },
             diffuseMap: { value: null },
         },
-        vertexShader: document.getElementById('vertexShader2').textContent,
-        fragmentShader: document.getElementById('fragmentShader2').textContent,
+        vertexShader: document.getElementById('vertexShader2')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader2')!.textContent!,
         glslVersion: THREE.GLSL3,
     });
 
@@ -136,7 +136,7 @@ function animate() {
     const delta = clock.getDelta();
 
     scene.traverse(function (child) {
-        if (child.isMesh) {
+        if ((child as THREE.Mesh).isMesh) {
             child.rotation.x += delta * 0.5;
             child.rotation.y += delta * 0.3;
         }
diff --git a/examples-testing/examples/webgl2_ubo_arrays.ts b/examples-testing/examples/webgl2_ubo_arrays.ts
index 7f1b3c8..ca43ef5 100644
--- a/examples-testing/examples/webgl2_ubo_arrays.ts
+++ b/examples-testing/examples/webgl2_ubo_arrays.ts
@@ -5,11 +5,15 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, clock, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    stats: Stats;
 
-let lightingUniformsGroup, lightCenters;
+let lightingUniformsGroup: THREE.UniformsGroup, lightCenters: { x: number; z: number }[];
 
-const container = document.getElementById('container');
+const container = document.getElementById('container')!;
 
 const pointLightsMax = 300;
 
@@ -78,8 +82,8 @@ function init() {
         defines: {
             POINTLIGHTS_MAX: pointLightsMax,
         },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
         glslVersion: THREE.GLSL3,
     });
 
@@ -135,7 +139,7 @@ function init() {
     gui.add(api, 'count', 1, pointLightsMax)
         .step(1)
         .onChange(function () {
-            lightingUniformsGroup.uniforms[2].value = api.count;
+            (lightingUniformsGroup.uniforms[2] as THREE.Uniform).value = api.count;
         });
 }
 
@@ -155,7 +159,7 @@ function animate() {
 
     const elapsedTime = clock.getElapsedTime();
 
-    const lights = lightingUniformsGroup.uniforms[0];
+    const lights = lightingUniformsGroup.uniforms[0] as THREE.Uniform[];
 
     // Parameters for circular movement
     const radius = 5; // Smaller radius for individual circular movements
diff --git a/examples-testing/examples/webgl2_volume_cloud.ts b/examples-testing/examples/webgl2_volume_cloud.ts
index bc54732..7fe4043 100644
--- a/examples-testing/examples/webgl2_volume_cloud.ts
+++ b/examples-testing/examples/webgl2_volume_cloud.ts
@@ -9,8 +9,8 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let renderer, scene, camera;
-let mesh;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let mesh: THREE.Mesh<THREE.BoxGeometry, THREE.RawShaderMaterial>;
 
 init();
 animate();
@@ -34,7 +34,7 @@ function init() {
     canvas.width = 1;
     canvas.height = 32;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     const gradient = context.createLinearGradient(0, 0, 0, 32);
     gradient.addColorStop(0.0, '#014a84');
     gradient.addColorStop(0.5, '#0561a0');
@@ -277,10 +277,10 @@ function onWindowResize() {
 function animate() {
     requestAnimationFrame(animate);
 
-    mesh.material.uniforms.cameraPos.value.copy(camera.position);
+    (mesh.material.uniforms.cameraPos.value as THREE.Vector3).copy(camera.position);
     mesh.rotation.y = -performance.now() / 7500;
 
-    mesh.material.uniforms.frame.value++;
+    (mesh.material.uniforms.frame.value as number)++;
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl2_volume_instancing.ts b/examples-testing/examples/webgl2_volume_instancing.ts
index 09e1e58..3afdda9 100644
--- a/examples-testing/examples/webgl2_volume_instancing.ts
+++ b/examples-testing/examples/webgl2_volume_instancing.ts
@@ -8,7 +8,11 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let renderer, scene, camera, controls, clock;
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    controls: OrbitControls,
+    clock: THREE.Clock;
 
 init();
 animate();
@@ -161,7 +165,7 @@ function init() {
 
             const mesh = new THREE.InstancedMesh(geometry, material, 50000);
             mesh.onBeforeRender = function () {
-                this.material.uniforms.cameraPos.value.copy(camera.position);
+                (this.material.uniforms.cameraPos.value as THREE.Vector3).copy(camera.position);
             };
 
             const transform = new THREE.Object3D();
diff --git a/examples-testing/examples/webgl2_volume_perlin.ts b/examples-testing/examples/webgl2_volume_perlin.ts
index a75328f..35a0321 100644
--- a/examples-testing/examples/webgl2_volume_perlin.ts
+++ b/examples-testing/examples/webgl2_volume_perlin.ts
@@ -9,8 +9,8 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let renderer, scene, camera;
-let mesh;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let mesh: THREE.Mesh<THREE.BoxGeometry, THREE.RawShaderMaterial>;
 
 init();
 animate();
@@ -209,7 +209,7 @@ function onWindowResize() {
 function animate() {
     requestAnimationFrame(animate);
 
-    mesh.material.uniforms.cameraPos.value.copy(camera.position);
+    (mesh.material.uniforms.cameraPos.value as THREE.Vector3).copy(camera.position);
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl_animation_keyframes.ts b/examples-testing/examples/webgl_animation_keyframes.ts
index 22dd961..fbe392b 100644
--- a/examples-testing/examples/webgl_animation_keyframes.ts
+++ b/examples-testing/examples/webgl_animation_keyframes.ts
@@ -8,10 +8,10 @@ import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 
-let mixer;
+let mixer: THREE.AnimationMixer;
 
 const clock = new THREE.Clock();
-const container = document.getElementById('container');
+const container = document.getElementById('container')!;
 
 const stats = new Stats();
 container.appendChild(stats.dom);
diff --git a/examples-testing/examples/webgl_animation_multiple.ts b/examples-testing/examples/webgl_animation_multiple.ts
index 62e9682..e260deb 100644
--- a/examples-testing/examples/webgl_animation_multiple.ts
+++ b/examples-testing/examples/webgl_animation_multiple.ts
@@ -4,11 +4,11 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, clock;
-let model, animations;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
+let model: THREE.Group, animations: THREE.AnimationClip[];
 
-const mixers = [],
-    objects = [];
+const mixers: THREE.AnimationMixer[] = [],
+    objects: THREE.Object3D[] = [];
 
 const params = {
     sharedSkeleton: false,
@@ -61,7 +61,7 @@ function init() {
         animations = gltf.animations;
 
         model.traverse(function (object) {
-            if (object.isMesh) object.castShadow = true;
+            if ((object as THREE.Mesh).isMesh) object.castShadow = true;
         });
 
         setupDefaultScene();
@@ -102,7 +102,7 @@ function clearScene() {
         scene.remove(object);
 
         scene.traverse(function (child) {
-            if (child.isSkinnedMesh) child.skeleton.dispose();
+            if ((child as THREE.SkinnedMesh).isSkinnedMesh) (child as THREE.SkinnedMesh).skeleton.dispose();
         });
     }
 }
@@ -138,9 +138,9 @@ function setupSharedSkeletonScene() {
     // all models share the same animation state
 
     const sharedModel = SkeletonUtils.clone(model);
-    const shareSkinnedMesh = sharedModel.getObjectByName('vanguard_Mesh');
+    const shareSkinnedMesh = sharedModel.getObjectByName('vanguard_Mesh') as THREE.SkinnedMesh;
     const sharedSkeleton = shareSkinnedMesh.skeleton;
-    const sharedParentBone = sharedModel.getObjectByName('mixamorigHips');
+    const sharedParentBone = sharedModel.getObjectByName('mixamorigHips')!;
     scene.add(sharedParentBone); // the bones need to be in the scene for the animation to work
 
     const model1 = shareSkinnedMesh.clone();
diff --git a/examples-testing/examples/webgl_animation_skinning_morph.ts b/examples-testing/examples/webgl_animation_skinning_morph.ts
index 6aa1368..4eaea5d 100644
--- a/examples-testing/examples/webgl_animation_skinning_morph.ts
+++ b/examples-testing/examples/webgl_animation_skinning_morph.ts
@@ -5,10 +5,29 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let container, stats, clock, gui, mixer, actions, activeAction, previousAction;
-let camera, scene, renderer, model, face;
-
-const api = { state: 'Walking' };
+let container: HTMLDivElement,
+    stats: Stats,
+    clock: THREE.Clock,
+    gui: GUI,
+    mixer: THREE.AnimationMixer,
+    actions: Record<string, THREE.AnimationAction>,
+    activeAction: THREE.AnimationAction,
+    previousAction: THREE.AnimationAction;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    model: THREE.Group,
+    face: THREE.Mesh;
+
+const api: {
+    state: string;
+    Jump?: () => void;
+    Yes?: () => void;
+    No?: () => void;
+    Wave?: () => void;
+    Punch?: () => void;
+    ThumbsUp?: () => void;
+} = { state: 'Walking' };
 
 init();
 animate();
@@ -80,9 +99,9 @@ function init() {
     container.appendChild(stats.dom);
 }
 
-function createGUI(model, animations) {
+function createGUI(model: THREE.Group, animations: THREE.AnimationClip[]) {
     const states = ['Idle', 'Walking', 'Running', 'Dance', 'Death', 'Sitting', 'Standing'];
-    const emotes = ['Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp'];
+    const emotes = ['Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp'] as const;
 
     gui = new GUI();
 
@@ -95,7 +114,7 @@ function createGUI(model, animations) {
         const action = mixer.clipAction(clip);
         actions[clip.name] = action;
 
-        if (emotes.indexOf(clip.name) >= 0 || states.indexOf(clip.name) >= 4) {
+        if (emotes.indexOf(clip.name as (typeof emotes)[number]) >= 0 || states.indexOf(clip.name) >= 4) {
             action.clampWhenFinished = true;
             action.loop = THREE.LoopOnce;
         }
@@ -117,14 +136,14 @@ function createGUI(model, animations) {
 
     const emoteFolder = gui.addFolder('Emotes');
 
-    function createEmoteCallback(name) {
+    function createEmoteCallback(name: (typeof emotes)[number]) {
         api[name] = function () {
             fadeToAction(name, 0.2);
 
             mixer.addEventListener('finished', restoreState);
         };
 
-        emoteFolder.add(api, name);
+        emoteFolder.add(api as Required<typeof api>, name);
     }
 
     function restoreState() {
@@ -141,13 +160,13 @@ function createGUI(model, animations) {
 
     // expressions
 
-    face = model.getObjectByName('Head_4');
+    face = model.getObjectByName('Head_4') as THREE.Mesh;
 
-    const expressions = Object.keys(face.morphTargetDictionary);
+    const expressions = Object.keys(face.morphTargetDictionary!);
     const expressionFolder = gui.addFolder('Expressions');
 
     for (let i = 0; i < expressions.length; i++) {
-        expressionFolder.add(face.morphTargetInfluences, i, 0, 1, 0.01).name(expressions[i]);
+        expressionFolder.add(face.morphTargetInfluences!, i, 0, 1, 0.01).name(expressions[i]);
     }
 
     activeAction = actions['Walking'];
@@ -156,7 +175,7 @@ function createGUI(model, animations) {
     expressionFolder.open();
 }
 
-function fadeToAction(name, duration) {
+function fadeToAction(name: string, duration: number) {
     previousAction = activeAction;
     activeAction = actions[name];
 
diff --git a/examples-testing/examples/webgl_buffergeometry.ts b/examples-testing/examples/webgl_buffergeometry.ts
index 5f9bb39..03d2644 100644
--- a/examples-testing/examples/webgl_buffergeometry.ts
+++ b/examples-testing/examples/webgl_buffergeometry.ts
@@ -2,17 +2,17 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh;
+let mesh: THREE.Mesh;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -117,8 +117,8 @@ function init() {
         colors.push(color.r, color.g, color.b, alpha);
     }
 
-    function disposeArray() {
-        this.array = null;
+    function disposeArray(this: THREE.BufferAttribute) {
+        this.array = null as unknown as THREE.TypedArray;
     }
 
     geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3).onUpload(disposeArray));
diff --git a/examples-testing/examples/webgl_buffergeometry_custom_attributes_particles.ts b/examples-testing/examples/webgl_buffergeometry_custom_attributes_particles.ts
index e9e115d..65b7563 100644
--- a/examples-testing/examples/webgl_buffergeometry_custom_attributes_particles.ts
+++ b/examples-testing/examples/webgl_buffergeometry_custom_attributes_particles.ts
@@ -2,9 +2,11 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let particleSystem, uniforms, geometry;
+let particleSystem: THREE.Points,
+    uniforms: { pointTexture: THREE.IUniform<THREE.Texture> },
+    geometry: THREE.BufferGeometry;
 
 const particles = 100000;
 
@@ -23,8 +25,8 @@ function init() {
 
     const shaderMaterial = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
 
         blending: THREE.AdditiveBlending,
         depthTest: false,
@@ -66,7 +68,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_buffergeometry_drawrange.ts b/examples-testing/examples/webgl_buffergeometry_drawrange.ts
index 41f364d..347d455 100644
--- a/examples-testing/examples/webgl_buffergeometry_drawrange.ts
+++ b/examples-testing/examples/webgl_buffergeometry_drawrange.ts
@@ -5,15 +5,15 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let group;
-let container, stats;
-const particlesData = [];
-let camera, scene, renderer;
-let positions, colors;
-let particles;
-let pointCloud;
-let particlePositions;
-let linesMesh;
+let group: THREE.Group;
+let container: HTMLElement, stats: Stats;
+const particlesData: { velocity: THREE.Vector3; numConnections: number }[] = [];
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let positions: Float32Array, colors: Float32Array;
+let particles: THREE.BufferGeometry;
+let pointCloud: THREE.Points;
+let particlePositions: Float32Array;
+let linesMesh: THREE.LineSegments;
 
 const maxParticleCount = 1000;
 let particleCount = 500;
@@ -53,7 +53,7 @@ function initGUI() {
 function init() {
     initGUI();
 
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 4000);
     camera.position.z = 1750;
diff --git a/examples-testing/examples/webgl_buffergeometry_glbufferattribute.ts b/examples-testing/examples/webgl_buffergeometry_glbufferattribute.ts
index daf8a06..0624ea0 100644
--- a/examples-testing/examples/webgl_buffergeometry_glbufferattribute.ts
+++ b/examples-testing/examples/webgl_buffergeometry_glbufferattribute.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let points;
+let points: THREE.Points<THREE.BufferGeometry<THREE.NormalOrGLBufferAttributes>, THREE.PointsMaterial>;
 
 const particles = 300000;
 let drawCount = 10000;
@@ -15,7 +15,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -36,7 +36,7 @@ function init() {
 
     //
 
-    const geometry = new THREE.BufferGeometry();
+    const geometry = new THREE.BufferGeometry<THREE.NormalOrGLBufferAttributes>();
 
     const positions = [];
     const positions2 = [];
@@ -70,15 +70,15 @@ function init() {
 
     const gl = renderer.getContext();
 
-    const pos = gl.createBuffer();
+    const pos = gl.createBuffer()!;
     gl.bindBuffer(gl.ARRAY_BUFFER, pos);
     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
 
-    const pos2 = gl.createBuffer();
+    const pos2 = gl.createBuffer()!;
     gl.bindBuffer(gl.ARRAY_BUFFER, pos2);
     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions2), gl.STATIC_DRAW);
 
-    const rgb = gl.createBuffer();
+    const rgb = gl.createBuffer()!;
     gl.bindBuffer(gl.ARRAY_BUFFER, rgb);
     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
 
diff --git a/examples-testing/examples/webgl_buffergeometry_indexed.ts b/examples-testing/examples/webgl_buffergeometry_indexed.ts
index 1e9f668..ec64598 100644
--- a/examples-testing/examples/webgl_buffergeometry_indexed.ts
+++ b/examples-testing/examples/webgl_buffergeometry_indexed.ts
@@ -3,9 +3,9 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
-let mesh;
+let mesh: THREE.Mesh;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_buffergeometry_instancing.ts b/examples-testing/examples/webgl_buffergeometry_instancing.ts
index adff12a..fb9267f 100644
--- a/examples-testing/examples/webgl_buffergeometry_instancing.ts
+++ b/examples-testing/examples/webgl_buffergeometry_instancing.ts
@@ -3,15 +3,15 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10);
     camera.position.z = 2;
@@ -80,8 +80,8 @@ function init() {
             time: { value: 1.0 },
             sineTime: { value: 1.0 },
         },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
         side: THREE.DoubleSide,
         forceSinglePass: true,
         transparent: true,
@@ -100,7 +100,7 @@ function init() {
     container.appendChild(renderer.domElement);
 
     if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has('ANGLE_instanced_arrays') === false) {
-        document.getElementById('notSupported').style.display = '';
+        document.getElementById('notSupported')!.style.display = '';
         return;
     }
 
@@ -138,7 +138,7 @@ function animate() {
 function render() {
     const time = performance.now();
 
-    const object = scene.children[0];
+    const object = scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.RawShaderMaterial>;
 
     object.rotation.y = time * 0.0005;
     object.material.uniforms['time'].value = time * 0.005;
diff --git a/examples-testing/examples/webgl_buffergeometry_instancing_billboards.ts b/examples-testing/examples/webgl_buffergeometry_instancing_billboards.ts
index 785389c..64b3ee1 100644
--- a/examples-testing/examples/webgl_buffergeometry_instancing_billboards.ts
+++ b/examples-testing/examples/webgl_buffergeometry_instancing_billboards.ts
@@ -2,16 +2,16 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
-let geometry, material, mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let geometry: THREE.InstancedBufferGeometry, material: THREE.RawShaderMaterial, mesh: THREE.Mesh;
 
 function init() {
     renderer = new THREE.WebGLRenderer();
 
     if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has('ANGLE_instanced_arrays') === false) {
-        document.getElementById('notSupported').style.display = '';
+        document.getElementById('notSupported')!.style.display = '';
         return false;
     }
 
@@ -46,8 +46,8 @@ function init() {
             map: { value: new THREE.TextureLoader().load('textures/sprites/circle.png') },
             time: { value: 0.0 },
         },
-        vertexShader: document.getElementById('vshader').textContent,
-        fragmentShader: document.getElementById('fshader').textContent,
+        vertexShader: document.getElementById('vshader')!.textContent!,
+        fragmentShader: document.getElementById('fshader')!.textContent!,
         depthTest: true,
         depthWrite: true,
     });
diff --git a/examples-testing/examples/webgl_buffergeometry_instancing_interleaved.ts b/examples-testing/examples/webgl_buffergeometry_instancing_interleaved.ts
index 132e1e6..77ce657 100644
--- a/examples-testing/examples/webgl_buffergeometry_instancing_interleaved.ts
+++ b/examples-testing/examples/webgl_buffergeometry_instancing_interleaved.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
-let camera, scene, renderer, mesh;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mesh: THREE.InstancedMesh;
 
 const instances = 5000;
 let lastTime = 0;
@@ -17,7 +17,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
 
@@ -112,7 +112,7 @@ function init() {
     container.appendChild(renderer.domElement);
 
     if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has('ANGLE_instanced_arrays') === false) {
-        document.getElementById('notSupported').style.display = '';
+        document.getElementById('notSupported')!.style.display = '';
         return;
     }
 
diff --git a/examples-testing/examples/webgl_buffergeometry_lines.ts b/examples-testing/examples/webgl_buffergeometry_lines.ts
index c23ea0c..705d08f 100644
--- a/examples-testing/examples/webgl_buffergeometry_lines.ts
+++ b/examples-testing/examples/webgl_buffergeometry_lines.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats, clock;
+let container: HTMLElement, stats: Stats, clock: THREE.Clock;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let line;
+let line: THREE.Line;
 
 const segments = 10000;
 const r = 800;
@@ -16,7 +16,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -100,12 +100,12 @@ function render() {
     line.rotation.y = time * 0.5;
 
     t += delta * 0.5;
-    line.morphTargetInfluences[0] = Math.abs(Math.sin(t));
+    line.morphTargetInfluences![0] = Math.abs(Math.sin(t));
 
     renderer.render(scene, camera);
 }
 
-function generateMorphTargets(geometry) {
+function generateMorphTargets(geometry: THREE.BufferGeometry) {
     const data = [];
 
     for (let i = 0; i < segments; i++) {
diff --git a/examples-testing/examples/webgl_buffergeometry_lines_indexed.ts b/examples-testing/examples/webgl_buffergeometry_lines_indexed.ts
index 54bf898..096245e 100644
--- a/examples-testing/examples/webgl_buffergeometry_lines_indexed.ts
+++ b/examples-testing/examples/webgl_buffergeometry_lines_indexed.ts
@@ -2,17 +2,17 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let parent_node;
+let parent_node: THREE.Object3D;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 9000;
@@ -22,9 +22,9 @@ function init() {
     const geometry = new THREE.BufferGeometry();
     const material = new THREE.LineBasicMaterial({ vertexColors: true });
 
-    const indices = [];
-    const positions = [];
-    const colors = [];
+    const indices: number[] = [];
+    const positions: number[] = [];
+    const colors: number[] = [];
 
     let next_positions_index = 0;
 
@@ -33,7 +33,7 @@ function init() {
     const iteration_count = 4;
     const rangle = (60 * Math.PI) / 180.0;
 
-    function add_vertex(v) {
+    function add_vertex(v: THREE.Vector3) {
         positions.push(v.x, v.y, v.z);
         colors.push(Math.random() * 0.5 + 0.5, Math.random() * 0.5 + 0.5, 1);
 
@@ -42,7 +42,7 @@ function init() {
 
     // simple Koch curve
 
-    function snowflake_iteration(p0, p4, depth) {
+    function snowflake_iteration(p0: THREE.Vector3, p4: THREE.Vector3, depth: number) {
         if (--depth < 0) {
             const i = next_positions_index - 1; // p0 already there
             add_vertex(p4);
@@ -69,7 +69,7 @@ function init() {
         snowflake_iteration(p3, p4, depth);
     }
 
-    function snowflake(points, loop, x_offset) {
+    function snowflake(points: THREE.Vector3[], loop: boolean, x_offset: number) {
         for (let iteration = 0; iteration != iteration_count; iteration++) {
             add_vertex(points[0]);
 
diff --git a/examples-testing/examples/webgl_buffergeometry_points.ts b/examples-testing/examples/webgl_buffergeometry_points.ts
index fdfd957..b05a609 100644
--- a/examples-testing/examples/webgl_buffergeometry_points.ts
+++ b/examples-testing/examples/webgl_buffergeometry_points.ts
@@ -2,17 +2,17 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let points;
+let points: THREE.Points;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
diff --git a/examples-testing/examples/webgl_buffergeometry_points_interleaved.ts b/examples-testing/examples/webgl_buffergeometry_points_interleaved.ts
index 9d1ac41..e26b9a1 100644
--- a/examples-testing/examples/webgl_buffergeometry_points_interleaved.ts
+++ b/examples-testing/examples/webgl_buffergeometry_points_interleaved.ts
@@ -2,17 +2,17 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let points;
+let points: THREE.Points;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 5, 3500);
     camera.position.z = 2750;
diff --git a/examples-testing/examples/webgl_buffergeometry_rawshader.ts b/examples-testing/examples/webgl_buffergeometry_rawshader.ts
index 0d05339..cd5fe8c 100644
--- a/examples-testing/examples/webgl_buffergeometry_rawshader.ts
+++ b/examples-testing/examples/webgl_buffergeometry_rawshader.ts
@@ -2,15 +2,15 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10);
     camera.position.z = 2;
@@ -54,8 +54,8 @@ function init() {
         uniforms: {
             time: { value: 1.0 },
         },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
         side: THREE.DoubleSide,
         transparent: true,
     });
@@ -93,7 +93,7 @@ function animate() {
 function render() {
     const time = performance.now();
 
-    const object = scene.children[0];
+    const object = scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.RawShaderMaterial>;
 
     object.rotation.y = time * 0.0005;
     object.material.uniforms.time.value = time * 0.005;
diff --git a/examples-testing/examples/webgl_buffergeometry_selective_draw.ts b/examples-testing/examples/webgl_buffergeometry_selective_draw.ts
index f0752a2..8e8a44f 100644
--- a/examples-testing/examples/webgl_buffergeometry_selective_draw.ts
+++ b/examples-testing/examples/webgl_buffergeometry_selective_draw.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
-let geometry, mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let geometry: THREE.BufferGeometry, mesh: THREE.LineSegments;
 const numLat = 100;
 const numLng = 200;
 let numLinesCulled = 0;
@@ -29,14 +29,14 @@ function init() {
 
     addLines(1.0);
 
-    const hideLinesButton = document.getElementById('hideLines');
+    const hideLinesButton = document.getElementById('hideLines')!;
     hideLinesButton.addEventListener('click', hideLines);
 
-    const showAllLinesButton = document.getElementById('showAllLines');
+    const showAllLinesButton = document.getElementById('showAllLines')!;
     showAllLinesButton.addEventListener('click', showAllLines);
 }
 
-function addLines(radius) {
+function addLines(radius: number) {
     geometry = new THREE.BufferGeometry();
     const linePositions = new Float32Array(numLat * numLng * 3 * 2);
     const lineColors = new Float32Array(numLat * numLng * 3 * 2);
@@ -81,8 +81,8 @@ function addLines(radius) {
     geometry.computeBoundingSphere();
 
     const shaderMaterial = new THREE.ShaderMaterial({
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
     });
 
     mesh = new THREE.LineSegments(geometry, shaderMaterial);
@@ -98,7 +98,7 @@ function updateCount() {
         ' lines, ' +
         numLinesCulled +
         ' culled (<a target="_blank" href="http://callum.com">author</a>)';
-    document.getElementById('title').innerHTML = str.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
+    document.getElementById('title')!.innerHTML = str.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
 }
 
 function hideLines() {
diff --git a/examples-testing/examples/webgl_buffergeometry_uint.ts b/examples-testing/examples/webgl_buffergeometry_uint.ts
index d248a0d..16a111b 100644
--- a/examples-testing/examples/webgl_buffergeometry_uint.ts
+++ b/examples-testing/examples/webgl_buffergeometry_uint.ts
@@ -2,17 +2,17 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh;
+let mesh: THREE.Mesh;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
diff --git a/examples-testing/examples/webgl_camera.ts b/examples-testing/examples/webgl_camera.ts
index d78fbec..6b84a2c 100644
--- a/examples-testing/examples/webgl_camera.ts
+++ b/examples-testing/examples/webgl_camera.ts
@@ -6,11 +6,11 @@ let SCREEN_WIDTH = window.innerWidth;
 let SCREEN_HEIGHT = window.innerHeight;
 let aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
 
-let container, stats;
-let camera, scene, renderer, mesh;
-let cameraRig, activeCamera, activeHelper;
-let cameraPerspective, cameraOrtho;
-let cameraPerspectiveHelper, cameraOrthoHelper;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mesh: THREE.Mesh;
+let cameraRig: THREE.Group, activeCamera: THREE.Camera, activeHelper: THREE.CameraHelper;
+let cameraPerspective: THREE.PerspectiveCamera, cameraOrtho: THREE.OrthographicCamera;
+let cameraPerspectiveHelper: THREE.CameraHelper, cameraOrthoHelper: THREE.CameraHelper;
 const frustumSize = 600;
 
 init();
@@ -122,7 +122,7 @@ function init() {
 
 //
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     switch (event.keyCode) {
         case 79 /*O*/:
             activeCamera = cameraOrtho;
diff --git a/examples-testing/examples/webgl_camera_logarithmicdepthbuffer.ts b/examples-testing/examples/webgl_camera_logarithmicdepthbuffer.ts
index a80cc19..4d1f2c8 100644
--- a/examples-testing/examples/webgl_camera_logarithmicdepthbuffer.ts
+++ b/examples-testing/examples/webgl_camera_logarithmicdepthbuffer.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three';
 
-import { FontLoader } from 'three/addons/loaders/FontLoader.js';
+import { Font, FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
 import Stats from 'three/addons/libs/stats.module.js';
@@ -17,8 +17,16 @@ let zoompos = -100,
     minzoomspeed = 0.015;
 let zoomspeed = minzoomspeed;
 
-let container, border, stats;
-const objects = {};
+let container: HTMLElement, border: HTMLElement, stats: Stats;
+
+interface ObjectView {
+    container: HTMLElement;
+    renderer: THREE.WebGLRenderer;
+    scene: THREE.Scene;
+    camera: THREE.PerspectiveCamera;
+}
+
+const objects: { normal?: ObjectView; logzbuf?: ObjectView } = {};
 
 // Generate a number of text labels, from 1m in size up to 100,000,000 light years
 // Try to use some descriptive real-world examples of objects at each scale
@@ -44,7 +52,7 @@ const labeldata = [
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     const loader = new FontLoader();
     loader.load('fonts/helvetiker_regular.typeface.json', function (font) {
@@ -61,7 +69,7 @@ function init() {
     container.appendChild(stats.dom);
 
     // Resize border allows the user to easily compare effects of logarithmic depth buffer over the whole scene
-    border = document.getElementById('renderer_border');
+    border = document.getElementById('renderer_border')!;
     border.addEventListener('pointerdown', onBorderPointerDown);
 
     window.addEventListener('mousemove', onMouseMove);
@@ -69,8 +77,8 @@ function init() {
     window.addEventListener('wheel', onMouseWheel);
 }
 
-function initView(scene, name, logDepthBuf) {
-    const framecontainer = document.getElementById('container_' + name);
+function initView(scene: THREE.Scene, name: string, logDepthBuf: boolean) {
+    const framecontainer = document.getElementById('container_' + name)!;
 
     const camera = new THREE.PerspectiveCamera(50, (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT, NEAR, FAR);
     scene.add(camera);
@@ -85,7 +93,7 @@ function initView(scene, name, logDepthBuf) {
     return { container: framecontainer, renderer: renderer, scene: scene, camera: camera };
 }
 
-function initScene(font) {
+function initScene(font: Font) {
     const scene = new THREE.Scene();
 
     scene.add(new THREE.AmbientLight(0x777777));
@@ -94,7 +102,7 @@ function initScene(font) {
     light.position.set(100, 100, 100);
     scene.add(light);
 
-    const materialargs = {
+    const materialargs: { color: THREE.ColorRepresentation; specular: number; shininess: number; emissive: number } = {
         color: 0xffffff,
         specular: 0x050505,
         shininess: 50,
@@ -115,7 +123,7 @@ function initScene(font) {
         labelgeo.computeBoundingSphere();
 
         // center text
-        labelgeo.translate(-labelgeo.boundingSphere.radius, 0, 0);
+        labelgeo.translate(-labelgeo.boundingSphere!.radius, 0, 0);
 
         materialargs.color = new THREE.Color().setHSL(Math.random(), 0.5, 0.5);
 
@@ -148,16 +156,16 @@ function updateRendererSizes() {
 
     screensplit_right = 1 - screensplit;
 
-    objects.normal.renderer.setSize(screensplit * SCREEN_WIDTH, SCREEN_HEIGHT);
-    objects.normal.camera.aspect = (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT;
-    objects.normal.camera.updateProjectionMatrix();
-    objects.normal.camera.setViewOffset(SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT);
-    objects.normal.container.style.width = screensplit * 100 + '%';
+    objects.normal!.renderer.setSize(screensplit * SCREEN_WIDTH, SCREEN_HEIGHT);
+    objects.normal!.camera.aspect = (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT;
+    objects.normal!.camera.updateProjectionMatrix();
+    objects.normal!.camera.setViewOffset(SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT);
+    objects.normal!.container.style.width = screensplit * 100 + '%';
 
-    objects.logzbuf.renderer.setSize(screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT);
-    objects.logzbuf.camera.aspect = (screensplit_right * SCREEN_WIDTH) / SCREEN_HEIGHT;
-    objects.logzbuf.camera.updateProjectionMatrix();
-    objects.logzbuf.camera.setViewOffset(
+    objects.logzbuf!.renderer.setSize(screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT);
+    objects.logzbuf!.camera.aspect = (screensplit_right * SCREEN_WIDTH) / SCREEN_HEIGHT;
+    objects.logzbuf!.camera.updateProjectionMatrix();
+    objects.logzbuf!.camera.setViewOffset(
         SCREEN_WIDTH,
         SCREEN_HEIGHT,
         SCREEN_WIDTH * screensplit,
@@ -165,7 +173,7 @@ function updateRendererSizes() {
         SCREEN_WIDTH * screensplit_right,
         SCREEN_HEIGHT,
     );
-    objects.logzbuf.container.style.width = screensplit_right * 100 + '%';
+    objects.logzbuf!.container.style.width = screensplit_right * 100 + '%';
 
     border.style.left = screensplit * 100 + '%';
 }
@@ -193,22 +201,22 @@ function render() {
     zoompos += zoomspeed;
     zoomspeed *= damping;
 
-    objects.normal.camera.position.x = Math.sin(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
-    objects.normal.camera.position.y = Math.sin(0.25 * Math.PI * (mouse[1] - 0.5)) * zoom;
-    objects.normal.camera.position.z = Math.cos(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
-    objects.normal.camera.lookAt(objects.normal.scene.position);
+    objects.normal!.camera.position.x = Math.sin(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
+    objects.normal!.camera.position.y = Math.sin(0.25 * Math.PI * (mouse[1] - 0.5)) * zoom;
+    objects.normal!.camera.position.z = Math.cos(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
+    objects.normal!.camera.lookAt(objects.normal!.scene.position);
 
     // Clone camera settings across both scenes
-    objects.logzbuf.camera.position.copy(objects.normal.camera.position);
-    objects.logzbuf.camera.quaternion.copy(objects.normal.camera.quaternion);
+    objects.logzbuf!.camera.position.copy(objects.normal!.camera.position);
+    objects.logzbuf!.camera.quaternion.copy(objects.normal!.camera.quaternion);
 
     // Update renderer sizes if the split has changed
     if (screensplit_right != 1 - screensplit) {
         updateRendererSizes();
     }
 
-    objects.normal.renderer.render(objects.normal.scene, objects.normal.camera);
-    objects.logzbuf.renderer.render(objects.logzbuf.scene, objects.logzbuf.camera);
+    objects.normal!.renderer.render(objects.normal!.scene, objects.normal!.camera);
+    objects.logzbuf!.renderer.render(objects.logzbuf!.scene, objects.logzbuf!.camera);
 
     stats.update();
 }
@@ -223,7 +231,7 @@ function onBorderPointerDown() {
     window.addEventListener('pointerup', onBorderPointerUp);
 }
 
-function onBorderPointerMove(ev) {
+function onBorderPointerMove(ev: PointerEvent) {
     screensplit = Math.max(0, Math.min(1, ev.clientX / window.innerWidth));
 }
 
@@ -232,12 +240,12 @@ function onBorderPointerUp() {
     window.removeEventListener('pointerup', onBorderPointerUp);
 }
 
-function onMouseMove(ev) {
+function onMouseMove(ev: MouseEvent) {
     mouse[0] = ev.clientX / window.innerWidth;
     mouse[1] = ev.clientY / window.innerHeight;
 }
 
-function onMouseWheel(ev) {
+function onMouseWheel(ev: WheelEvent) {
     const amount = ev.deltaY;
     if (amount === 0) return;
     const dir = amount / Math.abs(amount);
diff --git a/examples-testing/examples/webgl_clipping.ts b/examples-testing/examples/webgl_clipping.ts
index 219a704..74a24e3 100644
--- a/examples-testing/examples/webgl_clipping.ts
+++ b/examples-testing/examples/webgl_clipping.ts
@@ -5,7 +5,12 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, startTime, object, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    startTime: number,
+    object: THREE.Mesh,
+    stats: Stats;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_clipping_advanced.ts b/examples-testing/examples/webgl_clipping_advanced.ts
index d60532c..75dba77 100644
--- a/examples-testing/examples/webgl_clipping_advanced.ts
+++ b/examples-testing/examples/webgl_clipping_advanced.ts
@@ -5,7 +5,7 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-function planesFromMesh(vertices, indices) {
+function planesFromMesh(vertices: THREE.Vector3[], indices: number[]) {
     // creates a clipping volume from a convex triangular mesh
     // specified by the arrays 'vertices' and 'indices'
 
@@ -23,23 +23,23 @@ function planesFromMesh(vertices, indices) {
     return result;
 }
 
-function createPlanes(n) {
+function createPlanes(n: number) {
     // creates an array of n uninitialized plane objects
 
-    const result = new Array(n);
+    const result = new Array<THREE.Plane>(n);
 
     for (let i = 0; i !== n; ++i) result[i] = new THREE.Plane();
 
     return result;
 }
 
-function assignTransformedPlanes(planesOut, planesIn, matrix) {
+function assignTransformedPlanes(planesOut: THREE.Plane[], planesIn: THREE.Plane[], matrix: THREE.Matrix4) {
     // sets an array of existing planes to transformed 'planesIn'
 
     for (let i = 0, n = planesIn.length; i !== n; ++i) planesOut[i].copy(planesIn[i]).applyMatrix4(matrix);
 }
 
-function cylindricalPlanes(n, innerRadius) {
+function cylindricalPlanes(n: number, innerRadius: number) {
     const result = createPlanes(n);
 
     for (let i = 0; i !== n; ++i) {
@@ -62,7 +62,7 @@ const planeToMatrix = (function () {
         yAxis = new THREE.Vector3(),
         trans = new THREE.Vector3();
 
-    return function planeToMatrix(plane) {
+    return function planeToMatrix(plane: THREE.Plane) {
         const zAxis = plane.normal,
             matrix = new THREE.Matrix4();
 
@@ -113,7 +113,15 @@ const Vertices = [
     GlobalClippingPlanes = cylindricalPlanes(5, 2.5),
     Empty = Object.freeze([]);
 
-let camera, scene, renderer, startTime, stats, object, clipMaterial, volumeVisualization, globalClippingPlanes;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    startTime: number,
+    stats: Stats,
+    object: THREE.Group,
+    clipMaterial: THREE.MeshPhongMaterial,
+    volumeVisualization: THREE.Group,
+    globalClippingPlanes: THREE.Plane[];
 
 function init() {
     camera = new THREE.PerspectiveCamera(36, window.innerWidth / window.innerHeight, 0.25, 16);
@@ -194,7 +202,7 @@ function init() {
 
             // clip to the others to show the volume (wildly
             // intersecting transparent planes look bad)
-            clippingPlanes: clipMaterial.clippingPlanes.filter(function (_, j) {
+            clippingPlanes: clipMaterial.clippingPlanes!.filter(function (_, j) {
                 return j !== i;
             }),
 
@@ -306,12 +314,12 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function setObjectWorldMatrix(object, matrix) {
+function setObjectWorldMatrix(object: THREE.Object3D, matrix: THREE.Matrix4) {
     // set the orientation of an object based on a world matrix
 
     const parent = object.parent;
     scene.updateMatrixWorld();
-    object.matrix.copy(parent.matrixWorld).invert();
+    object.matrix.copy(parent!.matrixWorld).invert();
     object.applyMatrix4(matrix);
 }
 
@@ -334,7 +342,7 @@ function animate() {
     const bouncy = Math.cos(time * 0.5) * 0.5 + 0.7;
     transform.multiply(tmpMatrix.makeScale(bouncy, bouncy, bouncy));
 
-    assignTransformedPlanes(clipMaterial.clippingPlanes, Planes, transform);
+    assignTransformedPlanes(clipMaterial.clippingPlanes!, Planes, transform);
 
     const planeMeshes = volumeVisualization.children;
 
diff --git a/examples-testing/examples/webgl_clipping_intersection.ts b/examples-testing/examples/webgl_clipping_intersection.ts
index 5f45e45..cb3cbdf 100644
--- a/examples-testing/examples/webgl_clipping_intersection.ts
+++ b/examples-testing/examples/webgl_clipping_intersection.ts
@@ -4,7 +4,7 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const params = {
     clipIntersection: true,
@@ -80,8 +80,8 @@ function init() {
 
     gui.add(params, 'alphaToCoverage').onChange(function (value) {
         group.children.forEach(c => {
-            c.material.alphaToCoverage = Boolean(value);
-            c.material.needsUpdate = true;
+            (c as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.alphaToCoverage = Boolean(value);
+            (c as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.needsUpdate = true;
         });
 
         render();
@@ -93,7 +93,7 @@ function init() {
             const children = group.children;
 
             for (let i = 0; i < children.length; i++) {
-                children[i].material.clipIntersection = value;
+                ((children[i] as THREE.Mesh).material as THREE.Material).clipIntersection = value;
             }
 
             render();
diff --git a/examples-testing/examples/webgl_clipping_stencil.ts b/examples-testing/examples/webgl_clipping_stencil.ts
index 365087d..9dd56a1 100644
--- a/examples-testing/examples/webgl_clipping_stencil.ts
+++ b/examples-testing/examples/webgl_clipping_stencil.ts
@@ -3,9 +3,13 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, object, stats;
-let planes, planeObjects, planeHelpers;
-let clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    object: THREE.Group,
+    stats: Stats;
+let planes: THREE.Plane[], planeObjects: THREE.Mesh[], planeHelpers: THREE.PlaneHelper[];
+let clock: THREE.Clock;
 
 const params = {
     animate: true,
@@ -29,7 +33,7 @@ const params = {
 init();
 animate();
 
-function createPlaneStencilGroup(geometry, plane, renderOrder) {
+function createPlaneStencilGroup(geometry: THREE.TorusKnotGeometry, plane: THREE.Plane, renderOrder: number) {
     const group = new THREE.Group();
     const baseMat = new THREE.MeshBasicMaterial();
     baseMat.depthWrite = false;
diff --git a/examples-testing/examples/webgl_custom_attributes.ts b/examples-testing/examples/webgl_custom_attributes.ts
index 648e097..98d024c 100644
--- a/examples-testing/examples/webgl_custom_attributes.ts
+++ b/examples-testing/examples/webgl_custom_attributes.ts
@@ -2,11 +2,16 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let sphere, uniforms;
+let sphere: THREE.Mesh,
+    uniforms: {
+        amplitude: THREE.IUniform<number>;
+        color: THREE.IUniform<THREE.Color>;
+        colorTexture: THREE.IUniform<THREE.Texture>;
+    };
 
-let displacement, noise;
+let displacement: Float32Array, noise: Float32Array;
 
 init();
 animate();
@@ -28,8 +33,8 @@ function init() {
 
     const shaderMaterial = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
     });
 
     const radius = 50,
@@ -54,7 +59,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_custom_attributes_lines.ts b/examples-testing/examples/webgl_custom_attributes_lines.ts
index 29b8a06..9217e11 100644
--- a/examples-testing/examples/webgl_custom_attributes_lines.ts
+++ b/examples-testing/examples/webgl_custom_attributes_lines.ts
@@ -1,13 +1,18 @@
 import * as THREE from 'three';
 
-import { FontLoader } from 'three/addons/loaders/FontLoader.js';
+import { Font, FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let line, uniforms;
+let line: THREE.Line,
+    uniforms: {
+        amplitude: THREE.IUniform<number>;
+        opacity: THREE.IUniform<number>;
+        color: THREE.IUniform<THREE.Color>;
+    };
 
 const loader = new FontLoader();
 loader.load('fonts/helvetiker_bold.typeface.json', function (font) {
@@ -15,7 +20,7 @@ loader.load('fonts/helvetiker_bold.typeface.json', function (font) {
     animate();
 });
 
-function init(font) {
+function init(font: Font) {
     camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 400;
 
@@ -30,8 +35,8 @@ function init(font) {
 
     const shaderMaterial = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
         blending: THREE.AdditiveBlending,
         depthTest: false,
         transparent: true,
@@ -75,7 +80,7 @@ function init(font) {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_custom_attributes_points.ts b/examples-testing/examples/webgl_custom_attributes_points.ts
index f1cfedc..a6ec206 100644
--- a/examples-testing/examples/webgl_custom_attributes_points.ts
+++ b/examples-testing/examples/webgl_custom_attributes_points.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let sphere;
+let sphere: THREE.Points;
 
 const WIDTH = window.innerWidth;
 const HEIGHT = window.innerHeight;
@@ -57,8 +57,8 @@ function init() {
             color: { value: new THREE.Color(0xffffff) },
             pointTexture: { value: new THREE.TextureLoader().load('textures/sprites/spark1.png') },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
 
         blending: THREE.AdditiveBlending,
         depthTest: false,
@@ -76,7 +76,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(WIDTH, HEIGHT);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_custom_attributes_points2.ts b/examples-testing/examples/webgl_custom_attributes_points2.ts
index f744a1e..d3b5cc2 100644
--- a/examples-testing/examples/webgl_custom_attributes_points2.ts
+++ b/examples-testing/examples/webgl_custom_attributes_points2.ts
@@ -4,8 +4,8 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let renderer, scene, camera, stats;
-let sphere, length1;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
+let sphere: THREE.Points, length1: number;
 
 const WIDTH = window.innerWidth;
 const HEIGHT = window.innerHeight;
@@ -23,8 +23,8 @@ function init() {
         segments = 68,
         rings = 38;
 
-    let sphereGeometry = new THREE.SphereGeometry(radius, segments, rings);
-    let boxGeometry = new THREE.BoxGeometry(0.8 * radius, 0.8 * radius, 0.8 * radius, 10, 10, 10);
+    let sphereGeometry: THREE.BufferGeometry = new THREE.SphereGeometry(radius, segments, rings);
+    let boxGeometry: THREE.BufferGeometry = new THREE.BoxGeometry(0.8 * radius, 0.8 * radius, 0.8 * radius, 10, 10, 10);
 
     // if normal and uv attributes are not removed, mergeVertices() can't consolidate identical vertices with different normal/uv data
 
@@ -40,8 +40,8 @@ function init() {
     const combinedGeometry = BufferGeometryUtils.mergeGeometries([sphereGeometry, boxGeometry]);
     const positionAttribute = combinedGeometry.getAttribute('position');
 
-    const colors = [];
-    const sizes = [];
+    const colors: number[] = [];
+    const sizes: number[] = [];
 
     const color = new THREE.Color();
     const vertex = new THREE.Vector3();
@@ -78,8 +78,8 @@ function init() {
             color: { value: new THREE.Color(0xffffff) },
             pointTexture: { value: texture },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
         transparent: true,
     });
 
@@ -94,7 +94,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(WIDTH, HEIGHT);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
@@ -150,7 +150,7 @@ function sortPoints() {
         sortArray.push([vector.z, i]);
     }
 
-    function numericalSort(a, b) {
+    function numericalSort(a: number[], b: number[]) {
         return b[0] - a[0];
     }
 
@@ -162,7 +162,7 @@ function sortPoints() {
         indices[i] = sortArray[i][1];
     }
 
-    geometry.index.needsUpdate = true;
+    geometry.index!.needsUpdate = true;
 }
 
 function animate() {
diff --git a/examples-testing/examples/webgl_custom_attributes_points3.ts b/examples-testing/examples/webgl_custom_attributes_points3.ts
index 1ef2f1f..fc34046 100644
--- a/examples-testing/examples/webgl_custom_attributes_points3.ts
+++ b/examples-testing/examples/webgl_custom_attributes_points3.ts
@@ -4,11 +4,11 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let object;
+let object: THREE.Points;
 
-let vertices1;
+let vertices1: number;
 
 const WIDTH = window.innerWidth;
 const HEIGHT = window.innerHeight;
@@ -48,7 +48,7 @@ function init() {
 
     radius = 200;
 
-    let boxGeometry1 = new THREE.BoxGeometry(radius, 0.1 * radius, 0.1 * radius, 50, 5, 5);
+    let boxGeometry1: THREE.BufferGeometry = new THREE.BoxGeometry(radius, 0.1 * radius, 0.1 * radius, 50, 5, 5);
 
     // if normal and uv attributes are not removed, mergeVertices() can't consolidate indentical vertices with different normal/uv data
 
@@ -63,7 +63,7 @@ function init() {
     const quaternion = new THREE.Quaternion();
     const scale = new THREE.Vector3(1, 1, 1);
 
-    function addGeo(geo, x, y, z, ry) {
+    function addGeo(geo: THREE.BufferGeometry, x: number, y: number, z: number, ry: number) {
         position.set(x, y, z);
         rotation.set(0, ry, 0);
 
@@ -94,7 +94,7 @@ function init() {
 
     // corner edges
 
-    let boxGeometry2 = new THREE.BoxGeometry(0.1 * radius, radius * 1.2, 0.1 * radius, 5, 60, 5);
+    let boxGeometry2: THREE.BufferGeometry = new THREE.BoxGeometry(0.1 * radius, radius * 1.2, 0.1 * radius, 5, 60, 5);
 
     boxGeometry2.deleteAttribute('normal');
     boxGeometry2.deleteAttribute('uv');
@@ -108,8 +108,8 @@ function init() {
 
     const positionAttribute = new THREE.Float32BufferAttribute(vertices, 3);
 
-    const colors = [];
-    const sizes = [];
+    const colors: number[] = [];
+    const sizes: number[] = [];
 
     const color = new THREE.Color();
 
@@ -142,8 +142,8 @@ function init() {
             color: { value: new THREE.Color(0xffffff) },
             pointTexture: { value: texture },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
     });
 
     //
@@ -157,7 +157,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(WIDTH, HEIGHT);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_decals.ts b/examples-testing/examples/webgl_decals.ts
index 975463c..d1ffa77 100644
--- a/examples-testing/examples/webgl_decals.ts
+++ b/examples-testing/examples/webgl_decals.ts
@@ -7,12 +7,12 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';
 
-const container = document.getElementById('container');
+const container = document.getElementById('container')!;
 
-let renderer, scene, camera, stats;
-let mesh;
-let raycaster;
-let line;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
+let mesh: THREE.Mesh;
+let raycaster: THREE.Raycaster;
+let line: THREE.Line;
 
 const intersection = {
     intersects: false,
@@ -20,7 +20,7 @@ const intersection = {
     normal: new THREE.Vector3(),
 };
 const mouse = new THREE.Vector2();
-const intersects = [];
+const intersects: THREE.Intersection[] = [];
 
 const textureLoader = new THREE.TextureLoader();
 const decalDiffuse = textureLoader.load('textures/decal/decal-diffuse.png');
@@ -41,8 +41,8 @@ const decalMaterial = new THREE.MeshPhongMaterial({
     wireframe: false,
 });
 
-const decals = [];
-let mouseHelper;
+const decals: THREE.Mesh[] = [];
+let mouseHelper: THREE.Mesh;
 const position = new THREE.Vector3();
 const orientation = new THREE.Euler();
 const size = new THREE.Vector3(10, 10, 10);
@@ -123,13 +123,13 @@ function init() {
 
     window.addEventListener('pointermove', onPointerMove);
 
-    function onPointerMove(event) {
+    function onPointerMove(event: PointerEvent) {
         if (event.isPrimary) {
             checkIntersection(event.clientX, event.clientY);
         }
     }
 
-    function checkIntersection(x, y) {
+    function checkIntersection(x: number, y: number) {
         if (mesh === undefined) return;
 
         mouse.x = (x / window.innerWidth) * 2 - 1;
@@ -143,12 +143,12 @@ function init() {
             mouseHelper.position.copy(p);
             intersection.point.copy(p);
 
-            const n = intersects[0].face.normal.clone();
+            const n = intersects[0].face!.normal.clone();
             n.transformDirection(mesh.matrixWorld);
             n.multiplyScalar(10);
             n.add(intersects[0].point);
 
-            intersection.normal.copy(intersects[0].face.normal);
+            intersection.normal.copy(intersects[0].face!.normal);
             mouseHelper.lookAt(n);
 
             const positions = line.geometry.attributes.position;
@@ -182,7 +182,7 @@ function loadLeePerrySmith() {
     const loader = new GLTFLoader();
 
     loader.load('models/gltf/LeePerrySmith/LeePerrySmith.glb', function (gltf) {
-        mesh = gltf.scene.children[0];
+        mesh = gltf.scene.children[0] as THREE.Mesh;
         mesh.material = new THREE.MeshPhongMaterial({
             specular: 0x111111,
             map: map,
diff --git a/examples-testing/examples/webgl_effects_anaglyph.ts b/examples-testing/examples/webgl_effects_anaglyph.ts
index 5132963..af1bb7f 100644
--- a/examples-testing/examples/webgl_effects_anaglyph.ts
+++ b/examples-testing/examples/webgl_effects_anaglyph.ts
@@ -2,9 +2,13 @@ import * as THREE from 'three';
 
 import { AnaglyphEffect } from 'three/addons/effects/AnaglyphEffect.js';
 
-let container, camera, scene, renderer, effect;
+let container: HTMLDivElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    effect: AnaglyphEffect;
 
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
 let mouseX = 0;
 let mouseY = 0;
@@ -84,7 +88,7 @@ function onWindowResize() {
     effect.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) / 100;
     mouseY = (event.clientY - windowHalfY) / 100;
 }
diff --git a/examples-testing/examples/webgl_effects_ascii.ts b/examples-testing/examples/webgl_effects_ascii.ts
index 60b7de8..6e546c4 100644
--- a/examples-testing/examples/webgl_effects_ascii.ts
+++ b/examples-testing/examples/webgl_effects_ascii.ts
@@ -3,9 +3,13 @@ import * as THREE from 'three';
 import { AsciiEffect } from 'three/addons/effects/AsciiEffect.js';
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 
-let camera, controls, scene, renderer, effect;
+let camera: THREE.PerspectiveCamera,
+    controls: TrackballControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    effect: AsciiEffect;
 
-let sphere, plane;
+let sphere: THREE.Mesh, plane: THREE.Mesh;
 
 const start = Date.now();
 
diff --git a/examples-testing/examples/webgl_effects_parallaxbarrier.ts b/examples-testing/examples/webgl_effects_parallaxbarrier.ts
index 45e7491..f6ed13c 100644
--- a/examples-testing/examples/webgl_effects_parallaxbarrier.ts
+++ b/examples-testing/examples/webgl_effects_parallaxbarrier.ts
@@ -2,9 +2,13 @@ import * as THREE from 'three';
 
 import { ParallaxBarrierEffect } from 'three/addons/effects/ParallaxBarrierEffect.js';
 
-let container, camera, scene, renderer, effect;
+let container: HTMLDivElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    effect: ParallaxBarrierEffect;
 
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
 let mouseX = 0;
 let mouseY = 0;
@@ -84,7 +88,7 @@ function onWindowResize() {
     effect.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) / 100;
     mouseY = (event.clientY - windowHalfY) / 100;
 }
diff --git a/examples-testing/examples/webgl_effects_peppersghost.ts b/examples-testing/examples/webgl_effects_peppersghost.ts
index 90cfe01..314b24c 100644
--- a/examples-testing/examples/webgl_effects_peppersghost.ts
+++ b/examples-testing/examples/webgl_effects_peppersghost.ts
@@ -2,10 +2,10 @@ import * as THREE from 'three';
 
 import { PeppersGhostEffect } from 'three/addons/effects/PeppersGhostEffect.js';
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer, effect;
-let group;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, effect: PeppersGhostEffect;
+let group: THREE.Group;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_effects_stereo.ts b/examples-testing/examples/webgl_effects_stereo.ts
index 4db7184..a5457e3 100644
--- a/examples-testing/examples/webgl_effects_stereo.ts
+++ b/examples-testing/examples/webgl_effects_stereo.ts
@@ -2,9 +2,13 @@ import * as THREE from 'three';
 
 import { StereoEffect } from 'three/addons/effects/StereoEffect.js';
 
-let container, camera, scene, renderer, effect;
+let container: HTMLDivElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    effect: StereoEffect;
 
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
 let mouseX = 0,
     mouseY = 0;
@@ -73,7 +77,7 @@ function onWindowResize() {
     effect.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) * 10;
     mouseY = (event.clientY - windowHalfY) * 10;
 }
diff --git a/examples-testing/examples/webgl_framebuffer_texture.ts b/examples-testing/examples/webgl_framebuffer_texture.ts
index 379737f..5f4095f 100644
--- a/examples-testing/examples/webgl_framebuffer_texture.ts
+++ b/examples-testing/examples/webgl_framebuffer_texture.ts
@@ -3,10 +3,10 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';
 
-let camera, scene, renderer;
-let line, sprite, texture;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let line: THREE.Line, sprite: THREE.Sprite, texture: THREE.FramebufferTexture;
 
-let cameraOrtho, sceneOrtho;
+let cameraOrtho: THREE.OrthographicCamera, sceneOrtho: THREE.Scene;
 
 let offset = 0;
 
@@ -76,7 +76,7 @@ function init() {
 
     //
 
-    const selection = document.getElementById('selection');
+    const selection = document.getElementById('selection')!;
     const controls = new OrbitControls(camera, selection);
     controls.enablePan = false;
 
@@ -135,7 +135,7 @@ function animate() {
     renderer.render(sceneOrtho, cameraOrtho);
 }
 
-function updateColors(colorAttribute) {
+function updateColors(colorAttribute: THREE.BufferAttribute | THREE.InterleavedBufferAttribute) {
     const l = colorAttribute.count;
 
     for (let i = 0; i < l; i++) {
diff --git a/examples-testing/examples/webgl_furnace_test.ts b/examples-testing/examples/webgl_furnace_test.ts
index a819541..46230b4 100644
--- a/examples-testing/examples/webgl_furnace_test.ts
+++ b/examples-testing/examples/webgl_furnace_test.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three';
 
-let scene, camera, renderer, radianceMap;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, radianceMap: THREE.Texture;
 
 const COLOR = 0xcccccc;
 
@@ -20,7 +20,8 @@ function init() {
 
     document.body.addEventListener('mouseover', function () {
         scene.traverse(function (child) {
-            if (child.isMesh) child.material.color.setHex(0xffffff);
+            if ((child as THREE.Mesh).isMesh)
+                ((child as THREE.Mesh).material as THREE.MeshStandardMaterial).color.setHex(0xffffff);
         });
 
         render();
@@ -28,7 +29,8 @@ function init() {
 
     document.body.addEventListener('mouseout', function () {
         scene.traverse(function (child) {
-            if (child.isMesh) child.material.color.setHex(0xccccff); // tinted for visibility
+            if ((child as THREE.Mesh).isMesh)
+                ((child as THREE.Mesh).material as THREE.MeshStandardMaterial).color.setHex(0xccccff); // tinted for visibility
         });
 
         render();
diff --git a/examples-testing/examples/webgl_geometries.ts b/examples-testing/examples/webgl_geometries.ts
index 154164e..ab4961b 100644
--- a/examples-testing/examples/webgl_geometries.ts
+++ b/examples-testing/examples/webgl_geometries.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 animate();
@@ -129,7 +129,7 @@ function render() {
     camera.lookAt(scene.position);
 
     scene.traverse(function (object) {
-        if (object.isMesh === true) {
+        if ((object as THREE.Mesh).isMesh === true) {
             object.rotation.x = timer * 5;
             object.rotation.y = timer * 2.5;
         }
diff --git a/examples-testing/examples/webgl_geometries_parametric.ts b/examples-testing/examples/webgl_geometries_parametric.ts
index 8aa86c3..ea8662c 100644
--- a/examples-testing/examples/webgl_geometries_parametric.ts
+++ b/examples-testing/examples/webgl_geometries_parametric.ts
@@ -6,13 +6,13 @@ import * as Curves from 'three/addons/curves/CurveExtras.js';
 import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';
 import { ParametricGeometries } from 'three/addons/geometries/ParametricGeometries.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
     camera.position.y = 400;
@@ -116,7 +116,7 @@ function render() {
     camera.lookAt(scene.position);
 
     scene.traverse(function (object) {
-        if (object.isMesh === true) {
+        if ((object as THREE.Mesh).isMesh === true) {
             object.rotation.x = timer * 5;
             object.rotation.y = timer * 2.5;
         }
diff --git a/examples-testing/examples/webgl_geometry_colors.ts b/examples-testing/examples/webgl_geometry_colors.ts
index 7acc60f..836e466 100644
--- a/examples-testing/examples/webgl_geometry_colors.ts
+++ b/examples-testing/examples/webgl_geometry_colors.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let mouseX = 0,
     mouseY = 0;
@@ -16,7 +16,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 1800;
@@ -34,7 +34,7 @@ function init() {
     canvas.width = 128;
     canvas.height = 128;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     const gradient = context.createRadialGradient(
         canvas.width / 2,
         canvas.height / 2,
@@ -154,7 +154,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgl_geometry_colors_lookuptable.ts b/examples-testing/examples/webgl_geometry_colors_lookuptable.ts
index 6b01385..382a9b7 100644
--- a/examples-testing/examples/webgl_geometry_colors_lookuptable.ts
+++ b/examples-testing/examples/webgl_geometry_colors_lookuptable.ts
@@ -5,19 +5,19 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Lut } from 'three/addons/math/Lut.js';
 
-let container;
+let container: HTMLElement;
 
-let perpCamera, orthoCamera, renderer, lut;
+let perpCamera: THREE.PerspectiveCamera, orthoCamera: THREE.OrthographicCamera, renderer: THREE.WebGLRenderer, lut: Lut;
 
-let mesh, sprite;
-let scene, uiScene;
+let mesh: THREE.Mesh, sprite: THREE.Sprite;
+let scene: THREE.Scene, uiScene: THREE.Scene;
 
-let params;
+let params: { colorMap: string };
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
     scene.background = new THREE.Color(0xffffff);
@@ -41,7 +41,7 @@ function init() {
             map: new THREE.CanvasTexture(lut.createCanvas()),
         }),
     );
-    sprite.material.map.colorSpace = THREE.SRGBColorSpace;
+    sprite.material.map!.colorSpace = THREE.SRGBColorSpace;
     sprite.scale.x = 0.125;
     uiScene.add(sprite);
 
@@ -142,7 +142,7 @@ function updateColors() {
 
     colors.needsUpdate = true;
 
-    const map = sprite.material.map;
+    const map = sprite.material.map!;
     lut.updateCanvas(map.image);
     map.needsUpdate = true;
 }
diff --git a/examples-testing/examples/webgl_geometry_convex.ts b/examples-testing/examples/webgl_geometry_convex.ts
index b033036..38eecb8 100644
--- a/examples-testing/examples/webgl_geometry_convex.ts
+++ b/examples-testing/examples/webgl_geometry_convex.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let group, camera, scene, renderer;
+let group: THREE.Group, camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -54,7 +54,7 @@ function init() {
 
     // points
 
-    let dodecahedronGeometry = new THREE.DodecahedronGeometry(10);
+    let dodecahedronGeometry: THREE.BufferGeometry = new THREE.DodecahedronGeometry(10);
 
     // if normal and uv attributes are not removed, mergeVertices() can't consolidate indentical vertices with different normal/uv data
 
diff --git a/examples-testing/examples/webgl_geometry_cube.ts b/examples-testing/examples/webgl_geometry_cube.ts
index bf22fcb..71a3610 100644
--- a/examples-testing/examples/webgl_geometry_cube.ts
+++ b/examples-testing/examples/webgl_geometry_cube.ts
@@ -1,7 +1,7 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
-let mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mesh: THREE.Mesh;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_geometry_dynamic.ts b/examples-testing/examples/webgl_geometry_dynamic.ts
index ccbaa6b..b9307ac 100644
--- a/examples-testing/examples/webgl_geometry_dynamic.ts
+++ b/examples-testing/examples/webgl_geometry_dynamic.ts
@@ -4,9 +4,13 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
 
-let camera, controls, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera,
+    controls: FirstPersonControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats;
 
-let mesh, geometry, material, clock;
+let mesh: THREE.Mesh, geometry: THREE.PlaneGeometry, material: THREE.MeshBasicMaterial, clock: THREE.Clock;
 
 const worldWidth = 128,
     worldDepth = 128;
@@ -27,7 +31,7 @@ function init() {
     geometry = new THREE.PlaneGeometry(20000, 20000, worldWidth - 1, worldDepth - 1);
     geometry.rotateX(-Math.PI / 2);
 
-    const position = geometry.attributes.position;
+    const position = geometry.attributes.position as THREE.BufferAttribute;
     position.usage = THREE.DynamicDrawUsage;
 
     for (let i = 0; i < position.count; i++) {
diff --git a/examples-testing/examples/webgl_geometry_extrude_shapes.ts b/examples-testing/examples/webgl_geometry_extrude_shapes.ts
index 099b425..a2de450 100644
--- a/examples-testing/examples/webgl_geometry_extrude_shapes.ts
+++ b/examples-testing/examples/webgl_geometry_extrude_shapes.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: TrackballControls;
 
 init();
 animate();
@@ -14,7 +14,7 @@ function init() {
     info.style.width = '100%';
     info.style.textAlign = 'center';
     info.style.color = '#fff';
-    info.style.link = '#f80';
+    (info.style as any).link = '#f80';
     info.innerHTML =
         '<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - geometry extrude shapes';
     document.body.appendChild(info);
diff --git a/examples-testing/examples/webgl_geometry_extrude_splines.ts b/examples-testing/examples/webgl_geometry_extrude_splines.ts
index 370a4d9..bbb481f 100644
--- a/examples-testing/examples/webgl_geometry_extrude_splines.ts
+++ b/examples-testing/examples/webgl_geometry_extrude_splines.ts
@@ -6,9 +6,14 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import * as Curves from 'three/addons/curves/CurveExtras.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer, splineCamera, cameraHelper, cameraEye;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    splineCamera: THREE.PerspectiveCamera,
+    cameraHelper: THREE.CameraHelper,
+    cameraEye: THREE.Mesh;
 
 const direction = new THREE.Vector3();
 const binormal = new THREE.Vector3();
@@ -78,9 +83,18 @@ const splines = {
     SampleClosedSpline: sampleClosedSpline,
 };
 
-let parent, tubeGeometry, mesh;
-
-const params = {
+let parent: THREE.Object3D, tubeGeometry: THREE.TubeGeometry, mesh: THREE.Mesh;
+
+const params: {
+    spline: keyof typeof splines;
+    scale: number;
+    extrusionSegments: number;
+    radiusSegments: number;
+    closed: boolean;
+    animationView: boolean;
+    lookAhead: boolean;
+    cameraHelper: boolean;
+} = {
     spline: 'GrannyKnot',
     scale: 4,
     extrusionSegments: 100,
@@ -125,7 +139,7 @@ function setScale() {
     mesh.scale.set(params.scale, params.scale, params.scale);
 }
 
-function addGeometry(geometry) {
+function addGeometry(geometry: THREE.BufferGeometry) {
     // 3D shape
 
     mesh = new THREE.Mesh(geometry, material);
@@ -144,7 +158,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     // camera
 
@@ -202,7 +216,7 @@ function init() {
     const gui = new GUI({ width: 285 });
 
     const folderGeometry = gui.addFolder('Geometry');
-    folderGeometry.add(params, 'spline', Object.keys(splines)).onChange(function () {
+    folderGeometry.add(params, 'spline', Object.keys(splines) as (keyof typeof splines)[]).onChange(function () {
         addTube();
     });
     folderGeometry
diff --git a/examples-testing/examples/webgl_geometry_minecraft.ts b/examples-testing/examples/webgl_geometry_minecraft.ts
index 537d8d5..bfa97ba 100644
--- a/examples-testing/examples/webgl_geometry_minecraft.ts
+++ b/examples-testing/examples/webgl_geometry_minecraft.ts
@@ -6,9 +6,9 @@ import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.j
 import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: FirstPersonControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const worldWidth = 128,
     worldDepth = 128;
@@ -22,7 +22,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);
     camera.position.y = getY(worldHalfWidth, worldHalfDepth) * 100 + 100;
@@ -143,7 +143,7 @@ function onWindowResize() {
     controls.handleResize();
 }
 
-function generateHeight(width, height) {
+function generateHeight(width: number, height: number) {
     const data = [],
         perlin = new ImprovedNoise(),
         size = width * height,
@@ -166,7 +166,7 @@ function generateHeight(width, height) {
     return data;
 }
 
-function getY(x, z) {
+function getY(x: number, z: number) {
     return (data[x + z * worldWidth] * 0.15) | 0;
 }
 
diff --git a/examples-testing/examples/webgl_geometry_nurbs.ts b/examples-testing/examples/webgl_geometry_nurbs.ts
index 6ab8b32..47ab35c 100644
--- a/examples-testing/examples/webgl_geometry_nurbs.ts
+++ b/examples-testing/examples/webgl_geometry_nurbs.ts
@@ -7,10 +7,10 @@ import { NURBSSurface } from 'three/addons/curves/NURBSSurface.js';
 import { NURBSVolume } from 'three/addons/curves/NURBSVolume.js';
 import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
-let group;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let group: THREE.Group;
 
 let targetRotation = 0;
 let targetRotationOnPointerDown = 0;
@@ -79,7 +79,7 @@ function init() {
     group.add(nurbsLine);
 
     const nurbsControlPointsGeometry = new THREE.BufferGeometry();
-    nurbsControlPointsGeometry.setFromPoints(nurbsCurve.controlPoints);
+    nurbsControlPointsGeometry.setFromPoints(nurbsCurve.controlPoints as THREE.Vector3[]);
 
     const nurbsControlPointsMaterial = new THREE.LineBasicMaterial({
         color: 0x333333,
@@ -124,7 +124,7 @@ function init() {
         map.anisotropy = 16;
         map.colorSpace = THREE.SRGBColorSpace;
 
-        function getSurfacePoint(u, v, target) {
+        function getSurfacePoint(u: number, v: number, target: THREE.Vector3) {
             return nurbsSurface.getPoint(u, v, target);
         }
 
@@ -175,23 +175,23 @@ function init() {
         // we create evaluation functions for different surfaces with one of the three
         // parameter values (u, v, w) kept constant and create multiple THREE.Mesh
         // objects one for each surface
-        function getSurfacePointFront(u, v, target) {
+        function getSurfacePointFront(u: number, v: number, target: THREE.Vector3) {
             return nurbsVolume.getPoint(u, v, 0, target);
         }
 
-        function getSurfacePointMiddle(u, v, target) {
+        function getSurfacePointMiddle(u: number, v: number, target: THREE.Vector3) {
             return nurbsVolume.getPoint(u, v, 0.5, target);
         }
 
-        function getSurfacePointBack(u, v, target) {
+        function getSurfacePointBack(u: number, v: number, target: THREE.Vector3) {
             return nurbsVolume.getPoint(u, v, 1, target);
         }
 
-        function getSurfacePointTop(u, w, target) {
+        function getSurfacePointTop(u: number, w: number, target: THREE.Vector3) {
             return nurbsVolume.getPoint(u, 1, w, target);
         }
 
-        function getSurfacePointSide(v, w, target) {
+        function getSurfacePointSide(v: number, w: number, target: THREE.Vector3) {
             return nurbsVolume.getPoint(0, v, w, target);
         }
 
@@ -260,7 +260,7 @@ function onWindowResize() {
 
 //
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerXOnPointerDown = event.clientX - windowHalfX;
@@ -270,7 +270,7 @@ function onPointerDown(event) {
     document.addEventListener('pointerup', onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerX = event.clientX - windowHalfX;
@@ -278,7 +278,7 @@ function onPointerMove(event) {
     targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
 }
 
-function onPointerUp() {
+function onPointerUp(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     document.removeEventListener('pointermove', onPointerMove);
diff --git a/examples-testing/examples/webgl_geometry_sdf.ts b/examples-testing/examples/webgl_geometry_sdf.ts
index c342065..bff700c 100644
--- a/examples-testing/examples/webgl_geometry_sdf.ts
+++ b/examples-testing/examples/webgl_geometry_sdf.ts
@@ -1,10 +1,19 @@
 import * as THREE from 'three';
-import { OrbitControls } from './jsm/controls/OrbitControls.js';
+import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { SDFGeometryGenerator } from 'three/addons/geometries/SDFGeometryGenerator.js';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let renderer, stats, meshFromSDF, scene, camera, clock, controls;
+let renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    meshFromSDF: THREE.Mesh<
+        THREE.BufferGeometry,
+        THREE.MeshBasicMaterial | THREE.MeshDepthMaterial | THREE.MeshNormalMaterial
+    >,
+    scene: THREE.Scene,
+    camera: THREE.OrthographicCamera,
+    clock: THREE.Clock,
+    controls: OrbitControls;
 
 const settings = {
     res: 4,
@@ -12,7 +21,7 @@ const settings = {
     autoRotate: true,
     wireframe: true,
     material: 'depth',
-    vertexCount: '0',
+    vertexCount: 0,
 };
 
 // Example SDF from https://www.shadertoy.com/view/MdXSWn -->
diff --git a/examples-testing/examples/webgl_geometry_shapes.ts b/examples-testing/examples/webgl_geometry_shapes.ts
index c3ff3a7..ff3abca 100644
--- a/examples-testing/examples/webgl_geometry_shapes.ts
+++ b/examples-testing/examples/webgl_geometry_shapes.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let group;
+let group: THREE.Group;
 
 let targetRotation = 0;
 let targetRotationOnPointerDown = 0;
@@ -46,11 +46,22 @@ function init() {
     texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
     texture.repeat.set(0.008, 0.008);
 
-    function addShape(shape, extrudeSettings, color, x, y, z, rx, ry, rz, s) {
+    function addShape(
+        shape: THREE.Shape,
+        extrudeSettings: THREE.ExtrudeGeometryOptions,
+        color: number,
+        x: number,
+        y: number,
+        z: number,
+        rx: number,
+        ry: number,
+        rz: number,
+        s: number,
+    ) {
         // flat shape with texture
         // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices
 
-        let geometry = new THREE.ShapeGeometry(shape);
+        let geometry: THREE.BufferGeometry = new THREE.ShapeGeometry(shape);
 
         let mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ side: THREE.DoubleSide, map: texture }));
         mesh.position.set(x, y, z - 175);
@@ -81,7 +92,17 @@ function init() {
         addLineShape(shape, color, x, y, z, rx, ry, rz, s);
     }
 
-    function addLineShape(shape, color, x, y, z, rx, ry, rz, s) {
+    function addLineShape(
+        shape: THREE.Path,
+        color: number,
+        x: number,
+        y: number,
+        z: number,
+        rx: number,
+        ry: number,
+        rz: number,
+        s: number,
+    ) {
         // lines
 
         shape.autoClose = true;
@@ -325,7 +346,7 @@ function onWindowResize() {
 
 //
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerXOnPointerDown = event.clientX - windowHalfX;
@@ -335,7 +356,7 @@ function onPointerDown(event) {
     document.addEventListener('pointerup', onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerX = event.clientX - windowHalfX;
@@ -343,7 +364,7 @@ function onPointerMove(event) {
     targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
 }
 
-function onPointerUp() {
+function onPointerUp(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     document.removeEventListener('pointermove', onPointerMove);
diff --git a/examples-testing/examples/webgl_geometry_teapot.ts b/examples-testing/examples/webgl_geometry_teapot.ts
index 4c884a5..b94b16d 100644
--- a/examples-testing/examples/webgl_geometry_teapot.ts
+++ b/examples-testing/examples/webgl_geometry_teapot.ts
@@ -5,22 +5,30 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 let cameraControls;
-let effectController;
+let effectController: {
+    newTess: number;
+    bottom: boolean;
+    lid: boolean;
+    body: boolean;
+    fitLid: boolean;
+    nonblinn: boolean;
+    newShading: string;
+};
 const teapotSize = 300;
-let ambientLight, light;
+let ambientLight: THREE.AmbientLight, light: THREE.DirectionalLight;
 
 let tess = -1; // force initialization
-let bBottom;
-let bLid;
-let bBody;
-let bFitLid;
-let bNonBlinn;
-let shading;
-
-let teapot, textureCube;
-const materials = {};
+let bBottom: boolean;
+let bLid: boolean;
+let bBody: boolean;
+let bFitLid: boolean;
+let bNonBlinn: boolean;
+let shading: string;
+
+let teapot: THREE.Mesh, textureCube: THREE.CubeTexture;
+const materials: Record<string, THREE.Material> = {};
 
 init();
 render();
diff --git a/examples-testing/examples/webgl_geometry_terrain.ts b/examples-testing/examples/webgl_geometry_terrain.ts
index b63a363..965d70a 100644
--- a/examples-testing/examples/webgl_geometry_terrain.ts
+++ b/examples-testing/examples/webgl_geometry_terrain.ts
@@ -5,9 +5,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
 import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
 
-let container, stats;
-let camera, controls, scene, renderer;
-let mesh, texture;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, controls: FirstPersonControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mesh: THREE.Mesh, texture: THREE.CanvasTexture;
 
 const worldWidth = 256,
     worldDepth = 256;
@@ -17,7 +17,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
 
@@ -73,7 +73,7 @@ function onWindowResize() {
     controls.handleResize();
 }
 
-function generateHeight(width, height) {
+function generateHeight(width: number, height: number) {
     let seed = Math.PI / 4;
     window.Math.random = function () {
         const x = Math.sin(seed++) * 10000;
@@ -100,7 +100,7 @@ function generateHeight(width, height) {
     return data;
 }
 
-function generateTexture(data, width, height) {
+function generateTexture(data: Uint8Array, width: number, height: number) {
     let context, image, imageData, shade;
 
     const vector3 = new THREE.Vector3(0, 0, 0);
@@ -112,7 +112,7 @@ function generateTexture(data, width, height) {
     canvas.width = width;
     canvas.height = height;
 
-    context = canvas.getContext('2d');
+    context = canvas.getContext('2d')!;
     context.fillStyle = '#000';
     context.fillRect(0, 0, width, height);
 
@@ -140,7 +140,7 @@ function generateTexture(data, width, height) {
     canvasScaled.width = width * 4;
     canvasScaled.height = height * 4;
 
-    context = canvasScaled.getContext('2d');
+    context = canvasScaled.getContext('2d')!;
     context.scale(4, 4);
     context.drawImage(canvas, 0, 0);
 
diff --git a/examples-testing/examples/webgl_geometry_terrain_raycast.ts b/examples-testing/examples/webgl_geometry_terrain_raycast.ts
index 4e9a7d3..86071e3 100644
--- a/examples-testing/examples/webgl_geometry_terrain_raycast.ts
+++ b/examples-testing/examples/webgl_geometry_terrain_raycast.ts
@@ -5,18 +5,18 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh, texture;
+let mesh: THREE.Mesh, texture: THREE.CanvasTexture;
 
 const worldWidth = 256,
     worldDepth = 256,
     worldHalfWidth = worldWidth / 2,
     worldHalfDepth = worldDepth / 2;
 
-let helper;
+let helper: THREE.Mesh;
 
 const raycaster = new THREE.Raycaster();
 const pointer = new THREE.Vector2();
@@ -25,7 +25,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
     container.innerHTML = '';
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -94,7 +94,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function generateHeight(width, height) {
+function generateHeight(width: number, height: number) {
     const size = width * height,
         data = new Uint8Array(size),
         perlin = new ImprovedNoise(),
@@ -115,7 +115,7 @@ function generateHeight(width, height) {
     return data;
 }
 
-function generateTexture(data, width, height) {
+function generateTexture(data: Uint8Array, width: number, height: number) {
     // bake lighting into texture
 
     let context, image, imageData, shade;
@@ -129,7 +129,7 @@ function generateTexture(data, width, height) {
     canvas.width = width;
     canvas.height = height;
 
-    context = canvas.getContext('2d');
+    context = canvas.getContext('2d')!;
     context.fillStyle = '#000';
     context.fillRect(0, 0, width, height);
 
@@ -157,7 +157,7 @@ function generateTexture(data, width, height) {
     canvasScaled.width = width * 4;
     canvasScaled.height = height * 4;
 
-    context = canvasScaled.getContext('2d');
+    context = canvasScaled.getContext('2d')!;
     context.scale(4, 4);
     context.drawImage(canvas, 0, 0);
 
@@ -190,7 +190,7 @@ function render() {
     renderer.render(scene, camera);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
     pointer.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
     raycaster.setFromCamera(pointer, camera);
@@ -201,7 +201,7 @@ function onPointerMove(event) {
     // Toggle rotation bool for meshes that we clicked
     if (intersects.length > 0) {
         helper.position.set(0, 0, 0);
-        helper.lookAt(intersects[0].face.normal);
+        helper.lookAt(intersects[0].face!.normal);
 
         helper.position.copy(intersects[0].point);
     }
diff --git a/examples-testing/examples/webgl_geometry_text.ts b/examples-testing/examples/webgl_geometry_text.ts
index 51a639b..90087e4 100644
--- a/examples-testing/examples/webgl_geometry_text.ts
+++ b/examples-testing/examples/webgl_geometry_text.ts
@@ -1,23 +1,23 @@
 import * as THREE from 'three';
 
-import { FontLoader } from 'three/addons/loaders/FontLoader.js';
+import { Font, FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 THREE.Cache.enabled = true;
 
-let container;
+let container: HTMLDivElement;
 
-let camera, cameraTarget, scene, renderer;
+let camera: THREE.PerspectiveCamera, cameraTarget: THREE.Vector3, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let group, textMesh1, textMesh2, textGeo, materials;
+let group: THREE.Group, textMesh1: THREE.Mesh, textMesh2: THREE.Mesh, textGeo, materials: THREE.MeshPhongMaterial[];
 
 let firstLetter = true;
 
 let text = 'three.js',
     bevelEnabled = true,
-    font = undefined,
+    font: Font | undefined = undefined,
     fontName = 'optimer', // helvetiker, optimer, gentilis, droid sans, droid serif
     fontWeight = 'bold'; // normal bold
 
@@ -43,11 +43,11 @@ const weightMap = {
     bold: 1,
 };
 
-const reverseFontMap = [];
-const reverseWeightMap = [];
+const reverseFontMap: string[] = [];
+const reverseWeightMap: string[] = [];
 
-for (const i in fontMap) reverseFontMap[fontMap[i]] = i;
-for (const i in weightMap) reverseWeightMap[weightMap[i]] = i;
+for (const i in fontMap) reverseFontMap[fontMap[i as keyof typeof fontMap]] = i;
+for (const i in weightMap) reverseWeightMap[weightMap[i as keyof typeof weightMap]] = i;
 
 let targetRotation = 0;
 let targetRotationOnPointerDown = 0;
@@ -180,7 +180,7 @@ function onWindowResize() {
 
 //
 
-function onDocumentKeyDown(event) {
+function onDocumentKeyDown(event: KeyboardEvent) {
     if (firstLetter) {
         firstLetter = false;
         text = '';
@@ -200,7 +200,7 @@ function onDocumentKeyDown(event) {
     }
 }
 
-function onDocumentKeyPress(event) {
+function onDocumentKeyPress(event: KeyboardEvent) {
     const keyCode = event.which;
 
     // backspace
@@ -226,7 +226,7 @@ function loadFont() {
 
 function createText() {
     textGeo = new TextGeometry(text, {
-        font: font,
+        font: font!,
 
         size: size,
         height: height,
@@ -239,7 +239,7 @@ function createText() {
 
     textGeo.computeBoundingBox();
 
-    const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
+    const centerOffset = -0.5 * (textGeo.boundingBox!.max.x - textGeo.boundingBox!.min.x);
 
     textMesh1 = new THREE.Mesh(textGeo, materials);
 
@@ -275,7 +275,7 @@ function refreshText() {
     createText();
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerXOnPointerDown = event.clientX - windowHalfX;
@@ -285,7 +285,7 @@ function onPointerDown(event) {
     document.addEventListener('pointerup', onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerX = event.clientX - windowHalfX;
@@ -293,7 +293,7 @@ function onPointerMove(event) {
     targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
 }
 
-function onPointerUp() {
+function onPointerUp(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     document.removeEventListener('pointermove', onPointerMove);
diff --git a/examples-testing/examples/webgl_geometry_text_shapes.ts b/examples-testing/examples/webgl_geometry_text_shapes.ts
index adfb600..141b618 100644
--- a/examples-testing/examples/webgl_geometry_text_shapes.ts
+++ b/examples-testing/examples/webgl_geometry_text_shapes.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { FontLoader } from 'three/addons/loaders/FontLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -32,13 +32,13 @@ function init() {
 
         const message = '   Three.js\nSimple text.';
 
-        const shapes = font.generateShapes(message, 100);
+        const shapes: THREE.Path[] = font.generateShapes(message, 100);
 
-        const geometry = new THREE.ShapeGeometry(shapes);
+        const geometry = new THREE.ShapeGeometry(shapes as THREE.Shape[]);
 
         geometry.computeBoundingBox();
 
-        const xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
+        const xMid = -0.5 * (geometry.boundingBox!.max.x - geometry.boundingBox!.min.x);
 
         geometry.translate(xMid, 0, 0);
 
@@ -50,10 +50,10 @@ function init() {
 
         // make line shape ( N.B. edge view remains visible )
 
-        const holeShapes = [];
+        const holeShapes: THREE.Path[] = [];
 
         for (let i = 0; i < shapes.length; i++) {
-            const shape = shapes[i];
+            const shape = shapes[i] as THREE.Shape;
 
             if (shape.holes && shape.holes.length > 0) {
                 for (let j = 0; j < shape.holes.length; j++) {
diff --git a/examples-testing/examples/webgl_geometry_text_stroke.ts b/examples-testing/examples/webgl_geometry_text_stroke.ts
index 9a19832..e47d7b6 100644
--- a/examples-testing/examples/webgl_geometry_text_stroke.ts
+++ b/examples-testing/examples/webgl_geometry_text_stroke.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
 import { FontLoader } from 'three/addons/loaders/FontLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -33,13 +33,13 @@ function init() {
 
         const message = '   Three.js\nStroke text.';
 
-        const shapes = font.generateShapes(message, 100);
+        const shapes: THREE.Path[] = font.generateShapes(message, 100);
 
-        const geometry = new THREE.ShapeGeometry(shapes);
+        const geometry = new THREE.ShapeGeometry(shapes as THREE.Shape[]);
 
         geometry.computeBoundingBox();
 
-        const xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
+        const xMid = -0.5 * (geometry.boundingBox!.max.x - geometry.boundingBox!.min.x);
 
         geometry.translate(xMid, 0, 0);
 
@@ -51,10 +51,10 @@ function init() {
 
         // make line shape ( N.B. edge view remains visible )
 
-        const holeShapes = [];
+        const holeShapes: THREE.Path[] = [];
 
         for (let i = 0; i < shapes.length; i++) {
-            const shape = shapes[i];
+            const shape = shapes[i] as THREE.Shape;
 
             if (shape.holes && shape.holes.length > 0) {
                 for (let j = 0; j < shape.holes.length; j++) {
diff --git a/examples-testing/examples/webgl_gpgpu_birds.ts b/examples-testing/examples/webgl_gpgpu_birds.ts
index ecf53eb..4f865bd 100644
--- a/examples-testing/examples/webgl_gpgpu_birds.ts
+++ b/examples-testing/examples/webgl_gpgpu_birds.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
+import { GPUComputationRenderer, Variable } from 'three/addons/misc/GPUComputationRenderer.js';
 
 /* TEXTURE WIDTH FOR SIMULATION */
 const WIDTH = 32;
@@ -33,9 +33,9 @@ class BirdGeometry extends THREE.BufferGeometry {
 
         let v = 0;
 
-        function verts_push() {
-            for (let i = 0; i < arguments.length; i++) {
-                vertices.array[v++] = arguments[i];
+        function verts_push(...args: number[]) {
+            for (let i = 0; i < args.length; i++) {
+                vertices.array[v++] = args[i];
             }
         }
 
@@ -77,8 +77,8 @@ class BirdGeometry extends THREE.BufferGeometry {
 
 //
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 let mouseX = 0,
     mouseY = 0;
 
@@ -90,12 +90,12 @@ const BOUNDS = 800,
 
 let last = performance.now();
 
-let gpuCompute;
-let velocityVariable;
-let positionVariable;
-let positionUniforms;
-let velocityUniforms;
-let birdUniforms;
+let gpuCompute: GPUComputationRenderer;
+let velocityVariable: Variable;
+let positionVariable: Variable;
+let positionUniforms: Record<string, THREE.IUniform>;
+let velocityUniforms: Record<string, THREE.IUniform>;
+let birdUniforms: Record<string, THREE.IUniform>;
 
 init();
 animate();
@@ -168,12 +168,12 @@ function initComputeRenderer() {
 
     velocityVariable = gpuCompute.addVariable(
         'textureVelocity',
-        document.getElementById('fragmentShaderVelocity').textContent,
+        document.getElementById('fragmentShaderVelocity')!.textContent!,
         dtVelocity,
     );
     positionVariable = gpuCompute.addVariable(
         'texturePosition',
-        document.getElementById('fragmentShaderPosition').textContent,
+        document.getElementById('fragmentShaderPosition')!.textContent!,
         dtPosition,
     );
 
@@ -222,8 +222,8 @@ function initBirds() {
     // THREE.ShaderMaterial
     const material = new THREE.ShaderMaterial({
         uniforms: birdUniforms,
-        vertexShader: document.getElementById('birdVS').textContent,
-        fragmentShader: document.getElementById('birdFS').textContent,
+        vertexShader: document.getElementById('birdVS')!.textContent!,
+        fragmentShader: document.getElementById('birdFS')!.textContent!,
         side: THREE.DoubleSide,
     });
 
@@ -235,7 +235,7 @@ function initBirds() {
     scene.add(birdMesh);
 }
 
-function fillPositionTexture(texture) {
+function fillPositionTexture(texture: THREE.DataTexture) {
     const theArray = texture.image.data;
 
     for (let k = 0, kl = theArray.length; k < kl; k += 4) {
@@ -250,7 +250,7 @@ function fillPositionTexture(texture) {
     }
 }
 
-function fillVelocityTexture(texture) {
+function fillVelocityTexture(texture: THREE.DataTexture) {
     const theArray = texture.image.data;
 
     for (let k = 0, kl = theArray.length; k < kl; k += 4) {
@@ -275,7 +275,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
diff --git a/examples-testing/examples/webgl_gpgpu_birds_gltf.ts b/examples-testing/examples/webgl_gpgpu_birds_gltf.ts
index 58aee4f..d66c36e 100644
--- a/examples-testing/examples/webgl_gpgpu_birds_gltf.ts
+++ b/examples-testing/examples/webgl_gpgpu_birds_gltf.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
-import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
+import { GPUComputationRenderer, Variable } from 'three/addons/misc/GPUComputationRenderer.js';
 
 /* TEXTURE WIDTH FOR SIMULATION */
 const WIDTH = 64;
@@ -10,16 +10,20 @@ const BIRDS = WIDTH * WIDTH;
 
 /* BAKE ANIMATION INTO TEXTURE and CREATE GEOMETRY FROM BASE MODEL */
 const BirdGeometry = new THREE.BufferGeometry();
-let textureAnimation, durationAnimation, birdMesh, materialShader, indicesPerBird;
+let textureAnimation: THREE.DataTexture,
+    durationAnimation: number,
+    birdMesh: THREE.Mesh,
+    materialShader: THREE.WebGLProgramParametersWithUniforms,
+    indicesPerBird: number;
 
-function nextPowerOf2(n) {
+function nextPowerOf2(n: number) {
     return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)));
 }
 
-Math.lerp = function (value1, value2, amount) {
+function lerp(value1: number, value2: number, amount: number) {
     amount = Math.max(Math.min(amount, 1), 0);
     return value1 + (value2 - value1) * amount;
-};
+}
 
 const gltfs = ['models/gltf/Parrot.glb', 'models/gltf/Flamingo.glb'];
 const colors = [0xccffff, 0xffdeff];
@@ -28,11 +32,11 @@ const selectModel = Math.floor(Math.random() * gltfs.length);
 new GLTFLoader().load(gltfs[selectModel], function (gltf) {
     const animations = gltf.animations;
     durationAnimation = Math.round(animations[0].duration * 60);
-    const birdGeo = gltf.scene.children[0].geometry;
+    const birdGeo = (gltf.scene.children[0] as THREE.Mesh).geometry;
     const morphAttributes = birdGeo.morphAttributes.position;
     const tHeight = nextPowerOf2(durationAnimation);
     const tWidth = nextPowerOf2(birdGeo.getAttribute('position').count);
-    indicesPerBird = birdGeo.index.count;
+    indicesPerBird = birdGeo.index!.count;
     const tData = new Float32Array(4 * tWidth * tHeight);
 
     for (let i = 0; i < tWidth; i++) {
@@ -50,17 +54,17 @@ new GLTFLoader().load(gltfs[selectModel], function (gltf) {
                 d0 = morphAttributes[curMorph].array[i * 3];
                 d1 = morphAttributes[nextMorph].array[i * 3];
 
-                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4] = Math.lerp(d0, d1, lerpAmount);
+                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4] = lerp(d0, d1, lerpAmount);
 
                 d0 = morphAttributes[curMorph].array[i * 3 + 1];
                 d1 = morphAttributes[nextMorph].array[i * 3 + 1];
 
-                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4 + 1] = Math.lerp(d0, d1, lerpAmount);
+                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4 + 1] = lerp(d0, d1, lerpAmount);
 
                 d0 = morphAttributes[curMorph].array[i * 3 + 2];
                 d1 = morphAttributes[nextMorph].array[i * 3 + 2];
 
-                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4 + 2] = Math.lerp(d0, d1, lerpAmount);
+                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4 + 2] = lerp(d0, d1, lerpAmount);
 
                 tData[offset + i * 4 + 3] = 1;
             }
@@ -94,9 +98,9 @@ new GLTFLoader().load(gltfs[selectModel], function (gltf) {
         seeds.push(bird, r, Math.random(), Math.random());
     }
 
-    for (let i = 0; i < birdGeo.index.array.length * BIRDS; i++) {
-        const offset = Math.floor(i / birdGeo.index.array.length) * birdGeo.getAttribute('position').count;
-        indices.push(birdGeo.index.array[i % birdGeo.index.array.length] + offset);
+    for (let i = 0; i < birdGeo.index!.array.length * BIRDS; i++) {
+        const offset = Math.floor(i / birdGeo.index!.array.length) * birdGeo.getAttribute('position').count;
+        indices.push(birdGeo.index!.array[i % birdGeo.index!.array.length] + offset);
     }
 
     BirdGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
@@ -111,8 +115,8 @@ new GLTFLoader().load(gltfs[selectModel], function (gltf) {
     animate();
 });
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 let mouseX = 0,
     mouseY = 0;
 
@@ -124,11 +128,20 @@ const BOUNDS = 800,
 
 let last = performance.now();
 
-let gpuCompute;
-let velocityVariable;
-let positionVariable;
-let positionUniforms;
-let velocityUniforms;
+let gpuCompute: GPUComputationRenderer;
+let velocityVariable: Variable;
+let positionVariable: Variable;
+let positionUniforms: Record<string, THREE.IUniform>;
+let velocityUniforms: Record<string, THREE.IUniform>;
+
+interface EffectController {
+    separation: number;
+    alignment: number;
+    cohesion: number;
+    freedom: number;
+    size: number;
+    count: number;
+}
 
 function init() {
     container = document.createElement('div');
@@ -216,12 +229,12 @@ function initComputeRenderer() {
 
     velocityVariable = gpuCompute.addVariable(
         'textureVelocity',
-        document.getElementById('fragmentShaderVelocity').textContent,
+        document.getElementById('fragmentShaderVelocity')!.textContent!,
         dtVelocity,
     );
     positionVariable = gpuCompute.addVariable(
         'texturePosition',
-        document.getElementById('fragmentShaderPosition').textContent,
+        document.getElementById('fragmentShaderPosition')!.textContent!,
         dtPosition,
     );
 
@@ -255,7 +268,7 @@ function initComputeRenderer() {
     }
 }
 
-function initBirds(effectController) {
+function initBirds(effectController: EffectController) {
     const geometry = BirdGeometry;
 
     const m = new THREE.MeshStandardMaterial({
@@ -335,7 +348,7 @@ function initBirds(effectController) {
     scene.add(birdMesh);
 }
 
-function fillPositionTexture(texture) {
+function fillPositionTexture(texture: THREE.DataTexture) {
     const theArray = texture.image.data;
 
     for (let k = 0, kl = theArray.length; k < kl; k += 4) {
@@ -350,7 +363,7 @@ function fillPositionTexture(texture) {
     }
 }
 
-function fillVelocityTexture(texture) {
+function fillVelocityTexture(texture: THREE.DataTexture) {
     const theArray = texture.image.data;
 
     for (let k = 0, kl = theArray.length; k < kl; k += 4) {
@@ -375,7 +388,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
diff --git a/examples-testing/examples/webgl_gpgpu_protoplanet.ts b/examples-testing/examples/webgl_gpgpu_protoplanet.ts
index b1a7e02..35fb039 100644
--- a/examples-testing/examples/webgl_gpgpu_protoplanet.ts
+++ b/examples-testing/examples/webgl_gpgpu_protoplanet.ts
@@ -4,22 +4,32 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
+import { GPUComputationRenderer, Variable } from 'three/addons/misc/GPUComputationRenderer.js';
 
 // Texture width for simulation (each texel is a debris particle)
 const WIDTH = 64;
 
-let container, stats;
-let camera, scene, renderer, geometry;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, geometry;
 
 const PARTICLES = WIDTH * WIDTH;
 
-let gpuCompute;
-let velocityVariable;
-let positionVariable;
-let velocityUniforms;
-let particleUniforms;
-let effectController;
+let gpuCompute: GPUComputationRenderer;
+let velocityVariable: Variable;
+let positionVariable: Variable;
+let velocityUniforms: Record<string, THREE.IUniform>;
+let particleUniforms: Record<string, THREE.IUniform>;
+let effectController: {
+    gravityConstant: number;
+    density: number;
+    radius: number;
+    height: number;
+    exponent: number;
+    maxMass: number;
+    velocity: number;
+    velocityExponent: number;
+    randVelocity: number;
+};
 
 init();
 animate();
@@ -86,12 +96,12 @@ function initComputeRenderer() {
 
     velocityVariable = gpuCompute.addVariable(
         'textureVelocity',
-        document.getElementById('computeShaderVelocity').textContent,
+        document.getElementById('computeShaderVelocity')!.textContent!,
         dtVelocity,
     );
     positionVariable = gpuCompute.addVariable(
         'texturePosition',
-        document.getElementById('computeShaderPosition').textContent,
+        document.getElementById('computeShaderPosition')!.textContent!,
         dtPosition,
     );
 
@@ -157,8 +167,8 @@ function initProtoplanets() {
     // THREE.ShaderMaterial
     const material = new THREE.ShaderMaterial({
         uniforms: particleUniforms,
-        vertexShader: document.getElementById('particleVertexShader').textContent,
-        fragmentShader: document.getElementById('particleFragmentShader').textContent,
+        vertexShader: document.getElementById('particleVertexShader')!.textContent!,
+        fragmentShader: document.getElementById('particleFragmentShader')!.textContent!,
     });
 
     material.extensions.drawBuffers = true;
@@ -170,7 +180,7 @@ function initProtoplanets() {
     scene.add(particles);
 }
 
-function fillTextures(texturePosition, textureVelocity) {
+function fillTextures(texturePosition: THREE.DataTexture, textureVelocity: THREE.DataTexture) {
     const posArray = texturePosition.image.data;
     const velArray = textureVelocity.image.data;
 
@@ -267,7 +277,7 @@ function initGUI() {
     folder2.open();
 }
 
-function getCameraConstant(camera) {
+function getCameraConstant(camera: THREE.PerspectiveCamera) {
     return window.innerHeight / (Math.tan(THREE.MathUtils.DEG2RAD * 0.5 * camera.fov) / camera.zoom);
 }
 
diff --git a/examples-testing/examples/webgl_gpgpu_water.ts b/examples-testing/examples/webgl_gpgpu_water.ts
index f9cce64..66cf7a7 100644
--- a/examples-testing/examples/webgl_gpgpu_water.ts
+++ b/examples-testing/examples/webgl_gpgpu_water.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
+import { GPUComputationRenderer, Variable } from 'three/addons/misc/GPUComputationRenderer.js';
 import { SimplexNoise } from 'three/addons/math/SimplexNoise.js';
 
 // Texture width for simulation
@@ -13,25 +13,25 @@ const WIDTH = 128;
 const BOUNDS = 512;
 const BOUNDS_HALF = BOUNDS * 0.5;
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 let mouseMoved = false;
 const mouseCoords = new THREE.Vector2();
 const raycaster = new THREE.Raycaster();
 
-let waterMesh;
-let meshRay;
-let gpuCompute;
-let heightmapVariable;
-let waterUniforms;
-let smoothShader;
-let readWaterLevelShader;
-let readWaterLevelRenderTarget;
-let readWaterLevelImage;
+let waterMesh: THREE.Mesh<THREE.PlaneGeometry, THREE.ShaderMaterial>;
+let meshRay: THREE.Mesh;
+let gpuCompute: GPUComputationRenderer;
+let heightmapVariable: Variable;
+let waterUniforms: Record<string, THREE.IUniform>;
+let smoothShader: THREE.ShaderMaterial;
+let readWaterLevelShader: THREE.ShaderMaterial;
+let readWaterLevelRenderTarget: THREE.WebGLRenderTarget;
+let readWaterLevelImage: Uint8Array;
 const waterNormal = new THREE.Vector3();
 
 const NUM_SPHERES = 5;
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 let spheresEnabled = true;
 
 const simplex = new SimplexNoise();
@@ -127,7 +127,7 @@ function initWater() {
                 heightmap: { value: null },
             },
         ]),
-        vertexShader: document.getElementById('waterVertexShader').textContent,
+        vertexShader: document.getElementById('waterVertexShader')!.textContent!,
         fragmentShader: THREE.ShaderChunk['meshphong_frag'],
     });
 
@@ -175,7 +175,7 @@ function initWater() {
 
     heightmapVariable = gpuCompute.addVariable(
         'heightmap',
-        document.getElementById('heightmapFragmentShader').textContent,
+        document.getElementById('heightmapFragmentShader')!.textContent!,
         heightmap0,
     );
 
@@ -193,13 +193,13 @@ function initWater() {
     }
 
     // Create compute shader to smooth the water surface and velocity
-    smoothShader = gpuCompute.createShaderMaterial(document.getElementById('smoothFragmentShader').textContent, {
+    smoothShader = gpuCompute.createShaderMaterial(document.getElementById('smoothFragmentShader')!.textContent!, {
         smoothTexture: { value: null },
     });
 
     // Create compute shader to read water level
     readWaterLevelShader = gpuCompute.createShaderMaterial(
-        document.getElementById('readWaterLevelFragmentShader').textContent,
+        document.getElementById('readWaterLevelFragmentShader')!.textContent!,
         {
             point1: { value: new THREE.Vector2() },
             levelTexture: { value: null },
@@ -222,10 +222,10 @@ function initWater() {
     });
 }
 
-function fillTexture(texture) {
+function fillTexture(texture: THREE.DataTexture) {
     const waterMaxHeight = 10;
 
-    function noise(x, y) {
+    function noise(x: number, y: number) {
         let multR = waterMaxHeight;
         let mult = 0.025;
         let r = 0;
@@ -350,12 +350,12 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function setMouseCoords(x, y) {
+function setMouseCoords(x: number, y: number) {
     mouseCoords.set((x / renderer.domElement.clientWidth) * 2 - 1, -(y / renderer.domElement.clientHeight) * 2 + 1);
     mouseMoved = true;
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     setMouseCoords(event.clientX, event.clientY);
diff --git a/examples-testing/examples/webgl_helpers.ts b/examples-testing/examples/webgl_helpers.ts
index 5d75326..65c573d 100644
--- a/examples-testing/examples/webgl_helpers.ts
+++ b/examples-testing/examples/webgl_helpers.ts
@@ -5,10 +5,10 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { VertexNormalsHelper } from 'three/addons/helpers/VertexNormalsHelper.js';
 import { VertexTangentsHelper } from 'three/addons/helpers/VertexTangentsHelper.js';
 
-let scene, renderer;
-let camera, light;
-let vnh;
-let vth;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let camera: THREE.PerspectiveCamera, light: THREE.PointLight;
+let vnh: VertexNormalsHelper;
+let vth: VertexTangentsHelper;
 
 init();
 animate();
@@ -44,7 +44,7 @@ function init() {
 
     const loader = new GLTFLoader();
     loader.load('models/gltf/LeePerrySmith/LeePerrySmith.glb', function (gltf) {
-        const mesh = gltf.scene.children[0];
+        const mesh = gltf.scene.children[0] as THREE.Mesh;
 
         mesh.geometry.computeTangents(); // generates bad data due to degenerate UVs
 
@@ -66,7 +66,7 @@ function init() {
         scene.add(new THREE.BoxHelper(mesh));
 
         const wireframe = new THREE.WireframeGeometry(mesh.geometry);
-        let line = new THREE.LineSegments(wireframe);
+        let line: THREE.LineSegments<THREE.BufferGeometry, THREE.LineBasicMaterial> = new THREE.LineSegments(wireframe);
         line.material.depthTest = false;
         line.material.opacity = 0.25;
         line.material.transparent = true;
diff --git a/examples-testing/examples/webgl_instancing_dynamic.ts b/examples-testing/examples/webgl_instancing_dynamic.ts
index 8c94528..b0e453e 100644
--- a/examples-testing/examples/webgl_instancing_dynamic.ts
+++ b/examples-testing/examples/webgl_instancing_dynamic.ts
@@ -3,9 +3,9 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
-let mesh;
+let mesh: THREE.InstancedMesh;
 const amount = parseInt(window.location.search.slice(1)) || 10;
 const count = Math.pow(amount, 3);
 const dummy = new THREE.Object3D();
diff --git a/examples-testing/examples/webgl_instancing_morph.ts b/examples-testing/examples/webgl_instancing_morph.ts
index 7a4245c..6eecf7c 100644
--- a/examples-testing/examples/webgl_instancing_morph.ts
+++ b/examples-testing/examples/webgl_instancing_morph.ts
@@ -4,7 +4,13 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats, mesh, mixer, dummy;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    mesh: THREE.InstancedMesh,
+    mixer: THREE.AnimationMixer,
+    dummy: THREE.Mesh;
 
 const offset = 5000;
 
@@ -64,7 +70,7 @@ function init() {
     const loader = new GLTFLoader();
 
     loader.load('models/gltf/Horse.glb', function (glb) {
-        dummy = glb.scene.children[0];
+        dummy = glb.scene.children[0] as THREE.Mesh;
 
         mesh = new THREE.InstancedMesh(dummy.geometry, dummy.material, 1024);
 
@@ -142,7 +148,7 @@ function render() {
             mesh.setMorphAt(i, dummy);
         }
 
-        mesh.morphTexture.needsUpdate = true;
+        mesh.morphTexture!.needsUpdate = true;
     }
 
     renderer.render(scene, camera);
diff --git a/examples-testing/examples/webgl_instancing_performance.ts b/examples-testing/examples/webgl_instancing_performance.ts
index 62ed935..b34abd6 100644
--- a/examples-testing/examples/webgl_instancing_performance.ts
+++ b/examples-testing/examples/webgl_instancing_performance.ts
@@ -6,8 +6,12 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let container, stats, gui, guiStatsEl;
-let camera, controls, scene, renderer, material;
+let container: HTMLElement, stats: Stats, gui: GUI, guiStatsEl: HTMLDivElement;
+let camera: THREE.PerspectiveCamera,
+    controls: OrbitControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    material: THREE.MeshNormalMaterial;
 
 // gui
 
@@ -31,15 +35,15 @@ animate();
 //
 
 function clean() {
-    const meshes = [];
+    const meshes: THREE.Mesh[] = [];
 
     scene.traverse(function (object) {
-        if (object.isMesh) meshes.push(object);
+        if ((object as THREE.Mesh).isMesh) meshes.push(object as THREE.Mesh);
     });
 
     for (let i = 0; i < meshes.length; i++) {
         const mesh = meshes[i];
-        mesh.material.dispose();
+        (mesh.material as THREE.Material).dispose();
         mesh.geometry.dispose();
 
         scene.remove(mesh);
@@ -51,7 +55,7 @@ const randomizeMatrix = (function () {
     const quaternion = new THREE.Quaternion();
     const scale = new THREE.Vector3();
 
-    return function (matrix) {
+    return function (matrix: THREE.Matrix4) {
         position.x = Math.random() * 40 - 20;
         position.y = Math.random() * 40 - 20;
         position.z = Math.random() * 40 - 20;
@@ -93,7 +97,7 @@ function initMesh() {
     });
 }
 
-function makeInstanced(geometry) {
+function makeInstanced(geometry: THREE.BufferGeometry) {
     const matrix = new THREE.Matrix4();
     const mesh = new THREE.InstancedMesh(geometry, material, api.count);
 
@@ -114,7 +118,7 @@ function makeInstanced(geometry) {
     ].join('<br/>');
 }
 
-function makeMerged(geometry) {
+function makeMerged(geometry: THREE.BufferGeometry) {
     const geometries = [];
     const matrix = new THREE.Matrix4();
 
@@ -139,7 +143,7 @@ function makeMerged(geometry) {
     ].join('<br/>');
 }
 
-function makeNaive(geometry) {
+function makeNaive(geometry: THREE.BufferGeometry) {
     const matrix = new THREE.Matrix4();
 
     for (let i = 0; i < api.count; i++) {
@@ -175,7 +179,7 @@ function init() {
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(width, height);
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     // scene
@@ -241,7 +245,7 @@ function render() {
 
 //
 
-function getGeometryByteLength(geometry) {
+function getGeometryByteLength(geometry: THREE.BufferGeometry) {
     let total = 0;
 
     if (geometry.index) total += geometry.index.array.byteLength;
@@ -254,7 +258,7 @@ function getGeometryByteLength(geometry) {
 }
 
 // Source: https://stackoverflow.com/a/18650828/1314762
-function formatBytes(bytes, decimals) {
+function formatBytes(bytes: number, decimals: number) {
     if (bytes === 0) return '0 bytes';
 
     const k = 1024;
diff --git a/examples-testing/examples/webgl_instancing_raycast.ts b/examples-testing/examples/webgl_instancing_raycast.ts
index 71f0d6e..ba3ebb0 100644
--- a/examples-testing/examples/webgl_instancing_raycast.ts
+++ b/examples-testing/examples/webgl_instancing_raycast.ts
@@ -4,9 +4,13 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, controls, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    controls: OrbitControls,
+    stats: Stats;
 
-let mesh;
+let mesh: THREE.InstancedMesh;
 const amount = parseInt(window.location.search.slice(1)) || 10;
 const count = Math.pow(amount, 3);
 
@@ -84,7 +88,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onMouseMove(event) {
+function onMouseMove(event: MouseEvent) {
     event.preventDefault();
 
     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
@@ -101,14 +105,14 @@ function animate() {
     const intersection = raycaster.intersectObject(mesh);
 
     if (intersection.length > 0) {
-        const instanceId = intersection[0].instanceId;
+        const instanceId = intersection[0].instanceId!;
 
         mesh.getColorAt(instanceId, color);
 
         if (color.equals(white)) {
             mesh.setColorAt(instanceId, color.setHex(Math.random() * 0xffffff));
 
-            mesh.instanceColor.needsUpdate = true;
+            mesh.instanceColor!.needsUpdate = true;
         }
     }
 
diff --git a/examples-testing/examples/webgl_instancing_scatter.ts b/examples-testing/examples/webgl_instancing_scatter.ts
index af7f39d..574f5c7 100644
--- a/examples-testing/examples/webgl_instancing_scatter.ts
+++ b/examples-testing/examples/webgl_instancing_scatter.ts
@@ -5,7 +5,7 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 const api = {
     count: 2000,
@@ -15,11 +15,11 @@ const api = {
     backgroundColor: 0xe39469,
 };
 
-let stemMesh, blossomMesh;
-let stemGeometry, blossomGeometry;
-let stemMaterial, blossomMaterial;
+let stemMesh: THREE.InstancedMesh, blossomMesh: THREE.InstancedMesh;
+let stemGeometry: THREE.BufferGeometry, blossomGeometry: THREE.BufferGeometry;
+let stemMaterial: THREE.Material | THREE.Material[], blossomMaterial: THREE.Material | THREE.Material[];
 
-let sampler;
+let sampler: MeshSurfaceSampler;
 const count = api.count;
 const ages = new Float32Array(count);
 const scales = new Float32Array(count);
@@ -35,21 +35,21 @@ const surfaceMaterial = new THREE.MeshLambertMaterial({ color: api.surfaceColor,
 const surface = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
 
 // Source: https://gist.github.com/gre/1650294
-const easeOutCubic = function (t) {
+const easeOutCubic = function (t: number) {
     return --t * t * t + 1;
 };
 
 // Scaling curve causes particles to grow quickly, ease gradually into full scale, then
 // disappear quickly. More of the particle's lifetime is spent around full scale.
-const scaleCurve = function (t) {
+const scaleCurve = function (t: number) {
     return Math.abs(easeOutCubic((t > 0.5 ? 1 - t : t) * 2));
 };
 
 const loader = new GLTFLoader();
 
 loader.load('./models/gltf/Flower/Flower.glb', function (gltf) {
-    const _stemMesh = gltf.scene.getObjectByName('Stem');
-    const _blossomMesh = gltf.scene.getObjectByName('Blossom');
+    const _stemMesh = gltf.scene.getObjectByName('Stem') as THREE.Mesh;
+    const _blossomMesh = gltf.scene.getObjectByName('Blossom') as THREE.Mesh;
 
     stemGeometry = _stemMesh.geometry.clone();
     blossomGeometry = _blossomMesh.geometry.clone();
@@ -179,7 +179,7 @@ function resample() {
     blossomMesh.instanceMatrix.needsUpdate = true;
 }
 
-function resampleParticle(i) {
+function resampleParticle(i: number) {
     sampler.sample(_position, _normal);
     _normal.add(_position);
 
@@ -192,7 +192,7 @@ function resampleParticle(i) {
     blossomMesh.setMatrixAt(i, dummy.matrix);
 }
 
-function updateParticle(i) {
+function updateParticle(i: number) {
     // Update lifecycle.
 
     ages[i] += 0.005;
diff --git a/examples-testing/examples/webgl_interactive_buffergeometry.ts b/examples-testing/examples/webgl_interactive_buffergeometry.ts
index fafa7a1..98a202c 100644
--- a/examples-testing/examples/webgl_interactive_buffergeometry.ts
+++ b/examples-testing/examples/webgl_interactive_buffergeometry.ts
@@ -2,19 +2,19 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let raycaster, pointer;
+let raycaster: THREE.Raycaster, pointer: THREE.Vector2;
 
-let mesh, line;
+let mesh: THREE.Mesh, line: THREE.Line;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -147,7 +147,7 @@ function init() {
 
     geometry.computeBoundingSphere();
 
-    let material = new THREE.MeshPhongMaterial({
+    let material: THREE.Material = new THREE.MeshPhongMaterial({
         color: 0xaaaaaa,
         specular: 0xffffff,
         shininess: 250,
@@ -197,7 +197,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -223,10 +223,10 @@ function render() {
 
     if (intersects.length > 0) {
         const intersect = intersects[0];
-        const face = intersect.face;
+        const face = intersect.face!;
 
-        const linePosition = line.geometry.attributes.position;
-        const meshPosition = mesh.geometry.attributes.position;
+        const linePosition = line.geometry.attributes.position as THREE.BufferAttribute;
+        const meshPosition = mesh.geometry.attributes.position as THREE.BufferAttribute;
 
         linePosition.copyAt(0, meshPosition, face.a);
         linePosition.copyAt(1, meshPosition, face.b);
diff --git a/examples-testing/examples/webgl_interactive_cubes.ts b/examples-testing/examples/webgl_interactive_cubes.ts
index c082289..a126b56 100644
--- a/examples-testing/examples/webgl_interactive_cubes.ts
+++ b/examples-testing/examples/webgl_interactive_cubes.ts
@@ -2,10 +2,10 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let stats;
-let camera, scene, raycaster, renderer;
+let stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, raycaster: THREE.Raycaster, renderer: THREE.WebGLRenderer;
 
-let INTERSECTED;
+let INTERSECTED: (THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial> & { currentHex?: number }) | null;
 let theta = 0;
 
 const pointer = new THREE.Vector2();
@@ -68,7 +68,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: MouseEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -100,14 +100,14 @@ function render() {
 
     if (intersects.length > 0) {
         if (INTERSECTED != intersects[0].object) {
-            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
+            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex!);
 
-            INTERSECTED = intersects[0].object;
+            INTERSECTED = intersects[0].object as THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial>;
             INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
             INTERSECTED.material.emissive.setHex(0xff0000);
         }
     } else {
-        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
+        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex!);
 
         INTERSECTED = null;
     }
diff --git a/examples-testing/examples/webgl_interactive_cubes_gpu.ts b/examples-testing/examples/webgl_interactive_cubes_gpu.ts
index f80c89f..59c40eb 100644
--- a/examples-testing/examples/webgl_interactive_cubes_gpu.ts
+++ b/examples-testing/examples/webgl_interactive_cubes_gpu.ts
@@ -5,12 +5,12 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let container, stats;
-let camera, controls, scene, renderer;
-let pickingTexture, pickingScene;
-let highlightBox;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, controls: TrackballControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let pickingTexture: THREE.WebGLRenderTarget, pickingScene: THREE.Scene;
+let highlightBox: THREE.Mesh;
 
-const pickingData = [];
+const pickingData: { position: THREE.Vector3; rotation: THREE.Euler; scale: THREE.Vector3 }[] = [];
 
 const pointer = new THREE.Vector2();
 const offset = new THREE.Vector3(10, 10, 10);
@@ -20,7 +20,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 1000;
@@ -74,7 +74,7 @@ function init() {
 					`,
     });
 
-    function applyId(geometry, id) {
+    function applyId(geometry: THREE.BoxGeometry, id: number) {
         const position = geometry.attributes.position;
         const array = new Int16Array(position.count);
         array.fill(id);
@@ -84,7 +84,7 @@ function init() {
         geometry.setAttribute('id', bufferAttribute);
     }
 
-    function applyVertexColors(geometry, color) {
+    function applyVertexColors(geometry: THREE.BoxGeometry, color: THREE.Color) {
         const position = geometry.attributes.position;
         const colors = [];
 
@@ -166,7 +166,7 @@ function init() {
 
 //
 
-function onPointerMove(e) {
+function onPointerMove(e: PointerEvent) {
     pointer.x = e.clientX;
     pointer.y = e.clientY;
 }
diff --git a/examples-testing/examples/webgl_interactive_cubes_ortho.ts b/examples-testing/examples/webgl_interactive_cubes_ortho.ts
index 92396d7..4639221 100644
--- a/examples-testing/examples/webgl_interactive_cubes_ortho.ts
+++ b/examples-testing/examples/webgl_interactive_cubes_ortho.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let stats;
-let camera, scene, raycaster, renderer;
+let stats: Stats;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, raycaster: THREE.Raycaster, renderer: THREE.WebGLRenderer;
 
 let theta = 0;
-let INTERSECTED;
+let INTERSECTED: (THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial> & { currentHex?: number }) | null;
 
 const pointer = new THREE.Vector2();
 const radius = 25;
@@ -83,7 +83,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -115,14 +115,14 @@ function render() {
 
     if (intersects.length > 0) {
         if (INTERSECTED != intersects[0].object) {
-            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
+            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex!);
 
-            INTERSECTED = intersects[0].object;
+            INTERSECTED = intersects[0].object as THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial>;
             INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
             INTERSECTED.material.emissive.setHex(0xff0000);
         }
     } else {
-        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
+        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex!);
 
         INTERSECTED = null;
     }
diff --git a/examples-testing/examples/webgl_interactive_lines.ts b/examples-testing/examples/webgl_interactive_lines.ts
index 69a1916..18bc732 100644
--- a/examples-testing/examples/webgl_interactive_lines.ts
+++ b/examples-testing/examples/webgl_interactive_lines.ts
@@ -2,8 +2,13 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
-let camera, scene, raycaster, renderer, parentTransform, sphereInter;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    raycaster: THREE.Raycaster,
+    renderer: THREE.WebGLRenderer,
+    parentTransform: THREE.Object3D,
+    sphereInter: THREE.Mesh;
 
 const pointer = new THREE.Vector2();
 const radius = 100;
@@ -121,7 +126,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
diff --git a/examples-testing/examples/webgl_interactive_points.ts b/examples-testing/examples/webgl_interactive_points.ts
index 99bad4a..eb62bf3 100644
--- a/examples-testing/examples/webgl_interactive_points.ts
+++ b/examples-testing/examples/webgl_interactive_points.ts
@@ -4,20 +4,20 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let particles;
+let particles: THREE.Points;
 
 const PARTICLE_SIZE = 20;
 
-let raycaster, intersects;
-let pointer, INTERSECTED;
+let raycaster: THREE.Raycaster, intersects;
+let pointer: THREE.Vector2, INTERSECTED: number | null;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
 
@@ -26,7 +26,7 @@ function init() {
 
     //
 
-    let boxGeometry = new THREE.BoxGeometry(200, 200, 200, 16, 16, 16);
+    let boxGeometry: THREE.BufferGeometry = new THREE.BoxGeometry(200, 200, 200, 16, 16, 16);
 
     // if normal and uv attributes are not removed, mergeVertices() can't consolidate indentical vertices with different normal/uv data
 
@@ -39,8 +39,8 @@ function init() {
 
     const positionAttribute = boxGeometry.getAttribute('position');
 
-    const colors = [];
-    const sizes = [];
+    const colors: number[] = [];
+    const sizes: number[] = [];
 
     const color = new THREE.Color();
 
@@ -64,8 +64,8 @@ function init() {
             pointTexture: { value: new THREE.TextureLoader().load('textures/sprites/disc.png') },
             alphaTest: { value: 0.9 },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
     });
 
     //
@@ -96,7 +96,7 @@ function init() {
     document.addEventListener('pointermove', onPointerMove);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -128,9 +128,9 @@ function render() {
 
     if (intersects.length > 0) {
         if (INTERSECTED != intersects[0].index) {
-            attributes.size.array[INTERSECTED] = PARTICLE_SIZE;
+            attributes.size.array[INTERSECTED!] = PARTICLE_SIZE;
 
-            INTERSECTED = intersects[0].index;
+            INTERSECTED = intersects[0].index!;
 
             attributes.size.array[INTERSECTED] = PARTICLE_SIZE * 1.25;
             attributes.size.needsUpdate = true;
diff --git a/examples-testing/examples/webgl_interactive_raycasting_points.ts b/examples-testing/examples/webgl_interactive_raycasting_points.ts
index ac4c0ba..a985151 100644
--- a/examples-testing/examples/webgl_interactive_raycasting_points.ts
+++ b/examples-testing/examples/webgl_interactive_raycasting_points.ts
@@ -2,16 +2,16 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let renderer, scene, camera, stats;
-let pointclouds;
-let raycaster;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
+let pointclouds: THREE.Points[];
+let raycaster: THREE.Raycaster;
 let intersection = null;
 let spheresIndex = 0;
-let clock;
+let clock: THREE.Clock;
 let toggle = 0;
 
 const pointer = new THREE.Vector2();
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
 const threshold = 0.1;
 const pointSize = 0.05;
@@ -22,7 +22,7 @@ const rotateY = new THREE.Matrix4().makeRotationY(0.005);
 init();
 animate();
 
-function generatePointCloudGeometry(color, width, length) {
+function generatePointCloudGeometry(color: THREE.Color, width: number, length: number) {
     const geometry = new THREE.BufferGeometry();
     const numPoints = width * length;
 
@@ -59,14 +59,14 @@ function generatePointCloudGeometry(color, width, length) {
     return geometry;
 }
 
-function generatePointcloud(color, width, length) {
+function generatePointcloud(color: THREE.Color, width: number, length: number) {
     const geometry = generatePointCloudGeometry(color, width, length);
     const material = new THREE.PointsMaterial({ size: pointSize, vertexColors: true });
 
     return new THREE.Points(geometry, material);
 }
 
-function generateIndexedPointcloud(color, width, length) {
+function generateIndexedPointcloud(color: THREE.Color, width: number, length: number) {
     const geometry = generatePointCloudGeometry(color, width, length);
     const numPoints = width * length;
     const indices = new Uint16Array(numPoints);
@@ -87,7 +87,7 @@ function generateIndexedPointcloud(color, width, length) {
     return new THREE.Points(geometry, material);
 }
 
-function generateIndexedWithOffsetPointcloud(color, width, length) {
+function generateIndexedWithOffsetPointcloud(color: THREE.Color, width: number, length: number) {
     const geometry = generatePointCloudGeometry(color, width, length);
     const numPoints = width * length;
     const indices = new Uint16Array(numPoints);
@@ -110,7 +110,7 @@ function generateIndexedWithOffsetPointcloud(color, width, length) {
 }
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
 
@@ -174,7 +174,7 @@ function init() {
     document.addEventListener('pointermove', onPointerMove);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
diff --git a/examples-testing/examples/webgl_interactive_voxelpainter.ts b/examples-testing/examples/webgl_interactive_voxelpainter.ts
index 48b16f3..dae1d75 100644
--- a/examples-testing/examples/webgl_interactive_voxelpainter.ts
+++ b/examples-testing/examples/webgl_interactive_voxelpainter.ts
@@ -1,15 +1,15 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
-let plane;
-let pointer,
-    raycaster,
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let plane: THREE.Mesh;
+let pointer: THREE.Vector2,
+    raycaster: THREE.Raycaster,
     isShiftDown = false;
 
-let rollOverMesh, rollOverMaterial;
-let cubeGeo, cubeMaterial;
+let rollOverMesh: THREE.Mesh, rollOverMaterial: THREE.MeshBasicMaterial;
+let cubeGeo: THREE.BoxGeometry, cubeMaterial: THREE.MeshLambertMaterial;
 
-const objects = [];
+const objects: THREE.Object3D[] = [];
 
 init();
 render();
@@ -87,7 +87,7 @@ function onWindowResize() {
     render();
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
 
     raycaster.setFromCamera(pointer, camera);
@@ -97,14 +97,14 @@ function onPointerMove(event) {
     if (intersects.length > 0) {
         const intersect = intersects[0];
 
-        rollOverMesh.position.copy(intersect.point).add(intersect.face.normal);
+        rollOverMesh.position.copy(intersect.point).add(intersect.face!.normal);
         rollOverMesh.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
 
         render();
     }
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     pointer.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
 
     raycaster.setFromCamera(pointer, camera);
@@ -126,7 +126,7 @@ function onPointerDown(event) {
             // create cube
         } else {
             const voxel = new THREE.Mesh(cubeGeo, cubeMaterial);
-            voxel.position.copy(intersect.point).add(intersect.face.normal);
+            voxel.position.copy(intersect.point).add(intersect.face!.normal);
             voxel.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
             scene.add(voxel);
 
@@ -137,7 +137,7 @@ function onPointerDown(event) {
     }
 }
 
-function onDocumentKeyDown(event) {
+function onDocumentKeyDown(event: KeyboardEvent) {
     switch (event.keyCode) {
         case 16:
             isShiftDown = true;
@@ -145,7 +145,7 @@ function onDocumentKeyDown(event) {
     }
 }
 
-function onDocumentKeyUp(event) {
+function onDocumentKeyUp(event: KeyboardEvent) {
     switch (event.keyCode) {
         case 16:
             isShiftDown = false;
diff --git a/examples-testing/examples/webgl_layers.ts b/examples-testing/examples/webgl_layers.ts
index 5b0a450..654840c 100644
--- a/examples-testing/examples/webgl_layers.ts
+++ b/examples-testing/examples/webgl_layers.ts
@@ -3,8 +3,8 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let theta = 0;
 const radius = 5;
diff --git a/examples-testing/examples/webgl_lensflares.ts b/examples-testing/examples/webgl_lensflares.ts
index e24dcd1..da07ba7 100644
--- a/examples-testing/examples/webgl_lensflares.ts
+++ b/examples-testing/examples/webgl_lensflares.ts
@@ -5,10 +5,10 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { FlyControls } from 'three/addons/controls/FlyControls.js';
 import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controls: FlyControls;
 
 const clock = new THREE.Clock();
 
@@ -71,7 +71,7 @@ function init() {
     addLight(0.08, 0.8, 0.5, 0, 0, -1000);
     addLight(0.995, 0.5, 0.9, 5000, 5000, -1000);
 
-    function addLight(h, s, l, x, y, z) {
+    function addLight(h: number, s: number, l: number, x: number, y: number, z: number) {
         const light = new THREE.PointLight(0xffffff, 1.5, 2000, 0);
         light.color.setHSL(h, s, l);
         light.position.set(x, y, z);
diff --git a/examples-testing/examples/webgl_lightprobe.ts b/examples-testing/examples/webgl_lightprobe.ts
index 2efcad5..b21d028 100644
--- a/examples-testing/examples/webgl_lightprobe.ts
+++ b/examples-testing/examples/webgl_lightprobe.ts
@@ -5,12 +5,15 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js';
 
-let mesh, renderer, scene, camera;
+let mesh: THREE.Mesh<THREE.SphereGeometry, THREE.MeshStandardMaterial>,
+    renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera;
 
 let gui;
 
-let lightProbe;
-let directionalLight;
+let lightProbe: THREE.LightProbe;
+let directionalLight: THREE.DirectionalLight;
 
 // linear color space
 const API = {
@@ -55,7 +58,7 @@ function init() {
     scene.add(directionalLight);
 
     // envmap
-    const genCubeUrls = function (prefix, postfix) {
+    const genCubeUrls = function (prefix: string, postfix: string) {
         return [
             prefix + 'px' + postfix,
             prefix + 'nx' + postfix,
diff --git a/examples-testing/examples/webgl_lightprobe_cubecamera.ts b/examples-testing/examples/webgl_lightprobe_cubecamera.ts
index c714d29..ccf95e0 100644
--- a/examples-testing/examples/webgl_lightprobe_cubecamera.ts
+++ b/examples-testing/examples/webgl_lightprobe_cubecamera.ts
@@ -4,9 +4,9 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { LightProbeHelper } from 'three/addons/helpers/LightProbeHelper.js';
 import { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js';
 
-let renderer, scene, camera, cubeCamera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, cubeCamera: THREE.CubeCamera;
 
-let lightProbe;
+let lightProbe: THREE.LightProbe;
 
 init();
 
@@ -40,7 +40,7 @@ function init() {
     scene.add(lightProbe);
 
     // envmap
-    const genCubeUrls = function (prefix, postfix) {
+    const genCubeUrls = function (prefix: string, postfix: string) {
         return [
             prefix + 'px' + postfix,
             prefix + 'nx' + postfix,
diff --git a/examples-testing/examples/webgl_lights_hemisphere.ts b/examples-testing/examples/webgl_lights_hemisphere.ts
index 71e1d3d..73aa07c 100644
--- a/examples-testing/examples/webgl_lights_hemisphere.ts
+++ b/examples-testing/examples/webgl_lights_hemisphere.ts
@@ -5,9 +5,9 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let camera, scene, renderer;
-const mixers = [];
-let stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+const mixers: THREE.AnimationMixer[] = [];
+let stats: Stats;
 
 const clock = new THREE.Clock();
 
@@ -15,7 +15,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 5000);
     camera.position.set(0, 0, 250);
@@ -75,8 +75,8 @@ function init() {
 
     // SKYDOME
 
-    const vertexShader = document.getElementById('vertexShader').textContent;
-    const fragmentShader = document.getElementById('fragmentShader').textContent;
+    const vertexShader = document.getElementById('vertexShader')!.textContent!;
+    const fragmentShader = document.getElementById('fragmentShader')!.textContent!;
     const uniforms = {
         topColor: { value: new THREE.Color(0x0077ff) },
         bottomColor: { value: new THREE.Color(0xffffff) },
diff --git a/examples-testing/examples/webgl_lights_physical.ts b/examples-testing/examples/webgl_lights_physical.ts
index 4fa760d..b91677c 100644
--- a/examples-testing/examples/webgl_lights_physical.ts
+++ b/examples-testing/examples/webgl_lights_physical.ts
@@ -5,13 +5,19 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, bulbLight, bulbMat, hemiLight, stats;
-let ballMat, cubeMat, floorMat;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    bulbLight: THREE.PointLight,
+    bulbMat: THREE.MeshStandardMaterial,
+    hemiLight: THREE.HemisphereLight,
+    stats: Stats;
+let ballMat: THREE.MeshStandardMaterial, cubeMat: THREE.MeshStandardMaterial, floorMat: THREE.MeshStandardMaterial;
 
 let previousShadowMap = false;
 
 // ref for lumens: http://www.power-sure.com/lumens.htm
-const bulbLuminousPowers = {
+const bulbLuminousPowers: Record<string, number> = {
     '110000 lm (1000W)': 110000,
     '3500 lm (300W)': 3500,
     '1700 lm (100W)': 1700,
@@ -23,7 +29,7 @@ const bulbLuminousPowers = {
 };
 
 // ref for solar irradiances: https://en.wikipedia.org/wiki/Lux
-const hemiLuminousIrradiances = {
+const hemiLuminousIrradiances: Record<string, number> = {
     '0.0001 lx (Moonless Night)': 0.0001,
     '0.002 lx (Night Airglow)': 0.002,
     '0.5 lx (Full Moon)': 0.5,
@@ -48,7 +54,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     stats = new Stats();
     container.appendChild(stats.dom);
diff --git a/examples-testing/examples/webgl_lights_pointlights.ts b/examples-testing/examples/webgl_lights_pointlights.ts
index b3c17f4..b51888a 100644
--- a/examples-testing/examples/webgl_lights_pointlights.ts
+++ b/examples-testing/examples/webgl_lights_pointlights.ts
@@ -4,7 +4,15 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
 
-let camera, scene, renderer, light1, light2, light3, light4, object, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    light1: THREE.PointLight,
+    light2: THREE.PointLight,
+    light3: THREE.PointLight,
+    light4: THREE.PointLight,
+    object: THREE.Group,
+    stats: Stats;
 
 const clock = new THREE.Clock();
 
diff --git a/examples-testing/examples/webgl_lights_rectarealight.ts b/examples-testing/examples/webgl_lights_rectarealight.ts
index b841fa6..f305161 100644
--- a/examples-testing/examples/webgl_lights_rectarealight.ts
+++ b/examples-testing/examples/webgl_lights_rectarealight.ts
@@ -6,8 +6,8 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';
 import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
 
-let renderer, scene, camera;
-let stats, meshKnot;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let stats: Stats, meshKnot: THREE.Mesh;
 
 init();
 
@@ -70,7 +70,7 @@ function onWindowResize() {
     camera.updateProjectionMatrix();
 }
 
-function animation(time) {
+function animation(time: DOMHighResTimeStamp) {
     meshKnot.rotation.y = time / 1000;
 
     renderer.render(scene, camera);
diff --git a/examples-testing/examples/webgl_lights_spotlight.ts b/examples-testing/examples/webgl_lights_spotlight.ts
index a05169e..e0e0feb 100644
--- a/examples-testing/examples/webgl_lights_spotlight.ts
+++ b/examples-testing/examples/webgl_lights_spotlight.ts
@@ -5,9 +5,9 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let renderer, scene, camera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
 
-let spotLight, lightHelper;
+let spotLight: THREE.SpotLight, lightHelper: THREE.SpotLightHelper;
 
 init();
 
@@ -43,7 +43,7 @@ function init() {
     const loader = new THREE.TextureLoader().setPath('textures/');
     const filenames = ['disturb.jpg', 'colors.png', 'uv_grid_opengl.jpg'];
 
-    const textures = { none: null };
+    const textures: Record<string, THREE.Texture | null> = { none: null };
 
     for (let i = 0; i < filenames.length; i++) {
         const filename = filenames[i];
@@ -156,8 +156,8 @@ function init() {
         renderer.shadowMap.enabled = val;
 
         scene.traverse(function (child) {
-            if (child.material) {
-                child.material.needsUpdate = true;
+            if ((child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material) {
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.needsUpdate = true;
             }
         });
     });
diff --git a/examples-testing/examples/webgl_lights_spotlights.ts b/examples-testing/examples/webgl_lights_spotlights.ts
index da6917b..ae113e9 100644
--- a/examples-testing/examples/webgl_lights_spotlights.ts
+++ b/examples-testing/examples/webgl_lights_spotlights.ts
@@ -28,7 +28,7 @@ const spotLight1 = createSpotlight(0xff7f00);
 const spotLight2 = createSpotlight(0x00ff7f);
 const spotLight3 = createSpotlight(0x7f00ff);
 
-let lightHelper1, lightHelper2, lightHelper3;
+let lightHelper1: THREE.SpotLightHelper, lightHelper2: THREE.SpotLightHelper, lightHelper3: THREE.SpotLightHelper;
 
 function init() {
     renderer.shadowMap.enabled = true;
@@ -67,7 +67,7 @@ function init() {
     controls.update();
 }
 
-function createSpotlight(color) {
+function createSpotlight(color: number) {
     const newObj = new THREE.SpotLight(color, 10);
 
     newObj.castShadow = true;
@@ -85,7 +85,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function tween(light) {
+function tween(light: THREE.SpotLight) {
     new TWEEN.Tween(light)
         .to(
             {
diff --git a/examples-testing/examples/webgl_lines_colors.ts b/examples-testing/examples/webgl_lines_colors.ts
index 0582e48..fa920c8 100644
--- a/examples-testing/examples/webgl_lines_colors.ts
+++ b/examples-testing/examples/webgl_lines_colors.ts
@@ -8,7 +8,7 @@ let mouseX = 0,
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -110,7 +110,7 @@ function init() {
     const scale = 0.3,
         d = 225;
 
-    const parameters = [
+    const parameters: [THREE.Material, number, [number, number, number], THREE.BufferGeometry][] = [
         [material, scale * 1.5, [-d, -d / 2, 0], geometry1],
         [material, scale * 1.5, [0, -d / 2, 0], geometry2],
         [material, scale * 1.5, [d, -d / 2, 0], geometry3],
@@ -152,7 +152,7 @@ function onWindowResize() {
 
 //
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
@@ -177,7 +177,7 @@ function render() {
     for (let i = 0; i < scene.children.length; i++) {
         const object = scene.children[i];
 
-        if (object.isLine) {
+        if ((object as THREE.Line).isLine) {
             object.rotation.y = time * (i % 2 ? 1 : -1);
         }
     }
diff --git a/examples-testing/examples/webgl_lines_dashed.ts b/examples-testing/examples/webgl_lines_dashed.ts
index 32f8f9c..4871ed8 100644
--- a/examples-testing/examples/webgl_lines_dashed.ts
+++ b/examples-testing/examples/webgl_lines_dashed.ts
@@ -4,8 +4,8 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';
 
-let renderer, scene, camera, stats;
-const objects = [];
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
+const objects: THREE.Object3D[] = [];
 
 const WIDTH = window.innerWidth,
     HEIGHT = window.innerHeight;
@@ -63,7 +63,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function box(width, height, depth) {
+function box(width: number, height: number, depth: number) {
     (width = width * 0.5), (height = height * 0.5), (depth = depth * 0.5);
 
     const geometry = new THREE.BufferGeometry();
@@ -178,7 +178,7 @@ function render() {
     const time = Date.now() * 0.001;
 
     scene.traverse(function (object) {
-        if (object.isLine) {
+        if ((object as THREE.Line).isLine) {
             object.rotation.x = 0.25 * time;
             object.rotation.y = 0.25 * time;
         }
diff --git a/examples-testing/examples/webgl_lines_fat.ts b/examples-testing/examples/webgl_lines_fat.ts
index 41354b0..414df7a 100644
--- a/examples-testing/examples/webgl_lines_fat.ts
+++ b/examples-testing/examples/webgl_lines_fat.ts
@@ -10,15 +10,20 @@ import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
 import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
 import * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';
 
-let line, renderer, scene, camera, camera2, controls;
-let line1;
-let matLine, matLineBasic, matLineDashed;
-let stats, gpuPanel;
-let gui;
+let line: Line2,
+    renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    camera2: THREE.PerspectiveCamera,
+    controls: OrbitControls;
+let line1: THREE.Line;
+let matLine: LineMaterial, matLineBasic: THREE.LineBasicMaterial, matLineDashed: THREE.LineDashedMaterial;
+let stats: Stats, gpuPanel: GPUStatsPanel;
+let gui: GUI;
 
 // viewport
-let insetWidth;
-let insetHeight;
+let insetWidth: number;
+let insetHeight: number;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_lines_fat_raycasting.ts b/examples-testing/examples/webgl_lines_fat_raycasting.ts
index a40a775..bcbf72a 100644
--- a/examples-testing/examples/webgl_lines_fat_raycasting.ts
+++ b/examples-testing/examples/webgl_lines_fat_raycasting.ts
@@ -11,12 +11,13 @@ import { LineSegmentsGeometry } from 'three/addons/lines/LineSegmentsGeometry.js
 import { Line2 } from 'three/addons/lines/Line2.js';
 import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
 
-let line, thresholdLine, segments, thresholdSegments;
-let renderer, scene, camera, controls;
-let sphereInter, sphereOnLine;
-let stats, gpuPanel;
-let gui;
-let clock;
+let line: Line2, thresholdLine: Line2, segments: LineSegments2, thresholdSegments: LineSegments2;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
+let sphereInter: THREE.Mesh<THREE.SphereGeometry, THREE.MeshBasicMaterial>,
+    sphereOnLine: THREE.Mesh<THREE.SphereGeometry, THREE.MeshBasicMaterial>;
+let stats: Stats, gpuPanel: GPUStatsPanel;
+let gui: GUI;
+let clock: THREE.Clock;
 
 const color = new THREE.Color();
 
@@ -24,8 +25,7 @@ const pointer = new THREE.Vector2(Infinity, Infinity);
 
 const raycaster = new THREE.Raycaster();
 
-raycaster.params.Line2 = {};
-raycaster.params.Line2.threshold = 0;
+raycaster.params.Line2 = { threshold: 0 };
 
 const matLine = new LineMaterial({
     color: 0xffffff,
@@ -179,7 +179,7 @@ function onWindowResize() {
     matThresholdLine.resolution.set(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -212,9 +212,9 @@ function animate() {
         sphereOnLine.visible = true;
 
         sphereInter.position.copy(intersects[0].point);
-        sphereOnLine.position.copy(intersects[0].pointOnLine);
+        sphereOnLine.position.copy(intersects[0].pointOnLine!);
 
-        const index = intersects[0].faceIndex;
+        const index = intersects[0].faceIndex!;
         const colors = obj.geometry.getAttribute('instanceColorStart');
 
         color.fromBufferAttribute(colors, index);
@@ -236,7 +236,7 @@ function animate() {
 
 //
 
-function switchLine(val) {
+function switchLine(val: number) {
     switch (val) {
         case 0:
             line.visible = true;
@@ -281,7 +281,7 @@ function initGui() {
 
     gui.add(params, 'width', 1, 10).onChange(function (val) {
         matLine.linewidth = val;
-        matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2.threshold;
+        matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2!.threshold;
     });
 
     gui.add(params, 'alphaToCoverage').onChange(function (val) {
@@ -289,8 +289,8 @@ function initGui() {
     });
 
     gui.add(params, 'threshold', 0, 10).onChange(function (val) {
-        raycaster.params.Line2.threshold = val;
-        matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2.threshold;
+        raycaster.params.Line2!.threshold = val;
+        matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2!.threshold;
     });
 
     gui.add(params, 'translation', 0, 10).onChange(function (val) {
diff --git a/examples-testing/examples/webgl_lines_fat_wireframe.ts b/examples-testing/examples/webgl_lines_fat_wireframe.ts
index b3ca12c..47dca0a 100644
--- a/examples-testing/examples/webgl_lines_fat_wireframe.ts
+++ b/examples-testing/examples/webgl_lines_fat_wireframe.ts
@@ -8,15 +8,20 @@ import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
 import { Wireframe } from 'three/addons/lines/Wireframe.js';
 import { WireframeGeometry2 } from 'three/addons/lines/WireframeGeometry2.js';
 
-let wireframe, renderer, scene, camera, camera2, controls;
-let wireframe1;
-let matLine, matLineBasic, matLineDashed;
-let stats;
-let gui;
+let wireframe: Wireframe,
+    renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    camera2: THREE.PerspectiveCamera,
+    controls: OrbitControls;
+let wireframe1: THREE.LineSegments;
+let matLine: LineMaterial, matLineBasic: THREE.LineBasicMaterial, matLineDashed: THREE.LineDashedMaterial;
+let stats: Stats;
+let gui: GUI;
 
 // viewport
-let insetWidth;
-let insetHeight;
+let insetWidth: number;
+let insetHeight: number;
 
 init();
 animate();
@@ -42,7 +47,7 @@ function init() {
 
     // Wireframe ( WireframeGeometry2, LineMaterial )
 
-    let geo = new THREE.IcosahedronGeometry(20, 1);
+    let geo: THREE.BufferGeometry = new THREE.IcosahedronGeometry(20, 1);
 
     const geometry = new WireframeGeometry2(geo);
 
diff --git a/examples-testing/examples/webgl_loader_3dm.ts b/examples-testing/examples/webgl_loader_3dm.ts
index fc3b73d..218a5f1 100644
--- a/examples-testing/examples/webgl_loader_3dm.ts
+++ b/examples-testing/examples/webgl_loader_3dm.ts
@@ -5,8 +5,8 @@ import { Rhino3dmLoader } from 'three/addons/loaders/3DMLoader.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
-let controls, gui;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controls: OrbitControls, gui: GUI;
 
 init();
 animate();
@@ -38,7 +38,7 @@ function init() {
             initGUI(object.userData.layers);
 
             // hide spinner
-            document.getElementById('loader').style.display = 'none';
+            document.getElementById('loader')!.style.display = 'none';
         },
         function (progress) {
             console.log((progress.loaded / progress.total) * 100 + '%');
@@ -70,7 +70,7 @@ function animate() {
     requestAnimationFrame(animate);
 }
 
-function initGUI(layers) {
+function initGUI(layers: { name: string; visible: boolean }[]) {
     gui = new GUI({ title: 'layers' });
 
     for (let i = 0; i < layers.length; i++) {
diff --git a/examples-testing/examples/webgl_loader_3ds.ts b/examples-testing/examples/webgl_loader_3ds.ts
index b0bcebe..a0ae9d6 100644
--- a/examples-testing/examples/webgl_loader_3ds.ts
+++ b/examples-testing/examples/webgl_loader_3ds.ts
@@ -3,8 +3,8 @@ import * as THREE from 'three';
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import { TDSLoader } from 'three/addons/loaders/TDSLoader.js';
 
-let container, controls;
-let camera, scene, renderer;
+let container: HTMLDivElement, controls: TrackballControls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -30,9 +30,9 @@ function init() {
     loader.setResourcePath('models/3ds/portalgun/textures/');
     loader.load('models/3ds/portalgun/portalgun.3ds', function (object) {
         object.traverse(function (child) {
-            if (child.isMesh) {
-                child.material.specular.setScalar(0.1);
-                child.material.normalMap = normal;
+            if ((child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).isMesh) {
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).material.specular.setScalar(0.1);
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).material.normalMap = normal;
             }
         });
 
diff --git a/examples-testing/examples/webgl_loader_3mf.ts b/examples-testing/examples/webgl_loader_3mf.ts
index c31e321..eecda51 100644
--- a/examples-testing/examples/webgl_loader_3mf.ts
+++ b/examples-testing/examples/webgl_loader_3mf.ts
@@ -4,7 +4,12 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { ThreeMFLoader } from 'three/addons/loaders/3MFLoader.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, object, loader, controls;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    object: THREE.Group,
+    loader: ThreeMFLoader,
+    controls: OrbitControls;
 
 const params = {
     asset: 'cube_gears',
@@ -73,13 +78,18 @@ function init() {
     });
 }
 
-function loadAsset(asset) {
+function loadAsset(asset: string) {
     loader.load('models/3mf/' + asset + '.3mf', function (group) {
         if (object) {
             object.traverse(function (child) {
-                if (child.material) child.material.dispose();
-                if (child.material && child.material.map) child.material.map.dispose();
-                if (child.geometry) child.geometry.dispose();
+                if ((child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material)
+                    (child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.dispose();
+                if (
+                    (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material &&
+                    (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.map
+                )
+                    (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.map!.dispose();
+                if ((child as THREE.Mesh).geometry) (child as THREE.Mesh).geometry.dispose();
             });
 
             scene.remove(object);
diff --git a/examples-testing/examples/webgl_loader_3mf_materials.ts b/examples-testing/examples/webgl_loader_3mf_materials.ts
index fcdd730..3cfb49b 100644
--- a/examples-testing/examples/webgl_loader_3mf_materials.ts
+++ b/examples-testing/examples/webgl_loader_3mf_materials.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { ThreeMFLoader } from 'three/addons/loaders/3MFLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_amf.ts b/examples-testing/examples/webgl_loader_amf.ts
index ee576e0..7569a04 100644
--- a/examples-testing/examples/webgl_loader_amf.ts
+++ b/examples-testing/examples/webgl_loader_amf.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { AMFLoader } from 'three/addons/loaders/AMFLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_bvh.ts b/examples-testing/examples/webgl_loader_bvh.ts
index 22eddd6..ba5f08e 100644
--- a/examples-testing/examples/webgl_loader_bvh.ts
+++ b/examples-testing/examples/webgl_loader_bvh.ts
@@ -5,8 +5,8 @@ import { BVHLoader } from 'three/addons/loaders/BVHLoader.js';
 
 const clock = new THREE.Clock();
 
-let camera, controls, scene, renderer;
-let mixer;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mixer: THREE.AnimationMixer;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_loader_collada.ts b/examples-testing/examples/webgl_loader_collada.ts
index 589217f..ee2f586 100644
--- a/examples-testing/examples/webgl_loader_collada.ts
+++ b/examples-testing/examples/webgl_loader_collada.ts
@@ -4,14 +4,14 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { ColladaLoader } from 'three/addons/loaders/ColladaLoader.js';
 
-let container, stats, clock;
-let camera, scene, renderer, elf;
+let container: HTMLElement, stats: Stats, clock: THREE.Clock;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, elf: THREE.Scene;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
     camera.position.set(8, 10, 8);
diff --git a/examples-testing/examples/webgl_loader_collada_skinning.ts b/examples-testing/examples/webgl_loader_collada_skinning.ts
index 4d3f393..a3f95c7 100644
--- a/examples-testing/examples/webgl_loader_collada_skinning.ts
+++ b/examples-testing/examples/webgl_loader_collada_skinning.ts
@@ -5,14 +5,14 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { ColladaLoader } from 'three/addons/loaders/ColladaLoader.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container, stats, clock, controls;
-let camera, scene, renderer, mixer;
+let container: HTMLElement, stats: Stats, clock: THREE.Clock, controls: OrbitControls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mixer: THREE.AnimationMixer;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 1, 1000);
     camera.position.set(15, 10, -15);
diff --git a/examples-testing/examples/webgl_loader_draco.ts b/examples-testing/examples/webgl_loader_draco.ts
index 4e7d17b..32018ae 100644
--- a/examples-testing/examples/webgl_loader_draco.ts
+++ b/examples-testing/examples/webgl_loader_draco.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-const container = document.querySelector('#container');
+const container = document.querySelector('#container')!;
 
 // Configure and create Draco decoder.
 const dracoLoader = new DRACOLoader();
diff --git a/examples-testing/examples/webgl_loader_fbx.ts b/examples-testing/examples/webgl_loader_fbx.ts
index eda3079..5a5a6be 100644
--- a/examples-testing/examples/webgl_loader_fbx.ts
+++ b/examples-testing/examples/webgl_loader_fbx.ts
@@ -5,11 +5,11 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 const clock = new THREE.Clock();
 
-let mixer;
+let mixer: THREE.AnimationMixer;
 
 init();
 animate();
@@ -63,7 +63,7 @@ function init() {
         action.play();
 
         object.traverse(function (child) {
-            if (child.isMesh) {
+            if ((child as THREE.Mesh).isMesh) {
                 child.castShadow = true;
                 child.receiveShadow = true;
             }
diff --git a/examples-testing/examples/webgl_loader_fbx_nurbs.ts b/examples-testing/examples/webgl_loader_fbx_nurbs.ts
index 919a96d..7af5eb7 100644
--- a/examples-testing/examples/webgl_loader_fbx_nurbs.ts
+++ b/examples-testing/examples/webgl_loader_fbx_nurbs.ts
@@ -5,7 +5,7 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_loader_gcode.ts b/examples-testing/examples/webgl_loader_gcode.ts
index 6fd3e14..79c6423 100644
--- a/examples-testing/examples/webgl_loader_gcode.ts
+++ b/examples-testing/examples/webgl_loader_gcode.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GCodeLoader } from 'three/addons/loaders/GCodeLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 render();
diff --git a/examples-testing/examples/webgl_loader_gltf.ts b/examples-testing/examples/webgl_loader_gltf.ts
index e1b0adc..6fcb3ed 100644
--- a/examples-testing/examples/webgl_loader_gltf.ts
+++ b/examples-testing/examples/webgl_loader_gltf.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_gltf_anisotropy.ts b/examples-testing/examples/webgl_loader_gltf_anisotropy.ts
index 6e240a2..96a3939 100644
--- a/examples-testing/examples/webgl_loader_gltf_anisotropy.ts
+++ b/examples-testing/examples/webgl_loader_gltf_anisotropy.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 
-let renderer, scene, camera, controls;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_gltf_avif.ts b/examples-testing/examples/webgl_loader_gltf_avif.ts
index 37d6385..68dff97 100644
--- a/examples-testing/examples/webgl_loader_gltf_avif.ts
+++ b/examples-testing/examples/webgl_loader_gltf_avif.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 render();
diff --git a/examples-testing/examples/webgl_loader_gltf_compressed.ts b/examples-testing/examples/webgl_loader_gltf_compressed.ts
index 8202430..0926a59 100644
--- a/examples-testing/examples/webgl_loader_gltf_compressed.ts
+++ b/examples-testing/examples/webgl_loader_gltf_compressed.ts
@@ -7,7 +7,7 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
 import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 render();
diff --git a/examples-testing/examples/webgl_loader_gltf_instancing.ts b/examples-testing/examples/webgl_loader_gltf_instancing.ts
index 5d23e77..b8a6814 100644
--- a/examples-testing/examples/webgl_loader_gltf_instancing.ts
+++ b/examples-testing/examples/webgl_loader_gltf_instancing.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 render();
diff --git a/examples-testing/examples/webgl_loader_gltf_iridescence.ts b/examples-testing/examples/webgl_loader_gltf_iridescence.ts
index 366ee49..1f10a04 100644
--- a/examples-testing/examples/webgl_loader_gltf_iridescence.ts
+++ b/examples-testing/examples/webgl_loader_gltf_iridescence.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 
-let renderer, scene, camera, controls;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
 
 init().catch(function (err) {
     console.error(err);
diff --git a/examples-testing/examples/webgl_loader_gltf_lights.ts b/examples-testing/examples/webgl_loader_gltf_lights.ts
index f2bd5b1..7efbb03 100644
--- a/examples-testing/examples/webgl_loader_gltf_lights.ts
+++ b/examples-testing/examples/webgl_loader_gltf_lights.ts
@@ -6,7 +6,7 @@ import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const params = {
     punctualLightsEnabled: true,
@@ -66,9 +66,9 @@ function onWindowResize() {
     render();
 }
 
-function toggleLights(visible) {
+function toggleLights(visible: boolean) {
     scene.traverse(function (object) {
-        if (object.isLight) {
+        if ((object as THREE.Light).isLight) {
             object.visible = visible;
         }
     });
diff --git a/examples-testing/examples/webgl_loader_gltf_sheen.ts b/examples-testing/examples/webgl_loader_gltf_sheen.ts
index 39072e9..a336dc5 100644
--- a/examples-testing/examples/webgl_loader_gltf_sheen.ts
+++ b/examples-testing/examples/webgl_loader_gltf_sheen.ts
@@ -6,7 +6,7 @@ import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
 
 init();
 animate();
@@ -25,7 +25,10 @@ function init() {
     new GLTFLoader().setPath('models/gltf/').load('SheenChair.glb', function (gltf) {
         scene.add(gltf.scene);
 
-        const object = gltf.scene.getObjectByName('SheenChair_fabric');
+        const object = gltf.scene.getObjectByName('SheenChair_fabric') as THREE.Mesh<
+            THREE.BufferGeometry,
+            THREE.MeshPhysicalMaterial
+        >;
 
         const gui = new GUI();
 
diff --git a/examples-testing/examples/webgl_loader_gltf_transmission.ts b/examples-testing/examples/webgl_loader_gltf_transmission.ts
index 05d4fd1..3b3add9 100644
--- a/examples-testing/examples/webgl_loader_gltf_transmission.ts
+++ b/examples-testing/examples/webgl_loader_gltf_transmission.ts
@@ -6,7 +6,12 @@ import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 
-let camera, scene, renderer, controls, clock, mixer;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    controls: OrbitControls,
+    clock: THREE.Clock,
+    mixer: THREE.AnimationMixer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_imagebitmap.ts b/examples-testing/examples/webgl_loader_imagebitmap.ts
index 4f2900f..ef1da2b 100644
--- a/examples-testing/examples/webgl_loader_imagebitmap.ts
+++ b/examples-testing/examples/webgl_loader_imagebitmap.ts
@@ -1,7 +1,7 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
-let group, cubes;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let group: THREE.Group, cubes: THREE.Group;
 
 init();
 animate();
@@ -43,7 +43,7 @@ function addImage() {
 
 const geometry = new THREE.BoxGeometry();
 
-function addCube(material) {
+function addCube(material: THREE.MeshBasicMaterial) {
     const cube = new THREE.Mesh(geometry, material);
     cube.position.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
     cube.rotation.set(Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI);
diff --git a/examples-testing/examples/webgl_loader_kmz.ts b/examples-testing/examples/webgl_loader_kmz.ts
index f93555e..8793a35 100644
--- a/examples-testing/examples/webgl_loader_kmz.ts
+++ b/examples-testing/examples/webgl_loader_kmz.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { KMZLoader } from 'three/addons/loaders/KMZLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_lwo.ts b/examples-testing/examples/webgl_loader_lwo.ts
index d505621..6b1d95a 100644
--- a/examples-testing/examples/webgl_loader_lwo.ts
+++ b/examples-testing/examples/webgl_loader_lwo.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { LWOLoader } from 'three/addons/loaders/LWOLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_md2_control.ts b/examples-testing/examples/webgl_loader_md2_control.ts
index 0ce644a..e0ada97 100644
--- a/examples-testing/examples/webgl_loader_md2_control.ts
+++ b/examples-testing/examples/webgl_loader_md2_control.ts
@@ -9,10 +9,10 @@ import { Gyroscope } from 'three/addons/misc/Gyroscope.js';
 let SCREEN_WIDTH = window.innerWidth;
 let SCREEN_HEIGHT = window.innerHeight;
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-const characters = [];
+const characters: MD2CharacterComplex[] = [];
 let nCharacters = 0;
 
 let cameraControls;
@@ -77,10 +77,10 @@ function init() {
 
     const ground = new THREE.Mesh(gg, gm);
     ground.rotation.x = -Math.PI / 2;
-    ground.material.map.repeat.set(64, 64);
-    ground.material.map.wrapS = THREE.RepeatWrapping;
-    ground.material.map.wrapT = THREE.RepeatWrapping;
-    ground.material.map.colorSpace = THREE.SRGBColorSpace;
+    ground.material.map!.repeat.set(64, 64);
+    ground.material.map!.wrapS = THREE.RepeatWrapping;
+    ground.material.map!.wrapT = THREE.RepeatWrapping;
+    ground.material.map!.colorSpace = THREE.SRGBColorSpace;
     // note that because the ground does not cast a shadow, .castShadow is left false
     ground.receiveShadow = true;
 
@@ -212,7 +212,7 @@ function onWindowResize() {
     camera.updateProjectionMatrix();
 }
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     switch (event.code) {
         case 'ArrowUp':
         case 'KeyW':
@@ -241,7 +241,7 @@ function onKeyDown(event) {
     }
 }
 
-function onKeyUp(event) {
+function onKeyUp(event: KeyboardEvent) {
     switch (event.code) {
         case 'ArrowUp':
         case 'KeyW':
diff --git a/examples-testing/examples/webgl_loader_mdd.ts b/examples-testing/examples/webgl_loader_mdd.ts
index a1e76f0..4d3edb9 100644
--- a/examples-testing/examples/webgl_loader_mdd.ts
+++ b/examples-testing/examples/webgl_loader_mdd.ts
@@ -2,7 +2,11 @@ import * as THREE from 'three';
 
 import { MDDLoader } from 'three/addons/loaders/MDDLoader.js';
 
-let camera, scene, renderer, mixer, clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    mixer: THREE.AnimationMixer,
+    clock: THREE.Clock;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_obj.ts b/examples-testing/examples/webgl_loader_obj.ts
index f61eeb7..44b29b6 100644
--- a/examples-testing/examples/webgl_loader_obj.ts
+++ b/examples-testing/examples/webgl_loader_obj.ts
@@ -3,9 +3,9 @@ import * as THREE from 'three';
 import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let object;
+let object: THREE.Group;
 
 init();
 
@@ -28,7 +28,8 @@ function init() {
 
     function loadModel() {
         object.traverse(function (child) {
-            if (child.isMesh) child.material.map = texture;
+            if ((child as THREE.Mesh).isMesh)
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).material.map = texture;
         });
 
         object.position.y = -0.95;
@@ -48,7 +49,7 @@ function init() {
 
     // model
 
-    function onProgress(xhr) {
+    function onProgress(xhr: ProgressEvent) {
         if (xhr.lengthComputable) {
             const percentComplete = (xhr.loaded / xhr.total) * 100;
             console.log('model ' + percentComplete.toFixed(2) + '% downloaded');
diff --git a/examples-testing/examples/webgl_loader_obj_mtl.ts b/examples-testing/examples/webgl_loader_obj_mtl.ts
index 2e6a267..00b2416 100644
--- a/examples-testing/examples/webgl_loader_obj_mtl.ts
+++ b/examples-testing/examples/webgl_loader_obj_mtl.ts
@@ -4,7 +4,7 @@ import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
 import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -26,7 +26,7 @@ function init() {
 
     // model
 
-    const onProgress = function (xhr) {
+    const onProgress = function (xhr: ProgressEvent) {
         if (xhr.lengthComputable) {
             const percentComplete = (xhr.loaded / xhr.total) * 100;
             console.log(percentComplete.toFixed(2) + '% downloaded');
diff --git a/examples-testing/examples/webgl_loader_pcd.ts b/examples-testing/examples/webgl_loader_pcd.ts
index d69e3fa..312ad67 100644
--- a/examples-testing/examples/webgl_loader_pcd.ts
+++ b/examples-testing/examples/webgl_loader_pcd.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { PCDLoader } from 'three/addons/loaders/PCDLoader.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 render();
diff --git a/examples-testing/examples/webgl_loader_pdb.ts b/examples-testing/examples/webgl_loader_pdb.ts
index 3ab34b5..c95d5c3 100644
--- a/examples-testing/examples/webgl_loader_pdb.ts
+++ b/examples-testing/examples/webgl_loader_pdb.ts
@@ -5,10 +5,10 @@ import { PDBLoader } from 'three/addons/loaders/PDBLoader.js';
 import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, labelRenderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, labelRenderer: CSS2DRenderer;
+let controls: TrackballControls;
 
-let root;
+let root: THREE.Group;
 
 const MOLECULES = {
     Ethanol: 'ethanol.pdb',
@@ -64,14 +64,14 @@ function init() {
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
-    document.getElementById('container').appendChild(renderer.domElement);
+    document.getElementById('container')!.appendChild(renderer.domElement);
 
     labelRenderer = new CSS2DRenderer();
     labelRenderer.setSize(window.innerWidth, window.innerHeight);
     labelRenderer.domElement.style.position = 'absolute';
     labelRenderer.domElement.style.top = '0px';
     labelRenderer.domElement.style.pointerEvents = 'none';
-    document.getElementById('container').appendChild(labelRenderer.domElement);
+    document.getElementById('container')!.appendChild(labelRenderer.domElement);
 
     //
 
@@ -97,12 +97,12 @@ function init() {
 
 //
 
-function loadMolecule(model) {
+function loadMolecule(model: string) {
     const url = 'models/pdb/' + model;
 
     while (root.children.length > 0) {
         const object = root.children[0];
-        object.parent.remove(object);
+        object.parent!.remove(object);
     }
 
     loader.load(url, function (pdb) {
@@ -114,7 +114,7 @@ function loadMolecule(model) {
         const sphereGeometry = new THREE.IcosahedronGeometry(1, 3);
 
         geometryAtoms.computeBoundingBox();
-        geometryAtoms.boundingBox.getCenter(offset).negate();
+        geometryAtoms.boundingBox!.getCenter(offset).negate();
 
         geometryAtoms.translate(offset.x, offset.y, offset.z);
         geometryBonds.translate(offset.x, offset.y, offset.z);
diff --git a/examples-testing/examples/webgl_loader_ply.ts b/examples-testing/examples/webgl_loader_ply.ts
index f3cb460..7b8a122 100644
--- a/examples-testing/examples/webgl_loader_ply.ts
+++ b/examples-testing/examples/webgl_loader_ply.ts
@@ -4,9 +4,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, cameraTarget, scene, renderer;
+let camera: THREE.PerspectiveCamera, cameraTarget: THREE.Vector3, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -100,7 +100,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function addShadowedLight(x, y, z, color, intensity) {
+function addShadowedLight(x: number, y: number, z: number, color: number, intensity: number) {
     const directionalLight = new THREE.DirectionalLight(color, intensity);
     directionalLight.position.set(x, y, z);
     scene.add(directionalLight);
diff --git a/examples-testing/examples/webgl_loader_svg.ts b/examples-testing/examples/webgl_loader_svg.ts
index 45361b9..f5d72d3 100644
--- a/examples-testing/examples/webgl_loader_svg.ts
+++ b/examples-testing/examples/webgl_loader_svg.ts
@@ -3,14 +3,24 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
 
-let renderer, scene, camera, gui, guiData;
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    gui: GUI,
+    guiData: {
+        currentURL: string;
+        drawFillShapes: boolean;
+        drawStrokes: boolean;
+        fillShapesWireframe: boolean;
+        strokesWireframe: boolean;
+    };
 
 init();
 
 //
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     //
 
@@ -100,7 +110,7 @@ function createGUI() {
     }
 }
 
-function loadSVG(url) {
+function loadSVG(url: string) {
     //
 
     scene = new THREE.Scene();
@@ -126,12 +136,12 @@ function loadSVG(url) {
         let renderOrder = 0;
 
         for (const path of data.paths) {
-            const fillColor = path.userData.style.fill;
+            const fillColor = path.userData!.style.fill;
 
             if (guiData.drawFillShapes && fillColor !== undefined && fillColor !== 'none') {
                 const material = new THREE.MeshBasicMaterial({
                     color: new THREE.Color().setStyle(fillColor),
-                    opacity: path.userData.style.fillOpacity,
+                    opacity: path.userData!.style.fillOpacity,
                     transparent: true,
                     side: THREE.DoubleSide,
                     depthWrite: false,
@@ -149,12 +159,12 @@ function loadSVG(url) {
                 }
             }
 
-            const strokeColor = path.userData.style.stroke;
+            const strokeColor = path.userData!.style.stroke;
 
             if (guiData.drawStrokes && strokeColor !== undefined && strokeColor !== 'none') {
                 const material = new THREE.MeshBasicMaterial({
                     color: new THREE.Color().setStyle(strokeColor),
-                    opacity: path.userData.style.strokeOpacity,
+                    opacity: path.userData!.style.strokeOpacity,
                     transparent: true,
                     side: THREE.DoubleSide,
                     depthWrite: false,
@@ -162,7 +172,7 @@ function loadSVG(url) {
                 });
 
                 for (const subPath of path.subPaths) {
-                    const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style);
+                    const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData!.style);
 
                     if (geometry) {
                         const mesh = new THREE.Mesh(geometry, material);
diff --git a/examples-testing/examples/webgl_loader_texture_dds.ts b/examples-testing/examples/webgl_loader_texture_dds.ts
index cac02b8..9f00f89 100644
--- a/examples-testing/examples/webgl_loader_texture_dds.ts
+++ b/examples-testing/examples/webgl_loader_texture_dds.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three';
 
 import { DDSLoader } from 'three/addons/loaders/DDSLoader.js';
 
-let camera, scene, renderer;
-const meshes = [];
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+const meshes: THREE.Mesh[] = [];
 
 init();
 animate();
@@ -107,7 +107,7 @@ function init() {
     const material11 = new THREE.MeshBasicMaterial({ map: map9 });
     const material12 = new THREE.MeshBasicMaterial({ map: map10 });
 
-    let mesh = new THREE.Mesh(new THREE.TorusGeometry(), material1);
+    let mesh: THREE.Mesh = new THREE.Mesh(new THREE.TorusGeometry(), material1);
     mesh.position.x = -10;
     mesh.position.y = -2;
     scene.add(mesh);
diff --git a/examples-testing/examples/webgl_loader_texture_ktx.ts b/examples-testing/examples/webgl_loader_texture_ktx.ts
index 1bb33e0..6e66f98 100644
--- a/examples-testing/examples/webgl_loader_texture_ktx.ts
+++ b/examples-testing/examples/webgl_loader_texture_ktx.ts
@@ -17,8 +17,8 @@ import { KTXLoader } from 'three/addons/loaders/KTXLoader.js';
 	ASTC_4x4, ASTC8x8 - transparent textures with full alpha range
 	*/
 
-let camera, scene, renderer;
-const meshes = [];
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+const meshes: THREE.Mesh[] = [];
 
 init();
 animate();
@@ -51,14 +51,14 @@ function init() {
         material1 = new THREE.MeshBasicMaterial({
             map: loader.load('textures/compressed/disturb_PVR2bpp.ktx'),
         });
-        material1.map.colorSpace = THREE.SRGBColorSpace;
+        material1.map!.colorSpace = THREE.SRGBColorSpace;
         material2 = new THREE.MeshBasicMaterial({
             map: loader.load('textures/compressed/lensflare_PVR4bpp.ktx'),
             depthTest: false,
             transparent: true,
             side: THREE.DoubleSide,
         });
-        material2.map.colorSpace = THREE.SRGBColorSpace;
+        material2.map!.colorSpace = THREE.SRGBColorSpace;
 
         meshes.push(new THREE.Mesh(geometry, material1));
         meshes.push(new THREE.Mesh(geometry, material2));
@@ -68,14 +68,14 @@ function init() {
         material1 = new THREE.MeshBasicMaterial({
             map: loader.load('textures/compressed/disturb_BC1.ktx'),
         });
-        material1.map.colorSpace = THREE.SRGBColorSpace;
+        material1.map!.colorSpace = THREE.SRGBColorSpace;
         material2 = new THREE.MeshBasicMaterial({
             map: loader.load('textures/compressed/lensflare_BC3.ktx'),
             depthTest: false,
             transparent: true,
             side: THREE.DoubleSide,
         });
-        material2.map.colorSpace = THREE.SRGBColorSpace;
+        material2.map!.colorSpace = THREE.SRGBColorSpace;
 
         meshes.push(new THREE.Mesh(geometry, material1));
         meshes.push(new THREE.Mesh(geometry, material2));
@@ -93,14 +93,14 @@ function init() {
         material1 = new THREE.MeshBasicMaterial({
             map: loader.load('textures/compressed/disturb_ASTC4x4.ktx'),
         });
-        material1.map.colorSpace = THREE.SRGBColorSpace;
+        material1.map!.colorSpace = THREE.SRGBColorSpace;
         material2 = new THREE.MeshBasicMaterial({
             map: loader.load('textures/compressed/lensflare_ASTC8x8.ktx'),
             depthTest: false,
             transparent: true,
             side: THREE.DoubleSide,
         });
-        material2.map.colorSpace = THREE.SRGBColorSpace;
+        material2.map!.colorSpace = THREE.SRGBColorSpace;
 
         meshes.push(new THREE.Mesh(geometry, material1));
         meshes.push(new THREE.Mesh(geometry, material2));
diff --git a/examples-testing/examples/webgl_loader_texture_logluv.ts b/examples-testing/examples/webgl_loader_texture_logluv.ts
index 7f3fbd4..181e003 100644
--- a/examples-testing/examples/webgl_loader_texture_logluv.ts
+++ b/examples-testing/examples/webgl_loader_texture_logluv.ts
@@ -8,7 +8,7 @@ const params = {
     exposure: 2.0,
 };
 
-let renderer, scene, camera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.OrthographicCamera;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_texture_rgbm.ts b/examples-testing/examples/webgl_loader_texture_rgbm.ts
index a882cdb..a7cbf3e 100644
--- a/examples-testing/examples/webgl_loader_texture_rgbm.ts
+++ b/examples-testing/examples/webgl_loader_texture_rgbm.ts
@@ -8,7 +8,7 @@ const params = {
     exposure: 2.0,
 };
 
-let renderer, scene, camera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.OrthographicCamera;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_texture_tga.ts b/examples-testing/examples/webgl_loader_texture_tga.ts
index 0a78b0f..a8e16b1 100644
--- a/examples-testing/examples/webgl_loader_texture_tga.ts
+++ b/examples-testing/examples/webgl_loader_texture_tga.ts
@@ -5,7 +5,7 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { TGALoader } from 'three/addons/loaders/TGALoader.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_loader_texture_tiff.ts b/examples-testing/examples/webgl_loader_texture_tiff.ts
index f097774..bb5b9d9 100644
--- a/examples-testing/examples/webgl_loader_texture_tiff.ts
+++ b/examples-testing/examples/webgl_loader_texture_tiff.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 
 import { TIFFLoader } from 'three/addons/loaders/TIFFLoader.js';
 
-let renderer, scene, camera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_tilt.ts b/examples-testing/examples/webgl_loader_tilt.ts
index 2a583c2..8e3e976 100644
--- a/examples-testing/examples/webgl_loader_tilt.ts
+++ b/examples-testing/examples/webgl_loader_tilt.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { TiltLoader } from 'three/addons/loaders/TiltLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_ttf.ts b/examples-testing/examples/webgl_loader_ttf.ts
index 0dd7f41..4d6cd14 100644
--- a/examples-testing/examples/webgl_loader_ttf.ts
+++ b/examples-testing/examples/webgl_loader_ttf.ts
@@ -4,9 +4,9 @@ import { TTFLoader } from 'three/addons/loaders/TTFLoader.js';
 import { Font } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
-let container;
-let camera, cameraTarget, scene, renderer;
-let group, textMesh1, textMesh2, textGeo, material;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, cameraTarget: THREE.Vector3, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let group: THREE.Group, textMesh1: THREE.Mesh, textMesh2: THREE.Mesh, textGeo, material: THREE.MeshPhongMaterial;
 let firstLetter = true;
 
 let text = 'three.js';
@@ -17,7 +17,7 @@ const height = 20,
     bevelThickness = 2,
     bevelSize = 1.5;
 
-let font = null;
+let font: Font | null = null;
 const mirror = true;
 
 let targetRotation = 0;
@@ -108,7 +108,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentKeyDown(event) {
+function onDocumentKeyDown(event: KeyboardEvent) {
     if (firstLetter) {
         firstLetter = false;
         text = '';
@@ -128,7 +128,7 @@ function onDocumentKeyDown(event) {
     }
 }
 
-function onDocumentKeyPress(event) {
+function onDocumentKeyPress(event: KeyboardEvent) {
     const keyCode = event.which;
 
     // backspace
@@ -145,7 +145,7 @@ function onDocumentKeyPress(event) {
 
 function createText() {
     textGeo = new TextGeometry(text, {
-        font: font,
+        font: font!,
 
         size: size,
         height: height,
@@ -159,7 +159,7 @@ function createText() {
     textGeo.computeBoundingBox();
     textGeo.computeVertexNormals();
 
-    const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
+    const centerOffset = -0.5 * (textGeo.boundingBox!.max.x - textGeo.boundingBox!.min.x);
 
     textMesh1 = new THREE.Mesh(textGeo, material);
 
@@ -195,7 +195,7 @@ function refreshText() {
     createText();
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerXOnPointerDown = event.clientX - windowHalfX;
@@ -205,7 +205,7 @@ function onPointerDown(event) {
     document.addEventListener('pointerup', onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerX = event.clientX - windowHalfX;
@@ -214,7 +214,7 @@ function onPointerMove(event) {
 }
 
 function onPointerUp() {
-    if (event.isPrimary === false) return;
+    if ((event as PointerEvent).isPrimary === false) return;
 
     document.removeEventListener('pointermove', onPointerMove);
     document.removeEventListener('pointerup', onPointerUp);
diff --git a/examples-testing/examples/webgl_loader_usdz.ts b/examples-testing/examples/webgl_loader_usdz.ts
index 63bebdb..3094cab 100644
--- a/examples-testing/examples/webgl_loader_usdz.ts
+++ b/examples-testing/examples/webgl_loader_usdz.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 import { USDZLoader } from 'three/addons/loaders/USDZLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_loader_vox.ts b/examples-testing/examples/webgl_loader_vox.ts
index b536ebd..1ec3b80 100644
--- a/examples-testing/examples/webgl_loader_vox.ts
+++ b/examples-testing/examples/webgl_loader_vox.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { VOXLoader, VOXMesh } from 'three/addons/loaders/VOXLoader.js';
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_loader_vrml.ts b/examples-testing/examples/webgl_loader_vrml.ts
index 242405a..407d284 100644
--- a/examples-testing/examples/webgl_loader_vrml.ts
+++ b/examples-testing/examples/webgl_loader_vrml.ts
@@ -6,7 +6,12 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { VRMLLoader } from 'three/addons/loaders/VRMLLoader.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, stats, controls, loader;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    controls: OrbitControls,
+    loader: VRMLLoader;
 
 const params = {
     asset: 'house',
@@ -29,7 +34,7 @@ const assets = [
     'points',
 ];
 
-let vrmlScene;
+let vrmlScene: THREE.Scene;
 
 init();
 animate();
@@ -82,9 +87,14 @@ function init() {
     gui.add(params, 'asset', assets).onChange(function (value) {
         if (vrmlScene) {
             vrmlScene.traverse(function (object) {
-                if (object.material) object.material.dispose();
-                if (object.material && object.material.map) object.material.map.dispose();
-                if (object.geometry) object.geometry.dispose();
+                if ((object as THREE.Mesh).material)
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.dispose();
+                if (
+                    (object as THREE.Mesh).material &&
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).material.map
+                )
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).material.map!.dispose();
+                if ((object as THREE.Mesh).geometry) (object as THREE.Mesh).geometry.dispose();
             });
 
             scene.remove(vrmlScene);
@@ -94,7 +104,7 @@ function init() {
     });
 }
 
-function loadAsset(asset) {
+function loadAsset(asset: string) {
     loader.load('models/vrml/' + asset + '.wrl', function (object) {
         vrmlScene = object;
         scene.add(object);
diff --git a/examples-testing/examples/webgl_loader_vtk.ts b/examples-testing/examples/webgl_loader_vtk.ts
index 503dd76..b7fa273 100644
--- a/examples-testing/examples/webgl_loader_vtk.ts
+++ b/examples-testing/examples/webgl_loader_vtk.ts
@@ -5,9 +5,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import { VTKLoader } from 'three/addons/loaders/VTKLoader.js';
 
-let stats;
+let stats: Stats;
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: TrackballControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_loader_xyz.ts b/examples-testing/examples/webgl_loader_xyz.ts
index 28dd174..431c3de 100644
--- a/examples-testing/examples/webgl_loader_xyz.ts
+++ b/examples-testing/examples/webgl_loader_xyz.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import { XYZLoader } from 'three/addons/loaders/XYZLoader.js';
 
-let camera, scene, renderer, clock;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
 
-let points;
+let points: THREE.Points;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_lod.ts b/examples-testing/examples/webgl_lod.ts
index 6e00570..c6928a7 100644
--- a/examples-testing/examples/webgl_lod.ts
+++ b/examples-testing/examples/webgl_lod.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import { FlyControls } from 'three/addons/controls/FlyControls.js';
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: FlyControls;
 
 const clock = new THREE.Clock();
 
@@ -29,7 +29,7 @@ function init() {
     dirLight.position.set(0, 0, 1).normalize();
     scene.add(dirLight);
 
-    const geometry = [
+    const geometry: [THREE.IcosahedronGeometry, number][] = [
         [new THREE.IcosahedronGeometry(100, 16), 50],
         [new THREE.IcosahedronGeometry(100, 8), 300],
         [new THREE.IcosahedronGeometry(100, 4), 1000],
diff --git a/examples-testing/examples/webgl_marchingcubes.ts b/examples-testing/examples/webgl_marchingcubes.ts
index c3383ca..942abd4 100644
--- a/examples-testing/examples/webgl_marchingcubes.ts
+++ b/examples-testing/examples/webgl_marchingcubes.ts
@@ -7,17 +7,42 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { MarchingCubes } from 'three/addons/objects/MarchingCubes.js';
 import { ToonShader1, ToonShader2, ToonShaderHatching, ToonShaderDotted } from 'three/addons/shaders/ToonShader.js';
 
-let container, stats;
-
-let camera, scene, renderer;
-
-let materials, current_material;
-
-let light, pointLight, ambientLight;
-
-let effect, resolution;
-
-let effectController;
+let container: HTMLElement, stats: Stats;
+
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+
+type Material =
+    | 'shiny'
+    | 'chrome'
+    | 'liquid'
+    | 'matte'
+    | 'flat'
+    | 'textured'
+    | 'colors'
+    | 'multiColors'
+    | 'plastic'
+    | 'toon1'
+    | 'toon2'
+    | 'hatching'
+    | 'dotted';
+
+let materials: { [M in Material]: THREE.Material }, current_material: Material;
+
+let light: THREE.DirectionalLight, pointLight: THREE.PointLight, ambientLight: THREE.AmbientLight;
+
+let effect: MarchingCubes, resolution: number;
+
+let effectController: {
+    material: Material;
+    speed: number;
+    numBlobs: number;
+    resolution: number;
+    isolation: number;
+    floor: boolean;
+    wallx: boolean;
+    wallz: boolean;
+    dummy: () => void;
+} & { [M in Material]?: () => void };
 
 let time = 0;
 
@@ -27,7 +52,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     // CAMERA
 
@@ -164,7 +189,11 @@ function generateMaterials() {
     return materials;
 }
 
-function createShaderMaterial(shader, light, ambientLight) {
+function createShaderMaterial(
+    shader: { uniforms: Record<string, THREE.IUniform>; vertexShader: string; fragmentShader: string },
+    light: THREE.DirectionalLight,
+    ambientLight: THREE.AmbientLight,
+) {
     const u = THREE.UniformsUtils.clone(shader.uniforms);
 
     const vs = shader.vertexShader;
@@ -183,7 +212,7 @@ function createShaderMaterial(shader, light, ambientLight) {
 //
 
 function setupGui() {
-    const createHandler = function (id) {
+    const createHandler = function (id: Material) {
         return function () {
             current_material = id;
 
@@ -217,8 +246,8 @@ function setupGui() {
     h = gui.addFolder('Materials');
 
     for (const m in materials) {
-        effectController[m] = createHandler(m);
-        h.add(effectController, m).name(m);
+        effectController[m as Material] = createHandler(m as Material);
+        h.add(effectController as Required<typeof effectController>, m as Material).name(m);
     }
 
     // simulation
@@ -237,7 +266,14 @@ function setupGui() {
 
 // this controls content of marching cubes voxel field
 
-function updateCubes(object, time, numblobs, floor, wallx, wallz) {
+function updateCubes(
+    object: MarchingCubes,
+    time: number,
+    numblobs: number,
+    floor: boolean,
+    wallx: boolean,
+    wallz: boolean,
+) {
     object.reset();
 
     // fill the field with some metaballs
diff --git a/examples-testing/examples/webgl_materials_alphahash.ts b/examples-testing/examples/webgl_materials_alphahash.ts
index 405de7b..1bd54bf 100644
--- a/examples-testing/examples/webgl_materials_alphahash.ts
+++ b/examples-testing/examples/webgl_materials_alphahash.ts
@@ -10,9 +10,15 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { TAARenderPass } from 'three/addons/postprocessing/TAARenderPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, scene, renderer, controls, stats, mesh, material;
-
-let composer, renderPass, taaRenderPass, outputPass;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    controls,
+    stats: Stats,
+    mesh: THREE.InstancedMesh,
+    material: THREE.MeshStandardMaterial;
+
+let composer: EffectComposer, renderPass: RenderPass, taaRenderPass: TAARenderPass, outputPass: OutputPass;
 
 let needsUpdate = false;
 
diff --git a/examples-testing/examples/webgl_materials_blending.ts b/examples-testing/examples/webgl_materials_blending.ts
index 7fc33a9..721d7f6 100644
--- a/examples-testing/examples/webgl_materials_blending.ts
+++ b/examples-testing/examples/webgl_materials_blending.ts
@@ -1,7 +1,7 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
-let mapBg;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mapBg: THREE.CanvasTexture;
 
 const textureLoader = new THREE.TextureLoader();
 
@@ -21,7 +21,7 @@ function init() {
     // BACKGROUND
 
     const canvas = document.createElement('canvas');
-    const ctx = canvas.getContext('2d');
+    const ctx = canvas.getContext('2d')!;
     canvas.width = canvas.height = 128;
     ctx.fillStyle = '#ddd';
     ctx.fillRect(0, 0, 128, 128);
@@ -51,7 +51,7 @@ function init() {
         { name: 'Multiply', constant: THREE.MultiplyBlending },
     ];
 
-    const assignSRGB = texture => {
+    const assignSRGB = (texture: THREE.Texture) => {
         texture.colorSpace = THREE.SRGBColorSpace;
     };
 
@@ -70,7 +70,7 @@ function init() {
     addImageRow(map3, -150);
     addImageRow(map4, -300);
 
-    function addImageRow(map, y) {
+    function addImageRow(map: THREE.Texture, y: number) {
         for (let i = 0; i < blendings.length; i++) {
             const blending = blendings[i];
 
@@ -115,9 +115,9 @@ function onWindowResize() {
     camera.updateProjectionMatrix();
 }
 
-function generateLabelMaterial(text) {
+function generateLabelMaterial(text: string) {
     const canvas = document.createElement('canvas');
-    const ctx = canvas.getContext('2d');
+    const ctx = canvas.getContext('2d')!;
     canvas.width = 128;
     canvas.height = 32;
 
diff --git a/examples-testing/examples/webgl_materials_blending_custom.ts b/examples-testing/examples/webgl_materials_blending_custom.ts
index b039787..f8ec41e 100644
--- a/examples-testing/examples/webgl_materials_blending_custom.ts
+++ b/examples-testing/examples/webgl_materials_blending_custom.ts
@@ -2,12 +2,12 @@ import * as THREE from 'three';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mapBg;
-const materials = [];
+let mapBg: THREE.CanvasTexture;
+const materials: THREE.Material[] = [];
 
-const params = {
+const params: { blendEquation: THREE.BlendingEquation } = {
     blendEquation: THREE.AddEquation,
 };
 
@@ -35,7 +35,7 @@ function init() {
     // BACKGROUND
 
     const canvas = document.createElement('canvas');
-    const ctx = canvas.getContext('2d');
+    const ctx = canvas.getContext('2d')!;
     canvas.width = canvas.height = 128;
     ctx.fillStyle = '#ddd';
     ctx.fillRect(0, 0, 128, 128);
@@ -177,9 +177,9 @@ function onWindowResize() {
 
 //
 
-function generateLabelMaterial(text, bg) {
+function generateLabelMaterial(text: string, bg: string) {
     const canvas = document.createElement('canvas');
-    const ctx = canvas.getContext('2d');
+    const ctx = canvas.getContext('2d')!;
     canvas.width = 128;
     canvas.height = 32;
 
@@ -197,7 +197,7 @@ function generateLabelMaterial(text, bg) {
     return material;
 }
 
-function updateBlendEquation(value) {
+function updateBlendEquation(value: THREE.BlendingEquation) {
     for (const material of materials) {
         material.blendEquation = value;
     }
diff --git a/examples-testing/examples/webgl_materials_bumpmap.ts b/examples-testing/examples/webgl_materials_bumpmap.ts
index 6cc0132..b3a03b6 100644
--- a/examples-testing/examples/webgl_materials_bumpmap.ts
+++ b/examples-testing/examples/webgl_materials_bumpmap.ts
@@ -4,13 +4,13 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let container, stats, loader;
+let container: HTMLDivElement, stats: Stats, loader: GLTFLoader;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh;
+let mesh: THREE.Mesh;
 
-let spotLight;
+let spotLight: THREE.SpotLight;
 
 let mouseX = 0;
 let mouseY = 0;
@@ -72,7 +72,7 @@ function init() {
 
     loader = new GLTFLoader();
     loader.load('models/gltf/LeePerrySmith/LeePerrySmith.glb', function (gltf) {
-        createScene(gltf.scene.children[0].geometry, 1, material);
+        createScene((gltf.scene.children[0] as THREE.Mesh).geometry, 1, material);
     });
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -93,7 +93,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function createScene(geometry, scale, material) {
+function createScene(geometry: THREE.BufferGeometry, scale: number, material: THREE.Material) {
     mesh = new THREE.Mesh(geometry, material);
 
     mesh.position.y = -0.5;
@@ -114,7 +114,7 @@ function onWindowResize() {
     camera.updateProjectionMatrix();
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgl_materials_car.ts b/examples-testing/examples/webgl_materials_car.ts
index 71f918b..822f739 100644
--- a/examples-testing/examples/webgl_materials_car.ts
+++ b/examples-testing/examples/webgl_materials_car.ts
@@ -8,16 +8,16 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 
-let camera, scene, renderer;
-let stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let stats: Stats;
 
-let grid;
-let controls;
+let grid: THREE.GridHelper;
+let controls: OrbitControls;
 
-const wheels = [];
+const wheels: THREE.Object3D[] = [];
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -78,17 +78,17 @@ function init() {
         transmission: 1.0,
     });
 
-    const bodyColorInput = document.getElementById('body-color');
+    const bodyColorInput = document.getElementById('body-color') as HTMLInputElement;
     bodyColorInput.addEventListener('input', function () {
         bodyMaterial.color.set(this.value);
     });
 
-    const detailsColorInput = document.getElementById('details-color');
+    const detailsColorInput = document.getElementById('details-color') as HTMLInputElement;
     detailsColorInput.addEventListener('input', function () {
         detailsMaterial.color.set(this.value);
     });
 
-    const glassColorInput = document.getElementById('glass-color');
+    const glassColorInput = document.getElementById('glass-color') as HTMLInputElement;
     glassColorInput.addEventListener('input', function () {
         glassMaterial.color.set(this.value);
     });
@@ -106,21 +106,21 @@ function init() {
     loader.load('models/gltf/ferrari.glb', function (gltf) {
         const carModel = gltf.scene.children[0];
 
-        carModel.getObjectByName('body').material = bodyMaterial;
+        (carModel.getObjectByName('body') as THREE.Mesh).material = bodyMaterial;
 
-        carModel.getObjectByName('rim_fl').material = detailsMaterial;
-        carModel.getObjectByName('rim_fr').material = detailsMaterial;
-        carModel.getObjectByName('rim_rr').material = detailsMaterial;
-        carModel.getObjectByName('rim_rl').material = detailsMaterial;
-        carModel.getObjectByName('trim').material = detailsMaterial;
+        (carModel.getObjectByName('rim_fl') as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName('rim_fr') as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName('rim_rr') as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName('rim_rl') as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName('trim') as THREE.Mesh).material = detailsMaterial;
 
-        carModel.getObjectByName('glass').material = glassMaterial;
+        (carModel.getObjectByName('glass') as THREE.Mesh).material = glassMaterial;
 
         wheels.push(
-            carModel.getObjectByName('wheel_fl'),
-            carModel.getObjectByName('wheel_fr'),
-            carModel.getObjectByName('wheel_rl'),
-            carModel.getObjectByName('wheel_rr'),
+            carModel.getObjectByName('wheel_fl')!,
+            carModel.getObjectByName('wheel_fr')!,
+            carModel.getObjectByName('wheel_rl')!,
+            carModel.getObjectByName('wheel_rr')!,
         );
 
         // shadow
diff --git a/examples-testing/examples/webgl_materials_cubemap.ts b/examples-testing/examples/webgl_materials_cubemap.ts
index 1d6f7bf..32ecfc2 100644
--- a/examples-testing/examples/webgl_materials_cubemap.ts
+++ b/examples-testing/examples/webgl_materials_cubemap.ts
@@ -5,9 +5,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let pointLight;
 
@@ -66,7 +66,7 @@ function init() {
 
     objLoader.setPath('models/obj/walt/');
     objLoader.load('WaltHead.obj', function (object) {
-        const head = object.children[0];
+        const head = object.children[0] as THREE.Mesh;
         head.scale.setScalar(0.1);
         head.position.y = -3;
         head.material = cubeMaterial1;
diff --git a/examples-testing/examples/webgl_materials_cubemap_dynamic.ts b/examples-testing/examples/webgl_materials_cubemap_dynamic.ts
index 2212cd6..7179fb1 100644
--- a/examples-testing/examples/webgl_materials_cubemap_dynamic.ts
+++ b/examples-testing/examples/webgl_materials_cubemap_dynamic.ts
@@ -6,12 +6,12 @@ import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
-let cube, sphere, torus, material;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let cube: THREE.Mesh, sphere: THREE.Mesh, torus: THREE.Mesh, material: THREE.MeshStandardMaterial;
 
-let cubeCamera, cubeRenderTarget;
+let cubeCamera: THREE.CubeCamera, cubeRenderTarget: THREE.WebGLCubeRenderTarget;
 
-let controls;
+let controls: OrbitControls;
 
 init();
 
@@ -88,7 +88,7 @@ function onWindowResized() {
     camera.updateProjectionMatrix();
 }
 
-function animation(msTime) {
+function animation(msTime: DOMHighResTimeStamp) {
     const time = msTime / 1000;
 
     cube.position.x = Math.cos(time) * 30;
diff --git a/examples-testing/examples/webgl_materials_cubemap_mipmaps.ts b/examples-testing/examples/webgl_materials_cubemap_mipmaps.ts
index 4e46230..bf3b2dd 100644
--- a/examples-testing/examples/webgl_materials_cubemap_mipmaps.ts
+++ b/examples-testing/examples/webgl_materials_cubemap_mipmaps.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -13,11 +13,11 @@ animate();
 async function loadCubeTextureWithMipmaps() {
     const path = 'textures/cube/angus/';
     const format = '.jpg';
-    const mipmaps = [];
+    const mipmaps: THREE.CubeTexture[] = [];
     const maxLevel = 8;
 
-    async function loadCubeTexture(urls) {
-        return new Promise(function (resolve) {
+    async function loadCubeTexture(urls: string[]) {
+        return new Promise<THREE.CubeTexture>(function (resolve) {
             new THREE.CubeTextureLoader().load(urls, function (cubeTexture) {
                 resolve(cubeTexture);
             });
@@ -45,7 +45,7 @@ async function loadCubeTextureWithMipmaps() {
 
     await Promise.all(pendings);
 
-    const customizedCubeTexture = mipmaps.shift();
+    const customizedCubeTexture = mipmaps.shift()!;
     customizedCubeTexture.mipmaps = mipmaps;
     customizedCubeTexture.colorSpace = THREE.SRGBColorSpace;
     customizedCubeTexture.minFilter = THREE.LinearMipMapLinearFilter;
diff --git a/examples-testing/examples/webgl_materials_cubemap_refraction.ts b/examples-testing/examples/webgl_materials_cubemap_refraction.ts
index 1e5600b..b1f025a 100644
--- a/examples-testing/examples/webgl_materials_cubemap_refraction.ts
+++ b/examples-testing/examples/webgl_materials_cubemap_refraction.ts
@@ -4,9 +4,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let mouseX = 0,
     mouseY = 0;
@@ -84,7 +84,12 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function createScene(geometry, m1, m2, m3) {
+function createScene(
+    geometry: THREE.BufferGeometry,
+    m1: THREE.MeshPhongMaterial,
+    m2: THREE.MeshPhongMaterial,
+    m3: THREE.MeshPhongMaterial,
+) {
     geometry.computeVertexNormals();
 
     const s = 1.5;
@@ -104,7 +109,7 @@ function createScene(geometry, m1, m2, m3) {
     scene.add(mesh);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) * 4;
     mouseY = (event.clientY - windowHalfY) * 4;
 }
diff --git a/examples-testing/examples/webgl_materials_cubemap_render_to_mipmaps.ts b/examples-testing/examples/webgl_materials_cubemap_render_to_mipmaps.ts
index 1fb0d41..1c517fb 100644
--- a/examples-testing/examples/webgl_materials_cubemap_render_to_mipmaps.ts
+++ b/examples-testing/examples/webgl_materials_cubemap_render_to_mipmaps.ts
@@ -1,8 +1,8 @@
 import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container;
-let camera, scene, renderer;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const CubemapFilterShader = {
     name: 'CubemapFilterShader',
@@ -56,15 +56,15 @@ const CubemapFilterShader = {
 init();
 animate();
 
-async function loadCubeTexture(urls) {
-    return new Promise(function (resolve) {
+async function loadCubeTexture(urls: string[]) {
+    return new Promise<THREE.CubeTexture>(function (resolve) {
         new THREE.CubeTextureLoader().load(urls, function (cubeTexture) {
             resolve(cubeTexture);
         });
     });
 }
 
-function allocateCubemapRenderTarget(cubeMapSize) {
+function allocateCubemapRenderTarget(cubeMapSize: number) {
     const params = {
         magFilter: THREE.LinearFilter,
         minFilter: THREE.LinearMipMapLinearFilter,
@@ -84,7 +84,7 @@ function allocateCubemapRenderTarget(cubeMapSize) {
     return rt;
 }
 
-function renderToCubeTexture(cubeMapRenderTarget, sourceCubeTexture) {
+function renderToCubeTexture(cubeMapRenderTarget: THREE.WebGLCubeRenderTarget, sourceCubeTexture: THREE.CubeTexture) {
     const geometry = new THREE.BoxGeometry(5, 5, 5);
 
     const material = new THREE.ShaderMaterial({
diff --git a/examples-testing/examples/webgl_materials_curvature.ts b/examples-testing/examples/webgl_materials_curvature.ts
index a5d7a73..825613e 100644
--- a/examples-testing/examples/webgl_materials_curvature.ts
+++ b/examples-testing/examples/webgl_materials_curvature.ts
@@ -4,15 +4,17 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let ninjaMeshRaw, curvatureAttribute, bufferGeo;
+let ninjaMeshRaw: THREE.Mesh,
+    curvatureAttribute: Float32Array,
+    bufferGeo: THREE.BufferGeometry<Record<string, THREE.BufferAttribute>>;
 
 init();
 animate();
 
 //returns average of elements in a dictionary
-function average(dict) {
+function average(dict: Record<string, number>) {
     let sum = 0;
     let length = 0;
 
@@ -25,26 +27,26 @@ function average(dict) {
 }
 
 //clamp a number between min and max
-function clamp(number, min, max) {
+function clamp(number: number, min: number, max: number) {
     return Math.max(min, Math.min(number, max));
 }
 
 //filter the curvature array to only show concave values
-function filterConcave(curvature) {
+function filterConcave(curvature: Float32Array) {
     for (let i = 0; i < curvature.length; i++) {
         curvature[i] = Math.abs(clamp(curvature[i], -1, 0));
     }
 }
 
 //filter the curvature array to only show convex values
-function filterConvex(curvature) {
+function filterConvex(curvature: Float32Array) {
     for (let i = 0; i < curvature.length; i++) {
         curvature[i] = clamp(curvature[i], 0, 1);
     }
 }
 
 //filter the curvature array to show both the concave and convex values
-function filterBoth(curvature) {
+function filterBoth(curvature: Float32Array) {
     for (let i = 0; i < curvature.length; i++) {
         curvature[i] = Math.abs(curvature[i]);
     }
@@ -74,10 +76,12 @@ function init() {
     //load the obj
     loader.load('models/obj/ninja/ninjaHead_Low.obj', function (object) {
         object.traverse(function (child) {
-            if (child.isMesh) {
-                bufferGeo = child.geometry;
+            if ((child as THREE.Mesh).isMesh) {
+                bufferGeo = (child as THREE.Mesh).geometry as THREE.BufferGeometry<
+                    Record<string, THREE.BufferAttribute>
+                >;
                 bufferGeo.center();
-                const dict = {};
+                const dict: Record<string, Record<string, number>> = {};
 
                 for (let i = 0; i < bufferGeo.attributes.position.count; i += 3) {
                     //create a dictionary of every position, and its neighboring positions
@@ -140,7 +144,7 @@ function init() {
                     dict[strC][strB] = c2b;
                 }
 
-                let curvatureDict = {};
+                let curvatureDict: Record<string, number> = {};
                 let min = 10,
                     max = 0;
 
@@ -197,8 +201,8 @@ function init() {
                 filterBoth(curvatureFiltered);
 
                 const materialRaw = new THREE.ShaderMaterial({
-                    vertexShader: document.getElementById('vertexShaderRaw').textContent,
-                    fragmentShader: document.getElementById('fragmentShaderRaw').textContent,
+                    vertexShader: document.getElementById('vertexShaderRaw')!.textContent!,
+                    fragmentShader: document.getElementById('fragmentShaderRaw')!.textContent!,
                 });
 
                 ninjaMeshRaw = new THREE.Mesh(bufferGeo, materialRaw);
diff --git a/examples-testing/examples/webgl_materials_displacementmap.ts b/examples-testing/examples/webgl_materials_displacementmap.ts
index ebd2f34..bbc3a2d 100644
--- a/examples-testing/examples/webgl_materials_displacementmap.ts
+++ b/examples-testing/examples/webgl_materials_displacementmap.ts
@@ -6,8 +6,8 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
 
-let stats;
-let camera, scene, renderer, controls;
+let stats: Stats;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
 
 const settings = {
     metalness: 1.0,
@@ -19,9 +19,9 @@ const settings = {
     normalScale: 1.0,
 };
 
-let mesh, material;
+let mesh, material: THREE.MeshStandardMaterial;
 
-let pointLight, ambientLight;
+let pointLight: THREE.PointLight, ambientLight: THREE.AmbientLight;
 
 const height = 500; // of camera frustum
 
@@ -173,7 +173,7 @@ function init() {
 
     const loader = new OBJLoader();
     loader.load('models/obj/ninja/ninjaHead_Low.obj', function (group) {
-        const geometry = group.children[0].geometry;
+        const geometry = (group.children[0] as THREE.Mesh).geometry;
         geometry.center();
 
         mesh = new THREE.Mesh(geometry, material);
diff --git a/examples-testing/examples/webgl_materials_envmaps.ts b/examples-testing/examples/webgl_materials_envmaps.ts
index e4a70c1..5eb4ab9 100644
--- a/examples-testing/examples/webgl_materials_envmaps.ts
+++ b/examples-testing/examples/webgl_materials_envmaps.ts
@@ -3,9 +3,19 @@ import * as THREE from 'three';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let controls, camera, scene, renderer;
-let textureEquirec, textureCube;
-let sphereMesh, sphereMaterial, params;
+let controls: OrbitControls, camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let textureEquirec: THREE.Texture, textureCube: THREE.CubeTexture;
+let sphereMesh: THREE.Mesh<THREE.IcosahedronGeometry, THREE.MeshBasicMaterial>,
+    sphereMaterial: THREE.MeshBasicMaterial,
+    params: {
+        Cube: () => void;
+        Equirectangular: () => void;
+        Refraction: boolean;
+        backgroundRotationX: boolean;
+        backgroundRotationY: boolean;
+        backgroundRotationZ: boolean;
+        syncMaterial: boolean;
+    };
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_materials_envmaps_exr.ts b/examples-testing/examples/webgl_materials_envmaps_exr.ts
index be789ae..8585310 100644
--- a/examples-testing/examples/webgl_materials_envmaps_exr.ts
+++ b/examples-testing/examples/webgl_materials_envmaps_exr.ts
@@ -14,11 +14,12 @@ const params = {
     debug: false,
 };
 
-let container, stats;
-let camera, scene, renderer, controls;
-let torusMesh, planeMesh;
-let pngCubeRenderTarget, exrCubeRenderTarget;
-let pngBackground, exrBackground;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls;
+let torusMesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>,
+    planeMesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshBasicMaterial>;
+let pngCubeRenderTarget: THREE.WebGLRenderTarget, exrCubeRenderTarget: THREE.WebGLRenderTarget;
+let pngBackground: THREE.Texture, exrBackground: THREE.DataTexture;
 
 init();
 animate();
@@ -42,8 +43,8 @@ function init() {
 
     //
 
-    let geometry = new THREE.TorusKnotGeometry(18, 8, 150, 20);
-    let material = new THREE.MeshStandardMaterial({
+    let geometry: THREE.BufferGeometry = new THREE.TorusKnotGeometry(18, 8, 150, 20);
+    let material: THREE.MeshStandardMaterial | THREE.MeshBasicMaterial = new THREE.MeshStandardMaterial({
         metalness: params.metalness,
         roughness: params.roughness,
         envMapIntensity: 1.0,
diff --git a/examples-testing/examples/webgl_materials_envmaps_groundprojected.ts b/examples-testing/examples/webgl_materials_envmaps_groundprojected.ts
index fb1dc1a..22f3dfc 100644
--- a/examples-testing/examples/webgl_materials_envmaps_groundprojected.ts
+++ b/examples-testing/examples/webgl_materials_envmaps_groundprojected.ts
@@ -13,7 +13,7 @@ const params = {
     enabled: true,
 };
 
-let camera, scene, renderer, skybox;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, skybox: GroundedSkybox;
 
 init().then(render);
 
@@ -68,15 +68,15 @@ async function init() {
         carModel.scale.multiplyScalar(4);
         carModel.rotation.y = Math.PI;
 
-        carModel.getObjectByName('body').material = bodyMaterial;
+        (carModel.getObjectByName('body') as THREE.Mesh).material = bodyMaterial;
 
-        carModel.getObjectByName('rim_fl').material = detailsMaterial;
-        carModel.getObjectByName('rim_fr').material = detailsMaterial;
-        carModel.getObjectByName('rim_rr').material = detailsMaterial;
-        carModel.getObjectByName('rim_rl').material = detailsMaterial;
-        carModel.getObjectByName('trim').material = detailsMaterial;
+        (carModel.getObjectByName('rim_fl') as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName('rim_fr') as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName('rim_rr') as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName('rim_rl') as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName('trim') as THREE.Mesh).material = detailsMaterial;
 
-        carModel.getObjectByName('glass').material = glassMaterial;
+        (carModel.getObjectByName('glass') as THREE.Mesh).material = glassMaterial;
 
         // shadow
         const mesh = new THREE.Mesh(
diff --git a/examples-testing/examples/webgl_materials_envmaps_hdr.ts b/examples-testing/examples/webgl_materials_envmaps_hdr.ts
index 060be95..0186939 100644
--- a/examples-testing/examples/webgl_materials_envmaps_hdr.ts
+++ b/examples-testing/examples/webgl_materials_envmaps_hdr.ts
@@ -8,7 +8,13 @@ import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.
 import { RGBMLoader } from 'three/addons/loaders/RGBMLoader.js';
 import { DebugEnvironment } from 'three/addons/environments/DebugEnvironment.js';
 
-const params = {
+const params: {
+    envMap: 'Generated' | 'LDR' | 'HDR' | 'RGBM16';
+    roughness: number;
+    metalness: number;
+    exposure: number;
+    debug: boolean;
+} = {
     envMap: 'HDR',
     roughness: 0.0,
     metalness: 0.0,
@@ -16,11 +22,15 @@ const params = {
     debug: false,
 };
 
-let container, stats;
-let camera, scene, renderer, controls;
-let torusMesh, planeMesh;
-let generatedCubeRenderTarget, ldrCubeRenderTarget, hdrCubeRenderTarget, rgbmCubeRenderTarget;
-let ldrCubeMap, hdrCubeMap, rgbmCubeMap;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
+let torusMesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>,
+    planeMesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshBasicMaterial>;
+let generatedCubeRenderTarget: THREE.WebGLRenderTarget,
+    ldrCubeRenderTarget: THREE.WebGLRenderTarget,
+    hdrCubeRenderTarget: THREE.WebGLRenderTarget,
+    rgbmCubeRenderTarget: THREE.WebGLRenderTarget;
+let ldrCubeMap: THREE.CubeTexture, hdrCubeMap: THREE.CubeTexture, rgbmCubeMap: THREE.CubeTexture;
 
 init();
 animate();
@@ -40,9 +50,9 @@ function init() {
 
     //
 
-    let geometry = new THREE.TorusKnotGeometry(18, 8, 150, 20);
+    let geometry: THREE.BufferGeometry = new THREE.TorusKnotGeometry(18, 8, 150, 20);
     // let geometry = new THREE.SphereGeometry( 26, 64, 32 );
-    let material = new THREE.MeshStandardMaterial({
+    let material: THREE.MeshStandardMaterial | THREE.MeshBasicMaterial = new THREE.MeshStandardMaterial({
         color: 0xffffff,
         metalness: params.metalness,
         roughness: params.roughness,
diff --git a/examples-testing/examples/webgl_materials_modified.ts b/examples-testing/examples/webgl_materials_modified.ts
index 3708f65..4c1f793 100644
--- a/examples-testing/examples/webgl_materials_modified.ts
+++ b/examples-testing/examples/webgl_materials_modified.ts
@@ -5,7 +5,7 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 animate();
@@ -18,7 +18,7 @@ function init() {
 
     const loader = new GLTFLoader();
     loader.load('models/gltf/LeePerrySmith/LeePerrySmith.glb', function (gltf) {
-        const geometry = gltf.scene.children[0].geometry;
+        const geometry = (gltf.scene.children[0] as THREE.Mesh).geometry;
 
         let mesh = new THREE.Mesh(geometry, buildTwistMaterial(2.0));
         mesh.position.x = -3.5;
@@ -50,7 +50,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function buildTwistMaterial(amount) {
+function buildTwistMaterial(amount: number) {
     const material = new THREE.MeshNormalMaterial();
     material.onBeforeCompile = function (shader) {
         shader.uniforms.time = { value: 0 };
@@ -104,8 +104,8 @@ function animate() {
 
 function render() {
     scene.traverse(function (child) {
-        if (child.isMesh) {
-            const shader = child.material.userData.shader;
+        if ((child as THREE.Mesh).isMesh) {
+            const shader = ((child as THREE.Mesh).material as THREE.Material).userData.shader;
 
             if (shader) {
                 shader.uniforms.time.value = performance.now() / 1000;
diff --git a/examples-testing/examples/webgl_materials_normalmap_object_space.ts b/examples-testing/examples/webgl_materials_normalmap_object_space.ts
index 1fc6f80..7210813 100644
--- a/examples-testing/examples/webgl_materials_normalmap_object_space.ts
+++ b/examples-testing/examples/webgl_materials_normalmap_object_space.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let renderer, scene, camera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
 
 init();
 
@@ -38,19 +38,23 @@ function init() {
     // model
     new GLTFLoader().load('models/gltf/Nefertiti/Nefertiti.glb', function (gltf) {
         gltf.scene.traverse(function (child) {
-            if (child.isMesh) {
+            if ((child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).isMesh) {
                 // glTF currently supports only tangent-space normal maps.
                 // this model has been modified to demonstrate the use of an object-space normal map.
 
-                child.material.normalMapType = THREE.ObjectSpaceNormalMap;
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.normalMapType =
+                    THREE.ObjectSpaceNormalMap;
 
                 // attribute normals are not required with an object-space normal map. remove them.
 
-                child.geometry.deleteAttribute('normal');
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).geometry.deleteAttribute(
+                    'normal',
+                );
 
                 //
 
-                child.material.side = THREE.DoubleSide;
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.side =
+                    THREE.DoubleSide;
 
                 child.scale.multiplyScalar(0.5);
 
diff --git a/examples-testing/examples/webgl_materials_physical_clearcoat.ts b/examples-testing/examples/webgl_materials_physical_clearcoat.ts
index b47e815..59c87e9 100644
--- a/examples-testing/examples/webgl_materials_physical_clearcoat.ts
+++ b/examples-testing/examples/webgl_materials_physical_clearcoat.ts
@@ -7,12 +7,12 @@ import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.
 
 import { FlakesTexture } from 'three/addons/textures/FlakesTexture.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let particleLight;
-let group;
+let particleLight: THREE.Mesh;
+let group: THREE.Group;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_materials_physical_transmission.ts b/examples-testing/examples/webgl_materials_physical_transmission.ts
index d459679..6464232 100644
--- a/examples-testing/examples/webgl_materials_physical_transmission.ts
+++ b/examples-testing/examples/webgl_materials_physical_transmission.ts
@@ -19,7 +19,7 @@ const params = {
     exposure: 1,
 };
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let mesh;
 
@@ -170,7 +170,7 @@ function generateTexture() {
     canvas.width = 2;
     canvas.height = 2;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     context.fillStyle = 'white';
     context.fillRect(0, 1, 2, 1);
 
diff --git a/examples-testing/examples/webgl_materials_physical_transmission_alpha.ts b/examples-testing/examples/webgl_materials_physical_transmission_alpha.ts
index d81f59c..1e194ce 100644
--- a/examples-testing/examples/webgl_materials_physical_transmission_alpha.ts
+++ b/examples-testing/examples/webgl_materials_physical_transmission_alpha.ts
@@ -22,17 +22,20 @@ const params = {
     exposure: 1,
 };
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh, material;
+let mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhysicalMaterial>, material: THREE.MeshPhysicalMaterial;
 
 const hdrEquirect = new RGBELoader().setPath('textures/equirectangular/').load('royal_esplanade_1k.hdr', function () {
     hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;
 
     new GLTFLoader().setPath('models/gltf/').load('DragonAttenuation.glb', function (gltf) {
         gltf.scene.traverse(function (child) {
-            if (child.isMesh && child.material.isMeshPhysicalMaterial) {
-                mesh = child;
+            if (
+                (child as THREE.Mesh).isMesh &&
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhysicalMaterial>).material.isMeshPhysicalMaterial
+            ) {
+                mesh = child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhysicalMaterial>;
                 material = mesh.material;
 
                 const color = new THREE.Color();
@@ -74,7 +77,7 @@ function init() {
 
     // accommodate CSS table
     renderer.domElement.style.position = 'absolute';
-    renderer.domElement.style.top = 0;
+    renderer.domElement.style.top = '0';
 
     scene = new THREE.Scene();
 
diff --git a/examples-testing/examples/webgl_materials_texture_anisotropy.ts b/examples-testing/examples/webgl_materials_texture_anisotropy.ts
index 7be707e..158e916 100644
--- a/examples-testing/examples/webgl_materials_texture_anisotropy.ts
+++ b/examples-testing/examples/webgl_materials_texture_anisotropy.ts
@@ -5,9 +5,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 const SCREEN_WIDTH = window.innerWidth;
 const SCREEN_HEIGHT = window.innerHeight;
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene1, scene2, renderer;
+let camera: THREE.PerspectiveCamera, scene1: THREE.Scene, scene2: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let mouseX = 0,
     mouseY = 0;
@@ -71,11 +71,11 @@ function init() {
     texture2.repeat.set(512, 512);
 
     if (maxAnisotropy > 0) {
-        document.getElementById('val_left').innerHTML = texture1.anisotropy;
-        document.getElementById('val_right').innerHTML = texture2.anisotropy;
+        document.getElementById('val_left')!.innerHTML = texture1.anisotropy.toString();
+        document.getElementById('val_right')!.innerHTML = texture2.anisotropy.toString();
     } else {
-        document.getElementById('val_left').innerHTML = 'not supported';
-        document.getElementById('val_right').innerHTML = 'not supported';
+        document.getElementById('val_left')!.innerHTML = 'not supported';
+        document.getElementById('val_right')!.innerHTML = 'not supported';
     }
 
     //
@@ -110,7 +110,7 @@ function init() {
     document.addEventListener('mousemove', onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgl_materials_texture_canvas.ts b/examples-testing/examples/webgl_materials_texture_canvas.ts
index 94a8b82..11c452c 100644
--- a/examples-testing/examples/webgl_materials_texture_canvas.ts
+++ b/examples-testing/examples/webgl_materials_texture_canvas.ts
@@ -1,6 +1,10 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer, mesh, material;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    mesh: THREE.Mesh,
+    material: THREE.MeshBasicMaterial;
 const drawStartPos = new THREE.Vector2();
 
 init();
@@ -31,8 +35,8 @@ function init() {
 function setupCanvasDrawing() {
     // get canvas and context
 
-    const drawingCanvas = document.getElementById('drawing-canvas');
-    const drawingContext = drawingCanvas.getContext('2d');
+    const drawingCanvas = document.getElementById('drawing-canvas') as HTMLCanvasElement;
+    const drawingContext = drawingCanvas.getContext('2d')!;
 
     // draw white background
 
@@ -66,7 +70,7 @@ function setupCanvasDrawing() {
     });
 }
 
-function draw(drawContext, x, y) {
+function draw(drawContext: CanvasRenderingContext2D, x: number, y: number) {
     drawContext.moveTo(drawStartPos.x, drawStartPos.y);
     drawContext.strokeStyle = '#000000';
     drawContext.lineTo(x, y);
@@ -74,7 +78,7 @@ function draw(drawContext, x, y) {
     // reset drawing start position to current position.
     drawStartPos.set(x, y);
     // need to flag the map as needing updating.
-    material.map.needsUpdate = true;
+    material.map!.needsUpdate = true;
 }
 
 function onWindowResize() {
diff --git a/examples-testing/examples/webgl_materials_texture_filters.ts b/examples-testing/examples/webgl_materials_texture_filters.ts
index d995b99..df606ba 100644
--- a/examples-testing/examples/webgl_materials_texture_filters.ts
+++ b/examples-testing/examples/webgl_materials_texture_filters.ts
@@ -3,9 +3,9 @@ import * as THREE from 'three';
 const SCREEN_WIDTH = window.innerWidth;
 const SCREEN_HEIGHT = window.innerHeight;
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, scene2, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, scene2: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let mouseX = 0,
     mouseY = 0;
@@ -34,7 +34,7 @@ function init() {
     // GROUND
 
     const imageCanvas = document.createElement('canvas');
-    const context = imageCanvas.getContext('2d');
+    const context = imageCanvas.getContext('2d')!;
 
     imageCanvas.width = imageCanvas.height = 128;
 
@@ -86,7 +86,7 @@ function init() {
         addPainting(scene, mesh);
         addPainting(scene2, mesh2);
 
-        function addPainting(zscene, zmesh) {
+        function addPainting(zscene: THREE.Scene, zmesh: THREE.Mesh) {
             zmesh.scale.x = image.width / 100;
             zmesh.scale.y = image.height / 100;
 
@@ -140,7 +140,7 @@ function init() {
     document.addEventListener('mousemove', onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgl_materials_texture_manualmipmap.ts b/examples-testing/examples/webgl_materials_texture_manualmipmap.ts
index 5412912..ba58209 100644
--- a/examples-testing/examples/webgl_materials_texture_manualmipmap.ts
+++ b/examples-testing/examples/webgl_materials_texture_manualmipmap.ts
@@ -3,9 +3,9 @@ import * as THREE from 'three';
 const SCREEN_WIDTH = window.innerWidth;
 const SCREEN_HEIGHT = window.innerHeight;
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene1, scene2, renderer;
+let camera: THREE.PerspectiveCamera, scene1: THREE.Scene, scene2: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let mouseX = 0,
     mouseY = 0;
@@ -33,9 +33,9 @@ function init() {
 
     // GROUND
 
-    function mipmap(size, color) {
+    function mipmap(size: number, color: string) {
         const imageCanvas = document.createElement('canvas');
-        const context = imageCanvas.getContext('2d');
+        const context = imageCanvas.getContext('2d')!;
 
         imageCanvas.width = imageCanvas.height = size;
 
@@ -98,7 +98,7 @@ function init() {
         addPainting(scene1, mesh1);
         addPainting(scene2, mesh2);
 
-        function addPainting(zscene, zmesh) {
+        function addPainting(zscene: THREE.Scene, zmesh: THREE.Mesh) {
             zmesh.scale.x = image.width / 100;
             zmesh.scale.y = image.height / 100;
 
@@ -151,7 +151,7 @@ function init() {
     document.addEventListener('mousemove', onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgl_materials_texture_partialupdate.ts b/examples-testing/examples/webgl_materials_texture_partialupdate.ts
index 965b259..261fd2e 100644
--- a/examples-testing/examples/webgl_materials_texture_partialupdate.ts
+++ b/examples-testing/examples/webgl_materials_texture_partialupdate.ts
@@ -1,6 +1,11 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer, clock, dataTexture, diffuseMap;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    dataTexture: THREE.DataTexture,
+    diffuseMap: THREE.Texture;
 
 let last = 0;
 const position = new THREE.Vector2();
@@ -78,7 +83,7 @@ function animate() {
     renderer.render(scene, camera);
 }
 
-function updateDataTexture(texture) {
+function updateDataTexture(texture: THREE.DataTexture) {
     const size = texture.image.width * texture.image.height;
     const data = texture.image.data;
 
diff --git a/examples-testing/examples/webgl_materials_texture_rotation.ts b/examples-testing/examples/webgl_materials_texture_rotation.ts
index 2666d09..b284d9f 100644
--- a/examples-testing/examples/webgl_materials_texture_rotation.ts
+++ b/examples-testing/examples/webgl_materials_texture_rotation.ts
@@ -3,7 +3,10 @@ import * as THREE from 'three';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let mesh, renderer, scene, camera;
+let mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshBasicMaterial>,
+    renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera;
 
 let gui;
 
@@ -76,7 +79,7 @@ function onWindowResize() {
 }
 
 function updateUvTransform() {
-    const texture = mesh.material.map;
+    const texture = mesh.material.map!;
 
     if (texture.matrixAutoUpdate === true) {
         texture.offset.set(API.offsetX, API.offsetY);
diff --git a/examples-testing/examples/webgl_materials_toon.ts b/examples-testing/examples/webgl_materials_toon.ts
index 2c491fe..72afff0 100644
--- a/examples-testing/examples/webgl_materials_toon.ts
+++ b/examples-testing/examples/webgl_materials_toon.ts
@@ -4,13 +4,13 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { OutlineEffect } from 'three/addons/effects/OutlineEffect.js';
-import { FontLoader } from 'three/addons/loaders/FontLoader.js';
+import { Font, FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer, effect;
-let particleLight;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, effect: OutlineEffect;
+let particleLight: THREE.Mesh;
 
 const loader = new FontLoader();
 loader.load('fonts/gentilis_regular.typeface.json', function (font) {
@@ -18,7 +18,7 @@ loader.load('fonts/gentilis_regular.typeface.json', function (font) {
     animate();
 });
 
-function init(font) {
+function init(font: Font) {
     container = document.createElement('div');
     document.body.appendChild(container);
 
@@ -80,7 +80,7 @@ function init(font) {
         }
     }
 
-    function addLabel(name, location) {
+    function addLabel(name: string, location: THREE.Vector3) {
         const textGeo = new TextGeometry(name, {
             font: font,
 
diff --git a/examples-testing/examples/webgl_materials_video.ts b/examples-testing/examples/webgl_materials_video.ts
index 6505cc0..9d69900 100644
--- a/examples-testing/examples/webgl_materials_video.ts
+++ b/examples-testing/examples/webgl_materials_video.ts
@@ -5,13 +5,16 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { BloomPass } from 'three/addons/postprocessing/BloomPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let video, texture, material, mesh;
+let video,
+    texture,
+    material: THREE.MeshLambertMaterial & { hue?: number; saturation?: number },
+    mesh: THREE.Mesh & { dx?: number; dy?: number };
 
-let composer;
+let composer: EffectComposer;
 
 let mouseX = 0;
 let mouseY = 0;
@@ -19,21 +22,21 @@ let mouseY = 0;
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
 
-let cube_count;
+let cube_count: number;
 
-const meshes = [],
-    materials = [],
+const meshes: THREE.Mesh[] = [],
+    materials: (THREE.MeshLambertMaterial & { hue?: number; saturation?: number })[] = [],
     xgrid = 20,
     ygrid = 10;
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', function () {
     init();
     animate();
 });
 
 function init() {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
     container = document.createElement('div');
@@ -53,7 +56,7 @@ function init() {
     renderer.setSize(window.innerWidth, window.innerHeight);
     container.appendChild(renderer.domElement);
 
-    video = document.getElementById('video');
+    video = document.getElementById('video') as HTMLVideoElement;
     video.play();
     video.addEventListener('play', function () {
         this.currentTime = 3;
@@ -145,7 +148,7 @@ function onWindowResize() {
     composer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function change_uvs(geometry, unitx, unity, offsetx, offsety) {
+function change_uvs(geometry: THREE.BoxGeometry, unitx: number, unity: number, offsetx: number, offsety: number) {
     const uvs = geometry.attributes.uv.array;
 
     for (let i = 0; i < uvs.length; i += 2) {
@@ -154,7 +157,7 @@ function change_uvs(geometry, unitx, unity, offsetx, offsety) {
     }
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = (event.clientY - windowHalfY) * 0.3;
 }
@@ -181,20 +184,20 @@ function render() {
     for (let i = 0; i < cube_count; i++) {
         material = materials[i];
 
-        h = ((360 * (material.hue + time)) % 360) / 360;
-        material.color.setHSL(h, material.saturation, 0.5);
+        h = ((360 * (material.hue! + time)) % 360) / 360;
+        material.color.setHSL(h, material.saturation!, 0.5);
     }
 
     if (counter % 1000 > 200) {
         for (let i = 0; i < cube_count; i++) {
             mesh = meshes[i];
 
-            mesh.rotation.x += 10 * mesh.dx;
-            mesh.rotation.y += 10 * mesh.dy;
+            mesh.rotation.x += 10 * mesh.dx!;
+            mesh.rotation.y += 10 * mesh.dy!;
 
-            mesh.position.x -= 150 * mesh.dx;
-            mesh.position.y += 150 * mesh.dy;
-            mesh.position.z += 300 * mesh.dx;
+            mesh.position.x -= 150 * mesh.dx!;
+            mesh.position.y += 150 * mesh.dy!;
+            mesh.position.z += 300 * mesh.dx!;
         }
     }
 
@@ -202,8 +205,8 @@ function render() {
         for (let i = 0; i < cube_count; i++) {
             mesh = meshes[i];
 
-            mesh.dx *= -1;
-            mesh.dy *= -1;
+            mesh.dx! *= -1;
+            mesh.dy! *= -1;
         }
     }
 
diff --git a/examples-testing/examples/webgl_materials_video_webcam.ts b/examples-testing/examples/webgl_materials_video_webcam.ts
index 26c7c13..5999082 100644
--- a/examples-testing/examples/webgl_materials_video_webcam.ts
+++ b/examples-testing/examples/webgl_materials_video_webcam.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, video;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, video: HTMLVideoElement;
 
 init();
 animate();
@@ -13,7 +13,7 @@ function init() {
 
     scene = new THREE.Scene();
 
-    video = document.getElementById('video');
+    video = document.getElementById('video') as HTMLVideoElement;
 
     const texture = new THREE.VideoTexture(video);
     texture.colorSpace = THREE.SRGBColorSpace;
diff --git a/examples-testing/examples/webgl_materials_wireframe.ts b/examples-testing/examples/webgl_materials_wireframe.ts
index 569afc6..ab307d8 100644
--- a/examples-testing/examples/webgl_materials_wireframe.ts
+++ b/examples-testing/examples/webgl_materials_wireframe.ts
@@ -8,7 +8,10 @@ const API = {
     thickness: 1,
 };
 
-let renderer, scene, camera, mesh2;
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    mesh2: THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>;
 
 init();
 
@@ -50,8 +53,8 @@ function init() {
 
         const material2 = new THREE.ShaderMaterial({
             uniforms: { thickness: { value: API.thickness } },
-            vertexShader: document.getElementById('vertexShader').textContent,
-            fragmentShader: document.getElementById('fragmentShader').textContent,
+            vertexShader: document.getElementById('vertexShader')!.textContent!,
+            fragmentShader: document.getElementById('fragmentShader')!.textContent!,
             side: THREE.DoubleSide,
             alphaToCoverage: true, // only works when WebGLRenderer's "antialias" is set to "true"
         });
@@ -83,7 +86,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function setupAttributes(geometry) {
+function setupAttributes(geometry: THREE.BufferGeometry) {
     const vectors = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];
 
     const position = geometry.attributes.position;
diff --git a/examples-testing/examples/webgl_math_obb.ts b/examples-testing/examples/webgl_math_obb.ts
index f9d12ec..bb55bcf 100644
--- a/examples-testing/examples/webgl_math_obb.ts
+++ b/examples-testing/examples/webgl_math_obb.ts
@@ -5,9 +5,16 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, clock, controls, stats, raycaster, hitbox;
-
-const objects = [],
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    controls: OrbitControls,
+    stats: Stats,
+    raycaster: THREE.Raycaster,
+    hitbox: THREE.Mesh;
+
+const objects: THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial>[] = [],
     mouse = new THREE.Vector2();
 
 init();
@@ -89,7 +96,7 @@ function init() {
     document.addEventListener('click', onClick);
 }
 
-function onClick(event) {
+function onClick(event: MouseEvent) {
     event.preventDefault();
 
     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
@@ -125,7 +132,10 @@ function onClick(event) {
     }
 }
 
-function sortIntersections(a, b) {
+function sortIntersections(
+    a: { distance: number; object: THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial> },
+    b: { distance: number; object: THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial> },
+) {
     return a.distance - b.distance;
 }
 
diff --git a/examples-testing/examples/webgl_math_orientation_transform.ts b/examples-testing/examples/webgl_math_orientation_transform.ts
index dfca0ac..bfa38b8 100644
--- a/examples-testing/examples/webgl_math_orientation_transform.ts
+++ b/examples-testing/examples/webgl_math_orientation_transform.ts
@@ -1,6 +1,10 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer, mesh, target;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    mesh: THREE.Mesh,
+    target: THREE.Mesh;
 
 const spherical = new THREE.Spherical();
 const rotationMatrix = new THREE.Matrix4();
diff --git a/examples-testing/examples/webgl_mesh_batch.ts b/examples-testing/examples/webgl_mesh_batch.ts
index 57a3ad8..e71bce8 100644
--- a/examples-testing/examples/webgl_mesh_batch.ts
+++ b/examples-testing/examples/webgl_mesh_batch.ts
@@ -4,12 +4,12 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { radixSort } from 'three/addons/utils/SortUtils.js';
+import { RadixSortOptions, radixSort } from 'three/addons/utils/SortUtils.js';
 
-let stats, gui, guiStatsEl;
-let camera, controls, scene, renderer;
-let geometries, mesh, material;
-const ids = [];
+let stats: Stats, gui: GUI, guiStatsEl: HTMLLIElement;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let geometries: THREE.BufferGeometry[], mesh: THREE.Group | THREE.BatchedMesh, material: THREE.MeshNormalMaterial;
+const ids: number[] = [];
 const matrix = new THREE.Matrix4();
 
 //
@@ -46,7 +46,7 @@ animate();
 
 //
 
-function randomizeMatrix(matrix) {
+function randomizeMatrix(matrix: THREE.Matrix4) {
     position.x = Math.random() * 40 - 20;
     position.y = Math.random() * 40 - 20;
     position.z = Math.random() * 40 - 20;
@@ -62,7 +62,7 @@ function randomizeMatrix(matrix) {
     return matrix.compose(position, quaternion, scale);
 }
 
-function randomizeRotationSpeed(rotation) {
+function randomizeRotationSpeed(rotation: THREE.Euler) {
     rotation.x = Math.random() * 0.01;
     rotation.y = Math.random() * 0.01;
     rotation.z = Math.random() * 0.01;
@@ -87,10 +87,10 @@ function createMaterial() {
 
 function cleanup() {
     if (mesh) {
-        mesh.parent.remove(mesh);
+        mesh.parent!.remove(mesh);
 
-        if (mesh.dispose) {
-            mesh.dispose();
+        if ((mesh as THREE.BatchedMesh).dispose) {
+            (mesh as THREE.BatchedMesh).dispose();
         }
     }
 }
@@ -213,18 +213,26 @@ function init() {
 
 //
 
-function sortFunction(list, camera) {
+type BatchedMeshWithOptions = THREE.BatchedMesh & {
+    _options?: RadixSortOptions<{ start: number; count: number; z: number }>;
+};
+
+function sortFunction(
+    this: THREE.BatchedMesh,
+    list: { start: number; count: number; z: number }[],
+    camera: THREE.Camera,
+) {
     // initialize options
-    this._options = this._options || {
+    (this as BatchedMeshWithOptions)._options = (this as BatchedMeshWithOptions)._options || {
         get: el => el.z,
         aux: new Array(this.maxGeometryCount),
     };
 
-    const options = this._options;
+    const options = (this as BatchedMeshWithOptions)._options!;
     options.reversed = this.material.transparent;
 
     // convert depth to unsigned 32 bit range
-    const factor = (2 ** 32 - 1) / camera.far; // UINT32_MAX / max_depth
+    const factor = (2 ** 32 - 1) / (camera as THREE.PerspectiveCamera).far; // UINT32_MAX / max_depth
     for (let i = 0, l = list.length; i < l; i++) {
         list[i].z *= factor;
     }
@@ -262,9 +270,9 @@ function animateMeshes() {
             const rotationMatrix = mesh.userData.rotationSpeeds[i];
             const id = ids[i];
 
-            mesh.getMatrixAt(id, matrix);
+            (mesh as THREE.BatchedMesh).getMatrixAt(id, matrix);
             matrix.multiply(rotationMatrix);
-            mesh.setMatrixAt(id, matrix);
+            (mesh as THREE.BatchedMesh).setMatrixAt(id, matrix);
         }
     } else {
         for (let i = 0; i < loopNum; i++) {
@@ -281,10 +289,10 @@ function animateMeshes() {
 }
 
 function render() {
-    if (mesh.isBatchedMesh) {
-        mesh.sortObjects = api.sortObjects;
-        mesh.perObjectFrustumCulled = api.perObjectFrustumCulled;
-        mesh.setCustomSort(api.useCustomSort ? sortFunction : null);
+    if ((mesh as THREE.BatchedMesh).isBatchedMesh) {
+        (mesh as THREE.BatchedMesh).sortObjects = api.sortObjects;
+        (mesh as THREE.BatchedMesh).perObjectFrustumCulled = api.perObjectFrustumCulled;
+        (mesh as THREE.BatchedMesh).setCustomSort(api.useCustomSort ? sortFunction : null);
     }
 
     renderer.render(scene, camera);
diff --git a/examples-testing/examples/webgl_mirror.ts b/examples-testing/examples/webgl_mirror.ts
index 5e68213..e4850ea 100644
--- a/examples-testing/examples/webgl_mirror.ts
+++ b/examples-testing/examples/webgl_mirror.ts
@@ -3,19 +3,19 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Reflector } from 'three/addons/objects/Reflector.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let cameraControls;
+let cameraControls: OrbitControls;
 
-let sphereGroup, smallSphere;
+let sphereGroup: THREE.Object3D, smallSphere: THREE.Mesh;
 
-let groundMirror, verticalMirror;
+let groundMirror: Reflector, verticalMirror: Reflector;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     // renderer
     renderer = new THREE.WebGLRenderer({ antialias: true });
diff --git a/examples-testing/examples/webgl_modifier_edgesplit.ts b/examples-testing/examples/webgl_modifier_edgesplit.ts
index 4725eff..96620f5 100644
--- a/examples-testing/examples/webgl_modifier_edgesplit.ts
+++ b/examples-testing/examples/webgl_modifier_edgesplit.ts
@@ -7,9 +7,11 @@ import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js'
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let renderer, scene, camera;
-let modifier, mesh, baseGeometry;
-let map;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let modifier: EdgeSplitModifier,
+    mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>,
+    baseGeometry: THREE.BufferGeometry;
+let map: THREE.Texture;
 
 const params = {
     smoothShading: true,
@@ -50,7 +52,7 @@ function init() {
     scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 3));
 
     new OBJLoader().load('./models/obj/cerberus/Cerberus.obj', function (group) {
-        const cerberus = group.children[0];
+        const cerberus = group.children[0] as THREE.Mesh;
         const modelGeometry = cerberus.geometry;
 
         modifier = new EdgeSplitModifier();
diff --git a/examples-testing/examples/webgl_modifier_simplifier.ts b/examples-testing/examples/webgl_modifier_simplifier.ts
index e6ea453..f55a658 100644
--- a/examples-testing/examples/webgl_modifier_simplifier.ts
+++ b/examples-testing/examples/webgl_modifier_simplifier.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { SimplifyModifier } from 'three/addons/modifiers/SimplifyModifier.js';
 
-let renderer, scene, camera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
 
 init();
 
@@ -47,7 +47,7 @@ function init() {
 
         const modifier = new SimplifyModifier();
 
-        const simplified = mesh.clone();
+        const simplified = mesh.clone() as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
         simplified.material = simplified.material.clone();
         simplified.material.flatShading = true;
         const count = Math.floor(simplified.geometry.attributes.position.count * 0.875); // number of vertices to remove
diff --git a/examples-testing/examples/webgl_modifier_tessellation.ts b/examples-testing/examples/webgl_modifier_tessellation.ts
index ad9ed59..cd8f4e0 100644
--- a/examples-testing/examples/webgl_modifier_tessellation.ts
+++ b/examples-testing/examples/webgl_modifier_tessellation.ts
@@ -4,14 +4,14 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import { TessellateModifier } from 'three/addons/modifiers/TessellateModifier.js';
-import { FontLoader } from 'three/addons/loaders/FontLoader.js';
+import { Font, FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let controls;
+let controls: TrackballControls;
 
-let mesh, uniforms;
+let mesh: THREE.Mesh, uniforms: Record<string, THREE.IUniform<unknown>>;
 
 const WIDTH = window.innerWidth;
 const HEIGHT = window.innerHeight;
@@ -22,7 +22,7 @@ loader.load('fonts/helvetiker_bold.typeface.json', function (font) {
     animate();
 });
 
-function init(font) {
+function init(font: Font) {
     camera = new THREE.PerspectiveCamera(40, WIDTH / HEIGHT, 1, 10000);
     camera.position.set(-100, 100, 200);
 
@@ -91,8 +91,8 @@ function init(font) {
 
     const shaderMaterial = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
     });
 
     //
@@ -105,7 +105,7 @@ function init(font) {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(WIDTH, HEIGHT);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     controls = new TrackballControls(camera, renderer.domElement);
diff --git a/examples-testing/examples/webgl_morphtargets.ts b/examples-testing/examples/webgl_morphtargets.ts
index 40d605f..5965ef3 100644
--- a/examples-testing/examples/webgl_morphtargets.ts
+++ b/examples-testing/examples/webgl_morphtargets.ts
@@ -3,12 +3,16 @@ import * as THREE from 'three';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container, camera, scene, renderer, mesh;
+let container: HTMLElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    mesh: THREE.Mesh;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
     scene.background = new THREE.Color(0x8fbcd4);
@@ -62,7 +66,7 @@ function createGeometry() {
     const spherePositions = [];
 
     // for the second morph target, we'll twist the cubes vertices
-    const twistPositions = [];
+    const twistPositions: number[] = [];
     const direction = new THREE.Vector3(1, 0, 0);
     const vertex = new THREE.Vector3();
 
@@ -103,12 +107,12 @@ function initGUI() {
     gui.add(params, 'Spherify', 0, 1)
         .step(0.01)
         .onChange(function (value) {
-            mesh.morphTargetInfluences[0] = value;
+            mesh.morphTargetInfluences![0] = value;
         });
     gui.add(params, 'Twist', 0, 1)
         .step(0.01)
         .onChange(function (value) {
-            mesh.morphTargetInfluences[1] = value;
+            mesh.morphTargetInfluences![1] = value;
         });
 }
 
diff --git a/examples-testing/examples/webgl_morphtargets_face.ts b/examples-testing/examples/webgl_morphtargets_face.ts
index 5e8bf1d..811c4db 100644
--- a/examples-testing/examples/webgl_morphtargets_face.ts
+++ b/examples-testing/examples/webgl_morphtargets_face.ts
@@ -15,7 +15,7 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 init();
 
 function init() {
-    let mixer;
+    let mixer: THREE.AnimationMixer;
 
     const clock = new THREE.Clock();
 
@@ -50,13 +50,13 @@ function init() {
 
             // GUI
 
-            const head = mesh.getObjectByName('mesh_2');
-            const influences = head.morphTargetInfluences;
+            const head = mesh.getObjectByName('mesh_2') as THREE.Mesh;
+            const influences = head.morphTargetInfluences!;
 
             const gui = new GUI();
             gui.close();
 
-            for (const [key, value] of Object.entries(head.morphTargetDictionary)) {
+            for (const [key, value] of Object.entries(head.morphTargetDictionary!)) {
                 gui.add(influences, value, 0, 1, 0.01).name(key.replace('blendShape1.', '')).listen();
             }
         });
diff --git a/examples-testing/examples/webgl_morphtargets_horse.ts b/examples-testing/examples/webgl_morphtargets_horse.ts
index e8253d2..5c1b3e1 100644
--- a/examples-testing/examples/webgl_morphtargets_horse.ts
+++ b/examples-testing/examples/webgl_morphtargets_horse.ts
@@ -4,9 +4,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let container, stats;
-let camera, scene, renderer;
-let mesh, mixer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mesh: THREE.Object3D, mixer: THREE.AnimationMixer;
 
 const radius = 600;
 let theta = 0;
diff --git a/examples-testing/examples/webgl_morphtargets_sphere.ts b/examples-testing/examples/webgl_morphtargets_sphere.ts
index 305889a..2885ad1 100644
--- a/examples-testing/examples/webgl_morphtargets_sphere.ts
+++ b/examples-testing/examples/webgl_morphtargets_sphere.ts
@@ -4,9 +4,9 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { Timer } from 'three/addons/misc/Timer.js';
 
-let camera, scene, renderer, timer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, timer: Timer;
 
-let mesh;
+let mesh: THREE.Mesh;
 
 let sign = 1;
 const speed = 0.5;
@@ -15,7 +15,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.2, 100);
     camera.position.set(0, 5, 5);
@@ -36,7 +36,7 @@ function init() {
 
     const loader = new GLTFLoader();
     loader.load('models/gltf/AnimatedMorphSphere/glTF/AnimatedMorphSphere.gltf', function (gltf) {
-        mesh = gltf.scene.getObjectByName('AnimatedMorphSphere');
+        mesh = gltf.scene.getObjectByName('AnimatedMorphSphere') as THREE.Mesh;
         mesh.rotation.z = Math.PI / 2;
         scene.add(mesh);
 
@@ -95,9 +95,9 @@ function render() {
 
         mesh.rotation.y += step;
 
-        mesh.morphTargetInfluences[1] = mesh.morphTargetInfluences[1] + step * sign;
+        mesh.morphTargetInfluences![1] = mesh.morphTargetInfluences![1] + step * sign;
 
-        if (mesh.morphTargetInfluences[1] <= 0 || mesh.morphTargetInfluences[1] >= 1) {
+        if (mesh.morphTargetInfluences![1] <= 0 || mesh.morphTargetInfluences![1] >= 1) {
             sign *= -1;
         }
     }
diff --git a/examples-testing/examples/webgl_multiple_elements.ts b/examples-testing/examples/webgl_multiple_elements.ts
index e21b51c..1b1f7d7 100644
--- a/examples-testing/examples/webgl_multiple_elements.ts
+++ b/examples-testing/examples/webgl_multiple_elements.ts
@@ -2,15 +2,15 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let canvas, renderer;
+let canvas: HTMLCanvasElement, renderer: THREE.WebGLRenderer;
 
-const scenes = [];
+const scenes: THREE.Scene[] = [];
 
 init();
 animate();
 
 function init() {
-    canvas = document.getElementById('c');
+    canvas = document.getElementById('c') as HTMLCanvasElement;
 
     const geometries = [
         new THREE.BoxGeometry(1, 1, 1),
@@ -19,7 +19,7 @@ function init() {
         new THREE.CylinderGeometry(0.5, 0.5, 1, 12),
     ];
 
-    const content = document.getElementById('content');
+    const content = document.getElementById('content')!;
 
     for (let i = 0; i < 40; i++) {
         const scene = new THREE.Scene();
diff --git a/examples-testing/examples/webgl_multiple_scenes_comparison.ts b/examples-testing/examples/webgl_multiple_scenes_comparison.ts
index 1753aec..4d55dc8 100644
--- a/examples-testing/examples/webgl_multiple_scenes_comparison.ts
+++ b/examples-testing/examples/webgl_multiple_scenes_comparison.ts
@@ -2,15 +2,15 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container, camera, renderer, controls;
-let sceneL, sceneR;
+let container: HTMLElement, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, controls: OrbitControls;
+let sceneL: THREE.Scene, sceneR: THREE.Scene;
 
 let sliderPos = window.innerWidth / 2;
 
 init();
 
 function init() {
-    container = document.querySelector('.container');
+    container = document.querySelector('.container')!;
 
     sceneL = new THREE.Scene();
     sceneL.background = new THREE.Color(0xbcd48f);
@@ -52,9 +52,9 @@ function initMeshes() {
 }
 
 function initSlider() {
-    const slider = document.querySelector('.slider');
+    const slider = document.querySelector('.slider') as HTMLElement;
 
-    function onPointerDown() {
+    function onPointerDown(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
         controls.enabled = false;
@@ -70,10 +70,10 @@ function initSlider() {
         window.removeEventListener('pointerup', onPointerUp);
     }
 
-    function onPointerMove(e) {
+    function onPointerMove(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
-        sliderPos = Math.max(0, Math.min(window.innerWidth, e.pageX));
+        sliderPos = Math.max(0, Math.min(window.innerWidth, event.pageX));
 
         slider.style.left = sliderPos - slider.offsetWidth / 2 + 'px';
     }
diff --git a/examples-testing/examples/webgl_multiple_views.ts b/examples-testing/examples/webgl_multiple_views.ts
index 94987b7..4e920e2 100644
--- a/examples-testing/examples/webgl_multiple_views.ts
+++ b/examples-testing/examples/webgl_multiple_views.ts
@@ -2,16 +2,27 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let stats;
+let stats: Stats;
 
-let scene, renderer;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let mouseX = 0,
     mouseY = 0;
 
-let windowWidth, windowHeight;
-
-const views = [
+let windowWidth: number, windowHeight: number;
+
+const views: {
+    left: number;
+    bottom: number;
+    width: number;
+    height: number;
+    background: THREE.Color;
+    eye: [number, number, number];
+    up: [number, number, number];
+    fov: number;
+    updateCamera: (camera: THREE.PerspectiveCamera, scene: THREE.Scene, mouseX: number, mouseY: number) => void;
+    camera?: THREE.PerspectiveCamera;
+}[] = [
     {
         left: 0,
         bottom: 0,
@@ -63,7 +74,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     for (let ii = 0; ii < views.length; ++ii) {
         const view = views[ii];
@@ -85,7 +96,7 @@ function init() {
     canvas.width = 128;
     canvas.height = 128;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     const gradient = context.createRadialGradient(
         canvas.width / 2,
         canvas.height / 2,
@@ -191,7 +202,7 @@ function init() {
     document.addEventListener('mousemove', onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowWidth / 2;
     mouseY = event.clientY - windowHeight / 2;
 }
@@ -217,7 +228,7 @@ function render() {
 
     for (let ii = 0; ii < views.length; ++ii) {
         const view = views[ii];
-        const camera = view.camera;
+        const camera = view.camera!;
 
         view.updateCamera(camera, scene, mouseX, mouseY);
 
diff --git a/examples-testing/examples/webgl_nodes_loader_gltf_iridescence.ts b/examples-testing/examples/webgl_nodes_loader_gltf_iridescence.ts
index 6ff0f3b..c845683 100644
--- a/examples-testing/examples/webgl_nodes_loader_gltf_iridescence.ts
+++ b/examples-testing/examples/webgl_nodes_loader_gltf_iridescence.ts
@@ -7,7 +7,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 
-let renderer, scene, camera, controls;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
 
 init().catch(function (err) {
     console.error(err);
@@ -42,21 +42,21 @@ async function init() {
     // nodes
 
     gltf.scene.traverse(mesh => {
-        const material = mesh.material;
+        const material = (mesh as THREE.Mesh).material;
 
-        if (material && material.iridescence > 0) {
+        if (material && (material as THREE.MeshPhysicalMaterial).iridescence > 0) {
             const iridescenceFactorNode = checker(
                 uv()
                     .add(vec2(timerLocal(-0.05), 0))
                     .mul(20),
             );
 
-            const nodeMaterial = NodeMaterial.fromMaterial(material); // @TODO: NodeMaterial.fromMaterial can be removed if WebGLNodes will apply it by default (as in WebGPURenderer)
+            const nodeMaterial = NodeMaterial.fromMaterial(material as THREE.MeshPhysicalMaterial); // @TODO: NodeMaterial.fromMaterial can be removed if WebGLNodes will apply it by default (as in WebGPURenderer)
             nodeMaterial.iridescenceNode = iridescenceFactorNode;
             nodeMaterial.iridescenceIORNode = float(1.3);
             nodeMaterial.iridescenceThicknessNode = float(400);
 
-            mesh.material = nodeMaterial;
+            (mesh as THREE.Mesh).material = nodeMaterial;
         }
     });
 
diff --git a/examples-testing/examples/webgl_nodes_loader_gltf_sheen.ts b/examples-testing/examples/webgl_nodes_loader_gltf_sheen.ts
index 589658f..473434d 100644
--- a/examples-testing/examples/webgl_nodes_loader_gltf_sheen.ts
+++ b/examples-testing/examples/webgl_nodes_loader_gltf_sheen.ts
@@ -7,7 +7,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
 
 init();
 animate();
@@ -26,10 +26,10 @@ function init() {
     new GLTFLoader().setPath('models/gltf/').load('SheenChair.glb', function (gltf) {
         scene.add(gltf.scene);
 
-        const object = gltf.scene.getObjectByName('SheenChair_fabric');
+        const object = gltf.scene.getObjectByName('SheenChair_fabric') as THREE.Mesh;
 
         // Convert to NodeMaterial
-        const material = NodeMaterial.fromMaterial(object.material); // @TODO: NodeMaterial.fromMaterial can be removed if WebGLNodes will apply it by default (as in WebGPURenderer)
+        const material = NodeMaterial.fromMaterial(object.material as THREE.MeshPhysicalMaterial); // @TODO: NodeMaterial.fromMaterial can be removed if WebGLNodes will apply it by default (as in WebGPURenderer)
 
         const checkerNode = checker(uv().mul(5));
 
diff --git a/examples-testing/examples/webgl_nodes_loader_materialx.ts b/examples-testing/examples/webgl_nodes_loader_materialx.ts
index a70415a..371f648 100644
--- a/examples-testing/examples/webgl_nodes_loader_materialx.ts
+++ b/examples-testing/examples/webgl_nodes_loader_materialx.ts
@@ -1,11 +1,11 @@
 import * as THREE from 'three';
 
-import { MaterialXLoader } from './jsm/loaders/MaterialXLoader.js';
-import { OrbitControls } from './jsm/controls/OrbitControls.js';
-import { RGBELoader } from './jsm/loaders/RGBELoader.js';
-import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
+import { MaterialXLoader } from 'three/addons/loaders/MaterialXLoader.js';
+import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
+import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
+import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-import { nodeFrame } from './jsm/renderers/webgl-legacy/nodes/WebGLNodes.js';
+import { nodeFrame } from 'three/addons/renderers/webgl-legacy/nodes/WebGLNodes.js';
 
 const SAMPLE_PATH =
     'https://raw.githubusercontent.com/materialx/MaterialX/main/resources/Materials/Examples/StandardSurface/';
@@ -34,8 +34,8 @@ const samples = [
     'standard_surface_wood_tiled.mtlx',
 ];
 
-let camera, scene, renderer, prefab;
-const models = [];
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, prefab: THREE.Group;
+const models: THREE.Group[] = [];
 
 init();
 
@@ -98,7 +98,7 @@ function updateModelsAlign() {
     }
 }
 
-async function addSample(sample) {
+async function addSample(sample: string) {
     const model = prefab.clone();
 
     models.push(model);
@@ -109,15 +109,15 @@ async function addSample(sample) {
 
     //
 
-    const material = await new MaterialXLoader()
+    const material = (await new MaterialXLoader()
         .setPath(SAMPLE_PATH)
         .loadAsync(sample)
-        .then(({ materials }) => Object.values(materials).pop());
+        .then(({ materials }) => Object.values(materials).pop()))!;
 
-    const calibrationMesh = model.getObjectByName('Calibration_Mesh');
+    const calibrationMesh = model.getObjectByName('Calibration_Mesh') as THREE.Mesh;
     calibrationMesh.material = material;
 
-    const Preview_Mesh = model.getObjectByName('Preview_Mesh');
+    const Preview_Mesh = model.getObjectByName('Preview_Mesh') as THREE.Mesh;
     Preview_Mesh.material = material;
 }
 
diff --git a/examples-testing/examples/webgl_nodes_materials_instance_uniform.ts b/examples-testing/examples/webgl_nodes_materials_instance_uniform.ts
index 0c911aa..ec8e186 100644
--- a/examples-testing/examples/webgl_nodes_materials_instance_uniform.ts
+++ b/examples-testing/examples/webgl_nodes_materials_instance_uniform.ts
@@ -1,5 +1,15 @@
 import * as THREE from 'three';
-import { MeshStandardNodeMaterial, Node, NodeUpdateType, nodeObject, uniform, cubeTexture } from 'three/nodes';
+import {
+    MeshStandardNodeMaterial,
+    Node,
+    NodeUpdateType,
+    nodeObject,
+    uniform,
+    cubeTexture,
+    NodeFrame,
+    NodeBuilder,
+    UniformNode,
+} from 'three/nodes';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
@@ -8,6 +18,8 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { nodeFrame } from 'three/addons/renderers/webgl-legacy/nodes/WebGLNodes.js';
 
 class InstanceUniformNode extends Node {
+    uniformNode: UniformNode<THREE.Color>;
+
     constructor() {
         super('vec3');
 
@@ -16,22 +28,22 @@ class InstanceUniformNode extends Node {
         this.uniformNode = uniform(new THREE.Color());
     }
 
-    update(frame) {
-        this.uniformNode.value.copy(frame.object.color);
+    update(frame: NodeFrame) {
+        this.uniformNode.value.copy((frame.object as THREE.Mesh & { color: THREE.Color }).color);
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null) {
         return this.uniformNode.build(builder, output);
     }
 }
 
-let stats;
+let stats: Stats;
 
-let camera, scene, renderer;
-let controls;
-let pointLight;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controls: OrbitControls;
+let pointLight: THREE.PointLight;
 
-const objects = [];
+const objects: THREE.Mesh[] = [];
 
 init();
 animate();
@@ -126,10 +138,10 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function addMesh(geometry, material) {
+function addMesh(geometry: THREE.SphereGeometry, material: MeshStandardNodeMaterial) {
     const mesh = new THREE.Mesh(geometry, material);
 
-    mesh.color = new THREE.Color(Math.random() * 0xffffff);
+    (mesh as THREE.Mesh & { color?: THREE.Color }).color = new THREE.Color(Math.random() * 0xffffff);
 
     mesh.position.x = (objects.length % 4) * 20 - 30;
     mesh.position.z = Math.floor(objects.length / 4) * 20 - 20;
diff --git a/examples-testing/examples/webgl_nodes_materials_physical_clearcoat.ts b/examples-testing/examples/webgl_nodes_materials_physical_clearcoat.ts
index 615179e..41a86a6 100644
--- a/examples-testing/examples/webgl_nodes_materials_physical_clearcoat.ts
+++ b/examples-testing/examples/webgl_nodes_materials_physical_clearcoat.ts
@@ -10,12 +10,12 @@ import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.
 
 import { FlakesTexture } from 'three/addons/textures/FlakesTexture.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let particleLight;
-let group;
+let particleLight: THREE.Mesh;
+let group: THREE.Group;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_nodes_materialx_noise.ts b/examples-testing/examples/webgl_nodes_materialx_noise.ts
index 028b06b..07e50e8 100644
--- a/examples-testing/examples/webgl_nodes_materialx_noise.ts
+++ b/examples-testing/examples/webgl_nodes_materialx_noise.ts
@@ -16,12 +16,12 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let particleLight;
-let group;
+let particleLight: THREE.Mesh;
+let group: THREE.Group;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_panorama_cube.ts b/examples-testing/examples/webgl_panorama_cube.ts
index 951e6be..a66d5f0 100644
--- a/examples-testing/examples/webgl_panorama_cube.ts
+++ b/examples-testing/examples/webgl_panorama_cube.ts
@@ -2,15 +2,15 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, controls;
-let renderer;
-let scene;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls;
+let renderer: THREE.WebGLRenderer;
+let scene: THREE.Scene;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer();
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -43,8 +43,8 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function getTexturesFromAtlasFile(atlasImgUrl, tilesNum) {
-    const textures = [];
+function getTexturesFromAtlasFile(atlasImgUrl: string, tilesNum: number) {
+    const textures: THREE.Texture[] = [];
 
     for (let i = 0; i < tilesNum; i++) {
         textures[i] = new THREE.Texture();
@@ -56,7 +56,7 @@ function getTexturesFromAtlasFile(atlasImgUrl, tilesNum) {
 
         for (let i = 0; i < textures.length; i++) {
             canvas = document.createElement('canvas');
-            context = canvas.getContext('2d');
+            context = canvas.getContext('2d')!;
             canvas.height = tileWidth;
             canvas.width = tileWidth;
             context.drawImage(image, tileWidth * i, 0, tileWidth, tileWidth, 0, 0, tileWidth, tileWidth);
diff --git a/examples-testing/examples/webgl_panorama_equirectangular.ts b/examples-testing/examples/webgl_panorama_equirectangular.ts
index aa441b8..5c162dd 100644
--- a/examples-testing/examples/webgl_panorama_equirectangular.ts
+++ b/examples-testing/examples/webgl_panorama_equirectangular.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let isUserInteracting = false,
     onPointerDownMouseX = 0,
@@ -16,7 +16,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);
 
@@ -48,15 +48,15 @@ function init() {
 
     document.addEventListener('dragover', function (event) {
         event.preventDefault();
-        event.dataTransfer.dropEffect = 'copy';
+        event.dataTransfer!.dropEffect = 'copy';
     });
 
     document.addEventListener('dragenter', function () {
-        document.body.style.opacity = 0.5;
+        document.body.style.opacity = '0.5';
     });
 
     document.addEventListener('dragleave', function () {
-        document.body.style.opacity = 1;
+        document.body.style.opacity = '1';
     });
 
     document.addEventListener('drop', function (event) {
@@ -64,12 +64,12 @@ function init() {
 
         const reader = new FileReader();
         reader.addEventListener('load', function (event) {
-            material.map.image.src = event.target.result;
-            material.map.needsUpdate = true;
+            material.map!.image.src = event.target!.result;
+            material.map!.needsUpdate = true;
         });
-        reader.readAsDataURL(event.dataTransfer.files[0]);
+        reader.readAsDataURL(event.dataTransfer!.files[0]);
 
-        document.body.style.opacity = 1;
+        document.body.style.opacity = '1';
     });
 
     //
@@ -84,7 +84,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     isUserInteracting = true;
@@ -99,14 +99,14 @@ function onPointerDown(event) {
     document.addEventListener('pointerup', onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     lon = (onPointerDownMouseX - event.clientX) * 0.1 + onPointerDownLon;
     lat = (event.clientY - onPointerDownMouseY) * 0.1 + onPointerDownLat;
 }
 
-function onPointerUp() {
+function onPointerUp(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     isUserInteracting = false;
@@ -115,7 +115,7 @@ function onPointerUp() {
     document.removeEventListener('pointerup', onPointerUp);
 }
 
-function onDocumentMouseWheel(event) {
+function onDocumentMouseWheel(event: WheelEvent) {
     const fov = camera.fov + event.deltaY * 0.05;
 
     camera.fov = THREE.MathUtils.clamp(fov, 10, 75);
diff --git a/examples-testing/examples/webgl_pmrem_test.ts b/examples-testing/examples/webgl_pmrem_test.ts
index b33e4e2..3f0ef81 100644
--- a/examples-testing/examples/webgl_pmrem_test.ts
+++ b/examples-testing/examples/webgl_pmrem_test.ts
@@ -5,7 +5,7 @@ import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, controls, renderer;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls, renderer: THREE.WebGLRenderer;
 
 function init() {
     const width = window.innerWidth;
@@ -68,8 +68,9 @@ function init() {
             directionalLight.intensity = value ? 0 : 1;
 
             scene.traverse(function (child) {
-                if (child.isMesh) {
-                    child.material.envMapIntensity = 1 - directionalLight.intensity;
+                if ((child as THREE.Mesh).isMesh) {
+                    ((child as THREE.Mesh).material as THREE.MeshStandardMaterial).envMapIntensity =
+                        1 - directionalLight.intensity;
                 }
             });
 
diff --git a/examples-testing/examples/webgl_points_billboards.ts b/examples-testing/examples/webgl_points_billboards.ts
index a792b77..2ecaaeb 100644
--- a/examples-testing/examples/webgl_points_billboards.ts
+++ b/examples-testing/examples/webgl_points_billboards.ts
@@ -4,7 +4,11 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, stats, material;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    material: THREE.PointsMaterial;
 let mouseX = 0,
     mouseY = 0;
 
@@ -91,7 +95,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
diff --git a/examples-testing/examples/webgl_points_sprites.ts b/examples-testing/examples/webgl_points_sprites.ts
index 2a7aaa1..c240034 100644
--- a/examples-testing/examples/webgl_points_sprites.ts
+++ b/examples-testing/examples/webgl_points_sprites.ts
@@ -4,14 +4,18 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, stats, parameters;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    parameters: [[number, number, number], THREE.Texture, number][];
 let mouseX = 0,
     mouseY = 0;
 
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
 
-const materials = [];
+const materials: THREE.PointsMaterial[] = [];
 
 init();
 animate();
@@ -28,7 +32,7 @@ function init() {
 
     const textureLoader = new THREE.TextureLoader();
 
-    const assignSRGB = texture => {
+    const assignSRGB = (texture: THREE.Texture) => {
         texture.colorSpace = THREE.SRGBColorSpace;
     };
 
@@ -126,7 +130,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
diff --git a/examples-testing/examples/webgl_points_waves.ts b/examples-testing/examples/webgl_points_waves.ts
index d7405f0..fad9039 100644
--- a/examples-testing/examples/webgl_points_waves.ts
+++ b/examples-testing/examples/webgl_points_waves.ts
@@ -6,10 +6,10 @@ const SEPARATION = 100,
     AMOUNTX = 50,
     AMOUNTY = 50;
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let particles,
+let particles: THREE.Points,
     count = 0;
 
 let mouseX = 0,
@@ -61,8 +61,8 @@ function init() {
         uniforms: {
             color: { value: new THREE.Color(0xffffff) },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
     });
 
     //
@@ -100,7 +100,7 @@ function onWindowResize() {
 
 //
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
diff --git a/examples-testing/examples/webgl_portal.ts b/examples-testing/examples/webgl_portal.ts
index 6d47206..37355aa 100644
--- a/examples-testing/examples/webgl_portal.ts
+++ b/examples-testing/examples/webgl_portal.ts
@@ -3,27 +3,27 @@ import * as THREE from 'three';
 import * as CameraUtils from 'three/addons/utils/CameraUtils.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let cameraControls;
+let cameraControls: OrbitControls;
 
-let smallSphereOne, smallSphereTwo;
+let smallSphereOne: THREE.Mesh, smallSphereTwo: THREE.Mesh;
 
-let portalCamera,
-    leftPortal,
-    rightPortal,
-    leftPortalTexture,
-    reflectedPosition,
-    rightPortalTexture,
-    bottomLeftCorner,
-    bottomRightCorner,
-    topLeftCorner;
+let portalCamera: THREE.PerspectiveCamera,
+    leftPortal: THREE.Mesh,
+    rightPortal: THREE.Mesh,
+    leftPortalTexture: THREE.WebGLRenderTarget,
+    reflectedPosition: THREE.Vector3,
+    rightPortalTexture: THREE.WebGLRenderTarget,
+    bottomLeftCorner: THREE.Vector3,
+    bottomRightCorner: THREE.Vector3,
+    topLeftCorner: THREE.Vector3;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     // renderer
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -150,7 +150,11 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function renderPortal(thisPortalMesh, otherPortalMesh, thisPortalTexture) {
+function renderPortal(
+    thisPortalMesh: THREE.Mesh,
+    otherPortalMesh: THREE.Mesh,
+    thisPortalTexture: THREE.WebGLRenderTarget,
+) {
     // set the portal camera position to be reflected about the portal plane
     thisPortalMesh.worldToLocal(reflectedPosition.copy(camera.position));
     reflectedPosition.x *= -1.0;
diff --git a/examples-testing/examples/webgl_postprocessing.ts b/examples-testing/examples/webgl_postprocessing.ts
index 944115b..d0afc09 100644
--- a/examples-testing/examples/webgl_postprocessing.ts
+++ b/examples-testing/examples/webgl_postprocessing.ts
@@ -8,8 +8,8 @@ import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';
 import { DotScreenShader } from 'three/addons/shaders/DotScreenShader.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, renderer, composer;
-let object;
+let camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let object: THREE.Object3D;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_postprocessing_advanced.ts b/examples-testing/examples/webgl_postprocessing_advanced.ts
index 976a443..2b29dd4 100644
--- a/examples-testing/examples/webgl_postprocessing_advanced.ts
+++ b/examples-testing/examples/webgl_postprocessing_advanced.ts
@@ -21,11 +21,21 @@ import { GammaCorrectionShader } from 'three/addons/shaders/GammaCorrectionShade
 
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let container, stats;
-
-let composerScene, composer1, composer2, composer3, composer4;
-
-let cameraOrtho, cameraPerspective, sceneModel, sceneBG, renderer, mesh, directionalLight;
+let container: HTMLElement, stats: Stats;
+
+let composerScene: EffectComposer,
+    composer1: EffectComposer,
+    composer2: EffectComposer,
+    composer3: EffectComposer,
+    composer4: EffectComposer;
+
+let cameraOrtho: THREE.OrthographicCamera,
+    cameraPerspective: THREE.PerspectiveCamera,
+    sceneModel: THREE.Scene,
+    sceneBG: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    mesh: THREE.Mesh,
+    directionalLight: THREE.DirectionalLight;
 
 const width = window.innerWidth || 2;
 const height = window.innerHeight || 2;
@@ -33,7 +43,7 @@ const height = window.innerHeight || 2;
 let halfWidth = width / 2;
 let halfHeight = height / 2;
 
-let quadBG, quadMask, renderScene;
+let quadBG: THREE.Mesh, quadMask: THREE.Mesh, renderScene: TexturePass;
 
 const delta = 0.01;
 
@@ -41,7 +51,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -64,7 +74,7 @@ function init() {
 
     const loader = new GLTFLoader();
     loader.load('models/gltf/LeePerrySmith/LeePerrySmith.glb', function (gltf) {
-        createMesh(gltf.scene.children[0].geometry, sceneModel, 100);
+        createMesh((gltf.scene.children[0] as THREE.Mesh).geometry, sceneModel, 100);
     });
 
     //
@@ -254,7 +264,7 @@ function onWindowResize() {
     quadMask.scale.set(window.innerWidth / 2, window.innerHeight / 2, 1);
 }
 
-function createMesh(geometry, scene, scale) {
+function createMesh(geometry: THREE.BufferGeometry, scene: THREE.Scene, scale: number) {
     const diffuseMap = new THREE.TextureLoader().load('models/gltf/LeePerrySmith/Map-COL.jpg');
     diffuseMap.colorSpace = THREE.SRGBColorSpace;
 
diff --git a/examples-testing/examples/webgl_postprocessing_afterimage.ts b/examples-testing/examples/webgl_postprocessing_afterimage.ts
index 2477c50..160e1a9 100644
--- a/examples-testing/examples/webgl_postprocessing_afterimage.ts
+++ b/examples-testing/examples/webgl_postprocessing_afterimage.ts
@@ -7,10 +7,10 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, scene, renderer, composer;
-let mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let mesh: THREE.Mesh;
 
-let afterimagePass;
+let afterimagePass: AfterimagePass;
 
 const params = {
     enable: true,
@@ -50,7 +50,7 @@ function init() {
 
     window.addEventListener('resize', onWindowResize);
 
-    if (typeof TESTING !== 'undefined') {
+    if (typeof (window as any).TESTING !== 'undefined') {
         for (let i = 0; i < 45; i++) {
             render();
         }
diff --git a/examples-testing/examples/webgl_postprocessing_backgrounds.ts b/examples-testing/examples/webgl_postprocessing_backgrounds.ts
index 0bfb655..89c4a5c 100644
--- a/examples-testing/examples/webgl_postprocessing_backgrounds.ts
+++ b/examples-testing/examples/webgl_postprocessing_backgrounds.ts
@@ -11,10 +11,10 @@ import { ClearPass } from 'three/addons/postprocessing/ClearPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let scene, renderer, composer;
-let clearPass, texturePass, renderPass;
-let cameraP, cubeTexturePassP;
-let gui, stats;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let clearPass: ClearPass, texturePass: TexturePass, renderPass: RenderPass;
+let cameraP: THREE.PerspectiveCamera, cubeTexturePassP: CubeTexturePass | null;
+let gui: GUI | undefined, stats: Stats;
 
 const params = {
     clearPass: true,
@@ -56,7 +56,7 @@ function clearGui() {
 }
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     const width = window.innerWidth || 1;
     const height = window.innerHeight || 1;
@@ -111,7 +111,7 @@ function init() {
 
     // postprocessing
 
-    const genCubeUrls = function (prefix, postfix) {
+    const genCubeUrls = function (prefix: string, postfix: string) {
         return [
             prefix + 'px' + postfix,
             prefix + 'nx' + postfix,
diff --git a/examples-testing/examples/webgl_postprocessing_crossfade.ts b/examples-testing/examples/webgl_postprocessing_crossfade.ts
index d3203e3..7b7f06f 100644
--- a/examples-testing/examples/webgl_postprocessing_crossfade.ts
+++ b/examples-testing/examples/webgl_postprocessing_crossfade.ts
@@ -4,9 +4,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import TWEEN from 'three/addons/libs/tween.module.js';
 
-let container, stats;
-let renderer;
-let transition;
+let container: HTMLElement, stats: Stats;
+let renderer: THREE.WebGLRenderer;
+let transition: Transition;
 
 const transitionParams = {
     useTexture: true,
@@ -25,7 +25,7 @@ animate();
 function init() {
     initGUI();
 
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -77,7 +77,7 @@ function render() {
     transition.render(clock.getDelta());
 }
 
-function generateInstancedMesh(geometry, material, count) {
+function generateInstancedMesh(geometry: THREE.BufferGeometry, material: THREE.MeshPhongMaterial, count: number) {
     const mesh = new THREE.InstancedMesh(geometry, material, count);
 
     const dummy = new THREE.Object3D();
@@ -111,192 +111,207 @@ function generateInstancedMesh(geometry, material, count) {
     return mesh;
 }
 
-function FXScene(geometry, rotationSpeed, clearColor) {
-    this.clearColor = clearColor;
+class FXScene {
+    clearColor: number;
+    rotationSpeed: THREE.Vector3;
+    fbo: THREE.WebGLRenderTarget;
+    render: (delta: number, rtt: boolean) => void;
 
-    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
-    camera.position.z = 20;
+    constructor(geometry: THREE.BufferGeometry, rotationSpeed: THREE.Vector3, clearColor: number) {
+        this.clearColor = clearColor;
 
-    // Setup scene
-    const scene = new THREE.Scene();
-    scene.add(new THREE.AmbientLight(0xaaaaaa, 3));
+        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
+        camera.position.z = 20;
 
-    const light = new THREE.DirectionalLight(0xffffff, 3);
-    light.position.set(0, 1, 4);
-    scene.add(light);
+        // Setup scene
+        const scene = new THREE.Scene();
+        scene.add(new THREE.AmbientLight(0xaaaaaa, 3));
 
-    this.rotationSpeed = rotationSpeed;
+        const light = new THREE.DirectionalLight(0xffffff, 3);
+        light.position.set(0, 1, 4);
+        scene.add(light);
 
-    const color = geometry.type === 'BoxGeometry' ? 0x0000ff : 0xff0000;
-    const material = new THREE.MeshPhongMaterial({ color: color, flatShading: true });
-    const mesh = generateInstancedMesh(geometry, material, 500);
-    scene.add(mesh);
+        this.rotationSpeed = rotationSpeed;
 
-    this.fbo = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { type: THREE.HalfFloatType });
+        const color = geometry.type === 'BoxGeometry' ? 0x0000ff : 0xff0000;
+        const material = new THREE.MeshPhongMaterial({ color: color, flatShading: true });
+        const mesh = generateInstancedMesh(geometry, material, 500);
+        scene.add(mesh);
 
-    this.render = function (delta, rtt) {
-        mesh.rotation.x += delta * this.rotationSpeed.x;
-        mesh.rotation.y += delta * this.rotationSpeed.y;
-        mesh.rotation.z += delta * this.rotationSpeed.z;
+        this.fbo = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { type: THREE.HalfFloatType });
 
-        renderer.setClearColor(this.clearColor);
+        this.render = function (delta, rtt) {
+            mesh.rotation.x += delta * this.rotationSpeed.x;
+            mesh.rotation.y += delta * this.rotationSpeed.y;
+            mesh.rotation.z += delta * this.rotationSpeed.z;
 
-        if (rtt) {
-            renderer.setRenderTarget(this.fbo);
-            renderer.clear();
-            renderer.render(scene, camera);
-        } else {
-            renderer.setRenderTarget(null);
-            renderer.render(scene, camera);
-        }
-    };
+            renderer.setClearColor(this.clearColor);
+
+            if (rtt) {
+                renderer.setRenderTarget(this.fbo);
+                renderer.clear();
+                renderer.render(scene, camera);
+            } else {
+                renderer.setRenderTarget(null);
+                renderer.render(scene, camera);
+            }
+        };
+    }
 }
 
-function Transition(sceneA, sceneB) {
-    const scene = new THREE.Scene();
+class Transition {
+    needsTextureChange: boolean;
+    setTextureThreshold: (value: number) => void;
+    useTexture: (value: boolean) => void;
+    setTexture: (value: number) => void;
+    render: (delta: number) => void;
 
-    const width = window.innerWidth;
-    const height = window.innerHeight;
+    constructor(sceneA: FXScene, sceneB: FXScene) {
+        const scene = new THREE.Scene();
 
-    const camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, -10, 10);
+        const width = window.innerWidth;
+        const height = window.innerHeight;
 
-    const textures = [];
+        const camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, -10, 10);
 
-    const loader = new THREE.TextureLoader();
+        const textures: THREE.Texture[] = [];
 
-    for (let i = 0; i < 6; i++) {
-        textures[i] = loader.load('textures/transition/transition' + (i + 1) + '.png');
-    }
+        const loader = new THREE.TextureLoader();
 
-    const material = new THREE.ShaderMaterial({
-        uniforms: {
-            tDiffuse1: {
-                value: null,
-            },
-            tDiffuse2: {
-                value: null,
-            },
-            mixRatio: {
-                value: 0.0,
-            },
-            threshold: {
-                value: 0.1,
-            },
-            useTexture: {
-                value: 1,
-            },
-            tMixTexture: {
-                value: textures[0],
+        for (let i = 0; i < 6; i++) {
+            textures[i] = loader.load('textures/transition/transition' + (i + 1) + '.png');
+        }
+
+        const material = new THREE.ShaderMaterial({
+            uniforms: {
+                tDiffuse1: {
+                    value: null,
+                },
+                tDiffuse2: {
+                    value: null,
+                },
+                mixRatio: {
+                    value: 0.0,
+                },
+                threshold: {
+                    value: 0.1,
+                },
+                useTexture: {
+                    value: 1,
+                },
+                tMixTexture: {
+                    value: textures[0],
+                },
             },
-        },
-        vertexShader: [
-            'varying vec2 vUv;',
+            vertexShader: [
+                'varying vec2 vUv;',
 
-            'void main() {',
+                'void main() {',
 
-            'vUv = vec2( uv.x, uv.y );',
-            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
+                'vUv = vec2( uv.x, uv.y );',
+                'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
 
-            '}',
-        ].join('\n'),
-        fragmentShader: [
-            'uniform float mixRatio;',
+                '}',
+            ].join('\n'),
+            fragmentShader: [
+                'uniform float mixRatio;',
 
-            'uniform sampler2D tDiffuse1;',
-            'uniform sampler2D tDiffuse2;',
-            'uniform sampler2D tMixTexture;',
+                'uniform sampler2D tDiffuse1;',
+                'uniform sampler2D tDiffuse2;',
+                'uniform sampler2D tMixTexture;',
 
-            'uniform int useTexture;',
-            'uniform float threshold;',
+                'uniform int useTexture;',
+                'uniform float threshold;',
 
-            'varying vec2 vUv;',
+                'varying vec2 vUv;',
 
-            'void main() {',
+                'void main() {',
 
-            '	vec4 texel1 = texture2D( tDiffuse1, vUv );',
-            '	vec4 texel2 = texture2D( tDiffuse2, vUv );',
+                '	vec4 texel1 = texture2D( tDiffuse1, vUv );',
+                '	vec4 texel2 = texture2D( tDiffuse2, vUv );',
 
-            '	if (useTexture==1) {',
+                '	if (useTexture==1) {',
 
-            '		vec4 transitionTexel = texture2D( tMixTexture, vUv );',
-            '		float r = mixRatio * (1.0 + threshold * 2.0) - threshold;',
-            '		float mixf=clamp((transitionTexel.r - r)*(1.0/threshold), 0.0, 1.0);',
+                '		vec4 transitionTexel = texture2D( tMixTexture, vUv );',
+                '		float r = mixRatio * (1.0 + threshold * 2.0) - threshold;',
+                '		float mixf=clamp((transitionTexel.r - r)*(1.0/threshold), 0.0, 1.0);',
 
-            '		gl_FragColor = mix( texel1, texel2, mixf );',
+                '		gl_FragColor = mix( texel1, texel2, mixf );',
 
-            '	} else {',
+                '	} else {',
 
-            '		gl_FragColor = mix( texel2, texel1, mixRatio );',
+                '		gl_FragColor = mix( texel2, texel1, mixRatio );',
 
-            '	}',
+                '	}',
 
-            '	#include <tonemapping_fragment>',
-            '	#include <colorspace_fragment>',
+                '	#include <tonemapping_fragment>',
+                '	#include <colorspace_fragment>',
 
-            '}',
-        ].join('\n'),
-    });
+                '}',
+            ].join('\n'),
+        });
 
-    const geometry = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
-    const mesh = new THREE.Mesh(geometry, material);
-    scene.add(mesh);
+        const geometry = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
+        const mesh = new THREE.Mesh(geometry, material);
+        scene.add(mesh);
 
-    material.uniforms.tDiffuse1.value = sceneA.fbo.texture;
-    material.uniforms.tDiffuse2.value = sceneB.fbo.texture;
+        material.uniforms.tDiffuse1.value = sceneA.fbo.texture;
+        material.uniforms.tDiffuse2.value = sceneB.fbo.texture;
 
-    new TWEEN.Tween(transitionParams).to({ transition: 1 }, 1500).repeat(Infinity).delay(2000).yoyo(true).start();
+        new TWEEN.Tween(transitionParams).to({ transition: 1 }, 1500).repeat(Infinity).delay(2000).yoyo(true).start();
 
-    this.needsTextureChange = false;
+        this.needsTextureChange = false;
 
-    this.setTextureThreshold = function (value) {
-        material.uniforms.threshold.value = value;
-    };
+        this.setTextureThreshold = function (value) {
+            material.uniforms.threshold.value = value;
+        };
 
-    this.useTexture = function (value) {
-        material.uniforms.useTexture.value = value ? 1 : 0;
-    };
+        this.useTexture = function (value) {
+            material.uniforms.useTexture.value = value ? 1 : 0;
+        };
 
-    this.setTexture = function (i) {
-        material.uniforms.tMixTexture.value = textures[i];
-    };
+        this.setTexture = function (i) {
+            material.uniforms.tMixTexture.value = textures[i];
+        };
 
-    this.render = function (delta) {
-        // Transition animation
-        if (transitionParams.animate) {
-            TWEEN.update();
+        this.render = function (delta) {
+            // Transition animation
+            if (transitionParams.animate) {
+                TWEEN.update();
 
-            // Change the current alpha texture after each transition
-            if (transitionParams.cycle) {
-                if (transitionParams.transition == 0 || transitionParams.transition == 1) {
-                    if (this.needsTextureChange) {
-                        transitionParams.texture = (transitionParams.texture + 1) % textures.length;
-                        material.uniforms.tMixTexture.value = textures[transitionParams.texture];
-                        this.needsTextureChange = false;
+                // Change the current alpha texture after each transition
+                if (transitionParams.cycle) {
+                    if (transitionParams.transition == 0 || transitionParams.transition == 1) {
+                        if (this.needsTextureChange) {
+                            transitionParams.texture = (transitionParams.texture + 1) % textures.length;
+                            material.uniforms.tMixTexture.value = textures[transitionParams.texture];
+                            this.needsTextureChange = false;
+                        }
+                    } else {
+                        this.needsTextureChange = true;
                     }
                 } else {
                     this.needsTextureChange = true;
                 }
-            } else {
-                this.needsTextureChange = true;
             }
-        }
 
-        material.uniforms.mixRatio.value = transitionParams.transition;
+            material.uniforms.mixRatio.value = transitionParams.transition;
 
-        // Prevent render both scenes when it's not necessary
-        if (transitionParams.transition == 0) {
-            sceneB.render(delta, false);
-        } else if (transitionParams.transition == 1) {
-            sceneA.render(delta, false);
-        } else {
-            // When 0<transition<1 render transition between two scenes
+            // Prevent render both scenes when it's not necessary
+            if (transitionParams.transition == 0) {
+                sceneB.render(delta, false);
+            } else if (transitionParams.transition == 1) {
+                sceneA.render(delta, false);
+            } else {
+                // When 0<transition<1 render transition between two scenes
 
-            sceneA.render(delta, true);
-            sceneB.render(delta, true);
+                sceneA.render(delta, true);
+                sceneB.render(delta, true);
 
-            renderer.setRenderTarget(null);
-            renderer.clear();
-            renderer.render(scene, camera);
-        }
-    };
+                renderer.setRenderTarget(null);
+                renderer.clear();
+                renderer.render(scene, camera);
+            }
+        };
+    }
 }
diff --git a/examples-testing/examples/webgl_postprocessing_fxaa.ts b/examples-testing/examples/webgl_postprocessing_fxaa.ts
index 14b6a35..c6e40d5 100644
--- a/examples-testing/examples/webgl_postprocessing_fxaa.ts
+++ b/examples-testing/examples/webgl_postprocessing_fxaa.ts
@@ -6,15 +6,20 @@ import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
 
-let camera, scene, renderer, clock, group, container;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    group: THREE.Group,
+    container: HTMLElement;
 
-let composer1, composer2, fxaaPass;
+let composer1: EffectComposer, composer2: EffectComposer, fxaaPass: ShaderPass;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 1, 2000);
     camera.position.z = 500;
diff --git a/examples-testing/examples/webgl_postprocessing_glitch.ts b/examples-testing/examples/webgl_postprocessing_glitch.ts
index 343f2b1..9c6d3f5 100644
--- a/examples-testing/examples/webgl_postprocessing_glitch.ts
+++ b/examples-testing/examples/webgl_postprocessing_glitch.ts
@@ -5,14 +5,14 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, scene, renderer, composer;
-let object, light;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let object: THREE.Object3D, light: THREE.DirectionalLight;
 
-let glitchPass;
+let glitchPass: GlitchPass;
 
-const button = document.querySelector('#startButton');
+const button = document.querySelector('#startButton')!;
 button.addEventListener('click', function () {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
     init();
@@ -20,7 +20,7 @@ button.addEventListener('click', function () {
 });
 
 function updateOptions() {
-    const wildGlitch = document.getElementById('wildGlitch');
+    const wildGlitch = document.getElementById('wildGlitch') as HTMLInputElement;
     glitchPass.goWild = wildGlitch.checked;
 }
 
@@ -75,7 +75,7 @@ function init() {
 
     window.addEventListener('resize', onWindowResize);
 
-    const wildGlitchOption = document.getElementById('wildGlitch');
+    const wildGlitchOption = document.getElementById('wildGlitch')!;
     wildGlitchOption.addEventListener('change', updateOptions);
 
     updateOptions();
diff --git a/examples-testing/examples/webgl_postprocessing_godrays.ts b/examples-testing/examples/webgl_postprocessing_godrays.ts
index 47e89f6..4329bfe 100644
--- a/examples-testing/examples/webgl_postprocessing_godrays.ts
+++ b/examples-testing/examples/webgl_postprocessing_godrays.ts
@@ -11,16 +11,37 @@ import {
     GodRaysGenerateShader,
 } from 'three/addons/shaders/GodRaysShader.js';
 
-let container, stats;
-let camera, scene, renderer, materialDepth;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    materialDepth: THREE.MeshDepthMaterial;
 
-let sphereMesh;
+let sphereMesh: THREE.Mesh;
 
 const sunPosition = new THREE.Vector3(0, 1000, -1000);
 const clipPosition = new THREE.Vector4();
 const screenSpacePosition = new THREE.Vector3();
 
-const postprocessing = { enabled: true };
+const postprocessing: {
+    enabled: boolean;
+    scene?: THREE.Scene;
+    camera?: THREE.OrthographicCamera;
+    rtTextureColors?: THREE.WebGLRenderTarget;
+    rtTextureDepth?: THREE.WebGLRenderTarget;
+    rtTextureDepthMask?: THREE.WebGLRenderTarget;
+    rtTextureGodRays1?: THREE.WebGLRenderTarget;
+    rtTextureGodRays2?: THREE.WebGLRenderTarget;
+    godrayMaskUniforms?: (typeof GodRaysDepthMaskShader)['uniforms'];
+    materialGodraysDepthMask?: THREE.ShaderMaterial;
+    godrayGenUniforms?: (typeof GodRaysGenerateShader)['uniforms'];
+    materialGodraysGenerate?: THREE.ShaderMaterial;
+    godrayCombineUniforms?: (typeof GodRaysCombineShader)['uniforms'];
+    materialGodraysCombine?: THREE.ShaderMaterial;
+    godraysFakeSunUniforms?: (typeof GodRaysFakeSunShader)['uniforms'];
+    materialGodraysFakeSun?: THREE.ShaderMaterial;
+    quad?: THREE.Mesh;
+} = { enabled: true };
 
 const orbitRadius = 200;
 
@@ -102,17 +123,17 @@ function onWindowResize() {
     camera.updateProjectionMatrix();
 
     renderer.setSize(renderTargetWidth, renderTargetHeight);
-    postprocessing.rtTextureColors.setSize(renderTargetWidth, renderTargetHeight);
-    postprocessing.rtTextureDepth.setSize(renderTargetWidth, renderTargetHeight);
-    postprocessing.rtTextureDepthMask.setSize(renderTargetWidth, renderTargetHeight);
+    postprocessing.rtTextureColors!.setSize(renderTargetWidth, renderTargetHeight);
+    postprocessing.rtTextureDepth!.setSize(renderTargetWidth, renderTargetHeight);
+    postprocessing.rtTextureDepthMask!.setSize(renderTargetWidth, renderTargetHeight);
 
     const adjustedWidth = renderTargetWidth * godrayRenderTargetResolutionMultiplier;
     const adjustedHeight = renderTargetHeight * godrayRenderTargetResolutionMultiplier;
-    postprocessing.rtTextureGodRays1.setSize(adjustedWidth, adjustedHeight);
-    postprocessing.rtTextureGodRays2.setSize(adjustedWidth, adjustedHeight);
+    postprocessing.rtTextureGodRays1!.setSize(adjustedWidth, adjustedHeight);
+    postprocessing.rtTextureGodRays2!.setSize(adjustedWidth, adjustedHeight);
 }
 
-function initPostprocessing(renderTargetWidth, renderTargetHeight) {
+function initPostprocessing(renderTargetWidth: number, renderTargetHeight: number) {
     postprocessing.scene = new THREE.Scene();
 
     postprocessing.camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);
@@ -183,10 +204,10 @@ function initPostprocessing(renderTargetWidth, renderTargetHeight) {
         fragmentShader: godraysFakeSunShader.fragmentShader,
     });
 
-    postprocessing.godraysFakeSunUniforms.bgColor.value.setHex(bgColor);
-    postprocessing.godraysFakeSunUniforms.sunColor.value.setHex(sunColor);
+    postprocessing.godraysFakeSunUniforms!.bgColor.value.setHex(bgColor);
+    postprocessing.godraysFakeSunUniforms!.sunColor.value.setHex(sunColor);
 
-    postprocessing.godrayCombineUniforms.fGodRayIntensity.value = 0.75;
+    postprocessing.godrayCombineUniforms!.fGodRayIntensity.value = 0.75;
 
     postprocessing.quad = new THREE.Mesh(new THREE.PlaneGeometry(1.0, 1.0), postprocessing.materialGodraysGenerate);
     postprocessing.quad.position.z = -9900;
@@ -201,19 +222,19 @@ function animate() {
     stats.end();
 }
 
-function getStepSize(filterLen, tapsPerPass, pass) {
+function getStepSize(filterLen: number, tapsPerPass: number, pass: number) {
     return filterLen * Math.pow(tapsPerPass, -pass);
 }
 
-function filterGodRays(inputTex, renderTarget, stepSize) {
-    postprocessing.scene.overrideMaterial = postprocessing.materialGodraysGenerate;
+function filterGodRays(inputTex: THREE.Texture, renderTarget: THREE.WebGLRenderTarget, stepSize: number) {
+    postprocessing.scene!.overrideMaterial = postprocessing.materialGodraysGenerate!;
 
-    postprocessing.godrayGenUniforms['fStepSize'].value = stepSize;
-    postprocessing.godrayGenUniforms['tInput'].value = inputTex;
+    postprocessing.godrayGenUniforms!['fStepSize'].value = stepSize;
+    postprocessing.godrayGenUniforms!['tInput'].value = inputTex;
 
     renderer.setRenderTarget(renderTarget);
-    renderer.render(postprocessing.scene, postprocessing.camera);
-    postprocessing.scene.overrideMaterial = null;
+    renderer.render(postprocessing.scene!, postprocessing.camera!);
+    postprocessing.scene!.overrideMaterial = null;
 }
 
 function render() {
@@ -241,14 +262,14 @@ function render() {
 
         // Give it to the god-ray and sun shaders
 
-        postprocessing.godrayGenUniforms['vSunPositionScreenSpace'].value.copy(screenSpacePosition);
-        postprocessing.godraysFakeSunUniforms['vSunPositionScreenSpace'].value.copy(screenSpacePosition);
+        postprocessing.godrayGenUniforms!['vSunPositionScreenSpace'].value.copy(screenSpacePosition);
+        postprocessing.godraysFakeSunUniforms!['vSunPositionScreenSpace'].value.copy(screenSpacePosition);
 
         // -- Draw sky and sun --
 
         // Clear colors and depths, will clear to sky color
 
-        renderer.setRenderTarget(postprocessing.rtTextureColors);
+        renderer.setRenderTarget(postprocessing.rtTextureColors!);
         renderer.clear(true, true, false);
 
         // Sun render. Runs a shader that gives a brightness based on the screen
@@ -264,11 +285,11 @@ function render() {
         renderer.setScissor(screenSpacePosition.x - sunsqW / 2, screenSpacePosition.y - sunsqH / 2, sunsqW, sunsqH);
         renderer.setScissorTest(true);
 
-        postprocessing.godraysFakeSunUniforms['fAspect'].value = window.innerWidth / window.innerHeight;
+        postprocessing.godraysFakeSunUniforms!['fAspect'].value = window.innerWidth / window.innerHeight;
 
-        postprocessing.scene.overrideMaterial = postprocessing.materialGodraysFakeSun;
-        renderer.setRenderTarget(postprocessing.rtTextureColors);
-        renderer.render(postprocessing.scene, postprocessing.camera);
+        postprocessing.scene!.overrideMaterial = postprocessing.materialGodraysFakeSun!;
+        renderer.setRenderTarget(postprocessing.rtTextureColors!);
+        renderer.render(postprocessing.scene!, postprocessing.camera!);
 
         renderer.setScissorTest(false);
 
@@ -277,23 +298,23 @@ function render() {
         // Colors
 
         scene.overrideMaterial = null;
-        renderer.setRenderTarget(postprocessing.rtTextureColors);
+        renderer.setRenderTarget(postprocessing.rtTextureColors!);
         renderer.render(scene, camera);
 
         // Depth
 
         scene.overrideMaterial = materialDepth;
-        renderer.setRenderTarget(postprocessing.rtTextureDepth);
+        renderer.setRenderTarget(postprocessing.rtTextureDepth!);
         renderer.clear();
         renderer.render(scene, camera);
 
         //
 
-        postprocessing.godrayMaskUniforms['tInput'].value = postprocessing.rtTextureDepth.texture;
+        postprocessing.godrayMaskUniforms!['tInput'].value = postprocessing.rtTextureDepth!.texture;
 
-        postprocessing.scene.overrideMaterial = postprocessing.materialGodraysDepthMask;
-        renderer.setRenderTarget(postprocessing.rtTextureDepthMask);
-        renderer.render(postprocessing.scene, postprocessing.camera);
+        postprocessing.scene!.overrideMaterial = postprocessing.materialGodraysDepthMask!;
+        renderer.setRenderTarget(postprocessing.rtTextureDepthMask!);
+        renderer.render(postprocessing.scene!, postprocessing.camera!);
 
         // -- Render god-rays --
 
@@ -312,35 +333,35 @@ function render() {
 
         // pass 1 - render into first ping-pong target
         filterGodRays(
-            postprocessing.rtTextureDepthMask.texture,
-            postprocessing.rtTextureGodRays2,
+            postprocessing.rtTextureDepthMask!.texture,
+            postprocessing.rtTextureGodRays2!,
             getStepSize(filterLen, TAPS_PER_PASS, 1.0),
         );
 
         // pass 2 - render into second ping-pong target
         filterGodRays(
-            postprocessing.rtTextureGodRays2.texture,
-            postprocessing.rtTextureGodRays1,
+            postprocessing.rtTextureGodRays2!.texture,
+            postprocessing.rtTextureGodRays1!,
             getStepSize(filterLen, TAPS_PER_PASS, 2.0),
         );
 
         // pass 3 - 1st RT
         filterGodRays(
-            postprocessing.rtTextureGodRays1.texture,
-            postprocessing.rtTextureGodRays2,
+            postprocessing.rtTextureGodRays1!.texture,
+            postprocessing.rtTextureGodRays2!,
             getStepSize(filterLen, TAPS_PER_PASS, 3.0),
         );
 
         // final pass - composite god-rays onto colors
 
-        postprocessing.godrayCombineUniforms['tColors'].value = postprocessing.rtTextureColors.texture;
-        postprocessing.godrayCombineUniforms['tGodRays'].value = postprocessing.rtTextureGodRays2.texture;
+        postprocessing.godrayCombineUniforms!['tColors'].value = postprocessing.rtTextureColors!.texture;
+        postprocessing.godrayCombineUniforms!['tGodRays'].value = postprocessing.rtTextureGodRays2!.texture;
 
-        postprocessing.scene.overrideMaterial = postprocessing.materialGodraysCombine;
+        postprocessing.scene!.overrideMaterial = postprocessing.materialGodraysCombine!;
 
         renderer.setRenderTarget(null);
-        renderer.render(postprocessing.scene, postprocessing.camera);
-        postprocessing.scene.overrideMaterial = null;
+        renderer.render(postprocessing.scene!, postprocessing.camera!);
+        postprocessing.scene!.overrideMaterial = null;
     } else {
         renderer.setRenderTarget(null);
         renderer.clear();
diff --git a/examples-testing/examples/webgl_postprocessing_gtao.ts b/examples-testing/examples/webgl_postprocessing_gtao.ts
index e004cea..d4483b3 100644
--- a/examples-testing/examples/webgl_postprocessing_gtao.ts
+++ b/examples-testing/examples/webgl_postprocessing_gtao.ts
@@ -10,7 +10,14 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { GTAOPass } from 'three/addons/postprocessing/GTAOPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, scene, renderer, composer, controls, clock, stats, mixer;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    composer: EffectComposer,
+    controls: OrbitControls,
+    clock: THREE.Clock,
+    stats: Stats,
+    mixer: THREE.AnimationMixer;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_postprocessing_masking.ts b/examples-testing/examples/webgl_postprocessing_masking.ts
index 3650bfe..88a3d81 100644
--- a/examples-testing/examples/webgl_postprocessing_masking.ts
+++ b/examples-testing/examples/webgl_postprocessing_masking.ts
@@ -6,8 +6,8 @@ import { ClearPass } from 'three/addons/postprocessing/ClearPass.js';
 import { MaskPass, ClearMaskPass } from 'three/addons/postprocessing/MaskPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, composer, renderer;
-let box, torus;
+let camera: THREE.PerspectiveCamera, composer: EffectComposer, renderer: THREE.WebGLRenderer;
+let box: THREE.Mesh, torus: THREE.Mesh;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_postprocessing_material_ao.ts b/examples-testing/examples/webgl_postprocessing_material_ao.ts
index 299ca00..fee1ca8 100644
--- a/examples-testing/examples/webgl_postprocessing_material_ao.ts
+++ b/examples-testing/examples/webgl_postprocessing_material_ao.ts
@@ -10,7 +10,12 @@ import { GTAOPass } from 'three/addons/postprocessing/GTAOPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import { MeshPostProcessingMaterial } from 'three/addons/materials/MeshPostProcessingMaterial.js';
 
-let renderer, camera, scene, composer, controls, stats;
+let renderer: THREE.WebGLRenderer,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    composer: EffectComposer,
+    controls: OrbitControls,
+    stats: Stats;
 const sceneParameters = {
     output: 0,
     envMapIntensity: 1.0,
@@ -218,7 +223,7 @@ function init() {
         .max(100)
         .step(1)
         .onChange(() => {
-            lightGroup.children.forEach(light => (light.intensity = sceneParameters.lightIntensity));
+            lightGroup.children.forEach(light => ((light as THREE.Light).intensity = sceneParameters.lightIntensity));
         });
     gui.add(sceneParameters, 'shadow').onChange(value => {
         renderer.shadowMap.enabled = value;
diff --git a/examples-testing/examples/webgl_postprocessing_outline.ts b/examples-testing/examples/webgl_postprocessing_outline.ts
index 60d8b01..daa0c75 100644
--- a/examples-testing/examples/webgl_postprocessing_outline.ts
+++ b/examples-testing/examples/webgl_postprocessing_outline.ts
@@ -12,11 +12,11 @@ import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
 
-let container, stats;
-let camera, scene, renderer, controls;
-let composer, effectFXAA, outlinePass;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
+let composer: EffectComposer, effectFXAA: ShaderPass, outlinePass: OutlinePass;
 
-let selectedObjects = [];
+let selectedObjects: THREE.Object3D[] = [];
 
 const raycaster = new THREE.Raycaster();
 const mouse = new THREE.Vector2();
@@ -59,9 +59,14 @@ gui.add(params, 'usePatternTexture').onChange(function (value) {
     outlinePass.usePatternTexture = value;
 });
 
-function Configuration() {
-    this.visibleEdgeColor = '#ffffff';
-    this.hiddenEdgeColor = '#190a05';
+class Configuration {
+    visibleEdgeColor: string;
+    hiddenEdgeColor: string;
+
+    constructor() {
+        this.visibleEdgeColor = '#ffffff';
+        this.hiddenEdgeColor = '#190a05';
+    }
 }
 
 const conf = new Configuration();
@@ -223,7 +228,7 @@ function init() {
     renderer.domElement.style.touchAction = 'none';
     renderer.domElement.addEventListener('pointermove', onPointerMove);
 
-    function onPointerMove(event) {
+    function onPointerMove(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
         mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
@@ -232,7 +237,7 @@ function init() {
         checkIntersection();
     }
 
-    function addSelectedObject(object) {
+    function addSelectedObject(object: THREE.Object3D) {
         selectedObjects = [];
         selectedObjects.push(object);
     }
diff --git a/examples-testing/examples/webgl_postprocessing_pixel.ts b/examples-testing/examples/webgl_postprocessing_pixel.ts
index fa76309..e9e4350 100644
--- a/examples-testing/examples/webgl_postprocessing_pixel.ts
+++ b/examples-testing/examples/webgl_postprocessing_pixel.ts
@@ -6,8 +6,14 @@ import { RenderPixelatedPass } from 'three/addons/postprocessing/RenderPixelated
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, composer, crystalMesh, clock;
-let gui, params;
+let camera: THREE.OrthographicCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    composer: EffectComposer,
+    crystalMesh: THREE.Mesh<THREE.IcosahedronGeometry, THREE.MeshPhongMaterial>,
+    clock: THREE.Clock;
+let gui: GUI,
+    params: { pixelSize: number; normalEdgeStrength: number; depthEdgeStrength: number; pixelAlignedPanning: boolean };
 
 init();
 animate();
@@ -53,8 +59,14 @@ function init() {
         .onChange(() => {
             renderPixelatedPass.setPixelSize(params.pixelSize);
         });
-    gui.add(renderPixelatedPass, 'normalEdgeStrength').min(0).max(2).step(0.05);
-    gui.add(renderPixelatedPass, 'depthEdgeStrength').min(0).max(1).step(0.05);
+    gui.add(renderPixelatedPass as { normalEdgeStrength: number }, 'normalEdgeStrength')
+        .min(0)
+        .max(2)
+        .step(0.05);
+    gui.add(renderPixelatedPass as { depthEdgeStrength: number }, 'depthEdgeStrength')
+        .min(0)
+        .max(1)
+        .step(0.05);
     gui.add(params, 'pixelAlignedPanning');
 
     // textures
@@ -69,7 +81,7 @@ function init() {
 
     const boxMaterial = new THREE.MeshPhongMaterial({ map: texChecker2 });
 
-    function addBox(boxSideLength, x, z, rotation) {
+    function addBox(boxSideLength: number, x: number, z: number, rotation: number) {
         const mesh = new THREE.Mesh(new THREE.BoxGeometry(boxSideLength, boxSideLength, boxSideLength), boxMaterial);
         mesh.castShadow = true;
         mesh.receiveShadow = true;
@@ -168,7 +180,7 @@ function animate() {
 
 // Helper functions
 
-function pixelTexture(texture) {
+function pixelTexture(texture: THREE.Texture) {
     texture.minFilter = THREE.NearestFilter;
     texture.magFilter = THREE.NearestFilter;
     texture.generateMipmaps = false;
@@ -178,25 +190,30 @@ function pixelTexture(texture) {
     return texture;
 }
 
-function easeInOutCubic(x) {
+function easeInOutCubic(x: number) {
     return x ** 2 * 3 - x ** 3 * 2;
 }
 
-function linearStep(x, edge0, edge1) {
+function linearStep(x: number, edge0: number, edge1: number) {
     const w = edge1 - edge0;
     const m = 1 / w;
     const y0 = -m * edge0;
     return THREE.MathUtils.clamp(y0 + m * x, 0, 1);
 }
 
-function stopGoEased(x, downtime, period) {
+function stopGoEased(x: number, downtime: number, period: number) {
     const cycle = (x / period) | 0;
     const tween = x - cycle * period;
     const linStep = easeInOutCubic(linearStep(tween, downtime, period));
     return cycle + linStep;
 }
 
-function pixelAlignFrustum(camera, aspectRatio, pixelsPerScreenWidth, pixelsPerScreenHeight) {
+function pixelAlignFrustum(
+    camera: THREE.OrthographicCamera,
+    aspectRatio: number,
+    pixelsPerScreenWidth: number,
+    pixelsPerScreenHeight: number,
+) {
     // 0. Get Pixel Grid Units
     const worldScreenWidth = (camera.right - camera.left) / camera.zoom;
     const worldScreenHeight = (camera.top - camera.bottom) / camera.zoom;
diff --git a/examples-testing/examples/webgl_postprocessing_procedural.ts b/examples-testing/examples/webgl_postprocessing_procedural.ts
index 860b1c4..e38910e 100644
--- a/examples-testing/examples/webgl_postprocessing_procedural.ts
+++ b/examples-testing/examples/webgl_postprocessing_procedural.ts
@@ -3,9 +3,13 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let postCamera, postScene, renderer;
-let postMaterial, noiseRandom1DMaterial, noiseRandom2DMaterial, noiseRandom3DMaterial, postQuad;
-let stats;
+let postCamera: THREE.OrthographicCamera, postScene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let postMaterial: THREE.ShaderMaterial,
+    noiseRandom1DMaterial: THREE.ShaderMaterial,
+    noiseRandom2DMaterial: THREE.ShaderMaterial,
+    noiseRandom3DMaterial: THREE.ShaderMaterial,
+    postQuad: THREE.Mesh;
+let stats: Stats;
 
 const params = { procedure: 'noiseRandom3D' };
 
@@ -20,7 +24,7 @@ function initGui() {
 }
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer();
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -33,16 +37,16 @@ function init() {
     // Setup post processing stage
     postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
     noiseRandom1DMaterial = new THREE.ShaderMaterial({
-        vertexShader: document.querySelector('#procedural-vert').textContent.trim(),
-        fragmentShader: document.querySelector('#noiseRandom1D-frag').textContent.trim(),
+        vertexShader: document.querySelector('#procedural-vert')!.textContent!.trim(),
+        fragmentShader: document.querySelector('#noiseRandom1D-frag')!.textContent!.trim(),
     });
     noiseRandom2DMaterial = new THREE.ShaderMaterial({
-        vertexShader: document.querySelector('#procedural-vert').textContent.trim(),
-        fragmentShader: document.querySelector('#noiseRandom2D-frag').textContent.trim(),
+        vertexShader: document.querySelector('#procedural-vert')!.textContent!.trim(),
+        fragmentShader: document.querySelector('#noiseRandom2D-frag')!.textContent!.trim(),
     });
     noiseRandom3DMaterial = new THREE.ShaderMaterial({
-        vertexShader: document.querySelector('#procedural-vert').textContent.trim(),
-        fragmentShader: document.querySelector('#noiseRandom3D-frag').textContent.trim(),
+        vertexShader: document.querySelector('#procedural-vert')!.textContent!.trim(),
+        fragmentShader: document.querySelector('#noiseRandom3D-frag')!.textContent!.trim(),
     });
     postMaterial = noiseRandom3DMaterial;
     const postPlane = new THREE.PlaneGeometry(2, 2);
diff --git a/examples-testing/examples/webgl_postprocessing_rgb_halftone.ts b/examples-testing/examples/webgl_postprocessing_rgb_halftone.ts
index e81303e..7d062b7 100644
--- a/examples-testing/examples/webgl_postprocessing_rgb_halftone.ts
+++ b/examples-testing/examples/webgl_postprocessing_rgb_halftone.ts
@@ -8,11 +8,11 @@ import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
 import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { HalftonePass } from 'three/addons/postprocessing/HalftonePass.js';
 
-let renderer, clock, camera, stats;
+let renderer: THREE.WebGLRenderer, clock: THREE.Clock, camera: THREE.PerspectiveCamera, stats: Stats;
 
 const rotationSpeed = Math.PI / 64;
 
-let composer, group;
+let composer: EffectComposer, group: THREE.Group;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_postprocessing_sao.ts b/examples-testing/examples/webgl_postprocessing_sao.ts
index 1e84217..da5730f 100644
--- a/examples-testing/examples/webgl_postprocessing_sao.ts
+++ b/examples-testing/examples/webgl_postprocessing_sao.ts
@@ -8,10 +8,10 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { SAOPass } from 'three/addons/postprocessing/SAOPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let container, stats;
-let camera, scene, renderer;
-let composer, renderPass, saoPass;
-let group;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let composer: EffectComposer, renderPass: RenderPass, saoPass: SAOPass;
+let group: THREE.Object3D;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_postprocessing_smaa.ts b/examples-testing/examples/webgl_postprocessing_smaa.ts
index cd9291a..68a5482 100644
--- a/examples-testing/examples/webgl_postprocessing_smaa.ts
+++ b/examples-testing/examples/webgl_postprocessing_smaa.ts
@@ -8,7 +8,12 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, scene, renderer, composer, stats, smaaPass;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    composer: EffectComposer,
+    stats: Stats,
+    smaaPass: SMAAPass;
 
 const params = {
     enabled: true,
@@ -19,7 +24,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer();
     renderer.setPixelRatio(window.devicePixelRatio);
diff --git a/examples-testing/examples/webgl_postprocessing_sobel.ts b/examples-testing/examples/webgl_postprocessing_sobel.ts
index 3266312..4712f25 100644
--- a/examples-testing/examples/webgl_postprocessing_sobel.ts
+++ b/examples-testing/examples/webgl_postprocessing_sobel.ts
@@ -11,9 +11,9 @@ import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
 import { LuminosityShader } from 'three/addons/shaders/LuminosityShader.js';
 import { SobelOperatorShader } from 'three/addons/shaders/SobelOperatorShader.js';
 
-let camera, scene, renderer, composer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
 
-let effectSobel;
+let effectSobel: ShaderPass;
 
 const params = {
     enable: true,
diff --git a/examples-testing/examples/webgl_postprocessing_ssaa.ts b/examples-testing/examples/webgl_postprocessing_ssaa.ts
index bca3b46..0aa0074 100644
--- a/examples-testing/examples/webgl_postprocessing_ssaa.ts
+++ b/examples-testing/examples/webgl_postprocessing_ssaa.ts
@@ -7,10 +7,10 @@ import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
 import { SSAARenderPass } from 'three/addons/postprocessing/SSAARenderPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let scene, renderer, composer;
-let cameraP, ssaaRenderPassP;
-let cameraO, ssaaRenderPassO;
-let gui, stats;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let cameraP: THREE.PerspectiveCamera, ssaaRenderPassP: SSAARenderPass;
+let cameraO: THREE.OrthographicCamera, ssaaRenderPassO: SSAARenderPass;
+let gui: GUI, stats: Stats;
 
 const params = {
     sampleLevel: 4,
@@ -51,7 +51,7 @@ function clearGui() {
 }
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     const width = window.innerWidth || 1;
     const height = window.innerHeight || 1;
@@ -200,7 +200,7 @@ function animate() {
     ssaaRenderPassP.enabled = params.camera === 'perspective';
     ssaaRenderPassO.enabled = params.camera === 'orthographic';
 
-    cameraP.view.offsetX = params.viewOffsetX;
+    cameraP.view!.offsetX = params.viewOffsetX;
 
     composer.render();
 
diff --git a/examples-testing/examples/webgl_postprocessing_ssao.ts b/examples-testing/examples/webgl_postprocessing_ssao.ts
index b4201ee..b3a308c 100644
--- a/examples-testing/examples/webgl_postprocessing_ssao.ts
+++ b/examples-testing/examples/webgl_postprocessing_ssao.ts
@@ -8,10 +8,10 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let container, stats;
-let camera, scene, renderer;
-let composer;
-let group;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let composer: EffectComposer;
+let group: THREE.Group;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_postprocessing_ssr.ts b/examples-testing/examples/webgl_postprocessing_ssr.ts
index 4af292e..bcf7969 100644
--- a/examples-testing/examples/webgl_postprocessing_ssr.ts
+++ b/examples-testing/examples/webgl_postprocessing_ssr.ts
@@ -18,17 +18,17 @@ const params = {
     otherMeshes: true,
     groundReflector: true,
 };
-let composer;
-let ssrPass;
-let gui;
-let stats;
-let controls;
-let camera, scene, renderer;
-const otherMeshes = [];
-let groundReflector;
-const selects = [];
-
-const container = document.querySelector('#container');
+let composer: EffectComposer;
+let ssrPass: SSRPass;
+let gui: GUI;
+let stats: Stats;
+let controls: OrbitControls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+const otherMeshes: THREE.Mesh[] = [];
+let groundReflector: ReflectorForSSRPass;
+const selects: THREE.Mesh[] = [];
+
+const container = document.querySelector('#container')!;
 
 // Configure and create Draco decoder.
 const dracoLoader = new DRACOLoader();
@@ -78,7 +78,7 @@ function init() {
         dracoLoader.dispose();
     });
 
-    let geometry, material, mesh;
+    let geometry: THREE.BufferGeometry, material: THREE.MeshStandardMaterial, mesh: THREE.Mesh;
 
     geometry = new THREE.BoxGeometry(0.05, 0.05, 0.05);
     material = new THREE.MeshStandardMaterial({ color: 'green' });
diff --git a/examples-testing/examples/webgl_postprocessing_taa.ts b/examples-testing/examples/webgl_postprocessing_taa.ts
index b2a12b5..b1efc76 100644
--- a/examples-testing/examples/webgl_postprocessing_taa.ts
+++ b/examples-testing/examples/webgl_postprocessing_taa.ts
@@ -8,8 +8,13 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { TAARenderPass } from 'three/addons/postprocessing/TAARenderPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, scene, renderer, composer, taaRenderPass, renderPass;
-let gui, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    composer: EffectComposer,
+    taaRenderPass: TAARenderPass,
+    renderPass: RenderPass;
+let gui: GUI | undefined, stats: Stats;
 let index = 0;
 
 const param = { TAAEnabled: '1', TAASampleLevel: 0 };
@@ -51,7 +56,7 @@ function clearGui() {
 }
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer();
     renderer.setPixelRatio(window.devicePixelRatio);
diff --git a/examples-testing/examples/webgl_postprocessing_unreal_bloom.ts b/examples-testing/examples/webgl_postprocessing_unreal_bloom.ts
index 886f77f..00666b2 100644
--- a/examples-testing/examples/webgl_postprocessing_unreal_bloom.ts
+++ b/examples-testing/examples/webgl_postprocessing_unreal_bloom.ts
@@ -10,8 +10,8 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, stats;
-let composer, renderer, mixer, clock;
+let camera: THREE.PerspectiveCamera, stats: Stats;
+let composer: EffectComposer, renderer: THREE.WebGLRenderer, mixer: THREE.AnimationMixer, clock: THREE.Clock;
 
 const params = {
     threshold: 0,
@@ -23,7 +23,7 @@ const params = {
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     stats = new Stats();
     container.appendChild(stats.dom);
diff --git a/examples-testing/examples/webgl_postprocessing_unreal_bloom_selective.ts b/examples-testing/examples/webgl_postprocessing_unreal_bloom_selective.ts
index d633806..a25f53b 100644
--- a/examples-testing/examples/webgl_postprocessing_unreal_bloom_selective.ts
+++ b/examples-testing/examples/webgl_postprocessing_unreal_bloom_selective.ts
@@ -22,7 +22,7 @@ const params = {
 };
 
 const darkMaterial = new THREE.MeshBasicMaterial({ color: 'black' });
-const materials = {};
+const materials: Record<string, THREE.Material | THREE.Material[]> = {};
 
 const renderer = new THREE.WebGLRenderer({ antialias: true });
 renderer.setPixelRatio(window.devicePixelRatio);
@@ -60,8 +60,8 @@ const mixPass = new ShaderPass(
             baseTexture: { value: null },
             bloomTexture: { value: bloomComposer.renderTarget2.texture },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
         defines: {},
     }),
     'baseTexture',
@@ -112,7 +112,7 @@ toneMappingFolder.add(params, 'exposure', 0.1, 2).onChange(function (value) {
 
 setupScene();
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
     mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
 
@@ -165,9 +165,9 @@ function setupScene() {
     render();
 }
 
-function disposeMaterial(obj) {
-    if (obj.material) {
-        obj.material.dispose();
+function disposeMaterial(obj: THREE.Object3D) {
+    if ((obj as THREE.Mesh).material) {
+        ((obj as THREE.Mesh).material as THREE.Material).dispose();
     }
 }
 
@@ -180,16 +180,16 @@ function render() {
     finalComposer.render();
 }
 
-function darkenNonBloomed(obj) {
-    if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
-        materials[obj.uuid] = obj.material;
-        obj.material = darkMaterial;
+function darkenNonBloomed(obj: THREE.Object3D) {
+    if ((obj as THREE.Mesh).isMesh && bloomLayer.test(obj.layers) === false) {
+        materials[obj.uuid] = (obj as THREE.Mesh).material;
+        (obj as THREE.Mesh).material = darkMaterial;
     }
 }
 
-function restoreMaterial(obj) {
+function restoreMaterial(obj: THREE.Object3D) {
     if (materials[obj.uuid]) {
-        obj.material = materials[obj.uuid];
+        (obj as THREE.Mesh).material = materials[obj.uuid];
         delete materials[obj.uuid];
     }
 }
diff --git a/examples-testing/examples/webgl_raycaster_sprite.ts b/examples-testing/examples/webgl_raycaster_sprite.ts
index 1de2b51..0da8464 100644
--- a/examples-testing/examples/webgl_raycaster_sprite.ts
+++ b/examples-testing/examples/webgl_raycaster_sprite.ts
@@ -2,10 +2,10 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let renderer, scene, camera;
-let group;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let group: THREE.Group;
 
-let selectedObject = null;
+let selectedObject: THREE.Mesh<THREE.BufferGeometry, THREE.SpriteMaterial> | null = null;
 const raycaster = new THREE.Raycaster();
 const pointer = new THREE.Vector2();
 
@@ -78,7 +78,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (selectedObject) {
         selectedObject.material.color.set('#69f');
         selectedObject = null;
@@ -97,7 +97,7 @@ function onPointerMove(event) {
         })[0];
 
         if (res && res.object) {
-            selectedObject = res.object;
+            selectedObject = res.object as THREE.Mesh<THREE.BufferGeometry, THREE.SpriteMaterial>;
             selectedObject.material.color.set('#f00');
         }
     }
diff --git a/examples-testing/examples/webgl_raycaster_texture.ts b/examples-testing/examples/webgl_raycaster_texture.ts
index 2a9110c..8799c72 100644
--- a/examples-testing/examples/webgl_raycaster_texture.ts
+++ b/examples-testing/examples/webgl_raycaster_texture.ts
@@ -8,7 +8,15 @@ const WRAPPING = {
     MirroredRepeatWrapping: THREE.MirroredRepeatWrapping,
 };
 
-const params = {
+const params: {
+    wrapS: THREE.Wrapping;
+    wrapT: THREE.Wrapping;
+    offsetX: number;
+    offsetY: number;
+    repeatX: number;
+    repeatY: number;
+    rotation: number;
+} = {
     wrapS: THREE.RepeatWrapping,
     wrapT: THREE.RepeatWrapping,
     offsetX: 0,
@@ -18,68 +26,68 @@ const params = {
     rotation: 0,
 };
 
-function CanvasTexture(parentTexture) {
-    this._canvas = document.createElement('canvas');
-    this._canvas.width = this._canvas.height = 1024;
-    this._context2D = this._canvas.getContext('2d');
+class CanvasTexture {
+    _background: HTMLImageElement;
 
-    if (parentTexture) {
-        this._parentTexture.push(parentTexture);
-        parentTexture.image = this._canvas;
-    }
+    constructor(parentTexture: THREE.Texture) {
+        this._canvas = document.createElement('canvas');
+        this._canvas.width = this._canvas.height = 1024;
+        this._context2D = this._canvas.getContext('2d');
 
-    const that = this;
-    this._background = document.createElement('img');
-    this._background.addEventListener('load', function () {
-        that._canvas.width = that._background.naturalWidth;
-        that._canvas.height = that._background.naturalHeight;
+        if (parentTexture) {
+            this._parentTexture.push(parentTexture);
+            parentTexture.image = this._canvas;
+        }
 
-        that._crossRadius = Math.ceil(Math.min(that._canvas.width, that._canvas.height / 30));
-        that._crossMax = Math.ceil(0.70710678 * that._crossRadius);
-        that._crossMin = Math.ceil(that._crossMax / 10);
-        that._crossThickness = Math.ceil(that._crossMax / 10);
+        const that = this;
+        this._background = document.createElement('img');
+        this._background.addEventListener('load', function () {
+            that._canvas!.width = that._background.naturalWidth;
+            that._canvas!.height = that._background.naturalHeight;
 
-        that._draw();
-    });
-    this._background.crossOrigin = '';
-    this._background.src = 'textures/uv_grid_opengl.jpg';
+            that._crossRadius = Math.ceil(Math.min(that._canvas!.width, that._canvas!.height / 30));
+            that._crossMax = Math.ceil(0.70710678 * that._crossRadius);
+            that._crossMin = Math.ceil(that._crossMax / 10);
+            that._crossThickness = Math.ceil(that._crossMax / 10);
 
-    this._draw();
-}
+            that._draw();
+        });
+        this._background.crossOrigin = '';
+        this._background.src = 'textures/uv_grid_opengl.jpg';
 
-CanvasTexture.prototype = {
-    constructor: CanvasTexture,
+        this._draw();
+    }
 
-    _canvas: null,
-    _context2D: null,
-    _xCross: 0,
-    _yCross: 0,
+    _canvas: HTMLCanvasElement | null = null;
+    _context2D: CanvasRenderingContext2D | null = null;
+    _xCross = 0;
+    _yCross = 0;
 
-    _crossRadius: 57,
-    _crossMax: 40,
-    _crossMin: 4,
-    _crossThickness: 4,
+    _crossRadius = 57;
+    _crossMax = 40;
+    _crossMin = 4;
+    _crossThickness = 4;
 
-    _parentTexture: [],
+    _parentTexture: THREE.Texture[] = [];
 
-    addParent: function (parentTexture) {
+    addParent = function (this: CanvasTexture, parentTexture: THREE.Texture) {
         if (this._parentTexture.indexOf(parentTexture) === -1) {
             this._parentTexture.push(parentTexture);
             parentTexture.image = this._canvas;
         }
-    },
+    };
 
-    setCrossPosition: function (x, y) {
-        this._xCross = x * this._canvas.width;
-        this._yCross = y * this._canvas.height;
+    setCrossPosition = function (this: CanvasTexture, x: number, y: number) {
+        this._xCross = x * this._canvas!.width;
+        this._yCross = y * this._canvas!.height;
 
         this._draw();
-    },
+    };
 
-    _draw: function () {
+    _draw = function (this: CanvasTexture) {
         if (!this._context2D) return;
 
-        this._context2D.clearRect(0, 0, this._canvas.width, this._canvas.height);
+        this._context2D.clearRect(0, 0, this._canvas!.width, this._canvas!.height);
 
         // Background.
         this._context2D.drawImage(this._background, 0, 0);
@@ -106,18 +114,18 @@ CanvasTexture.prototype = {
         for (let i = 0; i < this._parentTexture.length; i++) {
             this._parentTexture[i].needsUpdate = true;
         }
-    },
-};
+    };
+}
 
 const width = window.innerWidth;
 const height = window.innerHeight;
 
-let canvas;
-let planeTexture, cubeTexture, circleTexture;
+let canvas: CanvasTexture;
+let planeTexture: THREE.Texture, cubeTexture: THREE.Texture, circleTexture: THREE.Texture;
 
-let container;
+let container: HTMLElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const raycaster = new THREE.Raycaster();
 const mouse = new THREE.Vector2();
@@ -127,7 +135,7 @@ init();
 render();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
     scene.background = new THREE.Color(0xeeeeee);
@@ -233,7 +241,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onMouseMove(evt) {
+function onMouseMove(evt: MouseEvent) {
     evt.preventDefault();
 
     const array = getMousePosition(container, evt.clientX, evt.clientY);
@@ -243,17 +251,19 @@ function onMouseMove(evt) {
 
     if (intersects.length > 0 && intersects[0].uv) {
         const uv = intersects[0].uv;
-        intersects[0].object.material.map.transformUv(uv);
+        (intersects[0].object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshBasicMaterial>).material.map!.transformUv(
+            uv,
+        );
         canvas.setCrossPosition(uv.x, uv.y);
     }
 }
 
-function getMousePosition(dom, x, y) {
+function getMousePosition(dom: HTMLElement, x: number, y: number) {
     const rect = dom.getBoundingClientRect();
     return [(x - rect.left) / rect.width, (y - rect.top) / rect.height];
 }
 
-function getIntersects(point, objects) {
+function getIntersects(point: THREE.Vector2, objects: THREE.Object3D[]) {
     mouse.set(point.x * 2 - 1, -(point.y * 2) + 1);
 
     raycaster.setFromCamera(mouse, camera);
@@ -277,12 +287,12 @@ function render() {
     renderer.render(scene, camera);
 }
 
-function setwrapS(value) {
+function setwrapS(value: THREE.Wrapping) {
     circleTexture.wrapS = value;
     circleTexture.needsUpdate = true;
 }
 
-function setwrapT(value) {
+function setwrapT(value: THREE.Wrapping) {
     circleTexture.wrapT = value;
     circleTexture.needsUpdate = true;
 }
diff --git a/examples-testing/examples/webgl_raymarching_reflect.ts b/examples-testing/examples/webgl_raymarching_reflect.ts
index 96f9a81..43bd75d 100644
--- a/examples-testing/examples/webgl_raymarching_reflect.ts
+++ b/examples-testing/examples/webgl_raymarching_reflect.ts
@@ -5,11 +5,11 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let dolly, camera, scene, renderer;
-let geometry, material, mesh;
-let stats, clock;
+let dolly: THREE.Group, camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let geometry: THREE.PlaneGeometry, material: THREE.RawShaderMaterial, mesh;
+let stats: Stats, clock: THREE.Clock;
 
-const canvas = document.querySelector('#canvas');
+const canvas = document.querySelector('#canvas') as HTMLCanvasElement;
 
 const config = {
     saveImage: function () {
@@ -48,8 +48,8 @@ function init() {
             cameraWorldMatrix: { value: camera.matrixWorld },
             cameraProjectionMatrixInverse: { value: camera.projectionMatrixInverse.clone() },
         },
-        vertexShader: document.getElementById('vertex_shader').textContent,
-        fragmentShader: document.getElementById('fragment_shader').textContent,
+        vertexShader: document.getElementById('vertex_shader')!.textContent!,
+        fragmentShader: document.getElementById('fragment_shader')!.textContent!,
     });
     mesh = new THREE.Mesh(geometry, material);
     mesh.frustumCulled = false;
diff --git a/examples-testing/examples/webgl_read_float_buffer.ts b/examples-testing/examples/webgl_read_float_buffer.ts
index fbc8057..42b50b0 100644
--- a/examples-testing/examples/webgl_read_float_buffer.ts
+++ b/examples-testing/examples/webgl_read_float_buffer.ts
@@ -2,9 +2,14 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let cameraRTT, sceneRTT, sceneScreen, renderer, zmesh1, zmesh2;
+let cameraRTT: THREE.OrthographicCamera,
+    sceneRTT: THREE.Scene,
+    sceneScreen: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    zmesh1: THREE.Mesh,
+    zmesh2: THREE.Mesh;
 
 let mouseX = 0,
     mouseY = 0;
@@ -12,16 +17,16 @@ let mouseX = 0,
 const windowHalfX = window.innerWidth / 2;
 const windowHalfY = window.innerHeight / 2;
 
-let rtTexture, material, quad;
+let rtTexture: THREE.WebGLRenderTarget, material: THREE.ShaderMaterial, quad: THREE.Mesh;
 
 let delta = 0.01;
-let valueNode;
+let valueNode: HTMLElement;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     cameraRTT = new THREE.OrthographicCamera(
         window.innerWidth / -2,
@@ -55,14 +60,14 @@ function init() {
 
     material = new THREE.ShaderMaterial({
         uniforms: { time: { value: 0.0 } },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragment_shader_pass_1').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragment_shader_pass_1')!.textContent!,
     });
 
     const materialScreen = new THREE.ShaderMaterial({
         uniforms: { tDiffuse: { value: rtTexture.texture } },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragment_shader_screen').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragment_shader_screen')!.textContent!,
 
         depthWrite: false,
     });
@@ -102,12 +107,12 @@ function init() {
     stats = new Stats();
     container.appendChild(stats.dom);
 
-    valueNode = document.getElementById('values');
+    valueNode = document.getElementById('values')!;
 
     document.addEventListener('mousemove', onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgl_refraction.ts b/examples-testing/examples/webgl_refraction.ts
index fb22aa8..6820596 100644
--- a/examples-testing/examples/webgl_refraction.ts
+++ b/examples-testing/examples/webgl_refraction.ts
@@ -4,14 +4,14 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Refractor } from 'three/addons/objects/Refractor.js';
 import { WaterRefractionShader } from 'three/addons/shaders/WaterRefractionShader.js';
 
-let camera, scene, renderer, clock;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
 
-let refractor, smallSphere;
+let refractor: Refractor, smallSphere: THREE.Mesh;
 
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     clock = new THREE.Clock();
 
diff --git a/examples-testing/examples/webgl_rtt.ts b/examples-testing/examples/webgl_rtt.ts
index 2f3714e..d0ccac2 100644
--- a/examples-testing/examples/webgl_rtt.ts
+++ b/examples-testing/examples/webgl_rtt.ts
@@ -2,9 +2,16 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let cameraRTT, camera, sceneRTT, sceneScreen, scene, renderer, zmesh1, zmesh2;
+let cameraRTT: THREE.OrthographicCamera,
+    camera: THREE.PerspectiveCamera,
+    sceneRTT: THREE.Scene,
+    sceneScreen: THREE.Scene,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    zmesh1: THREE.Mesh,
+    zmesh2: THREE.Mesh;
 
 let mouseX = 0,
     mouseY = 0;
@@ -12,7 +19,7 @@ let mouseX = 0,
 const windowHalfX = window.innerWidth / 2;
 const windowHalfY = window.innerHeight / 2;
 
-let rtTexture, material, quad;
+let rtTexture: THREE.WebGLRenderTarget, material: THREE.ShaderMaterial, quad: THREE.Mesh;
 
 let delta = 0.01;
 
@@ -20,7 +27,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 100;
@@ -53,14 +60,14 @@ function init() {
 
     material = new THREE.ShaderMaterial({
         uniforms: { time: { value: 0.0 } },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragment_shader_pass_1').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragment_shader_pass_1')!.textContent!,
     });
 
     const materialScreen = new THREE.ShaderMaterial({
         uniforms: { tDiffuse: { value: rtTexture.texture } },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragment_shader_screen').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragment_shader_screen')!.textContent!,
 
         depthWrite: false,
     });
@@ -121,7 +128,7 @@ function init() {
     document.addEventListener('mousemove', onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgl_shader.ts b/examples-testing/examples/webgl_shader.ts
index 5bd07a0..ddb932c 100644
--- a/examples-testing/examples/webgl_shader.ts
+++ b/examples-testing/examples/webgl_shader.ts
@@ -1,14 +1,14 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let uniforms;
+let uniforms: Record<string, THREE.IUniform<unknown>>;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
 
@@ -22,8 +22,8 @@ function init() {
 
     const material = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
     });
 
     const mesh = new THREE.Mesh(geometry, material);
diff --git a/examples-testing/examples/webgl_shader_lava.ts b/examples-testing/examples/webgl_shader_lava.ts
index 68f764e..6d57ac4 100644
--- a/examples-testing/examples/webgl_shader_lava.ts
+++ b/examples-testing/examples/webgl_shader_lava.ts
@@ -5,15 +5,23 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { BloomPass } from 'three/addons/postprocessing/BloomPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, renderer, composer, clock;
-
-let uniforms, mesh;
+let camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, composer: EffectComposer, clock: THREE.Clock;
+
+let uniforms: {
+        fogDensity: THREE.IUniform<number>;
+        fogColor: THREE.IUniform<THREE.Vector3>;
+        time: THREE.IUniform<number>;
+        uvScale: THREE.IUniform<THREE.Vector2>;
+        texture1: THREE.IUniform<THREE.Texture>;
+        texture2: THREE.IUniform<THREE.Texture>;
+    },
+    mesh: THREE.Mesh;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 3000);
     camera.position.z = 4;
@@ -45,8 +53,8 @@ function init() {
 
     const material = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
     });
 
     mesh = new THREE.Mesh(new THREE.TorusGeometry(size, 0.3, 30, 30), material);
diff --git a/examples-testing/examples/webgl_shaders_ocean.ts b/examples-testing/examples/webgl_shaders_ocean.ts
index fa4fadd..91c9d5a 100644
--- a/examples-testing/examples/webgl_shaders_ocean.ts
+++ b/examples-testing/examples/webgl_shaders_ocean.ts
@@ -7,15 +7,15 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Water } from 'three/addons/objects/Water.js';
 import { Sky } from 'three/addons/objects/Sky.js';
 
-let container, stats;
-let camera, scene, renderer;
-let controls, water, sun, mesh;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controls, water: Water, sun: THREE.Vector3, mesh: THREE.Mesh;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -79,7 +79,7 @@ function init() {
     const pmremGenerator = new THREE.PMREMGenerator(renderer);
     const sceneEnv = new THREE.Scene();
 
-    let renderTarget;
+    let renderTarget: THREE.WebGLRenderTarget;
 
     function updateSun() {
         const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);
diff --git a/examples-testing/examples/webgl_shaders_sky.ts b/examples-testing/examples/webgl_shaders_sky.ts
index 18020f7..3b61996 100644
--- a/examples-testing/examples/webgl_shaders_sky.ts
+++ b/examples-testing/examples/webgl_shaders_sky.ts
@@ -4,9 +4,9 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Sky } from 'three/addons/objects/Sky.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let sky, sun;
+let sky: Sky, sun: THREE.Vector3;
 
 init();
 render();
diff --git a/examples-testing/examples/webgl_shadow_contact.ts b/examples-testing/examples/webgl_shadow_contact.ts
index 157b8da..63b7a3f 100644
--- a/examples-testing/examples/webgl_shadow_contact.ts
+++ b/examples-testing/examples/webgl_shadow_contact.ts
@@ -5,9 +5,9 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { HorizontalBlurShader } from 'three/addons/shaders/HorizontalBlurShader.js';
 import { VerticalBlurShader } from 'three/addons/shaders/VerticalBlurShader.js';
 
-let camera, scene, renderer, stats, gui;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats, gui;
 
-const meshes = [];
+const meshes: THREE.Mesh[] = [];
 
 const PLANE_WIDTH = 2.5;
 const PLANE_HEIGHT = 2.5;
@@ -26,16 +26,18 @@ const state = {
     showWireframe: false,
 };
 
-let shadowGroup,
-    renderTarget,
-    renderTargetBlur,
-    shadowCamera,
-    cameraHelper,
-    depthMaterial,
-    horizontalBlurMaterial,
-    verticalBlurMaterial;
+let shadowGroup: THREE.Group,
+    renderTarget: THREE.WebGLRenderTarget,
+    renderTargetBlur: THREE.WebGLRenderTarget,
+    shadowCamera: THREE.OrthographicCamera,
+    cameraHelper: THREE.CameraHelper,
+    depthMaterial: THREE.MeshDepthMaterial,
+    horizontalBlurMaterial: THREE.ShaderMaterial,
+    verticalBlurMaterial: THREE.ShaderMaterial;
 
-let plane, blurPlane, fillPlane;
+let plane: THREE.Mesh<THREE.PlaneGeometry, THREE.MeshBasicMaterial>,
+    blurPlane: THREE.Mesh<THREE.PlaneGeometry, THREE.MeshBasicMaterial | THREE.ShaderMaterial>,
+    fillPlane: THREE.Mesh<THREE.PlaneGeometry, THREE.MeshBasicMaterial>;
 
 init();
 animate();
@@ -206,7 +208,7 @@ function onWindowResize() {
 }
 
 // renderTarget --> blurPlane (horizontalBlur) --> renderTargetBlur --> blurPlane (verticalBlur) --> renderTarget
-function blurShadow(amount) {
+function blurShadow(amount: number) {
     blurPlane.visible = true;
 
     // blur horizontally and draw in the renderTargetBlur
diff --git a/examples-testing/examples/webgl_shadowmap.ts b/examples-testing/examples/webgl_shadowmap.ts
index 122fa84..e539bef 100644
--- a/examples-testing/examples/webgl_shadowmap.ts
+++ b/examples-testing/examples/webgl_shadowmap.ts
@@ -15,18 +15,18 @@ let SCREEN_WIDTH = window.innerWidth;
 let SCREEN_HEIGHT = window.innerHeight;
 const FLOOR = -250;
 
-let camera, controls, scene, renderer;
-let container, stats;
+let camera: THREE.PerspectiveCamera, controls: FirstPersonControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let container: HTMLDivElement, stats: Stats;
 
 const NEAR = 10,
     FAR = 3000;
 
-let mixer;
+let mixer: THREE.AnimationMixer;
 
-const morphs = [];
+const morphs: (THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial> & { speed?: number })[] = [];
 
-let light;
-let lightShadowMapViewer;
+let light: THREE.DirectionalLight;
+let lightShadowMapViewer: ShadowMapViewer;
 
 const clock = new THREE.Clock();
 
@@ -121,7 +121,7 @@ function onWindowResize() {
     controls.handleResize();
 }
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     switch (event.keyCode) {
         case 84 /*t*/:
             showHUD = !showHUD;
@@ -172,7 +172,7 @@ function createScene() {
         });
 
         textGeo.computeBoundingBox();
-        const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
+        const centerOffset = -0.5 * (textGeo.boundingBox!.max.x - textGeo.boundingBox!.min.x);
 
         const textMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
 
@@ -212,7 +212,16 @@ function createScene() {
 
     mixer = new THREE.AnimationMixer(scene);
 
-    function addMorph(mesh, clip, speed, duration, x, y, z, fudgeColor) {
+    function addMorph(
+        mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial> & { speed?: number },
+        clip: THREE.AnimationClip,
+        speed: number,
+        duration: number,
+        x: number,
+        y: number,
+        z: number,
+        fudgeColor?: boolean,
+    ) {
         mesh = mesh.clone();
         mesh.material = mesh.material.clone();
 
@@ -243,7 +252,7 @@ function createScene() {
     const gltfloader = new GLTFLoader();
 
     gltfloader.load('models/gltf/Horse.glb', function (gltf) {
-        const mesh = gltf.scene.children[0];
+        const mesh = gltf.scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
 
         const clip = gltf.animations[0];
 
@@ -257,21 +266,21 @@ function createScene() {
     });
 
     gltfloader.load('models/gltf/Flamingo.glb', function (gltf) {
-        const mesh = gltf.scene.children[0];
+        const mesh = gltf.scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
         const clip = gltf.animations[0];
 
         addMorph(mesh, clip, 500, 1, 500 - Math.random() * 500, FLOOR + 350, 40);
     });
 
     gltfloader.load('models/gltf/Stork.glb', function (gltf) {
-        const mesh = gltf.scene.children[0];
+        const mesh = gltf.scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
         const clip = gltf.animations[0];
 
         addMorph(mesh, clip, 350, 1, 500 - Math.random() * 500, FLOOR + 350, 340);
     });
 
     gltfloader.load('models/gltf/Parrot.glb', function (gltf) {
-        const mesh = gltf.scene.children[0];
+        const mesh = gltf.scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
         const clip = gltf.animations[0];
 
         addMorph(mesh, clip, 450, 0.5, 500 - Math.random() * 500, FLOOR + 300, 700);
@@ -293,7 +302,7 @@ function render() {
     for (let i = 0; i < morphs.length; i++) {
         const morph = morphs[i];
 
-        morph.position.x += morph.speed * delta;
+        morph.position.x += morph.speed! * delta;
 
         if (morph.position.x > 2000) {
             morph.position.x = -1000 - Math.random() * 500;
diff --git a/examples-testing/examples/webgl_shadowmap_csm.ts b/examples-testing/examples/webgl_shadowmap_csm.ts
index bdcd49f..0fc8a64 100644
--- a/examples-testing/examples/webgl_shadowmap_csm.ts
+++ b/examples-testing/examples/webgl_shadowmap_csm.ts
@@ -2,12 +2,32 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
-import { CSM } from 'three/addons/csm/CSM.js';
+import { CSM, CSMMode } from 'three/addons/csm/CSM.js';
 import { CSMHelper } from 'three/addons/csm/CSMHelper.js';
 
-let renderer, scene, camera, orthoCamera, controls, csm, csmHelper;
-
-const params = {
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    orthoCamera: THREE.OrthographicCamera,
+    controls: OrbitControls,
+    csm: CSM,
+    csmHelper: CSMHelper;
+
+const params: {
+    orthographic: boolean;
+    fade: boolean;
+    shadows: boolean;
+    far: number;
+    mode: CSMMode;
+    lightX: number;
+    lightY: number;
+    lightZ: number;
+    margin: number;
+    lightFar: number;
+    lightNear: number;
+    autoUpdateHelper: boolean;
+    updateHelper: () => void;
+} = {
     orthographic: false,
     fade: false,
     shadows: true,
@@ -133,8 +153,8 @@ function init() {
         renderer.shadowMap.enabled = value;
 
         scene.traverse(function (child) {
-            if (child.material) {
-                child.material.needsUpdate = true;
+            if ((child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material) {
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.needsUpdate = true;
             }
         });
     });
diff --git a/examples-testing/examples/webgl_shadowmap_pcss.ts b/examples-testing/examples/webgl_shadowmap_pcss.ts
index 91ba360..230059a 100644
--- a/examples-testing/examples/webgl_shadowmap_pcss.ts
+++ b/examples-testing/examples/webgl_shadowmap_pcss.ts
@@ -4,10 +4,10 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let stats;
-let camera, scene, renderer;
+let stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let group;
+let group: THREE.Group;
 
 init();
 animate();
@@ -96,12 +96,12 @@ function init() {
 
     shader = shader.replace(
         '#ifdef USE_SHADOWMAP',
-        '#ifdef USE_SHADOWMAP' + document.getElementById('PCSS').textContent,
+        '#ifdef USE_SHADOWMAP' + document.getElementById('PCSS')!.textContent,
     );
 
     shader = shader.replace(
         '#if defined( SHADOWMAP_TYPE_PCF )',
-        document.getElementById('PCSSGetShadow').textContent + '#if defined( SHADOWMAP_TYPE_PCF )',
+        document.getElementById('PCSSGetShadow')!.textContent + '#if defined( SHADOWMAP_TYPE_PCF )',
     );
 
     THREE.ShaderChunk.shadowmap_pars_fragment = shader;
diff --git a/examples-testing/examples/webgl_shadowmap_performance.ts b/examples-testing/examples/webgl_shadowmap_performance.ts
index c3f0207..c211b8a 100644
--- a/examples-testing/examples/webgl_shadowmap_performance.ts
+++ b/examples-testing/examples/webgl_shadowmap_performance.ts
@@ -16,16 +16,16 @@ const FLOOR = -250;
 
 const ANIMATION_GROUPS = 25;
 
-let camera, controls, scene, renderer;
-let stats;
+let camera: THREE.PerspectiveCamera, controls: FirstPersonControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let stats: Stats;
 
 const NEAR = 5,
     FAR = 3000;
 
-let morph, mixer;
+let morph, mixer: THREE.AnimationMixer;
 
-const morphs = [],
-    animGroups = [];
+const morphs: (THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial> & { speed?: number })[] = [],
+    animGroups: THREE.AnimationObjectGroup[] = [];
 
 const clock = new THREE.Clock();
 
@@ -150,7 +150,7 @@ function createScene() {
         });
 
         textGeo.computeBoundingBox();
-        const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
+        const centerOffset = -0.5 * (textGeo.boundingBox!.max.x - textGeo.boundingBox!.min.x);
 
         const textMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
 
@@ -195,7 +195,17 @@ function createScene() {
 
     // MORPHS
 
-    function addMorph(mesh, clip, speed, duration, x, y, z, fudgeColor, massOptimization) {
+    function addMorph(
+        mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial> & { speed?: number },
+        clip: THREE.AnimationClip,
+        speed: number,
+        duration: number,
+        x: number,
+        y: number,
+        z: number,
+        fudgeColor: boolean,
+        massOptimization: boolean,
+    ) {
         mesh = mesh.clone();
         mesh.material = mesh.material.clone();
 
@@ -242,7 +252,7 @@ function createScene() {
 
     const gltfLoader = new GLTFLoader();
     gltfLoader.load('models/gltf/Horse.glb', function (gltf) {
-        const mesh = gltf.scene.children[0];
+        const mesh = gltf.scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
         const clip = gltf.animations[0];
 
         for (let i = -600; i < 601; i += 2) {
@@ -269,7 +279,7 @@ function render() {
     for (let i = 0; i < morphs.length; i++) {
         morph = morphs[i];
 
-        morph.position.x += morph.speed * delta;
+        morph.position.x += morph.speed! * delta;
 
         if (morph.position.x > 2000) {
             morph.position.x = -1000 - Math.random() * 500;
diff --git a/examples-testing/examples/webgl_shadowmap_pointlight.ts b/examples-testing/examples/webgl_shadowmap_pointlight.ts
index f921519..d39eb4e 100644
--- a/examples-testing/examples/webgl_shadowmap_pointlight.ts
+++ b/examples-testing/examples/webgl_shadowmap_pointlight.ts
@@ -4,8 +4,8 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, stats;
-let pointLight, pointLight2;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let pointLight: THREE.PointLight, pointLight2: THREE.PointLight;
 
 init();
 animate();
@@ -19,7 +19,7 @@ function init() {
 
     // lights
 
-    function createLight(color) {
+    function createLight(color: number) {
         const intensity = 200;
 
         const light = new THREE.PointLight(color, intensity, 20);
@@ -27,9 +27,9 @@ function init() {
         light.shadow.bias = -0.005; // reduces self-shadowing on double-sided objects
 
         let geometry = new THREE.SphereGeometry(0.3, 12, 6);
-        let material = new THREE.MeshBasicMaterial({ color: color });
+        let material: THREE.MeshBasicMaterial | THREE.MeshPhongMaterial = new THREE.MeshBasicMaterial({ color: color });
         material.color.multiplyScalar(intensity);
-        let sphere = new THREE.Mesh(geometry, material);
+        let sphere = new THREE.Mesh<THREE.BufferGeometry, THREE.Material>(geometry, material);
         light.add(sphere);
 
         const texture = new THREE.CanvasTexture(generateTexture());
@@ -107,7 +107,7 @@ function generateTexture() {
     canvas.width = 2;
     canvas.height = 2;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     context.fillStyle = 'white';
     context.fillRect(0, 1, 2, 1);
 
diff --git a/examples-testing/examples/webgl_shadowmap_progressive.ts b/examples-testing/examples/webgl_shadowmap_progressive.ts
index eaf6e32..d3592c8 100644
--- a/examples-testing/examples/webgl_shadowmap_progressive.ts
+++ b/examples-testing/examples/webgl_shadowmap_progressive.ts
@@ -9,17 +9,17 @@ import { ProgressiveLightMap } from 'three/addons/misc/ProgressiveLightMap.js';
 const shadowMapRes = 512,
     lightMapRes = 1024,
     lightCount = 8;
-let camera,
-    scene,
-    renderer,
-    controls,
-    control,
-    control2,
-    object = new THREE.Mesh(),
-    lightOrigin = null,
-    progressiveSurfacemap;
-const dirLights = [],
-    lightmapObjects = [];
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    controls: OrbitControls,
+    control: TransformControls,
+    control2: TransformControls,
+    object: THREE.Object3D = new THREE.Mesh(),
+    lightOrigin: THREE.Group | null = null,
+    progressiveSurfacemap: ProgressiveLightMap;
+const dirLights: THREE.DirectionalLight[] = [],
+    lightmapObjects: THREE.Object3D[] = [];
 const params = {
     Enable: true,
     'Blur Edges': true,
@@ -98,11 +98,11 @@ function init() {
     // model
     function loadModel() {
         object.traverse(function (child) {
-            if (child.isMesh) {
+            if ((child as THREE.Mesh).isMesh) {
                 child.name = 'Loaded Mesh';
                 child.castShadow = true;
                 child.receiveShadow = true;
-                child.material = new THREE.MeshPhongMaterial();
+                (child as THREE.Mesh).material = new THREE.MeshPhongMaterial();
 
                 // This adds the model to the lightmap
                 lightmapObjects.push(child);
@@ -128,7 +128,7 @@ function init() {
 
         object.add(lightTarget);
 
-        if (typeof TESTING !== 'undefined') {
+        if (typeof (window as any).TESTING !== 'undefined') {
             for (let i = 0; i < 300; i++) {
                 render();
             }
@@ -188,9 +188,9 @@ function render() {
         // Sometimes they will be uniformly sampled from the upper hemisphere
         if (Math.random() > params['Ambient Weight']) {
             dirLights[l].position.set(
-                lightOrigin.position.x + Math.random() * params['Light Radius'],
-                lightOrigin.position.y + Math.random() * params['Light Radius'],
-                lightOrigin.position.z + Math.random() * params['Light Radius'],
+                lightOrigin!.position.x + Math.random() * params['Light Radius'],
+                lightOrigin!.position.y + Math.random() * params['Light Radius'],
+                lightOrigin!.position.z + Math.random() * params['Light Radius'],
             );
         } else {
             // Uniform Hemispherical Surface Distribution for Ambient Occlusion
diff --git a/examples-testing/examples/webgl_shadowmap_viewer.ts b/examples-testing/examples/webgl_shadowmap_viewer.ts
index 311cefe..c99b054 100644
--- a/examples-testing/examples/webgl_shadowmap_viewer.ts
+++ b/examples-testing/examples/webgl_shadowmap_viewer.ts
@@ -5,10 +5,14 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { ShadowMapViewer } from 'three/addons/utils/ShadowMapViewer.js';
 
-let camera, scene, renderer, clock, stats;
-let dirLight, spotLight;
-let torusKnot, cube;
-let dirLightShadowMapViewer, spotLightShadowMapViewer;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    stats: Stats;
+let dirLight: THREE.DirectionalLight, spotLight: THREE.SpotLight;
+let torusKnot: THREE.Mesh, cube: THREE.Mesh;
+let dirLightShadowMapViewer: ShadowMapViewer, spotLightShadowMapViewer: ShadowMapViewer;
 
 init();
 animate();
@@ -63,7 +67,7 @@ function initScene() {
     scene.add(new THREE.CameraHelper(dirLight.shadow.camera));
 
     // Geometry
-    let geometry = new THREE.TorusKnotGeometry(25, 8, 75, 20);
+    let geometry: THREE.BufferGeometry = new THREE.TorusKnotGeometry(25, 8, 75, 20);
     let material = new THREE.MeshPhongMaterial({
         color: 0xff0000,
         shininess: 150,
diff --git a/examples-testing/examples/webgl_shadowmap_vsm.ts b/examples-testing/examples/webgl_shadowmap_vsm.ts
index 2e42ab5..9ea1dde 100644
--- a/examples-testing/examples/webgl_shadowmap_vsm.ts
+++ b/examples-testing/examples/webgl_shadowmap_vsm.ts
@@ -5,9 +5,13 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, clock, stats;
-let dirLight, spotLight;
-let torusKnot, dirGroup;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    stats: Stats;
+let dirLight: THREE.DirectionalLight, spotLight: THREE.SpotLight;
+let torusKnot: THREE.Mesh, dirGroup: THREE.Group;
 
 init();
 animate();
@@ -184,7 +188,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function animate(time) {
+function animate(time?: DOMHighResTimeStamp) {
     requestAnimationFrame(animate);
 
     const delta = clock.getDelta();
@@ -194,7 +198,7 @@ function animate(time) {
     torusKnot.rotation.z += 1 * delta;
 
     dirGroup.rotation.y += 0.7 * delta;
-    dirLight.position.z = 17 + Math.sin(time * 0.001) * 5;
+    dirLight.position.z = 17 + Math.sin(time! * 0.001) * 5;
 
     renderer.render(scene, camera);
 
diff --git a/examples-testing/examples/webgl_shadowmesh.ts b/examples-testing/examples/webgl_shadowmesh.ts
index fd26313..203f44d 100644
--- a/examples-testing/examples/webgl_shadowmesh.ts
+++ b/examples-testing/examples/webgl_shadowmesh.ts
@@ -12,18 +12,18 @@ const renderer = new THREE.WebGLRenderer();
 
 const sunLight = new THREE.DirectionalLight('rgb(255,255,255)', 3);
 let useDirectionalLight = true;
-let arrowHelper1, arrowHelper2, arrowHelper3;
+let arrowHelper1: THREE.ArrowHelper, arrowHelper2: THREE.ArrowHelper, arrowHelper3: THREE.ArrowHelper;
 const arrowDirection = new THREE.Vector3();
 const arrowPosition1 = new THREE.Vector3();
 const arrowPosition2 = new THREE.Vector3();
 const arrowPosition3 = new THREE.Vector3();
-let groundMesh;
-let lightSphere, lightHolder;
-let pyramid, pyramidShadow;
-let sphere, sphereShadow;
-let cube, cubeShadow;
-let cylinder, cylinderShadow;
-let torus, torusShadow;
+let groundMesh: THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial>;
+let lightSphere: THREE.Mesh, lightHolder: THREE.Mesh;
+let pyramid: THREE.Mesh, pyramidShadow: ShadowMesh;
+let sphere: THREE.Mesh, sphereShadow: ShadowMesh;
+let cube: THREE.Mesh, cubeShadow: ShadowMesh;
+let cylinder: THREE.Mesh, cylinderShadow: ShadowMesh;
+let torus: THREE.Mesh, torusShadow: ShadowMesh;
 const normalVector = new THREE.Vector3(0, 1, 0);
 const planeConstant = 0.01; // this value must be slightly higher than the groundMesh's y position of 0.0
 const groundPlane = new THREE.Plane(normalVector, planeConstant);
@@ -41,7 +41,7 @@ function init() {
 
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
-    document.getElementById('container').appendChild(renderer.domElement);
+    document.getElementById('container')!.appendChild(renderer.domElement);
     window.addEventListener('resize', onWindowResize);
 
     camera.position.set(0, 2.5, 10);
@@ -149,7 +149,7 @@ function init() {
     pyramidShadow = new ShadowMesh(pyramid);
     scene.add(pyramidShadow);
 
-    document.getElementById('lightButton').addEventListener('click', lightButtonHandler);
+    document.getElementById('lightButton')!.addEventListener('click', lightButtonHandler);
 }
 
 function animate() {
@@ -204,7 +204,7 @@ function lightButtonHandler() {
     useDirectionalLight = !useDirectionalLight;
 
     if (useDirectionalLight) {
-        scene.background.setHex(0x0096ff);
+        (scene.background as THREE.Color).setHex(0x0096ff);
 
         groundMesh.material.color.setHex(0x008200);
         sunLight.position.set(5, 7, -1);
@@ -222,9 +222,9 @@ function lightButtonHandler() {
         lightSphere.visible = false;
         lightHolder.visible = false;
 
-        document.getElementById('lightButton').value = 'Switch to PointLight';
+        (document.getElementById('lightButton') as HTMLButtonElement).value = 'Switch to PointLight';
     } else {
-        scene.background.setHex(0x000000);
+        (scene.background as THREE.Color).setHex(0x000000);
 
         groundMesh.material.color.setHex(0x969696);
 
@@ -246,6 +246,6 @@ function lightButtonHandler() {
         lightSphere.visible = true;
         lightHolder.visible = true;
 
-        document.getElementById('lightButton').value = 'Switch to THREE.DirectionalLight';
+        (document.getElementById('lightButton') as HTMLButtonElement).value = 'Switch to THREE.DirectionalLight';
     }
 }
diff --git a/examples-testing/examples/webgl_simple_gi.ts b/examples-testing/examples/webgl_simple_gi.ts
index 5ce1d1d..0ddf9cf 100644
--- a/examples-testing/examples/webgl_simple_gi.ts
+++ b/examples-testing/examples/webgl_simple_gi.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 class GIMesh extends THREE.Mesh {
-    copy(source) {
+    copy(source: this) {
         super.copy(source);
 
         this.geometry = source.geometry.clone();
@@ -14,104 +14,109 @@ class GIMesh extends THREE.Mesh {
 
 //
 
-const SimpleGI = function (renderer, scene) {
-    const SIZE = 32,
-        SIZE2 = SIZE * SIZE;
+class SimpleGI {
+    constructor(renderer: THREE.WebGLRenderer, scene: THREE.Scene) {
+        const SIZE = 32,
+            SIZE2 = SIZE * SIZE;
 
-    const camera = new THREE.PerspectiveCamera(90, 1, 0.01, 100);
+        const camera = new THREE.PerspectiveCamera(90, 1, 0.01, 100);
 
-    scene.updateMatrixWorld(true);
+        scene.updateMatrixWorld(true);
 
-    let clone = scene.clone();
-    clone.matrixWorldAutoUpdate = false;
+        let clone = scene.clone();
+        clone.matrixWorldAutoUpdate = false;
 
-    const rt = new THREE.WebGLRenderTarget(SIZE, SIZE);
+        const rt = new THREE.WebGLRenderTarget(SIZE, SIZE);
 
-    const normalMatrix = new THREE.Matrix3();
+        const normalMatrix = new THREE.Matrix3();
 
-    const position = new THREE.Vector3();
-    const normal = new THREE.Vector3();
+        const position = new THREE.Vector3();
+        const normal = new THREE.Vector3();
 
-    let bounces = 0;
-    let currentVertex = 0;
+        let bounces = 0;
+        let currentVertex = 0;
 
-    const color = new Float32Array(3);
-    const buffer = new Uint8Array(SIZE2 * 4);
+        const color = new Float32Array(3);
+        const buffer = new Uint8Array(SIZE2 * 4);
 
-    function compute() {
-        if (bounces === 3) return;
+        function compute() {
+            if (bounces === 3) return;
 
-        const object = scene.children[0]; // torusKnot
-        const geometry = object.geometry;
+            const object = scene.children[0] as GIMesh; // torusKnot
+            const geometry = object.geometry;
 
-        const attributes = geometry.attributes;
-        const positions = attributes.position.array;
-        const normals = attributes.normal.array;
+            const attributes = geometry.attributes;
+            const positions = attributes.position.array;
+            const normals = attributes.normal.array;
 
-        if (attributes.color === undefined) {
-            const colors = new Float32Array(positions.length);
-            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));
-        }
+            if (attributes.color === undefined) {
+                const colors = new Float32Array(positions.length);
+                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));
+            }
 
-        const colors = attributes.color.array;
+            const colors = attributes.color.array;
 
-        const startVertex = currentVertex;
-        const totalVertex = positions.length / 3;
+            const startVertex = currentVertex;
+            const totalVertex = positions.length / 3;
 
-        for (let i = 0; i < 32; i++) {
-            if (currentVertex >= totalVertex) break;
+            for (let i = 0; i < 32; i++) {
+                if (currentVertex >= totalVertex) break;
 
-            position.fromArray(positions, currentVertex * 3);
-            position.applyMatrix4(object.matrixWorld);
+                position.fromArray(positions, currentVertex * 3);
+                position.applyMatrix4(object.matrixWorld);
 
-            normal.fromArray(normals, currentVertex * 3);
-            normal.applyMatrix3(normalMatrix.getNormalMatrix(object.matrixWorld)).normalize();
+                normal.fromArray(normals, currentVertex * 3);
+                normal.applyMatrix3(normalMatrix.getNormalMatrix(object.matrixWorld)).normalize();
 
-            camera.position.copy(position);
-            camera.lookAt(position.add(normal));
+                camera.position.copy(position);
+                camera.lookAt(position.add(normal));
 
-            renderer.setRenderTarget(rt);
-            renderer.render(clone, camera);
+                renderer.setRenderTarget(rt);
+                renderer.render(clone, camera);
 
-            renderer.readRenderTargetPixels(rt, 0, 0, SIZE, SIZE, buffer);
+                renderer.readRenderTargetPixels(rt, 0, 0, SIZE, SIZE, buffer);
 
-            color[0] = 0;
-            color[1] = 0;
-            color[2] = 0;
+                color[0] = 0;
+                color[1] = 0;
+                color[2] = 0;
 
-            for (let k = 0, kl = buffer.length; k < kl; k += 4) {
-                color[0] += buffer[k + 0];
-                color[1] += buffer[k + 1];
-                color[2] += buffer[k + 2];
-            }
+                for (let k = 0, kl = buffer.length; k < kl; k += 4) {
+                    color[0] += buffer[k + 0];
+                    color[1] += buffer[k + 1];
+                    color[2] += buffer[k + 2];
+                }
 
-            colors[currentVertex * 3 + 0] = color[0] / (SIZE2 * 255);
-            colors[currentVertex * 3 + 1] = color[1] / (SIZE2 * 255);
-            colors[currentVertex * 3 + 2] = color[2] / (SIZE2 * 255);
+                colors[currentVertex * 3 + 0] = color[0] / (SIZE2 * 255);
+                colors[currentVertex * 3 + 1] = color[1] / (SIZE2 * 255);
+                colors[currentVertex * 3 + 2] = color[2] / (SIZE2 * 255);
 
-            currentVertex++;
-        }
+                currentVertex++;
+            }
 
-        attributes.color.addUpdateRange(startVertex * 3, (currentVertex - startVertex) * 3);
-        attributes.color.needsUpdate = true;
+            (attributes.color as THREE.BufferAttribute).addUpdateRange(
+                startVertex * 3,
+                (currentVertex - startVertex) * 3,
+            );
+            attributes.color.needsUpdate = true;
 
-        if (currentVertex >= totalVertex) {
-            clone = scene.clone();
-            clone.matrixWorldAutoUpdate = false;
+            if (currentVertex >= totalVertex) {
+                clone = scene.clone();
+                clone.matrixWorldAutoUpdate = false;
 
-            bounces++;
-            currentVertex = 0;
+                bounces++;
+                currentVertex = 0;
+            }
+
+            requestAnimationFrame(compute);
         }
 
         requestAnimationFrame(compute);
     }
-
-    requestAnimationFrame(compute);
-};
+}
 
 //
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_sprites.ts b/examples-testing/examples/webgl_sprites.ts
index 48dd8df..779ab97 100644
--- a/examples-testing/examples/webgl_sprites.ts
+++ b/examples-testing/examples/webgl_sprites.ts
@@ -1,13 +1,17 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
-let cameraOrtho, sceneOrtho;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let cameraOrtho: THREE.OrthographicCamera, sceneOrtho: THREE.Scene;
 
-let spriteTL, spriteTR, spriteBL, spriteBR, spriteC;
+let spriteTL: THREE.Sprite,
+    spriteTR: THREE.Sprite,
+    spriteBL: THREE.Sprite,
+    spriteBR: THREE.Sprite,
+    spriteC: THREE.Sprite;
 
-let mapC;
+let mapC: THREE.Texture;
 
-let group;
+let group: THREE.Group;
 
 init();
 animate();
@@ -58,8 +62,8 @@ function init() {
         } else {
             material = materialC.clone();
             material.color.setHSL(0.5 * Math.random(), 0.75, 0.5);
-            material.map.offset.set(-0.5, -0.5);
-            material.map.repeat.set(2, 2);
+            material.map!.offset.set(-0.5, -0.5);
+            material.map!.repeat.set(2, 2);
         }
 
         const sprite = new THREE.Sprite(material);
@@ -87,13 +91,13 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function createHUDSprites(texture) {
+function createHUDSprites(texture: THREE.Texture) {
     texture.colorSpace = THREE.SRGBColorSpace;
 
     const material = new THREE.SpriteMaterial({ map: texture });
 
-    const width = material.map.image.width;
-    const height = material.map.image.height;
+    const width = material.map!.image.width;
+    const height = material.map!.image.height;
 
     spriteTL = new THREE.Sprite(material);
     spriteTL.center.set(0.0, 1.0);
@@ -161,7 +165,7 @@ function render() {
     const time = Date.now() / 1000;
 
     for (let i = 0, l = group.children.length; i < l; i++) {
-        const sprite = group.children[i];
+        const sprite = group.children[i] as THREE.Sprite;
         const material = sprite.material;
         const scale = Math.sin(time + sprite.position.x * 0.01) * 0.3 + 1.0;
 
diff --git a/examples-testing/examples/webgl_test_memory.ts b/examples-testing/examples/webgl_test_memory.ts
index 39ca2cc..8c9511f 100644
--- a/examples-testing/examples/webgl_test_memory.ts
+++ b/examples-testing/examples/webgl_test_memory.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -26,7 +26,7 @@ function createImage() {
     canvas.width = 256;
     canvas.height = 256;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     context.fillStyle =
         'rgb(' +
         Math.floor(Math.random() * 256) +
diff --git a/examples-testing/examples/webgl_test_memory2.ts b/examples-testing/examples/webgl_test_memory2.ts
index 366a279..74077e9 100644
--- a/examples-testing/examples/webgl_test_memory2.ts
+++ b/examples-testing/examples/webgl_test_memory2.ts
@@ -2,15 +2,15 @@ import * as THREE from 'three';
 
 const N = 100;
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let geometry;
+let geometry: THREE.SphereGeometry;
 
-const meshes = [];
+const meshes: THREE.Mesh<THREE.SphereGeometry, THREE.ShaderMaterial>[] = [];
 
-let fragmentShader, vertexShader;
+let fragmentShader: string, vertexShader: string;
 
 init();
 setInterval(render, 1000 / 60);
@@ -19,8 +19,8 @@ function init() {
     container = document.createElement('div');
     document.body.appendChild(container);
 
-    vertexShader = document.getElementById('vertexShader').textContent;
-    fragmentShader = document.getElementById('fragmentShader').textContent;
+    vertexShader = document.getElementById('vertexShader')!.textContent!;
+    fragmentShader = document.getElementById('fragmentShader')!.textContent!;
 
     camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 2000;
@@ -70,12 +70,12 @@ function render() {
 
     renderer.render(scene, camera);
 
-    console.log('before', renderer.info.programs.length);
+    console.log('before', renderer.info.programs!.length);
 
     for (let i = 0; i < N; i++) {
         const mesh = meshes[i];
         mesh.material.dispose();
     }
 
-    console.log('after', renderer.info.programs.length);
+    console.log('after', renderer.info.programs!.length);
 }
diff --git a/examples-testing/examples/webgl_test_wide_gamut.ts b/examples-testing/examples/webgl_test_wide_gamut.ts
index fa96129..58f8d4a 100644
--- a/examples-testing/examples/webgl_test_wide_gamut.ts
+++ b/examples-testing/examples/webgl_test_wide_gamut.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three';
 
 import WebGL from 'three/addons/capabilities/WebGL.js';
 
-let container, camera, renderer, loader;
-let sceneL, sceneR, textureL, textureR;
+let container: HTMLElement, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, loader: THREE.TextureLoader;
+let sceneL: THREE.Scene, sceneR: THREE.Scene, textureL: THREE.Texture, textureR: THREE.Texture;
 
 let sliderPos = window.innerWidth / 2;
 
@@ -16,7 +16,7 @@ if (isP3Context) {
 init();
 
 function init() {
-    container = document.querySelector('.container');
+    container = document.querySelector('.container')!;
 
     sceneL = new THREE.Scene();
     sceneR = new THREE.Scene();
@@ -58,9 +58,9 @@ async function initTextures() {
 }
 
 function initSlider() {
-    const slider = document.querySelector('.slider');
+    const slider = document.querySelector('.slider') as HTMLElement;
 
-    function onPointerDown() {
+    function onPointerDown(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
         window.addEventListener('pointermove', onPointerMove);
@@ -72,10 +72,10 @@ function initSlider() {
         window.removeEventListener('pointerup', onPointerUp);
     }
 
-    function onPointerMove(e) {
+    function onPointerMove(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
-        sliderPos = Math.max(0, Math.min(window.innerWidth, e.pageX));
+        sliderPos = Math.max(0, Math.min(window.innerWidth, event.pageX));
 
         slider.style.left = sliderPos - slider.offsetWidth / 2 + 'px';
     }
@@ -90,18 +90,18 @@ function onWindowResize() {
 
     renderer.setSize(window.innerWidth, window.innerHeight);
 
-    containTexture(window.innerWidth / window.innerHeight, sceneL.background);
-    containTexture(window.innerWidth / window.innerHeight, sceneR.background);
+    containTexture(window.innerWidth / window.innerHeight, sceneL.background as THREE.Texture);
+    containTexture(window.innerWidth / window.innerHeight, sceneR.background as THREE.Texture);
 }
 
-function onGamutChange({ matches }) {
+function onGamutChange({ matches }: MediaQueryListEvent) {
     renderer.outputColorSpace = isP3Context && matches ? THREE.DisplayP3ColorSpace : THREE.SRGBColorSpace;
 
     textureL.needsUpdate = true;
     textureR.needsUpdate = true;
 }
 
-function containTexture(aspect, target) {
+function containTexture(aspect: number, target: THREE.Texture) {
     // Sets the matrix uv transform so the texture image is contained in a region having the specified aspect ratio,
     // and does so without distortion. Akin to CSS object-fit: contain.
     // Source: https://github.com/mrdoob/three.js/pull/17199
diff --git a/examples-testing/examples/webgl_tonemapping.ts b/examples-testing/examples/webgl_tonemapping.ts
index 08115cf..f68d7a8 100644
--- a/examples-testing/examples/webgl_tonemapping.ts
+++ b/examples-testing/examples/webgl_tonemapping.ts
@@ -1,22 +1,35 @@
 import * as THREE from 'three';
 
-import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
+import { GUI, NumberController } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 
-let mesh, renderer, scene, camera, controls;
-let gui,
-    guiExposure = null;
+type ToneMapping = 'None' | 'Linear' | 'Reinhard' | 'Cineon' | 'ACESFilmic' | 'AgX' | 'Neutral' | 'Custom';
 
-const params = {
+interface Params {
+    exposure: number;
+    toneMapping: ToneMapping;
+    blurriness: number;
+    intensity: number;
+}
+
+let mesh: THREE.Object3D,
+    renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    controls: OrbitControls;
+let gui: GUI,
+    guiExposure: NumberController<Params, 'exposure'> | null = null;
+
+const params: Params = {
     exposure: 1.0,
     toneMapping: 'AgX',
     blurriness: 0.3,
     intensity: 1.0,
 };
 
-const toneMappingOptions = {
+const toneMappingOptions: { [K in ToneMapping]: THREE.ToneMapping } = {
     None: THREE.NoToneMapping,
     Linear: THREE.LinearToneMapping,
     Reinhard: THREE.ReinhardToneMapping,
@@ -88,7 +101,7 @@ async function init() {
 
     // model
 
-    mesh = gltf.scene.getObjectByName('node_damagedHelmet_-6514');
+    mesh = gltf.scene.getObjectByName('node_damagedHelmet_-6514')!;
     scene.add(mesh);
 
     render();
@@ -99,7 +112,7 @@ async function init() {
     const toneMappingFolder = gui.addFolder('tone mapping');
 
     toneMappingFolder
-        .add(params, 'toneMapping', Object.keys(toneMappingOptions))
+        .add(params, 'toneMapping', Object.keys(toneMappingOptions) as ToneMapping[])
 
         .onChange(function () {
             updateGUI(toneMappingFolder);
@@ -131,7 +144,7 @@ async function init() {
     gui.open();
 }
 
-function updateGUI(folder) {
+function updateGUI(folder: GUI) {
     if (guiExposure !== null) {
         guiExposure.destroy();
         guiExposure = null;
diff --git a/examples-testing/examples/webgl_video_kinect.ts b/examples-testing/examples/webgl_video_kinect.ts
index 3c4d78b..298f025 100644
--- a/examples-testing/examples/webgl_video_kinect.ts
+++ b/examples-testing/examples/webgl_video_kinect.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, renderer;
-let geometry, mesh, material;
-let mouse, center;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer;
+let geometry: THREE.BufferGeometry, mesh: THREE.Points, material: THREE.ShaderMaterial;
+let mouse: THREE.Vector3, center: THREE.Vector3;
 
 init();
 animate();
@@ -25,7 +25,7 @@ function init() {
     center = new THREE.Vector3();
     center.z = -1000;
 
-    const video = document.getElementById('video');
+    const video = document.getElementById('video') as HTMLVideoElement;
 
     const texture = new THREE.VideoTexture(video);
     texture.minFilter = THREE.NearestFilter;
@@ -57,8 +57,8 @@ function init() {
             pointSize: { value: 2 },
             zOffset: { value: 1000 },
         },
-        vertexShader: document.getElementById('vs').textContent,
-        fragmentShader: document.getElementById('fs').textContent,
+        vertexShader: document.getElementById('vs')!.textContent!,
+        fragmentShader: document.getElementById('fs')!.textContent!,
         blending: THREE.AdditiveBlending,
         depthTest: false,
         depthWrite: false,
@@ -99,7 +99,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouse.x = (event.clientX - window.innerWidth / 2) * 8;
     mouse.y = (event.clientY - window.innerHeight / 2) * 8;
 }
diff --git a/examples-testing/examples/webgl_video_panorama_equirectangular.ts b/examples-testing/examples/webgl_video_panorama_equirectangular.ts
index 9fc58dc..f35ab49 100644
--- a/examples-testing/examples/webgl_video_panorama_equirectangular.ts
+++ b/examples-testing/examples/webgl_video_panorama_equirectangular.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let isUserInteracting = false,
     lon = 0,
@@ -18,7 +18,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.25, 10);
 
@@ -28,7 +28,7 @@ function init() {
     // invert the geometry on the x-axis so that all of the faces point inward
     geometry.scale(-1, 1, 1);
 
-    const video = document.getElementById('video');
+    const video = document.getElementById('video') as HTMLVideoElement;
     video.play();
 
     const texture = new THREE.VideoTexture(video);
@@ -59,7 +59,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     isUserInteracting = true;
 
     onPointerDownPointerX = event.clientX;
@@ -69,7 +69,7 @@ function onPointerDown(event) {
     onPointerDownLat = lat;
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (isUserInteracting === true) {
         lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
         lat = (onPointerDownPointerY - event.clientY) * 0.1 + onPointerDownLat;
diff --git a/examples-testing/examples/webgl_water.ts b/examples-testing/examples/webgl_water.ts
index f9e81d1..7329a9c 100644
--- a/examples-testing/examples/webgl_water.ts
+++ b/examples-testing/examples/webgl_water.ts
@@ -4,9 +4,13 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Water } from 'three/addons/objects/Water2.js';
 
-let scene, camera, clock, renderer, water;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    clock: THREE.Clock,
+    renderer: THREE.WebGLRenderer,
+    water: Water;
 
-let torusKnot;
+let torusKnot: THREE.Mesh;
 
 const params = {
     color: '#ffffff',
diff --git a/examples-testing/examples/webgl_water_flowmap.ts b/examples-testing/examples/webgl_water_flowmap.ts
index 6aadaf2..bb7fa30 100644
--- a/examples-testing/examples/webgl_water_flowmap.ts
+++ b/examples-testing/examples/webgl_water_flowmap.ts
@@ -4,7 +4,7 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Water } from 'three/addons/objects/Water2.js';
 
-let scene, camera, renderer, water;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, water: Water;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgpu_backdrop_area.ts b/examples-testing/examples/webgpu_backdrop_area.ts
index a40092c..9dc155c 100644
--- a/examples-testing/examples/webgpu_backdrop_area.ts
+++ b/examples-testing/examples/webgpu_backdrop_area.ts
@@ -24,8 +24,8 @@ import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
-let mixer, clock;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: WebGPURenderer;
+let mixer: THREE.AnimationMixer, clock: THREE.Clock;
 
 init();
 
@@ -137,13 +137,13 @@ function init() {
     };
 
     const gui = new GUI();
-    const options = { material: 'blurred' };
+    const options: { material: keyof typeof materials } = { material: 'blurred' };
 
     box.material = materials[options.material];
 
     gui.add(box.scale, 'x', 0.1, 2, 0.01);
     gui.add(box.scale, 'z', 0.1, 2, 0.01);
-    gui.add(options, 'material', Object.keys(materials)).onChange(name => {
+    gui.add(options, 'material', Object.keys(materials) as (keyof typeof materials)[]).onChange(name => {
         box.material = materials[name];
     });
 }
diff --git a/examples-testing/examples/webgpu_camera_logarithmicdepthbuffer.ts b/examples-testing/examples/webgpu_camera_logarithmicdepthbuffer.ts
index 2e0d37c..deac7ad 100644
--- a/examples-testing/examples/webgpu_camera_logarithmicdepthbuffer.ts
+++ b/examples-testing/examples/webgpu_camera_logarithmicdepthbuffer.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three';
 
-import { FontLoader } from 'three/addons/loaders/FontLoader.js';
+import { Font, FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
 import WebGPU from 'three/addons/capabilities/WebGPU.js';
@@ -22,8 +22,16 @@ let zoompos = -100,
     minzoomspeed = 0.015;
 let zoomspeed = minzoomspeed;
 
-let container, border, stats;
-const objects = {};
+let container: HTMLElement, border: HTMLElement, stats: Stats;
+
+interface ObjectView {
+    container: HTMLElement;
+    renderer: WebGPURenderer;
+    scene: THREE.Scene;
+    camera: THREE.PerspectiveCamera;
+}
+
+const objects: { normal?: ObjectView; logzbuf?: ObjectView } = {};
 
 // Generate a number of text labels, from 1m in size up to 100,000,000 light years
 // Try to use some descriptive real-world examples of objects at each scale
@@ -55,7 +63,7 @@ function init() {
         throw new Error('No WebGPU or WebGL2 support');
     }
 
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     const loader = new FontLoader();
     loader.load('fonts/helvetiker_regular.typeface.json', function (font) {
@@ -70,7 +78,7 @@ function init() {
     container.appendChild(stats.dom);
 
     // Resize border allows the user to easily compare effects of logarithmic depth buffer over the whole scene
-    border = document.getElementById('renderer_border');
+    border = document.getElementById('renderer_border')!;
     border.addEventListener('pointerdown', onBorderPointerDown);
 
     window.addEventListener('mousemove', onMouseMove);
@@ -78,8 +86,8 @@ function init() {
     window.addEventListener('wheel', onMouseWheel);
 }
 
-function initView(scene, name, logDepthBuf) {
-    const framecontainer = document.getElementById('container_' + name);
+function initView(scene: THREE.Scene, name: string, logDepthBuf: boolean) {
+    const framecontainer = document.getElementById('container_' + name)!;
 
     const camera = new THREE.PerspectiveCamera(50, (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT, NEAR, FAR);
     scene.add(camera);
@@ -95,7 +103,7 @@ function initView(scene, name, logDepthBuf) {
     return { container: framecontainer, renderer: renderer, scene: scene, camera: camera };
 }
 
-function initScene(font) {
+function initScene(font: Font) {
     const scene = new THREE.Scene();
 
     scene.add(new THREE.AmbientLight(0x777777));
@@ -104,7 +112,7 @@ function initScene(font) {
     light.position.set(100, 100, 100);
     scene.add(light);
 
-    const materialargs = {
+    const materialargs: { color: THREE.ColorRepresentation; specular: number; shininess: number; emissive: number } = {
         color: 0xffffff,
         specular: 0x050505,
         shininess: 50,
@@ -125,7 +133,7 @@ function initScene(font) {
         labelgeo.computeBoundingSphere();
 
         // center text
-        labelgeo.translate(-labelgeo.boundingSphere.radius, 0, 0);
+        labelgeo.translate(-labelgeo.boundingSphere!.radius, 0, 0);
 
         materialargs.color = new THREE.Color().setHSL(Math.random(), 0.5, 0.5);
 
@@ -158,16 +166,16 @@ function updateRendererSizes() {
 
     screensplit_right = 1 - screensplit;
 
-    objects.normal.renderer.setSize(screensplit * SCREEN_WIDTH, SCREEN_HEIGHT);
-    objects.normal.camera.aspect = (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT;
-    objects.normal.camera.updateProjectionMatrix();
-    objects.normal.camera.setViewOffset(SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT);
-    objects.normal.container.style.width = screensplit * 100 + '%';
+    objects.normal!.renderer.setSize(screensplit * SCREEN_WIDTH, SCREEN_HEIGHT);
+    objects.normal!.camera.aspect = (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT;
+    objects.normal!.camera.updateProjectionMatrix();
+    objects.normal!.camera.setViewOffset(SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT);
+    objects.normal!.container.style.width = screensplit * 100 + '%';
 
-    objects.logzbuf.renderer.setSize(screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT);
-    objects.logzbuf.camera.aspect = (screensplit_right * SCREEN_WIDTH) / SCREEN_HEIGHT;
-    objects.logzbuf.camera.updateProjectionMatrix();
-    objects.logzbuf.camera.setViewOffset(
+    objects.logzbuf!.renderer.setSize(screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT);
+    objects.logzbuf!.camera.aspect = (screensplit_right * SCREEN_WIDTH) / SCREEN_HEIGHT;
+    objects.logzbuf!.camera.updateProjectionMatrix();
+    objects.logzbuf!.camera.setViewOffset(
         SCREEN_WIDTH,
         SCREEN_HEIGHT,
         SCREEN_WIDTH * screensplit,
@@ -175,7 +183,7 @@ function updateRendererSizes() {
         SCREEN_WIDTH * screensplit_right,
         SCREEN_HEIGHT,
     );
-    objects.logzbuf.container.style.width = screensplit_right * 100 + '%';
+    objects.logzbuf!.container.style.width = screensplit_right * 100 + '%';
 
     border.style.left = screensplit * 100 + '%';
 }
@@ -198,22 +206,22 @@ function render() {
     zoompos += zoomspeed;
     zoomspeed *= damping;
 
-    objects.normal.camera.position.x = Math.sin(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
-    objects.normal.camera.position.y = Math.sin(0.25 * Math.PI * (mouse[1] - 0.5)) * zoom;
-    objects.normal.camera.position.z = Math.cos(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
-    objects.normal.camera.lookAt(objects.normal.scene.position);
+    objects.normal!.camera.position.x = Math.sin(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
+    objects.normal!.camera.position.y = Math.sin(0.25 * Math.PI * (mouse[1] - 0.5)) * zoom;
+    objects.normal!.camera.position.z = Math.cos(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
+    objects.normal!.camera.lookAt(objects.normal!.scene.position);
 
     // Clone camera settings across both scenes
-    objects.logzbuf.camera.position.copy(objects.normal.camera.position);
-    objects.logzbuf.camera.quaternion.copy(objects.normal.camera.quaternion);
+    objects.logzbuf!.camera.position.copy(objects.normal!.camera.position);
+    objects.logzbuf!.camera.quaternion.copy(objects.normal!.camera.quaternion);
 
     // Update renderer sizes if the split has changed
     if (screensplit_right != 1 - screensplit) {
         updateRendererSizes();
     }
 
-    objects.normal.renderer.render(objects.normal.scene, objects.normal.camera);
-    objects.logzbuf.renderer.render(objects.logzbuf.scene, objects.logzbuf.camera);
+    objects.normal!.renderer.render(objects.normal!.scene, objects.normal!.camera);
+    objects.logzbuf!.renderer.render(objects.logzbuf!.scene, objects.logzbuf!.camera);
 
     stats.update();
 }
@@ -228,7 +236,7 @@ function onBorderPointerDown() {
     window.addEventListener('pointerup', onBorderPointerUp);
 }
 
-function onBorderPointerMove(ev) {
+function onBorderPointerMove(ev: PointerEvent) {
     screensplit = Math.max(0, Math.min(1, ev.clientX / window.innerWidth));
 }
 
@@ -237,12 +245,12 @@ function onBorderPointerUp() {
     window.removeEventListener('pointerup', onBorderPointerUp);
 }
 
-function onMouseMove(ev) {
+function onMouseMove(ev: MouseEvent) {
     mouse[0] = ev.clientX / window.innerWidth;
     mouse[1] = ev.clientY / window.innerHeight;
 }
 
-function onMouseWheel(ev) {
+function onMouseWheel(ev: WheelEvent) {
     const amount = ev.deltaY;
     if (amount === 0) return;
     const dir = amount / Math.abs(amount);
diff --git a/examples-testing/examples/webgpu_clearcoat.ts b/examples-testing/examples/webgpu_clearcoat.ts
index 3705045..7fc1806 100644
--- a/examples-testing/examples/webgpu_clearcoat.ts
+++ b/examples-testing/examples/webgpu_clearcoat.ts
@@ -10,12 +10,12 @@ import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.
 
 import { FlakesTexture } from 'three/addons/textures/FlakesTexture.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: WebGPURenderer;
 
-let particleLight;
-let group;
+let particleLight: THREE.Mesh;
+let group: THREE.Group;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_clipping.ts b/examples-testing/examples/webgpu_clipping.ts
index c89b95f..60e0571 100644
--- a/examples-testing/examples/webgpu_clipping.ts
+++ b/examples-testing/examples/webgpu_clipping.ts
@@ -12,7 +12,12 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, startTime, object, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: WebGPURenderer,
+    startTime: number,
+    object: THREE.Mesh,
+    stats: Stats;
 
 init();
 
@@ -113,7 +118,7 @@ function init() {
 
     // ***** Clipping setup (renderer): *****
     const globalPlanes = [globalPlane];
-    const Empty = Object.freeze([]);
+    const Empty: readonly THREE.Plane[] = Object.freeze([]);
 
     renderer.clippingPlanes = Empty; // GUI sets it to globalPlanes
     renderer.localClippingEnabled = true;
@@ -132,7 +137,7 @@ function init() {
         folderLocal = gui.addFolder('Local Clipping'),
         propsLocal = {
             get Enabled() {
-                return renderer.localClippingEnabled;
+                return renderer.localClippingEnabled!;
             },
             set Enabled(v) {
                 renderer.localClippingEnabled = v;
@@ -205,7 +210,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function animate(currentTime) {
+function animate(currentTime: DOMHighResTimeStamp) {
     const time = (currentTime - startTime) / 1000;
 
     object.position.y = 0.8;
diff --git a/examples-testing/examples/webgpu_lights_ies_spotlight.ts b/examples-testing/examples/webgpu_lights_ies_spotlight.ts
index 1430a29..58b951d 100644
--- a/examples-testing/examples/webgpu_lights_ies_spotlight.ts
+++ b/examples-testing/examples/webgpu_lights_ies_spotlight.ts
@@ -7,12 +7,12 @@ import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
 
 import IESSpotLight from 'three/addons/lights/IESSpotLight.js';
 
-import { OrbitControls } from './jsm/controls/OrbitControls.js';
+import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-import { IESLoader } from './jsm/loaders/IESLoader.js';
+import { IESLoader } from 'three/addons/loaders/IESLoader.js';
 
-let renderer, scene, camera;
-let lights;
+let renderer: WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let lights: IESSpotLight[];
 
 async function init() {
     if (WebGPU.isAvailable() === false && WebGL.isWebGL2Available() === false) {
@@ -119,7 +119,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function render(time) {
+function render(time: number) {
     time = (time / 1000) * 2.0;
 
     for (let i = 0; i < lights.length; i++) {
diff --git a/examples-testing/examples/webgpu_loader_gltf.ts b/examples-testing/examples/webgpu_loader_gltf.ts
index d0fd310..7292c9e 100644
--- a/examples-testing/examples/webgpu_loader_gltf.ts
+++ b/examples-testing/examples/webgpu_loader_gltf.ts
@@ -10,7 +10,7 @@ import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: WebGPURenderer;
 
 init();
 render();
diff --git a/examples-testing/examples/webgpu_loader_gltf_compressed.ts b/examples-testing/examples/webgpu_loader_gltf_compressed.ts
index 74e7d69..bacdc10 100644
--- a/examples-testing/examples/webgpu_loader_gltf_compressed.ts
+++ b/examples-testing/examples/webgpu_loader_gltf_compressed.ts
@@ -8,7 +8,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: WebGPURenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_loader_gltf_iridescence.ts b/examples-testing/examples/webgpu_loader_gltf_iridescence.ts
index b36a9fe..d4c841b 100644
--- a/examples-testing/examples/webgpu_loader_gltf_iridescence.ts
+++ b/examples-testing/examples/webgpu_loader_gltf_iridescence.ts
@@ -9,7 +9,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 
-let renderer, scene, camera, controls;
+let renderer: WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
 
 init().catch(function (err) {
     console.error(err);
diff --git a/examples-testing/examples/webgpu_loader_gltf_sheen.ts b/examples-testing/examples/webgpu_loader_gltf_sheen.ts
index b8fb383..0bcc65c 100644
--- a/examples-testing/examples/webgpu_loader_gltf_sheen.ts
+++ b/examples-testing/examples/webgpu_loader_gltf_sheen.ts
@@ -11,7 +11,7 @@ import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: WebGPURenderer, controls: OrbitControls;
 
 init();
 
@@ -36,7 +36,10 @@ function init() {
     new GLTFLoader().setPath('models/gltf/').load('SheenChair.glb', function (gltf) {
         scene.add(gltf.scene);
 
-        const object = gltf.scene.getObjectByName('SheenChair_fabric');
+        const object = gltf.scene.getObjectByName('SheenChair_fabric') as THREE.Mesh<
+            THREE.BufferGeometry,
+            THREE.MeshPhysicalMaterial
+        >;
 
         const gui = new GUI();
 
diff --git a/examples-testing/examples/webgpu_materials_texture_anisotropy.ts b/examples-testing/examples/webgpu_materials_texture_anisotropy.ts
index ca0ae9e..2125232 100644
--- a/examples-testing/examples/webgpu_materials_texture_anisotropy.ts
+++ b/examples-testing/examples/webgpu_materials_texture_anisotropy.ts
@@ -3,9 +3,9 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene1, scene2, renderer;
+let camera: THREE.PerspectiveCamera, scene1: THREE.Scene, scene2: THREE.Scene, renderer: WebGPURenderer;
 
 let mouseX = 0,
     mouseY = 0;
@@ -76,11 +76,11 @@ function init() {
     texture2.repeat.set(512, 512);
 
     if (maxAnisotropy > 0) {
-        document.getElementById('val_left').innerHTML = texture1.anisotropy;
-        document.getElementById('val_right').innerHTML = texture2.anisotropy;
+        document.getElementById('val_left')!.innerHTML = texture1.anisotropy.toString();
+        document.getElementById('val_right')!.innerHTML = texture2.anisotropy.toString();
     } else {
-        document.getElementById('val_left').innerHTML = 'not supported';
-        document.getElementById('val_right').innerHTML = 'not supported';
+        document.getElementById('val_left')!.innerHTML = 'not supported';
+        document.getElementById('val_right')!.innerHTML = 'not supported';
     }
 
     //
@@ -115,7 +115,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     const windowHalfX = window.innerWidth / 2;
     const windowHalfY = window.innerHeight / 2;
 
diff --git a/examples-testing/examples/webgpu_materials_video.ts b/examples-testing/examples/webgpu_materials_video.ts
index fbbabfc..a1a82bd 100644
--- a/examples-testing/examples/webgpu_materials_video.ts
+++ b/examples-testing/examples/webgpu_materials_video.ts
@@ -2,11 +2,14 @@ import * as THREE from 'three';
 
 import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: WebGPURenderer;
 
-let video, texture, material, mesh;
+let video: HTMLVideoElement,
+    texture: THREE.VideoTexture,
+    material: THREE.MeshPhongMaterial & { hue?: number; saturation?: number },
+    mesh: THREE.Mesh & { dx?: number; dy?: number };
 
 let mouseX = 0;
 let mouseY = 0;
@@ -14,20 +17,20 @@ let mouseY = 0;
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
 
-let cube_count;
+let cube_count: number;
 
-const meshes = [],
-    materials = [],
+const meshes: THREE.Mesh[] = [],
+    materials: (THREE.MeshPhongMaterial & { hue?: number; saturation?: number })[] = [],
     xgrid = 20,
     ygrid = 10;
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', function () {
     init();
 });
 
 function init() {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
     container = document.createElement('div');
@@ -48,7 +51,7 @@ function init() {
     renderer.setAnimationLoop(render);
     container.appendChild(renderer.domElement);
 
-    video = document.getElementById('video');
+    video = document.getElementById('video') as HTMLVideoElement;
     video.play();
     video.addEventListener('play', function () {
         this.currentTime = 3;
@@ -124,7 +127,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function change_uvs(geometry, unitx, unity, offsetx, offsety) {
+function change_uvs(geometry: THREE.BoxGeometry, unitx: number, unity: number, offsetx: number, offsety: number) {
     const uvs = geometry.attributes.uv.array;
 
     for (let i = 0; i < uvs.length; i += 2) {
@@ -133,7 +136,7 @@ function change_uvs(geometry, unitx, unity, offsetx, offsety) {
     }
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = (event.clientY - windowHalfY) * 0.3;
 }
@@ -154,20 +157,20 @@ function render() {
     for (let i = 0; i < cube_count; i++) {
         material = materials[i];
 
-        h = ((360 * (material.hue + time)) % 360) / 360;
-        material.color.setHSL(h, material.saturation, 0.5);
+        h = ((360 * (material.hue! + time)) % 360) / 360;
+        material.color.setHSL(h, material.saturation!, 0.5);
     }
 
     if (counter % 1000 > 200) {
         for (let i = 0; i < cube_count; i++) {
             mesh = meshes[i];
 
-            mesh.rotation.x += 10 * mesh.dx;
-            mesh.rotation.y += 10 * mesh.dy;
+            mesh.rotation.x += 10 * mesh.dx!;
+            mesh.rotation.y += 10 * mesh.dy!;
 
-            mesh.position.x -= 150 * mesh.dx;
-            mesh.position.y += 150 * mesh.dy;
-            mesh.position.z += 300 * mesh.dx;
+            mesh.position.x -= 150 * mesh.dx!;
+            mesh.position.y += 150 * mesh.dy!;
+            mesh.position.z += 300 * mesh.dx!;
         }
     }
 
@@ -175,8 +178,8 @@ function render() {
         for (let i = 0; i < cube_count; i++) {
             mesh = meshes[i];
 
-            mesh.dx *= -1;
-            mesh.dy *= -1;
+            mesh.dx! *= -1;
+            mesh.dy! *= -1;
         }
     }
 
diff --git a/examples-testing/examples/webgpu_morphtargets.ts b/examples-testing/examples/webgpu_morphtargets.ts
index 751d39f..f54fb93 100644
--- a/examples-testing/examples/webgpu_morphtargets.ts
+++ b/examples-testing/examples/webgpu_morphtargets.ts
@@ -8,7 +8,11 @@ import WebGL from 'three/addons/capabilities/WebGL.js';
 
 import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
 
-let container, camera, scene, renderer, mesh;
+let container: HTMLElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: WebGPURenderer,
+    mesh: THREE.Mesh;
 
 init();
 
@@ -19,7 +23,7 @@ function init() {
         throw new Error('No WebGPU or WebGL2 support');
     }
 
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
     scene.background = new THREE.Color(0x8fbcd4);
@@ -73,7 +77,7 @@ function createGeometry() {
     const spherePositions = [];
 
     // for the second morph target, we'll twist the cubes vertices
-    const twistPositions = [];
+    const twistPositions: number[] = [];
     const direction = new THREE.Vector3(1, 0, 0);
     const vertex = new THREE.Vector3();
 
@@ -114,12 +118,12 @@ function initGUI() {
     gui.add(params, 'Spherify', 0, 1)
         .step(0.01)
         .onChange(function (value) {
-            mesh.morphTargetInfluences[0] = value;
+            mesh.morphTargetInfluences![0] = value;
         });
     gui.add(params, 'Twist', 0, 1)
         .step(0.01)
         .onChange(function (value) {
-            mesh.morphTargetInfluences[1] = value;
+            mesh.morphTargetInfluences![1] = value;
         });
 }
 
diff --git a/examples-testing/examples/webgpu_morphtargets_face.ts b/examples-testing/examples/webgpu_morphtargets_face.ts
index 3a13ab5..2850b1b 100644
--- a/examples-testing/examples/webgpu_morphtargets_face.ts
+++ b/examples-testing/examples/webgpu_morphtargets_face.ts
@@ -24,7 +24,7 @@ async function init() {
         throw new Error('No WebGPU or WebGL2 support');
     }
 
-    let mixer;
+    let mixer: THREE.AnimationMixer;
 
     const clock = new THREE.Clock();
 
@@ -61,8 +61,8 @@ async function init() {
 
             // GUI
 
-            const head = mesh.getObjectByName('mesh_2');
-            const influences = head.morphTargetInfluences;
+            const head = mesh.getObjectByName('mesh_2') as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
+            const influences = head.morphTargetInfluences!;
 
             //head.morphTargetInfluences = null;
 
@@ -72,7 +72,7 @@ async function init() {
             const gui = new GUI();
             gui.close();
 
-            for (const [key, value] of Object.entries(head.morphTargetDictionary)) {
+            for (const [key, value] of Object.entries(head.morphTargetDictionary!)) {
                 gui.add(influences, value, 0, 1, 0.01).name(key.replace('blendShape1.', '')).listen();
             }
         });
diff --git a/examples-testing/examples/webgpu_parallax_uv.ts b/examples-testing/examples/webgpu_parallax_uv.ts
index e042466..68f5e73 100644
--- a/examples-testing/examples/webgpu_parallax_uv.ts
+++ b/examples-testing/examples/webgpu_parallax_uv.ts
@@ -5,9 +5,9 @@ import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: WebGPURenderer;
 
-let controls;
+let controls: OrbitControls;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_postprocessing_afterimage.ts b/examples-testing/examples/webgpu_postprocessing_afterimage.ts
index b89f292..c3cfcdf 100644
--- a/examples-testing/examples/webgpu_postprocessing_afterimage.ts
+++ b/examples-testing/examples/webgpu_postprocessing_afterimage.ts
@@ -5,9 +5,10 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
 import PostProcessing from 'three/addons/renderers/common/PostProcessing.js';
 import { pass } from 'three/nodes';
+import type { AfterImageNode, ShaderNodeObject } from 'three/nodes';
 
-let camera, scene, renderer;
-let mesh, postProcessing, combinedPass;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: WebGPURenderer;
+let mesh: THREE.Mesh, postProcessing: PostProcessing, combinedPass: ShaderNodeObject<AfterImageNode>;
 
 const params = {
     damp: 0.96,
@@ -41,8 +42,7 @@ function init() {
     const scenePass = pass(scene, camera);
     const scenePassColor = scenePass.getTextureNode();
 
-    combinedPass = scenePassColor;
-    combinedPass = combinedPass.afterImage(params.damp);
+    combinedPass = scenePassColor.afterImage(params.damp);
 
     postProcessing.outputNode = combinedPass;
 
diff --git a/examples-testing/examples/webgpu_video_panorama.ts b/examples-testing/examples/webgpu_video_panorama.ts
index c6e051f..dca0db3 100644
--- a/examples-testing/examples/webgpu_video_panorama.ts
+++ b/examples-testing/examples/webgpu_video_panorama.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 
 import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: WebGPURenderer;
 
 let isUserInteracting = false,
     lon = 0,
@@ -19,7 +19,7 @@ const distance = 0.5;
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.25, 10);
 
@@ -29,7 +29,7 @@ function init() {
     // invert the geometry on the x-axis so that all of the faces point inward
     geometry.scale(-1, 1, 1);
 
-    const video = document.getElementById('video');
+    const video = document.getElementById('video') as HTMLVideoElement;
     video.play();
 
     const texture = new THREE.VideoTexture(video);
@@ -61,7 +61,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     isUserInteracting = true;
 
     onPointerDownPointerX = event.clientX;
@@ -71,7 +71,7 @@ function onPointerDown(event) {
     onPointerDownLat = lat;
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (isUserInteracting === true) {
         lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
         lat = (onPointerDownPointerY - event.clientY) * 0.1 + onPointerDownLat;
diff --git a/examples-testing/examples/webxr_ar_cones.ts b/examples-testing/examples/webxr_ar_cones.ts
index 996e41f..03af8ca 100644
--- a/examples-testing/examples/webxr_ar_cones.ts
+++ b/examples-testing/examples/webxr_ar_cones.ts
@@ -1,8 +1,8 @@
 import * as THREE from 'three';
 import { ARButton } from 'three/addons/webxr/ARButton.js';
 
-let camera, scene, renderer;
-let controller;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controller: THREE.XRTargetRaySpace;
 
 init();
 animate();
diff --git a/examples-testing/examples/webxr_ar_hittest.ts b/examples-testing/examples/webxr_ar_hittest.ts
index 5540c90..0cd8a4f 100644
--- a/examples-testing/examples/webxr_ar_hittest.ts
+++ b/examples-testing/examples/webxr_ar_hittest.ts
@@ -1,13 +1,13 @@
 import * as THREE from 'three';
 import { ARButton } from 'three/addons/webxr/ARButton.js';
 
-let container;
-let camera, scene, renderer;
-let controller;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controller: THREE.XRTargetRaySpace;
 
-let reticle;
+let reticle: THREE.Mesh;
 
-let hitTestSource = null;
+let hitTestSource: XRHitTestSource | null = null;
 let hitTestSourceRequested = false;
 
 init();
@@ -81,14 +81,14 @@ function animate() {
     renderer.setAnimationLoop(render);
 }
 
-function render(timestamp, frame) {
+function render(timestamp: DOMHighResTimeStamp, frame: XRFrame) {
     if (frame) {
         const referenceSpace = renderer.xr.getReferenceSpace();
-        const session = renderer.xr.getSession();
+        const session = renderer.xr.getSession()!;
 
         if (hitTestSourceRequested === false) {
             session.requestReferenceSpace('viewer').then(function (referenceSpace) {
-                session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
+                session.requestHitTestSource!({ space: referenceSpace })!.then(function (source) {
                     hitTestSource = source;
                 });
             });
@@ -108,7 +108,7 @@ function render(timestamp, frame) {
                 const hit = hitTestResults[0];
 
                 reticle.visible = true;
-                reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
+                reticle.matrix.fromArray(hit.getPose(referenceSpace!)!.transform.matrix);
             } else {
                 reticle.visible = false;
             }
diff --git a/examples-testing/examples/webxr_ar_lighting.ts b/examples-testing/examples/webxr_ar_lighting.ts
index 1a9c4de..53cb684 100644
--- a/examples-testing/examples/webxr_ar_lighting.ts
+++ b/examples-testing/examples/webxr_ar_lighting.ts
@@ -3,9 +3,9 @@ import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
 import { ARButton } from 'three/addons/webxr/ARButton.js';
 import { XREstimatedLight } from 'three/addons/webxr/XREstimatedLight.js';
 
-let camera, scene, renderer;
-let controller;
-let defaultEnvironment;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controller: THREE.XRTargetRaySpace;
+let defaultEnvironment: THREE.DataTexture;
 
 init();
 animate();
diff --git a/examples-testing/examples/webxr_vr_handinput.ts b/examples-testing/examples/webxr_vr_handinput.ts
index 5758501..33f9ab9 100644
--- a/examples-testing/examples/webxr_vr_handinput.ts
+++ b/examples-testing/examples/webxr_vr_handinput.ts
@@ -4,13 +4,13 @@ import { VRButton } from 'three/addons/webxr/VRButton.js';
 import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
 import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';
 
-let container;
-let camera, scene, renderer;
-let hand1, hand2;
-let controller1, controller2;
-let controllerGrip1, controllerGrip2;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let hand1: THREE.XRHandSpace, hand2: THREE.XRHandSpace;
+let controller1: THREE.XRTargetRaySpace, controller2: THREE.XRTargetRaySpace;
+let controllerGrip1: THREE.XRGripSpace, controllerGrip2: THREE.XRGripSpace;
 
-let controls;
+let controls: OrbitControls;
 
 init();
 animate();
diff --git a/examples-testing/examples/webxr_vr_panorama.ts b/examples-testing/examples/webxr_vr_panorama.ts
index fdd23aa..bd103ef 100644
--- a/examples-testing/examples/webxr_vr_panorama.ts
+++ b/examples-testing/examples/webxr_vr_panorama.ts
@@ -1,9 +1,9 @@
 import * as THREE from 'three';
 import { VRButton } from 'three/addons/webxr/VRButton.js';
 
-let camera;
-let renderer;
-let scene;
+let camera: THREE.PerspectiveCamera;
+let renderer: THREE.WebGLRenderer;
+let scene: THREE.Scene;
 
 init();
 animate();
@@ -53,8 +53,8 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function getTexturesFromAtlasFile(atlasImgUrl, tilesNum) {
-    const textures = [];
+function getTexturesFromAtlasFile(atlasImgUrl: string, tilesNum: number) {
+    const textures: THREE.Texture[] = [];
 
     for (let i = 0; i < tilesNum; i++) {
         textures[i] = new THREE.Texture();
@@ -67,7 +67,7 @@ function getTexturesFromAtlasFile(atlasImgUrl, tilesNum) {
 
         for (let i = 0; i < textures.length; i++) {
             canvas = document.createElement('canvas');
-            context = canvas.getContext('2d');
+            context = canvas.getContext('2d')!;
             canvas.height = tileWidth;
             canvas.width = tileWidth;
             context.drawImage(imageObj, tileWidth * i, 0, tileWidth, tileWidth, 0, 0, tileWidth, tileWidth);
diff --git a/examples-testing/examples/webxr_vr_panorama_depth.ts b/examples-testing/examples/webxr_vr_panorama_depth.ts
index a09b733..292719d 100644
--- a/examples-testing/examples/webxr_vr_panorama_depth.ts
+++ b/examples-testing/examples/webxr_vr_panorama_depth.ts
@@ -1,13 +1,17 @@
 import * as THREE from 'three';
 import { VRButton } from 'three/addons/webxr/VRButton.js';
 
-let camera, scene, renderer, sphere, clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    sphere: THREE.Mesh<THREE.SphereGeometry, THREE.MeshStandardMaterial>,
+    clock: THREE.Clock;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     clock = new THREE.Clock();
 
diff --git a/examples-testing/examples/webxr_vr_rollercoaster.ts b/examples-testing/examples/webxr_vr_rollercoaster.ts
index b659652..06e3224 100644
--- a/examples-testing/examples/webxr_vr_rollercoaster.ts
+++ b/examples-testing/examples/webxr_vr_rollercoaster.ts
@@ -9,7 +9,7 @@ import {
 } from 'three/addons/misc/RollerCoaster.js';
 import { VRButton } from 'three/addons/webxr/VRButton.js';
 
-let mesh, material, geometry;
+let mesh: THREE.Mesh, material: THREE.Material, geometry: SkyGeometry;
 
 const renderer = new THREE.WebGLRenderer({ antialias: true });
 renderer.setPixelRatio(window.devicePixelRatio);
@@ -86,7 +86,7 @@ const curve = (function () {
     const vector2 = new THREE.Vector3();
 
     return {
-        getPointAt: function (t) {
+        getPointAt: function (t: number) {
             t = t * PI2;
 
             const x = Math.sin(t * 3) * Math.cos(t * 4) * 50;
@@ -96,7 +96,7 @@ const curve = (function () {
             return vector.set(x, y, z).multiplyScalar(2);
         },
 
-        getTangentAt: function (t) {
+        getTangentAt: function (t: number) {
             const delta = 0.0001;
             const t1 = Math.max(0, t - delta);
             const t2 = Math.min(1, t + delta);
@@ -129,7 +129,7 @@ mesh = new THREE.Mesh(geometry, material);
 mesh.position.y = 0.1;
 scene.add(mesh);
 
-const funfairs = [];
+const funfairs: THREE.Mesh[] = [];
 
 //
 
diff --git a/examples-testing/examples/webxr_vr_sandbox.ts b/examples-testing/examples/webxr_vr_sandbox.ts
index d8212a4..3302cb5 100644
--- a/examples-testing/examples/webxr_vr_sandbox.ts
+++ b/examples-testing/examples/webxr_vr_sandbox.ts
@@ -12,9 +12,9 @@ import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFa
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer;
-let reflector;
-let stats, statsMesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let reflector: Reflector;
+let stats: Stats, statsMesh: HTMLMesh;
 
 const parameters = {
     radius: 0.6,
@@ -200,7 +200,7 @@ function animate() {
 
 function render() {
     const time = performance.now() * 0.0002;
-    const torus = scene.getObjectByName('torus');
+    const torus = scene.getObjectByName('torus')!;
     torus.rotation.x = time * 0.4;
     torus.rotation.y = time;
 
@@ -208,5 +208,9 @@ function render() {
     stats.update();
 
     // Canvas elements doesn't trigger DOM updates, so we have to update the texture
-    statsMesh.material.map.update();
+    (statsMesh.material.map as HTMLTexture).update();
+}
+
+interface HTMLTexture extends THREE.CanvasTexture {
+    update(): void;
 }
diff --git a/examples-testing/examples/webxr_vr_video.ts b/examples-testing/examples/webxr_vr_video.ts
index 2baded4..9c3f5e7 100644
--- a/examples-testing/examples/webxr_vr_video.ts
+++ b/examples-testing/examples/webxr_vr_video.ts
@@ -1,13 +1,13 @@
 import * as THREE from 'three';
 import { VRButton } from 'three/addons/webxr/VRButton.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.addEventListener('click', function () {
         video.play();
     });
@@ -17,7 +17,7 @@ function init() {
 
     // video
 
-    const video = document.getElementById('video');
+    const video = document.getElementById('video') as HTMLVideoElement;
     video.play();
 
     const texture = new THREE.VideoTexture(video);
diff --git a/examples-testing/examples/webxr_xr_controls_transform.ts b/examples-testing/examples/webxr_xr_controls_transform.ts
index 12e2dbf..adcaad8 100644
--- a/examples-testing/examples/webxr_xr_controls_transform.ts
+++ b/examples-testing/examples/webxr_xr_controls_transform.ts
@@ -2,15 +2,16 @@ import * as THREE from 'three';
 import { TransformControls } from 'three/addons/controls/TransformControls.js';
 import { XRButton } from 'three/addons/webxr/XRButton.js';
 import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
+import { Event } from 'three';
 
-let container;
-let camera, scene, renderer;
-let controller1, controller2, line;
-let controllerGrip1, controllerGrip2;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controller1: THREE.XRTargetRaySpace, controller2: THREE.XRTargetRaySpace, line: THREE.Line;
+let controllerGrip1: THREE.XRGripSpace, controllerGrip2: THREE.XRGripSpace;
 
-let raycaster;
+let raycaster: THREE.Raycaster;
 
-let controls, group;
+let controls: TransformControls, group: THREE.Group;
 
 init();
 animate();
@@ -148,7 +149,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function onSelect(event) {
+function onSelect(event: Event<'select', THREE.XRTargetRaySpace>) {
     const controller = event.target;
 
     controller1.userData.active = false;
@@ -173,7 +174,7 @@ function onSelect(event) {
     }
 }
 
-function onControllerEvent(event) {
+function onControllerEvent(event: Event<'selectstart' | 'selectend' | 'move', THREE.XRTargetRaySpace>) {
     const controller = event.target;
 
     if (controller.userData.active === false) return;
