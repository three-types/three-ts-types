diff --git a/examples-testing/examples/css2d_label.ts b/examples-testing/examples/css2d_label.ts
index 48a2d1f05..e7260210d 100644
--- a/examples-testing/examples/css2d_label.ts
+++ b/examples-testing/examples/css2d_label.ts
@@ -7,7 +7,7 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 let gui;
 
-let camera, scene, renderer, labelRenderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, labelRenderer: CSS2DRenderer;
 
 const layers = {
     'Toggle Name': function () {
@@ -28,7 +28,7 @@ const layers = {
 const clock = new THREE.Clock();
 const textureLoader = new THREE.TextureLoader();
 
-let moon;
+let moon: THREE.Mesh;
 
 init();
 animate();
@@ -63,7 +63,7 @@ function init() {
         normalMap: textureLoader.load('textures/planets/earth_normal_2048.jpg'),
         normalScale: new THREE.Vector2(0.85, 0.85),
     });
-    earthMaterial.map.colorSpace = THREE.SRGBColorSpace;
+    earthMaterial.map!.colorSpace = THREE.SRGBColorSpace;
     const earth = new THREE.Mesh(earthGeometry, earthMaterial);
     scene.add(earth);
 
@@ -72,7 +72,7 @@ function init() {
         shininess: 5,
         map: textureLoader.load('textures/planets/moon_1024.jpg'),
     });
-    moonMaterial.map.colorSpace = THREE.SRGBColorSpace;
+    moonMaterial.map!.colorSpace = THREE.SRGBColorSpace;
     moon = new THREE.Mesh(moonGeometry, moonMaterial);
     scene.add(moon);
 
diff --git a/examples-testing/examples/css3d_mixed.ts b/examples-testing/examples/css3d_mixed.ts
index b526e73e5..261f0d704 100644
--- a/examples-testing/examples/css3d_mixed.ts
+++ b/examples-testing/examples/css3d_mixed.ts
@@ -3,8 +3,11 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
 
-let camera, scene, rendererCSS3D, rendererWebGL;
-let controls;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    rendererCSS3D: CSS3DRenderer,
+    rendererWebGL: THREE.WebGLRenderer;
+let controls: OrbitControls;
 
 init();
 
@@ -81,7 +84,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function buildFrame(width, height, thickness) {
+function buildFrame(width: number, height: number, thickness: number) {
     const group = new THREE.Group();
     const material = new THREE.MeshStandardMaterial({ color: 0x2200ff });
 
diff --git a/examples-testing/examples/css3d_molecules.ts b/examples-testing/examples/css3d_molecules.ts
index 538472607..f08bb34ab 100644
--- a/examples-testing/examples/css3d_molecules.ts
+++ b/examples-testing/examples/css3d_molecules.ts
@@ -5,11 +5,11 @@ import { PDBLoader } from 'three/addons/loaders/PDBLoader.js';
 import { CSS3DRenderer, CSS3DObject, CSS3DSprite } from 'three/addons/renderers/CSS3DRenderer.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
-let controls;
-let root;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: CSS3DRenderer;
+let controls: TrackballControls;
+let root: THREE.Object3D;
 
-const objects = [];
+const objects: Array<CSS3DObject | CSS3DSprite> = [];
 const tmpVec1 = new THREE.Vector3();
 const tmpVec2 = new THREE.Vector3();
 const tmpVec3 = new THREE.Vector3();
@@ -49,7 +49,7 @@ const params = {
 };
 
 const loader = new PDBLoader();
-const colorSpriteMap = {};
+const colorSpriteMap: { [element: string]: string | undefined } = {};
 const baseSprite = document.createElement('img');
 
 init();
@@ -68,7 +68,7 @@ function init() {
 
     renderer = new CSS3DRenderer();
     renderer.setSize(window.innerWidth, window.innerHeight);
-    document.getElementById('container').appendChild(renderer.domElement);
+    document.getElementById('container')!.appendChild(renderer.domElement);
 
     //
 
@@ -96,7 +96,7 @@ function init() {
     gui.open();
 }
 
-function changeVizType(value) {
+function changeVizType(value: number) {
     if (value === 0) showAtoms();
     else if (value === 1) showBonds();
     else showAtomsBonds();
@@ -148,7 +148,7 @@ function showAtomsBonds() {
 
 //
 
-function colorify(ctx, width, height, color) {
+function colorify(ctx: CanvasRenderingContext2D, width: number, height: number, color: THREE.Color) {
     const r = color.r,
         g = color.g,
         b = color.b;
@@ -165,7 +165,7 @@ function colorify(ctx, width, height, color) {
     ctx.putImageData(imageData, 0, 0);
 }
 
-function imageToCanvas(image) {
+function imageToCanvas(image: HTMLImageElement) {
     const width = image.width;
     const height = image.height;
 
@@ -174,7 +174,7 @@ function imageToCanvas(image) {
     canvas.width = width;
     canvas.height = height;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     context.drawImage(image, 0, 0, width, height);
 
     return canvas;
@@ -182,12 +182,12 @@ function imageToCanvas(image) {
 
 //
 
-function loadMolecule(model) {
+function loadMolecule(model: string) {
     const url = 'models/pdb/' + model;
 
     for (let i = 0; i < objects.length; i++) {
         const object = objects[i];
-        object.parent.remove(object);
+        object.parent!.remove(object);
     }
 
     objects.length = 0;
@@ -198,7 +198,7 @@ function loadMolecule(model) {
         const json = pdb.json;
 
         geometryAtoms.computeBoundingBox();
-        geometryAtoms.boundingBox.getCenter(offset).negate();
+        geometryAtoms.boundingBox!.getCenter(offset).negate();
 
         geometryAtoms.translate(offset.x, offset.y, offset.z);
         geometryBonds.translate(offset.x, offset.y, offset.z);
@@ -218,7 +218,7 @@ function loadMolecule(model) {
 
             if (!colorSpriteMap[element]) {
                 const canvas = imageToCanvas(baseSprite);
-                const context = canvas.getContext('2d');
+                const context = canvas.getContext('2d')!;
 
                 colorify(context, canvas.width, canvas.height, color);
 
@@ -227,7 +227,7 @@ function loadMolecule(model) {
                 colorSpriteMap[element] = dataUrl;
             }
 
-            const colorSprite = colorSpriteMap[element];
+            const colorSprite = colorSpriteMap[element]!;
 
             const atom = document.createElement('img');
             atom.src = colorSprite;
diff --git a/examples-testing/examples/css3d_orthographic.ts b/examples-testing/examples/css3d_orthographic.ts
index 4aabbed08..67e41fde7 100644
--- a/examples-testing/examples/css3d_orthographic.ts
+++ b/examples-testing/examples/css3d_orthographic.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
-import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
+import { Controller, GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let scene2, renderer2;
+let scene2: THREE.Scene, renderer2: CSS3DRenderer;
 
 const frustumSize = 500;
 
@@ -75,18 +75,18 @@ function init() {
     renderer2 = new CSS3DRenderer();
     renderer2.setSize(window.innerWidth, window.innerHeight);
     renderer2.domElement.style.position = 'absolute';
-    renderer2.domElement.style.top = 0;
+    renderer2.domElement.style.top = '0';
     document.body.appendChild(renderer2.domElement);
 
     const controls = new OrbitControls(camera, renderer2.domElement);
     controls.minZoom = 0.5;
     controls.maxZoom = 2;
 
-    function createPlane(width, height, cssColor, pos, rot) {
+    function createPlane(width: number, height: number, cssColor: string, pos: THREE.Vector3, rot: THREE.Euler) {
         const element = document.createElement('div');
         element.style.width = width + 'px';
         element.style.height = height + 'px';
-        element.style.opacity = 0.75;
+        element.style.opacity = '0.75';
         element.style.background = cssColor;
 
         const object = new CSS3DObject(element);
@@ -133,12 +133,12 @@ function createPanel() {
 
     const settings = {
         setViewOffset() {
-            folder1.children[1].enable().setValue(window.innerWidth);
-            folder1.children[2].enable().setValue(window.innerHeight);
-            folder1.children[3].enable().setValue(0);
-            folder1.children[4].enable().setValue(0);
-            folder1.children[5].enable().setValue(window.innerWidth);
-            folder1.children[6].enable().setValue(window.innerHeight);
+            (folder1.children[1] as Controller).enable().setValue(window.innerWidth);
+            (folder1.children[2] as Controller).enable().setValue(window.innerHeight);
+            (folder1.children[3] as Controller).enable().setValue(0);
+            (folder1.children[4] as Controller).enable().setValue(0);
+            (folder1.children[5] as Controller).enable().setValue(window.innerWidth);
+            (folder1.children[6] as Controller).enable().setValue(window.innerHeight);
         },
         fullWidth: 0,
         fullHeight: 0,
@@ -147,12 +147,12 @@ function createPanel() {
         width: 0,
         height: 0,
         clearViewOffset() {
-            folder1.children[1].setValue(0).disable();
-            folder1.children[2].setValue(0).disable();
-            folder1.children[3].setValue(0).disable();
-            folder1.children[4].setValue(0).disable();
-            folder1.children[5].setValue(0).disable();
-            folder1.children[6].setValue(0).disable();
+            (folder1.children[1] as Controller).setValue(0).disable();
+            (folder1.children[2] as Controller).setValue(0).disable();
+            (folder1.children[3] as Controller).setValue(0).disable();
+            (folder1.children[4] as Controller).setValue(0).disable();
+            (folder1.children[5] as Controller).setValue(0).disable();
+            (folder1.children[6] as Controller).setValue(0).disable();
             camera.clearViewOffset();
         },
     };
@@ -185,7 +185,21 @@ function createPanel() {
     folder1.add(settings, 'clearViewOffset');
 }
 
-function updateCameraViewOffset({ fullWidth, fullHeight, x, y, width, height }) {
+function updateCameraViewOffset({
+    fullWidth,
+    fullHeight,
+    x,
+    y,
+    width,
+    height,
+}: {
+    fullWidth?: number;
+    fullHeight?: number;
+    x?: number;
+    y?: number;
+    width?: number;
+    height?: number;
+}) {
     if (!camera.view) {
         camera.setViewOffset(
             fullWidth || window.innerWidth,
diff --git a/examples-testing/examples/css3d_periodictable.ts b/examples-testing/examples/css3d_periodictable.ts
index e3a33f796..516df464c 100644
--- a/examples-testing/examples/css3d_periodictable.ts
+++ b/examples-testing/examples/css3d_periodictable.ts
@@ -597,11 +597,16 @@ const table = [
     7,
 ];
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: CSS3DRenderer;
+let controls: TrackballControls;
 
-const objects = [];
-const targets = { table: [], sphere: [], helix: [], grid: [] };
+const objects: CSS3DObject[] = [];
+const targets: {
+    table: THREE.Object3D[];
+    sphere: THREE.Object3D[];
+    helix: THREE.Object3D[];
+    grid: THREE.Object3D[];
+} = { table: [], sphere: [], helix: [], grid: [] };
 
 init();
 animate();
@@ -621,12 +626,12 @@ function init() {
 
         const number = document.createElement('div');
         number.className = 'number';
-        number.textContent = i / 5 + 1;
+        number.textContent = `${i / 5 + 1}`;
         element.appendChild(number);
 
         const symbol = document.createElement('div');
         symbol.className = 'symbol';
-        symbol.textContent = table[i];
+        symbol.textContent = table[i] as string;
         element.appendChild(symbol);
 
         const details = document.createElement('div');
@@ -645,8 +650,8 @@ function init() {
         //
 
         const object = new THREE.Object3D();
-        object.position.x = table[i + 3] * 140 - 1330;
-        object.position.y = -(table[i + 4] * 180) + 990;
+        object.position.x = (table[i + 3] as number) * 140 - 1330;
+        object.position.y = -((table[i + 4] as number) * 180) + 990;
 
         targets.table.push(object);
     }
@@ -705,7 +710,7 @@ function init() {
 
     renderer = new CSS3DRenderer();
     renderer.setSize(window.innerWidth, window.innerHeight);
-    document.getElementById('container').appendChild(renderer.domElement);
+    document.getElementById('container')!.appendChild(renderer.domElement);
 
     //
 
@@ -714,22 +719,22 @@ function init() {
     controls.maxDistance = 6000;
     controls.addEventListener('change', render);
 
-    const buttonTable = document.getElementById('table');
+    const buttonTable = document.getElementById('table')!;
     buttonTable.addEventListener('click', function () {
         transform(targets.table, 2000);
     });
 
-    const buttonSphere = document.getElementById('sphere');
+    const buttonSphere = document.getElementById('sphere')!;
     buttonSphere.addEventListener('click', function () {
         transform(targets.sphere, 2000);
     });
 
-    const buttonHelix = document.getElementById('helix');
+    const buttonHelix = document.getElementById('helix')!;
     buttonHelix.addEventListener('click', function () {
         transform(targets.helix, 2000);
     });
 
-    const buttonGrid = document.getElementById('grid');
+    const buttonGrid = document.getElementById('grid')!;
     buttonGrid.addEventListener('click', function () {
         transform(targets.grid, 2000);
     });
@@ -741,7 +746,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function transform(targets, duration) {
+function transform(targets: THREE.Object3D[], duration: number) {
     TWEEN.removeAll();
 
     for (let i = 0; i < objects.length; i++) {
@@ -765,7 +770,7 @@ function transform(targets, duration) {
             .start();
     }
 
-    new TWEEN.Tween(this)
+    new TWEEN.Tween({})
         .to({}, duration * 2)
         .onUpdate(render)
         .start();
diff --git a/examples-testing/examples/css3d_sandbox.ts b/examples-testing/examples/css3d_sandbox.ts
index 1088b84b1..02f1fa75a 100644
--- a/examples-testing/examples/css3d_sandbox.ts
+++ b/examples-testing/examples/css3d_sandbox.ts
@@ -2,13 +2,13 @@ import * as THREE from 'three';
 
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
-import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
+import { Controller, GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let scene2, renderer2;
+let scene2: THREE.Scene, renderer2: CSS3DRenderer;
 
-let controls;
+let controls: TrackballControls;
 
 init();
 animate();
@@ -35,7 +35,7 @@ function init() {
         const element = document.createElement('div');
         element.style.width = '100px';
         element.style.height = '100px';
-        element.style.opacity = i < 5 ? 0.5 : 1;
+        element.style.opacity = `${i < 5 ? 0.5 : 1}`;
         element.style.background = new THREE.Color(Math.random() * 0xffffff).getStyle();
 
         const object = new CSS3DObject(element);
@@ -67,7 +67,7 @@ function init() {
     renderer2 = new CSS3DRenderer();
     renderer2.setSize(window.innerWidth, window.innerHeight);
     renderer2.domElement.style.position = 'absolute';
-    renderer2.domElement.style.top = 0;
+    renderer2.domElement.style.top = '0';
     document.body.appendChild(renderer2.domElement);
 
     controls = new TrackballControls(camera, renderer2.domElement);
@@ -101,12 +101,12 @@ function createPanel() {
 
     const settings = {
         setViewOffset() {
-            folder1.children[1].enable().setValue(window.innerWidth);
-            folder1.children[2].enable().setValue(window.innerHeight);
-            folder1.children[3].enable().setValue(0);
-            folder1.children[4].enable().setValue(0);
-            folder1.children[5].enable().setValue(window.innerWidth);
-            folder1.children[6].enable().setValue(window.innerHeight);
+            (folder1.children[1] as Controller).enable().setValue(window.innerWidth);
+            (folder1.children[2] as Controller).enable().setValue(window.innerHeight);
+            (folder1.children[3] as Controller).enable().setValue(0);
+            (folder1.children[4] as Controller).enable().setValue(0);
+            (folder1.children[5] as Controller).enable().setValue(window.innerWidth);
+            (folder1.children[6] as Controller).enable().setValue(window.innerHeight);
         },
         fullWidth: 0,
         fullHeight: 0,
@@ -115,12 +115,12 @@ function createPanel() {
         width: 0,
         height: 0,
         clearViewOffset() {
-            folder1.children[1].setValue(0).disable();
-            folder1.children[2].setValue(0).disable();
-            folder1.children[3].setValue(0).disable();
-            folder1.children[4].setValue(0).disable();
-            folder1.children[5].setValue(0).disable();
-            folder1.children[6].setValue(0).disable();
+            (folder1.children[1] as Controller).setValue(0).disable();
+            (folder1.children[2] as Controller).setValue(0).disable();
+            (folder1.children[3] as Controller).setValue(0).disable();
+            (folder1.children[4] as Controller).setValue(0).disable();
+            (folder1.children[5] as Controller).setValue(0).disable();
+            (folder1.children[6] as Controller).setValue(0).disable();
             camera.clearViewOffset();
         },
     };
@@ -153,7 +153,21 @@ function createPanel() {
     folder1.add(settings, 'clearViewOffset');
 }
 
-function updateCameraViewOffset({ fullWidth, fullHeight, x, y, width, height }) {
+function updateCameraViewOffset({
+    fullWidth,
+    fullHeight,
+    x,
+    y,
+    width,
+    height,
+}: {
+    fullWidth?: number;
+    fullHeight?: number;
+    x?: number;
+    y?: number;
+    width?: number;
+    height?: number;
+}) {
     if (!camera.view) {
         camera.setViewOffset(
             fullWidth || window.innerWidth,
diff --git a/examples-testing/examples/css3d_sprites.ts b/examples-testing/examples/css3d_sprites.ts
index 39c3455a5..b3092cf3c 100644
--- a/examples-testing/examples/css3d_sprites.ts
+++ b/examples-testing/examples/css3d_sprites.ts
@@ -4,12 +4,12 @@ import TWEEN from 'three/addons/libs/tween.module.js';
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import { CSS3DRenderer, CSS3DSprite } from 'three/addons/renderers/CSS3DRenderer.js';
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: CSS3DRenderer;
+let controls: TrackballControls;
 
 const particlesTotal = 512;
-const positions = [];
-const objects = [];
+const positions: number[] = [];
+const objects: CSS3DSprite[] = [];
 let current = 0;
 
 init();
@@ -25,7 +25,7 @@ function init() {
     const image = document.createElement('img');
     image.addEventListener('load', function () {
         for (let i = 0; i < particlesTotal; i++) {
-            const object = new CSS3DSprite(image.cloneNode());
+            const object = new CSS3DSprite(image.cloneNode() as typeof image);
             ((object.position.x = Math.random() * 4000 - 2000),
                 (object.position.y = Math.random() * 4000 - 2000),
                 (object.position.z = Math.random() * 4000 - 2000));
@@ -93,7 +93,7 @@ function init() {
 
     renderer = new CSS3DRenderer();
     renderer.setSize(window.innerWidth, window.innerHeight);
-    document.getElementById('container').appendChild(renderer.domElement);
+    document.getElementById('container')!.appendChild(renderer.domElement);
 
     //
 
@@ -131,7 +131,7 @@ function transition() {
             .start();
     }
 
-    new TWEEN.Tween(this)
+    new TWEEN.Tween({})
         .to({}, duration * 3)
         .onComplete(transition)
         .start();
diff --git a/examples-testing/examples/css3d_youtube.ts b/examples-testing/examples/css3d_youtube.ts
index 62652f87f..3dcc2f12b 100644
--- a/examples-testing/examples/css3d_youtube.ts
+++ b/examples-testing/examples/css3d_youtube.ts
@@ -3,10 +3,10 @@ import * as THREE from 'three';
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: CSS3DRenderer;
+let controls: TrackballControls;
 
-function Element(id, x, y, z, ry) {
+function Element(id: string, x: number, y: number, z: number, ry: number) {
     const div = document.createElement('div');
     div.style.width = '480px';
     div.style.height = '360px';
@@ -30,7 +30,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 5000);
     camera.position.set(500, 350, 750);
@@ -42,10 +42,10 @@ function init() {
     container.appendChild(renderer.domElement);
 
     const group = new THREE.Group();
-    group.add(new Element('SJOz3qjfQXU', 0, 0, 240, 0));
-    group.add(new Element('Y2-xZ-1HE-Q', 240, 0, 0, Math.PI / 2));
-    group.add(new Element('IrydklNpcFI', 0, 0, -240, Math.PI));
-    group.add(new Element('9ubytEsCaS0', -240, 0, 0, -Math.PI / 2));
+    group.add(Element('SJOz3qjfQXU', 0, 0, 240, 0));
+    group.add(Element('Y2-xZ-1HE-Q', 240, 0, 0, Math.PI / 2));
+    group.add(Element('IrydklNpcFI', 0, 0, -240, Math.PI));
+    group.add(Element('9ubytEsCaS0', -240, 0, 0, -Math.PI / 2));
     scene.add(group);
 
     controls = new TrackballControls(camera, renderer.domElement);
@@ -55,7 +55,7 @@ function init() {
 
     // Block iframe events when dragging camera
 
-    const blocker = document.getElementById('blocker');
+    const blocker = document.getElementById('blocker')!;
     blocker.style.display = 'none';
 
     controls.addEventListener('start', function () {
diff --git a/examples-testing/examples/games_fps.ts b/examples-testing/examples/games_fps.ts
index 4c459f9bc..b714f591b 100644
--- a/examples-testing/examples/games_fps.ts
+++ b/examples-testing/examples/games_fps.ts
@@ -39,7 +39,7 @@ directionalLight.shadow.radius = 4;
 directionalLight.shadow.bias = -0.00006;
 scene.add(directionalLight);
 
-const container = document.getElementById('container');
+const container = document.getElementById('container')!;
 
 const renderer = new THREE.WebGLRenderer({ antialias: true });
 renderer.setPixelRatio(window.devicePixelRatio);
@@ -51,9 +51,9 @@ renderer.toneMapping = THREE.ACESFilmicToneMapping;
 container.appendChild(renderer.domElement);
 
 const stats = new Stats();
-stats.domElement.style.position = 'absolute';
-stats.domElement.style.top = '0px';
-container.appendChild(stats.domElement);
+stats.dom.style.position = 'absolute';
+stats.dom.style.top = '0px';
+container.appendChild(stats.dom);
 
 const GRAVITY = 30;
 
@@ -65,7 +65,13 @@ const STEPS_PER_FRAME = 5;
 const sphereGeometry = new THREE.IcosahedronGeometry(SPHERE_RADIUS, 5);
 const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0xdede8d });
 
-const spheres = [];
+interface Sphere {
+    mesh: THREE.Mesh;
+    collider: THREE.Sphere;
+    velocity: THREE.Vector3;
+}
+
+const spheres: Sphere[] = [];
 let sphereIdx = 0;
 
 for (let i = 0; i < NUM_SPHERES; i++) {
@@ -92,7 +98,7 @@ const playerDirection = new THREE.Vector3();
 let playerOnFloor = false;
 let mouseTime = 0;
 
-const keyStates = {};
+const keyStates: { [eventCode: string]: boolean | undefined } = {};
 
 const vector1 = new THREE.Vector3();
 const vector2 = new THREE.Vector3();
@@ -167,7 +173,7 @@ function playerCollisions() {
     }
 }
 
-function updatePlayer(deltaTime) {
+function updatePlayer(deltaTime: number) {
     let damping = Math.exp(-4 * deltaTime) - 1;
 
     if (!playerOnFloor) {
@@ -187,7 +193,7 @@ function updatePlayer(deltaTime) {
     camera.position.copy(playerCollider.end);
 }
 
-function playerSphereCollision(sphere) {
+function playerSphereCollision(sphere: Sphere) {
     const center = vector1.addVectors(playerCollider.start, playerCollider.end).multiplyScalar(0.5);
 
     const sphere_center = sphere.collider.center;
@@ -242,7 +248,7 @@ function spheresCollisions() {
     }
 }
 
-function updateSpheres(deltaTime) {
+function updateSpheres(deltaTime: number) {
     spheres.forEach(sphere => {
         sphere.collider.center.addScaledVector(sphere.velocity, deltaTime);
 
@@ -285,7 +291,7 @@ function getSideVector() {
     return playerDirection;
 }
 
-function controls(deltaTime) {
+function controls(deltaTime: number) {
     // gives a bit of air control
     const speedDelta = deltaTime * (playerOnFloor ? 25 : 8);
 
@@ -320,12 +326,12 @@ loader.load('collision-world.glb', gltf => {
     worldOctree.fromGraphNode(gltf.scene);
 
     gltf.scene.traverse(child => {
-        if (child.isMesh) {
+        if ((child as THREE.Mesh).isMesh) {
             child.castShadow = true;
             child.receiveShadow = true;
 
-            if (child.material.map) {
-                child.material.map.anisotropy = 4;
+            if (((child as THREE.Mesh).material as THREE.MeshStandardMaterial).map) {
+                ((child as THREE.Mesh).material as THREE.MeshStandardMaterial).map!.anisotropy = 4;
             }
         }
     });
diff --git a/examples-testing/examples/misc_animation_groups.ts b/examples-testing/examples/misc_animation_groups.ts
index 33fc41997..e5cc63bcc 100644
--- a/examples-testing/examples/misc_animation_groups.ts
+++ b/examples-testing/examples/misc_animation_groups.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let stats, clock;
-let scene, camera, renderer, mixer;
+let stats: Stats, clock: THREE.Clock;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, mixer: THREE.AnimationMixer;
 
 init();
 
diff --git a/examples-testing/examples/misc_animation_keys.ts b/examples-testing/examples/misc_animation_keys.ts
index e2f141f91..a2e43b586 100644
--- a/examples-testing/examples/misc_animation_keys.ts
+++ b/examples-testing/examples/misc_animation_keys.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let stats, clock;
-let scene, camera, renderer, mixer;
+let stats: Stats, clock: THREE.Clock;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, mixer: THREE.AnimationMixer;
 
 init();
 
@@ -24,7 +24,10 @@ function init() {
     //
 
     const geometry = new THREE.BoxGeometry(5, 5, 5);
-    const material = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true });
+    const material = new THREE.MeshBasicMaterial({
+        color: 0xffffff,
+        transparent: true,
+    });
     const mesh = new THREE.Mesh(geometry, material);
     scene.add(mesh);
 
diff --git a/examples-testing/examples/misc_boxselection.ts b/examples-testing/examples/misc_boxselection.ts
index e7079c405..e1d6904dc 100644
--- a/examples-testing/examples/misc_boxselection.ts
+++ b/examples-testing/examples/misc_boxselection.ts
@@ -5,8 +5,8 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { SelectionBox } from 'three/addons/interactive/SelectionBox.js';
 import { SelectionHelper } from 'three/addons/interactive/SelectionHelper.js';
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -87,12 +87,12 @@ function animate() {
     stats.update();
 }
 
-const selectionBox = new SelectionBox(camera, scene);
-const helper = new SelectionHelper(renderer, 'selectBox');
+const selectionBox = new SelectionBox(camera!, scene!);
+const helper = new SelectionHelper(renderer!, 'selectBox');
 
 document.addEventListener('pointerdown', function (event) {
     for (const item of selectionBox.collection) {
-        item.material.emissive.set(0x000000);
+        (item as THREE.Mesh<THREE.BufferGeometry, THREE.MeshLambertMaterial>).material.emissive.set(0x000000);
     }
 
     selectionBox.startPoint.set(
@@ -105,7 +105,9 @@ document.addEventListener('pointerdown', function (event) {
 document.addEventListener('pointermove', function (event) {
     if (helper.isDown) {
         for (let i = 0; i < selectionBox.collection.length; i++) {
-            selectionBox.collection[i].material.emissive.set(0x000000);
+            (
+                selectionBox.collection[i] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshLambertMaterial>
+            ).material.emissive.set(0x000000);
         }
 
         selectionBox.endPoint.set(
@@ -117,7 +119,9 @@ document.addEventListener('pointermove', function (event) {
         const allSelected = selectionBox.select();
 
         for (let i = 0; i < allSelected.length; i++) {
-            allSelected[i].material.emissive.set(0xffffff);
+            (allSelected[i] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshLambertMaterial>).material.emissive.set(
+                0xffffff,
+            );
         }
     }
 });
@@ -132,6 +136,6 @@ document.addEventListener('pointerup', function (event) {
     const allSelected = selectionBox.select();
 
     for (let i = 0; i < allSelected.length; i++) {
-        allSelected[i].material.emissive.set(0xffffff);
+        (allSelected[i] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshLambertMaterial>).material.emissive.set(0xffffff);
     }
 });
diff --git a/examples-testing/examples/misc_controls_arcball.ts b/examples-testing/examples/misc_controls_arcball.ts
index f2611be64..5982d6958 100644
--- a/examples-testing/examples/misc_controls_arcball.ts
+++ b/examples-testing/examples/misc_controls_arcball.ts
@@ -12,8 +12,12 @@ const cameraType = { type: 'Perspective' };
 
 const perspectiveDistance = 2.5;
 const orthographicDistance = 120;
-let camera, controls, scene, renderer, gui;
-let folderOptions, folderAnimations;
+let camera: THREE.OrthographicCamera | THREE.PerspectiveCamera,
+    controls: ArcballControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    gui: GUI;
+let folderOptions: GUI, folderAnimations: GUI;
 
 const arcballGui = {
     gizmoVisible: true,
@@ -98,8 +102,8 @@ function init() {
         material.normalMap.wrapS = THREE.RepeatWrapping;
 
         group.traverse(function (child) {
-            if (child.isMesh) {
-                child.material = material;
+            if ((child as THREE.Mesh).isMesh) {
+                (child as THREE.Mesh).material = material;
             }
         });
 
@@ -165,12 +169,12 @@ function onWindowResize() {
 
         const halfW = perspectiveDistance * Math.tan(halfFovH);
         const halfH = perspectiveDistance * Math.tan(halfFovV);
-        camera.left = -halfW;
-        camera.right = halfW;
-        camera.top = halfH;
-        camera.bottom = -halfH;
+        (camera as THREE.OrthographicCamera).left = -halfW;
+        (camera as THREE.OrthographicCamera).right = halfW;
+        (camera as THREE.OrthographicCamera).top = halfH;
+        (camera as THREE.OrthographicCamera).bottom = -halfH;
     } else if (camera.type == 'PerspectiveCamera') {
-        camera.aspect = window.innerWidth / window.innerHeight;
+        (camera as THREE.PerspectiveCamera).aspect = window.innerWidth / window.innerHeight;
     }
 
     camera.updateProjectionMatrix();
@@ -184,7 +188,7 @@ function render() {
     renderer.render(scene, camera);
 }
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     if (event.key === 'c') {
         if (event.ctrlKey || event.metaKey) {
             controls.copyState();
@@ -196,7 +200,7 @@ function onKeyDown(event) {
     }
 }
 
-function setCamera(type) {
+function setCamera(type: string) {
     if (type == 'Orthographic') {
         camera = makeOrthographicCamera();
         camera.position.set(0, 0, orthographicDistance);
diff --git a/examples-testing/examples/misc_controls_drag.ts b/examples-testing/examples/misc_controls_drag.ts
index b12b0421e..c3b378aa7 100644
--- a/examples-testing/examples/misc_controls_drag.ts
+++ b/examples-testing/examples/misc_controls_drag.ts
@@ -2,12 +2,12 @@ import * as THREE from 'three';
 
 import { DragControls } from 'three/addons/controls/DragControls.js';
 
-let container;
-let camera, scene, renderer;
-let controls, group;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controls: DragControls, group: THREE.Group;
 let enableSelection = false;
 
-const objects = [];
+const objects: THREE.Object3D[] = [];
 
 const mouse = new THREE.Vector2(),
     raycaster = new THREE.Raycaster();
@@ -98,7 +98,7 @@ function onWindowResize() {
     render();
 }
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     enableSelection = event.keyCode === 16 ? true : false;
 
     if (event.keyCode === 77) {
@@ -110,7 +110,7 @@ function onKeyUp() {
     enableSelection = false;
 }
 
-function onClick(event) {
+function onClick(event: MouseEvent) {
     event.preventDefault();
 
     if (enableSelection === true) {
@@ -128,10 +128,10 @@ function onClick(event) {
             const object = intersections[0].object;
 
             if (group.children.includes(object) === true) {
-                object.material.emissive.set(0x000000);
+                ((object as THREE.Mesh).material as THREE.MeshLambertMaterial).emissive.set(0x000000);
                 scene.attach(object);
             } else {
-                object.material.emissive.set(0xaaaaaa);
+                ((object as THREE.Mesh).material as THREE.MeshLambertMaterial).emissive.set(0xaaaaaa);
                 group.attach(object);
             }
 
diff --git a/examples-testing/examples/misc_controls_fly.ts b/examples-testing/examples/misc_controls_fly.ts
index a8a603bb3..e88957c04 100644
--- a/examples-testing/examples/misc_controls_fly.ts
+++ b/examples-testing/examples/misc_controls_fly.ts
@@ -16,11 +16,15 @@ const MARGIN = 0;
 let SCREEN_HEIGHT = window.innerHeight - MARGIN * 2;
 let SCREEN_WIDTH = window.innerWidth;
 
-let camera, controls, scene, renderer, stats;
-let geometry, meshPlanet, meshClouds, meshMoon;
-let dirLight;
+let camera: THREE.PerspectiveCamera,
+    controls: FlyControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    stats: Stats;
+let geometry: THREE.SphereGeometry, meshPlanet: THREE.Mesh, meshClouds: THREE.Mesh, meshMoon: THREE.Mesh;
+let dirLight: THREE.DirectionalLight;
 
-let postProcessing;
+let postProcessing: THREE.PostProcessing;
 
 const textureLoader = new THREE.TextureLoader();
 
@@ -52,7 +56,7 @@ function init() {
         // y scale is negated to compensate for normal map handedness.
         normalScale: new THREE.Vector2(0.85, -0.85),
     });
-    materialNormalMap.map.colorSpace = THREE.SRGBColorSpace;
+    materialNormalMap.map!.colorSpace = THREE.SRGBColorSpace;
 
     // planet
 
@@ -69,7 +73,7 @@ function init() {
         map: textureLoader.load('textures/planets/earth_clouds_1024.png'),
         transparent: true,
     });
-    materialClouds.map.colorSpace = THREE.SRGBColorSpace;
+    materialClouds.map!.colorSpace = THREE.SRGBColorSpace;
 
     meshClouds = new THREE.Mesh(geometry, materialClouds);
     meshClouds.scale.set(cloudsScale, cloudsScale, cloudsScale);
@@ -81,7 +85,7 @@ function init() {
     const materialMoon = new THREE.MeshPhongMaterial({
         map: textureLoader.load('textures/planets/moon_1024.jpg'),
     });
-    materialMoon.map.colorSpace = THREE.SRGBColorSpace;
+    materialMoon.map!.colorSpace = THREE.SRGBColorSpace;
 
     meshMoon = new THREE.Mesh(geometry, materialMoon);
     meshMoon.position.set(radius * 5, 0, 0);
diff --git a/examples-testing/examples/misc_controls_map.ts b/examples-testing/examples/misc_controls_map.ts
index fa36b55c9..560488d19 100644
--- a/examples-testing/examples/misc_controls_map.ts
+++ b/examples-testing/examples/misc_controls_map.ts
@@ -4,7 +4,7 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { MapControls } from 'three/addons/controls/MapControls.js';
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: MapControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 //render(); // remove when using animation loop
diff --git a/examples-testing/examples/misc_controls_orbit.ts b/examples-testing/examples/misc_controls_orbit.ts
index 81815d9db..6bb435481 100644
--- a/examples-testing/examples/misc_controls_orbit.ts
+++ b/examples-testing/examples/misc_controls_orbit.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 //render(); // remove when using animation loop
diff --git a/examples-testing/examples/misc_controls_pointerlock.ts b/examples-testing/examples/misc_controls_pointerlock.ts
index 0b6fcc516..d97bb4c3b 100644
--- a/examples-testing/examples/misc_controls_pointerlock.ts
+++ b/examples-testing/examples/misc_controls_pointerlock.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: PointerLockControls;
 
-const objects = [];
+const objects: THREE.Mesh[] = [];
 
-let raycaster;
+let raycaster: THREE.Raycaster;
 
 let moveForward = false;
 let moveBackward = false;
@@ -36,8 +36,8 @@ function init() {
 
     controls = new PointerLockControls(camera, document.body);
 
-    const blocker = document.getElementById('blocker');
-    const instructions = document.getElementById('instructions');
+    const blocker = document.getElementById('blocker')!;
+    const instructions = document.getElementById('instructions')!;
 
     instructions.addEventListener('click', function () {
         controls.lock();
@@ -55,7 +55,7 @@ function init() {
 
     scene.add(controls.object);
 
-    const onKeyDown = function (event) {
+    const onKeyDown = function (event: KeyboardEvent) {
         switch (event.code) {
             case 'ArrowUp':
             case 'KeyW':
@@ -84,7 +84,7 @@ function init() {
         }
     };
 
-    const onKeyUp = function (event) {
+    const onKeyUp = function (event: KeyboardEvent) {
         switch (event.code) {
             case 'ArrowUp':
             case 'KeyW':
@@ -115,7 +115,7 @@ function init() {
 
     // floor
 
-    let floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
+    let floorGeometry: THREE.BufferGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
     floorGeometry.rotateX(-Math.PI / 2);
 
     // vertex displacement
@@ -164,7 +164,11 @@ function init() {
     boxGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colorsBox, 3));
 
     for (let i = 0; i < 500; i++) {
-        const boxMaterial = new THREE.MeshPhongMaterial({ specular: 0xffffff, flatShading: true, vertexColors: true });
+        const boxMaterial = new THREE.MeshPhongMaterial({
+            specular: 0xffffff,
+            flatShading: true,
+            vertexColors: true,
+        });
         boxMaterial.color.setHSL(Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75, THREE.SRGBColorSpace);
 
         const box = new THREE.Mesh(boxGeometry, boxMaterial);
diff --git a/examples-testing/examples/misc_controls_trackball.ts b/examples-testing/examples/misc_controls_trackball.ts
index c2512a352..c4719944f 100644
--- a/examples-testing/examples/misc_controls_trackball.ts
+++ b/examples-testing/examples/misc_controls_trackball.ts
@@ -5,7 +5,12 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 
-let perspectiveCamera, orthographicCamera, controls, scene, renderer, stats;
+let perspectiveCamera: THREE.PerspectiveCamera,
+    orthographicCamera: THREE.OrthographicCamera,
+    controls: TrackballControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats;
 
 const params = {
     orthographicCamera: false,
@@ -96,7 +101,7 @@ function init() {
     createControls(perspectiveCamera);
 }
 
-function createControls(camera) {
+function createControls(camera: THREE.Camera) {
     controls = new TrackballControls(camera, renderer.domElement);
 
     controls.rotateSpeed = 1.0;
diff --git a/examples-testing/examples/misc_controls_transform.ts b/examples-testing/examples/misc_controls_transform.ts
index 6f7793d33..d7d327e96 100644
--- a/examples-testing/examples/misc_controls_transform.ts
+++ b/examples-testing/examples/misc_controls_transform.ts
@@ -3,8 +3,8 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { TransformControls } from 'three/addons/controls/TransformControls.js';
 
-let cameraPersp, cameraOrtho, currentCamera;
-let scene, renderer, control, orbit;
+let cameraPersp: THREE.PerspectiveCamera, cameraOrtho: THREE.OrthographicCamera, currentCamera: THREE.Camera;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer, control: TransformControls, orbit: OrbitControls;
 
 init();
 render();
@@ -96,7 +96,9 @@ function init() {
             case 'c':
                 const position = currentCamera.position.clone();
 
-                currentCamera = currentCamera.isPerspectiveCamera ? cameraOrtho : cameraPersp;
+                currentCamera = (currentCamera as THREE.PerspectiveCamera).isPerspectiveCamera
+                    ? cameraOrtho
+                    : cameraPersp;
                 currentCamera.position.copy(position);
 
                 orbit.object = currentCamera;
diff --git a/examples-testing/examples/misc_exporter_draco.ts b/examples-testing/examples/misc_exporter_draco.ts
index 40a62fb18..cb9d3f599 100644
--- a/examples-testing/examples/misc_exporter_draco.ts
+++ b/examples-testing/examples/misc_exporter_draco.ts
@@ -4,7 +4,11 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { DRACOExporter } from 'three/addons/exporters/DRACOExporter.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, renderer, exporter, mesh;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGLRenderer,
+    exporter: DRACOExporter,
+    mesh: THREE.Mesh;
 
 const params = {
     export: exportFile,
@@ -106,12 +110,12 @@ const link = document.createElement('a');
 link.style.display = 'none';
 document.body.appendChild(link);
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: BufferSource, filename: string) {
     save(new Blob([buffer], { type: 'application/octet-stream' }), filename);
 }
diff --git a/examples-testing/examples/misc_exporter_exr.ts b/examples-testing/examples/misc_exporter_exr.ts
index 014ea58a0..643f63522 100644
--- a/examples-testing/examples/misc_exporter_exr.ts
+++ b/examples-testing/examples/misc_exporter_exr.ts
@@ -5,7 +5,14 @@ import { EXRExporter, ZIP_COMPRESSION, ZIPS_COMPRESSION, NO_COMPRESSION } from '
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, renderer, exporter, mesh, controls, renderTarget, dataTexture;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGLRenderer,
+    exporter: EXRExporter,
+    mesh: THREE.Mesh,
+    controls: OrbitControls,
+    renderTarget: THREE.WebGLRenderTarget,
+    dataTexture: THREE.DataTexture;
 
 const params = {
     target: 'pmrem',
@@ -148,7 +155,7 @@ async function exportFile() {
     saveArrayBuffer(result, params.target + '.exr');
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: Uint8Array<ArrayBuffer>, filename: string) {
     const blob = new Blob([buffer], { type: 'image/x-exr' });
     const link = document.createElement('a');
 
diff --git a/examples-testing/examples/misc_exporter_gltf.ts b/examples-testing/examples/misc_exporter_gltf.ts
index 323c5c492..faef7421b 100644
--- a/examples-testing/examples/misc_exporter_gltf.ts
+++ b/examples-testing/examples/misc_exporter_gltf.ts
@@ -7,7 +7,7 @@ import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import * as TextureUtils from 'three/addons/utils/WebGLTextureUtils.js';
 
-function exportGLTF(input) {
+function exportGLTF(input: THREE.Object3D | THREE.Object3D[]) {
     const gltfExporter = new GLTFExporter().setTextureUtils(TextureUtils);
 
     const options = {
@@ -38,7 +38,7 @@ const link = document.createElement('a');
 link.style.display = 'none';
 document.body.appendChild(link); // Firefox workaround, see #6594
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
@@ -46,18 +46,25 @@ function save(blob, filename) {
     // URL.revokeObjectURL( url ); breaks Firefox...
 }
 
-function saveString(text, filename) {
+function saveString(text: string, filename: string) {
     save(new Blob([text], { type: 'text/plain' }), filename);
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: BufferSource, filename: string) {
     save(new Blob([buffer], { type: 'application/octet-stream' }), filename);
 }
 
-let container;
+let container: HTMLDivElement;
 
-let camera, object, object2, material, geometry, scene1, scene2, renderer;
-let gridHelper, sphere, model, coffeemat;
+let camera: THREE.PerspectiveCamera,
+    object: THREE.Object3D,
+    object2: THREE.Mesh,
+    material: THREE.MeshBasicMaterial | THREE.MeshLambertMaterial | THREE.MeshStandardMaterial,
+    geometry: THREE.BufferGeometry,
+    scene1: THREE.Scene,
+    scene2: THREE.Scene,
+    renderer: THREE.WebGLRenderer;
+let gridHelper: THREE.GridHelper, sphere: THREE.Mesh, model: THREE.Group, coffeemat: THREE.Group;
 
 const params = {
     trs: false,
@@ -388,8 +395,8 @@ function init() {
     const color = new THREE.Color();
     for (let i = 0; i < 50; i++) {
         matrix.setPosition(Math.random() * 100 - 50, Math.random() * 100 - 50, Math.random() * 100 - 50);
-        object.setMatrixAt(i, matrix);
-        object.setColorAt(i, color.setHSL(i / 50, 1, 0.5));
+        (object as THREE.InstancedMesh).setMatrixAt(i, matrix);
+        (object as THREE.InstancedMesh).setColorAt(i, color.setHSL(i / 50, 1, 0.5));
     }
 
     object.position.set(400, 0, 200);
diff --git a/examples-testing/examples/misc_exporter_ktx2.ts b/examples-testing/examples/misc_exporter_ktx2.ts
index c96889a24..1c8535e0e 100644
--- a/examples-testing/examples/misc_exporter_ktx2.ts
+++ b/examples-testing/examples/misc_exporter_ktx2.ts
@@ -5,7 +5,14 @@ import { KTX2Exporter } from 'three/addons/exporters/KTX2Exporter.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, renderer, exporter, mesh, controls, renderTarget, dataTexture;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGLRenderer,
+    exporter: KTX2Exporter,
+    mesh: THREE.Mesh,
+    controls: OrbitControls,
+    renderTarget: THREE.WebGLRenderTarget,
+    dataTexture: THREE.DataTexture;
 
 const params = {
     target: 'pmrem',
@@ -135,7 +142,7 @@ async function exportFile() {
     saveArrayBuffer(result, params.target + '.ktx2');
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: Uint8Array<ArrayBuffer>, filename: string) {
     const blob = new Blob([buffer], { type: 'image/ktx2' });
     const link = document.createElement('a');
 
diff --git a/examples-testing/examples/misc_exporter_obj.ts b/examples-testing/examples/misc_exporter_obj.ts
index 025034daf..73638fff1 100644
--- a/examples-testing/examples/misc_exporter_obj.ts
+++ b/examples-testing/examples/misc_exporter_obj.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const params = {
     addTriangle: addTriangle,
@@ -66,12 +66,12 @@ function exportToObj() {
     saveString(result, 'object.obj');
 }
 
-function addGeometry(type) {
+function addGeometry(type: number) {
     for (let i = 0; i < scene.children.length; i++) {
         const child = scene.children[i];
 
-        if (child.isMesh || child.isPoints) {
-            child.geometry.dispose();
+        if ((child as THREE.Mesh).isMesh || (child as THREE.Points).isPoints) {
+            (child as THREE.Mesh | THREE.Points).geometry.dispose();
             scene.remove(child);
             i--;
         }
@@ -156,13 +156,13 @@ const link = document.createElement('a');
 link.style.display = 'none';
 document.body.appendChild(link);
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
 }
 
-function saveString(text, filename) {
+function saveString(text: string, filename: string) {
     save(new Blob([text], { type: 'text/plain' }), filename);
 }
 
diff --git a/examples-testing/examples/misc_exporter_ply.ts b/examples-testing/examples/misc_exporter_ply.ts
index b7e324688..c1682103c 100644
--- a/examples-testing/examples/misc_exporter_ply.ts
+++ b/examples-testing/examples/misc_exporter_ply.ts
@@ -4,7 +4,11 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { PLYExporter } from 'three/addons/exporters/PLYExporter.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, renderer, exporter, mesh;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGLRenderer,
+    exporter: PLYExporter,
+    mesh: THREE.Mesh;
 
 const params = {
     exportASCII: exportASCII,
@@ -141,16 +145,16 @@ const link = document.createElement('a');
 link.style.display = 'none';
 document.body.appendChild(link);
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
 }
 
-function saveString(text, filename) {
+function saveString(text: string, filename: string) {
     save(new Blob([text], { type: 'text/plain' }), filename);
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: BufferSource, filename: string) {
     save(new Blob([buffer], { type: 'application/octet-stream' }), filename);
 }
diff --git a/examples-testing/examples/misc_exporter_stl.ts b/examples-testing/examples/misc_exporter_stl.ts
index ff6d6e2b5..105aeb07d 100644
--- a/examples-testing/examples/misc_exporter_stl.ts
+++ b/examples-testing/examples/misc_exporter_stl.ts
@@ -4,7 +4,11 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { STLExporter } from 'three/addons/exporters/STLExporter.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, renderer, exporter, mesh;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGLRenderer,
+    exporter: STLExporter,
+    mesh: THREE.Mesh;
 
 const params = {
     exportASCII: exportASCII,
@@ -114,16 +118,16 @@ const link = document.createElement('a');
 link.style.display = 'none';
 document.body.appendChild(link);
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
 }
 
-function saveString(text, filename) {
+function saveString(text: string, filename: string) {
     save(new Blob([text], { type: 'text/plain' }), filename);
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: BufferSource, filename: string) {
     save(new Blob([buffer], { type: 'application/octet-stream' }), filename);
 }
diff --git a/examples-testing/examples/misc_exporter_usdz.ts b/examples-testing/examples/misc_exporter_usdz.ts
index f1ce65485..5ec818dd0 100644
--- a/examples-testing/examples/misc_exporter_usdz.ts
+++ b/examples-testing/examples/misc_exporter_usdz.ts
@@ -7,7 +7,7 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { USDZExporter } from 'three/addons/exporters/USDZExporter.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const params = {
     exportUSDZ: exportUSDZ,
@@ -50,7 +50,7 @@ function init() {
         const arraybuffer = await exporter.parseAsync(gltf.scene);
         const blob = new Blob([arraybuffer], { type: 'application/octet-stream' });
 
-        const link = document.getElementById('link');
+        const link = document.getElementById('link') as HTMLAnchorElement;
         link.href = URL.createObjectURL(blob);
     });
 
@@ -78,7 +78,7 @@ function createSpotShadowMesh() {
     canvas.width = 128;
     canvas.height = 128;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     const gradient = context.createRadialGradient(
         canvas.width / 2,
         canvas.height / 2,
@@ -119,7 +119,7 @@ function onWindowResize() {
 }
 
 function exportUSDZ() {
-    const link = document.getElementById('link');
+    const link = document.getElementById('link')!;
     link.click();
 }
 
diff --git a/examples-testing/examples/misc_uv_tests.ts b/examples-testing/examples/misc_uv_tests.ts
index 4f782d45f..0759cfcad 100644
--- a/examples-testing/examples/misc_uv_tests.ts
+++ b/examples-testing/examples/misc_uv_tests.ts
@@ -7,7 +7,7 @@ import { UVsDebug } from 'three/addons/utils/UVsDebug.js';
  * as well as allow a new user to visualize what UVs are about.
  */
 
-function test(name, geometry) {
+function test(name: string, geometry: THREE.BufferGeometry) {
     const d = document.createElement('div');
 
     d.innerHTML = '<h3>' + name + '</h3>';
diff --git a/examples-testing/examples/physics_ammo_instancing.ts b/examples-testing/examples/physics_ammo_instancing.ts
index 5cbee3260..400763ef9 100644
--- a/examples-testing/examples/physics_ammo_instancing.ts
+++ b/examples-testing/examples/physics_ammo_instancing.ts
@@ -1,12 +1,12 @@
 import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { AmmoPhysics } from 'three/addons/physics/AmmoPhysics.js';
+import { AmmoPhysics, AmmoPhysicsObject } from 'three/addons/physics/AmmoPhysics.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
-let physics, position;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let physics: AmmoPhysicsObject, position: THREE.Vector3;
 
-let boxes, spheres;
+let boxes: THREE.InstancedMesh, spheres: THREE.InstancedMesh;
 
 init();
 
diff --git a/examples-testing/examples/physics_jolt_instancing.ts b/examples-testing/examples/physics_jolt_instancing.ts
index 70980b8d5..e102f5577 100644
--- a/examples-testing/examples/physics_jolt_instancing.ts
+++ b/examples-testing/examples/physics_jolt_instancing.ts
@@ -1,12 +1,12 @@
 import * as THREE from 'three/webgpu';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { JoltPhysics } from 'three/addons/physics/JoltPhysics.js';
+import { JoltPhysics, JoltPhysicsObject } from 'three/addons/physics/JoltPhysics.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
-let physics, position;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, stats: Stats;
+let physics: JoltPhysicsObject, position: THREE.Vector3;
 
-let boxes, spheres;
+let boxes: THREE.InstancedMesh, spheres: THREE.InstancedMesh;
 
 init();
 
diff --git a/examples-testing/examples/physics_rapier_basic.ts b/examples-testing/examples/physics_rapier_basic.ts
index 0bacda80c..cb3c4e4b5 100644
--- a/examples-testing/examples/physics_rapier_basic.ts
+++ b/examples-testing/examples/physics_rapier_basic.ts
@@ -1,12 +1,16 @@
 import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { RapierPhysics } from 'three/addons/physics/RapierPhysics.js';
+import { RapierPhysics, RapierPhysicsObject } from 'three/addons/physics/RapierPhysics.js';
 import { RapierHelper } from 'three/addons/helpers/RapierHelper.js';
 import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats, controls;
-let physics, physicsHelper;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    controls: OrbitControls;
+let physics: RapierPhysicsObject, physicsHelper: RapierHelper;
 
 init();
 
@@ -126,10 +130,10 @@ function onWindowResize() {
 
 function animate() {
     for (const object of scene.children) {
-        if (object.isMesh) {
+        if ((object as THREE.Mesh).isMesh) {
             if (object.position.y < -10) {
-                scene.remove(object);
-                physics.removeMesh(object);
+                scene.remove(object as THREE.Mesh);
+                physics.removeMesh(object as THREE.Mesh);
             }
         }
     }
diff --git a/examples-testing/examples/physics_rapier_character_controller.ts b/examples-testing/examples/physics_rapier_character_controller.ts
index 8e797a98c..d9b8caa6f 100644
--- a/examples-testing/examples/physics_rapier_character_controller.ts
+++ b/examples-testing/examples/physics_rapier_character_controller.ts
@@ -1,12 +1,14 @@
 import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { RapierPhysics } from 'three/addons/physics/RapierPhysics.js';
+import { RapierPhysics, RapierPhysicsObject, RAPIER } from 'three/addons/physics/RapierPhysics.js';
 import { RapierHelper } from 'three/addons/helpers/RapierHelper.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
-let physics, characterController, physicsHelper;
-let player, movement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let physics: RapierPhysicsObject,
+    characterController: InstanceType<RAPIER['KinematicCharacterController']>,
+    physicsHelper: RapierHelper;
+let player: THREE.Mesh, movement: { forward: number; right: number };
 
 init();
 
@@ -100,7 +102,7 @@ async function init() {
     window.addEventListener('resize', onWindowResize, false);
 }
 
-function random(min, max) {
+function random(min: number, max: number) {
     return Math.random() * (max - min) + min;
 }
 
diff --git a/examples-testing/examples/physics_rapier_instancing.ts b/examples-testing/examples/physics_rapier_instancing.ts
index 20509f7fd..c6e0ca0e1 100644
--- a/examples-testing/examples/physics_rapier_instancing.ts
+++ b/examples-testing/examples/physics_rapier_instancing.ts
@@ -1,12 +1,12 @@
 import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { RapierPhysics } from 'three/addons/physics/RapierPhysics.js';
+import { RapierPhysics, RapierPhysicsObject } from 'three/addons/physics/RapierPhysics.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
-let physics, position;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let physics: RapierPhysicsObject, position: THREE.Vector3;
 
-let boxes, spheres;
+let boxes: THREE.InstancedMesh, spheres: THREE.InstancedMesh;
 
 init();
 
diff --git a/examples-testing/examples/physics_rapier_joints.ts b/examples-testing/examples/physics_rapier_joints.ts
index 5f8805fe1..318ffa8ef 100644
--- a/examples-testing/examples/physics_rapier_joints.ts
+++ b/examples-testing/examples/physics_rapier_joints.ts
@@ -1,11 +1,11 @@
 import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { RapierPhysics } from 'three/addons/physics/RapierPhysics.js';
+import { RapierPhysics, RapierPhysicsObject } from 'three/addons/physics/RapierPhysics.js';
 import { RapierHelper } from 'three/addons/helpers/RapierHelper.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
-let physics, pivot, physicsHelper;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let physics: RapierPhysicsObject, pivot: THREE.Mesh, physicsHelper: RapierHelper;
 
 init();
 
@@ -88,7 +88,7 @@ async function initPhysics() {
 
 //link - the mesh that the new link will be attached to
 //x    - used to position the new link
-function addLink(link, x) {
+function addLink(link: THREE.Mesh, x: number) {
     const geometry = new THREE.CapsuleGeometry(0.25, 1.8);
     const material = new THREE.MeshStandardMaterial({ color: 0xcccc00 });
 
diff --git a/examples-testing/examples/physics_rapier_terrain.ts b/examples-testing/examples/physics_rapier_terrain.ts
index 7a6074da3..f0a8d4ad8 100644
--- a/examples-testing/examples/physics_rapier_terrain.ts
+++ b/examples-testing/examples/physics_rapier_terrain.ts
@@ -1,7 +1,7 @@
 import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { RapierPhysics } from 'three/addons/physics/RapierPhysics.js';
+import { RapierPhysics, RapierPhysicsObject } from 'three/addons/physics/RapierPhysics.js';
 
 // Heightfield parameters
 const terrainWidthExtents = 100;
@@ -14,15 +14,15 @@ const terrainMaxHeight = 8;
 const terrainMinHeight = -2;
 
 // Graphics variables
-let container, stats;
-let camera, scene, renderer;
-let terrainMesh;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let terrainMesh: THREE.Mesh;
 const clock = new THREE.Clock();
 
 // Physics variables
-let physics;
-const dynamicObjects = [];
-let heightData = null;
+let physics: RapierPhysicsObject;
+const dynamicObjects: THREE.Mesh[] = [];
+let heightData: Float32Array | null = null;
 
 let time = 0;
 const objectTimePeriod = 3;
@@ -40,7 +40,7 @@ async function init() {
 }
 
 function initGraphics() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
@@ -49,16 +49,16 @@ function initGraphics() {
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
-    stats.domElement.style.position = 'absolute';
-    stats.domElement.style.top = '0px';
-    container.appendChild(stats.domElement);
+    stats.dom.style.position = 'absolute';
+    stats.dom.style.top = '0px';
+    container.appendChild(stats.dom);
 
     camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.2, 2000);
     scene = new THREE.Scene();
     scene.background = new THREE.Color(0xbfd1e5);
 
     camera.position.y =
-        heightData[terrainHalfWidth + terrainHalfDepth * terrainWidth] * (terrainMaxHeight - terrainMinHeight) + 5;
+        heightData![terrainHalfWidth + terrainHalfDepth * terrainWidth] * (terrainMaxHeight - terrainMinHeight) + 5;
     camera.position.z = terrainDepthExtents / 2;
     camera.lookAt(0, 0, 0);
 
@@ -76,7 +76,7 @@ function initGraphics() {
     const vertices = geometry.attributes.position.array;
 
     for (let i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {
-        vertices[j + 1] = heightData[i];
+        vertices[j + 1] = heightData![i];
     }
 
     geometry.computeVertexNormals();
@@ -127,7 +127,7 @@ async function initPhysics() {
     physics = await RapierPhysics();
 
     // Create the terrain body using RapierPhysics module
-    physics.addHeightfield(terrainMesh, terrainWidth - 1, terrainDepth - 1, heightData, {
+    physics.addHeightfield(terrainMesh, terrainWidth - 1, terrainDepth - 1, heightData!, {
         x: terrainWidthExtents,
         y: 1.0,
         z: terrainDepthExtents,
@@ -136,7 +136,7 @@ async function initPhysics() {
     // Continue with adding other dynamic objects as needed
 }
 
-function generateHeight(width, depth, minHeight, maxHeight) {
+function generateHeight(width: number, depth: number, minHeight: number, maxHeight: number) {
     const size = width * depth;
     const data = new Float32Array(size);
     const hRange = maxHeight - minHeight;
diff --git a/examples-testing/examples/physics_rapier_vehicle_controller.ts b/examples-testing/examples/physics_rapier_vehicle_controller.ts
index fac5ef082..d4399154b 100644
--- a/examples-testing/examples/physics_rapier_vehicle_controller.ts
+++ b/examples-testing/examples/physics_rapier_vehicle_controller.ts
@@ -1,12 +1,23 @@
 import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { RapierPhysics } from 'three/addons/physics/RapierPhysics.js';
+import { RapierPhysics, RapierPhysicsObject, RAPIER } from 'three/addons/physics/RapierPhysics.js';
 import { RapierHelper } from 'three/addons/helpers/RapierHelper.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
-let physics, physicsHelper, controls;
-let car, chassis, wheels, movement, vehicleController;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let physics: RapierPhysicsObject, physicsHelper: RapierHelper, controls: OrbitControls;
+let car: THREE.Mesh,
+    chassis: InstanceType<RAPIER['RigidBody']>,
+    wheels: THREE.Mesh[],
+    movement: {
+        forward: number;
+        right: number;
+        brake: number;
+        reset: boolean;
+        accelerateForce: { value: number; min: number; max: number; step: number };
+        brakeForce: { value: number; min: number; max: number; step: number };
+    },
+    vehicleController: InstanceType<RAPIER['DynamicRayCastVehicleController']>;
 
 init();
 
@@ -148,7 +159,7 @@ function createCar() {
     vehicleController.setWheelSteering(1, Math.PI / 4);
 }
 
-function addWheel(index, pos, carMesh) {
+function addWheel(index: number, pos: { x: number; y: number; z: number }, carMesh: THREE.Mesh) {
     // Define wheel properties
     const wheelRadius = 0.3;
     const wheelWidth = 0.4;
@@ -167,7 +178,7 @@ function addWheel(index, pos, carMesh) {
     vehicleController.setWheelFrictionSlip(index, 1000.0);
 
     // Enable steering for the wheel
-    vehicleController.setWheelSteering(index, pos.z < 0);
+    vehicleController.setWheelSteering(index, (pos.z < 0) as unknown as number);
 
     // Create a wheel mesh
     const geometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelWidth, 16);
@@ -193,8 +204,8 @@ function updateWheels() {
     //const chassisPosition = chassis.translation();
 
     wheels.forEach((wheel, index) => {
-        const wheelAxleCs = vehicleController.wheelAxleCs(index);
-        const connection = vehicleController.wheelChassisConnectionPointCs(index).y || 0;
+        const wheelAxleCs = vehicleController.wheelAxleCs(index)!;
+        const connection = vehicleController.wheelChassisConnectionPointCs(index)!.y || 0;
         const suspension = vehicleController.wheelSuspensionLength(index) || 0;
         const steering = vehicleController.wheelSteering(index) || 0;
         const rotationRad = vehicleController.wheelRotation(index) || 0;
@@ -254,7 +265,7 @@ function updateCarControl() {
     vehicleController.setWheelEngineForce(0, engineForce);
     vehicleController.setWheelEngineForce(1, engineForce);
 
-    const currentSteering = vehicleController.wheelSteering(0);
+    const currentSteering = vehicleController.wheelSteering(0)!;
     const steerDirection = movement.right;
     const steerAngle = Math.PI / 4;
 
diff --git a/examples-testing/examples/svg_lines.ts b/examples-testing/examples/svg_lines.ts
index 99b74c405..65aaf28dd 100644
--- a/examples-testing/examples/svg_lines.ts
+++ b/examples-testing/examples/svg_lines.ts
@@ -4,7 +4,7 @@ import { SVGRenderer } from 'three/addons/renderers/SVGRenderer.js';
 
 THREE.ColorManagement.enabled = false;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: SVGRenderer;
 
 init();
 animate();
diff --git a/examples-testing/examples/svg_sandbox.ts b/examples-testing/examples/svg_sandbox.ts
index 88f651669..7a3381684 100644
--- a/examples-testing/examples/svg_sandbox.ts
+++ b/examples-testing/examples/svg_sandbox.ts
@@ -7,9 +7,9 @@ import { SVGRenderer, SVGObject } from 'three/addons/renderers/SVGRenderer.js';
 
 THREE.ColorManagement.enabled = false;
 
-let camera, scene, renderer, stats, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: SVGRenderer, stats: Stats, controls: OrbitControls;
 
-let group;
+let group: THREE.Mesh;
 
 init();
 animate();
@@ -34,9 +34,13 @@ function init() {
 
     const boxGeometry = new THREE.BoxGeometry(100, 100, 100);
 
-    let mesh = new THREE.Mesh(
+    let mesh: THREE.Mesh = new THREE.Mesh(
         boxGeometry,
-        new THREE.MeshBasicMaterial({ color: 0x0000ff, opacity: 0.5, transparent: true }),
+        new THREE.MeshBasicMaterial({
+            color: 0x0000ff,
+            opacity: 0.5,
+            transparent: true,
+        }),
     );
     mesh.position.x = 500;
     mesh.rotation.x = Math.random();
@@ -56,7 +60,10 @@ function init() {
 
     mesh = new THREE.Mesh(
         new THREE.PlaneGeometry(100, 100),
-        new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff, side: THREE.DoubleSide }),
+        new THREE.MeshBasicMaterial({
+            color: Math.random() * 0xffffff,
+            side: THREE.DoubleSide,
+        }),
     );
     mesh.position.y = -500;
     mesh.scale.x = mesh.scale.y = mesh.scale.z = 2;
@@ -76,7 +83,10 @@ function init() {
     // POLYFIELD
 
     const geometry = new THREE.BufferGeometry();
-    const material = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide });
+    const material = new THREE.MeshBasicMaterial({
+        vertexColors: true,
+        side: THREE.DoubleSide,
+    });
 
     const v = new THREE.Vector3();
     const v0 = new THREE.Vector3();
@@ -123,7 +133,9 @@ function init() {
     // SPRITES
 
     for (let i = 0; i < 50; i++) {
-        const material = new THREE.SpriteMaterial({ color: Math.random() * 0xffffff });
+        const material = new THREE.SpriteMaterial({
+            color: Math.random() * 0xffffff,
+        });
         const sprite = new THREE.Sprite(material);
         sprite.position.x = Math.random() * 1000 - 500;
         sprite.position.y = Math.random() * 1000 - 500;
@@ -140,7 +152,7 @@ function init() {
     node.setAttribute('r', '40');
 
     for (let i = 0; i < 50; i++) {
-        const object = new SVGObject(node.cloneNode());
+        const object = new SVGObject(node.cloneNode() as SVGCircleElement);
         object.position.x = Math.random() * 1000 - 500;
         object.position.y = Math.random() * 1000 - 500;
         object.position.z = Math.random() * 1000 - 500;
@@ -153,7 +165,7 @@ function init() {
     fileLoader.load('models/svg/hexagon.svg', function (svg) {
         const node = document.createElementNS('http://www.w3.org/2000/svg', 'g');
         const parser = new DOMParser();
-        const doc = parser.parseFromString(svg, 'image/svg+xml');
+        const doc = parser.parseFromString(svg as string, 'image/svg+xml');
 
         node.appendChild(doc.documentElement);
 
diff --git a/examples-testing/examples/webaudio_orientation.ts b/examples-testing/examples/webaudio_orientation.ts
index 7baaa88a0..e133c2cd2 100644
--- a/examples-testing/examples/webaudio_orientation.ts
+++ b/examples-testing/examples/webaudio_orientation.ts
@@ -4,16 +4,16 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { PositionalAudioHelper } from 'three/addons/helpers/PositionalAudioHelper.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let scene, camera, renderer;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer;
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', init);
 
 function init() {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     //
 
@@ -65,7 +65,7 @@ function init() {
     const listener = new THREE.AudioListener();
     camera.add(listener);
 
-    const audioElement = document.getElementById('music');
+    const audioElement = document.getElementById('music') as HTMLAudioElement;
     audioElement.play();
 
     const positionalAudio = new THREE.PositionalAudio(listener);
@@ -85,10 +85,10 @@ function init() {
         boomBox.scale.set(20, 20, 20);
 
         boomBox.traverse(function (object) {
-            if (object.isMesh) {
-                object.material.envMap = reflectionCube;
-                object.geometry.rotateY(-Math.PI);
-                object.castShadow = true;
+            if ((object as THREE.Mesh).isMesh) {
+                ((object as THREE.Mesh).material as THREE.MeshStandardMaterial).envMap = reflectionCube;
+                (object as THREE.Mesh).geometry.rotateY(-Math.PI);
+                (object as THREE.Mesh).castShadow = true;
             }
         });
 
@@ -101,7 +101,11 @@ function init() {
     // sound is damped behind this wall
 
     const wallGeometry = new THREE.BoxGeometry(2, 1, 0.1);
-    const wallMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
+    const wallMaterial = new THREE.MeshBasicMaterial({
+        color: 0xff0000,
+        transparent: true,
+        opacity: 0.5,
+    });
 
     const wall = new THREE.Mesh(wallGeometry, wallMaterial);
     wall.position.set(0, 0.5, -0.5);
diff --git a/examples-testing/examples/webaudio_sandbox.ts b/examples-testing/examples/webaudio_sandbox.ts
index d67d0d552..21c7a0bfc 100644
--- a/examples-testing/examples/webaudio_sandbox.ts
+++ b/examples-testing/examples/webaudio_sandbox.ts
@@ -4,19 +4,23 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
 
-let camera, controls, scene, renderer, light;
+let camera: THREE.PerspectiveCamera,
+    controls: FirstPersonControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    light: THREE.DirectionalLight;
 
-let material1, material2, material3;
+let material1: THREE.MeshPhongMaterial, material2: THREE.MeshPhongMaterial, material3: THREE.MeshPhongMaterial;
 
-let analyser1, analyser2, analyser3;
+let analyser1: THREE.AudioAnalyser, analyser2: THREE.AudioAnalyser, analyser3: THREE.AudioAnalyser;
 
 const clock = new THREE.Clock();
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', init);
 
 function init() {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
@@ -45,7 +49,7 @@ function init() {
     scene.add(mesh1);
 
     const sound1 = new THREE.PositionalAudio(listener);
-    const songElement = document.getElementById('song');
+    const songElement = document.getElementById('song') as HTMLAudioElement;
     sound1.setMediaElementSource(songElement);
     sound1.setRefDistance(20);
     songElement.play();
@@ -58,7 +62,7 @@ function init() {
     scene.add(mesh2);
 
     const sound2 = new THREE.PositionalAudio(listener);
-    const skullbeatzElement = document.getElementById('skullbeatz');
+    const skullbeatzElement = document.getElementById('skullbeatz') as HTMLAudioElement;
     sound2.setMediaElementSource(skullbeatzElement);
     sound2.setRefDistance(20);
     skullbeatzElement.play();
@@ -89,7 +93,7 @@ function init() {
     // global ambient audio
 
     const sound4 = new THREE.Audio(listener);
-    const utopiaElement = document.getElementById('utopia');
+    const utopiaElement = document.getElementById('utopia') as HTMLAudioElement;
     sound4.setMediaElementSource(utopiaElement);
     sound4.setVolume(0.5);
     utopiaElement.play();
@@ -102,18 +106,31 @@ function init() {
 
     //
 
-    const SoundControls = function () {
-        this.master = listener.getMasterVolume();
-        this.firstSphere = sound1.getVolume();
-        this.secondSphere = sound2.getVolume();
-        this.thirdSphere = sound3.getVolume();
-        this.Ambient = sound4.getVolume();
-    };
-
-    const GeneratorControls = function () {
-        this.frequency = oscillator.frequency.value;
-        this.wavetype = oscillator.type;
-    };
+    class SoundControls {
+        master: number;
+        firstSphere: number;
+        secondSphere: number;
+        thirdSphere: number;
+        Ambient: number;
+
+        constructor() {
+            this.master = listener.getMasterVolume();
+            this.firstSphere = sound1.getVolume();
+            this.secondSphere = sound2.getVolume();
+            this.thirdSphere = sound3.getVolume();
+            this.Ambient = sound4.getVolume();
+        }
+    }
+
+    class GeneratorControls {
+        frequency: number;
+        wavetype: OscillatorType;
+
+        constructor() {
+            this.frequency = oscillator.frequency.value;
+            this.wavetype = oscillator.type;
+        }
+    }
 
     const gui = new GUI();
     const soundControls = new SoundControls();
diff --git a/examples-testing/examples/webaudio_timing.ts b/examples-testing/examples/webaudio_timing.ts
index 9e17bcbcd..475113b94 100644
--- a/examples-testing/examples/webaudio_timing.ts
+++ b/examples-testing/examples/webaudio_timing.ts
@@ -2,22 +2,22 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let scene, camera, renderer, clock;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
 
-const objects = [];
+const objects: THREE.Mesh[] = [];
 
 const speed = 2.5;
 const height = 3;
 const offset = 0.5;
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', init);
 
 function init() {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
 
@@ -141,7 +141,7 @@ function animate() {
             if (ball.userData.down === true) {
                 // ball changed direction from down to up
 
-                const audio = ball.children[0];
+                const audio = ball.children[0] as THREE.Audio;
                 audio.play(); // play audio with perfect timing when ball hits the surface
                 ball.userData.down = false;
             }
diff --git a/examples-testing/examples/webaudio_visualizer.ts b/examples-testing/examples/webaudio_visualizer.ts
index a3f58cb36..0bad866f6 100644
--- a/examples-testing/examples/webaudio_visualizer.ts
+++ b/examples-testing/examples/webaudio_visualizer.ts
@@ -1,8 +1,13 @@
 import * as THREE from 'three';
+import { IUniform } from 'three';
 
-let scene, camera, renderer, analyser, uniforms;
+let scene: THREE.Scene,
+    camera: THREE.Camera,
+    renderer: THREE.WebGLRenderer,
+    analyser: THREE.AudioAnalyser,
+    uniforms: { [uniform: string]: IUniform };
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', init);
 
 function init() {
@@ -10,12 +15,12 @@ function init() {
 
     //
 
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
     //
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
 
@@ -51,8 +56,8 @@ function init() {
 
     const material = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
     });
 
     const geometry = new THREE.PlaneGeometry(1, 1);
diff --git a/examples-testing/examples/webgl_animation_keyframes.ts b/examples-testing/examples/webgl_animation_keyframes.ts
index 88048f24c..ffe75d3ee 100644
--- a/examples-testing/examples/webgl_animation_keyframes.ts
+++ b/examples-testing/examples/webgl_animation_keyframes.ts
@@ -8,10 +8,10 @@ import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 
-let mixer;
+let mixer: THREE.AnimationMixer;
 
 const clock = new THREE.Clock();
-const container = document.getElementById('container');
+const container = document.getElementById('container')!;
 
 const stats = new Stats();
 container.appendChild(stats.dom);
diff --git a/examples-testing/examples/webgl_animation_multiple.ts b/examples-testing/examples/webgl_animation_multiple.ts
index 152c65067..ce3887496 100644
--- a/examples-testing/examples/webgl_animation_multiple.ts
+++ b/examples-testing/examples/webgl_animation_multiple.ts
@@ -4,11 +4,11 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, clock;
-let model, animations;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
+let model: THREE.Group, animations: THREE.AnimationClip[];
 
-const mixers = [],
-    objects = [];
+const mixers: THREE.AnimationMixer[] = [],
+    objects: THREE.Object3D[] = [];
 
 const params = {
     sharedSkeleton: false,
@@ -60,7 +60,7 @@ function init() {
         animations = gltf.animations;
 
         model.traverse(function (object) {
-            if (object.isMesh) object.castShadow = true;
+            if ((object as THREE.Mesh).isMesh) object.castShadow = true;
         });
 
         setupDefaultScene();
@@ -102,7 +102,7 @@ function clearScene() {
         scene.remove(object);
 
         scene.traverse(function (child) {
-            if (child.isSkinnedMesh) child.skeleton.dispose();
+            if ((child as THREE.SkinnedMesh).isSkinnedMesh) (child as THREE.SkinnedMesh).skeleton.dispose();
         });
     }
 }
@@ -138,9 +138,9 @@ function setupSharedSkeletonScene() {
     // all models share the same animation state
 
     const sharedModel = SkeletonUtils.clone(model);
-    const shareSkinnedMesh = sharedModel.getObjectByName('vanguard_Mesh');
+    const shareSkinnedMesh = sharedModel.getObjectByName('vanguard_Mesh') as THREE.SkinnedMesh;
     const sharedSkeleton = shareSkinnedMesh.skeleton;
-    const sharedParentBone = sharedModel.getObjectByName('mixamorigHips');
+    const sharedParentBone = sharedModel.getObjectByName('mixamorigHips')!;
     scene.add(sharedParentBone); // the bones need to be in the scene for the animation to work
 
     const model1 = shareSkinnedMesh.clone();
diff --git a/examples-testing/examples/webgl_animation_skinning_morph.ts b/examples-testing/examples/webgl_animation_skinning_morph.ts
index f05369aa9..5e9ce7d0d 100644
--- a/examples-testing/examples/webgl_animation_skinning_morph.ts
+++ b/examples-testing/examples/webgl_animation_skinning_morph.ts
@@ -5,10 +5,29 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let container, stats, clock, gui, mixer, actions, activeAction, previousAction;
-let camera, scene, renderer, model, face;
-
-const api = { state: 'Walking' };
+let container: HTMLDivElement,
+    stats: Stats,
+    clock: THREE.Clock,
+    gui: GUI,
+    mixer: THREE.AnimationMixer,
+    actions: Record<string, THREE.AnimationAction>,
+    activeAction: THREE.AnimationAction,
+    previousAction: THREE.AnimationAction;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    model: THREE.Group,
+    face: THREE.Mesh;
+
+const api: {
+    state: string;
+    Jump?: () => void;
+    Yes?: () => void;
+    No?: () => void;
+    Wave?: () => void;
+    Punch?: () => void;
+    ThumbsUp?: () => void;
+} = { state: 'Walking' };
 
 init();
 
@@ -80,9 +99,9 @@ function init() {
     container.appendChild(stats.dom);
 }
 
-function createGUI(model, animations) {
+function createGUI(model: THREE.Group, animations: THREE.AnimationClip[]) {
     const states = ['Idle', 'Walking', 'Running', 'Dance', 'Death', 'Sitting', 'Standing'];
-    const emotes = ['Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp'];
+    const emotes = ['Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp'] as const;
 
     gui = new GUI();
 
@@ -95,7 +114,7 @@ function createGUI(model, animations) {
         const action = mixer.clipAction(clip);
         actions[clip.name] = action;
 
-        if (emotes.indexOf(clip.name) >= 0 || states.indexOf(clip.name) >= 4) {
+        if (emotes.indexOf(clip.name as (typeof emotes)[number]) >= 0 || states.indexOf(clip.name) >= 4) {
             action.clampWhenFinished = true;
             action.loop = THREE.LoopOnce;
         }
@@ -117,14 +136,14 @@ function createGUI(model, animations) {
 
     const emoteFolder = gui.addFolder('Emotes');
 
-    function createEmoteCallback(name) {
+    function createEmoteCallback(name: (typeof emotes)[number]) {
         api[name] = function () {
             fadeToAction(name, 0.2);
 
             mixer.addEventListener('finished', restoreState);
         };
 
-        emoteFolder.add(api, name);
+        emoteFolder.add(api as Required<typeof api>, name);
     }
 
     function restoreState() {
@@ -141,13 +160,13 @@ function createGUI(model, animations) {
 
     // expressions
 
-    face = model.getObjectByName('Head_4');
+    face = model.getObjectByName('Head_4') as THREE.Mesh;
 
-    const expressions = Object.keys(face.morphTargetDictionary);
+    const expressions = Object.keys(face.morphTargetDictionary!);
     const expressionFolder = gui.addFolder('Expressions');
 
     for (let i = 0; i < expressions.length; i++) {
-        expressionFolder.add(face.morphTargetInfluences, i, 0, 1, 0.01).name(expressions[i]);
+        expressionFolder.add(face.morphTargetInfluences!, i, 0, 1, 0.01).name(expressions[i]);
     }
 
     activeAction = actions['Walking'];
@@ -156,7 +175,7 @@ function createGUI(model, animations) {
     expressionFolder.open();
 }
 
-function fadeToAction(name, duration) {
+function fadeToAction(name: string, duration: number) {
     previousAction = activeAction;
     activeAction = actions[name];
 
diff --git a/examples-testing/examples/webgl_animation_walk.ts b/examples-testing/examples/webgl_animation_walk.ts
index adf576544..2eb64a609 100644
--- a/examples-testing/examples/webgl_animation_walk.ts
+++ b/examples-testing/examples/webgl_animation_walk.ts
@@ -6,10 +6,19 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
-let scene, renderer, camera, floor, orbitControls;
-let group, followGroup, model, skeleton, mixer, clock;
-
-let actions;
+let scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    camera: THREE.PerspectiveCamera,
+    floor: THREE.Mesh,
+    orbitControls: OrbitControls;
+let group: THREE.Group,
+    followGroup: THREE.Group,
+    model: THREE.Group,
+    skeleton: THREE.SkeletonHelper,
+    mixer: THREE.AnimationMixer,
+    clock: THREE.Clock;
+
+let actions: { Idle: THREE.AnimationAction; Walk: THREE.AnimationAction; Run: THREE.AnimationAction };
 
 const settings = {
     show_skeleton: false,
@@ -19,7 +28,19 @@ const settings = {
 const PI = Math.PI;
 const PI90 = Math.PI / 2;
 
-const controls = {
+const controls: {
+    key: number[];
+    ease: THREE.Vector3;
+    position: THREE.Vector3;
+    up: THREE.Vector3;
+    rotate: THREE.Quaternion;
+    current: keyof typeof actions;
+    fadeDuration: number;
+    runVelocity: number;
+    walkVelocity: number;
+    rotateSpeed: number;
+    floorDecale: number;
+} = {
     key: [0, 0],
     ease: new THREE.Vector3(),
     position: new THREE.Vector3(),
@@ -36,7 +57,7 @@ const controls = {
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
     camera.position.set(0, 2, -5);
@@ -156,21 +177,32 @@ function loadModel() {
         group.rotation.y = PI;
 
         model.traverse(function (object) {
-            if (object.isMesh) {
+            if ((object as THREE.Mesh).isMesh) {
                 if (object.name == 'vanguard_Mesh') {
-                    object.castShadow = true;
-                    object.receiveShadow = true;
-                    //object.material.envMapIntensity = 0.5;
-                    object.material.metalness = 1.0;
-                    object.material.roughness = 0.2;
-                    object.material.color.set(1, 1, 1);
-                    object.material.metalnessMap = object.material.map;
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).castShadow = true;
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).receiveShadow = true;
+                    //(object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.envMapIntensity = 0.5;
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.metalness = 1.0;
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.roughness = 0.2;
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.color.set(
+                        1,
+                        1,
+                        1,
+                    );
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.metalnessMap = (
+                        object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>
+                    ).material.map;
                 } else {
-                    object.material.metalness = 1;
-                    object.material.roughness = 0;
-                    object.material.transparent = true;
-                    object.material.opacity = 0.8;
-                    object.material.color.set(1, 1, 1);
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.metalness = 1;
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.roughness = 0;
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.transparent =
+                        true;
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.opacity = 0.8;
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.color.set(
+                        1,
+                        1,
+                        1,
+                    );
                 }
             }
         });
@@ -199,9 +231,9 @@ function loadModel() {
         };
 
         for (const m in actions) {
-            actions[m].enabled = true;
-            actions[m].setEffectiveTimeScale(1);
-            if (m !== 'Idle') actions[m].setEffectiveWeight(0);
+            actions[m as keyof typeof actions].enabled = true;
+            actions[m as keyof typeof actions].setEffectiveTimeScale(1);
+            if (m !== 'Idle') actions[m as keyof typeof actions].setEffectiveWeight(0);
         }
 
         actions.Idle.play();
@@ -210,7 +242,7 @@ function loadModel() {
     });
 }
 
-function updateCharacter(delta) {
+function updateCharacter(delta: number) {
     const fade = controls.fadeDuration;
     const key = controls.key;
     const up = controls.up;
@@ -283,7 +315,7 @@ function updateCharacter(delta) {
     orbitControls.update();
 }
 
-function unwrapRad(r) {
+function unwrapRad(r: number) {
     return Math.atan2(Math.sin(r), Math.cos(r));
 }
 
@@ -297,13 +329,13 @@ function createPanel() {
     panel.add(settings, 'fixe_transition');
 }
 
-function setWeight(action, weight) {
+function setWeight(action: THREE.AnimationAction, weight: number) {
     action.enabled = true;
     action.setEffectiveTimeScale(1);
     action.setEffectiveWeight(weight);
 }
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     const key = controls.key;
     switch (event.code) {
         case 'ArrowUp':
@@ -331,7 +363,7 @@ function onKeyDown(event) {
     }
 }
 
-function onKeyUp(event) {
+function onKeyUp(event: KeyboardEvent) {
     const key = controls.key;
     switch (event.code) {
         case 'ArrowUp':
diff --git a/examples-testing/examples/webgl_buffergeometry.ts b/examples-testing/examples/webgl_buffergeometry.ts
index 28b2c96a4..6a802ab6c 100644
--- a/examples-testing/examples/webgl_buffergeometry.ts
+++ b/examples-testing/examples/webgl_buffergeometry.ts
@@ -2,17 +2,17 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh;
+let mesh: THREE.Mesh;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -117,8 +117,8 @@ function init() {
         colors.push(color.r, color.g, color.b, alpha);
     }
 
-    function disposeArray() {
-        this.array = null;
+    function disposeArray(this: THREE.BufferAttribute) {
+        this.array = null as unknown as THREE.TypedArray;
     }
 
     geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3).onUpload(disposeArray));
diff --git a/examples-testing/examples/webgl_buffergeometry_attributes_integer.ts b/examples-testing/examples/webgl_buffergeometry_attributes_integer.ts
index 00490b716..c553afe5d 100644
--- a/examples-testing/examples/webgl_buffergeometry_attributes_integer.ts
+++ b/examples-testing/examples/webgl_buffergeometry_attributes_integer.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer, mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mesh: THREE.Mesh;
 
 init();
 
@@ -65,7 +65,7 @@ function init() {
     geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
     geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
     geometry.setAttribute('textureIndex', new THREE.Int16BufferAttribute(textureIndices, 1));
-    geometry.attributes.textureIndex.gpuType = THREE.IntType;
+    (geometry.attributes.textureIndex as THREE.BufferAttribute).gpuType = THREE.IntType;
 
     geometry.computeBoundingSphere();
 
diff --git a/examples-testing/examples/webgl_buffergeometry_attributes_none.ts b/examples-testing/examples/webgl_buffergeometry_attributes_none.ts
index a1424e871..f7fcf29f9 100644
--- a/examples-testing/examples/webgl_buffergeometry_attributes_none.ts
+++ b/examples-testing/examples/webgl_buffergeometry_attributes_none.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer, mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mesh: THREE.Mesh;
 
 init();
 
@@ -27,8 +27,8 @@ function init() {
         uniforms: {
             seed: { value: 42 },
         },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
         side: THREE.DoubleSide,
         glslVersion: THREE.GLSL3,
     });
@@ -48,7 +48,7 @@ function init() {
     document.body.appendChild(renderer.domElement);
 }
 
-function animate(time) {
+function animate(time: number) {
     mesh.rotation.x = (time / 1000.0) * 0.25;
     mesh.rotation.y = (time / 1000.0) * 0.5;
 
diff --git a/examples-testing/examples/webgl_buffergeometry_custom_attributes_particles.ts b/examples-testing/examples/webgl_buffergeometry_custom_attributes_particles.ts
index 0dffa65cc..96dd89106 100644
--- a/examples-testing/examples/webgl_buffergeometry_custom_attributes_particles.ts
+++ b/examples-testing/examples/webgl_buffergeometry_custom_attributes_particles.ts
@@ -2,9 +2,11 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let particleSystem, uniforms, geometry;
+let particleSystem: THREE.Points,
+    uniforms: { pointTexture: THREE.IUniform<THREE.Texture> },
+    geometry: THREE.BufferGeometry;
 
 const particles = 100000;
 
@@ -22,8 +24,8 @@ function init() {
 
     const shaderMaterial = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
 
         blending: THREE.AdditiveBlending,
         depthTest: false,
@@ -66,7 +68,7 @@ function init() {
     renderer.setSize(window.innerWidth, window.innerHeight);
     renderer.setAnimationLoop(animate);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_buffergeometry_drawrange.ts b/examples-testing/examples/webgl_buffergeometry_drawrange.ts
index 142ff43bf..4b26ac2ac 100644
--- a/examples-testing/examples/webgl_buffergeometry_drawrange.ts
+++ b/examples-testing/examples/webgl_buffergeometry_drawrange.ts
@@ -5,15 +5,15 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let group;
-let container, stats;
-const particlesData = [];
-let camera, scene, renderer;
-let positions, colors;
-let particles;
-let pointCloud;
-let particlePositions;
-let linesMesh;
+let group: THREE.Group;
+let container: HTMLElement, stats: Stats;
+const particlesData: { velocity: THREE.Vector3; numConnections: number }[] = [];
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let positions: Float32Array<ArrayBuffer>, colors: Float32Array<ArrayBuffer>;
+let particles: THREE.BufferGeometry;
+let pointCloud: THREE.Points;
+let particlePositions: Float32Array<ArrayBuffer>;
+let linesMesh: THREE.LineSegments;
 
 const maxParticleCount = 1000;
 let particleCount = 500;
@@ -52,7 +52,7 @@ function initGUI() {
 function init() {
     initGUI();
 
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 4000);
     camera.position.z = 1750;
diff --git a/examples-testing/examples/webgl_buffergeometry_glbufferattribute.ts b/examples-testing/examples/webgl_buffergeometry_glbufferattribute.ts
index 80fa828bb..77f1bc385 100644
--- a/examples-testing/examples/webgl_buffergeometry_glbufferattribute.ts
+++ b/examples-testing/examples/webgl_buffergeometry_glbufferattribute.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let points;
+let points: THREE.Points<THREE.BufferGeometry<THREE.NormalOrGLBufferAttributes>, THREE.PointsMaterial>;
 
 const particles = 300000;
 let drawCount = 10000;
@@ -15,7 +15,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -37,7 +37,7 @@ function init() {
 
     //
 
-    const geometry = new THREE.BufferGeometry();
+    const geometry = new THREE.BufferGeometry<THREE.NormalOrGLBufferAttributes>();
 
     const positions = [];
     const positions2 = [];
@@ -72,15 +72,15 @@ function init() {
 
     const gl = renderer.getContext();
 
-    const pos = gl.createBuffer();
+    const pos = gl.createBuffer()!;
     gl.bindBuffer(gl.ARRAY_BUFFER, pos);
     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
 
-    const pos2 = gl.createBuffer();
+    const pos2 = gl.createBuffer()!;
     gl.bindBuffer(gl.ARRAY_BUFFER, pos2);
     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions2), gl.STATIC_DRAW);
 
-    const rgb = gl.createBuffer();
+    const rgb = gl.createBuffer()!;
     gl.bindBuffer(gl.ARRAY_BUFFER, rgb);
     gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(colors), gl.STATIC_DRAW);
 
diff --git a/examples-testing/examples/webgl_buffergeometry_indexed.ts b/examples-testing/examples/webgl_buffergeometry_indexed.ts
index a2f9f3795..4ad49d3cd 100644
--- a/examples-testing/examples/webgl_buffergeometry_indexed.ts
+++ b/examples-testing/examples/webgl_buffergeometry_indexed.ts
@@ -3,9 +3,9 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
-let mesh;
+let mesh: THREE.Mesh;
 
 init();
 
diff --git a/examples-testing/examples/webgl_buffergeometry_instancing.ts b/examples-testing/examples/webgl_buffergeometry_instancing.ts
index b27f500f0..c9432b181 100644
--- a/examples-testing/examples/webgl_buffergeometry_instancing.ts
+++ b/examples-testing/examples/webgl_buffergeometry_instancing.ts
@@ -3,14 +3,14 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10);
     camera.position.z = 2;
@@ -79,8 +79,8 @@ function init() {
             time: { value: 1.0 },
             sineTime: { value: 1.0 },
         },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
         side: THREE.DoubleSide,
         forceSinglePass: true,
         transparent: true,
@@ -126,7 +126,7 @@ function onWindowResize() {
 function animate() {
     const time = performance.now();
 
-    const object = scene.children[0];
+    const object = scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.RawShaderMaterial>;
 
     object.rotation.y = time * 0.0005;
     object.material.uniforms['time'].value = time * 0.005;
diff --git a/examples-testing/examples/webgl_buffergeometry_instancing_billboards.ts b/examples-testing/examples/webgl_buffergeometry_instancing_billboards.ts
index 2158dff39..2c97fbd94 100644
--- a/examples-testing/examples/webgl_buffergeometry_instancing_billboards.ts
+++ b/examples-testing/examples/webgl_buffergeometry_instancing_billboards.ts
@@ -2,10 +2,10 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
-let geometry, material, mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let geometry: THREE.InstancedBufferGeometry, material: THREE.RawShaderMaterial, mesh: THREE.Mesh;
 
 init();
 
@@ -41,8 +41,8 @@ function init() {
             map: { value: new THREE.TextureLoader().load('textures/sprites/circle.png') },
             time: { value: 0.0 },
         },
-        vertexShader: document.getElementById('vshader').textContent,
-        fragmentShader: document.getElementById('fshader').textContent,
+        vertexShader: document.getElementById('vshader')!.textContent!,
+        fragmentShader: document.getElementById('fshader')!.textContent!,
         depthTest: true,
         depthWrite: true,
     });
diff --git a/examples-testing/examples/webgl_buffergeometry_instancing_interleaved.ts b/examples-testing/examples/webgl_buffergeometry_instancing_interleaved.ts
index bef2c264d..c0887a8d3 100644
--- a/examples-testing/examples/webgl_buffergeometry_instancing_interleaved.ts
+++ b/examples-testing/examples/webgl_buffergeometry_instancing_interleaved.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
-let camera, scene, renderer, mesh;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mesh: THREE.InstancedMesh;
 
 const instances = 5000;
 let lastTime = 0;
@@ -16,7 +16,7 @@ const currentM = new THREE.Matrix4();
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
 
diff --git a/examples-testing/examples/webgl_buffergeometry_lines.ts b/examples-testing/examples/webgl_buffergeometry_lines.ts
index d039e0112..0b39e912d 100644
--- a/examples-testing/examples/webgl_buffergeometry_lines.ts
+++ b/examples-testing/examples/webgl_buffergeometry_lines.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats, timer;
+let container: HTMLElement, stats: Stats, timer: THREE.Timer;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let line;
+let line: THREE.Line;
 
 const segments = 10000;
 const r = 800;
@@ -15,7 +15,7 @@ let t = 0;
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -96,14 +96,14 @@ function animate() {
     line.rotation.y = time * 0.5;
 
     t += delta * 0.5;
-    line.morphTargetInfluences[0] = Math.abs(Math.sin(t));
+    line.morphTargetInfluences![0] = Math.abs(Math.sin(t));
 
     renderer.render(scene, camera);
 
     stats.update();
 }
 
-function generateMorphTargets(geometry) {
+function generateMorphTargets(geometry: THREE.BufferGeometry) {
     const data = [];
 
     for (let i = 0; i < segments; i++) {
diff --git a/examples-testing/examples/webgl_buffergeometry_lines_indexed.ts b/examples-testing/examples/webgl_buffergeometry_lines_indexed.ts
index 58296087e..8af0d6e9d 100644
--- a/examples-testing/examples/webgl_buffergeometry_lines_indexed.ts
+++ b/examples-testing/examples/webgl_buffergeometry_lines_indexed.ts
@@ -2,16 +2,16 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let parent_node;
+let parent_node: THREE.Object3D;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 9000;
@@ -21,9 +21,9 @@ function init() {
     const geometry = new THREE.BufferGeometry();
     const material = new THREE.LineBasicMaterial({ vertexColors: true });
 
-    const indices = [];
-    const positions = [];
-    const colors = [];
+    const indices: number[] = [];
+    const positions: number[] = [];
+    const colors: number[] = [];
 
     let next_positions_index = 0;
 
@@ -32,7 +32,7 @@ function init() {
     const iteration_count = 4;
     const rangle = (60 * Math.PI) / 180.0;
 
-    function add_vertex(v) {
+    function add_vertex(v: THREE.Vector3) {
         positions.push(v.x, v.y, v.z);
         colors.push(Math.random() * 0.5 + 0.5, Math.random() * 0.5 + 0.5, 1);
 
@@ -41,7 +41,7 @@ function init() {
 
     // simple Koch curve
 
-    function snowflake_iteration(p0, p4, depth) {
+    function snowflake_iteration(p0: THREE.Vector3, p4: THREE.Vector3, depth: number) {
         if (--depth < 0) {
             const i = next_positions_index - 1; // p0 already there
             add_vertex(p4);
@@ -68,7 +68,7 @@ function init() {
         snowflake_iteration(p3, p4, depth);
     }
 
-    function snowflake(points, loop, x_offset) {
+    function snowflake(points: THREE.Vector3[], loop: boolean, x_offset: number) {
         for (let iteration = 0; iteration != iteration_count; iteration++) {
             add_vertex(points[0]);
 
diff --git a/examples-testing/examples/webgl_buffergeometry_points.ts b/examples-testing/examples/webgl_buffergeometry_points.ts
index 4547d9d08..357c3ddd6 100644
--- a/examples-testing/examples/webgl_buffergeometry_points.ts
+++ b/examples-testing/examples/webgl_buffergeometry_points.ts
@@ -2,17 +2,17 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let points;
+let points: THREE.Points;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
diff --git a/examples-testing/examples/webgl_buffergeometry_points_interleaved.ts b/examples-testing/examples/webgl_buffergeometry_points_interleaved.ts
index 93eed992e..60e05bc0a 100644
--- a/examples-testing/examples/webgl_buffergeometry_points_interleaved.ts
+++ b/examples-testing/examples/webgl_buffergeometry_points_interleaved.ts
@@ -2,16 +2,16 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let points;
+let points: THREE.Points;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 5, 3500);
     camera.position.z = 2750;
diff --git a/examples-testing/examples/webgl_buffergeometry_rawshader.ts b/examples-testing/examples/webgl_buffergeometry_rawshader.ts
index 5bc113dc3..225e220ac 100644
--- a/examples-testing/examples/webgl_buffergeometry_rawshader.ts
+++ b/examples-testing/examples/webgl_buffergeometry_rawshader.ts
@@ -2,14 +2,14 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10);
     camera.position.z = 2;
@@ -53,8 +53,8 @@ function init() {
         uniforms: {
             time: { value: 1.0 },
         },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
         side: THREE.DoubleSide,
         transparent: true,
     });
@@ -86,7 +86,7 @@ function onWindowResize() {
 function animate() {
     const time = performance.now();
 
-    const object = scene.children[0];
+    const object = scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.RawShaderMaterial>;
 
     object.rotation.y = time * 0.0005;
     object.material.uniforms.time.value = time * 0.005;
diff --git a/examples-testing/examples/webgl_buffergeometry_selective_draw.ts b/examples-testing/examples/webgl_buffergeometry_selective_draw.ts
index d07176c51..ce51386ee 100644
--- a/examples-testing/examples/webgl_buffergeometry_selective_draw.ts
+++ b/examples-testing/examples/webgl_buffergeometry_selective_draw.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
-let geometry, mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let geometry: THREE.BufferGeometry, mesh: THREE.LineSegments;
 const numLat = 100;
 const numLng = 200;
 let numLinesCulled = 0;
@@ -23,10 +23,10 @@ function init() {
 
     addLines(1.0);
 
-    const hideLinesButton = document.getElementById('hideLines');
+    const hideLinesButton = document.getElementById('hideLines')!;
     hideLinesButton.addEventListener('click', hideLines);
 
-    const showAllLinesButton = document.getElementById('showAllLines');
+    const showAllLinesButton = document.getElementById('showAllLines')!;
     showAllLinesButton.addEventListener('click', showAllLines);
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -36,7 +36,7 @@ function init() {
     document.body.appendChild(renderer.domElement);
 }
 
-function addLines(radius) {
+function addLines(radius: number) {
     geometry = new THREE.BufferGeometry();
     const linePositions = new Float32Array(numLat * numLng * 3 * 2);
     const lineColors = new Float32Array(numLat * numLng * 3 * 2);
@@ -81,8 +81,8 @@ function addLines(radius) {
     geometry.computeBoundingSphere();
 
     const shaderMaterial = new THREE.ShaderMaterial({
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
     });
 
     mesh = new THREE.LineSegments(geometry, shaderMaterial);
@@ -98,7 +98,7 @@ function updateCount() {
         ' lines, ' +
         numLinesCulled +
         ' culled (<a target="_blank" href="http://callum.com">author</a>)';
-    document.getElementById('title').innerHTML = str.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
+    document.getElementById('title')!.innerHTML = str.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
 }
 
 function hideLines() {
diff --git a/examples-testing/examples/webgl_buffergeometry_uint.ts b/examples-testing/examples/webgl_buffergeometry_uint.ts
index 0b8df6ec7..dbb23e05e 100644
--- a/examples-testing/examples/webgl_buffergeometry_uint.ts
+++ b/examples-testing/examples/webgl_buffergeometry_uint.ts
@@ -2,16 +2,16 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh;
+let mesh: THREE.Mesh;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
diff --git a/examples-testing/examples/webgl_camera.ts b/examples-testing/examples/webgl_camera.ts
index f3d663603..4235f508f 100644
--- a/examples-testing/examples/webgl_camera.ts
+++ b/examples-testing/examples/webgl_camera.ts
@@ -6,11 +6,11 @@ let SCREEN_WIDTH = window.innerWidth;
 let SCREEN_HEIGHT = window.innerHeight;
 let aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
 
-let container, stats;
-let camera, scene, renderer, mesh;
-let cameraRig, activeCamera, activeHelper;
-let cameraPerspective, cameraOrtho;
-let cameraPerspectiveHelper, cameraOrthoHelper;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mesh: THREE.Mesh;
+let cameraRig: THREE.Group, activeCamera: THREE.Camera, activeHelper: THREE.CameraHelper;
+let cameraPerspective: THREE.PerspectiveCamera, cameraOrtho: THREE.OrthographicCamera;
+let cameraPerspectiveHelper: THREE.CameraHelper, cameraOrthoHelper: THREE.CameraHelper;
 const frustumSize = 600;
 
 init();
@@ -122,7 +122,7 @@ function init() {
 
 //
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     switch (event.keyCode) {
         case 79 /*O*/:
             activeCamera = cameraOrtho;
diff --git a/examples-testing/examples/webgl_camera_array.ts b/examples-testing/examples/webgl_camera_array.ts
index 8b10e27cb..11295c5fd 100644
--- a/examples-testing/examples/webgl_camera_array.ts
+++ b/examples-testing/examples/webgl_camera_array.ts
@@ -1,7 +1,7 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
-let mesh;
+let camera: THREE.ArrayCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mesh: THREE.Mesh;
 const AMOUNT = 6;
 
 init();
@@ -86,7 +86,7 @@ function onWindowResize() {
         for (let x = 0; x < AMOUNT; x++) {
             const subcamera = camera.cameras[AMOUNT * y + x];
 
-            subcamera.viewport.set(Math.floor(x * WIDTH), Math.floor(y * HEIGHT), Math.ceil(WIDTH), Math.ceil(HEIGHT));
+            subcamera.viewport!.set(Math.floor(x * WIDTH), Math.floor(y * HEIGHT), Math.ceil(WIDTH), Math.ceil(HEIGHT));
 
             subcamera.aspect = ASPECT_RATIO;
             subcamera.updateProjectionMatrix();
diff --git a/examples-testing/examples/webgl_camera_logarithmicdepthbuffer.ts b/examples-testing/examples/webgl_camera_logarithmicdepthbuffer.ts
index f1d440004..7f149db11 100644
--- a/examples-testing/examples/webgl_camera_logarithmicdepthbuffer.ts
+++ b/examples-testing/examples/webgl_camera_logarithmicdepthbuffer.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three';
 
-import { FontLoader } from 'three/addons/loaders/FontLoader.js';
+import { Font, FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
 import Stats from 'three/addons/libs/stats.module.js';
@@ -17,8 +17,16 @@ let zoompos = -100,
     minzoomspeed = 0.015;
 let zoomspeed = minzoomspeed;
 
-let container, border, stats;
-const objects = {};
+let container: HTMLElement, border: HTMLElement, stats: Stats;
+
+interface ObjectView {
+    container: HTMLElement;
+    renderer: THREE.WebGLRenderer;
+    scene: THREE.Scene;
+    camera: THREE.PerspectiveCamera;
+}
+
+const objects: { normal?: ObjectView; logzbuf?: ObjectView } = {};
 
 // Generate a number of text labels, from 1m in size up to 100,000,000 light years
 // Try to use some descriptive real-world examples of objects at each scale
@@ -44,7 +52,7 @@ const labeldata = [
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     const loader = new FontLoader();
     loader.load('fonts/helvetiker_regular.typeface.json', function (font) {
@@ -61,7 +69,7 @@ function init() {
     container.appendChild(stats.dom);
 
     // Resize border allows the user to easily compare effects of logarithmic depth buffer over the whole scene
-    border = document.getElementById('renderer_border');
+    border = document.getElementById('renderer_border')!;
     border.addEventListener('pointerdown', onBorderPointerDown);
 
     window.addEventListener('mousemove', onMouseMove);
@@ -69,8 +77,8 @@ function init() {
     window.addEventListener('wheel', onMouseWheel);
 }
 
-function initView(scene, name, logDepthBuf) {
-    const framecontainer = document.getElementById('container_' + name);
+function initView(scene: THREE.Scene, name: string, logDepthBuf: boolean) {
+    const framecontainer = document.getElementById('container_' + name)!;
 
     const camera = new THREE.PerspectiveCamera(50, (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT, NEAR, FAR);
     scene.add(camera);
@@ -85,7 +93,7 @@ function initView(scene, name, logDepthBuf) {
     return { container: framecontainer, renderer: renderer, scene: scene, camera: camera };
 }
 
-function initScene(font) {
+function initScene(font: Font) {
     const scene = new THREE.Scene();
 
     scene.add(new THREE.AmbientLight(0x777777));
@@ -94,7 +102,7 @@ function initScene(font) {
     light.position.set(100, 100, 100);
     scene.add(light);
 
-    const materialargs = {
+    const materialargs: { color: THREE.ColorRepresentation; specular: number; shininess: number; emissive: number } = {
         color: 0xffffff,
         specular: 0x050505,
         shininess: 50,
@@ -115,7 +123,7 @@ function initScene(font) {
         labelgeo.computeBoundingSphere();
 
         // center text
-        labelgeo.translate(-labelgeo.boundingSphere.radius, 0, 0);
+        labelgeo.translate(-labelgeo.boundingSphere!.radius, 0, 0);
 
         materialargs.color = new THREE.Color().setHSL(Math.random(), 0.5, 0.5);
 
@@ -148,16 +156,16 @@ function updateRendererSizes() {
 
     screensplit_right = 1 - screensplit;
 
-    objects.normal.renderer.setSize(screensplit * SCREEN_WIDTH, SCREEN_HEIGHT);
-    objects.normal.camera.aspect = (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT;
-    objects.normal.camera.updateProjectionMatrix();
-    objects.normal.camera.setViewOffset(SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT);
-    objects.normal.container.style.width = screensplit * 100 + '%';
+    objects.normal!.renderer.setSize(screensplit * SCREEN_WIDTH, SCREEN_HEIGHT);
+    objects.normal!.camera.aspect = (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT;
+    objects.normal!.camera.updateProjectionMatrix();
+    objects.normal!.camera.setViewOffset(SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT);
+    objects.normal!.container.style.width = screensplit * 100 + '%';
 
-    objects.logzbuf.renderer.setSize(screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT);
-    objects.logzbuf.camera.aspect = (screensplit_right * SCREEN_WIDTH) / SCREEN_HEIGHT;
-    objects.logzbuf.camera.updateProjectionMatrix();
-    objects.logzbuf.camera.setViewOffset(
+    objects.logzbuf!.renderer.setSize(screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT);
+    objects.logzbuf!.camera.aspect = (screensplit_right * SCREEN_WIDTH) / SCREEN_HEIGHT;
+    objects.logzbuf!.camera.updateProjectionMatrix();
+    objects.logzbuf!.camera.setViewOffset(
         SCREEN_WIDTH,
         SCREEN_HEIGHT,
         SCREEN_WIDTH * screensplit,
@@ -165,7 +173,7 @@ function updateRendererSizes() {
         SCREEN_WIDTH * screensplit_right,
         SCREEN_HEIGHT,
     );
-    objects.logzbuf.container.style.width = screensplit_right * 100 + '%';
+    objects.logzbuf!.container.style.width = screensplit_right * 100 + '%';
 
     border.style.left = screensplit * 100 + '%';
 }
@@ -193,22 +201,22 @@ function render() {
     zoompos += zoomspeed;
     zoomspeed *= damping;
 
-    objects.normal.camera.position.x = Math.sin(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
-    objects.normal.camera.position.y = Math.sin(0.25 * Math.PI * (mouse[1] - 0.5)) * zoom;
-    objects.normal.camera.position.z = Math.cos(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
-    objects.normal.camera.lookAt(objects.normal.scene.position);
+    objects.normal!.camera.position.x = Math.sin(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
+    objects.normal!.camera.position.y = Math.sin(0.25 * Math.PI * (mouse[1] - 0.5)) * zoom;
+    objects.normal!.camera.position.z = Math.cos(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
+    objects.normal!.camera.lookAt(objects.normal!.scene.position);
 
     // Clone camera settings across both scenes
-    objects.logzbuf.camera.position.copy(objects.normal.camera.position);
-    objects.logzbuf.camera.quaternion.copy(objects.normal.camera.quaternion);
+    objects.logzbuf!.camera.position.copy(objects.normal!.camera.position);
+    objects.logzbuf!.camera.quaternion.copy(objects.normal!.camera.quaternion);
 
     // Update renderer sizes if the split has changed
     if (screensplit_right != 1 - screensplit) {
         updateRendererSizes();
     }
 
-    objects.normal.renderer.render(objects.normal.scene, objects.normal.camera);
-    objects.logzbuf.renderer.render(objects.logzbuf.scene, objects.logzbuf.camera);
+    objects.normal!.renderer.render(objects.normal!.scene, objects.normal!.camera);
+    objects.logzbuf!.renderer.render(objects.logzbuf!.scene, objects.logzbuf!.camera);
 
     stats.update();
 }
@@ -223,7 +231,7 @@ function onBorderPointerDown() {
     window.addEventListener('pointerup', onBorderPointerUp);
 }
 
-function onBorderPointerMove(ev) {
+function onBorderPointerMove(ev: PointerEvent) {
     screensplit = Math.max(0, Math.min(1, ev.clientX / window.innerWidth));
 }
 
@@ -232,12 +240,12 @@ function onBorderPointerUp() {
     window.removeEventListener('pointerup', onBorderPointerUp);
 }
 
-function onMouseMove(ev) {
+function onMouseMove(ev: MouseEvent) {
     mouse[0] = ev.clientX / window.innerWidth;
     mouse[1] = ev.clientY / window.innerHeight;
 }
 
-function onMouseWheel(ev) {
+function onMouseWheel(ev: WheelEvent) {
     const amount = ev.deltaY;
     if (amount === 0) return;
     const dir = amount / Math.abs(amount);
diff --git a/examples-testing/examples/webgl_clipculldistance.ts b/examples-testing/examples/webgl_clipculldistance.ts
index a5fb54d47..0165880a3 100644
--- a/examples-testing/examples/webgl_clipculldistance.ts
+++ b/examples-testing/examples/webgl_clipculldistance.ts
@@ -2,9 +2,14 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, controls, clock, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera,
+    controls: OrbitControls,
+    clock: THREE.Clock,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats;
 
-let material;
+let material: THREE.ShaderMaterial;
 
 init();
 
@@ -25,7 +30,7 @@ function init() {
     document.body.appendChild(renderer.domElement);
 
     if (renderer.extensions.has('WEBGL_clip_cull_distance') === false) {
-        document.getElementById('notSupported').style.display = '';
+        document.getElementById('notSupported')!.style.display = '';
         return;
     }
 
@@ -69,8 +74,8 @@ function init() {
         uniforms: {
             time: { value: 1.0 },
         },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
         side: THREE.DoubleSide,
         transparent: true,
         vertexColors: true,
diff --git a/examples-testing/examples/webgl_clipping.ts b/examples-testing/examples/webgl_clipping.ts
index cde10c7d1..6ab3ba65c 100644
--- a/examples-testing/examples/webgl_clipping.ts
+++ b/examples-testing/examples/webgl_clipping.ts
@@ -5,7 +5,12 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, startTime, object, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    startTime: number,
+    object: THREE.Mesh,
+    stats: Stats;
 
 init();
 
@@ -93,8 +98,8 @@ function init() {
 
     // ***** Clipping setup (renderer): *****
     const globalPlanes = [globalPlane],
-        Empty = Object.freeze([]);
-    renderer.clippingPlanes = Empty; // GUI sets it to globalPlanes
+        Empty = Object.freeze<THREE.Plane[]>([]);
+    renderer.clippingPlanes = Empty as THREE.Plane[]; // GUI sets it to globalPlanes
     renderer.localClippingEnabled = true;
 
     // Stats
@@ -143,7 +148,7 @@ function init() {
                 return renderer.clippingPlanes !== Empty;
             },
             set Enabled(v) {
-                renderer.clippingPlanes = v ? globalPlanes : Empty;
+                renderer.clippingPlanes = v ? globalPlanes : (Empty as THREE.Plane[]);
             },
 
             get Plane() {
diff --git a/examples-testing/examples/webgl_clipping_advanced.ts b/examples-testing/examples/webgl_clipping_advanced.ts
index f65f00043..988b56d80 100644
--- a/examples-testing/examples/webgl_clipping_advanced.ts
+++ b/examples-testing/examples/webgl_clipping_advanced.ts
@@ -5,7 +5,7 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-function planesFromMesh(vertices, indices) {
+function planesFromMesh(vertices: THREE.Vector3[], indices: number[]) {
     // creates a clipping volume from a convex triangular mesh
     // specified by the arrays 'vertices' and 'indices'
 
@@ -23,23 +23,23 @@ function planesFromMesh(vertices, indices) {
     return result;
 }
 
-function createPlanes(n) {
+function createPlanes(n: number) {
     // creates an array of n uninitialized plane objects
 
-    const result = new Array(n);
+    const result = new Array<THREE.Plane>(n);
 
     for (let i = 0; i !== n; ++i) result[i] = new THREE.Plane();
 
     return result;
 }
 
-function assignTransformedPlanes(planesOut, planesIn, matrix) {
+function assignTransformedPlanes(planesOut: THREE.Plane[], planesIn: THREE.Plane[], matrix: THREE.Matrix4) {
     // sets an array of existing planes to transformed 'planesIn'
 
     for (let i = 0, n = planesIn.length; i !== n; ++i) planesOut[i].copy(planesIn[i]).applyMatrix4(matrix);
 }
 
-function cylindricalPlanes(n, innerRadius) {
+function cylindricalPlanes(n: number, innerRadius: number) {
     const result = createPlanes(n);
 
     for (let i = 0; i !== n; ++i) {
@@ -62,7 +62,7 @@ const planeToMatrix = (function () {
         yAxis = new THREE.Vector3(),
         trans = new THREE.Vector3();
 
-    return function planeToMatrix(plane) {
+    return function planeToMatrix(plane: THREE.Plane) {
         const zAxis = plane.normal,
             matrix = new THREE.Matrix4();
 
@@ -111,9 +111,17 @@ const Vertices = [
     Planes = planesFromMesh(Vertices, Indices),
     PlaneMatrices = Planes.map(planeToMatrix),
     GlobalClippingPlanes = cylindricalPlanes(5, 2.5),
-    Empty = Object.freeze([]);
-
-let camera, scene, renderer, startTime, stats, object, clipMaterial, volumeVisualization, globalClippingPlanes;
+    Empty = Object.freeze<THREE.Plane[]>([]);
+
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    startTime: number,
+    stats: Stats,
+    object: THREE.InstancedMesh,
+    clipMaterial: THREE.MeshPhongMaterial,
+    volumeVisualization: THREE.Group,
+    globalClippingPlanes: THREE.Plane[];
 
 function init() {
     camera = new THREE.PerspectiveCamera(36, window.innerWidth / window.innerHeight, 0.25, 16);
@@ -196,7 +204,7 @@ function init() {
 
             // clip to the others to show the volume (wildly
             // intersecting transparent planes look bad)
-            clippingPlanes: clipMaterial.clippingPlanes.filter(function (_, j) {
+            clippingPlanes: clipMaterial.clippingPlanes!.filter(function (_, j) {
                 return j !== i;
             }),
 
@@ -236,7 +244,7 @@ function init() {
     container.appendChild(renderer.domElement);
     // Clipping setup:
     globalClippingPlanes = createPlanes(GlobalClippingPlanes.length);
-    renderer.clippingPlanes = Empty;
+    renderer.clippingPlanes = Empty as THREE.Plane[];
     renderer.localClippingEnabled = true;
 
     window.addEventListener('resize', onWindowResize);
@@ -292,7 +300,7 @@ function init() {
                 return renderer.clippingPlanes !== Empty;
             },
             set Enabled(v) {
-                renderer.clippingPlanes = v ? globalClippingPlanes : Empty;
+                renderer.clippingPlanes = v ? globalClippingPlanes : (Empty as THREE.Plane[]);
             },
         },
         'Enabled',
@@ -310,12 +318,12 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function setObjectWorldMatrix(object, matrix) {
+function setObjectWorldMatrix(object: THREE.Object3D, matrix: THREE.Matrix4) {
     // set the orientation of an object based on a world matrix
 
     const parent = object.parent;
     scene.updateMatrixWorld();
-    object.matrix.copy(parent.matrixWorld).invert();
+    object.matrix.copy(parent!.matrixWorld).invert();
     object.applyMatrix4(matrix);
 }
 
@@ -336,7 +344,7 @@ function animate() {
     const bouncy = Math.cos(time * 0.5) * 0.5 + 0.7;
     transform.multiply(tmpMatrix.makeScale(bouncy, bouncy, bouncy));
 
-    assignTransformedPlanes(clipMaterial.clippingPlanes, Planes, transform);
+    assignTransformedPlanes(clipMaterial.clippingPlanes!, Planes, transform);
 
     const planeMeshes = volumeVisualization.children;
 
diff --git a/examples-testing/examples/webgl_clipping_intersection.ts b/examples-testing/examples/webgl_clipping_intersection.ts
index 5f45e45df..cb3cbdf2e 100644
--- a/examples-testing/examples/webgl_clipping_intersection.ts
+++ b/examples-testing/examples/webgl_clipping_intersection.ts
@@ -4,7 +4,7 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const params = {
     clipIntersection: true,
@@ -80,8 +80,8 @@ function init() {
 
     gui.add(params, 'alphaToCoverage').onChange(function (value) {
         group.children.forEach(c => {
-            c.material.alphaToCoverage = Boolean(value);
-            c.material.needsUpdate = true;
+            (c as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.alphaToCoverage = Boolean(value);
+            (c as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.needsUpdate = true;
         });
 
         render();
@@ -93,7 +93,7 @@ function init() {
             const children = group.children;
 
             for (let i = 0; i < children.length; i++) {
-                children[i].material.clipIntersection = value;
+                ((children[i] as THREE.Mesh).material as THREE.Material).clipIntersection = value;
             }
 
             render();
diff --git a/examples-testing/examples/webgl_clipping_stencil.ts b/examples-testing/examples/webgl_clipping_stencil.ts
index ecb6b42b8..6efdbf5a6 100644
--- a/examples-testing/examples/webgl_clipping_stencil.ts
+++ b/examples-testing/examples/webgl_clipping_stencil.ts
@@ -3,9 +3,13 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, object, stats;
-let planes, planeObjects, planeHelpers;
-let clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    object: THREE.Group,
+    stats: Stats;
+let planes: THREE.Plane[], planeObjects: THREE.Mesh[], planeHelpers: THREE.PlaneHelper[];
+let clock: THREE.Clock;
 
 const params = {
     animate: true,
@@ -28,7 +32,7 @@ const params = {
 
 init();
 
-function createPlaneStencilGroup(geometry, plane, renderOrder) {
+function createPlaneStencilGroup(geometry: THREE.TorusKnotGeometry, plane: THREE.Plane, renderOrder: number) {
     const group = new THREE.Group();
     const baseMat = new THREE.MeshBasicMaterial();
     baseMat.depthWrite = false;
diff --git a/examples-testing/examples/webgl_custom_attributes.ts b/examples-testing/examples/webgl_custom_attributes.ts
index 0dc897748..431876d68 100644
--- a/examples-testing/examples/webgl_custom_attributes.ts
+++ b/examples-testing/examples/webgl_custom_attributes.ts
@@ -2,11 +2,16 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let sphere, uniforms;
+let sphere: THREE.Mesh,
+    uniforms: {
+        amplitude: THREE.IUniform<number>;
+        color: THREE.IUniform<THREE.Color>;
+        colorTexture: THREE.IUniform<THREE.Texture>;
+    };
 
-let displacement, noise;
+let displacement: Float32Array<ArrayBuffer>, noise: Float32Array;
 
 init();
 
@@ -27,8 +32,8 @@ function init() {
 
     const shaderMaterial = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
     });
 
     const radius = 50,
@@ -54,7 +59,7 @@ function init() {
     renderer.setSize(window.innerWidth, window.innerHeight);
     renderer.setAnimationLoop(animate);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_custom_attributes_lines.ts b/examples-testing/examples/webgl_custom_attributes_lines.ts
index 3e2454e92..d89a77d53 100644
--- a/examples-testing/examples/webgl_custom_attributes_lines.ts
+++ b/examples-testing/examples/webgl_custom_attributes_lines.ts
@@ -1,20 +1,25 @@
 import * as THREE from 'three';
 
-import { FontLoader } from 'three/addons/loaders/FontLoader.js';
+import { Font, FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let line, uniforms;
+let line: THREE.Line,
+    uniforms: {
+        amplitude: THREE.IUniform<number>;
+        opacity: THREE.IUniform<number>;
+        color: THREE.IUniform<THREE.Color>;
+    };
 
 const loader = new FontLoader();
 loader.load('fonts/helvetiker_bold.typeface.json', function (font) {
     init(font);
 });
 
-function init(font) {
+function init(font: Font) {
     camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 400;
 
@@ -29,8 +34,8 @@ function init(font) {
 
     const shaderMaterial = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
         blending: THREE.AdditiveBlending,
         depthTest: false,
         transparent: true,
@@ -75,7 +80,7 @@ function init(font) {
     renderer.setSize(window.innerWidth, window.innerHeight);
     renderer.setAnimationLoop(animate);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_custom_attributes_points.ts b/examples-testing/examples/webgl_custom_attributes_points.ts
index ae112980a..9035134c7 100644
--- a/examples-testing/examples/webgl_custom_attributes_points.ts
+++ b/examples-testing/examples/webgl_custom_attributes_points.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let sphere;
+let sphere: THREE.Points;
 
 const WIDTH = window.innerWidth;
 const HEIGHT = window.innerHeight;
@@ -56,8 +56,8 @@ function init() {
             color: { value: new THREE.Color(0xffffff) },
             pointTexture: { value: new THREE.TextureLoader().load('textures/sprites/spark1.png') },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
 
         blending: THREE.AdditiveBlending,
         depthTest: false,
@@ -76,7 +76,7 @@ function init() {
     renderer.setSize(WIDTH, HEIGHT);
     renderer.setAnimationLoop(animate);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_custom_attributes_points2.ts b/examples-testing/examples/webgl_custom_attributes_points2.ts
index edd158fa1..6f58c70ad 100644
--- a/examples-testing/examples/webgl_custom_attributes_points2.ts
+++ b/examples-testing/examples/webgl_custom_attributes_points2.ts
@@ -4,8 +4,8 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let renderer, scene, camera, stats;
-let sphere, length1;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
+let sphere: THREE.Points, length1: number;
 
 const WIDTH = window.innerWidth;
 const HEIGHT = window.innerHeight;
@@ -22,8 +22,8 @@ function init() {
         segments = 68,
         rings = 38;
 
-    let sphereGeometry = new THREE.SphereGeometry(radius, segments, rings);
-    let boxGeometry = new THREE.BoxGeometry(0.8 * radius, 0.8 * radius, 0.8 * radius, 10, 10, 10);
+    let sphereGeometry: THREE.BufferGeometry = new THREE.SphereGeometry(radius, segments, rings);
+    let boxGeometry: THREE.BufferGeometry = new THREE.BoxGeometry(0.8 * radius, 0.8 * radius, 0.8 * radius, 10, 10, 10);
 
     // if normal and uv attributes are not removed, mergeVertices() can't consolidate identical vertices with different normal/uv data
 
@@ -39,8 +39,8 @@ function init() {
     const combinedGeometry = BufferGeometryUtils.mergeGeometries([sphereGeometry, boxGeometry]);
     const positionAttribute = combinedGeometry.getAttribute('position');
 
-    const colors = [];
-    const sizes = [];
+    const colors: number[] = [];
+    const sizes: number[] = [];
 
     const color = new THREE.Color();
     const vertex = new THREE.Vector3();
@@ -77,8 +77,8 @@ function init() {
             color: { value: new THREE.Color(0xffffff) },
             pointTexture: { value: texture },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
         transparent: true,
     });
 
@@ -94,7 +94,7 @@ function init() {
     renderer.setSize(WIDTH, HEIGHT);
     renderer.setAnimationLoop(animate);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
@@ -150,7 +150,7 @@ function sortPoints() {
         sortArray.push([vector.z, i]);
     }
 
-    function numericalSort(a, b) {
+    function numericalSort(a: number[], b: number[]) {
         return b[0] - a[0];
     }
 
@@ -162,7 +162,7 @@ function sortPoints() {
         indices[i] = sortArray[i][1];
     }
 
-    geometry.index.needsUpdate = true;
+    geometry.index!.needsUpdate = true;
 }
 
 function animate() {
diff --git a/examples-testing/examples/webgl_custom_attributes_points3.ts b/examples-testing/examples/webgl_custom_attributes_points3.ts
index 1bca8ccd4..66f12591f 100644
--- a/examples-testing/examples/webgl_custom_attributes_points3.ts
+++ b/examples-testing/examples/webgl_custom_attributes_points3.ts
@@ -4,11 +4,11 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let object;
+let object: THREE.Points;
 
-let vertices1;
+let vertices1: number;
 
 const WIDTH = window.innerWidth;
 const HEIGHT = window.innerHeight;
@@ -47,7 +47,7 @@ function init() {
 
     radius = 200;
 
-    let boxGeometry1 = new THREE.BoxGeometry(radius, 0.1 * radius, 0.1 * radius, 50, 5, 5);
+    let boxGeometry1: THREE.BufferGeometry = new THREE.BoxGeometry(radius, 0.1 * radius, 0.1 * radius, 50, 5, 5);
 
     // if normal and uv attributes are not removed, mergeVertices() can't consolidate identical vertices with different normal/uv data
 
@@ -62,7 +62,7 @@ function init() {
     const quaternion = new THREE.Quaternion();
     const scale = new THREE.Vector3(1, 1, 1);
 
-    function addGeo(geo, x, y, z, ry) {
+    function addGeo(geo: THREE.BufferGeometry, x: number, y: number, z: number, ry: number) {
         position.set(x, y, z);
         rotation.set(0, ry, 0);
 
@@ -93,7 +93,7 @@ function init() {
 
     // corner edges
 
-    let boxGeometry2 = new THREE.BoxGeometry(0.1 * radius, radius * 1.2, 0.1 * radius, 5, 60, 5);
+    let boxGeometry2: THREE.BufferGeometry = new THREE.BoxGeometry(0.1 * radius, radius * 1.2, 0.1 * radius, 5, 60, 5);
 
     boxGeometry2.deleteAttribute('normal');
     boxGeometry2.deleteAttribute('uv');
@@ -107,8 +107,8 @@ function init() {
 
     const positionAttribute = new THREE.Float32BufferAttribute(vertices, 3);
 
-    const colors = [];
-    const sizes = [];
+    const colors: number[] = [];
+    const sizes: number[] = [];
 
     const color = new THREE.Color();
 
@@ -141,8 +141,8 @@ function init() {
             color: { value: new THREE.Color(0xffffff) },
             pointTexture: { value: texture },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
     });
 
     //
@@ -157,7 +157,7 @@ function init() {
     renderer.setSize(WIDTH, HEIGHT);
     renderer.setAnimationLoop(animate);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_decals.ts b/examples-testing/examples/webgl_decals.ts
index 8f77c30fc..acc5b2193 100644
--- a/examples-testing/examples/webgl_decals.ts
+++ b/examples-testing/examples/webgl_decals.ts
@@ -7,12 +7,12 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';
 
-const container = document.getElementById('container');
+const container = document.getElementById('container')!;
 
-let renderer, scene, camera, stats;
-let mesh;
-let raycaster;
-let line;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
+let mesh: THREE.Mesh;
+let raycaster: THREE.Raycaster;
+let line: THREE.Line;
 
 const intersection = {
     intersects: false,
@@ -20,7 +20,7 @@ const intersection = {
     normal: new THREE.Vector3(),
 };
 const mouse = new THREE.Vector2();
-const intersects = [];
+const intersects: THREE.Intersection[] = [];
 
 const textureLoader = new THREE.TextureLoader();
 const decalDiffuse = textureLoader.load('textures/decal/decal-diffuse.png');
@@ -41,8 +41,8 @@ const decalMaterial = new THREE.MeshPhongMaterial({
     wireframe: false,
 });
 
-const decals = [];
-let mouseHelper;
+const decals: THREE.Mesh[] = [];
+let mouseHelper: THREE.Mesh;
 const position = new THREE.Vector3();
 const orientation = new THREE.Euler();
 const size = new THREE.Vector3(10, 10, 10);
@@ -123,13 +123,13 @@ function init() {
 
     window.addEventListener('pointermove', onPointerMove);
 
-    function onPointerMove(event) {
+    function onPointerMove(event: PointerEvent) {
         if (event.isPrimary) {
             checkIntersection(event.clientX, event.clientY);
         }
     }
 
-    function checkIntersection(x, y) {
+    function checkIntersection(x: number, y: number) {
         if (mesh === undefined) return;
 
         mouse.x = (x / window.innerWidth) * 2 - 1;
@@ -145,12 +145,12 @@ function init() {
 
             const normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
 
-            const n = intersects[0].face.normal.clone();
+            const n = intersects[0].face!.normal.clone();
             n.applyNormalMatrix(normalMatrix);
             n.multiplyScalar(10);
             n.add(intersects[0].point);
 
-            intersection.normal.copy(intersects[0].face.normal);
+            intersection.normal.copy(intersects[0].face!.normal);
             mouseHelper.lookAt(n);
 
             const positions = line.geometry.attributes.position;
@@ -184,7 +184,7 @@ function loadLeePerrySmith() {
     const loader = new GLTFLoader();
 
     loader.load('models/gltf/LeePerrySmith/LeePerrySmith.glb', function (gltf) {
-        mesh = gltf.scene.children[0];
+        mesh = gltf.scene.children[0] as THREE.Mesh;
         mesh.material = new THREE.MeshPhongMaterial({
             specular: 0x111111,
             map: map,
diff --git a/examples-testing/examples/webgl_effects_anaglyph.ts b/examples-testing/examples/webgl_effects_anaglyph.ts
index 8415973df..d6a7d4c54 100644
--- a/examples-testing/examples/webgl_effects_anaglyph.ts
+++ b/examples-testing/examples/webgl_effects_anaglyph.ts
@@ -2,9 +2,13 @@ import * as THREE from 'three';
 
 import { AnaglyphEffect } from 'three/addons/effects/AnaglyphEffect.js';
 
-let container, camera, scene, renderer, effect;
+let container: HTMLDivElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    effect: AnaglyphEffect;
 
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
 let mouseX = 0;
 let mouseY = 0;
@@ -84,7 +88,7 @@ function onWindowResize() {
     effect.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) / 100;
     mouseY = (event.clientY - windowHalfY) / 100;
 }
diff --git a/examples-testing/examples/webgl_effects_ascii.ts b/examples-testing/examples/webgl_effects_ascii.ts
index a412bb79e..751102d76 100644
--- a/examples-testing/examples/webgl_effects_ascii.ts
+++ b/examples-testing/examples/webgl_effects_ascii.ts
@@ -3,9 +3,13 @@ import * as THREE from 'three';
 import { AsciiEffect } from 'three/addons/effects/AsciiEffect.js';
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 
-let camera, controls, scene, renderer, effect;
+let camera: THREE.PerspectiveCamera,
+    controls: TrackballControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    effect: AsciiEffect;
 
-let sphere, plane;
+let sphere: THREE.Mesh, plane: THREE.Mesh;
 
 const start = Date.now();
 
diff --git a/examples-testing/examples/webgl_effects_parallaxbarrier.ts b/examples-testing/examples/webgl_effects_parallaxbarrier.ts
index 90c867973..e03cb5d7b 100644
--- a/examples-testing/examples/webgl_effects_parallaxbarrier.ts
+++ b/examples-testing/examples/webgl_effects_parallaxbarrier.ts
@@ -2,9 +2,13 @@ import * as THREE from 'three';
 
 import { ParallaxBarrierEffect } from 'three/addons/effects/ParallaxBarrierEffect.js';
 
-let container, camera, scene, renderer, effect;
+let container: HTMLDivElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    effect: ParallaxBarrierEffect;
 
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
 let mouseX = 0;
 let mouseY = 0;
@@ -84,7 +88,7 @@ function onWindowResize() {
     effect.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) / 100;
     mouseY = (event.clientY - windowHalfY) / 100;
 }
diff --git a/examples-testing/examples/webgl_effects_stereo.ts b/examples-testing/examples/webgl_effects_stereo.ts
index dd2f61f91..6dab1b6ed 100644
--- a/examples-testing/examples/webgl_effects_stereo.ts
+++ b/examples-testing/examples/webgl_effects_stereo.ts
@@ -2,9 +2,13 @@ import * as THREE from 'three';
 
 import { StereoEffect } from 'three/addons/effects/StereoEffect.js';
 
-let container, camera, scene, renderer, effect;
+let container: HTMLDivElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    effect: StereoEffect;
 
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
 let mouseX = 0,
     mouseY = 0;
@@ -73,7 +77,7 @@ function onWindowResize() {
     effect.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) * 10;
     mouseY = (event.clientY - windowHalfY) * 10;
 }
diff --git a/examples-testing/examples/webgl_framebuffer_texture.ts b/examples-testing/examples/webgl_framebuffer_texture.ts
index df4acc9d6..636f9db9c 100644
--- a/examples-testing/examples/webgl_framebuffer_texture.ts
+++ b/examples-testing/examples/webgl_framebuffer_texture.ts
@@ -3,10 +3,10 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';
 
-let camera, scene, renderer;
-let line, sprite, texture;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let line: THREE.Line, sprite: THREE.Sprite, texture: THREE.FramebufferTexture;
 
-let cameraOrtho, sceneOrtho;
+let cameraOrtho: THREE.OrthographicCamera, sceneOrtho: THREE.Scene;
 
 let offset = 0;
 
@@ -76,7 +76,7 @@ function init() {
 
     //
 
-    const selection = document.getElementById('selection');
+    const selection = document.getElementById('selection')!;
     const controls = new OrbitControls(camera, selection);
     controls.enablePan = false;
 
@@ -133,7 +133,7 @@ function animate() {
     renderer.render(sceneOrtho, cameraOrtho);
 }
 
-function updateColors(colorAttribute) {
+function updateColors(colorAttribute: THREE.BufferAttribute | THREE.InterleavedBufferAttribute) {
     const l = colorAttribute.count;
 
     for (let i = 0; i < l; i++) {
diff --git a/examples-testing/examples/webgl_furnace_test.ts b/examples-testing/examples/webgl_furnace_test.ts
index a81954176..46230b4a9 100644
--- a/examples-testing/examples/webgl_furnace_test.ts
+++ b/examples-testing/examples/webgl_furnace_test.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three';
 
-let scene, camera, renderer, radianceMap;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, radianceMap: THREE.Texture;
 
 const COLOR = 0xcccccc;
 
@@ -20,7 +20,8 @@ function init() {
 
     document.body.addEventListener('mouseover', function () {
         scene.traverse(function (child) {
-            if (child.isMesh) child.material.color.setHex(0xffffff);
+            if ((child as THREE.Mesh).isMesh)
+                ((child as THREE.Mesh).material as THREE.MeshStandardMaterial).color.setHex(0xffffff);
         });
 
         render();
@@ -28,7 +29,8 @@ function init() {
 
     document.body.addEventListener('mouseout', function () {
         scene.traverse(function (child) {
-            if (child.isMesh) child.material.color.setHex(0xccccff); // tinted for visibility
+            if ((child as THREE.Mesh).isMesh)
+                ((child as THREE.Mesh).material as THREE.MeshStandardMaterial).color.setHex(0xccccff); // tinted for visibility
         });
 
         render();
diff --git a/examples-testing/examples/webgl_geometries.ts b/examples-testing/examples/webgl_geometries.ts
index 0eb50120c..a81813486 100644
--- a/examples-testing/examples/webgl_geometries.ts
+++ b/examples-testing/examples/webgl_geometries.ts
@@ -5,7 +5,7 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';
 import { plane, klein, mobius } from 'three/addons/geometries/ParametricFunctions.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 
@@ -155,7 +155,7 @@ function render() {
     camera.lookAt(scene.position);
 
     scene.traverse(function (object) {
-        if (object.isMesh === true) {
+        if ((object as THREE.Mesh).isMesh === true) {
             object.rotation.x = timer * 5;
             object.rotation.y = timer * 2.5;
         }
diff --git a/examples-testing/examples/webgl_geometry_colors.ts b/examples-testing/examples/webgl_geometry_colors.ts
index 3166c03bc..d2c22418f 100644
--- a/examples-testing/examples/webgl_geometry_colors.ts
+++ b/examples-testing/examples/webgl_geometry_colors.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let mouseX = 0,
     mouseY = 0;
@@ -15,7 +15,7 @@ let windowHalfY = window.innerHeight / 2;
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 1800;
@@ -33,7 +33,7 @@ function init() {
     canvas.width = 128;
     canvas.height = 128;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     const gradient = context.createRadialGradient(
         canvas.width / 2,
         canvas.height / 2,
@@ -77,7 +77,8 @@ function init() {
     const geometry1 = new THREE.IcosahedronGeometry(radius, 1);
 
     const count = geometry1.attributes.position.count;
-    const arrayType = typeof Float16Array !== 'undefined' ? Float16Array : Float32Array;
+    // @ts-expect-error
+    const arrayType: THREE.TypedArrayConstructor = typeof Float16Array !== 'undefined' ? Float16Array : Float32Array;
     geometry1.setAttribute('color', new THREE.BufferAttribute(new arrayType(count * 3), 3));
 
     const geometry2 = geometry1.clone();
@@ -155,7 +156,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgl_geometry_colors_lookuptable.ts b/examples-testing/examples/webgl_geometry_colors_lookuptable.ts
index 6b0138529..c46e067e6 100644
--- a/examples-testing/examples/webgl_geometry_colors_lookuptable.ts
+++ b/examples-testing/examples/webgl_geometry_colors_lookuptable.ts
@@ -5,19 +5,19 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Lut } from 'three/addons/math/Lut.js';
 
-let container;
+let container: HTMLElement;
 
-let perpCamera, orthoCamera, renderer, lut;
+let perpCamera: THREE.PerspectiveCamera, orthoCamera: THREE.OrthographicCamera, renderer: THREE.WebGLRenderer, lut: Lut;
 
-let mesh, sprite;
-let scene, uiScene;
+let mesh: THREE.Mesh, sprite: THREE.Sprite;
+let scene: THREE.Scene, uiScene: THREE.Scene;
 
-let params;
+let params: { colorMap: string };
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
     scene.background = new THREE.Color(0xffffff);
@@ -41,7 +41,7 @@ function init() {
             map: new THREE.CanvasTexture(lut.createCanvas()),
         }),
     );
-    sprite.material.map.colorSpace = THREE.SRGBColorSpace;
+    sprite.material.map!.colorSpace = THREE.SRGBColorSpace;
     sprite.scale.x = 0.125;
     uiScene.add(sprite);
 
@@ -142,7 +142,7 @@ function updateColors() {
 
     colors.needsUpdate = true;
 
-    const map = sprite.material.map;
+    const map = sprite.material.map as THREE.Texture<HTMLCanvasElement>;
     lut.updateCanvas(map.image);
     map.needsUpdate = true;
 }
diff --git a/examples-testing/examples/webgl_geometry_convex.ts b/examples-testing/examples/webgl_geometry_convex.ts
index 09516c070..fe9042217 100644
--- a/examples-testing/examples/webgl_geometry_convex.ts
+++ b/examples-testing/examples/webgl_geometry_convex.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let group, camera, scene, renderer;
+let group: THREE.Group, camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -54,7 +54,7 @@ function init() {
 
     // points
 
-    let dodecahedronGeometry = new THREE.DodecahedronGeometry(10);
+    let dodecahedronGeometry: THREE.BufferGeometry = new THREE.DodecahedronGeometry(10);
 
     // if normal and uv attributes are not removed, mergeVertices() can't consolidate identical vertices with different normal/uv data
 
diff --git a/examples-testing/examples/webgl_geometry_cube.ts b/examples-testing/examples/webgl_geometry_cube.ts
index 572601acb..136a31413 100644
--- a/examples-testing/examples/webgl_geometry_cube.ts
+++ b/examples-testing/examples/webgl_geometry_cube.ts
@@ -1,7 +1,7 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
-let mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mesh: THREE.Mesh;
 
 init();
 
diff --git a/examples-testing/examples/webgl_geometry_extrude_shapes.ts b/examples-testing/examples/webgl_geometry_extrude_shapes.ts
index a905c8ea3..00283d47e 100644
--- a/examples-testing/examples/webgl_geometry_extrude_shapes.ts
+++ b/examples-testing/examples/webgl_geometry_extrude_shapes.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: TrackballControls;
 
 init();
 
diff --git a/examples-testing/examples/webgl_geometry_extrude_splines.ts b/examples-testing/examples/webgl_geometry_extrude_splines.ts
index 8636812f7..90e2b7b06 100644
--- a/examples-testing/examples/webgl_geometry_extrude_splines.ts
+++ b/examples-testing/examples/webgl_geometry_extrude_splines.ts
@@ -6,9 +6,14 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import * as Curves from 'three/addons/curves/CurveExtras.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer, splineCamera, cameraHelper, cameraEye;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    splineCamera: THREE.PerspectiveCamera,
+    cameraHelper: THREE.CameraHelper,
+    cameraEye: THREE.Mesh;
 
 const direction = new THREE.Vector3();
 const binormal = new THREE.Vector3();
@@ -78,9 +83,18 @@ const splines = {
     SampleClosedSpline: sampleClosedSpline,
 };
 
-let parent, tubeGeometry, mesh;
-
-const params = {
+let parent: THREE.Object3D, tubeGeometry: THREE.TubeGeometry, mesh: THREE.Mesh;
+
+const params: {
+    spline: keyof typeof splines;
+    scale: number;
+    extrusionSegments: number;
+    radiusSegments: number;
+    closed: boolean;
+    animationView: boolean;
+    lookAhead: boolean;
+    cameraHelper: boolean;
+} = {
     spline: 'GrannyKnot',
     scale: 4,
     extrusionSegments: 100,
@@ -125,7 +139,7 @@ function setScale() {
     mesh.scale.set(params.scale, params.scale, params.scale);
 }
 
-function addGeometry(geometry) {
+function addGeometry(geometry: THREE.BufferGeometry) {
     // 3D shape
 
     mesh = new THREE.Mesh(geometry, material);
@@ -143,7 +157,7 @@ function animateCamera() {
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     // camera
 
@@ -202,7 +216,7 @@ function init() {
     const gui = new GUI({ width: 285 });
 
     const folderGeometry = gui.addFolder('Geometry');
-    folderGeometry.add(params, 'spline', Object.keys(splines)).onChange(function () {
+    folderGeometry.add(params, 'spline', Object.keys(splines) as (keyof typeof splines)[]).onChange(function () {
         addTube();
     });
     folderGeometry
diff --git a/examples-testing/examples/webgl_geometry_minecraft.ts b/examples-testing/examples/webgl_geometry_minecraft.ts
index 765aa1e49..b15665d8c 100644
--- a/examples-testing/examples/webgl_geometry_minecraft.ts
+++ b/examples-testing/examples/webgl_geometry_minecraft.ts
@@ -6,9 +6,9 @@ import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.j
 import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: FirstPersonControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const worldWidth = 128,
     worldDepth = 128;
@@ -21,7 +21,7 @@ const clock = new THREE.Clock();
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);
     camera.position.y = getY(worldHalfWidth, worldHalfDepth) * 100 + 100;
@@ -143,7 +143,7 @@ function onWindowResize() {
     controls.handleResize();
 }
 
-function generateHeight(width, height) {
+function generateHeight(width: number, height: number) {
     const data = [],
         perlin = new ImprovedNoise(),
         size = width * height,
@@ -166,7 +166,7 @@ function generateHeight(width, height) {
     return data;
 }
 
-function getY(x, z) {
+function getY(x: number, z: number) {
     return (data[x + z * worldWidth] * 0.15) | 0;
 }
 
diff --git a/examples-testing/examples/webgl_geometry_nurbs.ts b/examples-testing/examples/webgl_geometry_nurbs.ts
index ecd79c67e..74676e45c 100644
--- a/examples-testing/examples/webgl_geometry_nurbs.ts
+++ b/examples-testing/examples/webgl_geometry_nurbs.ts
@@ -7,10 +7,10 @@ import { NURBSSurface } from 'three/addons/curves/NURBSSurface.js';
 import { NURBSVolume } from 'three/addons/curves/NURBSVolume.js';
 import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
-let group;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let group: THREE.Group;
 
 let targetRotation = 0;
 let targetRotationOnPointerDown = 0;
@@ -78,7 +78,7 @@ function init() {
     group.add(nurbsLine);
 
     const nurbsControlPointsGeometry = new THREE.BufferGeometry();
-    nurbsControlPointsGeometry.setFromPoints(nurbsCurve.controlPoints);
+    nurbsControlPointsGeometry.setFromPoints(nurbsCurve.controlPoints as THREE.Vector3[]);
 
     const nurbsControlPointsMaterial = new THREE.LineBasicMaterial({
         color: 0x333333,
@@ -123,7 +123,7 @@ function init() {
         map.anisotropy = 16;
         map.colorSpace = THREE.SRGBColorSpace;
 
-        function getSurfacePoint(u, v, target) {
+        function getSurfacePoint(u: number, v: number, target: THREE.Vector3) {
             return nurbsSurface.getPoint(u, v, target);
         }
 
@@ -174,23 +174,23 @@ function init() {
         // we create evaluation functions for different surfaces with one of the three
         // parameter values (u, v, w) kept constant and create multiple THREE.Mesh
         // objects one for each surface
-        function getSurfacePointFront(u, v, target) {
+        function getSurfacePointFront(u: number, v: number, target: THREE.Vector3) {
             return nurbsVolume.getPoint(u, v, 0, target);
         }
 
-        function getSurfacePointMiddle(u, v, target) {
+        function getSurfacePointMiddle(u: number, v: number, target: THREE.Vector3) {
             return nurbsVolume.getPoint(u, v, 0.5, target);
         }
 
-        function getSurfacePointBack(u, v, target) {
+        function getSurfacePointBack(u: number, v: number, target: THREE.Vector3) {
             return nurbsVolume.getPoint(u, v, 1, target);
         }
 
-        function getSurfacePointTop(u, w, target) {
+        function getSurfacePointTop(u: number, w: number, target: THREE.Vector3) {
             return nurbsVolume.getPoint(u, 1, w, target);
         }
 
-        function getSurfacePointSide(v, w, target) {
+        function getSurfacePointSide(v: number, w: number, target: THREE.Vector3) {
             return nurbsVolume.getPoint(0, v, w, target);
         }
 
@@ -260,7 +260,7 @@ function onWindowResize() {
 
 //
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerXOnPointerDown = event.clientX - windowHalfX;
@@ -270,7 +270,7 @@ function onPointerDown(event) {
     document.addEventListener('pointerup', onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerX = event.clientX - windowHalfX;
@@ -278,7 +278,7 @@ function onPointerMove(event) {
     targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
 }
 
-function onPointerUp(event) {
+function onPointerUp(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     document.removeEventListener('pointermove', onPointerMove);
diff --git a/examples-testing/examples/webgl_geometry_shapes.ts b/examples-testing/examples/webgl_geometry_shapes.ts
index 0c25d8855..2042c3530 100644
--- a/examples-testing/examples/webgl_geometry_shapes.ts
+++ b/examples-testing/examples/webgl_geometry_shapes.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let group;
+let group: THREE.Group;
 
 let targetRotation = 0;
 let targetRotationOnPointerDown = 0;
@@ -45,11 +45,22 @@ function init() {
     texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
     texture.repeat.set(0.008, 0.008);
 
-    function addShape(shape, extrudeSettings, color, x, y, z, rx, ry, rz, s) {
+    function addShape(
+        shape: THREE.Shape,
+        extrudeSettings: THREE.ExtrudeGeometryOptions,
+        color: number,
+        x: number,
+        y: number,
+        z: number,
+        rx: number,
+        ry: number,
+        rz: number,
+        s: number,
+    ) {
         // flat shape with texture
         // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices
 
-        let geometry = new THREE.ShapeGeometry(shape);
+        let geometry: THREE.BufferGeometry = new THREE.ShapeGeometry(shape);
 
         let mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ side: THREE.DoubleSide, map: texture }));
         mesh.position.set(x, y, z - 175);
@@ -80,7 +91,17 @@ function init() {
         addLineShape(shape, color, x, y, z, rx, ry, rz, s);
     }
 
-    function addLineShape(shape, color, x, y, z, rx, ry, rz, s) {
+    function addLineShape(
+        shape: THREE.Path,
+        color: number,
+        x: number,
+        y: number,
+        z: number,
+        rx: number,
+        ry: number,
+        rz: number,
+        s: number,
+    ) {
         // lines
 
         shape.autoClose = true;
@@ -325,7 +346,7 @@ function onWindowResize() {
 
 //
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerXOnPointerDown = event.clientX - windowHalfX;
@@ -335,7 +356,7 @@ function onPointerDown(event) {
     document.addEventListener('pointerup', onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerX = event.clientX - windowHalfX;
@@ -343,7 +364,7 @@ function onPointerMove(event) {
     targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
 }
 
-function onPointerUp(event) {
+function onPointerUp(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     document.removeEventListener('pointermove', onPointerMove);
diff --git a/examples-testing/examples/webgl_geometry_teapot.ts b/examples-testing/examples/webgl_geometry_teapot.ts
index 2516d660c..0d7d5628f 100644
--- a/examples-testing/examples/webgl_geometry_teapot.ts
+++ b/examples-testing/examples/webgl_geometry_teapot.ts
@@ -5,22 +5,30 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 let cameraControls;
-let effectController;
+let effectController: {
+    newTess: number;
+    bottom: boolean;
+    lid: boolean;
+    body: boolean;
+    fitLid: boolean;
+    nonblinn: boolean;
+    newShading: string;
+};
 const teapotSize = 300;
-let ambientLight, light;
+let ambientLight: THREE.AmbientLight, light: THREE.DirectionalLight;
 
 let tess = -1; // force initialization
-let bBottom;
-let bLid;
-let bBody;
-let bFitLid;
-let bNonBlinn;
-let shading;
-
-let teapot, textureCube;
-const materials = {};
+let bBottom: boolean;
+let bLid: boolean;
+let bBody: boolean;
+let bFitLid: boolean;
+let bNonBlinn: boolean;
+let shading: string;
+
+let teapot: THREE.Mesh, textureCube: THREE.CubeTexture;
+const materials: Record<string, THREE.Material> = {};
 
 init();
 render();
diff --git a/examples-testing/examples/webgl_geometry_terrain.ts b/examples-testing/examples/webgl_geometry_terrain.ts
index 8b6ed84ea..22ec3f6a6 100644
--- a/examples-testing/examples/webgl_geometry_terrain.ts
+++ b/examples-testing/examples/webgl_geometry_terrain.ts
@@ -5,9 +5,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
 import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
 
-let container, stats;
-let camera, controls, scene, renderer;
-let mesh, texture;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, controls: FirstPersonControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mesh: THREE.Mesh, texture: THREE.CanvasTexture;
 
 const worldWidth = 256,
     worldDepth = 256;
@@ -16,7 +16,7 @@ const clock = new THREE.Clock();
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
 
@@ -73,7 +73,7 @@ function onWindowResize() {
     controls.handleResize();
 }
 
-function generateHeight(width, height) {
+function generateHeight(width: number, height: number) {
     let seed = Math.PI / 4;
     window.Math.random = function () {
         const x = Math.sin(seed++) * 10000;
@@ -100,7 +100,7 @@ function generateHeight(width, height) {
     return data;
 }
 
-function generateTexture(data, width, height) {
+function generateTexture(data: Uint8Array, width: number, height: number) {
     let context, image, imageData, shade;
 
     const vector3 = new THREE.Vector3(0, 0, 0);
@@ -112,7 +112,7 @@ function generateTexture(data, width, height) {
     canvas.width = width;
     canvas.height = height;
 
-    context = canvas.getContext('2d');
+    context = canvas.getContext('2d')!;
     context.fillStyle = '#000';
     context.fillRect(0, 0, width, height);
 
@@ -140,7 +140,7 @@ function generateTexture(data, width, height) {
     canvasScaled.width = width * 4;
     canvasScaled.height = height * 4;
 
-    context = canvasScaled.getContext('2d');
+    context = canvasScaled.getContext('2d')!;
     context.scale(4, 4);
     context.drawImage(canvas, 0, 0);
 
diff --git a/examples-testing/examples/webgl_geometry_terrain_raycast.ts b/examples-testing/examples/webgl_geometry_terrain_raycast.ts
index f1383c138..6e9cd0256 100644
--- a/examples-testing/examples/webgl_geometry_terrain_raycast.ts
+++ b/examples-testing/examples/webgl_geometry_terrain_raycast.ts
@@ -5,18 +5,18 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh, texture;
+let mesh: THREE.Mesh, texture: THREE.CanvasTexture;
 
 const worldWidth = 256,
     worldDepth = 256,
     worldHalfWidth = worldWidth / 2,
     worldHalfDepth = worldDepth / 2;
 
-let helper;
+let helper: THREE.Mesh;
 
 const raycaster = new THREE.Raycaster();
 const pointer = new THREE.Vector2();
@@ -24,7 +24,7 @@ const pointer = new THREE.Vector2();
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
     container.innerHTML = '';
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -94,7 +94,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function generateHeight(width, height) {
+function generateHeight(width: number, height: number) {
     const size = width * height,
         data = new Uint8Array(size),
         perlin = new ImprovedNoise(),
@@ -115,7 +115,7 @@ function generateHeight(width, height) {
     return data;
 }
 
-function generateTexture(data, width, height) {
+function generateTexture(data: Uint8Array, width: number, height: number) {
     // bake lighting into texture
 
     let context, image, imageData, shade;
@@ -129,7 +129,7 @@ function generateTexture(data, width, height) {
     canvas.width = width;
     canvas.height = height;
 
-    context = canvas.getContext('2d');
+    context = canvas.getContext('2d')!;
     context.fillStyle = '#000';
     context.fillRect(0, 0, width, height);
 
@@ -157,7 +157,7 @@ function generateTexture(data, width, height) {
     canvasScaled.width = width * 4;
     canvasScaled.height = height * 4;
 
-    context = canvasScaled.getContext('2d');
+    context = canvasScaled.getContext('2d')!;
     context.scale(4, 4);
     context.drawImage(canvas, 0, 0);
 
@@ -188,7 +188,7 @@ function render() {
     renderer.render(scene, camera);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
     pointer.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
     raycaster.setFromCamera(pointer, camera);
@@ -199,7 +199,7 @@ function onPointerMove(event) {
     // Toggle rotation bool for meshes that we clicked
     if (intersects.length > 0) {
         helper.position.set(0, 0, 0);
-        helper.lookAt(intersects[0].face.normal);
+        helper.lookAt(intersects[0].face!.normal);
 
         helper.position.copy(intersects[0].point);
     }
diff --git a/examples-testing/examples/webgl_geometry_text.ts b/examples-testing/examples/webgl_geometry_text.ts
index 1a9d00d06..e59473290 100644
--- a/examples-testing/examples/webgl_geometry_text.ts
+++ b/examples-testing/examples/webgl_geometry_text.ts
@@ -1,23 +1,23 @@
 import * as THREE from 'three';
 
-import { FontLoader } from 'three/addons/loaders/FontLoader.js';
+import { Font, FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 THREE.Cache.enabled = true;
 
-let container;
+let container: HTMLDivElement;
 
-let camera, cameraTarget, scene, renderer;
+let camera: THREE.PerspectiveCamera, cameraTarget: THREE.Vector3, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let group, textMesh1, textMesh2, textGeo, materials;
+let group: THREE.Group, textMesh1: THREE.Mesh, textMesh2: THREE.Mesh, textGeo, materials: THREE.MeshPhongMaterial[];
 
 let firstLetter = true;
 
 let text = 'three.js',
     bevelEnabled = true,
-    font = undefined,
+    font: Font | undefined = undefined,
     fontName = 'optimer', // helvetiker, optimer, gentilis, droid sans, droid serif
     fontWeight = 'bold'; // normal bold
 
@@ -43,11 +43,11 @@ const weightMap = {
     bold: 1,
 };
 
-const reverseFontMap = [];
-const reverseWeightMap = [];
+const reverseFontMap: string[] = [];
+const reverseWeightMap: string[] = [];
 
-for (const i in fontMap) reverseFontMap[fontMap[i]] = i;
-for (const i in weightMap) reverseWeightMap[weightMap[i]] = i;
+for (const i in fontMap) reverseFontMap[fontMap[i as keyof typeof fontMap]] = i;
+for (const i in weightMap) reverseWeightMap[weightMap[i as keyof typeof weightMap]] = i;
 
 let targetRotation = 0;
 let targetRotationOnPointerDown = 0;
@@ -180,7 +180,7 @@ function onWindowResize() {
 
 //
 
-function onDocumentKeyDown(event) {
+function onDocumentKeyDown(event: KeyboardEvent) {
     if (firstLetter) {
         firstLetter = false;
         text = '';
@@ -200,7 +200,7 @@ function onDocumentKeyDown(event) {
     }
 }
 
-function onDocumentKeyPress(event) {
+function onDocumentKeyPress(event: KeyboardEvent) {
     const keyCode = event.which;
 
     // backspace
@@ -226,7 +226,7 @@ function loadFont() {
 
 function createText() {
     textGeo = new TextGeometry(text, {
-        font: font,
+        font: font!,
 
         size: size,
         depth: depth,
@@ -239,7 +239,7 @@ function createText() {
 
     textGeo.computeBoundingBox();
 
-    const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
+    const centerOffset = -0.5 * (textGeo.boundingBox!.max.x - textGeo.boundingBox!.min.x);
 
     textMesh1 = new THREE.Mesh(textGeo, materials);
 
@@ -275,7 +275,7 @@ function refreshText() {
     createText();
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerXOnPointerDown = event.clientX - windowHalfX;
@@ -285,7 +285,7 @@ function onPointerDown(event) {
     document.addEventListener('pointerup', onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerX = event.clientX - windowHalfX;
@@ -293,7 +293,7 @@ function onPointerMove(event) {
     targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
 }
 
-function onPointerUp(event) {
+function onPointerUp(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     document.removeEventListener('pointermove', onPointerMove);
diff --git a/examples-testing/examples/webgl_geometry_text_shapes.ts b/examples-testing/examples/webgl_geometry_text_shapes.ts
index d9633cd15..c2b07d41f 100644
--- a/examples-testing/examples/webgl_geometry_text_shapes.ts
+++ b/examples-testing/examples/webgl_geometry_text_shapes.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { FontLoader } from 'three/addons/loaders/FontLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -32,13 +32,13 @@ function init() {
 
         const message = '   Three.js\nSimple text.';
 
-        const shapes = font.generateShapes(message, 100);
+        const shapes: THREE.Path[] = font.generateShapes(message, 100);
 
-        const geometry = new THREE.ShapeGeometry(shapes);
+        const geometry = new THREE.ShapeGeometry(shapes as THREE.Shape[]);
 
         geometry.computeBoundingBox();
 
-        const xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
+        const xMid = -0.5 * (geometry.boundingBox!.max.x - geometry.boundingBox!.min.x);
 
         geometry.translate(xMid, 0, 0);
 
@@ -50,10 +50,10 @@ function init() {
 
         // make line shape ( N.B. edge view remains visible )
 
-        const holeShapes = [];
+        const holeShapes: THREE.Path[] = [];
 
         for (let i = 0; i < shapes.length; i++) {
-            const shape = shapes[i];
+            const shape = shapes[i] as THREE.Shape;
 
             if (shape.holes && shape.holes.length > 0) {
                 for (let j = 0; j < shape.holes.length; j++) {
diff --git a/examples-testing/examples/webgl_geometry_text_stroke.ts b/examples-testing/examples/webgl_geometry_text_stroke.ts
index 373892c74..9bf589244 100644
--- a/examples-testing/examples/webgl_geometry_text_stroke.ts
+++ b/examples-testing/examples/webgl_geometry_text_stroke.ts
@@ -5,7 +5,7 @@ import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
 import { Font } from 'three/addons/loaders/FontLoader.js';
 import { unzipSync, strFromU8 } from 'three/addons/libs/fflate.module.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -19,7 +19,7 @@ function init() {
     new THREE.FileLoader()
         .setResponseType('arraybuffer')
         .load('fonts/MPLUSRounded1c/MPLUSRounded1c-Regular.typeface.json.zip', function (data) {
-            const zip = unzipSync(new Uint8Array(data));
+            const zip = unzipSync(new Uint8Array(data as ArrayBuffer));
             const strArray = strFromU8(new Uint8Array(zip['MPLUSRounded1c-Regular.typeface.json'].buffer));
 
             const font = new Font(JSON.parse(strArray));
@@ -82,16 +82,22 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 } // end init
 
-function generateStrokeText(font, material, message, size, direction = 'ltr') {
-    const shapes = font.generateShapes(message, size, direction);
+function generateStrokeText(
+    font: Font,
+    material: { dark: THREE.MeshBasicMaterial; lite: THREE.MeshBasicMaterial; color: THREE.Color },
+    message: string,
+    size: number,
+    direction: 'ltr' | 'rtl' | 'tb' = 'ltr',
+) {
+    const shapes: THREE.Path[] = font.generateShapes(message, size, direction);
 
-    const geometry = new THREE.ShapeGeometry(shapes);
+    const geometry = new THREE.ShapeGeometry(shapes as THREE.Shape[]);
 
     const strokeText = new THREE.Group();
 
     geometry.computeBoundingBox();
 
-    const xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
+    const xMid = -0.5 * (geometry.boundingBox!.max.x - geometry.boundingBox!.min.x);
 
     geometry.translate(xMid, 0, 0);
 
@@ -105,10 +111,10 @@ function generateStrokeText(font, material, message, size, direction = 'ltr') {
 
     // make line shape ( N.B. edge view remains visible )
 
-    const holeShapes = [];
+    const holeShapes: THREE.Path[] = [];
 
     for (let i = 0; i < shapes.length; i++) {
-        const shape = shapes[i];
+        const shape = shapes[i] as THREE.Shape;
 
         if (shape.holes && shape.holes.length > 0) {
             for (let j = 0; j < shape.holes.length; j++) {
diff --git a/examples-testing/examples/webgl_gpgpu_birds.ts b/examples-testing/examples/webgl_gpgpu_birds.ts
index 20a5e0d97..e9293211c 100644
--- a/examples-testing/examples/webgl_gpgpu_birds.ts
+++ b/examples-testing/examples/webgl_gpgpu_birds.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
+import { GPUComputationRenderer, Variable } from 'three/addons/misc/GPUComputationRenderer.js';
 
 /* TEXTURE WIDTH FOR SIMULATION */
 const WIDTH = 32;
@@ -33,9 +33,9 @@ class BirdGeometry extends THREE.BufferGeometry {
 
         let v = 0;
 
-        function verts_push() {
-            for (let i = 0; i < arguments.length; i++) {
-                vertices.array[v++] = arguments[i];
+        function verts_push(...args: number[]) {
+            for (let i = 0; i < args.length; i++) {
+                vertices.array[v++] = args[i];
             }
         }
 
@@ -77,8 +77,8 @@ class BirdGeometry extends THREE.BufferGeometry {
 
 //
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 let mouseX = 0,
     mouseY = 0;
 
@@ -90,12 +90,12 @@ const BOUNDS = 800,
 
 let last = performance.now();
 
-let gpuCompute;
-let velocityVariable;
-let positionVariable;
-let positionUniforms;
-let velocityUniforms;
-let birdUniforms;
+let gpuCompute: GPUComputationRenderer;
+let velocityVariable: Variable;
+let positionVariable: Variable;
+let positionUniforms: Record<string, THREE.IUniform>;
+let velocityUniforms: Record<string, THREE.IUniform>;
+let birdUniforms: Record<string, THREE.IUniform>;
 
 init();
 
@@ -164,12 +164,12 @@ function initComputeRenderer() {
 
     velocityVariable = gpuCompute.addVariable(
         'textureVelocity',
-        document.getElementById('fragmentShaderVelocity').textContent,
+        document.getElementById('fragmentShaderVelocity')!.textContent!,
         dtVelocity,
     );
     positionVariable = gpuCompute.addVariable(
         'texturePosition',
-        document.getElementById('fragmentShaderPosition').textContent,
+        document.getElementById('fragmentShaderPosition')!.textContent!,
         dtPosition,
     );
 
@@ -218,8 +218,8 @@ function initBirds() {
     // THREE.ShaderMaterial
     const material = new THREE.ShaderMaterial({
         uniforms: birdUniforms,
-        vertexShader: document.getElementById('birdVS').textContent,
-        fragmentShader: document.getElementById('birdFS').textContent,
+        vertexShader: document.getElementById('birdVS')!.textContent!,
+        fragmentShader: document.getElementById('birdFS')!.textContent!,
         side: THREE.DoubleSide,
     });
 
@@ -231,8 +231,8 @@ function initBirds() {
     scene.add(birdMesh);
 }
 
-function fillPositionTexture(texture) {
-    const theArray = texture.image.data;
+function fillPositionTexture(texture: THREE.DataTexture) {
+    const theArray = texture.image.data as Float32Array;
 
     for (let k = 0, kl = theArray.length; k < kl; k += 4) {
         const x = Math.random() * BOUNDS - BOUNDS_HALF;
@@ -246,8 +246,8 @@ function fillPositionTexture(texture) {
     }
 }
 
-function fillVelocityTexture(texture) {
-    const theArray = texture.image.data;
+function fillVelocityTexture(texture: THREE.DataTexture) {
+    const theArray = texture.image.data as Float32Array;
 
     for (let k = 0, kl = theArray.length; k < kl; k += 4) {
         const x = Math.random() - 0.5;
@@ -271,7 +271,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
diff --git a/examples-testing/examples/webgl_gpgpu_birds_gltf.ts b/examples-testing/examples/webgl_gpgpu_birds_gltf.ts
index 05f81a869..f86d0d386 100644
--- a/examples-testing/examples/webgl_gpgpu_birds_gltf.ts
+++ b/examples-testing/examples/webgl_gpgpu_birds_gltf.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
-import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
+import { GPUComputationRenderer, Variable } from 'three/addons/misc/GPUComputationRenderer.js';
 
 /* TEXTURE WIDTH FOR SIMULATION */
 const WIDTH = 64;
@@ -10,9 +10,13 @@ const BIRDS = WIDTH * WIDTH;
 
 /* BAKE ANIMATION INTO TEXTURE and CREATE GEOMETRY FROM BASE MODEL */
 const BirdGeometry = new THREE.BufferGeometry();
-let textureAnimation, durationAnimation, birdMesh, materialShader, indicesPerBird;
+let textureAnimation: THREE.DataTexture,
+    durationAnimation: number,
+    birdMesh: THREE.Mesh,
+    materialShader: THREE.WebGLProgramParametersWithUniforms,
+    indicesPerBird: number;
 
-function nextPowerOf2(n) {
+function nextPowerOf2(n: number) {
     return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)));
 }
 
@@ -23,11 +27,11 @@ const selectModel = Math.floor(Math.random() * gltfs.length);
 new GLTFLoader().load(gltfs[selectModel], function (gltf) {
     const animations = gltf.animations;
     durationAnimation = Math.round(animations[0].duration * 60);
-    const birdGeo = gltf.scene.children[0].geometry;
-    const morphAttributes = birdGeo.morphAttributes.position;
+    const birdGeo = (gltf.scene.children[0] as THREE.Mesh).geometry;
+    const morphAttributes = birdGeo.morphAttributes.position!;
     const tHeight = nextPowerOf2(durationAnimation);
     const tWidth = nextPowerOf2(birdGeo.getAttribute('position').count);
-    indicesPerBird = birdGeo.index.count;
+    indicesPerBird = birdGeo.index!.count;
     const tData = new Float32Array(4 * tWidth * tHeight);
 
     for (let i = 0; i < tWidth; i++) {
@@ -92,9 +96,9 @@ new GLTFLoader().load(gltfs[selectModel], function (gltf) {
         seeds.push(bird, r, Math.random(), Math.random());
     }
 
-    for (let i = 0; i < birdGeo.index.array.length * BIRDS; i++) {
-        const offset = Math.floor(i / birdGeo.index.array.length) * birdGeo.getAttribute('position').count;
-        indices.push(birdGeo.index.array[i % birdGeo.index.array.length] + offset);
+    for (let i = 0; i < birdGeo.index!.array.length * BIRDS; i++) {
+        const offset = Math.floor(i / birdGeo.index!.array.length) * birdGeo.getAttribute('position').count;
+        indices.push(birdGeo.index!.array[i % birdGeo.index!.array.length] + offset);
     }
 
     BirdGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
@@ -108,8 +112,8 @@ new GLTFLoader().load(gltfs[selectModel], function (gltf) {
     init();
 });
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 let mouseX = 0,
     mouseY = 0;
 
@@ -121,11 +125,20 @@ const BOUNDS = 800,
 
 let last = performance.now();
 
-let gpuCompute;
-let velocityVariable;
-let positionVariable;
-let positionUniforms;
-let velocityUniforms;
+let gpuCompute: GPUComputationRenderer;
+let velocityVariable: Variable;
+let positionVariable: Variable;
+let positionUniforms: Record<string, THREE.IUniform>;
+let velocityUniforms: Record<string, THREE.IUniform>;
+
+interface EffectController {
+    separation: number;
+    alignment: number;
+    cohesion: number;
+    freedom: number;
+    size: number;
+    count: number;
+}
 
 function init() {
     container = document.createElement('div');
@@ -210,12 +223,12 @@ function initComputeRenderer() {
 
     velocityVariable = gpuCompute.addVariable(
         'textureVelocity',
-        document.getElementById('fragmentShaderVelocity').textContent,
+        document.getElementById('fragmentShaderVelocity')!.textContent!,
         dtVelocity,
     );
     positionVariable = gpuCompute.addVariable(
         'texturePosition',
-        document.getElementById('fragmentShaderPosition').textContent,
+        document.getElementById('fragmentShaderPosition')!.textContent!,
         dtPosition,
     );
 
@@ -249,7 +262,7 @@ function initComputeRenderer() {
     }
 }
 
-function initBirds(effectController) {
+function initBirds(effectController: EffectController) {
     const geometry = BirdGeometry;
 
     const m = new THREE.MeshStandardMaterial({
@@ -329,8 +342,8 @@ function initBirds(effectController) {
     scene.add(birdMesh);
 }
 
-function fillPositionTexture(texture) {
-    const theArray = texture.image.data;
+function fillPositionTexture(texture: THREE.DataTexture) {
+    const theArray = texture.image.data as Float32Array;
 
     for (let k = 0, kl = theArray.length; k < kl; k += 4) {
         const x = Math.random() * BOUNDS - BOUNDS_HALF;
@@ -344,8 +357,8 @@ function fillPositionTexture(texture) {
     }
 }
 
-function fillVelocityTexture(texture) {
-    const theArray = texture.image.data;
+function fillVelocityTexture(texture: THREE.DataTexture) {
+    const theArray = texture.image.data as Float32Array;
 
     for (let k = 0, kl = theArray.length; k < kl; k += 4) {
         const x = Math.random() - 0.5;
@@ -369,7 +382,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
diff --git a/examples-testing/examples/webgl_gpgpu_protoplanet.ts b/examples-testing/examples/webgl_gpgpu_protoplanet.ts
index 30444ddba..e1c40aefa 100644
--- a/examples-testing/examples/webgl_gpgpu_protoplanet.ts
+++ b/examples-testing/examples/webgl_gpgpu_protoplanet.ts
@@ -4,22 +4,32 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
+import { GPUComputationRenderer, Variable } from 'three/addons/misc/GPUComputationRenderer.js';
 
 // Texture width for simulation (each texel is a debris particle)
 const WIDTH = 64;
 
-let container, stats;
-let camera, scene, renderer, geometry;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, geometry: THREE.BufferGeometry;
 
 const PARTICLES = WIDTH * WIDTH;
 
-let gpuCompute;
-let velocityVariable;
-let positionVariable;
-let velocityUniforms;
-let particleUniforms;
-let effectController;
+let gpuCompute: GPUComputationRenderer;
+let velocityVariable: Variable;
+let positionVariable: Variable;
+let velocityUniforms: Record<string, THREE.IUniform>;
+let particleUniforms: Record<string, THREE.IUniform>;
+let effectController: {
+    gravityConstant: number;
+    density: number;
+    radius: number;
+    height: number;
+    exponent: number;
+    maxMass: number;
+    velocity: number;
+    velocityExponent: number;
+    randVelocity: number;
+};
 
 init();
 
@@ -82,12 +92,12 @@ function initComputeRenderer() {
 
     velocityVariable = gpuCompute.addVariable(
         'textureVelocity',
-        document.getElementById('computeShaderVelocity').textContent,
+        document.getElementById('computeShaderVelocity')!.textContent!,
         dtVelocity,
     );
     positionVariable = gpuCompute.addVariable(
         'texturePosition',
-        document.getElementById('computeShaderPosition').textContent,
+        document.getElementById('computeShaderPosition')!.textContent!,
         dtPosition,
     );
 
@@ -153,8 +163,8 @@ function initProtoplanets() {
     // THREE.ShaderMaterial
     const material = new THREE.ShaderMaterial({
         uniforms: particleUniforms,
-        vertexShader: document.getElementById('particleVertexShader').textContent,
-        fragmentShader: document.getElementById('particleFragmentShader').textContent,
+        vertexShader: document.getElementById('particleVertexShader')!.textContent!,
+        fragmentShader: document.getElementById('particleFragmentShader')!.textContent!,
     });
 
     const particles = new THREE.Points(geometry, material);
@@ -164,9 +174,9 @@ function initProtoplanets() {
     scene.add(particles);
 }
 
-function fillTextures(texturePosition, textureVelocity) {
-    const posArray = texturePosition.image.data;
-    const velArray = textureVelocity.image.data;
+function fillTextures(texturePosition: THREE.DataTexture, textureVelocity: THREE.DataTexture) {
+    const posArray = texturePosition.image.data as Float32Array;
+    const velArray = textureVelocity.image.data as Float32Array;
 
     const radius = effectController.radius;
     const height = effectController.height;
@@ -261,7 +271,7 @@ function initGUI() {
     folder2.open();
 }
 
-function getCameraConstant(camera) {
+function getCameraConstant(camera: THREE.PerspectiveCamera) {
     return window.innerHeight / (Math.tan(THREE.MathUtils.DEG2RAD * 0.5 * camera.fov) / camera.zoom);
 }
 
diff --git a/examples-testing/examples/webgl_gpgpu_water.ts b/examples-testing/examples/webgl_gpgpu_water.ts
index 9a724d177..6cf5c8bc3 100644
--- a/examples-testing/examples/webgl_gpgpu_water.ts
+++ b/examples-testing/examples/webgl_gpgpu_water.ts
@@ -4,7 +4,7 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
+import { GPUComputationRenderer, Variable } from 'three/addons/misc/GPUComputationRenderer.js';
 import { SimplexNoise } from 'three/addons/math/SimplexNoise.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
@@ -17,32 +17,32 @@ const WIDTH = 128;
 const BOUNDS = 6;
 const BOUNDS_HALF = BOUNDS * 0.5;
 
-let tmpHeightmap = null;
+let tmpHeightmap: THREE.Texture | null = null;
 const tmpQuat = new THREE.Quaternion();
 const tmpQuatX = new THREE.Quaternion();
 const tmpQuatZ = new THREE.Quaternion();
-let duckModel = null;
+let duckModel: THREE.Mesh | null = null;
 
-let container, stats;
-let camera, scene, renderer, controls;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
 let mousedown = false;
 const mouseCoords = new THREE.Vector2();
 const raycaster = new THREE.Raycaster();
 
-let sun;
-let waterMesh;
-let poolBorder;
-let meshRay;
-let gpuCompute;
-let heightmapVariable;
-let smoothShader;
-let readWaterLevelShader;
-let readWaterLevelRenderTarget;
-let readWaterLevelImage;
+let sun: THREE.DirectionalLight;
+let waterMesh: THREE.Mesh<THREE.PlaneGeometry, WaterMaterial>;
+let poolBorder: THREE.Mesh<THREE.TorusGeometry, THREE.MeshStandardMaterial>;
+let meshRay: THREE.Mesh;
+let gpuCompute: GPUComputationRenderer;
+let heightmapVariable: Variable;
+let smoothShader: THREE.ShaderMaterial;
+let readWaterLevelShader: THREE.ShaderMaterial;
+let readWaterLevelRenderTarget: THREE.WebGLRenderTarget;
+let readWaterLevelImage: Uint8Array<ArrayBuffer>;
 const waterNormal = new THREE.Vector3();
 
 const NUM_DUCK = 12;
-const ducks = [];
+const ducks: THREE.Mesh[] = [];
 let ducksEnabled = true;
 
 const simplex = new SimplexNoise();
@@ -108,7 +108,7 @@ async function init() {
     scene.backgroundBlurriness = 0.3;
     scene.environmentIntensity = 1.25;
 
-    duckModel = model.scene.children[0];
+    duckModel = model.scene.children[0] as THREE.Mesh;
     duckModel.receiveShadow = true;
     duckModel.castShadow = true;
 
@@ -211,13 +211,13 @@ function initWater() {
     if (error !== null) console.error(error);
 
     // Create compute shader to smooth the water surface and velocity
-    smoothShader = gpuCompute.createShaderMaterial(document.getElementById('smoothFragmentShader').textContent, {
+    smoothShader = gpuCompute.createShaderMaterial(document.getElementById('smoothFragmentShader')!.textContent!, {
         smoothTexture: { value: null },
     });
 
     // Create compute shader to read water level
     readWaterLevelShader = gpuCompute.createShaderMaterial(
-        document.getElementById('readWaterLevelFragmentShader').textContent,
+        document.getElementById('readWaterLevelFragmentShader')!.textContent!,
         {
             point1: { value: new THREE.Vector2() },
             levelTexture: { value: null },
@@ -240,10 +240,10 @@ function initWater() {
     });
 }
 
-function fillTexture(texture) {
+function fillTexture(texture: THREE.DataTexture) {
     const waterMaxHeight = 0.1;
 
-    function noise(x, y) {
+    function noise(x: number, y: number) {
         let multR = waterMaxHeight;
         let mult = 0.025;
         let r = 0;
@@ -256,7 +256,7 @@ function fillTexture(texture) {
         return r;
     }
 
-    const pixels = texture.image.data;
+    const pixels = texture.image.data as Float32Array;
 
     let p = 0;
     for (let j = 0; j < WIDTH; j++) {
@@ -274,7 +274,7 @@ function fillTexture(texture) {
     }
 }
 
-function addShadow(v) {
+function addShadow(v: boolean) {
     renderer.shadowMap.enabled = v;
     sun.castShadow = v;
 
@@ -313,9 +313,9 @@ function smoothWater() {
 
 function createducks() {
     for (let i = 0; i < NUM_DUCK; i++) {
-        let sphere = duckModel;
+        let sphere = duckModel!;
         if (i < NUM_DUCK - 1) {
-            sphere = duckModel.clone();
+            sphere = duckModel!.clone();
         }
 
         sphere.position.x = (Math.random() - 0.5) * BOUNDS * 0.7;
@@ -414,7 +414,7 @@ function onPointerUp() {
     controls.enabled = true;
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     const dom = renderer.domElement;
     mouseCoords.set((event.clientX / dom.clientWidth) * 2 - 1, -(event.clientY / dom.clientHeight) * 2 + 1);
 }
@@ -469,7 +469,13 @@ function render() {
 //----------------------
 
 class WaterMaterial extends THREE.MeshStandardMaterial {
-    constructor(parameters) {
+    defines: { [name: string]: unknown };
+
+    extra: { [name: string]: unknown };
+
+    heightmap!: THREE.Texture | null;
+
+    constructor(parameters: THREE.MeshStandardMaterialParameters) {
         super();
 
         this.defines = {
@@ -486,7 +492,7 @@ class WaterMaterial extends THREE.MeshStandardMaterial {
         this.setValues(parameters);
     }
 
-    addParameter(name, value) {
+    addParameter(name: string, value: unknown) {
         this.extra[name] = value;
         Object.defineProperty(this, name, {
             get: () => this.extra[name],
@@ -497,7 +503,7 @@ class WaterMaterial extends THREE.MeshStandardMaterial {
         });
     }
 
-    onBeforeCompile(shader) {
+    onBeforeCompile(shader: THREE.WebGLProgramParametersWithUniforms) {
         for (const name in this.extra) {
             shader.uniforms[name] = { value: this.extra[name] };
         }
diff --git a/examples-testing/examples/webgl_helpers.ts b/examples-testing/examples/webgl_helpers.ts
index a8c3b9773..09ad778dc 100644
--- a/examples-testing/examples/webgl_helpers.ts
+++ b/examples-testing/examples/webgl_helpers.ts
@@ -5,10 +5,10 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { VertexNormalsHelper } from 'three/addons/helpers/VertexNormalsHelper.js';
 import { VertexTangentsHelper } from 'three/addons/helpers/VertexTangentsHelper.js';
 
-let scene, renderer;
-let camera, light;
-let vnh;
-let vth;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let camera: THREE.PerspectiveCamera, light: THREE.PointLight;
+let vnh: VertexNormalsHelper;
+let vth: VertexTangentsHelper;
 
 init();
 
@@ -44,7 +44,7 @@ function init() {
 
     const loader = new GLTFLoader();
     loader.load('models/gltf/LeePerrySmith/LeePerrySmith.glb', function (gltf) {
-        const mesh = gltf.scene.children[0];
+        const mesh = gltf.scene.children[0] as THREE.Mesh;
 
         mesh.geometry.computeTangents(); // generates bad data due to degenerate UVs
 
@@ -66,7 +66,7 @@ function init() {
         scene.add(new THREE.BoxHelper(mesh));
 
         const wireframe = new THREE.WireframeGeometry(mesh.geometry);
-        let line = new THREE.LineSegments(wireframe);
+        let line: THREE.LineSegments<THREE.BufferGeometry, THREE.LineBasicMaterial> = new THREE.LineSegments(wireframe);
         line.material.depthTest = false;
         line.material.opacity = 0.25;
         line.material.transparent = true;
diff --git a/examples-testing/examples/webgl_instancing_dynamic.ts b/examples-testing/examples/webgl_instancing_dynamic.ts
index bc4a88662..105d30e11 100644
--- a/examples-testing/examples/webgl_instancing_dynamic.ts
+++ b/examples-testing/examples/webgl_instancing_dynamic.ts
@@ -3,15 +3,19 @@ import * as THREE from 'three';
 import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
 import TWEEN from 'three/addons/libs/tween.module.js';
 
-let camera, scene, renderer, timer, mesh;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    timer: THREE.Timer,
+    mesh: THREE.InstancedMesh;
 
 const amount = 100;
 
 const count = Math.pow(amount, 2);
 const dummy = new THREE.Object3D();
 
-const seeds = [];
-const baseColors = [];
+const seeds: number[] = [];
+const baseColors: number[] = [];
 
 const color = new THREE.Color();
 const colors = [new THREE.Color(0x00ffff), new THREE.Color(0xffff00), new THREE.Color(0xff00ff)];
@@ -167,7 +171,7 @@ function animate() {
     }
 
     mesh.instanceMatrix.needsUpdate = true;
-    if (animation.t > 0) mesh.instanceColor.needsUpdate = true;
+    if (animation.t > 0) mesh.instanceColor!.needsUpdate = true;
 
     mesh.computeBoundingSphere();
 
diff --git a/examples-testing/examples/webgl_instancing_morph.ts b/examples-testing/examples/webgl_instancing_morph.ts
index 8686a75b9..fb76abe35 100644
--- a/examples-testing/examples/webgl_instancing_morph.ts
+++ b/examples-testing/examples/webgl_instancing_morph.ts
@@ -4,7 +4,13 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats, mesh, mixer, dummy;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    mesh: THREE.InstancedMesh,
+    mixer: THREE.AnimationMixer,
+    dummy: THREE.Mesh;
 
 const offset = 5000;
 
@@ -63,7 +69,7 @@ function init() {
     const loader = new GLTFLoader();
 
     loader.load('models/gltf/Horse.glb', function (glb) {
-        dummy = glb.scene.children[0];
+        dummy = glb.scene.children[0] as THREE.Mesh;
 
         mesh = new THREE.InstancedMesh(dummy.geometry, dummy.material, 1024);
 
@@ -140,7 +146,7 @@ function render() {
             mesh.setMorphAt(i, dummy);
         }
 
-        mesh.morphTexture.needsUpdate = true;
+        mesh.morphTexture!.needsUpdate = true;
     }
 
     renderer.render(scene, camera);
diff --git a/examples-testing/examples/webgl_instancing_performance.ts b/examples-testing/examples/webgl_instancing_performance.ts
index bf1deabad..705d2cf36 100644
--- a/examples-testing/examples/webgl_instancing_performance.ts
+++ b/examples-testing/examples/webgl_instancing_performance.ts
@@ -6,8 +6,12 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let container, stats, gui, guiStatsEl;
-let camera, controls, scene, renderer, material;
+let container: HTMLElement, stats: Stats, gui: GUI, guiStatsEl: HTMLDivElement;
+let camera: THREE.PerspectiveCamera,
+    controls: OrbitControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    material: THREE.MeshNormalMaterial;
 
 // gui
 
@@ -30,15 +34,15 @@ initMesh();
 //
 
 function clean() {
-    const meshes = [];
+    const meshes: THREE.Mesh[] = [];
 
     scene.traverse(function (object) {
-        if (object.isMesh) meshes.push(object);
+        if ((object as THREE.Mesh).isMesh) meshes.push(object as THREE.Mesh);
     });
 
     for (let i = 0; i < meshes.length; i++) {
         const mesh = meshes[i];
-        mesh.material.dispose();
+        (mesh.material as THREE.Material).dispose();
         mesh.geometry.dispose();
 
         scene.remove(mesh);
@@ -50,7 +54,7 @@ const randomizeMatrix = (function () {
     const quaternion = new THREE.Quaternion();
     const scale = new THREE.Vector3();
 
-    return function (matrix) {
+    return function (matrix: THREE.Matrix4) {
         position.x = Math.random() * 40 - 20;
         position.y = Math.random() * 40 - 20;
         position.z = Math.random() * 40 - 20;
@@ -92,7 +96,7 @@ function initMesh() {
     });
 }
 
-function makeInstanced(geometry) {
+function makeInstanced(geometry: THREE.BufferGeometry) {
     const matrix = new THREE.Matrix4();
     const mesh = new THREE.InstancedMesh(geometry, material, api.count);
 
@@ -113,7 +117,7 @@ function makeInstanced(geometry) {
     ].join('<br/>');
 }
 
-function makeMerged(geometry) {
+function makeMerged(geometry: THREE.BufferGeometry) {
     const geometries = [];
     const matrix = new THREE.Matrix4();
 
@@ -138,7 +142,7 @@ function makeMerged(geometry) {
     ].join('<br/>');
 }
 
-function makeNaive(geometry) {
+function makeNaive(geometry: THREE.BufferGeometry) {
     const matrix = new THREE.Matrix4();
 
     for (let i = 0; i < api.count; i++) {
@@ -175,7 +179,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(width, height);
     renderer.setAnimationLoop(animate);
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     // scene
@@ -236,7 +240,7 @@ function animate() {
 
 //
 
-function getGeometryByteLength(geometry) {
+function getGeometryByteLength(geometry: THREE.BufferGeometry) {
     let total = 0;
 
     if (geometry.index) total += geometry.index.array.byteLength;
@@ -249,7 +253,7 @@ function getGeometryByteLength(geometry) {
 }
 
 // Source: https://stackoverflow.com/a/18650828/1314762
-function formatBytes(bytes, decimals) {
+function formatBytes(bytes: number, decimals: number) {
     if (bytes === 0) return '0 bytes';
 
     const k = 1024;
diff --git a/examples-testing/examples/webgl_instancing_raycast.ts b/examples-testing/examples/webgl_instancing_raycast.ts
index 371ea070b..861bc9c51 100644
--- a/examples-testing/examples/webgl_instancing_raycast.ts
+++ b/examples-testing/examples/webgl_instancing_raycast.ts
@@ -4,9 +4,13 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, controls, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    controls: OrbitControls,
+    stats: Stats;
 
-let mesh;
+let mesh: THREE.InstancedMesh;
 const amount = parseInt(window.location.search.slice(1)) || 10;
 const count = Math.pow(amount, 3);
 
@@ -84,7 +88,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onMouseMove(event) {
+function onMouseMove(event: MouseEvent) {
     event.preventDefault();
 
     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
@@ -99,14 +103,14 @@ function animate() {
     const intersection = raycaster.intersectObject(mesh);
 
     if (intersection.length > 0) {
-        const instanceId = intersection[0].instanceId;
+        const instanceId = intersection[0].instanceId!;
 
         mesh.getColorAt(instanceId, color);
 
         if (color.equals(white)) {
             mesh.setColorAt(instanceId, color.setHex(Math.random() * 0xffffff));
 
-            mesh.instanceColor.needsUpdate = true;
+            mesh.instanceColor!.needsUpdate = true;
         }
     }
 
diff --git a/examples-testing/examples/webgl_instancing_scatter.ts b/examples-testing/examples/webgl_instancing_scatter.ts
index fc3b9cc9f..d0904e8e4 100644
--- a/examples-testing/examples/webgl_instancing_scatter.ts
+++ b/examples-testing/examples/webgl_instancing_scatter.ts
@@ -5,7 +5,7 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 const api = {
     count: 2000,
@@ -15,11 +15,11 @@ const api = {
     backgroundColor: 0xe39469,
 };
 
-let stemMesh, blossomMesh;
-let stemGeometry, blossomGeometry;
-let stemMaterial, blossomMaterial;
+let stemMesh: THREE.InstancedMesh, blossomMesh: THREE.InstancedMesh;
+let stemGeometry: THREE.BufferGeometry, blossomGeometry: THREE.BufferGeometry;
+let stemMaterial: THREE.Material | THREE.Material[], blossomMaterial: THREE.Material | THREE.Material[];
 
-let sampler;
+let sampler: MeshSurfaceSampler;
 const count = api.count;
 const ages = new Float32Array(count);
 const scales = new Float32Array(count);
@@ -35,21 +35,21 @@ const surfaceMaterial = new THREE.MeshLambertMaterial({ color: api.surfaceColor,
 const surface = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
 
 // Source: https://gist.github.com/gre/1650294
-const easeOutCubic = function (t) {
+const easeOutCubic = function (t: number) {
     return --t * t * t + 1;
 };
 
 // Scaling curve causes particles to grow quickly, ease gradually into full scale, then
 // disappear quickly. More of the particle's lifetime is spent around full scale.
-const scaleCurve = function (t) {
+const scaleCurve = function (t: number) {
     return Math.abs(easeOutCubic((t > 0.5 ? 1 - t : t) * 2));
 };
 
 const loader = new GLTFLoader();
 
 loader.load('./models/gltf/Flower/Flower.glb', function (gltf) {
-    const _stemMesh = gltf.scene.getObjectByName('Stem');
-    const _blossomMesh = gltf.scene.getObjectByName('Blossom');
+    const _stemMesh = gltf.scene.getObjectByName('Stem') as THREE.Mesh;
+    const _blossomMesh = gltf.scene.getObjectByName('Blossom') as THREE.Mesh;
 
     stemGeometry = _stemMesh.geometry.clone();
     blossomGeometry = _blossomMesh.geometry.clone();
@@ -179,7 +179,7 @@ function resample() {
     blossomMesh.instanceMatrix.needsUpdate = true;
 }
 
-function resampleParticle(i) {
+function resampleParticle(i: number) {
     sampler.sample(_position, _normal);
     _normal.add(_position);
 
@@ -192,7 +192,7 @@ function resampleParticle(i) {
     blossomMesh.setMatrixAt(i, dummy.matrix);
 }
 
-function updateParticle(i) {
+function updateParticle(i: number) {
     // Update lifecycle.
 
     ages[i] += 0.005;
diff --git a/examples-testing/examples/webgl_interactive_buffergeometry.ts b/examples-testing/examples/webgl_interactive_buffergeometry.ts
index 1d6608b13..c6aca942f 100644
--- a/examples-testing/examples/webgl_interactive_buffergeometry.ts
+++ b/examples-testing/examples/webgl_interactive_buffergeometry.ts
@@ -2,18 +2,18 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let raycaster, pointer;
+let raycaster: THREE.Raycaster, pointer: THREE.Vector2;
 
-let mesh, line;
+let mesh: THREE.Mesh, line: THREE.Line;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -146,7 +146,7 @@ function init() {
 
     geometry.computeBoundingSphere();
 
-    let material = new THREE.MeshPhongMaterial({
+    let material: THREE.Material = new THREE.MeshPhongMaterial({
         color: 0xaaaaaa,
         specular: 0xffffff,
         shininess: 250,
@@ -197,7 +197,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -221,10 +221,10 @@ function render() {
 
     if (intersects.length > 0) {
         const intersect = intersects[0];
-        const face = intersect.face;
+        const face = intersect.face!;
 
-        const linePosition = line.geometry.attributes.position;
-        const meshPosition = mesh.geometry.attributes.position;
+        const linePosition = line.geometry.attributes.position as THREE.BufferAttribute;
+        const meshPosition = mesh.geometry.attributes.position as THREE.BufferAttribute;
 
         linePosition.copyAt(0, meshPosition, face.a);
         linePosition.copyAt(1, meshPosition, face.b);
diff --git a/examples-testing/examples/webgl_interactive_cubes.ts b/examples-testing/examples/webgl_interactive_cubes.ts
index adfcfddf8..d26cee370 100644
--- a/examples-testing/examples/webgl_interactive_cubes.ts
+++ b/examples-testing/examples/webgl_interactive_cubes.ts
@@ -2,10 +2,10 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let stats;
-let camera, scene, raycaster, renderer;
+let stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, raycaster: THREE.Raycaster, renderer: THREE.WebGLRenderer;
 
-let INTERSECTED;
+let INTERSECTED: (THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial> & { currentHex?: number }) | null;
 let theta = 0;
 
 const pointer = new THREE.Vector2();
@@ -68,7 +68,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: MouseEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -98,14 +98,14 @@ function render() {
 
     if (intersects.length > 0) {
         if (INTERSECTED != intersects[0].object) {
-            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
+            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex!);
 
-            INTERSECTED = intersects[0].object;
+            INTERSECTED = intersects[0].object as THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial>;
             INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
             INTERSECTED.material.emissive.setHex(0xff0000);
         }
     } else {
-        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
+        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex!);
 
         INTERSECTED = null;
     }
diff --git a/examples-testing/examples/webgl_interactive_cubes_gpu.ts b/examples-testing/examples/webgl_interactive_cubes_gpu.ts
index 5b19d2085..b8772168d 100644
--- a/examples-testing/examples/webgl_interactive_cubes_gpu.ts
+++ b/examples-testing/examples/webgl_interactive_cubes_gpu.ts
@@ -5,12 +5,12 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let container, stats;
-let camera, controls, scene, renderer;
-let pickingTexture, pickingScene;
-let highlightBox;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, controls: TrackballControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let pickingTexture: THREE.WebGLRenderTarget, pickingScene: THREE.Scene;
+let highlightBox: THREE.Mesh;
 
-const pickingData = [];
+const pickingData: { position: THREE.Vector3; rotation: THREE.Euler; scale: THREE.Vector3 }[] = [];
 
 const pointer = new THREE.Vector2();
 const offset = new THREE.Vector3(10, 10, 10);
@@ -19,7 +19,7 @@ const clearColor = new THREE.Color();
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 1000;
@@ -73,7 +73,7 @@ function init() {
 					`,
     });
 
-    function applyId(geometry, id) {
+    function applyId(geometry: THREE.BoxGeometry, id: number) {
         const position = geometry.attributes.position;
         const array = new Int16Array(position.count);
         array.fill(id);
@@ -83,7 +83,7 @@ function init() {
         geometry.setAttribute('id', bufferAttribute);
     }
 
-    function applyVertexColors(geometry, color) {
+    function applyVertexColors(geometry: THREE.BoxGeometry, color: THREE.Color) {
         const position = geometry.attributes.position;
         const colors = [];
 
@@ -166,7 +166,7 @@ function init() {
 
 //
 
-function onPointerMove(e) {
+function onPointerMove(e: PointerEvent) {
     pointer.x = e.clientX;
     pointer.y = e.clientY;
 }
diff --git a/examples-testing/examples/webgl_interactive_cubes_ortho.ts b/examples-testing/examples/webgl_interactive_cubes_ortho.ts
index 520674b5f..4b083ffe9 100644
--- a/examples-testing/examples/webgl_interactive_cubes_ortho.ts
+++ b/examples-testing/examples/webgl_interactive_cubes_ortho.ts
@@ -2,11 +2,11 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let stats;
-let camera, scene, raycaster, renderer;
+let stats: Stats;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, raycaster: THREE.Raycaster, renderer: THREE.WebGLRenderer;
 
 let theta = 0;
-let INTERSECTED;
+let INTERSECTED: (THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial> & { currentHex?: number }) | null;
 
 const pointer = new THREE.Vector2();
 const radius = 25;
@@ -83,7 +83,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -113,14 +113,14 @@ function render() {
 
     if (intersects.length > 0) {
         if (INTERSECTED != intersects[0].object) {
-            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
+            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex!);
 
-            INTERSECTED = intersects[0].object;
+            INTERSECTED = intersects[0].object as THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial>;
             INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
             INTERSECTED.material.emissive.setHex(0xff0000);
         }
     } else {
-        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
+        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex!);
 
         INTERSECTED = null;
     }
diff --git a/examples-testing/examples/webgl_interactive_lines.ts b/examples-testing/examples/webgl_interactive_lines.ts
index b137c5501..891e5541c 100644
--- a/examples-testing/examples/webgl_interactive_lines.ts
+++ b/examples-testing/examples/webgl_interactive_lines.ts
@@ -2,8 +2,13 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
-let camera, scene, raycaster, renderer, parentTransform, sphereInter;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    raycaster: THREE.Raycaster,
+    renderer: THREE.WebGLRenderer,
+    parentTransform: THREE.Object3D,
+    sphereInter: THREE.Mesh;
 
 const pointer = new THREE.Vector2();
 const radius = 100;
@@ -121,7 +126,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
diff --git a/examples-testing/examples/webgl_interactive_points.ts b/examples-testing/examples/webgl_interactive_points.ts
index b6be0df05..2bc27dae9 100644
--- a/examples-testing/examples/webgl_interactive_points.ts
+++ b/examples-testing/examples/webgl_interactive_points.ts
@@ -4,19 +4,19 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let particles;
+let particles: THREE.Points;
 
 const PARTICLE_SIZE = 20;
 
-let raycaster, intersects;
-let pointer, INTERSECTED;
+let raycaster: THREE.Raycaster, intersects: THREE.Intersection<THREE.Object3D>[];
+let pointer: THREE.Vector2, INTERSECTED: number | null;
 
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
 
@@ -25,7 +25,7 @@ function init() {
 
     //
 
-    let boxGeometry = new THREE.BoxGeometry(200, 200, 200, 16, 16, 16);
+    let boxGeometry: THREE.BufferGeometry = new THREE.BoxGeometry(200, 200, 200, 16, 16, 16);
 
     // if normal and uv attributes are not removed, mergeVertices() can't consolidate identical vertices with different normal/uv data
 
@@ -38,8 +38,8 @@ function init() {
 
     const positionAttribute = boxGeometry.getAttribute('position');
 
-    const colors = [];
-    const sizes = [];
+    const colors: number[] = [];
+    const sizes: number[] = [];
 
     const color = new THREE.Color();
 
@@ -63,8 +63,8 @@ function init() {
             pointTexture: { value: new THREE.TextureLoader().load('textures/sprites/disc.png') },
             alphaTest: { value: 0.9 },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
     });
 
     //
@@ -96,7 +96,7 @@ function init() {
     document.addEventListener('pointermove', onPointerMove);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -126,9 +126,9 @@ function render() {
 
     if (intersects.length > 0) {
         if (INTERSECTED != intersects[0].index) {
-            attributes.size.array[INTERSECTED] = PARTICLE_SIZE;
+            attributes.size.array[INTERSECTED!] = PARTICLE_SIZE;
 
-            INTERSECTED = intersects[0].index;
+            INTERSECTED = intersects[0].index!;
 
             attributes.size.array[INTERSECTED] = PARTICLE_SIZE * 1.25;
             attributes.size.needsUpdate = true;
diff --git a/examples-testing/examples/webgl_interactive_raycasting_points.ts b/examples-testing/examples/webgl_interactive_raycasting_points.ts
index 41c158a43..bb1348189 100644
--- a/examples-testing/examples/webgl_interactive_raycasting_points.ts
+++ b/examples-testing/examples/webgl_interactive_raycasting_points.ts
@@ -2,16 +2,16 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let renderer, scene, camera, stats;
-let pointclouds;
-let raycaster;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
+let pointclouds: THREE.Points[];
+let raycaster: THREE.Raycaster;
 let intersection = null;
 let spheresIndex = 0;
-let clock;
+let clock: THREE.Clock;
 let toggle = 0;
 
 const pointer = new THREE.Vector2();
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
 const threshold = 0.1;
 const pointSize = 0.05;
@@ -21,7 +21,7 @@ const rotateY = new THREE.Matrix4().makeRotationY(0.005);
 
 init();
 
-function generatePointCloudGeometry(color, width, length) {
+function generatePointCloudGeometry(color: THREE.Color, width: number, length: number) {
     const geometry = new THREE.BufferGeometry();
     const numPoints = width * length;
 
@@ -58,14 +58,14 @@ function generatePointCloudGeometry(color, width, length) {
     return geometry;
 }
 
-function generatePointcloud(color, width, length) {
+function generatePointcloud(color: THREE.Color, width: number, length: number) {
     const geometry = generatePointCloudGeometry(color, width, length);
     const material = new THREE.PointsMaterial({ size: pointSize, vertexColors: true });
 
     return new THREE.Points(geometry, material);
 }
 
-function generateIndexedPointcloud(color, width, length) {
+function generateIndexedPointcloud(color: THREE.Color, width: number, length: number) {
     const geometry = generatePointCloudGeometry(color, width, length);
     const numPoints = width * length;
     const indices = new Uint16Array(numPoints);
@@ -86,7 +86,7 @@ function generateIndexedPointcloud(color, width, length) {
     return new THREE.Points(geometry, material);
 }
 
-function generateIndexedWithOffsetPointcloud(color, width, length) {
+function generateIndexedWithOffsetPointcloud(color: THREE.Color, width: number, length: number) {
     const geometry = generatePointCloudGeometry(color, width, length);
     const numPoints = width * length;
     const indices = new Uint16Array(numPoints);
@@ -109,7 +109,7 @@ function generateIndexedWithOffsetPointcloud(color, width, length) {
 }
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
 
@@ -174,7 +174,7 @@ function init() {
     document.addEventListener('pointermove', onPointerMove);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
diff --git a/examples-testing/examples/webgl_interactive_voxelpainter.ts b/examples-testing/examples/webgl_interactive_voxelpainter.ts
index 48b16f3b7..dae1d7589 100644
--- a/examples-testing/examples/webgl_interactive_voxelpainter.ts
+++ b/examples-testing/examples/webgl_interactive_voxelpainter.ts
@@ -1,15 +1,15 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
-let plane;
-let pointer,
-    raycaster,
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let plane: THREE.Mesh;
+let pointer: THREE.Vector2,
+    raycaster: THREE.Raycaster,
     isShiftDown = false;
 
-let rollOverMesh, rollOverMaterial;
-let cubeGeo, cubeMaterial;
+let rollOverMesh: THREE.Mesh, rollOverMaterial: THREE.MeshBasicMaterial;
+let cubeGeo: THREE.BoxGeometry, cubeMaterial: THREE.MeshLambertMaterial;
 
-const objects = [];
+const objects: THREE.Object3D[] = [];
 
 init();
 render();
@@ -87,7 +87,7 @@ function onWindowResize() {
     render();
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
 
     raycaster.setFromCamera(pointer, camera);
@@ -97,14 +97,14 @@ function onPointerMove(event) {
     if (intersects.length > 0) {
         const intersect = intersects[0];
 
-        rollOverMesh.position.copy(intersect.point).add(intersect.face.normal);
+        rollOverMesh.position.copy(intersect.point).add(intersect.face!.normal);
         rollOverMesh.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
 
         render();
     }
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     pointer.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
 
     raycaster.setFromCamera(pointer, camera);
@@ -126,7 +126,7 @@ function onPointerDown(event) {
             // create cube
         } else {
             const voxel = new THREE.Mesh(cubeGeo, cubeMaterial);
-            voxel.position.copy(intersect.point).add(intersect.face.normal);
+            voxel.position.copy(intersect.point).add(intersect.face!.normal);
             voxel.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
             scene.add(voxel);
 
@@ -137,7 +137,7 @@ function onPointerDown(event) {
     }
 }
 
-function onDocumentKeyDown(event) {
+function onDocumentKeyDown(event: KeyboardEvent) {
     switch (event.keyCode) {
         case 16:
             isShiftDown = true;
@@ -145,7 +145,7 @@ function onDocumentKeyDown(event) {
     }
 }
 
-function onDocumentKeyUp(event) {
+function onDocumentKeyUp(event: KeyboardEvent) {
     switch (event.keyCode) {
         case 16:
             isShiftDown = false;
diff --git a/examples-testing/examples/webgl_lensflares.ts b/examples-testing/examples/webgl_lensflares.ts
index 230cebfa0..56651e282 100644
--- a/examples-testing/examples/webgl_lensflares.ts
+++ b/examples-testing/examples/webgl_lensflares.ts
@@ -5,10 +5,10 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { FlyControls } from 'three/addons/controls/FlyControls.js';
 import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controls: FlyControls;
 
 const clock = new THREE.Clock();
 
@@ -70,7 +70,7 @@ function init() {
     addLight(0.08, 0.8, 0.5, 0, 0, -1000);
     addLight(0.995, 0.5, 0.9, 5000, 5000, -1000);
 
-    function addLight(h, s, l, x, y, z) {
+    function addLight(h: number, s: number, l: number, x: number, y: number, z: number) {
         const light = new THREE.PointLight(0xffffff, 1.5, 2000, 0);
         light.color.setHSL(h, s, l);
         light.position.set(x, y, z);
diff --git a/examples-testing/examples/webgl_lightprobe.ts b/examples-testing/examples/webgl_lightprobe.ts
index 58f021e6d..1427cce47 100644
--- a/examples-testing/examples/webgl_lightprobe.ts
+++ b/examples-testing/examples/webgl_lightprobe.ts
@@ -8,12 +8,15 @@ import { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js'
 
 import { LightProbeHelper } from 'three/addons/helpers/LightProbeHelper.js';
 
-let mesh, renderer, scene, camera;
+let mesh: THREE.Mesh<THREE.SphereGeometry, THREE.MeshStandardMaterial>,
+    renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera;
 
 let gui;
 
-let lightProbe;
-let directionalLight;
+let lightProbe: THREE.LightProbe;
+let directionalLight: THREE.DirectionalLight;
 
 // linear color space
 const API = {
@@ -58,7 +61,7 @@ function init() {
     scene.add(directionalLight);
 
     // envmap
-    const genCubeUrls = function (prefix, postfix) {
+    const genCubeUrls = function (prefix: string, postfix: string) {
         return [
             prefix + 'px' + postfix,
             prefix + 'nx' + postfix,
diff --git a/examples-testing/examples/webgl_lightprobe_cubecamera.ts b/examples-testing/examples/webgl_lightprobe_cubecamera.ts
index 65425d4e7..a9a0533ef 100644
--- a/examples-testing/examples/webgl_lightprobe_cubecamera.ts
+++ b/examples-testing/examples/webgl_lightprobe_cubecamera.ts
@@ -4,9 +4,9 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { LightProbeHelper } from 'three/addons/helpers/LightProbeHelper.js';
 import { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js';
 
-let renderer, scene, camera, cubeCamera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, cubeCamera: THREE.CubeCamera;
 
-let lightProbe;
+let lightProbe: THREE.LightProbe;
 
 init();
 
@@ -40,7 +40,7 @@ function init() {
     scene.add(lightProbe);
 
     // envmap
-    const genCubeUrls = function (prefix, postfix) {
+    const genCubeUrls = function (prefix: string, postfix: string) {
         return [
             prefix + 'px' + postfix,
             prefix + 'nx' + postfix,
diff --git a/examples-testing/examples/webgl_lights_hemisphere.ts b/examples-testing/examples/webgl_lights_hemisphere.ts
index 15bc76099..ef2538eec 100644
--- a/examples-testing/examples/webgl_lights_hemisphere.ts
+++ b/examples-testing/examples/webgl_lights_hemisphere.ts
@@ -5,16 +5,16 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let camera, scene, renderer;
-const mixers = [];
-let stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+const mixers: THREE.AnimationMixer[] = [];
+let stats: Stats;
 
 const clock = new THREE.Clock();
 
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 5000);
     camera.position.set(0, 0, 250);
@@ -74,8 +74,8 @@ function init() {
 
     // SKYDOME
 
-    const vertexShader = document.getElementById('vertexShader').textContent;
-    const fragmentShader = document.getElementById('fragmentShader').textContent;
+    const vertexShader = document.getElementById('vertexShader')!.textContent!;
+    const fragmentShader = document.getElementById('fragmentShader')!.textContent!;
     const uniforms = {
         topColor: { value: new THREE.Color(0x0077ff) },
         bottomColor: { value: new THREE.Color(0xffffff) },
diff --git a/examples-testing/examples/webgl_lights_physical.ts b/examples-testing/examples/webgl_lights_physical.ts
index 707ef200e..8e4cf0bbe 100644
--- a/examples-testing/examples/webgl_lights_physical.ts
+++ b/examples-testing/examples/webgl_lights_physical.ts
@@ -5,13 +5,19 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, bulbLight, bulbMat, hemiLight, stats;
-let ballMat, cubeMat, floorMat;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    bulbLight: THREE.PointLight,
+    bulbMat: THREE.MeshStandardMaterial,
+    hemiLight: THREE.HemisphereLight,
+    stats: Stats;
+let ballMat: THREE.MeshStandardMaterial, cubeMat: THREE.MeshStandardMaterial, floorMat: THREE.MeshStandardMaterial;
 
 let previousShadowMap = false;
 
 // ref for lumens: http://www.power-sure.com/lumens.htm
-const bulbLuminousPowers = {
+const bulbLuminousPowers: Record<string, number> = {
     '110000 lm (1000W)': 110000,
     '3500 lm (300W)': 3500,
     '1700 lm (100W)': 1700,
@@ -23,7 +29,7 @@ const bulbLuminousPowers = {
 };
 
 // ref for solar irradiances: https://en.wikipedia.org/wiki/Lux
-const hemiLuminousIrradiances = {
+const hemiLuminousIrradiances: Record<string, number> = {
     '0.0001 lx (Moonless Night)': 0.0001,
     '0.002 lx (Night Airglow)': 0.002,
     '0.5 lx (Full Moon)': 0.5,
@@ -47,7 +53,7 @@ const params = {
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     stats = new Stats();
     container.appendChild(stats.dom);
diff --git a/examples-testing/examples/webgl_lights_rectarealight.ts b/examples-testing/examples/webgl_lights_rectarealight.ts
index b841fa6b5..f3051618b 100644
--- a/examples-testing/examples/webgl_lights_rectarealight.ts
+++ b/examples-testing/examples/webgl_lights_rectarealight.ts
@@ -6,8 +6,8 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';
 import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
 
-let renderer, scene, camera;
-let stats, meshKnot;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let stats: Stats, meshKnot: THREE.Mesh;
 
 init();
 
@@ -70,7 +70,7 @@ function onWindowResize() {
     camera.updateProjectionMatrix();
 }
 
-function animation(time) {
+function animation(time: DOMHighResTimeStamp) {
     meshKnot.rotation.y = time / 1000;
 
     renderer.render(scene, camera);
diff --git a/examples-testing/examples/webgl_lights_spotlight.ts b/examples-testing/examples/webgl_lights_spotlight.ts
index 24d7d8c19..93318d4df 100644
--- a/examples-testing/examples/webgl_lights_spotlight.ts
+++ b/examples-testing/examples/webgl_lights_spotlight.ts
@@ -5,9 +5,9 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let renderer, scene, camera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
 
-let spotLight;
+let spotLight: THREE.SpotLight & { lightHelper?: THREE.SpotLightHelper; shadowCameraHelper?: THREE.CameraHelper };
 
 init();
 
@@ -45,7 +45,7 @@ function init() {
     const loader = new THREE.TextureLoader().setPath('textures/');
     const filenames = ['disturb.jpg', 'colors.png', 'uv_grid_opengl.jpg'];
 
-    const textures = { none: null };
+    const textures: Record<string, THREE.Texture | null> = { none: null };
 
     for (let i = 0; i < filenames.length; i++) {
         const filename = filenames[i];
@@ -176,8 +176,8 @@ function init() {
     });
 
     gui.add(params, 'helpers').onChange(function (val) {
-        spotLight.lightHelper.visible = val;
-        spotLight.shadowCameraHelper.visible = val;
+        spotLight.lightHelper!.visible = val;
+        spotLight.shadowCameraHelper!.visible = val;
     });
 
     gui.open();
@@ -196,7 +196,7 @@ function animate() {
     spotLight.position.x = Math.cos(time) * 2.5;
     spotLight.position.z = Math.sin(time) * 2.5;
 
-    spotLight.lightHelper.update();
+    spotLight.lightHelper!.update();
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl_lights_spotlights.ts b/examples-testing/examples/webgl_lights_spotlights.ts
index 70caf5a58..fc4817fbc 100644
--- a/examples-testing/examples/webgl_lights_spotlights.ts
+++ b/examples-testing/examples/webgl_lights_spotlights.ts
@@ -29,7 +29,7 @@ const spotLight1 = createSpotlight(0xff7f00);
 const spotLight2 = createSpotlight(0x00ff7f);
 const spotLight3 = createSpotlight(0x7f00ff);
 
-let lightHelper1, lightHelper2, lightHelper3;
+let lightHelper1: THREE.SpotLightHelper, lightHelper2: THREE.SpotLightHelper, lightHelper3: THREE.SpotLightHelper;
 
 function init() {
     renderer.shadowMap.enabled = true;
@@ -68,7 +68,7 @@ function init() {
     controls.update();
 }
 
-function createSpotlight(color) {
+function createSpotlight(color: number) {
     const newObj = new THREE.SpotLight(color, 10);
 
     newObj.castShadow = true;
@@ -86,7 +86,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function tween(light) {
+function tween(light: THREE.SpotLight) {
     new TWEEN.Tween(light)
         .to(
             {
diff --git a/examples-testing/examples/webgl_lines_colors.ts b/examples-testing/examples/webgl_lines_colors.ts
index 9da19ee2e..68bc979b0 100644
--- a/examples-testing/examples/webgl_lines_colors.ts
+++ b/examples-testing/examples/webgl_lines_colors.ts
@@ -8,7 +8,7 @@ let mouseX = 0,
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -110,7 +110,7 @@ function init() {
     const scale = 0.3,
         d = 225;
 
-    const parameters = [
+    const parameters: [THREE.Material, number, [number, number, number], THREE.BufferGeometry][] = [
         [material, scale * 1.5, [-d, -d / 2, 0], geometry1],
         [material, scale * 1.5, [0, -d / 2, 0], geometry2],
         [material, scale * 1.5, [d, -d / 2, 0], geometry3],
@@ -152,7 +152,7 @@ function onWindowResize() {
 
 //
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
@@ -172,7 +172,7 @@ function animate() {
     for (let i = 0; i < scene.children.length; i++) {
         const object = scene.children[i];
 
-        if (object.isLine) {
+        if ((object as THREE.Line).isLine) {
             object.rotation.y = time * (i % 2 ? 1 : -1);
         }
     }
diff --git a/examples-testing/examples/webgl_lines_dashed.ts b/examples-testing/examples/webgl_lines_dashed.ts
index 3e3ee3041..0c098cd5b 100644
--- a/examples-testing/examples/webgl_lines_dashed.ts
+++ b/examples-testing/examples/webgl_lines_dashed.ts
@@ -4,8 +4,8 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';
 
-let renderer, scene, camera, stats;
-const objects = [];
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
+const objects: THREE.Object3D[] = [];
 
 const WIDTH = window.innerWidth,
     HEIGHT = window.innerHeight;
@@ -63,7 +63,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function box(width, height, depth) {
+function box(width: number, height: number, depth: number) {
     ((width = width * 0.5), (height = height * 0.5), (depth = depth * 0.5));
 
     const geometry = new THREE.BufferGeometry();
@@ -176,7 +176,7 @@ function render() {
     const time = Date.now() * 0.001;
 
     scene.traverse(function (object) {
-        if (object.isLine) {
+        if ((object as THREE.Line).isLine) {
             object.rotation.x = 0.25 * time;
             object.rotation.y = 0.25 * time;
         }
diff --git a/examples-testing/examples/webgl_lines_fat.ts b/examples-testing/examples/webgl_lines_fat.ts
index 1587b2d82..5d95ccc6f 100644
--- a/examples-testing/examples/webgl_lines_fat.ts
+++ b/examples-testing/examples/webgl_lines_fat.ts
@@ -7,14 +7,19 @@ import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
 import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
 import * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';
 
-let line, renderer, scene, camera, camera2, controls;
-let line1;
-let matLine, matLineBasic, matLineDashed;
-let gui;
+let line: Line2,
+    renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    camera2: THREE.PerspectiveCamera,
+    controls: OrbitControls;
+let line1: THREE.Line;
+let matLine: LineMaterial, matLineBasic: THREE.LineBasicMaterial, matLineDashed: THREE.LineDashedMaterial;
+let gui: GUI;
 
 // viewport
-let insetWidth;
-let insetHeight;
+let insetWidth: number;
+let insetHeight: number;
 
 init();
 
diff --git a/examples-testing/examples/webgl_lines_fat_raycasting.ts b/examples-testing/examples/webgl_lines_fat_raycasting.ts
index 73dd71809..b2e1cf051 100644
--- a/examples-testing/examples/webgl_lines_fat_raycasting.ts
+++ b/examples-testing/examples/webgl_lines_fat_raycasting.ts
@@ -8,11 +8,12 @@ import { LineSegmentsGeometry } from 'three/addons/lines/LineSegmentsGeometry.js
 import { Line2 } from 'three/addons/lines/Line2.js';
 import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
 
-let line, thresholdLine, segments, thresholdSegments;
-let renderer, scene, camera, controls;
-let sphereInter, sphereOnLine;
-let gui;
-let clock;
+let line: Line2, thresholdLine: Line2, segments: LineSegments2, thresholdSegments: LineSegments2;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
+let sphereInter: THREE.Mesh<THREE.SphereGeometry, THREE.MeshBasicMaterial>,
+    sphereOnLine: THREE.Mesh<THREE.SphereGeometry, THREE.MeshBasicMaterial>;
+let gui: GUI;
+let clock: THREE.Clock;
 
 const color = new THREE.Color();
 
@@ -20,8 +21,7 @@ const pointer = new THREE.Vector2(Infinity, Infinity);
 
 const raycaster = new THREE.Raycaster();
 
-raycaster.params.Line2 = {};
-raycaster.params.Line2.threshold = 0;
+raycaster.params.Line2 = { threshold: 0 };
 
 const matLine = new LineMaterial({
     color: 0xffffff,
@@ -163,7 +163,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -192,9 +192,9 @@ function animate() {
         sphereOnLine.visible = true;
 
         sphereInter.position.copy(intersects[0].point);
-        sphereOnLine.position.copy(intersects[0].pointOnLine);
+        sphereOnLine.position.copy(intersects[0].pointOnLine!);
 
-        const index = intersects[0].faceIndex;
+        const index = intersects[0].faceIndex!;
         const colors = obj.geometry.getAttribute('instanceColorStart');
 
         color.fromBufferAttribute(colors, index);
@@ -214,7 +214,7 @@ function animate() {
 
 //
 
-function switchLine(val) {
+function switchLine(val: number) {
     switch (val) {
         case 0:
             line.visible = true;
@@ -259,7 +259,7 @@ function initGui() {
 
     gui.add(params, 'width', 1, 10).onChange(function (val) {
         matLine.linewidth = val;
-        matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2.threshold;
+        matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2!.threshold;
     });
 
     gui.add(params, 'alphaToCoverage').onChange(function (val) {
@@ -267,8 +267,8 @@ function initGui() {
     });
 
     gui.add(params, 'threshold', 0, 10).onChange(function (val) {
-        raycaster.params.Line2.threshold = val;
-        matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2.threshold;
+        raycaster.params.Line2!.threshold = val;
+        matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2!.threshold;
     });
 
     gui.add(params, 'translation', 0, 10).onChange(function (val) {
diff --git a/examples-testing/examples/webgl_lines_fat_wireframe.ts b/examples-testing/examples/webgl_lines_fat_wireframe.ts
index 59660ad7e..9f38fcb6d 100644
--- a/examples-testing/examples/webgl_lines_fat_wireframe.ts
+++ b/examples-testing/examples/webgl_lines_fat_wireframe.ts
@@ -8,15 +8,20 @@ import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
 import { Wireframe } from 'three/addons/lines/Wireframe.js';
 import { WireframeGeometry2 } from 'three/addons/lines/WireframeGeometry2.js';
 
-let wireframe, renderer, scene, camera, camera2, controls;
-let wireframe1;
-let matLine, matLineBasic, matLineDashed;
-let stats;
-let gui;
+let wireframe: Wireframe,
+    renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    camera2: THREE.PerspectiveCamera,
+    controls: OrbitControls;
+let wireframe1: THREE.LineSegments;
+let matLine: LineMaterial, matLineBasic: THREE.LineBasicMaterial, matLineDashed: THREE.LineDashedMaterial;
+let stats: Stats;
+let gui: GUI;
 
 // viewport
-let insetWidth;
-let insetHeight;
+let insetWidth: number;
+let insetHeight: number;
 
 init();
 
@@ -42,7 +47,7 @@ function init() {
 
     // Wireframe ( WireframeGeometry2, LineMaterial )
 
-    let geo = new THREE.IcosahedronGeometry(20, 1);
+    let geo: THREE.BufferGeometry = new THREE.IcosahedronGeometry(20, 1);
 
     const geometry = new WireframeGeometry2(geo);
 
diff --git a/examples-testing/examples/webgl_loader_3dm.ts b/examples-testing/examples/webgl_loader_3dm.ts
index 7570306fd..a363c2132 100644
--- a/examples-testing/examples/webgl_loader_3dm.ts
+++ b/examples-testing/examples/webgl_loader_3dm.ts
@@ -5,8 +5,8 @@ import { Rhino3dmLoader } from 'three/addons/loaders/3DMLoader.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
-let controls, gui;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controls: OrbitControls, gui: GUI;
 
 init();
 
@@ -38,7 +38,7 @@ function init() {
             initGUI(object.userData.layers);
 
             // hide spinner
-            document.getElementById('loader').style.display = 'none';
+            document.getElementById('loader')!.style.display = 'none';
         },
         function (progress) {
             console.log((progress.loaded / progress.total) * 100 + '%');
@@ -68,7 +68,7 @@ function animate() {
     renderer.render(scene, camera);
 }
 
-function initGUI(layers) {
+function initGUI(layers: { name: string; visible: boolean }[]) {
     gui = new GUI({ title: 'layers' });
 
     for (let i = 0; i < layers.length; i++) {
diff --git a/examples-testing/examples/webgl_loader_3ds.ts b/examples-testing/examples/webgl_loader_3ds.ts
index 10ce34076..ac3a6e232 100644
--- a/examples-testing/examples/webgl_loader_3ds.ts
+++ b/examples-testing/examples/webgl_loader_3ds.ts
@@ -3,8 +3,8 @@ import * as THREE from 'three';
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import { TDSLoader } from 'three/addons/loaders/TDSLoader.js';
 
-let container, controls;
-let camera, scene, renderer;
+let container: HTMLDivElement, controls: TrackballControls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -29,9 +29,9 @@ function init() {
     loader.setResourcePath('models/3ds/portalgun/textures/');
     loader.load('models/3ds/portalgun/portalgun.3ds', function (object) {
         object.traverse(function (child) {
-            if (child.isMesh) {
-                child.material.specular.setScalar(0.1);
-                child.material.normalMap = normal;
+            if ((child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).isMesh) {
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).material.specular.setScalar(0.1);
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).material.normalMap = normal;
             }
         });
 
diff --git a/examples-testing/examples/webgl_loader_3dtiles.ts b/examples-testing/examples/webgl_loader_3dtiles.ts
index bae36bc84..70aff0378 100644
--- a/examples-testing/examples/webgl_loader_3dtiles.ts
+++ b/examples-testing/examples/webgl_loader_3dtiles.ts
@@ -13,8 +13,8 @@ import {
 const ION_KEY =
     'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJiMTFiZTRmZS1mMWIxLTQ5YzYtYjA4Zi0xYTE0MjFmYzQ5OGYiLCJpZCI6MjY3NzgzLCJpYXQiOjE3MzY0NzQxMDh9.ppGPgpse1lq7QeNyljX7THUyK5w1x_4HksSHSlhe5sY';
 
-let camera, scene, renderer;
-let tiles, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let tiles: TilesRenderer, controls: GlobeControls;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_3mf.ts b/examples-testing/examples/webgl_loader_3mf.ts
index c31e32196..eecda516b 100644
--- a/examples-testing/examples/webgl_loader_3mf.ts
+++ b/examples-testing/examples/webgl_loader_3mf.ts
@@ -4,7 +4,12 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { ThreeMFLoader } from 'three/addons/loaders/3MFLoader.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, object, loader, controls;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    object: THREE.Group,
+    loader: ThreeMFLoader,
+    controls: OrbitControls;
 
 const params = {
     asset: 'cube_gears',
@@ -73,13 +78,18 @@ function init() {
     });
 }
 
-function loadAsset(asset) {
+function loadAsset(asset: string) {
     loader.load('models/3mf/' + asset + '.3mf', function (group) {
         if (object) {
             object.traverse(function (child) {
-                if (child.material) child.material.dispose();
-                if (child.material && child.material.map) child.material.map.dispose();
-                if (child.geometry) child.geometry.dispose();
+                if ((child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material)
+                    (child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.dispose();
+                if (
+                    (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material &&
+                    (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.map
+                )
+                    (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.map!.dispose();
+                if ((child as THREE.Mesh).geometry) (child as THREE.Mesh).geometry.dispose();
             });
 
             scene.remove(object);
diff --git a/examples-testing/examples/webgl_loader_3mf_materials.ts b/examples-testing/examples/webgl_loader_3mf_materials.ts
index fcdd7308e..3cfb49b44 100644
--- a/examples-testing/examples/webgl_loader_3mf_materials.ts
+++ b/examples-testing/examples/webgl_loader_3mf_materials.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { ThreeMFLoader } from 'three/addons/loaders/3MFLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_amf.ts b/examples-testing/examples/webgl_loader_amf.ts
index ee576e04f..7569a0448 100644
--- a/examples-testing/examples/webgl_loader_amf.ts
+++ b/examples-testing/examples/webgl_loader_amf.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { AMFLoader } from 'three/addons/loaders/AMFLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_bvh.ts b/examples-testing/examples/webgl_loader_bvh.ts
index 0be3add4d..cfdf0bc7f 100644
--- a/examples-testing/examples/webgl_loader_bvh.ts
+++ b/examples-testing/examples/webgl_loader_bvh.ts
@@ -5,8 +5,8 @@ import { BVHLoader } from 'three/addons/loaders/BVHLoader.js';
 
 const clock = new THREE.Clock();
 
-let camera, controls, scene, renderer;
-let mixer;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mixer: THREE.AnimationMixer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_collada.ts b/examples-testing/examples/webgl_loader_collada.ts
index 62588b698..e1e827714 100644
--- a/examples-testing/examples/webgl_loader_collada.ts
+++ b/examples-testing/examples/webgl_loader_collada.ts
@@ -4,13 +4,13 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { ColladaLoader } from 'three/addons/loaders/ColladaLoader.js';
 
-let container, stats, clock;
-let camera, scene, renderer, elf;
+let container: HTMLElement, stats: Stats, clock: THREE.Clock;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, elf: THREE.Scene;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
     camera.position.set(8, 10, 8);
diff --git a/examples-testing/examples/webgl_loader_collada_skinning.ts b/examples-testing/examples/webgl_loader_collada_skinning.ts
index 5cb808b17..7b2b57bd5 100644
--- a/examples-testing/examples/webgl_loader_collada_skinning.ts
+++ b/examples-testing/examples/webgl_loader_collada_skinning.ts
@@ -5,13 +5,13 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { ColladaLoader } from 'three/addons/loaders/ColladaLoader.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container, stats, clock, controls;
-let camera, scene, renderer, mixer;
+let container: HTMLElement, stats: Stats, clock: THREE.Clock, controls: OrbitControls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mixer: THREE.AnimationMixer;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 1, 1000);
     camera.position.set(15, 10, -15);
diff --git a/examples-testing/examples/webgl_loader_draco.ts b/examples-testing/examples/webgl_loader_draco.ts
index c9947c693..69bf22b48 100644
--- a/examples-testing/examples/webgl_loader_draco.ts
+++ b/examples-testing/examples/webgl_loader_draco.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-const container = document.querySelector('#container');
+const container = document.querySelector('#container')!;
 
 // Configure and create Draco decoder.
 const dracoLoader = new DRACOLoader();
diff --git a/examples-testing/examples/webgl_loader_fbx.ts b/examples-testing/examples/webgl_loader_fbx.ts
index ae1656e33..d41b05b8e 100644
--- a/examples-testing/examples/webgl_loader_fbx.ts
+++ b/examples-testing/examples/webgl_loader_fbx.ts
@@ -8,8 +8,14 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 const manager = new THREE.LoadingManager();
 
-let camera, scene, renderer, stats, object, loader, guiMorphsFolder;
-let mixer;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    object: THREE.Group,
+    loader: FBXLoader,
+    guiMorphsFolder: GUI;
+let mixer: THREE.AnimationMixer | null;
 
 const clock = new THREE.Clock();
 
@@ -89,23 +95,26 @@ function init() {
     guiMorphsFolder = gui.addFolder('Morphs').hide();
 }
 
-function loadAsset(asset) {
+function loadAsset(asset: string) {
     loader.load('models/fbx/' + asset + '.fbx', function (group) {
         if (object) {
             object.traverse(function (child) {
-                if (child.isSkinnedMesh) {
-                    child.skeleton.dispose();
+                if ((child as THREE.SkinnedMesh).isSkinnedMesh) {
+                    (child as THREE.SkinnedMesh).skeleton.dispose();
                 }
 
-                if (child.material) {
-                    const materials = Array.isArray(child.material) ? child.material : [child.material];
+                if ((child as THREE.Mesh).material) {
+                    const materials = Array.isArray((child as THREE.Mesh).material)
+                        ? (child as THREE.Mesh<THREE.BufferGeometry, THREE.Material[]>).material
+                        : [(child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material];
                     materials.forEach(material => {
-                        if (material.map) material.map.dispose();
+                        if ((material as THREE.MeshPhongMaterial).map)
+                            (material as THREE.MeshPhongMaterial).map!.dispose();
                         material.dispose();
                     });
                 }
 
-                if (child.geometry) child.geometry.dispose();
+                if ((child as THREE.Mesh).geometry) (child as THREE.Mesh).geometry.dispose();
             });
 
             scene.remove(object);
@@ -128,15 +137,21 @@ function loadAsset(asset) {
         guiMorphsFolder.hide();
 
         object.traverse(function (child) {
-            if (child.isMesh) {
+            if ((child as THREE.Mesh).isMesh) {
                 child.castShadow = true;
                 child.receiveShadow = true;
 
-                if (child.morphTargetDictionary) {
+                if ((child as THREE.Mesh).morphTargetDictionary) {
                     guiMorphsFolder.show();
                     const meshFolder = guiMorphsFolder.addFolder(child.name || child.uuid);
-                    Object.keys(child.morphTargetDictionary).forEach(key => {
-                        meshFolder.add(child.morphTargetInfluences, child.morphTargetDictionary[key], 0, 1, 0.01);
+                    Object.keys((child as THREE.Mesh).morphTargetDictionary!).forEach(key => {
+                        meshFolder.add(
+                            (child as THREE.Mesh).morphTargetInfluences!,
+                            (child as THREE.Mesh).morphTargetDictionary![key],
+                            0,
+                            1,
+                            0.01,
+                        );
                     });
                 }
             }
diff --git a/examples-testing/examples/webgl_loader_fbx_nurbs.ts b/examples-testing/examples/webgl_loader_fbx_nurbs.ts
index f2e45bcb5..c15264d71 100644
--- a/examples-testing/examples/webgl_loader_fbx_nurbs.ts
+++ b/examples-testing/examples/webgl_loader_fbx_nurbs.ts
@@ -5,7 +5,7 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_gcode.ts b/examples-testing/examples/webgl_loader_gcode.ts
index 6fd3e149d..79c642322 100644
--- a/examples-testing/examples/webgl_loader_gcode.ts
+++ b/examples-testing/examples/webgl_loader_gcode.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GCodeLoader } from 'three/addons/loaders/GCodeLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 render();
diff --git a/examples-testing/examples/webgl_loader_gltf.ts b/examples-testing/examples/webgl_loader_gltf.ts
index 52195156a..7d8ec71a1 100644
--- a/examples-testing/examples/webgl_loader_gltf.ts
+++ b/examples-testing/examples/webgl_loader_gltf.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_gltf_animation_pointer.ts b/examples-testing/examples/webgl_loader_gltf_animation_pointer.ts
index e54ef8f72..bce14b605 100644
--- a/examples-testing/examples/webgl_loader_gltf_animation_pointer.ts
+++ b/examples-testing/examples/webgl_loader_gltf_animation_pointer.ts
@@ -10,10 +10,10 @@ import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
 import { GLTFAnimationPointerExtension } from '@needle-tools/three-animation-pointer';
 
-let mixer;
+let mixer: THREE.AnimationMixer;
 
 const clock = new THREE.Clock();
-const container = document.getElementById('container');
+const container = document.getElementById('container')!;
 
 const stats = new Stats();
 container.appendChild(stats.dom);
diff --git a/examples-testing/examples/webgl_loader_gltf_anisotropy.ts b/examples-testing/examples/webgl_loader_gltf_anisotropy.ts
index ca6cfd39d..de8cde82f 100644
--- a/examples-testing/examples/webgl_loader_gltf_anisotropy.ts
+++ b/examples-testing/examples/webgl_loader_gltf_anisotropy.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
-let renderer, scene, camera, controls;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_gltf_avif.ts b/examples-testing/examples/webgl_loader_gltf_avif.ts
index 37d63859e..68dff97f2 100644
--- a/examples-testing/examples/webgl_loader_gltf_avif.ts
+++ b/examples-testing/examples/webgl_loader_gltf_avif.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 render();
diff --git a/examples-testing/examples/webgl_loader_gltf_compressed.ts b/examples-testing/examples/webgl_loader_gltf_compressed.ts
index 3bdcea8ec..c381c46df 100644
--- a/examples-testing/examples/webgl_loader_gltf_compressed.ts
+++ b/examples-testing/examples/webgl_loader_gltf_compressed.ts
@@ -7,7 +7,7 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
 import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 render();
diff --git a/examples-testing/examples/webgl_loader_gltf_dispersion.ts b/examples-testing/examples/webgl_loader_gltf_dispersion.ts
index 100badcab..bd16bf3b3 100644
--- a/examples-testing/examples/webgl_loader_gltf_dispersion.ts
+++ b/examples-testing/examples/webgl_loader_gltf_dispersion.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init().then(render);
 
diff --git a/examples-testing/examples/webgl_loader_gltf_instancing.ts b/examples-testing/examples/webgl_loader_gltf_instancing.ts
index 2966fbcbd..2f05edf1c 100644
--- a/examples-testing/examples/webgl_loader_gltf_instancing.ts
+++ b/examples-testing/examples/webgl_loader_gltf_instancing.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 render();
diff --git a/examples-testing/examples/webgl_loader_gltf_iridescence.ts b/examples-testing/examples/webgl_loader_gltf_iridescence.ts
index 5519835fe..6cfbb56c3 100644
--- a/examples-testing/examples/webgl_loader_gltf_iridescence.ts
+++ b/examples-testing/examples/webgl_loader_gltf_iridescence.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
-let renderer, scene, camera, controls;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
 
 init().catch(function (err) {
     console.error(err);
diff --git a/examples-testing/examples/webgl_loader_gltf_progressive_lod.ts b/examples-testing/examples/webgl_loader_gltf_progressive_lod.ts
index c09051e7d..f5b8e275b 100644
--- a/examples-testing/examples/webgl_loader_gltf_progressive_lod.ts
+++ b/examples-testing/examples/webgl_loader_gltf_progressive_lod.ts
@@ -5,8 +5,8 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 import { useNeedleProgressive } from '@needle-tools/gltf-progressive';
 
-let camera, scene, renderer, mixer;
-let airshipModel;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mixer: THREE.AnimationMixer;
+let airshipModel: THREE.Group;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_gltf_sheen.ts b/examples-testing/examples/webgl_loader_gltf_sheen.ts
index bd258d5c1..de9462865 100644
--- a/examples-testing/examples/webgl_loader_gltf_sheen.ts
+++ b/examples-testing/examples/webgl_loader_gltf_sheen.ts
@@ -6,7 +6,7 @@ import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
 
 init();
 
@@ -24,7 +24,10 @@ function init() {
     new GLTFLoader().setPath('models/gltf/').load('SheenChair.glb', function (gltf) {
         scene.add(gltf.scene);
 
-        const object = gltf.scene.getObjectByName('SheenChair_fabric');
+        const object = gltf.scene.getObjectByName('SheenChair_fabric') as THREE.Mesh<
+            THREE.BufferGeometry,
+            THREE.MeshPhysicalMaterial
+        >;
 
         const gui = new GUI();
 
diff --git a/examples-testing/examples/webgl_loader_gltf_transmission.ts b/examples-testing/examples/webgl_loader_gltf_transmission.ts
index 2c770e774..04d2acf53 100644
--- a/examples-testing/examples/webgl_loader_gltf_transmission.ts
+++ b/examples-testing/examples/webgl_loader_gltf_transmission.ts
@@ -6,7 +6,12 @@ import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 
-let camera, scene, renderer, controls, clock, mixer;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    controls: OrbitControls,
+    clock: THREE.Clock,
+    mixer: THREE.AnimationMixer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_imagebitmap.ts b/examples-testing/examples/webgl_loader_imagebitmap.ts
index 27c61b14d..4663b587b 100644
--- a/examples-testing/examples/webgl_loader_imagebitmap.ts
+++ b/examples-testing/examples/webgl_loader_imagebitmap.ts
@@ -1,7 +1,7 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
-let group, cubes;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let group: THREE.Group, cubes: THREE.Group;
 
 init();
 
@@ -15,7 +15,7 @@ function addImageBitmap() {
 
             // ImageBitmap should be disposed when done with it.
 
-            texture.onUpdate = disposeImageBitmap;
+            texture.onUpdate = disposeImageBitmap as (texture: THREE.Texture) => void;
 
             addCube(material);
         },
@@ -41,7 +41,7 @@ function addImage() {
 
 const geometry = new THREE.BoxGeometry();
 
-function addCube(material) {
+function addCube(material: THREE.MeshBasicMaterial) {
     const cube = new THREE.Mesh(geometry, material);
     cube.position.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
     cube.rotation.set(Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI);
@@ -107,7 +107,7 @@ function animate() {
     renderer.render(scene, camera);
 }
 
-function disposeImageBitmap(texture) {
+function disposeImageBitmap(texture: THREE.Texture<ImageBitmap>) {
     texture.source.data.close();
     texture.onUpdate = null; // make sure this callback is executed only once per texture
 }
diff --git a/examples-testing/examples/webgl_loader_kmz.ts b/examples-testing/examples/webgl_loader_kmz.ts
index f93555e41..8793a3511 100644
--- a/examples-testing/examples/webgl_loader_kmz.ts
+++ b/examples-testing/examples/webgl_loader_kmz.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { KMZLoader } from 'three/addons/loaders/KMZLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_lwo.ts b/examples-testing/examples/webgl_loader_lwo.ts
index fb10c8340..df003a04f 100644
--- a/examples-testing/examples/webgl_loader_lwo.ts
+++ b/examples-testing/examples/webgl_loader_lwo.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { LWOLoader } from 'three/addons/loaders/LWOLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_md2_control.ts b/examples-testing/examples/webgl_loader_md2_control.ts
index 683e4c2ad..845039ea2 100644
--- a/examples-testing/examples/webgl_loader_md2_control.ts
+++ b/examples-testing/examples/webgl_loader_md2_control.ts
@@ -9,10 +9,10 @@ import { Gyroscope } from 'three/addons/misc/Gyroscope.js';
 let SCREEN_WIDTH = window.innerWidth;
 let SCREEN_HEIGHT = window.innerHeight;
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-const characters = [];
+const characters: MD2CharacterComplex[] = [];
 let nCharacters = 0;
 
 let cameraControls;
@@ -76,10 +76,10 @@ function init() {
 
     const ground = new THREE.Mesh(gg, gm);
     ground.rotation.x = -Math.PI / 2;
-    ground.material.map.repeat.set(64, 64);
-    ground.material.map.wrapS = THREE.RepeatWrapping;
-    ground.material.map.wrapT = THREE.RepeatWrapping;
-    ground.material.map.colorSpace = THREE.SRGBColorSpace;
+    ground.material.map!.repeat.set(64, 64);
+    ground.material.map!.wrapS = THREE.RepeatWrapping;
+    ground.material.map!.wrapT = THREE.RepeatWrapping;
+    ground.material.map!.colorSpace = THREE.SRGBColorSpace;
     // note that because the ground does not cast a shadow, .castShadow is left false
     ground.receiveShadow = true;
 
@@ -212,7 +212,7 @@ function onWindowResize() {
     camera.updateProjectionMatrix();
 }
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     switch (event.code) {
         case 'ArrowUp':
         case 'KeyW':
@@ -241,7 +241,7 @@ function onKeyDown(event) {
     }
 }
 
-function onKeyUp(event) {
+function onKeyUp(event: KeyboardEvent) {
     switch (event.code) {
         case 'ArrowUp':
         case 'KeyW':
diff --git a/examples-testing/examples/webgl_loader_mdd.ts b/examples-testing/examples/webgl_loader_mdd.ts
index 5b13e8f4b..83aad15c8 100644
--- a/examples-testing/examples/webgl_loader_mdd.ts
+++ b/examples-testing/examples/webgl_loader_mdd.ts
@@ -2,7 +2,11 @@ import * as THREE from 'three';
 
 import { MDDLoader } from 'three/addons/loaders/MDDLoader.js';
 
-let camera, scene, renderer, mixer, clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    mixer: THREE.AnimationMixer,
+    clock: THREE.Clock;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_obj.ts b/examples-testing/examples/webgl_loader_obj.ts
index 42f1f3257..19ce70671 100644
--- a/examples-testing/examples/webgl_loader_obj.ts
+++ b/examples-testing/examples/webgl_loader_obj.ts
@@ -4,7 +4,7 @@ import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
 import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_pcd.ts b/examples-testing/examples/webgl_loader_pcd.ts
index dd0f0b0f5..e47005a81 100644
--- a/examples-testing/examples/webgl_loader_pcd.ts
+++ b/examples-testing/examples/webgl_loader_pcd.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { PCDLoader } from 'three/addons/loaders/PCDLoader.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 render();
@@ -30,7 +30,7 @@ function init() {
 
     const loader = new PCDLoader();
 
-    const loadPointCloud = function (file) {
+    const loadPointCloud = function (file: string) {
         loader.load('./models/pcd/' + file, function (points) {
             points.geometry.center();
             points.geometry.rotateX(Math.PI);
diff --git a/examples-testing/examples/webgl_loader_pdb.ts b/examples-testing/examples/webgl_loader_pdb.ts
index b560efa73..9882dff52 100644
--- a/examples-testing/examples/webgl_loader_pdb.ts
+++ b/examples-testing/examples/webgl_loader_pdb.ts
@@ -5,10 +5,10 @@ import { PDBLoader } from 'three/addons/loaders/PDBLoader.js';
 import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, labelRenderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, labelRenderer: CSS2DRenderer;
+let controls: TrackballControls;
 
-let root;
+let root: THREE.Group;
 
 const MOLECULES = {
     Ethanol: 'ethanol.pdb',
@@ -64,14 +64,14 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
     renderer.setAnimationLoop(animate);
-    document.getElementById('container').appendChild(renderer.domElement);
+    document.getElementById('container')!.appendChild(renderer.domElement);
 
     labelRenderer = new CSS2DRenderer();
     labelRenderer.setSize(window.innerWidth, window.innerHeight);
     labelRenderer.domElement.style.position = 'absolute';
     labelRenderer.domElement.style.top = '0px';
     labelRenderer.domElement.style.pointerEvents = 'none';
-    document.getElementById('container').appendChild(labelRenderer.domElement);
+    document.getElementById('container')!.appendChild(labelRenderer.domElement);
 
     //
 
@@ -97,12 +97,12 @@ function init() {
 
 //
 
-function loadMolecule(model) {
+function loadMolecule(model: string) {
     const url = 'models/pdb/' + model;
 
     while (root.children.length > 0) {
         const object = root.children[0];
-        object.parent.remove(object);
+        object.parent!.remove(object);
     }
 
     loader.load(url, function (pdb) {
@@ -114,7 +114,7 @@ function loadMolecule(model) {
         const sphereGeometry = new THREE.IcosahedronGeometry(1, 3);
 
         geometryAtoms.computeBoundingBox();
-        geometryAtoms.boundingBox.getCenter(offset).negate();
+        geometryAtoms.boundingBox!.getCenter(offset).negate();
 
         geometryAtoms.translate(offset.x, offset.y, offset.z);
         geometryBonds.translate(offset.x, offset.y, offset.z);
diff --git a/examples-testing/examples/webgl_loader_ply.ts b/examples-testing/examples/webgl_loader_ply.ts
index 0f4042b7d..dff17d169 100644
--- a/examples-testing/examples/webgl_loader_ply.ts
+++ b/examples-testing/examples/webgl_loader_ply.ts
@@ -4,9 +4,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, cameraTarget, scene, renderer;
+let camera: THREE.PerspectiveCamera, cameraTarget: THREE.Vector3, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -100,7 +100,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function addShadowedLight(x, y, z, color, intensity) {
+function addShadowedLight(x: number, y: number, z: number, color: number, intensity: number) {
     const directionalLight = new THREE.DirectionalLight(color, intensity);
     directionalLight.position.set(x, y, z);
     scene.add(directionalLight);
diff --git a/examples-testing/examples/webgl_loader_svg.ts b/examples-testing/examples/webgl_loader_svg.ts
index a04b79de2..48a055d41 100644
--- a/examples-testing/examples/webgl_loader_svg.ts
+++ b/examples-testing/examples/webgl_loader_svg.ts
@@ -3,14 +3,24 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
 
-let renderer, scene, camera, gui, guiData;
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    gui: GUI,
+    guiData: {
+        currentURL: string;
+        drawFillShapes: boolean;
+        drawStrokes: boolean;
+        fillShapesWireframe: boolean;
+        strokesWireframe: boolean;
+    };
 
 init();
 
 //
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     //
 
@@ -100,7 +110,7 @@ function createGUI() {
     }
 }
 
-function loadSVG(url) {
+function loadSVG(url: string) {
     //
 
     if (scene) disposeScene(scene);
@@ -130,12 +140,12 @@ function loadSVG(url) {
         let renderOrder = 0;
 
         for (const path of data.paths) {
-            const fillColor = path.userData.style.fill;
+            const fillColor = path.userData!.style.fill;
 
             if (guiData.drawFillShapes && fillColor !== undefined && fillColor !== 'none') {
                 const material = new THREE.MeshBasicMaterial({
                     color: new THREE.Color().setStyle(fillColor),
-                    opacity: path.userData.style.fillOpacity,
+                    opacity: path.userData!.style.fillOpacity,
                     transparent: true,
                     side: THREE.DoubleSide,
                     depthWrite: false,
@@ -153,12 +163,12 @@ function loadSVG(url) {
                 }
             }
 
-            const strokeColor = path.userData.style.stroke;
+            const strokeColor = path.userData!.style.stroke;
 
             if (guiData.drawStrokes && strokeColor !== undefined && strokeColor !== 'none') {
                 const material = new THREE.MeshBasicMaterial({
                     color: new THREE.Color().setStyle(strokeColor),
-                    opacity: path.userData.style.strokeOpacity,
+                    opacity: path.userData!.style.strokeOpacity,
                     transparent: true,
                     side: THREE.DoubleSide,
                     depthWrite: false,
@@ -166,7 +176,7 @@ function loadSVG(url) {
                 });
 
                 for (const subPath of path.subPaths) {
-                    const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style);
+                    const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData!.style);
 
                     if (geometry) {
                         const mesh = new THREE.Mesh(geometry, material);
@@ -196,11 +206,15 @@ function render() {
     renderer.render(scene, camera);
 }
 
-function disposeScene(scene) {
+function disposeScene(scene: THREE.Scene) {
     scene.traverse(function (object) {
-        if (object.isMesh || object.isLine) {
-            object.geometry.dispose();
-            object.material.dispose();
+        if ((object as THREE.Mesh).isMesh || (object as THREE.Line).isLine) {
+            (object as THREE.Mesh | THREE.Line).geometry.dispose();
+            (
+                object as
+                    | THREE.Mesh<THREE.BufferGeometry, THREE.Material>
+                    | THREE.Line<THREE.BufferGeometry, THREE.Material>
+            ).material.dispose();
         }
     });
 }
diff --git a/examples-testing/examples/webgl_loader_texture_dds.ts b/examples-testing/examples/webgl_loader_texture_dds.ts
index ba9b18e9d..d4161ff31 100644
--- a/examples-testing/examples/webgl_loader_texture_dds.ts
+++ b/examples-testing/examples/webgl_loader_texture_dds.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three';
 
 import { DDSLoader } from 'three/addons/loaders/DDSLoader.js';
 
-let camera, scene, renderer;
-const meshes = [];
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+const meshes: THREE.Mesh[] = [];
 
 init();
 
@@ -111,7 +111,7 @@ function init() {
     const material12 = new THREE.MeshBasicMaterial({ map: map10 });
     const material13 = new THREE.MeshBasicMaterial({ map: map11, transparent: true });
 
-    let mesh = new THREE.Mesh(new THREE.TorusGeometry(), material1);
+    let mesh: THREE.Mesh = new THREE.Mesh(new THREE.TorusGeometry(), material1);
     mesh.position.x = -10;
     mesh.position.y = -2;
     scene.add(mesh);
diff --git a/examples-testing/examples/webgl_loader_texture_ktx.ts b/examples-testing/examples/webgl_loader_texture_ktx.ts
index af66eb810..f7832073a 100644
--- a/examples-testing/examples/webgl_loader_texture_ktx.ts
+++ b/examples-testing/examples/webgl_loader_texture_ktx.ts
@@ -17,8 +17,8 @@ import { KTXLoader } from 'three/addons/loaders/KTXLoader.js';
 	ASTC_4x4, ASTC8x8 - transparent textures with full alpha range
 	*/
 
-let camera, scene, renderer;
-const meshes = [];
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+const meshes: THREE.Mesh[] = [];
 
 init();
 
@@ -51,14 +51,14 @@ function init() {
         material1 = new THREE.MeshBasicMaterial({
             map: loader.load('textures/compressed/disturb_PVR2bpp.ktx'),
         });
-        material1.map.colorSpace = THREE.SRGBColorSpace;
+        material1.map!.colorSpace = THREE.SRGBColorSpace;
         material2 = new THREE.MeshBasicMaterial({
             map: loader.load('textures/compressed/lensflare_PVR4bpp.ktx'),
             depthTest: false,
             transparent: true,
             side: THREE.DoubleSide,
         });
-        material2.map.colorSpace = THREE.SRGBColorSpace;
+        material2.map!.colorSpace = THREE.SRGBColorSpace;
 
         meshes.push(new THREE.Mesh(geometry, material1));
         meshes.push(new THREE.Mesh(geometry, material2));
@@ -68,14 +68,14 @@ function init() {
         material1 = new THREE.MeshBasicMaterial({
             map: loader.load('textures/compressed/disturb_BC1.ktx'),
         });
-        material1.map.colorSpace = THREE.SRGBColorSpace;
+        material1.map!.colorSpace = THREE.SRGBColorSpace;
         material2 = new THREE.MeshBasicMaterial({
             map: loader.load('textures/compressed/lensflare_BC3.ktx'),
             depthTest: false,
             transparent: true,
             side: THREE.DoubleSide,
         });
-        material2.map.colorSpace = THREE.SRGBColorSpace;
+        material2.map!.colorSpace = THREE.SRGBColorSpace;
 
         meshes.push(new THREE.Mesh(geometry, material1));
         meshes.push(new THREE.Mesh(geometry, material2));
@@ -93,14 +93,14 @@ function init() {
         material1 = new THREE.MeshBasicMaterial({
             map: loader.load('textures/compressed/disturb_ASTC4x4.ktx'),
         });
-        material1.map.colorSpace = THREE.SRGBColorSpace;
+        material1.map!.colorSpace = THREE.SRGBColorSpace;
         material2 = new THREE.MeshBasicMaterial({
             map: loader.load('textures/compressed/lensflare_ASTC8x8.ktx'),
             depthTest: false,
             transparent: true,
             side: THREE.DoubleSide,
         });
-        material2.map.colorSpace = THREE.SRGBColorSpace;
+        material2.map!.colorSpace = THREE.SRGBColorSpace;
 
         meshes.push(new THREE.Mesh(geometry, material1));
         meshes.push(new THREE.Mesh(geometry, material2));
diff --git a/examples-testing/examples/webgl_loader_texture_tga.ts b/examples-testing/examples/webgl_loader_texture_tga.ts
index c4f65b79a..fd6bab071 100644
--- a/examples-testing/examples/webgl_loader_texture_tga.ts
+++ b/examples-testing/examples/webgl_loader_texture_tga.ts
@@ -5,7 +5,7 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { TGALoader } from 'three/addons/loaders/TGALoader.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_texture_tiff.ts b/examples-testing/examples/webgl_loader_texture_tiff.ts
index f097774aa..bb5b9d9d9 100644
--- a/examples-testing/examples/webgl_loader_texture_tiff.ts
+++ b/examples-testing/examples/webgl_loader_texture_tiff.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 
 import { TIFFLoader } from 'three/addons/loaders/TIFFLoader.js';
 
-let renderer, scene, camera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_texture_ultrahdr.ts b/examples-testing/examples/webgl_loader_texture_ultrahdr.ts
index c8bce4bf9..a28a7f00b 100644
--- a/examples-testing/examples/webgl_loader_texture_ultrahdr.ts
+++ b/examples-testing/examples/webgl_loader_texture_ultrahdr.ts
@@ -5,7 +5,14 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { UltraHDRLoader } from 'three/addons/loaders/UltraHDRLoader.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-const params = {
+const params: {
+    autoRotate: boolean;
+    metalness: number;
+    roughness: number;
+    exposure: number;
+    resolution: '2k' | '4k';
+    type: 'HalfFloatType' | 'FloatType';
+} = {
     autoRotate: true,
     metalness: 1.0,
     roughness: 0.0,
@@ -14,7 +21,12 @@ const params = {
     type: 'HalfFloatType',
 };
 
-let renderer, scene, camera, controls, torusMesh, loader;
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    controls: OrbitControls,
+    torusMesh: THREE.Mesh<THREE.TorusKnotGeometry, THREE.MeshStandardMaterial>,
+    loader: UltraHDRLoader;
 
 init();
 
@@ -45,7 +57,10 @@ function init() {
     loader = new UltraHDRLoader();
     loader.setDataType(THREE.FloatType);
 
-    const loadEnvironment = function (resolution = '2k', type = 'HalfFloatType') {
+    const loadEnvironment = function (
+        resolution: '2k' | '4k' = '2k',
+        type: 'HalfFloatType' | 'FloatType' = 'HalfFloatType',
+    ) {
         loader.setDataType(THREE[type]);
 
         loader.load(`textures/equirectangular/spruit_sunrise_${resolution}.hdr.jpg`, function (texture) {
diff --git a/examples-testing/examples/webgl_loader_ttf.ts b/examples-testing/examples/webgl_loader_ttf.ts
index b54b8c290..40a692ebd 100644
--- a/examples-testing/examples/webgl_loader_ttf.ts
+++ b/examples-testing/examples/webgl_loader_ttf.ts
@@ -4,9 +4,9 @@ import { TTFLoader } from 'three/addons/loaders/TTFLoader.js';
 import { Font } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
-let container;
-let camera, cameraTarget, scene, renderer;
-let group, textMesh1, textMesh2, textGeo, material;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, cameraTarget: THREE.Vector3, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let group: THREE.Group, textMesh1: THREE.Mesh, textMesh2: THREE.Mesh, textGeo, material: THREE.MeshPhongMaterial;
 let firstLetter = true;
 
 let text = 'three.js';
@@ -17,7 +17,7 @@ const depth = 20,
     bevelThickness = 2,
     bevelSize = 1.5;
 
-let font = null;
+let font: Font | null = null;
 const mirror = true;
 
 let targetRotation = 0;
@@ -108,7 +108,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentKeyDown(event) {
+function onDocumentKeyDown(event: KeyboardEvent) {
     if (firstLetter) {
         firstLetter = false;
         text = '';
@@ -128,7 +128,7 @@ function onDocumentKeyDown(event) {
     }
 }
 
-function onDocumentKeyPress(event) {
+function onDocumentKeyPress(event: KeyboardEvent) {
     const keyCode = event.which;
 
     // backspace
@@ -145,7 +145,7 @@ function onDocumentKeyPress(event) {
 
 function createText() {
     textGeo = new TextGeometry(text, {
-        font: font,
+        font: font!,
 
         size: size,
         depth: depth,
@@ -159,7 +159,7 @@ function createText() {
     textGeo.computeBoundingBox();
     textGeo.computeVertexNormals();
 
-    const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
+    const centerOffset = -0.5 * (textGeo.boundingBox!.max.x - textGeo.boundingBox!.min.x);
 
     textMesh1 = new THREE.Mesh(textGeo, material);
 
@@ -195,7 +195,7 @@ function refreshText() {
     createText();
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerXOnPointerDown = event.clientX - windowHalfX;
@@ -205,7 +205,7 @@ function onPointerDown(event) {
     document.addEventListener('pointerup', onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerX = event.clientX - windowHalfX;
@@ -213,8 +213,8 @@ function onPointerMove(event) {
     targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
 }
 
-function onPointerUp(event) {
-    if (event.isPrimary === false) return;
+function onPointerUp(event: PointerEvent) {
+    if ((event as PointerEvent).isPrimary === false) return;
 
     document.removeEventListener('pointermove', onPointerMove);
     document.removeEventListener('pointerup', onPointerUp);
diff --git a/examples-testing/examples/webgl_loader_usdz.ts b/examples-testing/examples/webgl_loader_usdz.ts
index 409c6b597..dbde51b00 100644
--- a/examples-testing/examples/webgl_loader_usdz.ts
+++ b/examples-testing/examples/webgl_loader_usdz.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 import { USDLoader } from 'three/addons/loaders/USDLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_vox.ts b/examples-testing/examples/webgl_loader_vox.ts
index 061848012..1f9629e0b 100644
--- a/examples-testing/examples/webgl_loader_vox.ts
+++ b/examples-testing/examples/webgl_loader_vox.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { VOXLoader, VOXMesh } from 'three/addons/loaders/VOXLoader.js';
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_vrml.ts b/examples-testing/examples/webgl_loader_vrml.ts
index fecf4bb45..a6093ead7 100644
--- a/examples-testing/examples/webgl_loader_vrml.ts
+++ b/examples-testing/examples/webgl_loader_vrml.ts
@@ -6,7 +6,12 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { VRMLLoader } from 'three/addons/loaders/VRMLLoader.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, stats, controls, loader;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    controls: OrbitControls,
+    loader: VRMLLoader;
 
 const params = {
     asset: 'house',
@@ -29,7 +34,7 @@ const assets = [
     'points',
 ];
 
-let vrmlScene;
+let vrmlScene: THREE.Scene;
 
 init();
 
@@ -82,9 +87,14 @@ function init() {
     gui.add(params, 'asset', assets).onChange(function (value) {
         if (vrmlScene) {
             vrmlScene.traverse(function (object) {
-                if (object.material) object.material.dispose();
-                if (object.material && object.material.map) object.material.map.dispose();
-                if (object.geometry) object.geometry.dispose();
+                if ((object as THREE.Mesh).material)
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.dispose();
+                if (
+                    (object as THREE.Mesh).material &&
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).material.map
+                )
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).material.map!.dispose();
+                if ((object as THREE.Mesh).geometry) (object as THREE.Mesh).geometry.dispose();
             });
 
             scene.remove(vrmlScene);
@@ -94,7 +104,7 @@ function init() {
     });
 }
 
-function loadAsset(asset) {
+function loadAsset(asset: string) {
     loader.load('models/vrml/' + asset + '.wrl', function (object) {
         vrmlScene = object;
         scene.add(object);
diff --git a/examples-testing/examples/webgl_loader_vtk.ts b/examples-testing/examples/webgl_loader_vtk.ts
index dfc798657..de6983fb2 100644
--- a/examples-testing/examples/webgl_loader_vtk.ts
+++ b/examples-testing/examples/webgl_loader_vtk.ts
@@ -5,9 +5,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import { VTKLoader } from 'three/addons/loaders/VTKLoader.js';
 
-let stats;
+let stats: Stats;
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: TrackballControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_xyz.ts b/examples-testing/examples/webgl_loader_xyz.ts
index 90e009840..61ef0cf15 100644
--- a/examples-testing/examples/webgl_loader_xyz.ts
+++ b/examples-testing/examples/webgl_loader_xyz.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import { XYZLoader } from 'three/addons/loaders/XYZLoader.js';
 
-let camera, scene, renderer, clock;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
 
-let points;
+let points: THREE.Points;
 
 init();
 
diff --git a/examples-testing/examples/webgl_lod.ts b/examples-testing/examples/webgl_lod.ts
index 0bb9e7be0..bd1d0e469 100644
--- a/examples-testing/examples/webgl_lod.ts
+++ b/examples-testing/examples/webgl_lod.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import { FlyControls } from 'three/addons/controls/FlyControls.js';
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: FlyControls;
 
 const clock = new THREE.Clock();
 
@@ -28,7 +28,7 @@ function init() {
     dirLight.position.set(0, 0, 1).normalize();
     scene.add(dirLight);
 
-    const geometry = [
+    const geometry: [THREE.IcosahedronGeometry, number][] = [
         [new THREE.IcosahedronGeometry(100, 16), 50],
         [new THREE.IcosahedronGeometry(100, 8), 300],
         [new THREE.IcosahedronGeometry(100, 4), 1000],
diff --git a/examples-testing/examples/webgl_marchingcubes.ts b/examples-testing/examples/webgl_marchingcubes.ts
index d11df56a4..ea05a705b 100644
--- a/examples-testing/examples/webgl_marchingcubes.ts
+++ b/examples-testing/examples/webgl_marchingcubes.ts
@@ -7,17 +7,42 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { MarchingCubes } from 'three/addons/objects/MarchingCubes.js';
 import { ToonShader1, ToonShader2, ToonShaderHatching, ToonShaderDotted } from 'three/addons/shaders/ToonShader.js';
 
-let container, stats;
-
-let camera, scene, renderer;
-
-let materials, current_material;
-
-let light, pointLight, ambientLight;
-
-let effect, resolution;
-
-let effectController;
+let container: HTMLElement, stats: Stats;
+
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+
+type Material =
+    | 'shiny'
+    | 'chrome'
+    | 'liquid'
+    | 'matte'
+    | 'flat'
+    | 'textured'
+    | 'colors'
+    | 'multiColors'
+    | 'plastic'
+    | 'toon1'
+    | 'toon2'
+    | 'hatching'
+    | 'dotted';
+
+let materials: { [M in Material]: THREE.Material }, current_material: Material;
+
+let light: THREE.DirectionalLight, pointLight: THREE.PointLight, ambientLight: THREE.AmbientLight;
+
+let effect: MarchingCubes, resolution: number;
+
+let effectController: {
+    material: Material;
+    speed: number;
+    numBlobs: number;
+    resolution: number;
+    isolation: number;
+    floor: boolean;
+    wallx: boolean;
+    wallz: boolean;
+    dummy: () => void;
+} & { [M in Material]?: () => void };
 
 let time = 0;
 
@@ -26,7 +51,7 @@ const clock = new THREE.Clock();
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     // CAMERA
 
@@ -164,7 +189,11 @@ function generateMaterials() {
     return materials;
 }
 
-function createShaderMaterial(shader, light, ambientLight) {
+function createShaderMaterial(
+    shader: { uniforms: Record<string, THREE.IUniform>; vertexShader: string; fragmentShader: string },
+    light: THREE.DirectionalLight,
+    ambientLight: THREE.AmbientLight,
+) {
     const u = THREE.UniformsUtils.clone(shader.uniforms);
 
     const vs = shader.vertexShader;
@@ -183,7 +212,7 @@ function createShaderMaterial(shader, light, ambientLight) {
 //
 
 function setupGui() {
-    const createHandler = function (id) {
+    const createHandler = function (id: Material) {
         return function () {
             current_material = id;
 
@@ -217,8 +246,8 @@ function setupGui() {
     h = gui.addFolder('Materials');
 
     for (const m in materials) {
-        effectController[m] = createHandler(m);
-        h.add(effectController, m).name(m);
+        effectController[m as Material] = createHandler(m as Material);
+        h.add(effectController as Required<typeof effectController>, m as Material).name(m);
     }
 
     // simulation
@@ -237,7 +266,14 @@ function setupGui() {
 
 // this controls content of marching cubes voxel field
 
-function updateCubes(object, time, numblobs, floor, wallx, wallz) {
+function updateCubes(
+    object: MarchingCubes,
+    time: number,
+    numblobs: number,
+    floor: boolean,
+    wallx: boolean,
+    wallz: boolean,
+) {
     object.reset();
 
     // fill the field with some metaballs
diff --git a/examples-testing/examples/webgl_materials_alphahash.ts b/examples-testing/examples/webgl_materials_alphahash.ts
index 1ecf95f26..2373eb7e2 100644
--- a/examples-testing/examples/webgl_materials_alphahash.ts
+++ b/examples-testing/examples/webgl_materials_alphahash.ts
@@ -10,9 +10,15 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { TAARenderPass } from 'three/addons/postprocessing/TAARenderPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, scene, renderer, controls, stats, mesh, material;
-
-let composer, renderPass, taaRenderPass, outputPass;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    controls,
+    stats: Stats,
+    mesh: THREE.InstancedMesh,
+    material: THREE.MeshStandardMaterial;
+
+let composer: EffectComposer, renderPass: RenderPass, taaRenderPass: TAARenderPass, outputPass: OutputPass;
 
 let needsUpdate = false;
 
diff --git a/examples-testing/examples/webgl_materials_blending.ts b/examples-testing/examples/webgl_materials_blending.ts
index fb2e6a91e..6063485e3 100644
--- a/examples-testing/examples/webgl_materials_blending.ts
+++ b/examples-testing/examples/webgl_materials_blending.ts
@@ -1,7 +1,7 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
-let mapBg;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mapBg: THREE.CanvasTexture;
 
 const textureLoader = new THREE.TextureLoader();
 
@@ -20,7 +20,7 @@ function init() {
     // BACKGROUND
 
     const canvas = document.createElement('canvas');
-    const ctx = canvas.getContext('2d');
+    const ctx = canvas.getContext('2d')!;
     canvas.width = canvas.height = 128;
     ctx.fillStyle = '#ddd';
     ctx.fillRect(0, 0, 128, 128);
@@ -50,7 +50,7 @@ function init() {
         { name: 'Multiply', constant: THREE.MultiplyBlending },
     ];
 
-    const assignSRGB = texture => {
+    const assignSRGB = (texture: THREE.Texture) => {
         texture.colorSpace = THREE.SRGBColorSpace;
     };
 
@@ -69,7 +69,7 @@ function init() {
     addImageRow(map3, -150);
     addImageRow(map4, -300);
 
-    function addImageRow(map, y) {
+    function addImageRow(map: THREE.Texture, y: number) {
         for (let i = 0; i < blendings.length; i++) {
             const blending = blendings[i];
 
@@ -117,9 +117,9 @@ function onWindowResize() {
     camera.updateProjectionMatrix();
 }
 
-function generateLabelMaterial(text) {
+function generateLabelMaterial(text: string) {
     const canvas = document.createElement('canvas');
-    const ctx = canvas.getContext('2d');
+    const ctx = canvas.getContext('2d')!;
     canvas.width = 128;
     canvas.height = 32;
 
diff --git a/examples-testing/examples/webgl_materials_blending_custom.ts b/examples-testing/examples/webgl_materials_blending_custom.ts
index 072447426..62111971a 100644
--- a/examples-testing/examples/webgl_materials_blending_custom.ts
+++ b/examples-testing/examples/webgl_materials_blending_custom.ts
@@ -2,12 +2,12 @@ import * as THREE from 'three';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mapBg;
-const materials = [];
+let mapBg: THREE.CanvasTexture;
+const materials: THREE.Material[] = [];
 
-const params = {
+const params: { blendEquation: THREE.BlendingEquation } = {
     blendEquation: THREE.AddEquation,
 };
 
@@ -34,7 +34,7 @@ function init() {
     // BACKGROUND
 
     const canvas = document.createElement('canvas');
-    const ctx = canvas.getContext('2d');
+    const ctx = canvas.getContext('2d')!;
     canvas.width = canvas.height = 128;
     ctx.fillStyle = '#ddd';
     ctx.fillRect(0, 0, 128, 128);
@@ -177,9 +177,9 @@ function onWindowResize() {
 
 //
 
-function generateLabelMaterial(text, bg) {
+function generateLabelMaterial(text: string, bg: string) {
     const canvas = document.createElement('canvas');
-    const ctx = canvas.getContext('2d');
+    const ctx = canvas.getContext('2d')!;
     canvas.width = 128;
     canvas.height = 32;
 
@@ -197,7 +197,7 @@ function generateLabelMaterial(text, bg) {
     return material;
 }
 
-function updateBlendEquation(value) {
+function updateBlendEquation(value: THREE.BlendingEquation) {
     for (const material of materials) {
         material.blendEquation = value;
     }
diff --git a/examples-testing/examples/webgl_materials_bumpmap.ts b/examples-testing/examples/webgl_materials_bumpmap.ts
index a09c21573..00fe46b68 100644
--- a/examples-testing/examples/webgl_materials_bumpmap.ts
+++ b/examples-testing/examples/webgl_materials_bumpmap.ts
@@ -5,13 +5,13 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container, loader;
+let container: HTMLDivElement, loader: GLTFLoader;
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
 
-let mesh;
+let mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>;
 
-let spotLight;
+let spotLight: THREE.SpotLight;
 
 const params = {
     enableBumpMap: true,
@@ -67,7 +67,7 @@ function init() {
 
     loader = new GLTFLoader();
     loader.load('models/gltf/LeePerrySmith/LeePerrySmith.glb', function (gltf) {
-        createScene(gltf.scene.children[0].geometry, 1, material);
+        createScene((gltf.scene.children[0] as THREE.Mesh).geometry, 1, material);
     });
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -104,7 +104,7 @@ function init() {
     controls.enableDamping = true;
 }
 
-function createScene(geometry, scale, material) {
+function createScene(geometry: THREE.BufferGeometry, scale: number, material: THREE.MeshPhongMaterial) {
     mesh = new THREE.Mesh(geometry, material);
 
     mesh.position.y = -0.5;
diff --git a/examples-testing/examples/webgl_materials_car.ts b/examples-testing/examples/webgl_materials_car.ts
index 44be6e0ee..f3a7b9530 100644
--- a/examples-testing/examples/webgl_materials_car.ts
+++ b/examples-testing/examples/webgl_materials_car.ts
@@ -8,16 +8,16 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
-let camera, scene, renderer;
-let stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let stats: Stats;
 
-let grid;
-let controls;
+let grid: THREE.GridHelper;
+let controls: OrbitControls;
 
-const wheels = [];
+const wheels: THREE.Object3D[] = [];
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -78,17 +78,17 @@ function init() {
         transmission: 1.0,
     });
 
-    const bodyColorInput = document.getElementById('body-color');
+    const bodyColorInput = document.getElementById('body-color') as HTMLInputElement;
     bodyColorInput.addEventListener('input', function () {
         bodyMaterial.color.set(this.value);
     });
 
-    const detailsColorInput = document.getElementById('details-color');
+    const detailsColorInput = document.getElementById('details-color') as HTMLInputElement;
     detailsColorInput.addEventListener('input', function () {
         detailsMaterial.color.set(this.value);
     });
 
-    const glassColorInput = document.getElementById('glass-color');
+    const glassColorInput = document.getElementById('glass-color') as HTMLInputElement;
     glassColorInput.addEventListener('input', function () {
         glassMaterial.color.set(this.value);
     });
@@ -106,21 +106,21 @@ function init() {
     loader.load('models/gltf/ferrari.glb', function (gltf) {
         const carModel = gltf.scene.children[0];
 
-        carModel.getObjectByName('body').material = bodyMaterial;
+        (carModel.getObjectByName('body') as THREE.Mesh).material = bodyMaterial;
 
-        carModel.getObjectByName('rim_fl').material = detailsMaterial;
-        carModel.getObjectByName('rim_fr').material = detailsMaterial;
-        carModel.getObjectByName('rim_rr').material = detailsMaterial;
-        carModel.getObjectByName('rim_rl').material = detailsMaterial;
-        carModel.getObjectByName('trim').material = detailsMaterial;
+        (carModel.getObjectByName('rim_fl') as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName('rim_fr') as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName('rim_rr') as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName('rim_rl') as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName('trim') as THREE.Mesh).material = detailsMaterial;
 
-        carModel.getObjectByName('glass').material = glassMaterial;
+        (carModel.getObjectByName('glass') as THREE.Mesh).material = glassMaterial;
 
         wheels.push(
-            carModel.getObjectByName('wheel_fl'),
-            carModel.getObjectByName('wheel_fr'),
-            carModel.getObjectByName('wheel_rl'),
-            carModel.getObjectByName('wheel_rr'),
+            carModel.getObjectByName('wheel_fl')!,
+            carModel.getObjectByName('wheel_fr')!,
+            carModel.getObjectByName('wheel_rl')!,
+            carModel.getObjectByName('wheel_rr')!,
         );
 
         // shadow
diff --git a/examples-testing/examples/webgl_materials_cubemap.ts b/examples-testing/examples/webgl_materials_cubemap.ts
index 5f2692751..87044a874 100644
--- a/examples-testing/examples/webgl_materials_cubemap.ts
+++ b/examples-testing/examples/webgl_materials_cubemap.ts
@@ -5,9 +5,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let pointLight;
 
@@ -65,7 +65,7 @@ function init() {
 
     objLoader.setPath('models/obj/walt/');
     objLoader.load('WaltHead.obj', function (object) {
-        const head = object.children[0];
+        const head = object.children[0] as THREE.Mesh;
         head.scale.setScalar(0.1);
         head.position.y = -3;
         head.material = cubeMaterial1;
diff --git a/examples-testing/examples/webgl_materials_cubemap_dynamic.ts b/examples-testing/examples/webgl_materials_cubemap_dynamic.ts
index 301835dda..352e2bb7f 100644
--- a/examples-testing/examples/webgl_materials_cubemap_dynamic.ts
+++ b/examples-testing/examples/webgl_materials_cubemap_dynamic.ts
@@ -6,12 +6,12 @@ import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, stats;
-let cube, sphere, torus, material;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let cube: THREE.Mesh, sphere: THREE.Mesh, torus: THREE.Mesh, material: THREE.MeshStandardMaterial;
 
-let cubeCamera, cubeRenderTarget;
+let cubeCamera: THREE.CubeCamera, cubeRenderTarget: THREE.WebGLCubeRenderTarget;
 
-let controls;
+let controls: OrbitControls;
 
 init();
 
@@ -88,7 +88,7 @@ function onWindowResized() {
     camera.updateProjectionMatrix();
 }
 
-function animate(msTime) {
+function animate(msTime: DOMHighResTimeStamp) {
     const time = msTime / 1000;
 
     cube.position.x = Math.cos(time) * 30;
diff --git a/examples-testing/examples/webgl_materials_cubemap_mipmaps.ts b/examples-testing/examples/webgl_materials_cubemap_mipmaps.ts
index 944f4c18e..21010ffa4 100644
--- a/examples-testing/examples/webgl_materials_cubemap_mipmaps.ts
+++ b/examples-testing/examples/webgl_materials_cubemap_mipmaps.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -12,11 +12,11 @@ init();
 async function loadCubeTextureWithMipmaps() {
     const path = 'textures/cube/angus/';
     const format = '.jpg';
-    const mipmaps = [];
+    const mipmaps: THREE.CubeTexture[] = [];
     const maxLevel = 8;
 
-    async function loadCubeTexture(urls) {
-        return new Promise(function (resolve) {
+    async function loadCubeTexture(urls: string[]) {
+        return new Promise<THREE.CubeTexture>(function (resolve) {
             new THREE.CubeTextureLoader().load(urls, function (cubeTexture) {
                 resolve(cubeTexture);
             });
@@ -44,7 +44,7 @@ async function loadCubeTextureWithMipmaps() {
 
     await Promise.all(pendings);
 
-    const customizedCubeTexture = mipmaps.shift();
+    const customizedCubeTexture = mipmaps.shift()!;
     customizedCubeTexture.mipmaps = mipmaps;
     customizedCubeTexture.colorSpace = THREE.SRGBColorSpace;
     customizedCubeTexture.minFilter = THREE.LinearMipMapLinearFilter;
diff --git a/examples-testing/examples/webgl_materials_cubemap_refraction.ts b/examples-testing/examples/webgl_materials_cubemap_refraction.ts
index 8c025071f..a47c4832f 100644
--- a/examples-testing/examples/webgl_materials_cubemap_refraction.ts
+++ b/examples-testing/examples/webgl_materials_cubemap_refraction.ts
@@ -4,9 +4,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let mouseX = 0,
     mouseY = 0;
@@ -84,7 +84,12 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function createScene(geometry, m1, m2, m3) {
+function createScene(
+    geometry: THREE.BufferGeometry,
+    m1: THREE.MeshPhongMaterial,
+    m2: THREE.MeshPhongMaterial,
+    m3: THREE.MeshPhongMaterial,
+) {
     geometry.computeVertexNormals();
 
     const s = 1.5;
@@ -104,7 +109,7 @@ function createScene(geometry, m1, m2, m3) {
     scene.add(mesh);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) * 4;
     mouseY = (event.clientY - windowHalfY) * 4;
 }
diff --git a/examples-testing/examples/webgl_materials_cubemap_render_to_mipmaps.ts b/examples-testing/examples/webgl_materials_cubemap_render_to_mipmaps.ts
index 599a1369b..a23a0582c 100644
--- a/examples-testing/examples/webgl_materials_cubemap_render_to_mipmaps.ts
+++ b/examples-testing/examples/webgl_materials_cubemap_render_to_mipmaps.ts
@@ -1,8 +1,8 @@
 import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container;
-let camera, scene, renderer;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const CubemapFilterShader = {
     name: 'CubemapFilterShader',
@@ -55,15 +55,15 @@ const CubemapFilterShader = {
 
 init();
 
-async function loadCubeTexture(urls) {
-    return new Promise(function (resolve) {
+async function loadCubeTexture(urls: string[]) {
+    return new Promise<THREE.CubeTexture>(function (resolve) {
         new THREE.CubeTextureLoader().load(urls, function (cubeTexture) {
             resolve(cubeTexture);
         });
     });
 }
 
-function allocateCubemapRenderTarget(cubeMapSize) {
+function allocateCubemapRenderTarget(cubeMapSize: number) {
     const params = {
         magFilter: THREE.LinearFilter,
         minFilter: THREE.LinearMipMapLinearFilter,
@@ -77,13 +77,13 @@ function allocateCubemapRenderTarget(cubeMapSize) {
     const rt = new THREE.WebGLCubeRenderTarget(cubeMapSize, params);
 
     const mipLevels = Math.log(cubeMapSize) * Math.LOG2E + 1.0;
-    for (let i = 0; i < mipLevels; i++) rt.texture.mipmaps.push({});
+    for (let i = 0; i < mipLevels; i++) (rt.texture.mipmaps as THREE.CubeTexture[]).push({} as THREE.CubeTexture);
 
     rt.texture.mapping = THREE.CubeReflectionMapping;
     return rt;
 }
 
-function renderToCubeTexture(cubeMapRenderTarget, sourceCubeTexture) {
+function renderToCubeTexture(cubeMapRenderTarget: THREE.WebGLCubeRenderTarget, sourceCubeTexture: THREE.CubeTexture) {
     const geometry = new THREE.BoxGeometry(5, 5, 5);
 
     const material = new THREE.ShaderMaterial({
diff --git a/examples-testing/examples/webgl_materials_displacementmap.ts b/examples-testing/examples/webgl_materials_displacementmap.ts
index fd0be9a5e..9b08fe733 100644
--- a/examples-testing/examples/webgl_materials_displacementmap.ts
+++ b/examples-testing/examples/webgl_materials_displacementmap.ts
@@ -6,8 +6,8 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
 
-let stats;
-let camera, scene, renderer, controls;
+let stats: Stats;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
 
 const settings = {
     metalness: 1.0,
@@ -19,9 +19,9 @@ const settings = {
     normalScale: 1.0,
 };
 
-let mesh, material;
+let mesh, material: THREE.MeshStandardMaterial;
 
-let pointLight, ambientLight;
+let pointLight: THREE.PointLight, ambientLight: THREE.AmbientLight;
 
 const height = 500; // of camera frustum
 
@@ -173,7 +173,7 @@ function init() {
 
     const loader = new OBJLoader();
     loader.load('models/obj/ninja/ninjaHead_Low.obj', function (group) {
-        const geometry = group.children[0].geometry;
+        const geometry = (group.children[0] as THREE.Mesh).geometry;
         geometry.center();
 
         mesh = new THREE.Mesh(geometry, material);
diff --git a/examples-testing/examples/webgl_materials_envmaps.ts b/examples-testing/examples/webgl_materials_envmaps.ts
index 18a5542ed..13fe2efc9 100644
--- a/examples-testing/examples/webgl_materials_envmaps.ts
+++ b/examples-testing/examples/webgl_materials_envmaps.ts
@@ -3,9 +3,19 @@ import * as THREE from 'three';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let controls, camera, scene, renderer;
-let textureEquirec, textureCube;
-let sphereMesh, sphereMaterial, params;
+let controls: OrbitControls, camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let textureEquirec: THREE.Texture, textureCube: THREE.CubeTexture;
+let sphereMesh: THREE.Mesh<THREE.IcosahedronGeometry, THREE.MeshBasicMaterial>,
+    sphereMaterial: THREE.MeshBasicMaterial,
+    params: {
+        Cube: () => void;
+        Equirectangular: () => void;
+        Refraction: boolean;
+        backgroundRotationX: boolean;
+        backgroundRotationY: boolean;
+        backgroundRotationZ: boolean;
+        syncMaterial: boolean;
+    };
 
 init();
 
diff --git a/examples-testing/examples/webgl_materials_envmaps_exr.ts b/examples-testing/examples/webgl_materials_envmaps_exr.ts
index c3f3f4f7d..4ae4cb959 100644
--- a/examples-testing/examples/webgl_materials_envmaps_exr.ts
+++ b/examples-testing/examples/webgl_materials_envmaps_exr.ts
@@ -14,11 +14,12 @@ const params = {
     debug: false,
 };
 
-let container, stats;
-let camera, scene, renderer, controls;
-let torusMesh, planeMesh;
-let pngCubeRenderTarget, exrCubeRenderTarget;
-let pngBackground, exrBackground;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
+let torusMesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>,
+    planeMesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshBasicMaterial>;
+let pngCubeRenderTarget: THREE.WebGLRenderTarget, exrCubeRenderTarget: THREE.WebGLRenderTarget;
+let pngBackground: THREE.Texture, exrBackground: THREE.DataTexture;
 
 init();
 
@@ -42,8 +43,8 @@ function init() {
 
     //
 
-    let geometry = new THREE.TorusKnotGeometry(18, 8, 150, 20);
-    let material = new THREE.MeshStandardMaterial({
+    let geometry: THREE.BufferGeometry = new THREE.TorusKnotGeometry(18, 8, 150, 20);
+    let material: THREE.MeshStandardMaterial | THREE.MeshBasicMaterial = new THREE.MeshStandardMaterial({
         metalness: params.metalness,
         roughness: params.roughness,
         envMapIntensity: 1.0,
diff --git a/examples-testing/examples/webgl_materials_envmaps_fasthdr.ts b/examples-testing/examples/webgl_materials_envmaps_fasthdr.ts
index de8715eb7..18b6ed982 100644
--- a/examples-testing/examples/webgl_materials_envmaps_fasthdr.ts
+++ b/examples-testing/examples/webgl_materials_envmaps_fasthdr.ts
@@ -13,8 +13,8 @@ const params = {
     backgroundBlurriness: 0.0,
 };
 
-let container, stats;
-let camera, scene, renderer, controls;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
 
 init();
 
@@ -96,7 +96,7 @@ function init() {
 
     const loader = new KTX2Loader().setTranscoderPath('jsm/libs/basis/').detectSupport(renderer);
 
-    function loadTexture(url) {
+    function loadTexture(url: string) {
         loader.load(url, texture => {
             texture.mapping = THREE.CubeUVReflectionMapping;
             scene.environment = texture;
diff --git a/examples-testing/examples/webgl_materials_envmaps_groundprojected.ts b/examples-testing/examples/webgl_materials_envmaps_groundprojected.ts
index c1e0ed83b..f7acbbb3a 100644
--- a/examples-testing/examples/webgl_materials_envmaps_groundprojected.ts
+++ b/examples-testing/examples/webgl_materials_envmaps_groundprojected.ts
@@ -13,7 +13,7 @@ const params = {
     enabled: true,
 };
 
-let camera, scene, renderer, skybox;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, skybox: GroundedSkybox;
 
 init().then(render);
 
@@ -68,15 +68,15 @@ async function init() {
         carModel.scale.multiplyScalar(4);
         carModel.rotation.y = Math.PI;
 
-        carModel.getObjectByName('body').material = bodyMaterial;
+        (carModel.getObjectByName('body') as THREE.Mesh).material = bodyMaterial;
 
-        carModel.getObjectByName('rim_fl').material = detailsMaterial;
-        carModel.getObjectByName('rim_fr').material = detailsMaterial;
-        carModel.getObjectByName('rim_rr').material = detailsMaterial;
-        carModel.getObjectByName('rim_rl').material = detailsMaterial;
-        carModel.getObjectByName('trim').material = detailsMaterial;
+        (carModel.getObjectByName('rim_fl') as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName('rim_fr') as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName('rim_rr') as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName('rim_rl') as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName('trim') as THREE.Mesh).material = detailsMaterial;
 
-        carModel.getObjectByName('glass').material = glassMaterial;
+        (carModel.getObjectByName('glass') as THREE.Mesh).material = glassMaterial;
 
         // shadow
         const mesh = new THREE.Mesh(
diff --git a/examples-testing/examples/webgl_materials_envmaps_hdr.ts b/examples-testing/examples/webgl_materials_envmaps_hdr.ts
index 2dc2b808a..31851f3d4 100644
--- a/examples-testing/examples/webgl_materials_envmaps_hdr.ts
+++ b/examples-testing/examples/webgl_materials_envmaps_hdr.ts
@@ -7,7 +7,13 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';
 import { DebugEnvironment } from 'three/addons/environments/DebugEnvironment.js';
 
-const params = {
+const params: {
+    envMap: 'Generated' | 'LDR' | 'HDR';
+    roughness: number;
+    metalness: number;
+    exposure: number;
+    debug: boolean;
+} = {
     envMap: 'HDR',
     roughness: 0.0,
     metalness: 0.0,
@@ -15,11 +21,14 @@ const params = {
     debug: false,
 };
 
-let container, stats;
-let camera, scene, renderer, controls;
-let torusMesh, planeMesh;
-let generatedCubeRenderTarget, ldrCubeRenderTarget, hdrCubeRenderTarget;
-let ldrCubeMap, hdrCubeMap;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
+let torusMesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>,
+    planeMesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshBasicMaterial>;
+let generatedCubeRenderTarget: THREE.WebGLRenderTarget,
+    ldrCubeRenderTarget: THREE.WebGLRenderTarget,
+    hdrCubeRenderTarget: THREE.WebGLRenderTarget;
+let ldrCubeMap: THREE.CubeTexture, hdrCubeMap: THREE.CubeTexture;
 
 init();
 
@@ -38,9 +47,9 @@ function init() {
 
     //
 
-    let geometry = new THREE.TorusKnotGeometry(18, 8, 150, 20);
+    let geometry: THREE.BufferGeometry = new THREE.TorusKnotGeometry(18, 8, 150, 20);
     // let geometry = new THREE.SphereGeometry( 26, 64, 32 );
-    let material = new THREE.MeshStandardMaterial({
+    let material: THREE.MeshStandardMaterial | THREE.MeshBasicMaterial = new THREE.MeshStandardMaterial({
         color: 0xffffff,
         metalness: params.metalness,
         roughness: params.roughness,
diff --git a/examples-testing/examples/webgl_materials_modified.ts b/examples-testing/examples/webgl_materials_modified.ts
index de36aeb7d..778aedd59 100644
--- a/examples-testing/examples/webgl_materials_modified.ts
+++ b/examples-testing/examples/webgl_materials_modified.ts
@@ -5,7 +5,7 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 
@@ -17,7 +17,7 @@ function init() {
 
     const loader = new GLTFLoader();
     loader.load('models/gltf/LeePerrySmith/LeePerrySmith.glb', function (gltf) {
-        const geometry = gltf.scene.children[0].geometry;
+        const geometry = (gltf.scene.children[0] as THREE.Mesh).geometry;
 
         let mesh = new THREE.Mesh(geometry, buildTwistMaterial(2.0));
         mesh.position.x = -3.5;
@@ -50,7 +50,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function buildTwistMaterial(amount) {
+function buildTwistMaterial(amount: number) {
     const material = new THREE.MeshNormalMaterial();
     material.onBeforeCompile = function (shader) {
         shader.uniforms.time = { value: 0 };
@@ -102,8 +102,8 @@ function animate() {
 
 function render() {
     scene.traverse(function (child) {
-        if (child.isMesh) {
-            const shader = child.material.userData.shader;
+        if ((child as THREE.Mesh).isMesh) {
+            const shader = ((child as THREE.Mesh).material as THREE.Material).userData.shader;
 
             if (shader) {
                 shader.uniforms.time.value = performance.now() / 1000;
diff --git a/examples-testing/examples/webgl_materials_normalmap_object_space.ts b/examples-testing/examples/webgl_materials_normalmap_object_space.ts
index 1fc6f8066..72108134a 100644
--- a/examples-testing/examples/webgl_materials_normalmap_object_space.ts
+++ b/examples-testing/examples/webgl_materials_normalmap_object_space.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let renderer, scene, camera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
 
 init();
 
@@ -38,19 +38,23 @@ function init() {
     // model
     new GLTFLoader().load('models/gltf/Nefertiti/Nefertiti.glb', function (gltf) {
         gltf.scene.traverse(function (child) {
-            if (child.isMesh) {
+            if ((child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).isMesh) {
                 // glTF currently supports only tangent-space normal maps.
                 // this model has been modified to demonstrate the use of an object-space normal map.
 
-                child.material.normalMapType = THREE.ObjectSpaceNormalMap;
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.normalMapType =
+                    THREE.ObjectSpaceNormalMap;
 
                 // attribute normals are not required with an object-space normal map. remove them.
 
-                child.geometry.deleteAttribute('normal');
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).geometry.deleteAttribute(
+                    'normal',
+                );
 
                 //
 
-                child.material.side = THREE.DoubleSide;
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.side =
+                    THREE.DoubleSide;
 
                 child.scale.multiplyScalar(0.5);
 
diff --git a/examples-testing/examples/webgl_materials_physical_clearcoat.ts b/examples-testing/examples/webgl_materials_physical_clearcoat.ts
index 408fd9921..dc782ea9e 100644
--- a/examples-testing/examples/webgl_materials_physical_clearcoat.ts
+++ b/examples-testing/examples/webgl_materials_physical_clearcoat.ts
@@ -7,12 +7,12 @@ import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.
 
 import { FlakesTexture } from 'three/addons/textures/FlakesTexture.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let particleLight;
-let group;
+let particleLight: THREE.Mesh;
+let group: THREE.Group;
 
 init();
 
diff --git a/examples-testing/examples/webgl_materials_physical_transmission.ts b/examples-testing/examples/webgl_materials_physical_transmission.ts
index 070775cc3..c7a39d572 100644
--- a/examples-testing/examples/webgl_materials_physical_transmission.ts
+++ b/examples-testing/examples/webgl_materials_physical_transmission.ts
@@ -20,7 +20,7 @@ const params = {
     transmissionResolutionScale: 1,
 };
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let mesh;
 
@@ -178,7 +178,7 @@ function generateTexture() {
     canvas.width = 2;
     canvas.height = 2;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     context.fillStyle = 'white';
     context.fillRect(0, 1, 2, 1);
 
diff --git a/examples-testing/examples/webgl_materials_physical_transmission_alpha.ts b/examples-testing/examples/webgl_materials_physical_transmission_alpha.ts
index f4af7eebd..a02f075b6 100644
--- a/examples-testing/examples/webgl_materials_physical_transmission_alpha.ts
+++ b/examples-testing/examples/webgl_materials_physical_transmission_alpha.ts
@@ -22,17 +22,20 @@ const params = {
     exposure: 1,
 };
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh, material;
+let mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhysicalMaterial>, material: THREE.MeshPhysicalMaterial;
 
 const hdrEquirect = new HDRLoader().setPath('textures/equirectangular/').load('royal_esplanade_1k.hdr', function () {
     hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;
 
     new GLTFLoader().setPath('models/gltf/').load('DragonAttenuation.glb', function (gltf) {
         gltf.scene.traverse(function (child) {
-            if (child.isMesh && child.material.isMeshPhysicalMaterial) {
-                mesh = child;
+            if (
+                (child as THREE.Mesh).isMesh &&
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhysicalMaterial>).material.isMeshPhysicalMaterial
+            ) {
+                mesh = child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhysicalMaterial>;
                 material = mesh.material;
 
                 const color = new THREE.Color();
@@ -74,7 +77,7 @@ function init() {
 
     // accommodate CSS table
     renderer.domElement.style.position = 'absolute';
-    renderer.domElement.style.top = 0;
+    renderer.domElement.style.top = '0';
 
     scene = new THREE.Scene();
 
diff --git a/examples-testing/examples/webgl_materials_texture_anisotropy.ts b/examples-testing/examples/webgl_materials_texture_anisotropy.ts
index 1e030d64d..65577721c 100644
--- a/examples-testing/examples/webgl_materials_texture_anisotropy.ts
+++ b/examples-testing/examples/webgl_materials_texture_anisotropy.ts
@@ -5,9 +5,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 const SCREEN_WIDTH = window.innerWidth;
 const SCREEN_HEIGHT = window.innerHeight;
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene1, scene2, renderer;
+let camera: THREE.PerspectiveCamera, scene1: THREE.Scene, scene2: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let mouseX = 0,
     mouseY = 0;
@@ -70,11 +70,11 @@ function init() {
     texture2.repeat.set(512, 512);
 
     if (maxAnisotropy > 0) {
-        document.getElementById('val_left').innerHTML = texture1.anisotropy;
-        document.getElementById('val_right').innerHTML = texture2.anisotropy;
+        document.getElementById('val_left')!.innerHTML = texture1.anisotropy.toString();
+        document.getElementById('val_right')!.innerHTML = texture2.anisotropy.toString();
     } else {
-        document.getElementById('val_left').innerHTML = 'not supported';
-        document.getElementById('val_right').innerHTML = 'not supported';
+        document.getElementById('val_left')!.innerHTML = 'not supported';
+        document.getElementById('val_right')!.innerHTML = 'not supported';
     }
 
     //
@@ -110,7 +110,7 @@ function init() {
     document.addEventListener('mousemove', onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgl_materials_texture_canvas.ts b/examples-testing/examples/webgl_materials_texture_canvas.ts
index d23c68436..5a190fab0 100644
--- a/examples-testing/examples/webgl_materials_texture_canvas.ts
+++ b/examples-testing/examples/webgl_materials_texture_canvas.ts
@@ -1,6 +1,10 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer, mesh, material;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    mesh: THREE.Mesh,
+    material: THREE.MeshBasicMaterial;
 const drawStartPos = new THREE.Vector2();
 
 init();
@@ -31,8 +35,8 @@ function init() {
 function setupCanvasDrawing() {
     // get canvas and context
 
-    const drawingCanvas = document.getElementById('drawing-canvas');
-    const drawingContext = drawingCanvas.getContext('2d');
+    const drawingCanvas = document.getElementById('drawing-canvas') as HTMLCanvasElement;
+    const drawingContext = drawingCanvas.getContext('2d')!;
 
     // draw white background
 
@@ -66,7 +70,7 @@ function setupCanvasDrawing() {
     });
 }
 
-function draw(drawContext, x, y) {
+function draw(drawContext: CanvasRenderingContext2D, x: number, y: number) {
     drawContext.moveTo(drawStartPos.x, drawStartPos.y);
     drawContext.strokeStyle = '#000000';
     drawContext.lineTo(x, y);
@@ -74,7 +78,7 @@ function draw(drawContext, x, y) {
     // reset drawing start position to current position.
     drawStartPos.set(x, y);
     // need to flag the map as needing updating.
-    material.map.needsUpdate = true;
+    material.map!.needsUpdate = true;
 }
 
 function onWindowResize() {
diff --git a/examples-testing/examples/webgl_materials_texture_filters.ts b/examples-testing/examples/webgl_materials_texture_filters.ts
index 77b254684..b2ccb7690 100644
--- a/examples-testing/examples/webgl_materials_texture_filters.ts
+++ b/examples-testing/examples/webgl_materials_texture_filters.ts
@@ -3,9 +3,9 @@ import * as THREE from 'three';
 const SCREEN_WIDTH = window.innerWidth;
 const SCREEN_HEIGHT = window.innerHeight;
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, scene2, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, scene2: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let mouseX = 0,
     mouseY = 0;
@@ -33,7 +33,7 @@ function init() {
     // GROUND
 
     const imageCanvas = document.createElement('canvas');
-    const context = imageCanvas.getContext('2d');
+    const context = imageCanvas.getContext('2d')!;
 
     imageCanvas.width = imageCanvas.height = 128;
 
@@ -86,7 +86,7 @@ function init() {
         addPainting(scene, mesh);
         addPainting(scene2, mesh2);
 
-        function addPainting(zscene, zmesh) {
+        function addPainting(zscene: THREE.Scene, zmesh: THREE.Mesh) {
             zmesh.scale.x = image.width / 100;
             zmesh.scale.y = image.height / 100;
 
@@ -141,7 +141,7 @@ function init() {
     document.addEventListener('mousemove', onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgl_materials_texture_manualmipmap.ts b/examples-testing/examples/webgl_materials_texture_manualmipmap.ts
index 24bd4eb9f..2dad75e8e 100644
--- a/examples-testing/examples/webgl_materials_texture_manualmipmap.ts
+++ b/examples-testing/examples/webgl_materials_texture_manualmipmap.ts
@@ -3,9 +3,9 @@ import * as THREE from 'three';
 const SCREEN_WIDTH = window.innerWidth;
 const SCREEN_HEIGHT = window.innerHeight;
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene1, scene2, renderer;
+let camera: THREE.PerspectiveCamera, scene1: THREE.Scene, scene2: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let mouseX = 0,
     mouseY = 0;
@@ -32,9 +32,9 @@ function init() {
 
     // GROUND
 
-    function mipmap(size, color) {
+    function mipmap(size: number, color: string) {
         const imageCanvas = document.createElement('canvas');
-        const context = imageCanvas.getContext('2d');
+        const context = imageCanvas.getContext('2d')!;
 
         imageCanvas.width = imageCanvas.height = size;
 
@@ -49,14 +49,14 @@ function init() {
 
     const canvas = mipmap(128, '#f00');
     const textureCanvas1 = new THREE.CanvasTexture(canvas);
-    textureCanvas1.mipmaps[0] = canvas;
-    textureCanvas1.mipmaps[1] = mipmap(64, '#0f0');
-    textureCanvas1.mipmaps[2] = mipmap(32, '#00f');
-    textureCanvas1.mipmaps[3] = mipmap(16, '#400');
-    textureCanvas1.mipmaps[4] = mipmap(8, '#040');
-    textureCanvas1.mipmaps[5] = mipmap(4, '#004');
-    textureCanvas1.mipmaps[6] = mipmap(2, '#044');
-    textureCanvas1.mipmaps[7] = mipmap(1, '#404');
+    textureCanvas1.mipmaps![0] = canvas;
+    textureCanvas1.mipmaps![1] = mipmap(64, '#0f0');
+    textureCanvas1.mipmaps![2] = mipmap(32, '#00f');
+    textureCanvas1.mipmaps![3] = mipmap(16, '#400');
+    textureCanvas1.mipmaps![4] = mipmap(8, '#040');
+    textureCanvas1.mipmaps![5] = mipmap(4, '#004');
+    textureCanvas1.mipmaps![6] = mipmap(2, '#044');
+    textureCanvas1.mipmaps![7] = mipmap(1, '#404');
     textureCanvas1.colorSpace = THREE.SRGBColorSpace;
     textureCanvas1.repeat.set(1000, 1000);
     textureCanvas1.wrapS = THREE.RepeatWrapping;
@@ -97,7 +97,7 @@ function init() {
         addPainting(scene1, mesh1);
         addPainting(scene2, mesh2);
 
-        function addPainting(zscene, zmesh) {
+        function addPainting(zscene: THREE.Scene, zmesh: THREE.Mesh) {
             zmesh.scale.x = image.width / 100;
             zmesh.scale.y = image.height / 100;
 
@@ -151,7 +151,7 @@ function init() {
     document.addEventListener('mousemove', onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgl_materials_texture_partialupdate.ts b/examples-testing/examples/webgl_materials_texture_partialupdate.ts
index 5adfc8e69..6f3772f04 100644
--- a/examples-testing/examples/webgl_materials_texture_partialupdate.ts
+++ b/examples-testing/examples/webgl_materials_texture_partialupdate.ts
@@ -1,6 +1,11 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer, clock, dataTexture, diffuseMap;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    dataTexture: THREE.DataTexture,
+    diffuseMap: THREE.Texture;
 
 let last = 0;
 const position = new THREE.Vector2();
@@ -77,9 +82,9 @@ function animate() {
     renderer.render(scene, camera);
 }
 
-function updateDataTexture(texture) {
+function updateDataTexture(texture: THREE.DataTexture) {
     const size = texture.image.width * texture.image.height;
-    const data = texture.image.data;
+    const data = texture.image.data as Uint8Array;
 
     // generate a random color and update texture data
 
diff --git a/examples-testing/examples/webgl_materials_texture_rotation.ts b/examples-testing/examples/webgl_materials_texture_rotation.ts
index eedc80c6f..e5c7131f4 100644
--- a/examples-testing/examples/webgl_materials_texture_rotation.ts
+++ b/examples-testing/examples/webgl_materials_texture_rotation.ts
@@ -3,7 +3,10 @@ import * as THREE from 'three';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let mesh, renderer, scene, camera;
+let mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshBasicMaterial>,
+    renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera;
 
 let gui;
 
@@ -76,7 +79,7 @@ function onWindowResize() {
 }
 
 function updateUvTransform() {
-    const texture = mesh.material.map;
+    const texture = mesh.material.map!;
 
     if (texture.matrixAutoUpdate === true) {
         texture.offset.set(API.offsetX, API.offsetY);
diff --git a/examples-testing/examples/webgl_materials_toon.ts b/examples-testing/examples/webgl_materials_toon.ts
index 46c6a7e93..e89fc8cf3 100644
--- a/examples-testing/examples/webgl_materials_toon.ts
+++ b/examples-testing/examples/webgl_materials_toon.ts
@@ -4,20 +4,20 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { OutlineEffect } from 'three/addons/effects/OutlineEffect.js';
-import { FontLoader } from 'three/addons/loaders/FontLoader.js';
+import { Font, FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer, effect;
-let particleLight;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, effect: OutlineEffect;
+let particleLight: THREE.Mesh;
 
 const loader = new FontLoader();
 loader.load('fonts/gentilis_regular.typeface.json', function (font) {
     init(font);
 });
 
-function init(font) {
+function init(font: Font) {
     container = document.createElement('div');
     document.body.appendChild(container);
 
@@ -79,7 +79,7 @@ function init(font) {
         }
     }
 
-    function addLabel(name, location) {
+    function addLabel(name: string, location: THREE.Vector3) {
         const textGeo = new TextGeometry(name, {
             font: font,
 
diff --git a/examples-testing/examples/webgl_materials_video.ts b/examples-testing/examples/webgl_materials_video.ts
index 4f0d26a18..0bf378c5d 100644
--- a/examples-testing/examples/webgl_materials_video.ts
+++ b/examples-testing/examples/webgl_materials_video.ts
@@ -5,13 +5,16 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { BloomPass } from 'three/addons/postprocessing/BloomPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let video, texture, material, mesh;
+let video,
+    texture,
+    material: THREE.MeshLambertMaterial & { hue?: number; saturation?: number },
+    mesh: THREE.Mesh & { dx?: number; dy?: number };
 
-let composer;
+let composer: EffectComposer;
 
 let mouseX = 0;
 let mouseY = 0;
@@ -19,20 +22,20 @@ let mouseY = 0;
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
 
-let cube_count;
+let cube_count: number;
 
-const meshes = [],
-    materials = [],
+const meshes: THREE.Mesh[] = [],
+    materials: (THREE.MeshLambertMaterial & { hue?: number; saturation?: number })[] = [],
     xgrid = 20,
     ygrid = 10;
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', function () {
     init();
 });
 
 function init() {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
     container = document.createElement('div');
@@ -53,7 +56,7 @@ function init() {
     renderer.setAnimationLoop(animate);
     container.appendChild(renderer.domElement);
 
-    video = document.getElementById('video');
+    video = document.getElementById('video') as HTMLVideoElement;
     video.play();
     video.addEventListener('play', function () {
         this.currentTime = 3;
@@ -145,7 +148,7 @@ function onWindowResize() {
     composer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function change_uvs(geometry, unitx, unity, offsetx, offsety) {
+function change_uvs(geometry: THREE.BoxGeometry, unitx: number, unity: number, offsetx: number, offsety: number) {
     const uvs = geometry.attributes.uv.array;
 
     for (let i = 0; i < uvs.length; i += 2) {
@@ -154,7 +157,7 @@ function change_uvs(geometry, unitx, unity, offsetx, offsety) {
     }
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = (event.clientY - windowHalfY) * 0.3;
 }
@@ -175,20 +178,20 @@ function animate() {
     for (let i = 0; i < cube_count; i++) {
         material = materials[i];
 
-        h = ((360 * (material.hue + time)) % 360) / 360;
-        material.color.setHSL(h, material.saturation, 0.5);
+        h = ((360 * (material.hue! + time)) % 360) / 360;
+        material.color.setHSL(h, material.saturation!, 0.5);
     }
 
     if (counter % 1000 > 200) {
         for (let i = 0; i < cube_count; i++) {
             mesh = meshes[i];
 
-            mesh.rotation.x += 10 * mesh.dx;
-            mesh.rotation.y += 10 * mesh.dy;
+            mesh.rotation.x += 10 * mesh.dx!;
+            mesh.rotation.y += 10 * mesh.dy!;
 
-            mesh.position.x -= 150 * mesh.dx;
-            mesh.position.y += 150 * mesh.dy;
-            mesh.position.z += 300 * mesh.dx;
+            mesh.position.x -= 150 * mesh.dx!;
+            mesh.position.y += 150 * mesh.dy!;
+            mesh.position.z += 300 * mesh.dx!;
         }
     }
 
@@ -196,8 +199,8 @@ function animate() {
         for (let i = 0; i < cube_count; i++) {
             mesh = meshes[i];
 
-            mesh.dx *= -1;
-            mesh.dy *= -1;
+            mesh.dx! *= -1;
+            mesh.dy! *= -1;
         }
     }
 
diff --git a/examples-testing/examples/webgl_materials_video_webcam.ts b/examples-testing/examples/webgl_materials_video_webcam.ts
index cf6f8d50c..00b48c163 100644
--- a/examples-testing/examples/webgl_materials_video_webcam.ts
+++ b/examples-testing/examples/webgl_materials_video_webcam.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, video;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, video: HTMLVideoElement;
 
 init();
 
@@ -12,7 +12,7 @@ function init() {
 
     scene = new THREE.Scene();
 
-    video = document.getElementById('video');
+    video = document.getElementById('video') as HTMLVideoElement;
 
     const texture = new THREE.VideoTexture(video);
     texture.colorSpace = THREE.SRGBColorSpace;
diff --git a/examples-testing/examples/webgl_materials_wireframe.ts b/examples-testing/examples/webgl_materials_wireframe.ts
index 8adbd71d6..6424e8cbd 100644
--- a/examples-testing/examples/webgl_materials_wireframe.ts
+++ b/examples-testing/examples/webgl_materials_wireframe.ts
@@ -8,7 +8,10 @@ const API = {
     thickness: 1,
 };
 
-let renderer, scene, camera, mesh2;
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    mesh2: THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>;
 
 init();
 
@@ -50,8 +53,8 @@ function init() {
 
         const material2 = new THREE.ShaderMaterial({
             uniforms: { thickness: { value: API.thickness } },
-            vertexShader: document.getElementById('vertexShader').textContent,
-            fragmentShader: document.getElementById('fragmentShader').textContent,
+            vertexShader: document.getElementById('vertexShader')!.textContent!,
+            fragmentShader: document.getElementById('fragmentShader')!.textContent!,
             side: THREE.DoubleSide,
             alphaToCoverage: true, // only works when WebGLRenderer's "antialias" is set to "true"
         });
@@ -82,7 +85,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function setupAttributes(geometry) {
+function setupAttributes(geometry: THREE.BufferGeometry) {
     const vectors = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];
 
     const position = geometry.attributes.position;
diff --git a/examples-testing/examples/webgl_math_obb.ts b/examples-testing/examples/webgl_math_obb.ts
index 48480d10b..97a81a97e 100644
--- a/examples-testing/examples/webgl_math_obb.ts
+++ b/examples-testing/examples/webgl_math_obb.ts
@@ -5,9 +5,16 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer, clock, controls, stats, raycaster, hitbox;
-
-const objects = [],
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    controls: OrbitControls,
+    stats: Stats,
+    raycaster: THREE.Raycaster,
+    hitbox: THREE.Mesh;
+
+const objects: THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial>[] = [],
     mouse = new THREE.Vector2();
 
 init();
@@ -89,7 +96,7 @@ function init() {
     document.addEventListener('click', onClick);
 }
 
-function onClick(event) {
+function onClick(event: MouseEvent) {
     event.preventDefault();
 
     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
@@ -125,7 +132,10 @@ function onClick(event) {
     }
 }
 
-function sortIntersections(a, b) {
+function sortIntersections(
+    a: { distance: number; object: THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial> },
+    b: { distance: number; object: THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial> },
+) {
     return a.distance - b.distance;
 }
 
diff --git a/examples-testing/examples/webgl_math_orientation_transform.ts b/examples-testing/examples/webgl_math_orientation_transform.ts
index 2ae30caeb..9a48421f4 100644
--- a/examples-testing/examples/webgl_math_orientation_transform.ts
+++ b/examples-testing/examples/webgl_math_orientation_transform.ts
@@ -2,7 +2,11 @@ import * as THREE from 'three';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, mesh, target;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    mesh: THREE.Mesh,
+    target: THREE.Mesh;
 
 const spherical = new THREE.Spherical();
 const rotationMatrix = new THREE.Matrix4();
diff --git a/examples-testing/examples/webgl_mesh_batch.ts b/examples-testing/examples/webgl_mesh_batch.ts
index f93e5fb85..ee612f75e 100644
--- a/examples-testing/examples/webgl_mesh_batch.ts
+++ b/examples-testing/examples/webgl_mesh_batch.ts
@@ -4,12 +4,12 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { radixSort } from 'three/addons/utils/SortUtils.js';
+import { RadixSortOptions, radixSort } from 'three/addons/utils/SortUtils.js';
 
-let stats, gui, guiStatsEl;
-let camera, controls, scene, renderer;
-let geometries, mesh, material;
-const ids = [];
+let stats: Stats, gui: GUI, guiStatsEl: HTMLLIElement;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let geometries: THREE.BufferGeometry[], mesh: THREE.Group | THREE.BatchedMesh, material: THREE.MeshNormalMaterial;
+const ids: number[] = [];
 const matrix = new THREE.Matrix4();
 
 //
@@ -45,7 +45,7 @@ initMesh();
 
 //
 
-function randomizeMatrix(matrix) {
+function randomizeMatrix(matrix: THREE.Matrix4) {
     position.x = Math.random() * 40 - 20;
     position.y = Math.random() * 40 - 20;
     position.z = Math.random() * 40 - 20;
@@ -61,7 +61,7 @@ function randomizeMatrix(matrix) {
     return matrix.compose(position, quaternion, scale);
 }
 
-function randomizeRotationSpeed(rotation) {
+function randomizeRotationSpeed(rotation: THREE.Euler) {
     rotation.x = Math.random() * 0.01;
     rotation.y = Math.random() * 0.01;
     rotation.z = Math.random() * 0.01;
@@ -86,10 +86,10 @@ function createMaterial() {
 
 function cleanup() {
     if (mesh) {
-        mesh.parent.remove(mesh);
+        mesh.parent!.remove(mesh);
 
-        if (mesh.dispose) {
-            mesh.dispose();
+        if ((mesh as THREE.BatchedMesh).dispose) {
+            (mesh as THREE.BatchedMesh).dispose();
         }
     }
 }
@@ -219,14 +219,18 @@ function init() {
 
 //
 
-function sortFunction(list) {
+type BatchedMeshWithOptions = THREE.BatchedMesh & {
+    _options?: RadixSortOptions<{ start: number; count: number; z: number }>;
+};
+
+function sortFunction(this: THREE.BatchedMesh, list: { start: number; count: number; z: number }[]) {
     // initialize options
-    this._options = this._options || {
+    (this as BatchedMeshWithOptions)._options = (this as BatchedMeshWithOptions)._options || {
         get: el => el.z,
         aux: new Array(this.maxInstanceCount),
     };
 
-    const options = this._options;
+    const options = (this as BatchedMeshWithOptions)._options!;
     options.reversed = this.material.transparent;
 
     let minZ = Infinity;
@@ -276,9 +280,9 @@ function animateMeshes() {
             const rotationMatrix = mesh.userData.rotationSpeeds[i];
             const id = ids[i];
 
-            mesh.getMatrixAt(id, matrix);
+            (mesh as THREE.BatchedMesh).getMatrixAt(id, matrix);
             matrix.multiply(rotationMatrix);
-            mesh.setMatrixAt(id, matrix);
+            (mesh as THREE.BatchedMesh).setMatrixAt(id, matrix);
         }
     } else {
         for (let i = 0; i < loopNum; i++) {
@@ -295,10 +299,10 @@ function animateMeshes() {
 }
 
 function render() {
-    if (mesh.isBatchedMesh) {
-        mesh.sortObjects = api.sortObjects;
-        mesh.perObjectFrustumCulled = api.perObjectFrustumCulled;
-        mesh.setCustomSort(api.useCustomSort ? sortFunction : null);
+    if ((mesh as THREE.BatchedMesh).isBatchedMesh) {
+        (mesh as THREE.BatchedMesh).sortObjects = api.sortObjects;
+        (mesh as THREE.BatchedMesh).perObjectFrustumCulled = api.perObjectFrustumCulled;
+        (mesh as THREE.BatchedMesh).setCustomSort(api.useCustomSort ? sortFunction : null);
     }
 
     renderer.render(scene, camera);
diff --git a/examples-testing/examples/webgl_mirror.ts b/examples-testing/examples/webgl_mirror.ts
index 4f1f17f7d..6c780eabe 100644
--- a/examples-testing/examples/webgl_mirror.ts
+++ b/examples-testing/examples/webgl_mirror.ts
@@ -5,13 +5,13 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Reflector } from 'three/addons/objects/Reflector.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let cameraControls;
+let cameraControls: OrbitControls;
 
-let sphereGroup, smallSphere;
+let sphereGroup: THREE.Object3D, smallSphere: THREE.Mesh;
 
-let groundMirror, verticalMirror;
+let groundMirror: Reflector, verticalMirror: Reflector;
 
 let resolutionScale = 1; // render target scale factor in [ 0, 1 ]
 
@@ -20,7 +20,7 @@ const size = new THREE.Vector2();
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     // renderer
     renderer = new THREE.WebGLRenderer({ antialias: true });
diff --git a/examples-testing/examples/webgl_modifier_edgesplit.ts b/examples-testing/examples/webgl_modifier_edgesplit.ts
index 4725eff62..96620f504 100644
--- a/examples-testing/examples/webgl_modifier_edgesplit.ts
+++ b/examples-testing/examples/webgl_modifier_edgesplit.ts
@@ -7,9 +7,11 @@ import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js'
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let renderer, scene, camera;
-let modifier, mesh, baseGeometry;
-let map;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let modifier: EdgeSplitModifier,
+    mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>,
+    baseGeometry: THREE.BufferGeometry;
+let map: THREE.Texture;
 
 const params = {
     smoothShading: true,
@@ -50,7 +52,7 @@ function init() {
     scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 3));
 
     new OBJLoader().load('./models/obj/cerberus/Cerberus.obj', function (group) {
-        const cerberus = group.children[0];
+        const cerberus = group.children[0] as THREE.Mesh;
         const modelGeometry = cerberus.geometry;
 
         modifier = new EdgeSplitModifier();
diff --git a/examples-testing/examples/webgl_modifier_simplifier.ts b/examples-testing/examples/webgl_modifier_simplifier.ts
index e6ea453b3..f55a6581b 100644
--- a/examples-testing/examples/webgl_modifier_simplifier.ts
+++ b/examples-testing/examples/webgl_modifier_simplifier.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { SimplifyModifier } from 'three/addons/modifiers/SimplifyModifier.js';
 
-let renderer, scene, camera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
 
 init();
 
@@ -47,7 +47,7 @@ function init() {
 
         const modifier = new SimplifyModifier();
 
-        const simplified = mesh.clone();
+        const simplified = mesh.clone() as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
         simplified.material = simplified.material.clone();
         simplified.material.flatShading = true;
         const count = Math.floor(simplified.geometry.attributes.position.count * 0.875); // number of vertices to remove
diff --git a/examples-testing/examples/webgl_modifier_tessellation.ts b/examples-testing/examples/webgl_modifier_tessellation.ts
index 4600fc6cb..83af66a7c 100644
--- a/examples-testing/examples/webgl_modifier_tessellation.ts
+++ b/examples-testing/examples/webgl_modifier_tessellation.ts
@@ -4,14 +4,14 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
 import { TessellateModifier } from 'three/addons/modifiers/TessellateModifier.js';
-import { FontLoader } from 'three/addons/loaders/FontLoader.js';
+import { Font, FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let controls;
+let controls: TrackballControls;
 
-let mesh, uniforms;
+let mesh: THREE.Mesh, uniforms: Record<string, THREE.IUniform<unknown>>;
 
 const WIDTH = window.innerWidth;
 const HEIGHT = window.innerHeight;
@@ -21,7 +21,7 @@ loader.load('fonts/helvetiker_bold.typeface.json', function (font) {
     init(font);
 });
 
-function init(font) {
+function init(font: Font) {
     camera = new THREE.PerspectiveCamera(40, WIDTH / HEIGHT, 1, 10000);
     camera.position.set(-100, 100, 200);
 
@@ -90,8 +90,8 @@ function init(font) {
 
     const shaderMaterial = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
     });
 
     //
@@ -105,7 +105,7 @@ function init(font) {
     renderer.setSize(WIDTH, HEIGHT);
     renderer.setAnimationLoop(animate);
 
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.appendChild(renderer.domElement);
 
     controls = new TrackballControls(camera, renderer.domElement);
diff --git a/examples-testing/examples/webgl_morphtargets.ts b/examples-testing/examples/webgl_morphtargets.ts
index d8a4bbe8d..92ef3836a 100644
--- a/examples-testing/examples/webgl_morphtargets.ts
+++ b/examples-testing/examples/webgl_morphtargets.ts
@@ -3,12 +3,16 @@ import * as THREE from 'three';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container, camera, scene, renderer, mesh;
+let container: HTMLElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    mesh: THREE.Mesh;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
     scene.background = new THREE.Color(0x8fbcd4);
@@ -62,7 +66,7 @@ function createGeometry() {
     const spherePositions = [];
 
     // for the second morph target, we'll twist the cubes vertices
-    const twistPositions = [];
+    const twistPositions: number[] = [];
     const direction = new THREE.Vector3(1, 0, 0);
     const vertex = new THREE.Vector3();
 
@@ -101,10 +105,10 @@ function initGUI() {
     const gui = new GUI({ title: 'Morph Targets' });
 
     gui.add(params, 'Spherify', 0, 1, 0.01).onChange(function (value) {
-        mesh.morphTargetInfluences[0] = value;
+        mesh.morphTargetInfluences![0] = value;
     });
     gui.add(params, 'Twist', 0, 1, 0.01).onChange(function (value) {
-        mesh.morphTargetInfluences[1] = value;
+        mesh.morphTargetInfluences![1] = value;
     });
 }
 
diff --git a/examples-testing/examples/webgl_morphtargets_face.ts b/examples-testing/examples/webgl_morphtargets_face.ts
index 76179d902..c5b71065f 100644
--- a/examples-testing/examples/webgl_morphtargets_face.ts
+++ b/examples-testing/examples/webgl_morphtargets_face.ts
@@ -12,7 +12,13 @@ import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, stats, mixer, clock, controls;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    mixer: THREE.AnimationMixer,
+    clock: THREE.Clock,
+    controls: OrbitControls;
 
 init();
 
@@ -51,13 +57,13 @@ function init() {
 
             // GUI
 
-            const head = mesh.getObjectByName('mesh_2');
-            const influences = head.morphTargetInfluences;
+            const head = mesh.getObjectByName('mesh_2') as THREE.Mesh;
+            const influences = head.morphTargetInfluences!;
 
             const gui = new GUI();
             gui.close();
 
-            for (const [key, value] of Object.entries(head.morphTargetDictionary)) {
+            for (const [key, value] of Object.entries(head.morphTargetDictionary!)) {
                 gui.add(influences, value, 0, 1, 0.01).name(key.replace('blendShape1.', '')).listen();
             }
         });
diff --git a/examples-testing/examples/webgl_morphtargets_horse.ts b/examples-testing/examples/webgl_morphtargets_horse.ts
index 2c29e9c0e..5e285283a 100644
--- a/examples-testing/examples/webgl_morphtargets_horse.ts
+++ b/examples-testing/examples/webgl_morphtargets_horse.ts
@@ -4,9 +4,9 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let container, stats;
-let camera, scene, renderer;
-let mesh, mixer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mesh: THREE.Object3D, mixer: THREE.AnimationMixer;
 
 const radius = 600;
 let theta = 0;
diff --git a/examples-testing/examples/webgl_morphtargets_sphere.ts b/examples-testing/examples/webgl_morphtargets_sphere.ts
index 3e36f002c..0c45a0cf9 100644
--- a/examples-testing/examples/webgl_morphtargets_sphere.ts
+++ b/examples-testing/examples/webgl_morphtargets_sphere.ts
@@ -3,9 +3,9 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let camera, scene, renderer, timer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, timer: THREE.Timer;
 
-let mesh;
+let mesh: THREE.Mesh;
 
 let sign = 1;
 const speed = 0.5;
@@ -13,7 +13,7 @@ const speed = 0.5;
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.2, 100);
     camera.position.set(0, 5, 5);
@@ -35,7 +35,7 @@ function init() {
 
     const loader = new GLTFLoader();
     loader.load('models/gltf/AnimatedMorphSphere/glTF/AnimatedMorphSphere.gltf', function (gltf) {
-        mesh = gltf.scene.getObjectByName('AnimatedMorphSphere');
+        mesh = gltf.scene.getObjectByName('AnimatedMorphSphere') as THREE.Mesh;
         mesh.rotation.z = Math.PI / 2;
         scene.add(mesh);
 
@@ -94,9 +94,9 @@ function render() {
 
         mesh.rotation.y += step;
 
-        mesh.morphTargetInfluences[1] = mesh.morphTargetInfluences[1] + step * sign;
+        mesh.morphTargetInfluences![1] = mesh.morphTargetInfluences![1] + step * sign;
 
-        if (mesh.morphTargetInfluences[1] <= 0 || mesh.morphTargetInfluences[1] >= 1) {
+        if (mesh.morphTargetInfluences![1] <= 0 || mesh.morphTargetInfluences![1] >= 1) {
             sign *= -1;
         }
     }
diff --git a/examples-testing/examples/webgl_multiple_elements.ts b/examples-testing/examples/webgl_multiple_elements.ts
index 64f8a9c5f..8dafa6881 100644
--- a/examples-testing/examples/webgl_multiple_elements.ts
+++ b/examples-testing/examples/webgl_multiple_elements.ts
@@ -2,14 +2,14 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let canvas, renderer;
+let canvas: HTMLCanvasElement, renderer: THREE.WebGLRenderer;
 
-const scenes = [];
+const scenes: THREE.Scene[] = [];
 
 init();
 
 function init() {
-    canvas = document.getElementById('c');
+    canvas = document.getElementById('c') as HTMLCanvasElement;
 
     const geometries = [
         new THREE.BoxGeometry(1, 1, 1),
@@ -18,7 +18,7 @@ function init() {
         new THREE.CylinderGeometry(0.5, 0.5, 1, 12),
     ];
 
-    const content = document.getElementById('content');
+    const content = document.getElementById('content')!;
 
     for (let i = 0; i < 40; i++) {
         const scene = new THREE.Scene();
diff --git a/examples-testing/examples/webgl_multiple_rendertargets.ts b/examples-testing/examples/webgl_multiple_rendertargets.ts
index 86708082b..f63b7de60 100644
--- a/examples-testing/examples/webgl_multiple_rendertargets.ts
+++ b/examples-testing/examples/webgl_multiple_rendertargets.ts
@@ -3,9 +3,9 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, controls;
-let renderTarget;
-let postScene, postCamera;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
+let renderTarget: THREE.WebGLRenderTarget;
+let postScene: THREE.Scene, postCamera: THREE.OrthographicCamera;
 
 const parameters = {
     samples: 4,
@@ -62,8 +62,8 @@ function init() {
             new THREE.TorusKnotGeometry(1, 0.3, 128, 32),
             new THREE.RawShaderMaterial({
                 name: 'G-Buffer Shader',
-                vertexShader: document.querySelector('#gbuffer-vert').textContent.trim(),
-                fragmentShader: document.querySelector('#gbuffer-frag').textContent.trim(),
+                vertexShader: document.querySelector('#gbuffer-vert')!.textContent!.trim(),
+                fragmentShader: document.querySelector('#gbuffer-frag')!.textContent!.trim(),
                 uniforms: {
                     tDiffuse: { value: diffuse },
                     repeat: { value: new THREE.Vector2(5, 0.5) },
@@ -83,8 +83,8 @@ function init() {
             new THREE.PlaneGeometry(2, 2),
             new THREE.RawShaderMaterial({
                 name: 'Post-FX Shader',
-                vertexShader: document.querySelector('#render-vert').textContent.trim(),
-                fragmentShader: document.querySelector('#render-frag').textContent.trim(),
+                vertexShader: document.querySelector('#render-vert')!.textContent!.trim(),
+                fragmentShader: document.querySelector('#render-frag')!.textContent!.trim(),
                 uniforms: {
                     tDiffuse: { value: renderTarget.textures[0] },
                     tNormal: { value: renderTarget.textures[1] },
@@ -118,8 +118,8 @@ function render() {
     renderTarget.samples = parameters.samples;
 
     scene.traverse(function (child) {
-        if (child.material !== undefined) {
-            child.material.wireframe = parameters.wireframe;
+        if ((child as THREE.Mesh).material !== undefined) {
+            ((child as THREE.Mesh).material as THREE.RawShaderMaterial).wireframe = parameters.wireframe;
         }
     });
 
diff --git a/examples-testing/examples/webgl_multiple_scenes_comparison.ts b/examples-testing/examples/webgl_multiple_scenes_comparison.ts
index 41a5130d4..66d539a9b 100644
--- a/examples-testing/examples/webgl_multiple_scenes_comparison.ts
+++ b/examples-testing/examples/webgl_multiple_scenes_comparison.ts
@@ -2,15 +2,15 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container, camera, renderer, controls;
-let sceneL, sceneR;
+let container: HTMLElement, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, controls: OrbitControls;
+let sceneL: THREE.Scene, sceneR: THREE.Scene;
 
 let sliderPos = window.innerWidth / 2;
 
 init();
 
 function init() {
-    container = document.querySelector('.container');
+    container = document.querySelector('.container')!;
 
     sceneL = new THREE.Scene();
     sceneL.background = new THREE.Color(0xbcd48f);
@@ -52,9 +52,9 @@ function initMeshes() {
 }
 
 function initSlider() {
-    const slider = document.querySelector('.slider');
+    const slider = document.querySelector('.slider') as HTMLElement;
 
-    function onPointerDown() {
+    function onPointerDown(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
         controls.enabled = false;
@@ -70,10 +70,10 @@ function initSlider() {
         window.removeEventListener('pointerup', onPointerUp);
     }
 
-    function onPointerMove(e) {
+    function onPointerMove(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
-        sliderPos = Math.max(0, Math.min(window.innerWidth, e.pageX));
+        sliderPos = Math.max(0, Math.min(window.innerWidth, event.pageX));
 
         slider.style.left = sliderPos - slider.offsetWidth / 2 + 'px';
     }
diff --git a/examples-testing/examples/webgl_multiple_views.ts b/examples-testing/examples/webgl_multiple_views.ts
index 640eac827..04d7749c2 100644
--- a/examples-testing/examples/webgl_multiple_views.ts
+++ b/examples-testing/examples/webgl_multiple_views.ts
@@ -2,16 +2,27 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let stats;
+let stats: Stats;
 
-let scene, renderer;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let mouseX = 0,
     mouseY = 0;
 
-let windowWidth, windowHeight;
-
-const views = [
+let windowWidth: number, windowHeight: number;
+
+const views: {
+    left: number;
+    bottom: number;
+    width: number;
+    height: number;
+    background: THREE.Color;
+    eye: [number, number, number];
+    up: [number, number, number];
+    fov: number;
+    updateCamera: (camera: THREE.PerspectiveCamera, scene: THREE.Scene, mouseX: number) => void;
+    camera?: THREE.PerspectiveCamera;
+}[] = [
     {
         left: 0,
         bottom: 0,
@@ -62,7 +73,7 @@ const views = [
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     for (let ii = 0; ii < views.length; ++ii) {
         const view = views[ii];
@@ -84,7 +95,7 @@ function init() {
     canvas.width = 128;
     canvas.height = 128;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     const gradient = context.createRadialGradient(
         canvas.width / 2,
         canvas.height / 2,
@@ -191,7 +202,7 @@ function init() {
     document.addEventListener('mousemove', onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowWidth / 2;
     mouseY = event.clientY - windowHeight / 2;
 }
@@ -215,7 +226,7 @@ function render() {
 
     for (let ii = 0; ii < views.length; ++ii) {
         const view = views[ii];
-        const camera = view.camera;
+        const camera = view.camera!;
 
         view.updateCamera(camera, scene, mouseX);
 
diff --git a/examples-testing/examples/webgl_multisampled_renderbuffers.ts b/examples-testing/examples/webgl_multisampled_renderbuffers.ts
index df84fb144..fc3da7a87 100644
--- a/examples-testing/examples/webgl_multisampled_renderbuffers.ts
+++ b/examples-testing/examples/webgl_multisampled_renderbuffers.ts
@@ -5,9 +5,9 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, renderer, group, container;
+let camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, group: THREE.Group, container: HTMLElement;
 
-let composer1, composer2;
+let composer1: EffectComposer, composer2: EffectComposer;
 
 const params = {
     animate: true,
@@ -16,7 +16,7 @@ const params = {
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 10, 2000);
     camera.position.z = 500;
diff --git a/examples-testing/examples/webgl_panorama_cube.ts b/examples-testing/examples/webgl_panorama_cube.ts
index efd09cfc5..e4832209e 100644
--- a/examples-testing/examples/webgl_panorama_cube.ts
+++ b/examples-testing/examples/webgl_panorama_cube.ts
@@ -2,14 +2,14 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, controls;
-let renderer;
-let scene;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls;
+let renderer: THREE.WebGLRenderer;
+let scene: THREE.Scene;
 
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer();
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -43,8 +43,8 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function getTexturesFromAtlasFile(atlasImgUrl, tilesNum) {
-    const textures = [];
+function getTexturesFromAtlasFile(atlasImgUrl: string, tilesNum: number) {
+    const textures: THREE.Texture[] = [];
 
     for (let i = 0; i < tilesNum; i++) {
         textures[i] = new THREE.Texture();
@@ -56,7 +56,7 @@ function getTexturesFromAtlasFile(atlasImgUrl, tilesNum) {
 
         for (let i = 0; i < textures.length; i++) {
             canvas = document.createElement('canvas');
-            context = canvas.getContext('2d');
+            context = canvas.getContext('2d')!;
             canvas.height = tileWidth;
             canvas.width = tileWidth;
             context.drawImage(image, tileWidth * i, 0, tileWidth, tileWidth, 0, 0, tileWidth, tileWidth);
diff --git a/examples-testing/examples/webgl_panorama_equirectangular.ts b/examples-testing/examples/webgl_panorama_equirectangular.ts
index 35949ee6f..6d631dee3 100644
--- a/examples-testing/examples/webgl_panorama_equirectangular.ts
+++ b/examples-testing/examples/webgl_panorama_equirectangular.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let isUserInteracting = false,
     onPointerDownMouseX = 0,
@@ -15,7 +15,7 @@ let isUserInteracting = false,
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);
 
@@ -54,7 +54,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     isUserInteracting = true;
@@ -69,14 +69,14 @@ function onPointerDown(event) {
     document.addEventListener('pointerup', onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     lon = (onPointerDownMouseX - event.clientX) * 0.1 + onPointerDownLon;
     lat = (event.clientY - onPointerDownMouseY) * 0.1 + onPointerDownLat;
 }
 
-function onPointerUp(event) {
+function onPointerUp(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     isUserInteracting = false;
@@ -85,7 +85,7 @@ function onPointerUp(event) {
     document.removeEventListener('pointerup', onPointerUp);
 }
 
-function onDocumentMouseWheel(event) {
+function onDocumentMouseWheel(event: WheelEvent) {
     const fov = camera.fov + event.deltaY * 0.05;
 
     camera.fov = THREE.MathUtils.clamp(fov, 10, 75);
diff --git a/examples-testing/examples/webgl_performance.ts b/examples-testing/examples/webgl_performance.ts
index d6d2bdfc9..7c412fa17 100644
--- a/examples-testing/examples/webgl_performance.ts
+++ b/examples-testing/examples/webgl_performance.ts
@@ -6,7 +6,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 
diff --git a/examples-testing/examples/webgl_pmrem_cubemap.ts b/examples-testing/examples/webgl_pmrem_cubemap.ts
index fb5bdafc1..c432f8d35 100644
--- a/examples-testing/examples/webgl_pmrem_cubemap.ts
+++ b/examples-testing/examples/webgl_pmrem_cubemap.ts
@@ -4,7 +4,7 @@ import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_pmrem_equirectangular.ts b/examples-testing/examples/webgl_pmrem_equirectangular.ts
index 7f04d9700..67cef6639 100644
--- a/examples-testing/examples/webgl_pmrem_equirectangular.ts
+++ b/examples-testing/examples/webgl_pmrem_equirectangular.ts
@@ -4,7 +4,7 @@ import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_pmrem_test.ts b/examples-testing/examples/webgl_pmrem_test.ts
index 3c482338f..292f01c3d 100644
--- a/examples-testing/examples/webgl_pmrem_test.ts
+++ b/examples-testing/examples/webgl_pmrem_test.ts
@@ -5,7 +5,7 @@ import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, controls, renderer;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls, renderer: THREE.WebGLRenderer;
 
 function init() {
     const width = window.innerWidth;
@@ -68,8 +68,9 @@ function init() {
             directionalLight.intensity = value ? 0 : 1;
 
             scene.traverse(function (child) {
-                if (child.isMesh) {
-                    child.material.envMapIntensity = 1 - directionalLight.intensity;
+                if ((child as THREE.Mesh).isMesh) {
+                    ((child as THREE.Mesh).material as THREE.MeshStandardMaterial).envMapIntensity =
+                        1 - directionalLight.intensity;
                 }
             });
 
diff --git a/examples-testing/examples/webgl_points_billboards.ts b/examples-testing/examples/webgl_points_billboards.ts
index 24d4de1a9..f1a089bf9 100644
--- a/examples-testing/examples/webgl_points_billboards.ts
+++ b/examples-testing/examples/webgl_points_billboards.ts
@@ -4,7 +4,11 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, stats, material;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    material: THREE.PointsMaterial;
 let mouseX = 0,
     mouseY = 0;
 
@@ -91,7 +95,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
diff --git a/examples-testing/examples/webgl_points_sprites.ts b/examples-testing/examples/webgl_points_sprites.ts
index 31b9e2ce1..d8f24b296 100644
--- a/examples-testing/examples/webgl_points_sprites.ts
+++ b/examples-testing/examples/webgl_points_sprites.ts
@@ -4,14 +4,18 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, stats, parameters;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    parameters: [[number, number, number], THREE.Texture, number][];
 let mouseX = 0,
     mouseY = 0;
 
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
 
-const materials = [];
+const materials: THREE.PointsMaterial[] = [];
 
 init();
 
@@ -27,7 +31,7 @@ function init() {
 
     const textureLoader = new THREE.TextureLoader();
 
-    const assignSRGB = texture => {
+    const assignSRGB = (texture: THREE.Texture) => {
         texture.colorSpace = THREE.SRGBColorSpace;
     };
 
@@ -126,7 +130,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
diff --git a/examples-testing/examples/webgl_points_waves.ts b/examples-testing/examples/webgl_points_waves.ts
index 91986e9e9..cb8e76873 100644
--- a/examples-testing/examples/webgl_points_waves.ts
+++ b/examples-testing/examples/webgl_points_waves.ts
@@ -6,10 +6,10 @@ const SEPARATION = 100,
     AMOUNTX = 50,
     AMOUNTY = 50;
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let particles,
+let particles: THREE.Points,
     count = 0;
 
 let mouseX = 0,
@@ -60,8 +60,8 @@ function init() {
         uniforms: {
             color: { value: new THREE.Color(0xffffff) },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
     });
 
     //
@@ -100,7 +100,7 @@ function onWindowResize() {
 
 //
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
diff --git a/examples-testing/examples/webgl_portal.ts b/examples-testing/examples/webgl_portal.ts
index 4bc59593f..e61736c30 100644
--- a/examples-testing/examples/webgl_portal.ts
+++ b/examples-testing/examples/webgl_portal.ts
@@ -3,26 +3,26 @@ import * as THREE from 'three';
 import * as CameraUtils from 'three/addons/utils/CameraUtils.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let cameraControls;
+let cameraControls: OrbitControls;
 
-let smallSphereOne, smallSphereTwo;
+let smallSphereOne: THREE.Mesh, smallSphereTwo: THREE.Mesh;
 
-let portalCamera,
-    leftPortal,
-    rightPortal,
-    leftPortalTexture,
-    reflectedPosition,
-    rightPortalTexture,
-    bottomLeftCorner,
-    bottomRightCorner,
-    topLeftCorner;
+let portalCamera: THREE.PerspectiveCamera,
+    leftPortal: THREE.Mesh,
+    rightPortal: THREE.Mesh,
+    leftPortalTexture: THREE.WebGLRenderTarget,
+    reflectedPosition: THREE.Vector3,
+    rightPortalTexture: THREE.WebGLRenderTarget,
+    bottomLeftCorner: THREE.Vector3,
+    bottomRightCorner: THREE.Vector3,
+    topLeftCorner: THREE.Vector3;
 
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     // renderer
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -150,7 +150,11 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function renderPortal(thisPortalMesh, otherPortalMesh, thisPortalTexture) {
+function renderPortal(
+    thisPortalMesh: THREE.Mesh,
+    otherPortalMesh: THREE.Mesh,
+    thisPortalTexture: THREE.WebGLRenderTarget,
+) {
     // set the portal camera position to be reflected about the portal plane
     thisPortalMesh.worldToLocal(reflectedPosition.copy(camera.position));
     reflectedPosition.x *= -1.0;
diff --git a/examples-testing/examples/webgl_postprocessing.ts b/examples-testing/examples/webgl_postprocessing.ts
index ecc9b28ee..2e8942363 100644
--- a/examples-testing/examples/webgl_postprocessing.ts
+++ b/examples-testing/examples/webgl_postprocessing.ts
@@ -8,8 +8,8 @@ import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';
 import { DotScreenShader } from 'three/addons/shaders/DotScreenShader.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, renderer, composer;
-let object;
+let camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let object: THREE.Object3D;
 
 init();
 
diff --git a/examples-testing/examples/webgl_postprocessing_advanced.ts b/examples-testing/examples/webgl_postprocessing_advanced.ts
index 82fc39be3..1a14c2b9b 100644
--- a/examples-testing/examples/webgl_postprocessing_advanced.ts
+++ b/examples-testing/examples/webgl_postprocessing_advanced.ts
@@ -21,11 +21,21 @@ import { GammaCorrectionShader } from 'three/addons/shaders/GammaCorrectionShade
 
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let container, stats;
-
-let composerScene, composer1, composer2, composer3, composer4;
-
-let cameraOrtho, cameraPerspective, sceneModel, sceneBG, renderer, mesh, directionalLight;
+let container: HTMLElement, stats: Stats;
+
+let composerScene: EffectComposer,
+    composer1: EffectComposer,
+    composer2: EffectComposer,
+    composer3: EffectComposer,
+    composer4: EffectComposer;
+
+let cameraOrtho: THREE.OrthographicCamera,
+    cameraPerspective: THREE.PerspectiveCamera,
+    sceneModel: THREE.Scene,
+    sceneBG: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    mesh: THREE.Mesh,
+    directionalLight: THREE.DirectionalLight;
 
 const width = window.innerWidth || 2;
 const height = window.innerHeight || 2;
@@ -33,14 +43,14 @@ const height = window.innerHeight || 2;
 let halfWidth = width / 2;
 let halfHeight = height / 2;
 
-let quadBG, quadMask, renderScene;
+let quadBG: THREE.Mesh, quadMask: THREE.Mesh, renderScene: TexturePass;
 
 const delta = 0.01;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -63,7 +73,7 @@ function init() {
 
     const loader = new GLTFLoader();
     loader.load('models/gltf/LeePerrySmith/LeePerrySmith.glb', function (gltf) {
-        createMesh(gltf.scene.children[0].geometry, sceneModel, 100);
+        createMesh((gltf.scene.children[0] as THREE.Mesh).geometry, sceneModel, 100);
     });
 
     //
@@ -254,7 +264,7 @@ function onWindowResize() {
     quadMask.scale.set(window.innerWidth / 2, window.innerHeight / 2, 1);
 }
 
-function createMesh(geometry, scene, scale) {
+function createMesh(geometry: THREE.BufferGeometry, scene: THREE.Scene, scale: number) {
     const diffuseMap = new THREE.TextureLoader().load('models/gltf/LeePerrySmith/Map-COL.jpg');
     diffuseMap.colorSpace = THREE.SRGBColorSpace;
 
diff --git a/examples-testing/examples/webgl_postprocessing_afterimage.ts b/examples-testing/examples/webgl_postprocessing_afterimage.ts
index 97353dcd2..433322a3e 100644
--- a/examples-testing/examples/webgl_postprocessing_afterimage.ts
+++ b/examples-testing/examples/webgl_postprocessing_afterimage.ts
@@ -7,10 +7,10 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, scene, renderer, composer;
-let mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let mesh: THREE.Mesh;
 
-let afterimagePass;
+let afterimagePass: AfterimagePass;
 
 const params = {
     enable: true,
diff --git a/examples-testing/examples/webgl_postprocessing_backgrounds.ts b/examples-testing/examples/webgl_postprocessing_backgrounds.ts
index 57a6a2dbd..f6d4c7167 100644
--- a/examples-testing/examples/webgl_postprocessing_backgrounds.ts
+++ b/examples-testing/examples/webgl_postprocessing_backgrounds.ts
@@ -11,10 +11,10 @@ import { ClearPass } from 'three/addons/postprocessing/ClearPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let scene, renderer, composer;
-let clearPass, texturePass, renderPass;
-let cameraP, cubeTexturePassP;
-let gui, stats;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let clearPass: ClearPass, texturePass: TexturePass, renderPass: RenderPass;
+let cameraP: THREE.PerspectiveCamera, cubeTexturePassP: CubeTexturePass | null;
+let gui: GUI | undefined, stats: Stats;
 
 const params = {
     clearPass: true,
@@ -55,7 +55,7 @@ function clearGui() {
 }
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     const width = window.innerWidth || 1;
     const height = window.innerHeight || 1;
@@ -111,7 +111,7 @@ function init() {
 
     // postprocessing
 
-    const genCubeUrls = function (prefix, postfix) {
+    const genCubeUrls = function (prefix: string, postfix: string) {
         return [
             prefix + 'px' + postfix,
             prefix + 'nx' + postfix,
diff --git a/examples-testing/examples/webgl_postprocessing_fxaa.ts b/examples-testing/examples/webgl_postprocessing_fxaa.ts
index c5e632ad7..1774b0c84 100644
--- a/examples-testing/examples/webgl_postprocessing_fxaa.ts
+++ b/examples-testing/examples/webgl_postprocessing_fxaa.ts
@@ -6,14 +6,18 @@ import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import { FXAAPass } from 'three/addons/postprocessing/FXAAPass.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, controls, container;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    controls: OrbitControls,
+    container: HTMLElement;
 
-let composer1, composer2, fxaaPass;
+let composer1: EffectComposer, composer2: EffectComposer, fxaaPass: FXAAPass;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 1, 2000);
     camera.position.z = 500;
diff --git a/examples-testing/examples/webgl_postprocessing_glitch.ts b/examples-testing/examples/webgl_postprocessing_glitch.ts
index 02acda572..5c39961fa 100644
--- a/examples-testing/examples/webgl_postprocessing_glitch.ts
+++ b/examples-testing/examples/webgl_postprocessing_glitch.ts
@@ -5,21 +5,21 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, scene, renderer, composer;
-let object, light;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let object: THREE.Object3D, light: THREE.DirectionalLight;
 
-let glitchPass;
+let glitchPass: GlitchPass;
 
-const button = document.querySelector('#startButton');
+const button = document.querySelector('#startButton')!;
 button.addEventListener('click', function () {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
     init();
 });
 
 function updateOptions() {
-    const wildGlitch = document.getElementById('wildGlitch');
+    const wildGlitch = document.getElementById('wildGlitch') as HTMLInputElement;
     glitchPass.goWild = wildGlitch.checked;
 }
 
@@ -86,7 +86,7 @@ function init() {
 
     window.addEventListener('resize', onWindowResize);
 
-    const wildGlitchOption = document.getElementById('wildGlitch');
+    const wildGlitchOption = document.getElementById('wildGlitch')!;
     wildGlitchOption.addEventListener('change', updateOptions);
 
     updateOptions();
diff --git a/examples-testing/examples/webgl_postprocessing_godrays.ts b/examples-testing/examples/webgl_postprocessing_godrays.ts
index c2caf2766..235b07411 100644
--- a/examples-testing/examples/webgl_postprocessing_godrays.ts
+++ b/examples-testing/examples/webgl_postprocessing_godrays.ts
@@ -11,16 +11,37 @@ import {
     GodRaysGenerateShader,
 } from 'three/addons/shaders/GodRaysShader.js';
 
-let container, stats;
-let camera, scene, renderer, materialDepth;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    materialDepth: THREE.MeshDepthMaterial;
 
-let sphereMesh;
+let sphereMesh: THREE.Mesh;
 
 const sunPosition = new THREE.Vector3(0, 1000, -1000);
 const clipPosition = new THREE.Vector4();
 const screenSpacePosition = new THREE.Vector3();
 
-const postprocessing = { enabled: true };
+const postprocessing: {
+    enabled: boolean;
+    scene?: THREE.Scene;
+    camera?: THREE.OrthographicCamera;
+    rtTextureColors?: THREE.WebGLRenderTarget;
+    rtTextureDepth?: THREE.WebGLRenderTarget;
+    rtTextureDepthMask?: THREE.WebGLRenderTarget;
+    rtTextureGodRays1?: THREE.WebGLRenderTarget;
+    rtTextureGodRays2?: THREE.WebGLRenderTarget;
+    godrayMaskUniforms?: (typeof GodRaysDepthMaskShader)['uniforms'];
+    materialGodraysDepthMask?: THREE.ShaderMaterial;
+    godrayGenUniforms?: (typeof GodRaysGenerateShader)['uniforms'];
+    materialGodraysGenerate?: THREE.ShaderMaterial;
+    godrayCombineUniforms?: (typeof GodRaysCombineShader)['uniforms'];
+    materialGodraysCombine?: THREE.ShaderMaterial;
+    godraysFakeSunUniforms?: (typeof GodRaysFakeSunShader)['uniforms'];
+    materialGodraysFakeSun?: THREE.ShaderMaterial;
+    quad?: THREE.Mesh;
+} = { enabled: true };
 
 const orbitRadius = 200;
 
@@ -102,17 +123,17 @@ function onWindowResize() {
     camera.updateProjectionMatrix();
 
     renderer.setSize(renderTargetWidth, renderTargetHeight);
-    postprocessing.rtTextureColors.setSize(renderTargetWidth, renderTargetHeight);
-    postprocessing.rtTextureDepth.setSize(renderTargetWidth, renderTargetHeight);
-    postprocessing.rtTextureDepthMask.setSize(renderTargetWidth, renderTargetHeight);
+    postprocessing.rtTextureColors!.setSize(renderTargetWidth, renderTargetHeight);
+    postprocessing.rtTextureDepth!.setSize(renderTargetWidth, renderTargetHeight);
+    postprocessing.rtTextureDepthMask!.setSize(renderTargetWidth, renderTargetHeight);
 
     const adjustedWidth = renderTargetWidth * godrayRenderTargetResolutionMultiplier;
     const adjustedHeight = renderTargetHeight * godrayRenderTargetResolutionMultiplier;
-    postprocessing.rtTextureGodRays1.setSize(adjustedWidth, adjustedHeight);
-    postprocessing.rtTextureGodRays2.setSize(adjustedWidth, adjustedHeight);
+    postprocessing.rtTextureGodRays1!.setSize(adjustedWidth, adjustedHeight);
+    postprocessing.rtTextureGodRays2!.setSize(adjustedWidth, adjustedHeight);
 }
 
-function initPostprocessing(renderTargetWidth, renderTargetHeight) {
+function initPostprocessing(renderTargetWidth: number, renderTargetHeight: number) {
     postprocessing.scene = new THREE.Scene();
 
     postprocessing.camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);
@@ -179,10 +200,10 @@ function initPostprocessing(renderTargetWidth, renderTargetHeight) {
         fragmentShader: godraysFakeSunShader.fragmentShader,
     });
 
-    postprocessing.godraysFakeSunUniforms.bgColor.value.setHex(bgColor);
-    postprocessing.godraysFakeSunUniforms.sunColor.value.setHex(sunColor);
+    postprocessing.godraysFakeSunUniforms!.bgColor.value.setHex(bgColor);
+    postprocessing.godraysFakeSunUniforms!.sunColor.value.setHex(sunColor);
 
-    postprocessing.godrayCombineUniforms.fGodRayIntensity.value = 0.75;
+    postprocessing.godrayCombineUniforms!.fGodRayIntensity.value = 0.75;
 
     postprocessing.quad = new THREE.Mesh(new THREE.PlaneGeometry(1.0, 1.0), postprocessing.materialGodraysGenerate);
     postprocessing.quad.position.z = -9900;
@@ -195,19 +216,19 @@ function animate() {
     stats.end();
 }
 
-function getStepSize(filterLen, tapsPerPass, pass) {
+function getStepSize(filterLen: number, tapsPerPass: number, pass: number) {
     return filterLen * Math.pow(tapsPerPass, -pass);
 }
 
-function filterGodRays(inputTex, renderTarget, stepSize) {
-    postprocessing.scene.overrideMaterial = postprocessing.materialGodraysGenerate;
+function filterGodRays(inputTex: THREE.Texture, renderTarget: THREE.WebGLRenderTarget, stepSize: number) {
+    postprocessing.scene!.overrideMaterial = postprocessing.materialGodraysGenerate!;
 
-    postprocessing.godrayGenUniforms['fStepSize'].value = stepSize;
-    postprocessing.godrayGenUniforms['tInput'].value = inputTex;
+    postprocessing.godrayGenUniforms!['fStepSize'].value = stepSize;
+    postprocessing.godrayGenUniforms!['tInput'].value = inputTex;
 
     renderer.setRenderTarget(renderTarget);
-    renderer.render(postprocessing.scene, postprocessing.camera);
-    postprocessing.scene.overrideMaterial = null;
+    renderer.render(postprocessing.scene!, postprocessing.camera!);
+    postprocessing.scene!.overrideMaterial = null;
 }
 
 function render() {
@@ -235,14 +256,14 @@ function render() {
 
         // Give it to the god-ray and sun shaders
 
-        postprocessing.godrayGenUniforms['vSunPositionScreenSpace'].value.copy(screenSpacePosition);
-        postprocessing.godraysFakeSunUniforms['vSunPositionScreenSpace'].value.copy(screenSpacePosition);
+        postprocessing.godrayGenUniforms!['vSunPositionScreenSpace'].value.copy(screenSpacePosition);
+        postprocessing.godraysFakeSunUniforms!['vSunPositionScreenSpace'].value.copy(screenSpacePosition);
 
         // -- Draw sky and sun --
 
         // Clear colors and depths, will clear to sky color
 
-        renderer.setRenderTarget(postprocessing.rtTextureColors);
+        renderer.setRenderTarget(postprocessing.rtTextureColors!);
         renderer.clear(true, true, false);
 
         // Sun render. Runs a shader that gives a brightness based on the screen
@@ -258,11 +279,11 @@ function render() {
         renderer.setScissor(screenSpacePosition.x - sunsqW / 2, screenSpacePosition.y - sunsqH / 2, sunsqW, sunsqH);
         renderer.setScissorTest(true);
 
-        postprocessing.godraysFakeSunUniforms['fAspect'].value = window.innerWidth / window.innerHeight;
+        postprocessing.godraysFakeSunUniforms!['fAspect'].value = window.innerWidth / window.innerHeight;
 
-        postprocessing.scene.overrideMaterial = postprocessing.materialGodraysFakeSun;
-        renderer.setRenderTarget(postprocessing.rtTextureColors);
-        renderer.render(postprocessing.scene, postprocessing.camera);
+        postprocessing.scene!.overrideMaterial = postprocessing.materialGodraysFakeSun!;
+        renderer.setRenderTarget(postprocessing.rtTextureColors!);
+        renderer.render(postprocessing.scene!, postprocessing.camera!);
 
         renderer.setScissorTest(false);
 
@@ -271,23 +292,23 @@ function render() {
         // Colors
 
         scene.overrideMaterial = null;
-        renderer.setRenderTarget(postprocessing.rtTextureColors);
+        renderer.setRenderTarget(postprocessing.rtTextureColors!);
         renderer.render(scene, camera);
 
         // Depth
 
         scene.overrideMaterial = materialDepth;
-        renderer.setRenderTarget(postprocessing.rtTextureDepth);
+        renderer.setRenderTarget(postprocessing.rtTextureDepth!);
         renderer.clear();
         renderer.render(scene, camera);
 
         //
 
-        postprocessing.godrayMaskUniforms['tInput'].value = postprocessing.rtTextureDepth.texture;
+        postprocessing.godrayMaskUniforms!['tInput'].value = postprocessing.rtTextureDepth!.texture;
 
-        postprocessing.scene.overrideMaterial = postprocessing.materialGodraysDepthMask;
-        renderer.setRenderTarget(postprocessing.rtTextureDepthMask);
-        renderer.render(postprocessing.scene, postprocessing.camera);
+        postprocessing.scene!.overrideMaterial = postprocessing.materialGodraysDepthMask!;
+        renderer.setRenderTarget(postprocessing.rtTextureDepthMask!);
+        renderer.render(postprocessing.scene!, postprocessing.camera!);
 
         // -- Render god-rays --
 
@@ -306,35 +327,35 @@ function render() {
 
         // pass 1 - render into first ping-pong target
         filterGodRays(
-            postprocessing.rtTextureDepthMask.texture,
-            postprocessing.rtTextureGodRays2,
+            postprocessing.rtTextureDepthMask!.texture,
+            postprocessing.rtTextureGodRays2!,
             getStepSize(filterLen, TAPS_PER_PASS, 1.0),
         );
 
         // pass 2 - render into second ping-pong target
         filterGodRays(
-            postprocessing.rtTextureGodRays2.texture,
-            postprocessing.rtTextureGodRays1,
+            postprocessing.rtTextureGodRays2!.texture,
+            postprocessing.rtTextureGodRays1!,
             getStepSize(filterLen, TAPS_PER_PASS, 2.0),
         );
 
         // pass 3 - 1st RT
         filterGodRays(
-            postprocessing.rtTextureGodRays1.texture,
-            postprocessing.rtTextureGodRays2,
+            postprocessing.rtTextureGodRays1!.texture,
+            postprocessing.rtTextureGodRays2!,
             getStepSize(filterLen, TAPS_PER_PASS, 3.0),
         );
 
         // final pass - composite god-rays onto colors
 
-        postprocessing.godrayCombineUniforms['tColors'].value = postprocessing.rtTextureColors.texture;
-        postprocessing.godrayCombineUniforms['tGodRays'].value = postprocessing.rtTextureGodRays2.texture;
+        postprocessing.godrayCombineUniforms!['tColors'].value = postprocessing.rtTextureColors!.texture;
+        postprocessing.godrayCombineUniforms!['tGodRays'].value = postprocessing.rtTextureGodRays2!.texture;
 
-        postprocessing.scene.overrideMaterial = postprocessing.materialGodraysCombine;
+        postprocessing.scene!.overrideMaterial = postprocessing.materialGodraysCombine!;
 
         renderer.setRenderTarget(null);
-        renderer.render(postprocessing.scene, postprocessing.camera);
-        postprocessing.scene.overrideMaterial = null;
+        renderer.render(postprocessing.scene!, postprocessing.camera!);
+        postprocessing.scene!.overrideMaterial = null;
     } else {
         renderer.setRenderTarget(null);
         renderer.clear();
diff --git a/examples-testing/examples/webgl_postprocessing_gtao.ts b/examples-testing/examples/webgl_postprocessing_gtao.ts
index 4f16d1554..ff12d709a 100644
--- a/examples-testing/examples/webgl_postprocessing_gtao.ts
+++ b/examples-testing/examples/webgl_postprocessing_gtao.ts
@@ -10,7 +10,14 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { GTAOPass } from 'three/addons/postprocessing/GTAOPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, scene, renderer, composer, controls, clock, stats, mixer;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    composer: EffectComposer,
+    controls: OrbitControls,
+    clock: THREE.Clock,
+    stats: Stats,
+    mixer: THREE.AnimationMixer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_postprocessing_masking.ts b/examples-testing/examples/webgl_postprocessing_masking.ts
index a4d09866d..238c37da7 100644
--- a/examples-testing/examples/webgl_postprocessing_masking.ts
+++ b/examples-testing/examples/webgl_postprocessing_masking.ts
@@ -6,8 +6,8 @@ import { ClearPass } from 'three/addons/postprocessing/ClearPass.js';
 import { MaskPass, ClearMaskPass } from 'three/addons/postprocessing/MaskPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, composer, renderer;
-let box, torus;
+let camera: THREE.PerspectiveCamera, composer: EffectComposer, renderer: THREE.WebGLRenderer;
+let box: THREE.Mesh, torus: THREE.Mesh;
 
 init();
 
diff --git a/examples-testing/examples/webgl_postprocessing_material_ao.ts b/examples-testing/examples/webgl_postprocessing_material_ao.ts
index 5bd817ef2..2321ad812 100644
--- a/examples-testing/examples/webgl_postprocessing_material_ao.ts
+++ b/examples-testing/examples/webgl_postprocessing_material_ao.ts
@@ -10,7 +10,12 @@ import { GTAOPass } from 'three/addons/postprocessing/GTAOPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import { MeshPostProcessingMaterial } from 'three/addons/materials/MeshPostProcessingMaterial.js';
 
-let renderer, camera, scene, composer, controls, stats;
+let renderer: THREE.WebGLRenderer,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    composer: EffectComposer,
+    controls: OrbitControls,
+    stats: Stats;
 const sceneParameters = {
     output: 0,
     envMapIntensity: 1.0,
@@ -218,7 +223,7 @@ function init() {
         .max(100)
         .step(1)
         .onChange(() => {
-            lightGroup.children.forEach(light => (light.intensity = sceneParameters.lightIntensity));
+            lightGroup.children.forEach(light => ((light as THREE.Light).intensity = sceneParameters.lightIntensity));
         });
     gui.add(sceneParameters, 'shadow').onChange(value => {
         renderer.shadowMap.enabled = value;
diff --git a/examples-testing/examples/webgl_postprocessing_outline.ts b/examples-testing/examples/webgl_postprocessing_outline.ts
index 31ef6b9b2..4b1fa11a3 100644
--- a/examples-testing/examples/webgl_postprocessing_outline.ts
+++ b/examples-testing/examples/webgl_postprocessing_outline.ts
@@ -12,11 +12,11 @@ import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
 
-let container, stats;
-let camera, scene, renderer, controls;
-let composer, effectFXAA, outlinePass;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
+let composer: EffectComposer, effectFXAA: ShaderPass, outlinePass: OutlinePass;
 
-let selectedObjects = [];
+let selectedObjects: THREE.Object3D[] = [];
 
 const raycaster = new THREE.Raycaster();
 const mouse = new THREE.Vector2();
@@ -59,9 +59,14 @@ gui.add(params, 'usePatternTexture').onChange(function (value) {
     outlinePass.usePatternTexture = value;
 });
 
-function Configuration() {
-    this.visibleEdgeColor = '#ffffff';
-    this.hiddenEdgeColor = '#190a05';
+class Configuration {
+    visibleEdgeColor: string;
+    hiddenEdgeColor: string;
+
+    constructor() {
+        this.visibleEdgeColor = '#ffffff';
+        this.hiddenEdgeColor = '#190a05';
+    }
 }
 
 const conf = new Configuration();
@@ -223,7 +228,7 @@ function init() {
     renderer.domElement.style.touchAction = 'none';
     renderer.domElement.addEventListener('pointermove', onPointerMove);
 
-    function onPointerMove(event) {
+    function onPointerMove(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
         mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
@@ -232,7 +237,7 @@ function init() {
         checkIntersection();
     }
 
-    function addSelectedObject(object) {
+    function addSelectedObject(object: THREE.Object3D) {
         selectedObjects = [];
         selectedObjects.push(object);
     }
diff --git a/examples-testing/examples/webgl_postprocessing_pixel.ts b/examples-testing/examples/webgl_postprocessing_pixel.ts
index 15b54d072..fdea0e6ec 100644
--- a/examples-testing/examples/webgl_postprocessing_pixel.ts
+++ b/examples-testing/examples/webgl_postprocessing_pixel.ts
@@ -6,8 +6,14 @@ import { RenderPixelatedPass } from 'three/addons/postprocessing/RenderPixelated
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, composer, crystalMesh, clock;
-let gui, params;
+let camera: THREE.OrthographicCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    composer: EffectComposer,
+    crystalMesh: THREE.Mesh<THREE.IcosahedronGeometry, THREE.MeshPhongMaterial>,
+    clock: THREE.Clock;
+let gui: GUI,
+    params: { pixelSize: number; normalEdgeStrength: number; depthEdgeStrength: number; pixelAlignedPanning: boolean };
 
 init();
 
@@ -53,8 +59,14 @@ function init() {
         .onChange(() => {
             renderPixelatedPass.setPixelSize(params.pixelSize);
         });
-    gui.add(renderPixelatedPass, 'normalEdgeStrength').min(0).max(2).step(0.05);
-    gui.add(renderPixelatedPass, 'depthEdgeStrength').min(0).max(1).step(0.05);
+    gui.add(renderPixelatedPass as { normalEdgeStrength: number }, 'normalEdgeStrength')
+        .min(0)
+        .max(2)
+        .step(0.05);
+    gui.add(renderPixelatedPass as { depthEdgeStrength: number }, 'depthEdgeStrength')
+        .min(0)
+        .max(1)
+        .step(0.05);
     gui.add(params, 'pixelAlignedPanning');
 
     // textures
@@ -69,7 +81,7 @@ function init() {
 
     const boxMaterial = new THREE.MeshPhongMaterial({ map: texChecker2 });
 
-    function addBox(boxSideLength, x, z, rotation) {
+    function addBox(boxSideLength: number, x: number, z: number, rotation: number) {
         const mesh = new THREE.Mesh(new THREE.BoxGeometry(boxSideLength, boxSideLength, boxSideLength), boxMaterial);
         mesh.castShadow = true;
         mesh.receiveShadow = true;
@@ -166,7 +178,7 @@ function animate() {
 
 // Helper functions
 
-function pixelTexture(texture) {
+function pixelTexture(texture: THREE.Texture) {
     texture.minFilter = THREE.NearestFilter;
     texture.magFilter = THREE.NearestFilter;
     texture.generateMipmaps = false;
@@ -176,25 +188,30 @@ function pixelTexture(texture) {
     return texture;
 }
 
-function easeInOutCubic(x) {
+function easeInOutCubic(x: number) {
     return x ** 2 * 3 - x ** 3 * 2;
 }
 
-function linearStep(x, edge0, edge1) {
+function linearStep(x: number, edge0: number, edge1: number) {
     const w = edge1 - edge0;
     const m = 1 / w;
     const y0 = -m * edge0;
     return THREE.MathUtils.clamp(y0 + m * x, 0, 1);
 }
 
-function stopGoEased(x, downtime, period) {
+function stopGoEased(x: number, downtime: number, period: number) {
     const cycle = (x / period) | 0;
     const tween = x - cycle * period;
     const linStep = easeInOutCubic(linearStep(tween, downtime, period));
     return cycle + linStep;
 }
 
-function pixelAlignFrustum(camera, aspectRatio, pixelsPerScreenWidth, pixelsPerScreenHeight) {
+function pixelAlignFrustum(
+    camera: THREE.OrthographicCamera,
+    aspectRatio: number,
+    pixelsPerScreenWidth: number,
+    pixelsPerScreenHeight: number,
+) {
     // 0. Get Pixel Grid Units
     const worldScreenWidth = (camera.right - camera.left) / camera.zoom;
     const worldScreenHeight = (camera.top - camera.bottom) / camera.zoom;
diff --git a/examples-testing/examples/webgl_postprocessing_procedural.ts b/examples-testing/examples/webgl_postprocessing_procedural.ts
index 869824270..4533b72bd 100644
--- a/examples-testing/examples/webgl_postprocessing_procedural.ts
+++ b/examples-testing/examples/webgl_postprocessing_procedural.ts
@@ -3,16 +3,20 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let postCamera, postScene, renderer;
-let postMaterial, noiseRandom1DMaterial, noiseRandom2DMaterial, noiseRandom3DMaterial, postQuad;
-let stats;
+let postCamera: THREE.OrthographicCamera, postScene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let postMaterial: THREE.ShaderMaterial,
+    noiseRandom1DMaterial: THREE.ShaderMaterial,
+    noiseRandom2DMaterial: THREE.ShaderMaterial,
+    noiseRandom3DMaterial: THREE.ShaderMaterial,
+    postQuad: THREE.Mesh;
+let stats: Stats;
 
 const params = { procedure: 'noiseRandom3D' };
 
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer();
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -26,16 +30,16 @@ function init() {
     // Setup post processing stage
     postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
     noiseRandom1DMaterial = new THREE.ShaderMaterial({
-        vertexShader: document.querySelector('#procedural-vert').textContent.trim(),
-        fragmentShader: document.querySelector('#noiseRandom1D-frag').textContent.trim(),
+        vertexShader: document.querySelector('#procedural-vert')!.textContent!.trim(),
+        fragmentShader: document.querySelector('#noiseRandom1D-frag')!.textContent!.trim(),
     });
     noiseRandom2DMaterial = new THREE.ShaderMaterial({
-        vertexShader: document.querySelector('#procedural-vert').textContent.trim(),
-        fragmentShader: document.querySelector('#noiseRandom2D-frag').textContent.trim(),
+        vertexShader: document.querySelector('#procedural-vert')!.textContent!.trim(),
+        fragmentShader: document.querySelector('#noiseRandom2D-frag')!.textContent!.trim(),
     });
     noiseRandom3DMaterial = new THREE.ShaderMaterial({
-        vertexShader: document.querySelector('#procedural-vert').textContent.trim(),
-        fragmentShader: document.querySelector('#noiseRandom3D-frag').textContent.trim(),
+        vertexShader: document.querySelector('#procedural-vert')!.textContent!.trim(),
+        fragmentShader: document.querySelector('#noiseRandom3D-frag')!.textContent!.trim(),
     });
     postMaterial = noiseRandom3DMaterial;
     const postPlane = new THREE.PlaneGeometry(2, 2);
diff --git a/examples-testing/examples/webgl_postprocessing_rgb_halftone.ts b/examples-testing/examples/webgl_postprocessing_rgb_halftone.ts
index ea00886d1..41f6c7823 100644
--- a/examples-testing/examples/webgl_postprocessing_rgb_halftone.ts
+++ b/examples-testing/examples/webgl_postprocessing_rgb_halftone.ts
@@ -8,11 +8,11 @@ import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
 import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { HalftonePass } from 'three/addons/postprocessing/HalftonePass.js';
 
-let renderer, clock, camera, stats;
+let renderer: THREE.WebGLRenderer, clock: THREE.Clock, camera: THREE.PerspectiveCamera, stats: Stats;
 
 const rotationSpeed = Math.PI / 64;
 
-let composer, group;
+let composer: EffectComposer, group: THREE.Group;
 
 init();
 
diff --git a/examples-testing/examples/webgl_postprocessing_sao.ts b/examples-testing/examples/webgl_postprocessing_sao.ts
index 0c6298e6b..c7ab9a36e 100644
--- a/examples-testing/examples/webgl_postprocessing_sao.ts
+++ b/examples-testing/examples/webgl_postprocessing_sao.ts
@@ -8,10 +8,10 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { SAOPass } from 'three/addons/postprocessing/SAOPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let container, stats;
-let camera, scene, renderer;
-let composer, renderPass, saoPass;
-let group;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let composer: EffectComposer, renderPass: RenderPass, saoPass: SAOPass;
+let group: THREE.Object3D;
 
 init();
 
diff --git a/examples-testing/examples/webgl_postprocessing_smaa.ts b/examples-testing/examples/webgl_postprocessing_smaa.ts
index 9e73d38b0..e07817b17 100644
--- a/examples-testing/examples/webgl_postprocessing_smaa.ts
+++ b/examples-testing/examples/webgl_postprocessing_smaa.ts
@@ -8,7 +8,12 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, scene, renderer, composer, stats, smaaPass;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    composer: EffectComposer,
+    stats: Stats,
+    smaaPass: SMAAPass;
 
 const params = {
     enabled: true,
@@ -18,7 +23,7 @@ const params = {
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer();
     renderer.setPixelRatio(window.devicePixelRatio);
diff --git a/examples-testing/examples/webgl_postprocessing_sobel.ts b/examples-testing/examples/webgl_postprocessing_sobel.ts
index 55d88dc02..1512ed8bd 100644
--- a/examples-testing/examples/webgl_postprocessing_sobel.ts
+++ b/examples-testing/examples/webgl_postprocessing_sobel.ts
@@ -11,9 +11,9 @@ import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
 import { LuminosityShader } from 'three/addons/shaders/LuminosityShader.js';
 import { SobelOperatorShader } from 'three/addons/shaders/SobelOperatorShader.js';
 
-let camera, scene, renderer, composer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
 
-let effectSobel;
+let effectSobel: ShaderPass;
 
 const params = {
     enable: true,
diff --git a/examples-testing/examples/webgl_postprocessing_ssaa.ts b/examples-testing/examples/webgl_postprocessing_ssaa.ts
index 45d8767b1..84be0a91f 100644
--- a/examples-testing/examples/webgl_postprocessing_ssaa.ts
+++ b/examples-testing/examples/webgl_postprocessing_ssaa.ts
@@ -7,10 +7,10 @@ import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
 import { SSAARenderPass } from 'three/addons/postprocessing/SSAARenderPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let scene, renderer, composer;
-let cameraP, ssaaRenderPassP;
-let cameraO, ssaaRenderPassO;
-let gui, stats;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let cameraP: THREE.PerspectiveCamera, ssaaRenderPassP: SSAARenderPass;
+let cameraO: THREE.OrthographicCamera, ssaaRenderPassO: SSAARenderPass;
+let gui: GUI, stats: Stats;
 
 const params = {
     sampleLevel: 4,
@@ -50,7 +50,7 @@ function clearGui() {
 }
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     const width = window.innerWidth || 1;
     const height = window.innerHeight || 1;
@@ -206,7 +206,7 @@ function animate() {
     ssaaRenderPassP.enabled = params.camera === 'perspective';
     ssaaRenderPassO.enabled = params.camera === 'orthographic';
 
-    cameraP.view.offsetX = params.viewOffsetX;
+    cameraP.view!.offsetX = params.viewOffsetX;
 
     composer.render();
 
diff --git a/examples-testing/examples/webgl_postprocessing_ssao.ts b/examples-testing/examples/webgl_postprocessing_ssao.ts
index fd3739af3..5d2865f06 100644
--- a/examples-testing/examples/webgl_postprocessing_ssao.ts
+++ b/examples-testing/examples/webgl_postprocessing_ssao.ts
@@ -8,10 +8,10 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let container, stats;
-let camera, scene, renderer;
-let composer;
-let group;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let composer: EffectComposer;
+let group: THREE.Group;
 
 init();
 
diff --git a/examples-testing/examples/webgl_postprocessing_ssr.ts b/examples-testing/examples/webgl_postprocessing_ssr.ts
index 1f5e48d3b..bad3a477f 100644
--- a/examples-testing/examples/webgl_postprocessing_ssr.ts
+++ b/examples-testing/examples/webgl_postprocessing_ssr.ts
@@ -18,17 +18,17 @@ const params = {
     otherMeshes: true,
     groundReflector: true,
 };
-let composer;
-let ssrPass;
-let gui;
-let stats;
-let controls;
-let camera, scene, renderer;
-const otherMeshes = [];
-let groundReflector;
-const selects = [];
-
-const container = document.querySelector('#container');
+let composer: EffectComposer;
+let ssrPass: SSRPass;
+let gui: GUI;
+let stats: Stats;
+let controls: OrbitControls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+const otherMeshes: THREE.Mesh[] = [];
+let groundReflector: ReflectorForSSRPass;
+const selects: THREE.Mesh[] = [];
+
+const container = document.querySelector('#container')!;
 
 // Configure and create Draco decoder.
 const dracoLoader = new DRACOLoader();
@@ -77,7 +77,7 @@ function init() {
         dracoLoader.dispose();
     });
 
-    let geometry, material, mesh;
+    let geometry: THREE.BufferGeometry, material: THREE.MeshStandardMaterial, mesh: THREE.Mesh;
 
     geometry = new THREE.BoxGeometry(0.05, 0.05, 0.05);
     material = new THREE.MeshStandardMaterial({ color: 'green' });
diff --git a/examples-testing/examples/webgl_postprocessing_taa.ts b/examples-testing/examples/webgl_postprocessing_taa.ts
index 11a986741..ddb2bcc6c 100644
--- a/examples-testing/examples/webgl_postprocessing_taa.ts
+++ b/examples-testing/examples/webgl_postprocessing_taa.ts
@@ -8,8 +8,13 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { TAARenderPass } from 'three/addons/postprocessing/TAARenderPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, scene, renderer, composer, taaRenderPass, renderPass;
-let gui, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    composer: EffectComposer,
+    taaRenderPass: TAARenderPass,
+    renderPass: RenderPass;
+let gui: GUI | undefined, stats: Stats;
 let index = 0;
 
 const param = { TAAEnabled: '1', TAASampleLevel: 0 };
@@ -50,7 +55,7 @@ function clearGui() {
 }
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     renderer = new THREE.WebGLRenderer();
     renderer.setPixelRatio(window.devicePixelRatio);
diff --git a/examples-testing/examples/webgl_postprocessing_transition.ts b/examples-testing/examples/webgl_postprocessing_transition.ts
index d05466131..8c5fb8719 100644
--- a/examples-testing/examples/webgl_postprocessing_transition.ts
+++ b/examples-testing/examples/webgl_postprocessing_transition.ts
@@ -7,10 +7,10 @@ import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
 import { RenderTransitionPass } from 'three/addons/postprocessing/RenderTransitionPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let stats;
-let renderer, composer, renderTransitionPass;
+let stats: Stats;
+let renderer: THREE.WebGLRenderer, composer: EffectComposer, renderTransitionPass: RenderTransitionPass;
 
-const textures = [];
+const textures: THREE.Texture[] = [];
 const clock = new THREE.Clock();
 
 const params = {
@@ -23,6 +23,56 @@ const params = {
     threshold: 0.1,
 };
 
+class FXScene {
+    rotationSpeed: THREE.Vector3;
+
+    scene: THREE.Scene;
+    camera: THREE.PerspectiveCamera;
+    mesh: THREE.InstancedMesh;
+
+    update: (delta: number) => void;
+
+    resize: () => void;
+
+    constructor(geometry: THREE.BufferGeometry, rotationSpeed: THREE.Vector3, backgroundColor: number) {
+        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
+        camera.position.z = 20;
+
+        // Setup scene
+        const scene = new THREE.Scene();
+        scene.background = new THREE.Color(backgroundColor);
+        scene.add(new THREE.AmbientLight(0xaaaaaa, 3));
+
+        const light = new THREE.DirectionalLight(0xffffff, 3);
+        light.position.set(0, 1, 4);
+        scene.add(light);
+
+        this.rotationSpeed = rotationSpeed;
+
+        const color = geometry.type === 'BoxGeometry' ? 0x0000ff : 0xff0000;
+        const material = new THREE.MeshPhongMaterial({ color: color, flatShading: true });
+        const mesh = generateInstancedMesh(geometry, material, 500);
+        scene.add(mesh);
+
+        this.scene = scene;
+        this.camera = camera;
+        this.mesh = mesh;
+
+        this.update = function (delta) {
+            if (params.sceneAnimate) {
+                mesh.rotation.x += this.rotationSpeed.x * delta;
+                mesh.rotation.y += this.rotationSpeed.y * delta;
+                mesh.rotation.z += this.rotationSpeed.z * delta;
+            }
+        };
+
+        this.resize = function () {
+            camera.aspect = window.innerWidth / window.innerHeight;
+            camera.updateProjectionMatrix();
+        };
+    }
+}
+
 const fxSceneA = new FXScene(new THREE.BoxGeometry(2, 2, 2), new THREE.Vector3(0, -0.4, 0), 0xffffff);
 const fxSceneB = new FXScene(new THREE.IcosahedronGeometry(1, 1), new THREE.Vector3(0, 0.2, 0.1), 0x000000);
 
@@ -138,45 +188,7 @@ function render() {
     }
 }
 
-function FXScene(geometry, rotationSpeed, backgroundColor) {
-    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
-    camera.position.z = 20;
-
-    // Setup scene
-    const scene = new THREE.Scene();
-    scene.background = new THREE.Color(backgroundColor);
-    scene.add(new THREE.AmbientLight(0xaaaaaa, 3));
-
-    const light = new THREE.DirectionalLight(0xffffff, 3);
-    light.position.set(0, 1, 4);
-    scene.add(light);
-
-    this.rotationSpeed = rotationSpeed;
-
-    const color = geometry.type === 'BoxGeometry' ? 0x0000ff : 0xff0000;
-    const material = new THREE.MeshPhongMaterial({ color: color, flatShading: true });
-    const mesh = generateInstancedMesh(geometry, material, 500);
-    scene.add(mesh);
-
-    this.scene = scene;
-    this.camera = camera;
-    this.mesh = mesh;
-
-    this.update = function (delta) {
-        if (params.sceneAnimate) {
-            mesh.rotation.x += this.rotationSpeed.x * delta;
-            mesh.rotation.y += this.rotationSpeed.y * delta;
-            mesh.rotation.z += this.rotationSpeed.z * delta;
-        }
-    };
-
-    this.resize = function () {
-        camera.aspect = window.innerWidth / window.innerHeight;
-        camera.updateProjectionMatrix();
-    };
-}
-
-function generateInstancedMesh(geometry, material, count) {
+function generateInstancedMesh(geometry: THREE.BufferGeometry, material: THREE.MeshPhongMaterial, count: number) {
     const mesh = new THREE.InstancedMesh(geometry, material, count);
 
     const dummy = new THREE.Object3D();
diff --git a/examples-testing/examples/webgl_postprocessing_unreal_bloom.ts b/examples-testing/examples/webgl_postprocessing_unreal_bloom.ts
index ddcf5e6e5..b386e1cb5 100644
--- a/examples-testing/examples/webgl_postprocessing_unreal_bloom.ts
+++ b/examples-testing/examples/webgl_postprocessing_unreal_bloom.ts
@@ -10,8 +10,8 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, stats;
-let composer, renderer, mixer, clock;
+let camera: THREE.PerspectiveCamera, stats: Stats;
+let composer: EffectComposer, renderer: THREE.WebGLRenderer, mixer: THREE.AnimationMixer, clock: THREE.Clock;
 
 const params = {
     threshold: 0,
@@ -23,7 +23,7 @@ const params = {
 init();
 
 async function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     clock = new THREE.Clock();
 
diff --git a/examples-testing/examples/webgl_postprocessing_unreal_bloom_selective.ts b/examples-testing/examples/webgl_postprocessing_unreal_bloom_selective.ts
index 288b4477d..e56fedad4 100644
--- a/examples-testing/examples/webgl_postprocessing_unreal_bloom_selective.ts
+++ b/examples-testing/examples/webgl_postprocessing_unreal_bloom_selective.ts
@@ -23,7 +23,7 @@ const params = {
 };
 
 const darkMaterial = new THREE.MeshBasicMaterial({ color: 'black' });
-const materials = {};
+const materials: Record<string, THREE.Material | THREE.Material[]> = {};
 
 const renderer = new THREE.WebGLRenderer({ antialias: false });
 renderer.setPixelRatio(window.devicePixelRatio);
@@ -67,8 +67,8 @@ const mixPass = new ShaderPass(
             bloomTexture: { value: bloomComposer.renderTarget2.texture },
             bloomStrength: { value: params.strength },
         },
-        vertexShader: document.getElementById('vertexshader').textContent,
-        fragmentShader: document.getElementById('fragmentshader').textContent,
+        vertexShader: document.getElementById('vertexshader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentshader')!.textContent!,
         defines: {},
     }),
     'baseTexture',
@@ -125,7 +125,7 @@ toneMappingFolder.add(params, 'exposure', 0.1, 2).onChange(function (value) {
 
 setupScene();
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
     mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
 
@@ -178,9 +178,9 @@ function setupScene() {
     render();
 }
 
-function disposeMaterial(obj) {
-    if (obj.material) {
-        obj.material.dispose();
+function disposeMaterial(obj: THREE.Object3D) {
+    if ((obj as THREE.Mesh).material) {
+        ((obj as THREE.Mesh).material as THREE.Material).dispose();
     }
 }
 
@@ -193,16 +193,16 @@ function render() {
     finalComposer.render();
 }
 
-function darkenNonBloomed(obj) {
-    if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
-        materials[obj.uuid] = obj.material;
-        obj.material = darkMaterial;
+function darkenNonBloomed(obj: THREE.Object3D) {
+    if ((obj as THREE.Mesh).isMesh && bloomLayer.test(obj.layers) === false) {
+        materials[obj.uuid] = (obj as THREE.Mesh).material;
+        (obj as THREE.Mesh).material = darkMaterial;
     }
 }
 
-function restoreMaterial(obj) {
+function restoreMaterial(obj: THREE.Object3D) {
     if (materials[obj.uuid]) {
-        obj.material = materials[obj.uuid];
+        (obj as THREE.Mesh).material = materials[obj.uuid];
         delete materials[obj.uuid];
     }
 }
diff --git a/examples-testing/examples/webgl_random_uv.ts b/examples-testing/examples/webgl_random_uv.ts
index fea6b3478..fef399378 100644
--- a/examples-testing/examples/webgl_random_uv.ts
+++ b/examples-testing/examples/webgl_random_uv.ts
@@ -6,14 +6,24 @@ import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
-
-let camera, scene, renderer, dirLight, ground, gui, material, materialIn, uniforms, uniformsIn;
+import { IUniform } from 'three';
+
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    dirLight: THREE.DirectionalLight,
+    ground: THREE.Mesh<THREE.PlaneGeometry, THREE.ShadowMaterial>,
+    gui: GUI,
+    material: THREE.MeshStandardMaterial,
+    materialIn: THREE.MeshStandardMaterial,
+    uniforms: { [uniform: string]: IUniform },
+    uniformsIn: { [uniform: string]: IUniform };
 
 init();
 render();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 20);
     camera.position.set(-0.8, 0.6, 1.5);
@@ -95,12 +105,14 @@ function init() {
                 shaderBall.children[i].renderOrder = n++;
             }
 
-            material = shaderBall.children[0].material;
+            material = (shaderBall.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>)
+                .material;
             material.map = map;
             material.alphaMap = disolveMap;
             material.transparent = true;
 
-            materialIn = shaderBall.children[1].material;
+            materialIn = (shaderBall.children[1] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>)
+                .material;
             materialIn.alphaMap = disolveMap;
             materialIn.transparent = true;
 
diff --git a/examples-testing/examples/webgl_raycaster_sprite.ts b/examples-testing/examples/webgl_raycaster_sprite.ts
index f35d5de17..73dd93494 100644
--- a/examples-testing/examples/webgl_raycaster_sprite.ts
+++ b/examples-testing/examples/webgl_raycaster_sprite.ts
@@ -2,10 +2,10 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let renderer, scene, camera;
-let group;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let group: THREE.Group;
 
-let selectedObject = null;
+let selectedObject: THREE.Mesh<THREE.BufferGeometry, THREE.SpriteMaterial> | null = null;
 const raycaster = new THREE.Raycaster();
 const pointer = new THREE.Vector2();
 
@@ -77,7 +77,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (selectedObject) {
         selectedObject.material.color.set('#69f');
         selectedObject = null;
@@ -96,7 +96,7 @@ function onPointerMove(event) {
         })[0];
 
         if (res && res.object) {
-            selectedObject = res.object;
+            selectedObject = res.object as THREE.Mesh<THREE.BufferGeometry, THREE.SpriteMaterial>;
             selectedObject.material.color.set('#f00');
         }
     }
diff --git a/examples-testing/examples/webgl_raycaster_texture.ts b/examples-testing/examples/webgl_raycaster_texture.ts
index 72c7054dc..0e584dc0b 100644
--- a/examples-testing/examples/webgl_raycaster_texture.ts
+++ b/examples-testing/examples/webgl_raycaster_texture.ts
@@ -8,7 +8,15 @@ const WRAPPING = {
     MirroredRepeatWrapping: THREE.MirroredRepeatWrapping,
 };
 
-const params = {
+const params: {
+    wrapS: THREE.Wrapping;
+    wrapT: THREE.Wrapping;
+    offsetX: number;
+    offsetY: number;
+    repeatX: number;
+    repeatY: number;
+    rotation: number;
+} = {
     wrapS: THREE.RepeatWrapping,
     wrapT: THREE.RepeatWrapping,
     offsetX: 0,
@@ -18,68 +26,68 @@ const params = {
     rotation: 0,
 };
 
-function CanvasTexture(parentTexture) {
-    this._canvas = document.createElement('canvas');
-    this._canvas.width = this._canvas.height = 1024;
-    this._context2D = this._canvas.getContext('2d');
+class CanvasTexture {
+    _background: HTMLImageElement;
 
-    if (parentTexture) {
-        this._parentTexture.push(parentTexture);
-        parentTexture.image = this._canvas;
-    }
+    constructor(parentTexture: THREE.Texture) {
+        this._canvas = document.createElement('canvas');
+        this._canvas.width = this._canvas.height = 1024;
+        this._context2D = this._canvas.getContext('2d');
 
-    const that = this;
-    this._background = document.createElement('img');
-    this._background.addEventListener('load', function () {
-        that._canvas.width = that._background.naturalWidth;
-        that._canvas.height = that._background.naturalHeight;
+        if (parentTexture) {
+            this._parentTexture.push(parentTexture);
+            parentTexture.image = this._canvas;
+        }
 
-        that._crossRadius = Math.ceil(Math.min(that._canvas.width, that._canvas.height / 30));
-        that._crossMax = Math.ceil(0.70710678 * that._crossRadius);
-        that._crossMin = Math.ceil(that._crossMax / 10);
-        that._crossThickness = Math.ceil(that._crossMax / 10);
+        const that = this;
+        this._background = document.createElement('img');
+        this._background.addEventListener('load', function () {
+            that._canvas!.width = that._background.naturalWidth;
+            that._canvas!.height = that._background.naturalHeight;
 
-        that._draw();
-    });
-    this._background.crossOrigin = '';
-    this._background.src = 'textures/uv_grid_opengl.jpg';
+            that._crossRadius = Math.ceil(Math.min(that._canvas!.width, that._canvas!.height / 30));
+            that._crossMax = Math.ceil(0.70710678 * that._crossRadius);
+            that._crossMin = Math.ceil(that._crossMax / 10);
+            that._crossThickness = Math.ceil(that._crossMax / 10);
 
-    this._draw();
-}
+            that._draw();
+        });
+        this._background.crossOrigin = '';
+        this._background.src = 'textures/uv_grid_opengl.jpg';
 
-CanvasTexture.prototype = {
-    constructor: CanvasTexture,
+        this._draw();
+    }
 
-    _canvas: null,
-    _context2D: null,
-    _xCross: 0,
-    _yCross: 0,
+    _canvas: HTMLCanvasElement | null = null;
+    _context2D: CanvasRenderingContext2D | null = null;
+    _xCross = 0;
+    _yCross = 0;
 
-    _crossRadius: 57,
-    _crossMax: 40,
-    _crossMin: 4,
-    _crossThickness: 4,
+    _crossRadius = 57;
+    _crossMax = 40;
+    _crossMin = 4;
+    _crossThickness = 4;
 
-    _parentTexture: [],
+    _parentTexture: THREE.Texture[] = [];
 
-    addParent: function (parentTexture) {
+    addParent = function (this: CanvasTexture, parentTexture: THREE.Texture) {
         if (this._parentTexture.indexOf(parentTexture) === -1) {
             this._parentTexture.push(parentTexture);
             parentTexture.image = this._canvas;
         }
-    },
+    };
 
-    setCrossPosition: function (x, y) {
-        this._xCross = x * this._canvas.width;
-        this._yCross = y * this._canvas.height;
+    setCrossPosition = function (this: CanvasTexture, x: number, y: number) {
+        this._xCross = x * this._canvas!.width;
+        this._yCross = y * this._canvas!.height;
 
         this._draw();
-    },
+    };
 
-    _draw: function () {
+    _draw = function (this: CanvasTexture) {
         if (!this._context2D) return;
 
-        this._context2D.clearRect(0, 0, this._canvas.width, this._canvas.height);
+        this._context2D.clearRect(0, 0, this._canvas!.width, this._canvas!.height);
 
         // Background.
         this._context2D.drawImage(this._background, 0, 0);
@@ -106,18 +114,18 @@ CanvasTexture.prototype = {
         for (let i = 0; i < this._parentTexture.length; i++) {
             this._parentTexture[i].needsUpdate = true;
         }
-    },
-};
+    };
+}
 
 const width = window.innerWidth;
 const height = window.innerHeight;
 
-let canvas;
-let planeTexture, cubeTexture, circleTexture;
+let canvas: CanvasTexture;
+let planeTexture: THREE.Texture, cubeTexture: THREE.Texture, circleTexture: THREE.Texture;
 
-let container;
+let container: HTMLElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const raycaster = new THREE.Raycaster();
 const mouse = new THREE.Vector2();
@@ -126,7 +134,7 @@ const onClickPosition = new THREE.Vector2();
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
     scene.background = new THREE.Color(0xeeeeee);
@@ -233,7 +241,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onMouseMove(evt) {
+function onMouseMove(evt: MouseEvent) {
     evt.preventDefault();
 
     const array = getMousePosition(container, evt.clientX, evt.clientY);
@@ -243,17 +251,19 @@ function onMouseMove(evt) {
 
     if (intersects.length > 0 && intersects[0].uv) {
         const uv = intersects[0].uv;
-        intersects[0].object.material.map.transformUv(uv);
+        (intersects[0].object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshBasicMaterial>).material.map!.transformUv(
+            uv,
+        );
         canvas.setCrossPosition(uv.x, uv.y);
     }
 }
 
-function getMousePosition(dom, x, y) {
+function getMousePosition(dom: HTMLElement, x: number, y: number) {
     const rect = dom.getBoundingClientRect();
     return [(x - rect.left) / rect.width, (y - rect.top) / rect.height];
 }
 
-function getIntersects(point, objects) {
+function getIntersects(point: THREE.Vector2, objects: THREE.Object3D[]) {
     mouse.set(point.x * 2 - 1, -(point.y * 2) + 1);
 
     raycaster.setFromCamera(mouse, camera);
@@ -275,12 +285,12 @@ function animate() {
     renderer.render(scene, camera);
 }
 
-function setwrapS(value) {
+function setwrapS(value: THREE.Wrapping) {
     circleTexture.wrapS = value;
     circleTexture.needsUpdate = true;
 }
 
-function setwrapT(value) {
+function setwrapT(value: THREE.Wrapping) {
     circleTexture.wrapT = value;
     circleTexture.needsUpdate = true;
 }
diff --git a/examples-testing/examples/webgl_read_float_buffer.ts b/examples-testing/examples/webgl_read_float_buffer.ts
index 69f847729..e0e975c4f 100644
--- a/examples-testing/examples/webgl_read_float_buffer.ts
+++ b/examples-testing/examples/webgl_read_float_buffer.ts
@@ -2,9 +2,14 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let cameraRTT, sceneRTT, sceneScreen, renderer, zmesh1, zmesh2;
+let cameraRTT: THREE.OrthographicCamera,
+    sceneRTT: THREE.Scene,
+    sceneScreen: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    zmesh1: THREE.Mesh,
+    zmesh2: THREE.Mesh;
 
 let mouseX = 0,
     mouseY = 0;
@@ -12,15 +17,15 @@ let mouseX = 0,
 const windowHalfX = window.innerWidth / 2;
 const windowHalfY = window.innerHeight / 2;
 
-let rtTexture, material, quad;
+let rtTexture: THREE.WebGLRenderTarget, material: THREE.ShaderMaterial, quad: THREE.Mesh;
 
 let delta = 0.01;
-let valueNode;
+let valueNode: HTMLElement;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     cameraRTT = new THREE.OrthographicCamera(
         window.innerWidth / -2,
@@ -54,14 +59,14 @@ function init() {
 
     material = new THREE.ShaderMaterial({
         uniforms: { time: { value: 0.0 } },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragment_shader_pass_1').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragment_shader_pass_1')!.textContent!,
     });
 
     const materialScreen = new THREE.ShaderMaterial({
         uniforms: { tDiffuse: { value: rtTexture.texture } },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragment_shader_screen').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragment_shader_screen')!.textContent!,
 
         depthWrite: false,
     });
@@ -102,12 +107,12 @@ function init() {
     stats = new Stats();
     container.appendChild(stats.dom);
 
-    valueNode = document.getElementById('values');
+    valueNode = document.getElementById('values')!;
 
     document.addEventListener('mousemove', onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgl_refraction.ts b/examples-testing/examples/webgl_refraction.ts
index 572575afa..169120a14 100644
--- a/examples-testing/examples/webgl_refraction.ts
+++ b/examples-testing/examples/webgl_refraction.ts
@@ -4,14 +4,14 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Refractor } from 'three/addons/objects/Refractor.js';
 import { WaterRefractionShader } from 'three/addons/shaders/WaterRefractionShader.js';
 
-let camera, scene, renderer, clock;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
 
-let refractor, smallSphere;
+let refractor: Refractor, smallSphere: THREE.Mesh;
 
 init();
 
 async function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     clock = new THREE.Clock();
 
diff --git a/examples-testing/examples/webgl_rtt.ts b/examples-testing/examples/webgl_rtt.ts
index b80e78ed3..47e8e8b3b 100644
--- a/examples-testing/examples/webgl_rtt.ts
+++ b/examples-testing/examples/webgl_rtt.ts
@@ -2,9 +2,16 @@ import * as THREE from 'three';
 
 import Stats from 'three/addons/libs/stats.module.js';
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let cameraRTT, camera, sceneRTT, sceneScreen, scene, renderer, zmesh1, zmesh2;
+let cameraRTT: THREE.OrthographicCamera,
+    camera: THREE.PerspectiveCamera,
+    sceneRTT: THREE.Scene,
+    sceneScreen: THREE.Scene,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    zmesh1: THREE.Mesh,
+    zmesh2: THREE.Mesh;
 
 let mouseX = 0,
     mouseY = 0;
@@ -12,14 +19,14 @@ let mouseX = 0,
 const windowHalfX = window.innerWidth / 2;
 const windowHalfY = window.innerHeight / 2;
 
-let rtTexture, material, quad;
+let rtTexture: THREE.WebGLRenderTarget, material: THREE.ShaderMaterial, quad: THREE.Mesh;
 
 let delta = 0.01;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 100;
@@ -52,14 +59,14 @@ function init() {
 
     material = new THREE.ShaderMaterial({
         uniforms: { time: { value: 0.0 } },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragment_shader_pass_1').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragment_shader_pass_1')!.textContent!,
     });
 
     const materialScreen = new THREE.ShaderMaterial({
         uniforms: { tDiffuse: { value: rtTexture.texture } },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragment_shader_screen').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragment_shader_screen')!.textContent!,
 
         depthWrite: false,
     });
@@ -121,7 +128,7 @@ function init() {
     document.addEventListener('mousemove', onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgl_shader.ts b/examples-testing/examples/webgl_shader.ts
index 47a6c7ece..7ac1257b6 100644
--- a/examples-testing/examples/webgl_shader.ts
+++ b/examples-testing/examples/webgl_shader.ts
@@ -1,13 +1,13 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let uniforms;
+let uniforms: Record<string, THREE.IUniform<unknown>>;
 
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
 
@@ -21,8 +21,8 @@ function init() {
 
     const material = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
     });
 
     const mesh = new THREE.Mesh(geometry, material);
diff --git a/examples-testing/examples/webgl_shader_lava.ts b/examples-testing/examples/webgl_shader_lava.ts
index 973a580eb..a5d1f1afb 100644
--- a/examples-testing/examples/webgl_shader_lava.ts
+++ b/examples-testing/examples/webgl_shader_lava.ts
@@ -5,14 +5,22 @@ import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { BloomPass } from 'three/addons/postprocessing/BloomPass.js';
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 
-let camera, renderer, composer, clock;
-
-let uniforms, mesh;
+let camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, composer: EffectComposer, clock: THREE.Clock;
+
+let uniforms: {
+        fogDensity: THREE.IUniform<number>;
+        fogColor: THREE.IUniform<THREE.Vector3>;
+        time: THREE.IUniform<number>;
+        uvScale: THREE.IUniform<THREE.Vector2>;
+        texture1: THREE.IUniform<THREE.Texture>;
+        texture2: THREE.IUniform<THREE.Texture>;
+    },
+    mesh: THREE.Mesh;
 
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 3000);
     camera.position.z = 4;
@@ -44,8 +52,8 @@ function init() {
 
     const material = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
     });
 
     mesh = new THREE.Mesh(new THREE.TorusGeometry(size, 0.3, 30, 30), material);
diff --git a/examples-testing/examples/webgl_shaders_ocean.ts b/examples-testing/examples/webgl_shaders_ocean.ts
index 8b0f9a738..afbdb1dae 100644
--- a/examples-testing/examples/webgl_shaders_ocean.ts
+++ b/examples-testing/examples/webgl_shaders_ocean.ts
@@ -7,14 +7,14 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Water } from 'three/addons/objects/Water.js';
 import { Sky } from 'three/addons/objects/Sky.js';
 
-let container, stats;
-let camera, scene, renderer;
-let controls, water, sun, mesh;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controls: OrbitControls, water: Water, sun: THREE.Vector3, mesh: THREE.Mesh;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -79,7 +79,7 @@ function init() {
     const pmremGenerator = new THREE.PMREMGenerator(renderer);
     const sceneEnv = new THREE.Scene();
 
-    let renderTarget;
+    let renderTarget: THREE.WebGLRenderTarget;
 
     function updateSun() {
         const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);
diff --git a/examples-testing/examples/webgl_shaders_sky.ts b/examples-testing/examples/webgl_shaders_sky.ts
index 18020f78f..3b61996d2 100644
--- a/examples-testing/examples/webgl_shaders_sky.ts
+++ b/examples-testing/examples/webgl_shaders_sky.ts
@@ -4,9 +4,9 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Sky } from 'three/addons/objects/Sky.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let sky, sun;
+let sky: Sky, sun: THREE.Vector3;
 
 init();
 render();
diff --git a/examples-testing/examples/webgl_shadow_contact.ts b/examples-testing/examples/webgl_shadow_contact.ts
index f402fa20d..8e71282d7 100644
--- a/examples-testing/examples/webgl_shadow_contact.ts
+++ b/examples-testing/examples/webgl_shadow_contact.ts
@@ -5,9 +5,9 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { HorizontalBlurShader } from 'three/addons/shaders/HorizontalBlurShader.js';
 import { VerticalBlurShader } from 'three/addons/shaders/VerticalBlurShader.js';
 
-let camera, scene, renderer, stats, gui;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats, gui;
 
-const meshes = [];
+const meshes: THREE.Mesh[] = [];
 
 const PLANE_WIDTH = 2.5;
 const PLANE_HEIGHT = 2.5;
@@ -26,16 +26,18 @@ const state = {
     showWireframe: false,
 };
 
-let shadowGroup,
-    renderTarget,
-    renderTargetBlur,
-    shadowCamera,
-    cameraHelper,
-    depthMaterial,
-    horizontalBlurMaterial,
-    verticalBlurMaterial;
+let shadowGroup: THREE.Group,
+    renderTarget: THREE.WebGLRenderTarget,
+    renderTargetBlur: THREE.WebGLRenderTarget,
+    shadowCamera: THREE.OrthographicCamera,
+    cameraHelper: THREE.CameraHelper,
+    depthMaterial: THREE.MeshDepthMaterial,
+    horizontalBlurMaterial: THREE.ShaderMaterial,
+    verticalBlurMaterial: THREE.ShaderMaterial;
 
-let plane, blurPlane, fillPlane;
+let plane: THREE.Mesh<THREE.PlaneGeometry, THREE.MeshBasicMaterial>,
+    blurPlane: THREE.Mesh<THREE.PlaneGeometry, THREE.MeshBasicMaterial | THREE.ShaderMaterial>,
+    fillPlane: THREE.Mesh<THREE.PlaneGeometry, THREE.MeshBasicMaterial>;
 
 init();
 
@@ -206,7 +208,7 @@ function onWindowResize() {
 }
 
 // renderTarget --> blurPlane (horizontalBlur) --> renderTargetBlur --> blurPlane (verticalBlur) --> renderTarget
-function blurShadow(amount) {
+function blurShadow(amount: number) {
     blurPlane.visible = true;
 
     // blur horizontally and draw in the renderTargetBlur
diff --git a/examples-testing/examples/webgl_shadowmap.ts b/examples-testing/examples/webgl_shadowmap.ts
index ef5d820cb..791a91b19 100644
--- a/examples-testing/examples/webgl_shadowmap.ts
+++ b/examples-testing/examples/webgl_shadowmap.ts
@@ -15,18 +15,18 @@ const SCREEN_WIDTH = window.innerWidth;
 const SCREEN_HEIGHT = window.innerHeight;
 const FLOOR = -250;
 
-let camera, controls, scene, renderer;
-let container, stats;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let container: HTMLDivElement, stats: Stats;
 
 const NEAR = 10,
     FAR = 3000;
 
-let mixer;
+let mixer: THREE.AnimationMixer;
 
-const morphs = [];
+const morphs: (THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial> & { speed?: number })[] = [];
 
-let light;
-let lightShadowMapViewer;
+let light: THREE.DirectionalLight;
+let lightShadowMapViewer: ShadowMapViewer;
 
 const clock = new THREE.Clock();
 
@@ -117,7 +117,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     switch (event.keyCode) {
         case 84 /*t*/:
             showHUD = !showHUD;
@@ -168,7 +168,7 @@ function createScene() {
         });
 
         textGeo.computeBoundingBox();
-        const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
+        const centerOffset = -0.5 * (textGeo.boundingBox!.max.x - textGeo.boundingBox!.min.x);
 
         const textMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
 
@@ -208,7 +208,16 @@ function createScene() {
 
     mixer = new THREE.AnimationMixer(scene);
 
-    function addMorph(mesh, clip, speed, duration, x, y, z, fudgeColor) {
+    function addMorph(
+        mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial> & { speed?: number },
+        clip: THREE.AnimationClip,
+        speed: number,
+        duration: number,
+        x: number,
+        y: number,
+        z: number,
+        fudgeColor?: boolean,
+    ) {
         mesh = mesh.clone();
         mesh.material = mesh.material.clone();
 
@@ -239,7 +248,7 @@ function createScene() {
     const gltfloader = new GLTFLoader();
 
     gltfloader.load('models/gltf/Horse.glb', function (gltf) {
-        const mesh = gltf.scene.children[0];
+        const mesh = gltf.scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
 
         const clip = gltf.animations[0];
 
@@ -253,21 +262,21 @@ function createScene() {
     });
 
     gltfloader.load('models/gltf/Flamingo.glb', function (gltf) {
-        const mesh = gltf.scene.children[0];
+        const mesh = gltf.scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
         const clip = gltf.animations[0];
 
         addMorph(mesh, clip, 500, 1, 500 - Math.random() * 500, FLOOR + 350, 40);
     });
 
     gltfloader.load('models/gltf/Stork.glb', function (gltf) {
-        const mesh = gltf.scene.children[0];
+        const mesh = gltf.scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
         const clip = gltf.animations[0];
 
         addMorph(mesh, clip, 350, 1, 500 - Math.random() * 500, FLOOR + 350, 340);
     });
 
     gltfloader.load('models/gltf/Parrot.glb', function (gltf) {
-        const mesh = gltf.scene.children[0];
+        const mesh = gltf.scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
         const clip = gltf.animations[0];
 
         addMorph(mesh, clip, 450, 0.5, 500 - Math.random() * 500, FLOOR + 300, 700);
@@ -287,7 +296,7 @@ function render() {
     for (let i = 0; i < morphs.length; i++) {
         const morph = morphs[i];
 
-        morph.position.x += morph.speed * delta;
+        morph.position.x += morph.speed! * delta;
 
         if (morph.position.x > 2000) {
             morph.position.x = -1000 - Math.random() * 500;
diff --git a/examples-testing/examples/webgl_shadowmap_csm.ts b/examples-testing/examples/webgl_shadowmap_csm.ts
index c89bc02df..4da2da356 100644
--- a/examples-testing/examples/webgl_shadowmap_csm.ts
+++ b/examples-testing/examples/webgl_shadowmap_csm.ts
@@ -2,12 +2,32 @@ import * as THREE from 'three';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
-import { CSM } from 'three/addons/csm/CSM.js';
+import { CSM, CSMMode } from 'three/addons/csm/CSM.js';
 import { CSMHelper } from 'three/addons/csm/CSMHelper.js';
 
-let renderer, scene, camera, orthoCamera, controls, csm, csmHelper;
-
-const params = {
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    orthoCamera: THREE.OrthographicCamera,
+    controls: OrbitControls,
+    csm: CSM,
+    csmHelper: CSMHelper;
+
+const params: {
+    orthographic: boolean;
+    fade: boolean;
+    shadows: boolean;
+    far: number;
+    mode: CSMMode;
+    lightX: number;
+    lightY: number;
+    lightZ: number;
+    margin: number;
+    lightFar: number;
+    lightNear: number;
+    autoUpdateHelper: boolean;
+    updateHelper: () => void;
+} = {
     orthographic: false,
     fade: false,
     shadows: true,
@@ -133,8 +153,8 @@ function init() {
         renderer.shadowMap.enabled = value;
 
         scene.traverse(function (child) {
-            if (child.material) {
-                child.material.needsUpdate = true;
+            if ((child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material) {
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.needsUpdate = true;
             }
         });
     });
diff --git a/examples-testing/examples/webgl_shadowmap_pcss.ts b/examples-testing/examples/webgl_shadowmap_pcss.ts
index a47a011ff..7e1f5fb32 100644
--- a/examples-testing/examples/webgl_shadowmap_pcss.ts
+++ b/examples-testing/examples/webgl_shadowmap_pcss.ts
@@ -4,10 +4,10 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let stats;
-let camera, scene, renderer;
+let stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let group;
+let group: THREE.Group;
 
 init();
 
@@ -95,12 +95,12 @@ function init() {
 
     shader = shader.replace(
         '#ifdef USE_SHADOWMAP',
-        '#ifdef USE_SHADOWMAP' + document.getElementById('PCSS').textContent,
+        '#ifdef USE_SHADOWMAP' + document.getElementById('PCSS')!.textContent,
     );
 
     shader = shader.replace(
         '#if defined( SHADOWMAP_TYPE_PCF )',
-        document.getElementById('PCSSGetShadow').textContent + '#if defined( SHADOWMAP_TYPE_PCF )',
+        document.getElementById('PCSSGetShadow')!.textContent + '#if defined( SHADOWMAP_TYPE_PCF )',
     );
 
     THREE.ShaderChunk.shadowmap_pars_fragment = shader;
diff --git a/examples-testing/examples/webgl_shadowmap_performance.ts b/examples-testing/examples/webgl_shadowmap_performance.ts
index 0e45b63f9..1b61f3dbb 100644
--- a/examples-testing/examples/webgl_shadowmap_performance.ts
+++ b/examples-testing/examples/webgl_shadowmap_performance.ts
@@ -16,16 +16,16 @@ const FLOOR = -250;
 
 const ANIMATION_GROUPS = 25;
 
-let camera, controls, scene, renderer;
-let stats;
+let camera: THREE.PerspectiveCamera, controls: FirstPersonControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let stats: Stats;
 
 const NEAR = 5,
     FAR = 3000;
 
-let morph, mixer;
+let morph, mixer: THREE.AnimationMixer;
 
-const morphs = [],
-    animGroups = [];
+const morphs: (THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial> & { speed?: number })[] = [],
+    animGroups: THREE.AnimationObjectGroup[] = [];
 
 const clock = new THREE.Clock();
 
@@ -150,7 +150,7 @@ function createScene() {
         });
 
         textGeo.computeBoundingBox();
-        const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
+        const centerOffset = -0.5 * (textGeo.boundingBox!.max.x - textGeo.boundingBox!.min.x);
 
         const textMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
 
@@ -195,7 +195,17 @@ function createScene() {
 
     // MORPHS
 
-    function addMorph(mesh, clip, speed, duration, x, y, z, fudgeColor, massOptimization) {
+    function addMorph(
+        mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial> & { speed?: number },
+        clip: THREE.AnimationClip,
+        speed: number,
+        duration: number,
+        x: number,
+        y: number,
+        z: number,
+        fudgeColor: boolean,
+        massOptimization: boolean,
+    ) {
         mesh = mesh.clone();
         mesh.material = mesh.material.clone();
 
@@ -242,7 +252,7 @@ function createScene() {
 
     const gltfLoader = new GLTFLoader();
     gltfLoader.load('models/gltf/Horse.glb', function (gltf) {
-        const mesh = gltf.scene.children[0];
+        const mesh = gltf.scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
         const clip = gltf.animations[0];
 
         for (let i = -600; i < 601; i += 2) {
@@ -267,7 +277,7 @@ function render() {
     for (let i = 0; i < morphs.length; i++) {
         morph = morphs[i];
 
-        morph.position.x += morph.speed * delta;
+        morph.position.x += morph.speed! * delta;
 
         if (morph.position.x > 2000) {
             morph.position.x = -1000 - Math.random() * 500;
diff --git a/examples-testing/examples/webgl_shadowmap_pointlight.ts b/examples-testing/examples/webgl_shadowmap_pointlight.ts
index c68d69749..996aedd4d 100644
--- a/examples-testing/examples/webgl_shadowmap_pointlight.ts
+++ b/examples-testing/examples/webgl_shadowmap_pointlight.ts
@@ -4,8 +4,8 @@ import Stats from 'three/addons/libs/stats.module.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, stats;
-let pointLight, pointLight2;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let pointLight: THREE.PointLight, pointLight2: THREE.PointLight;
 
 init();
 
@@ -18,7 +18,7 @@ function init() {
 
     // lights
 
-    function createLight(color) {
+    function createLight(color: number) {
         const intensity = 200;
 
         const light = new THREE.PointLight(color, intensity, 20);
@@ -26,9 +26,9 @@ function init() {
         light.shadow.bias = -0.005; // reduces self-shadowing on double-sided objects
 
         let geometry = new THREE.SphereGeometry(0.3, 12, 6);
-        let material = new THREE.MeshBasicMaterial({ color: color });
+        let material: THREE.MeshBasicMaterial | THREE.MeshPhongMaterial = new THREE.MeshBasicMaterial({ color: color });
         material.color.multiplyScalar(intensity);
-        let sphere = new THREE.Mesh(geometry, material);
+        let sphere = new THREE.Mesh<THREE.BufferGeometry, THREE.Material>(geometry, material);
         light.add(sphere);
 
         const texture = new THREE.CanvasTexture(generateTexture());
@@ -107,7 +107,7 @@ function generateTexture() {
     canvas.width = 2;
     canvas.height = 2;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     context.fillStyle = 'white';
     context.fillRect(0, 1, 2, 1);
 
diff --git a/examples-testing/examples/webgl_shadowmap_progressive.ts b/examples-testing/examples/webgl_shadowmap_progressive.ts
index 29298630f..9d04c42ee 100644
--- a/examples-testing/examples/webgl_shadowmap_progressive.ts
+++ b/examples-testing/examples/webgl_shadowmap_progressive.ts
@@ -9,17 +9,17 @@ import { ProgressiveLightMap } from 'three/addons/misc/ProgressiveLightMap.js';
 const shadowMapRes = 512,
     lightMapRes = 1024,
     lightCount = 8;
-let camera,
-    scene,
-    renderer,
-    controls,
-    control,
-    control2,
-    object = new THREE.Mesh(),
-    lightOrigin = null,
-    progressiveSurfacemap;
-const dirLights = [],
-    lightmapObjects = [];
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    controls: OrbitControls,
+    control: TransformControls,
+    control2: TransformControls,
+    object: THREE.Object3D = new THREE.Mesh(),
+    lightOrigin: THREE.Group | null = null,
+    progressiveSurfacemap: ProgressiveLightMap;
+const dirLights: THREE.DirectionalLight[] = [],
+    lightmapObjects: THREE.Object3D[] = [];
 const params = {
     Enable: true,
     'Blur Edges': true,
@@ -98,11 +98,11 @@ function init() {
     // model
     function loadModel() {
         object.traverse(function (child) {
-            if (child.isMesh) {
+            if ((child as THREE.Mesh).isMesh) {
                 child.name = 'Loaded Mesh';
                 child.castShadow = true;
                 child.receiveShadow = true;
-                child.material = new THREE.MeshPhongMaterial();
+                (child as THREE.Mesh).material = new THREE.MeshPhongMaterial();
 
                 // This adds the model to the lightmap
                 lightmapObjects.push(child);
@@ -183,9 +183,9 @@ function animate() {
         // Sometimes they will be uniformly sampled from the upper hemisphere
         if (Math.random() > params['Ambient Weight']) {
             dirLights[l].position.set(
-                lightOrigin.position.x + Math.random() * params['Light Radius'],
-                lightOrigin.position.y + Math.random() * params['Light Radius'],
-                lightOrigin.position.z + Math.random() * params['Light Radius'],
+                lightOrigin!.position.x + Math.random() * params['Light Radius'],
+                lightOrigin!.position.y + Math.random() * params['Light Radius'],
+                lightOrigin!.position.z + Math.random() * params['Light Radius'],
             );
         } else {
             // Uniform Hemispherical Surface Distribution for Ambient Occlusion
diff --git a/examples-testing/examples/webgl_shadowmap_viewer.ts b/examples-testing/examples/webgl_shadowmap_viewer.ts
index f974ef038..755278b82 100644
--- a/examples-testing/examples/webgl_shadowmap_viewer.ts
+++ b/examples-testing/examples/webgl_shadowmap_viewer.ts
@@ -5,10 +5,14 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { ShadowMapViewer } from 'three/addons/utils/ShadowMapViewer.js';
 
-let camera, scene, renderer, clock, stats;
-let dirLight, spotLight;
-let torusKnot, cube;
-let dirLightShadowMapViewer, spotLightShadowMapViewer;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    stats: Stats;
+let dirLight: THREE.DirectionalLight, spotLight: THREE.SpotLight;
+let torusKnot: THREE.Mesh, cube: THREE.Mesh;
+let dirLightShadowMapViewer: ShadowMapViewer, spotLightShadowMapViewer: ShadowMapViewer;
 
 init();
 
@@ -62,7 +66,7 @@ function initScene() {
     scene.add(new THREE.CameraHelper(dirLight.shadow.camera));
 
     // Geometry
-    let geometry = new THREE.TorusKnotGeometry(25, 8, 75, 20);
+    let geometry: THREE.BufferGeometry = new THREE.TorusKnotGeometry(25, 8, 75, 20);
     let material = new THREE.MeshPhongMaterial({
         color: 0xff0000,
         shininess: 150,
diff --git a/examples-testing/examples/webgl_shadowmap_vsm.ts b/examples-testing/examples/webgl_shadowmap_vsm.ts
index 4867c7315..2e2ccaa92 100644
--- a/examples-testing/examples/webgl_shadowmap_vsm.ts
+++ b/examples-testing/examples/webgl_shadowmap_vsm.ts
@@ -5,9 +5,13 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, clock, stats;
-let dirLight, spotLight;
-let torusKnot, dirGroup;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    stats: Stats;
+let dirLight: THREE.DirectionalLight, spotLight: THREE.SpotLight;
+let torusKnot: THREE.Mesh, dirGroup: THREE.Group;
 
 init();
 
@@ -184,7 +188,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function animate(time) {
+function animate(time: DOMHighResTimeStamp) {
     const delta = clock.getDelta();
 
     torusKnot.rotation.x += 0.25 * delta;
@@ -192,7 +196,7 @@ function animate(time) {
     torusKnot.rotation.z += 1 * delta;
 
     dirGroup.rotation.y += 0.7 * delta;
-    dirLight.position.z = 17 + Math.sin(time * 0.001) * 5;
+    dirLight.position.z = 17 + Math.sin(time! * 0.001) * 5;
 
     renderer.render(scene, camera);
 
diff --git a/examples-testing/examples/webgl_shadowmesh.ts b/examples-testing/examples/webgl_shadowmesh.ts
index 412fc0283..6043a477d 100644
--- a/examples-testing/examples/webgl_shadowmesh.ts
+++ b/examples-testing/examples/webgl_shadowmesh.ts
@@ -12,18 +12,18 @@ const renderer = new THREE.WebGLRenderer({ stencil: true });
 
 const sunLight = new THREE.DirectionalLight('rgb(255,255,255)', 3);
 let useDirectionalLight = true;
-let arrowHelper1, arrowHelper2, arrowHelper3;
+let arrowHelper1: THREE.ArrowHelper, arrowHelper2: THREE.ArrowHelper, arrowHelper3: THREE.ArrowHelper;
 const arrowDirection = new THREE.Vector3();
 const arrowPosition1 = new THREE.Vector3();
 const arrowPosition2 = new THREE.Vector3();
 const arrowPosition3 = new THREE.Vector3();
-let groundMesh;
-let lightSphere, lightHolder;
-let pyramid, pyramidShadow;
-let sphere, sphereShadow;
-let cube, cubeShadow;
-let cylinder, cylinderShadow;
-let torus, torusShadow;
+let groundMesh: THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial>;
+let lightSphere: THREE.Mesh, lightHolder: THREE.Mesh;
+let pyramid: THREE.Mesh, pyramidShadow: ShadowMesh;
+let sphere: THREE.Mesh, sphereShadow: ShadowMesh;
+let cube: THREE.Mesh, cubeShadow: ShadowMesh;
+let cylinder: THREE.Mesh, cylinderShadow: ShadowMesh;
+let torus: THREE.Mesh, torusShadow: ShadowMesh;
 const normalVector = new THREE.Vector3(0, 1, 0);
 const planeConstant = 0.01; // this value must be slightly higher than the groundMesh's y position of 0.0
 const groundPlane = new THREE.Plane(normalVector, planeConstant);
@@ -41,7 +41,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
     renderer.setAnimationLoop(animate);
-    document.getElementById('container').appendChild(renderer.domElement);
+    document.getElementById('container')!.appendChild(renderer.domElement);
 
     window.addEventListener('resize', onWindowResize);
 
@@ -150,7 +150,7 @@ function init() {
     pyramidShadow = new ShadowMesh(pyramid);
     scene.add(pyramidShadow);
 
-    document.getElementById('lightButton').addEventListener('click', lightButtonHandler);
+    document.getElementById('lightButton')!.addEventListener('click', lightButtonHandler);
 }
 
 function animate() {
@@ -203,7 +203,7 @@ function lightButtonHandler() {
     useDirectionalLight = !useDirectionalLight;
 
     if (useDirectionalLight) {
-        scene.background.setHex(0x0096ff);
+        (scene.background as THREE.Color).setHex(0x0096ff);
 
         groundMesh.material.color.setHex(0x008200);
         sunLight.position.set(5, 7, -1);
@@ -221,9 +221,9 @@ function lightButtonHandler() {
         lightSphere.visible = false;
         lightHolder.visible = false;
 
-        document.getElementById('lightButton').value = 'Switch to PointLight';
+        (document.getElementById('lightButton') as HTMLButtonElement).value = 'Switch to PointLight';
     } else {
-        scene.background.setHex(0x000000);
+        (scene.background as THREE.Color).setHex(0x000000);
 
         groundMesh.material.color.setHex(0x969696);
 
@@ -245,6 +245,6 @@ function lightButtonHandler() {
         lightSphere.visible = true;
         lightHolder.visible = true;
 
-        document.getElementById('lightButton').value = 'Switch to THREE.DirectionalLight';
+        (document.getElementById('lightButton') as HTMLButtonElement).value = 'Switch to THREE.DirectionalLight';
     }
 }
diff --git a/examples-testing/examples/webgl_simple_gi.ts b/examples-testing/examples/webgl_simple_gi.ts
index 4ab6dc895..adea084a0 100644
--- a/examples-testing/examples/webgl_simple_gi.ts
+++ b/examples-testing/examples/webgl_simple_gi.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 class GIMesh extends THREE.Mesh {
-    copy(source) {
+    copy(source: this) {
         super.copy(source);
 
         this.geometry = source.geometry.clone();
@@ -14,104 +14,109 @@ class GIMesh extends THREE.Mesh {
 
 //
 
-const SimpleGI = function (renderer, scene) {
-    const SIZE = 32,
-        SIZE2 = SIZE * SIZE;
+class SimpleGI {
+    constructor(renderer: THREE.WebGLRenderer, scene: THREE.Scene) {
+        const SIZE = 32,
+            SIZE2 = SIZE * SIZE;
 
-    const camera = new THREE.PerspectiveCamera(90, 1, 0.01, 100);
+        const camera = new THREE.PerspectiveCamera(90, 1, 0.01, 100);
 
-    scene.updateMatrixWorld(true);
+        scene.updateMatrixWorld(true);
 
-    let clone = scene.clone();
-    clone.matrixWorldAutoUpdate = false;
+        let clone = scene.clone();
+        clone.matrixWorldAutoUpdate = false;
 
-    const rt = new THREE.WebGLRenderTarget(SIZE, SIZE);
+        const rt = new THREE.WebGLRenderTarget(SIZE, SIZE);
 
-    const normalMatrix = new THREE.Matrix3();
+        const normalMatrix = new THREE.Matrix3();
 
-    const position = new THREE.Vector3();
-    const normal = new THREE.Vector3();
+        const position = new THREE.Vector3();
+        const normal = new THREE.Vector3();
 
-    let bounces = 0;
-    let currentVertex = 0;
+        let bounces = 0;
+        let currentVertex = 0;
 
-    const color = new Float32Array(3);
-    const buffer = new Uint8Array(SIZE2 * 4);
+        const color = new Float32Array(3);
+        const buffer = new Uint8Array(SIZE2 * 4);
 
-    function compute() {
-        if (bounces === 3) return;
+        function compute() {
+            if (bounces === 3) return;
 
-        const object = scene.children[0]; // torusKnot
-        const geometry = object.geometry;
+            const object = scene.children[0] as GIMesh; // torusKnot
+            const geometry = object.geometry;
 
-        const attributes = geometry.attributes;
-        const positions = attributes.position.array;
-        const normals = attributes.normal.array;
+            const attributes = geometry.attributes;
+            const positions = attributes.position.array;
+            const normals = attributes.normal.array;
 
-        if (attributes.color === undefined) {
-            const colors = new Float32Array(positions.length);
-            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));
-        }
+            if (attributes.color === undefined) {
+                const colors = new Float32Array(positions.length);
+                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));
+            }
 
-        const colors = attributes.color.array;
+            const colors = attributes.color.array;
 
-        const startVertex = currentVertex;
-        const totalVertex = positions.length / 3;
+            const startVertex = currentVertex;
+            const totalVertex = positions.length / 3;
 
-        for (let i = 0; i < 32; i++) {
-            if (currentVertex >= totalVertex) break;
+            for (let i = 0; i < 32; i++) {
+                if (currentVertex >= totalVertex) break;
 
-            position.fromArray(positions, currentVertex * 3);
-            position.applyMatrix4(object.matrixWorld);
+                position.fromArray(positions, currentVertex * 3);
+                position.applyMatrix4(object.matrixWorld);
 
-            normal.fromArray(normals, currentVertex * 3);
-            normal.applyMatrix3(normalMatrix.getNormalMatrix(object.matrixWorld)).normalize();
+                normal.fromArray(normals, currentVertex * 3);
+                normal.applyMatrix3(normalMatrix.getNormalMatrix(object.matrixWorld)).normalize();
 
-            camera.position.copy(position);
-            camera.lookAt(position.add(normal));
+                camera.position.copy(position);
+                camera.lookAt(position.add(normal));
 
-            renderer.setRenderTarget(rt);
-            renderer.render(clone, camera);
+                renderer.setRenderTarget(rt);
+                renderer.render(clone, camera);
 
-            renderer.readRenderTargetPixels(rt, 0, 0, SIZE, SIZE, buffer);
+                renderer.readRenderTargetPixels(rt, 0, 0, SIZE, SIZE, buffer);
 
-            color[0] = 0;
-            color[1] = 0;
-            color[2] = 0;
+                color[0] = 0;
+                color[1] = 0;
+                color[2] = 0;
 
-            for (let k = 0, kl = buffer.length; k < kl; k += 4) {
-                color[0] += buffer[k + 0];
-                color[1] += buffer[k + 1];
-                color[2] += buffer[k + 2];
-            }
+                for (let k = 0, kl = buffer.length; k < kl; k += 4) {
+                    color[0] += buffer[k + 0];
+                    color[1] += buffer[k + 1];
+                    color[2] += buffer[k + 2];
+                }
 
-            colors[currentVertex * 3 + 0] = color[0] / (SIZE2 * 255);
-            colors[currentVertex * 3 + 1] = color[1] / (SIZE2 * 255);
-            colors[currentVertex * 3 + 2] = color[2] / (SIZE2 * 255);
+                colors[currentVertex * 3 + 0] = color[0] / (SIZE2 * 255);
+                colors[currentVertex * 3 + 1] = color[1] / (SIZE2 * 255);
+                colors[currentVertex * 3 + 2] = color[2] / (SIZE2 * 255);
 
-            currentVertex++;
-        }
+                currentVertex++;
+            }
 
-        attributes.color.addUpdateRange(startVertex * 3, (currentVertex - startVertex) * 3);
-        attributes.color.needsUpdate = true;
+            (attributes.color as THREE.BufferAttribute).addUpdateRange(
+                startVertex * 3,
+                (currentVertex - startVertex) * 3,
+            );
+            attributes.color.needsUpdate = true;
 
-        if (currentVertex >= totalVertex) {
-            clone = scene.clone();
-            clone.matrixWorldAutoUpdate = false;
+            if (currentVertex >= totalVertex) {
+                clone = scene.clone();
+                clone.matrixWorldAutoUpdate = false;
 
-            bounces++;
-            currentVertex = 0;
+                bounces++;
+                currentVertex = 0;
+            }
+
+            requestAnimationFrame(compute);
         }
 
         requestAnimationFrame(compute);
     }
-
-    requestAnimationFrame(compute);
-};
+}
 
 //
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgl_sprites.ts b/examples-testing/examples/webgl_sprites.ts
index 2e4189347..3ff04b108 100644
--- a/examples-testing/examples/webgl_sprites.ts
+++ b/examples-testing/examples/webgl_sprites.ts
@@ -1,13 +1,17 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
-let cameraOrtho, sceneOrtho;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let cameraOrtho: THREE.OrthographicCamera, sceneOrtho: THREE.Scene;
 
-let spriteTL, spriteTR, spriteBL, spriteBR, spriteC;
+let spriteTL: THREE.Sprite,
+    spriteTR: THREE.Sprite,
+    spriteBL: THREE.Sprite,
+    spriteBR: THREE.Sprite,
+    spriteC: THREE.Sprite;
 
-let mapC;
+let mapC: THREE.Texture;
 
-let group;
+let group: THREE.Group;
 
 init();
 
@@ -57,8 +61,8 @@ function init() {
         } else {
             material = materialC.clone();
             material.color.setHSL(0.5 * Math.random(), 0.75, 0.5);
-            material.map.offset.set(-0.5, -0.5);
-            material.map.repeat.set(2, 2);
+            material.map!.offset.set(-0.5, -0.5);
+            material.map!.repeat.set(2, 2);
         }
 
         const sprite = new THREE.Sprite(material);
@@ -87,13 +91,13 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function createHUDSprites(texture) {
+function createHUDSprites(texture: THREE.Texture<HTMLImageElement>) {
     texture.colorSpace = THREE.SRGBColorSpace;
 
     const material = new THREE.SpriteMaterial({ map: texture });
 
-    const width = material.map.image.width;
-    const height = material.map.image.height;
+    const width = (material.map!.image as HTMLImageElement).width;
+    const height = (material.map!.image as HTMLImageElement).height;
 
     spriteTL = new THREE.Sprite(material);
     spriteTL.center.set(0.0, 1.0);
@@ -156,16 +160,16 @@ function animate() {
     const time = Date.now() / 1000;
 
     for (let i = 0, l = group.children.length; i < l; i++) {
-        const sprite = group.children[i];
+        const sprite = group.children[i] as THREE.Sprite;
         const material = sprite.material;
         const scale = Math.sin(time + sprite.position.x * 0.01) * 0.3 + 1.0;
 
         let imageWidth = 1;
         let imageHeight = 1;
 
-        if (material.map && material.map.image && material.map.image.width) {
-            imageWidth = material.map.image.width;
-            imageHeight = material.map.image.height;
+        if (material.map && material.map.image && (material.map.image as HTMLImageElement).width) {
+            imageWidth = (material.map.image as HTMLImageElement).width;
+            imageHeight = (material.map.image as HTMLImageElement).height;
         }
 
         sprite.material.rotation += 0.1 * (i / l);
diff --git a/examples-testing/examples/webgl_test_memory.ts b/examples-testing/examples/webgl_test_memory.ts
index f5d0e112d..128862a27 100644
--- a/examples-testing/examples/webgl_test_memory.ts
+++ b/examples-testing/examples/webgl_test_memory.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -26,7 +26,7 @@ function createImage() {
     canvas.width = 256;
     canvas.height = 256;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     context.fillStyle =
         'rgb(' +
         Math.floor(Math.random() * 256) +
diff --git a/examples-testing/examples/webgl_test_memory2.ts b/examples-testing/examples/webgl_test_memory2.ts
index 366a27914..74077e99b 100644
--- a/examples-testing/examples/webgl_test_memory2.ts
+++ b/examples-testing/examples/webgl_test_memory2.ts
@@ -2,15 +2,15 @@ import * as THREE from 'three';
 
 const N = 100;
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let geometry;
+let geometry: THREE.SphereGeometry;
 
-const meshes = [];
+const meshes: THREE.Mesh<THREE.SphereGeometry, THREE.ShaderMaterial>[] = [];
 
-let fragmentShader, vertexShader;
+let fragmentShader: string, vertexShader: string;
 
 init();
 setInterval(render, 1000 / 60);
@@ -19,8 +19,8 @@ function init() {
     container = document.createElement('div');
     document.body.appendChild(container);
 
-    vertexShader = document.getElementById('vertexShader').textContent;
-    fragmentShader = document.getElementById('fragmentShader').textContent;
+    vertexShader = document.getElementById('vertexShader')!.textContent!;
+    fragmentShader = document.getElementById('fragmentShader')!.textContent!;
 
     camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 2000;
@@ -70,12 +70,12 @@ function render() {
 
     renderer.render(scene, camera);
 
-    console.log('before', renderer.info.programs.length);
+    console.log('before', renderer.info.programs!.length);
 
     for (let i = 0; i < N; i++) {
         const mesh = meshes[i];
         mesh.material.dispose();
     }
 
-    console.log('after', renderer.info.programs.length);
+    console.log('after', renderer.info.programs!.length);
 }
diff --git a/examples-testing/examples/webgl_test_wide_gamut.ts b/examples-testing/examples/webgl_test_wide_gamut.ts
index 5988299e1..6da2af6ca 100644
--- a/examples-testing/examples/webgl_test_wide_gamut.ts
+++ b/examples-testing/examples/webgl_test_wide_gamut.ts
@@ -9,12 +9,12 @@ import {
 
 import WebGL from 'three/addons/capabilities/WebGL.js';
 
-let container, camera, renderer, loader;
-let sceneL, sceneR, textureL, textureR;
+let container: HTMLElement, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, loader: THREE.TextureLoader;
+let sceneL: THREE.Scene, sceneR: THREE.Scene, textureL: THREE.Texture, textureR: THREE.Texture;
 
 let sliderPos = window.innerWidth / 2;
 
-const slider = document.querySelector('.slider');
+const slider = document.querySelector('.slider') as HTMLElement;
 
 const isP3Context = WebGL.isColorSpaceAvailable(DisplayP3ColorSpace);
 
@@ -30,7 +30,7 @@ if (isP3Context) {
 init();
 
 function init() {
-    container = document.querySelector('.container');
+    container = document.querySelector('.container')!;
 
     sceneL = new THREE.Scene();
     sceneR = new THREE.Scene();
@@ -72,7 +72,7 @@ async function initTextures() {
 }
 
 function initSlider() {
-    function onPointerDown() {
+    function onPointerDown(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
         window.addEventListener('pointermove', onPointerMove);
@@ -84,10 +84,10 @@ function initSlider() {
         window.removeEventListener('pointerup', onPointerUp);
     }
 
-    function onPointerMove(e) {
+    function onPointerMove(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
-        updateSlider(e.pageX);
+        updateSlider(event.pageX);
     }
 
     updateSlider(sliderPos);
@@ -96,7 +96,7 @@ function initSlider() {
     slider.addEventListener('pointerdown', onPointerDown);
 }
 
-function updateSlider(offset) {
+function updateSlider(offset: number) {
     sliderPos = Math.max(10, Math.min(window.innerWidth - 10, offset));
 
     slider.style.left = sliderPos - slider.offsetWidth / 2 + 'px';
@@ -108,13 +108,13 @@ function onWindowResize() {
 
     renderer.setSize(window.innerWidth, window.innerHeight);
 
-    THREE.TextureUtils.contain(sceneL.background, window.innerWidth / window.innerHeight);
-    THREE.TextureUtils.contain(sceneR.background, window.innerWidth / window.innerHeight);
+    THREE.TextureUtils.contain(sceneL.background as THREE.Texture, window.innerWidth / window.innerHeight);
+    THREE.TextureUtils.contain(sceneR.background as THREE.Texture, window.innerWidth / window.innerHeight);
 
     updateSlider(sliderPos);
 }
 
-function onGamutChange({ matches }) {
+function onGamutChange({ matches }: MediaQueryListEvent) {
     renderer.outputColorSpace = isP3Context && matches ? DisplayP3ColorSpace : THREE.SRGBColorSpace;
 
     textureL.needsUpdate = true;
diff --git a/examples-testing/examples/webgl_texture2darray_compressed.ts b/examples-testing/examples/webgl_texture2darray_compressed.ts
index f263be706..bc8f86226 100644
--- a/examples-testing/examples/webgl_texture2darray_compressed.ts
+++ b/examples-testing/examples/webgl_texture2darray_compressed.ts
@@ -3,7 +3,12 @@ import * as THREE from 'three';
 import Stats from 'three/addons/libs/stats.module.js';
 import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
 
-let camera, scene, mesh, renderer, stats, clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    mesh: THREE.Mesh<THREE.PlaneGeometry, THREE.ShaderMaterial>,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    clock: THREE.Clock;
 
 const planeWidth = 50;
 const planeHeight = 25;
@@ -43,8 +48,8 @@ function init() {
                 depth: { value: 55 },
                 size: { value: new THREE.Vector2(planeWidth, planeHeight) },
             },
-            vertexShader: document.getElementById('vs').textContent.trim(),
-            fragmentShader: document.getElementById('fs').textContent.trim(),
+            vertexShader: document.getElementById('vs')!.textContent!.trim(),
+            fragmentShader: document.getElementById('fs')!.textContent!.trim(),
             glslVersion: THREE.GLSL3,
         });
 
diff --git a/examples-testing/examples/webgl_texture2darray_layerupdate.ts b/examples-testing/examples/webgl_texture2darray_layerupdate.ts
index 0cc136cb7..262372590 100644
--- a/examples-testing/examples/webgl_texture2darray_layerupdate.ts
+++ b/examples-testing/examples/webgl_texture2darray_layerupdate.ts
@@ -3,7 +3,7 @@ import * as THREE from 'three';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
 
-let camera, scene, mesh, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, mesh: THREE.InstancedMesh, renderer: THREE.WebGLRenderer;
 
 const planeWidth = 20;
 const planeHeight = 10;
@@ -35,7 +35,7 @@ async function init() {
     // Load several KTX2 textures which will later be used to modify
     // specific texture array layers.
 
-    const spiritedaway = await ktx2Loader.loadAsync('textures/spiritedaway.ktx2');
+    const spiritedaway = (await ktx2Loader.loadAsync('textures/spiritedaway.ktx2')) as THREE.CompressedArrayTexture;
 
     // Create a texture array for rendering.
 
@@ -67,9 +67,9 @@ async function init() {
         srcLayer: 0,
         destLayer: 0,
         transfer() {
-            const layerElementLength = layerByteLength / spiritedaway.mipmaps[0].data.BYTES_PER_ELEMENT;
-            textureArray.mipmaps[0].data.set(
-                spiritedaway.mipmaps[0].data.subarray(
+            const layerElementLength = layerByteLength / spiritedaway.mipmaps![0].data.BYTES_PER_ELEMENT;
+            textureArray.mipmaps![0].data.set(
+                spiritedaway.mipmaps![0].data.subarray(
                     layerElementLength * (formData.srcLayer % spiritedaway.image.depth),
                     layerElementLength * ((formData.srcLayer % spiritedaway.image.depth) + 1),
                 ),
@@ -94,13 +94,13 @@ async function init() {
             diffuse: { value: textureArray },
             size: { value: new THREE.Vector2(planeWidth, planeHeight) },
         },
-        vertexShader: document.getElementById('vs').textContent.trim(),
-        fragmentShader: document.getElementById('fs').textContent.trim(),
+        vertexShader: document.getElementById('vs')!.textContent!.trim(),
+        fragmentShader: document.getElementById('fs')!.textContent!.trim(),
         glslVersion: THREE.GLSL3,
     });
 
     const geometry = new THREE.InstancedBufferGeometry();
-    geometry.copy(new THREE.PlaneGeometry(planeWidth, planeHeight));
+    geometry.copy(new THREE.PlaneGeometry(planeWidth, planeHeight) as unknown as THREE.InstancedBufferGeometry);
     geometry.instanceCount = 3;
 
     const instancedIndexAttribute = new THREE.InstancedBufferAttribute(new Uint16Array([0, 1, 2]), 1, false, 1);
@@ -116,7 +116,7 @@ async function init() {
     // Initialize the texture array by first rendering the spirited away
     // frames in order.
 
-    textureArray.mipmaps[0].data.set(spiritedaway.mipmaps[0].data.subarray(0, textureArray.mipmaps[0].data.length));
+    textureArray.mipmaps![0].data.set(spiritedaway.mipmaps![0].data.subarray(0, textureArray.mipmaps![0].data.length));
     textureArray.needsUpdate = true;
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl_texture3d.ts b/examples-testing/examples/webgl_texture3d.ts
index 977dbadb7..fb1460cae 100644
--- a/examples-testing/examples/webgl_texture3d.ts
+++ b/examples-testing/examples/webgl_texture3d.ts
@@ -5,7 +5,15 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { NRRDLoader } from 'three/addons/loaders/NRRDLoader.js';
 import { VolumeRenderShader1 } from 'three/addons/shaders/VolumeShader.js';
 
-let renderer, scene, camera, controls, material, volconfig, cmtextures;
+type ColorMap = 'gray' | 'viridis';
+
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.OrthographicCamera,
+    controls: OrbitControls,
+    material: THREE.ShaderMaterial,
+    volconfig: { clim1: number; clim2: number; renderstyle: string; isothreshold: number; colormap: ColorMap },
+    cmtextures: { [K in ColorMap]: THREE.Texture };
 
 init();
 
@@ -100,7 +108,7 @@ function init() {
 }
 
 function updateUniforms() {
-    material.uniforms['u_clim'].value.set(volconfig.clim1, volconfig.clim2);
+    (material.uniforms['u_clim'].value as THREE.Vector2).set(volconfig.clim1, volconfig.clim2);
     material.uniforms['u_renderstyle'].value = volconfig.renderstyle == 'mip' ? 0 : 1; // 0: MIP, 1: ISO
     material.uniforms['u_renderthreshold'].value = volconfig.isothreshold; // For ISO renderstyle
     material.uniforms['u_cmdata'].value = cmtextures[volconfig.colormap];
diff --git a/examples-testing/examples/webgl_texture3d_partialupdate.ts b/examples-testing/examples/webgl_texture3d_partialupdate.ts
index 58615db84..1ae4e437f 100644
--- a/examples-testing/examples/webgl_texture3d_partialupdate.ts
+++ b/examples-testing/examples/webgl_texture3d_partialupdate.ts
@@ -6,14 +6,14 @@ import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
 const INITIAL_CLOUD_SIZE = 128;
 
-let renderer, scene, camera;
-let mesh;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let mesh: THREE.Mesh<THREE.BoxGeometry, THREE.RawShaderMaterial>;
 let prevTime = performance.now();
-let cloudTexture = null;
+let cloudTexture: THREE.Data3DTexture | null = null;
 
 init();
 
-function generateCloudTexture(size, scaleFactor = 1.0) {
+function generateCloudTexture(size: number, scaleFactor = 1.0) {
     const data = new Uint8Array(size * size * size);
     const scale = (scaleFactor * 10.0) / size;
 
@@ -60,7 +60,7 @@ function init() {
     canvas.width = 1;
     canvas.height = 32;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     const gradient = context.createLinearGradient(0, 0, 0, 32);
     gradient.addColorStop(0.0, '#014a84');
     gradient.addColorStop(0.5, '#0561a0');
@@ -310,17 +310,17 @@ function animate() {
         const scaleFactor = (Math.random() + 0.5) * 0.5;
         const source = generateCloudTexture(perElementPaddedSize, scaleFactor);
 
-        renderer.copyTextureToTexture(source, cloudTexture, box, position);
+        renderer.copyTextureToTexture(source, cloudTexture!, box, position);
 
         prevTime = time;
 
         curr++;
     }
 
-    mesh.material.uniforms.cameraPos.value.copy(camera.position);
+    (mesh.material.uniforms.cameraPos.value as THREE.Vector3).copy(camera.position);
     // mesh.rotation.y = - performance.now() / 7500;
 
-    mesh.material.uniforms.frame.value++;
+    (mesh.material.uniforms.frame.value as number)++;
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl_tonemapping.ts b/examples-testing/examples/webgl_tonemapping.ts
index 2163e1b06..a7cb196ef 100644
--- a/examples-testing/examples/webgl_tonemapping.ts
+++ b/examples-testing/examples/webgl_tonemapping.ts
@@ -1,23 +1,32 @@
 import * as THREE from 'three';
 
-import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
+import { GUI, NumberController } from 'three/addons/libs/lil-gui.module.min.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
-let renderer, scene, camera, controls;
-let gui,
-    guiExposure = null;
+type ToneMapping = 'None' | 'Linear' | 'Reinhard' | 'Cineon' | 'ACESFilmic' | 'AgX' | 'Neutral' | 'Custom';
 
-const params = {
+interface Params {
+    exposure: number;
+    toneMapping: ToneMapping;
+    blurriness: number;
+    intensity: number;
+}
+
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
+let gui: GUI,
+    guiExposure: NumberController<Params, 'exposure'> | null = null;
+
+const params: Params = {
     exposure: 1.0,
     toneMapping: 'Neutral',
     blurriness: 0.3,
     intensity: 1.0,
 };
 
-const toneMappingOptions = {
+const toneMappingOptions: { [K in ToneMapping]: THREE.ToneMapping } = {
     None: THREE.NoToneMapping,
     Linear: THREE.LinearToneMapping,
     Reinhard: THREE.ReinhardToneMapping,
@@ -112,7 +121,7 @@ async function init() {
     const toneMappingFolder = gui.addFolder('Tone Mapping');
 
     toneMappingFolder
-        .add(params, 'toneMapping', Object.keys(toneMappingOptions))
+        .add(params, 'toneMapping', Object.keys(toneMappingOptions) as ToneMapping[])
 
         .name('type')
         .onChange(function () {
@@ -151,9 +160,9 @@ async function init() {
 
 function updateGUI() {
     if (params.toneMapping === 'None') {
-        guiExposure.hide();
+        guiExposure!.hide();
     } else {
-        guiExposure.show();
+        guiExposure!.show();
     }
 }
 
diff --git a/examples-testing/examples/webgl_ubo.ts b/examples-testing/examples/webgl_ubo.ts
index 01064f115..814edd871 100644
--- a/examples-testing/examples/webgl_ubo.ts
+++ b/examples-testing/examples/webgl_ubo.ts
@@ -1,11 +1,11 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer, clock;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
 
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
     camera.position.set(0, 0, 25);
@@ -51,8 +51,8 @@ function init() {
             normalMatrix: { value: null },
             color: { value: null },
         },
-        vertexShader: document.getElementById('vertexShader1').textContent,
-        fragmentShader: document.getElementById('fragmentShader1').textContent,
+        vertexShader: document.getElementById('vertexShader1')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader1')!.textContent!,
         glslVersion: THREE.GLSL3,
     });
 
@@ -61,8 +61,8 @@ function init() {
             modelMatrix: { value: null },
             diffuseMap: { value: null },
         },
-        vertexShader: document.getElementById('vertexShader2').textContent,
-        fragmentShader: document.getElementById('fragmentShader2').textContent,
+        vertexShader: document.getElementById('vertexShader2')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader2')!.textContent!,
         glslVersion: THREE.GLSL3,
     });
 
@@ -127,7 +127,7 @@ function animate() {
     const delta = clock.getDelta();
 
     scene.traverse(function (child) {
-        if (child.isMesh) {
+        if ((child as THREE.Mesh).isMesh) {
             child.rotation.x += delta * 0.5;
             child.rotation.y += delta * 0.3;
         }
diff --git a/examples-testing/examples/webgl_ubo_arrays.ts b/examples-testing/examples/webgl_ubo_arrays.ts
index d846e1443..85bcff4c8 100644
--- a/examples-testing/examples/webgl_ubo_arrays.ts
+++ b/examples-testing/examples/webgl_ubo_arrays.ts
@@ -4,11 +4,15 @@ import Stats from 'three/addons/libs/stats.module.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer, clock, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    stats: Stats;
 
-let lightingUniformsGroup, lightCenters;
+let lightingUniformsGroup: THREE.UniformsGroup, lightCenters: { x: number; z: number }[];
 
-const container = document.getElementById('container');
+const container = document.getElementById('container')!;
 
 const pointLightsMax = 300;
 
@@ -71,8 +75,8 @@ function init() {
         defines: {
             POINTLIGHTS_MAX: pointLightsMax,
         },
-        vertexShader: document.getElementById('vertexShader').textContent,
-        fragmentShader: document.getElementById('fragmentShader').textContent,
+        vertexShader: document.getElementById('vertexShader')!.textContent!,
+        fragmentShader: document.getElementById('fragmentShader')!.textContent!,
         glslVersion: THREE.GLSL3,
     });
 
@@ -129,7 +133,7 @@ function init() {
     gui.add(api, 'count', 1, pointLightsMax)
         .step(1)
         .onChange(function () {
-            lightingUniformsGroup.uniforms[2].value = api.count;
+            (lightingUniformsGroup.uniforms[2] as THREE.Uniform).value = api.count;
         });
 }
 
@@ -145,7 +149,7 @@ function onWindowResize() {
 function animate() {
     const elapsedTime = clock.getElapsedTime();
 
-    const lights = lightingUniformsGroup.uniforms[0];
+    const lights = lightingUniformsGroup.uniforms[0] as THREE.Uniform[];
 
     // Parameters for circular movement
     const radius = 5; // Smaller radius for individual circular movements
diff --git a/examples-testing/examples/webgl_video_kinect.ts b/examples-testing/examples/webgl_video_kinect.ts
index 8abc93917..dd637649d 100644
--- a/examples-testing/examples/webgl_video_kinect.ts
+++ b/examples-testing/examples/webgl_video_kinect.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let scene, camera, renderer;
-let geometry, mesh, material;
-let mouse, center;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer;
+let geometry: THREE.BufferGeometry, mesh: THREE.Points, material: THREE.ShaderMaterial;
+let mouse: THREE.Vector3, center: THREE.Vector3;
 
 init();
 
@@ -24,7 +24,7 @@ function init() {
     center = new THREE.Vector3();
     center.z = -1000;
 
-    const video = document.getElementById('video');
+    const video = document.getElementById('video') as HTMLVideoElement;
 
     const texture = new THREE.VideoTexture(video);
     texture.minFilter = THREE.NearestFilter;
@@ -57,8 +57,8 @@ function init() {
             pointSize: { value: 2 },
             zOffset: { value: 1000 },
         },
-        vertexShader: document.getElementById('vs').textContent,
-        fragmentShader: document.getElementById('fs').textContent,
+        vertexShader: document.getElementById('vs')!.textContent!,
+        fragmentShader: document.getElementById('fs')!.textContent!,
         blending: THREE.AdditiveBlending,
         depthTest: false,
         depthWrite: false,
@@ -100,7 +100,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouse.x = (event.clientX - window.innerWidth / 2) * 8;
     mouse.y = (event.clientY - window.innerHeight / 2) * 8;
 }
diff --git a/examples-testing/examples/webgl_video_panorama_equirectangular.ts b/examples-testing/examples/webgl_video_panorama_equirectangular.ts
index 866eca16a..073011389 100644
--- a/examples-testing/examples/webgl_video_panorama_equirectangular.ts
+++ b/examples-testing/examples/webgl_video_panorama_equirectangular.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let isUserInteracting = false,
     lon = 0,
@@ -17,7 +17,7 @@ const distance = 0.5;
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.25, 10);
 
@@ -27,7 +27,7 @@ function init() {
     // invert the geometry on the x-axis so that all of the faces point inward
     geometry.scale(-1, 1, 1);
 
-    const video = document.getElementById('video');
+    const video = document.getElementById('video') as HTMLVideoElement;
     video.play();
 
     const texture = new THREE.VideoTexture(video);
@@ -59,7 +59,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     isUserInteracting = true;
 
     onPointerDownPointerX = event.clientX;
@@ -69,7 +69,7 @@ function onPointerDown(event) {
     onPointerDownLat = lat;
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (isUserInteracting === true) {
         lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
         lat = (onPointerDownPointerY - event.clientY) * 0.1 + onPointerDownLat;
diff --git a/examples-testing/examples/webgl_volume_cloud.ts b/examples-testing/examples/webgl_volume_cloud.ts
index 9aa07b98f..dfe98826a 100644
--- a/examples-testing/examples/webgl_volume_cloud.ts
+++ b/examples-testing/examples/webgl_volume_cloud.ts
@@ -4,8 +4,8 @@ import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let renderer, scene, camera;
-let mesh;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let mesh: THREE.Mesh<THREE.BoxGeometry, THREE.RawShaderMaterial>;
 
 init();
 
@@ -29,7 +29,7 @@ function init() {
     canvas.width = 1;
     canvas.height = 32;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     const gradient = context.createLinearGradient(0, 0, 0, 32);
     gradient.addColorStop(0.0, '#014a84');
     gradient.addColorStop(0.5, '#0561a0');
@@ -270,10 +270,10 @@ function onWindowResize() {
 }
 
 function animate() {
-    mesh.material.uniforms.cameraPos.value.copy(camera.position);
+    (mesh.material.uniforms.cameraPos.value as THREE.Vector3).copy(camera.position);
     mesh.rotation.y = -performance.now() / 7500;
 
-    mesh.material.uniforms.frame.value++;
+    (mesh.material.uniforms.frame.value as number)++;
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl_volume_instancing.ts b/examples-testing/examples/webgl_volume_instancing.ts
index 086e6fcf7..34d0b3fe0 100644
--- a/examples-testing/examples/webgl_volume_instancing.ts
+++ b/examples-testing/examples/webgl_volume_instancing.ts
@@ -2,7 +2,11 @@ import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { VOXLoader, VOXData3DTexture } from 'three/addons/loaders/VOXLoader.js';
 
-let renderer, scene, camera, controls, clock;
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    controls: OrbitControls,
+    clock: THREE.Clock;
 
 init();
 
@@ -182,7 +186,7 @@ function init() {
 
             const mesh = new THREE.InstancedMesh(geometry, material, 50000);
             mesh.onBeforeRender = function () {
-                this.material.uniforms.cameraPos.value.copy(camera.position);
+                (this.material.uniforms.cameraPos.value as THREE.Vector3).copy(camera.position);
             };
 
             const transform = new THREE.Object3D();
diff --git a/examples-testing/examples/webgl_volume_perlin.ts b/examples-testing/examples/webgl_volume_perlin.ts
index 0f299f66f..b02dd139c 100644
--- a/examples-testing/examples/webgl_volume_perlin.ts
+++ b/examples-testing/examples/webgl_volume_perlin.ts
@@ -4,8 +4,8 @@ import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
 
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let renderer, scene, camera;
-let mesh;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let mesh: THREE.Mesh<THREE.BoxGeometry, THREE.RawShaderMaterial>;
 
 init();
 
@@ -199,7 +199,7 @@ function onWindowResize() {
 }
 
 function animate() {
-    mesh.material.uniforms.cameraPos.value.copy(camera.position);
+    (mesh.material.uniforms.cameraPos.value as THREE.Vector3).copy(camera.position);
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl_watch.ts b/examples-testing/examples/webgl_watch.ts
index b65f53093..0b83eab46 100644
--- a/examples-testing/examples/webgl_watch.ts
+++ b/examples-testing/examples/webgl_watch.ts
@@ -1,5 +1,5 @@
 import * as THREE from 'three';
-import * as TWEEN from 'tween';
+import * as TWEEN from 'three/addons/libs/tween.module.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
@@ -13,12 +13,17 @@ import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js'
 import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
 import { TAARenderPass } from 'three/addons/postprocessing/TAARenderPass.js';
 
-let composer, camera, scene, renderer;
-let gui, dirLight, pointLight, controls, bloomPass, taaPass;
+let composer: EffectComposer | null, camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let gui: GUI,
+    dirLight: THREE.DirectionalLight,
+    pointLight: THREE.PointLight,
+    controls: OrbitControls,
+    bloomPass: UnrealBloomPass | null,
+    taaPass: TAARenderPass | null;
 let ready = false;
 
-const meshes = {};
-const materials = {};
+const meshes: { [name: string]: THREE.Mesh | THREE.Group } = {};
+const materials: { [name: string]: THREE.MeshStandardMaterial } = {};
 const torad = Math.PI / 180;
 
 const setting = {
@@ -34,7 +39,7 @@ const setting = {
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 20);
     camera.position.set(0.8, 0.5, -1.5);
@@ -67,23 +72,26 @@ function init() {
             gltf.scene.rotation.x = Math.PI * 0.25;
 
             gltf.scene.traverse(child => {
-                if (child.isMesh || child.isGroup) {
-                    if (child.isMesh) {
-                        child.material.vertexColors = false;
-                        materials[child.material.name] = child.material;
+                if ((child as THREE.Mesh).isMesh || (child as THREE.Group).isGroup) {
+                    if ((child as THREE.Mesh).isMesh) {
+                        (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.vertexColors =
+                            false;
+                        materials[(child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.name] = (
+                            child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>
+                        ).material;
                         if (child.name !== 'glass') {
                             child.receiveShadow = true;
                             child.castShadow = true;
                         }
                     }
 
-                    meshes[child.name] = child;
+                    meshes[child.name] = child as THREE.Mesh | THREE.Group;
                 }
             });
 
             scene.add(gltf.scene);
 
-            meshes.glass.material = new THREE.MeshPhysicalMaterial({
+            (meshes.glass as THREE.Mesh).material = new THREE.MeshPhysicalMaterial({
                 color: 0x020205,
                 transparent: true,
                 opacity: setting.opacity,
@@ -161,7 +169,7 @@ function moveCamera() {
         .start();
 }
 
-function postProcess(b) {
+function postProcess(b: boolean) {
     if (b) {
         if (composer) return;
 
@@ -207,7 +215,7 @@ function createGUI() {
 function upMaterial() {
     materials.Gold.metalness = materials.Silver.metalness = setting.metalness;
     materials.Gold.roughness = materials.Silver.roughness = setting.roughness;
-    meshes.glass.material.opacity = setting.opacity;
+    (meshes.glass as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.opacity = setting.opacity;
 }
 
 function upBloom() {
diff --git a/examples-testing/examples/webgpu_animation_retargeting.ts b/examples-testing/examples/webgpu_animation_retargeting.ts
index 91bc961d7..e48af49ee 100644
--- a/examples-testing/examples/webgpu_animation_retargeting.ts
+++ b/examples-testing/examples/webgpu_animation_retargeting.ts
@@ -21,17 +21,17 @@ import {
 } from 'three/tsl';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
+import { GLTF, GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
 
 const [sourceModel, targetModel] = await Promise.all([
-    new Promise((resolve, reject) => {
+    new Promise<GLTF>((resolve, reject) => {
         new GLTFLoader().load('./models/gltf/Michelle.glb', resolve, undefined, reject);
     }),
 
-    new Promise((resolve, reject) => {
+    new Promise<GLTF>((resolve, reject) => {
         new GLTFLoader().load('./models/gltf/Soldier.glb', resolve, undefined, reject);
     }),
 ]);
@@ -40,7 +40,7 @@ const [sourceModel, targetModel] = await Promise.all([
 
 const clock = new THREE.Clock();
 
-export const lightSpeed = /*#__PURE__*/ Fn(([suv_immutable]) => {
+export const lightSpeed = /*#__PURE__*/ Fn<[THREE.Node], THREE.Node<'vec3'>>(([suv_immutable]) => {
     // forked from https://www.shadertoy.com/view/7ly3D1
 
     const suv = vec2(suv_immutable);
@@ -161,12 +161,18 @@ controls.maxDistance = 12;
 controls.target.set(0, 1, 0);
 controls.maxPolarAngle = Math.PI / 2;
 
-const gui = renderer.inspector.createParameters('Scene settings');
+const gui = (renderer.inspector as Inspector).createParameters('Scene settings');
 gui.add(helpers, 'visible').name('show helpers');
 
 //
 
-function getSource(sourceModel) {
+interface Source {
+    clip: THREE.AnimationClip;
+    skeleton: THREE.Skeleton;
+    mixer: THREE.AnimationMixer;
+}
+
+function getSource(sourceModel: GLTF): Source {
     const clip = sourceModel.animations[0];
 
     const helper = new THREE.SkeletonHelper(sourceModel.scene);
@@ -180,7 +186,7 @@ function getSource(sourceModel) {
     return { clip, skeleton, mixer };
 }
 
-function retargetModel(sourceModel, targetModel) {
+function retargetModel(sourceModel: Source, targetModel: GLTF) {
     const targetSkin = targetModel.scene.children[0].children[0];
 
     const targetSkelHelper = new THREE.SkeletonHelper(targetModel.scene);
diff --git a/examples-testing/examples/webgpu_animation_retargeting_readyplayer.ts b/examples-testing/examples/webgpu_animation_retargeting_readyplayer.ts
index 32befa2e3..12bf346f6 100644
--- a/examples-testing/examples/webgpu_animation_retargeting_readyplayer.ts
+++ b/examples-testing/examples/webgpu_animation_retargeting_readyplayer.ts
@@ -2,18 +2,18 @@ import * as THREE from 'three/webgpu';
 import { screenUV, color, vec2, vec4, reflector, positionWorld } from 'three/tsl';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
+import { GLTFLoader, GLTF } from 'three/addons/loaders/GLTFLoader.js';
 import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
 
 const [sourceModel, targetModel] = await Promise.all([
-    new Promise((resolve, reject) => {
+    new Promise<THREE.Group>((resolve, reject) => {
         new FBXLoader().load('./models/fbx/mixamo.fbx', resolve, undefined, reject);
     }),
 
-    new Promise((resolve, reject) => {
+    new Promise<GLTF>((resolve, reject) => {
         new GLTFLoader().load('./models/gltf/readyplayer.me.glb', resolve, undefined, reject);
     }),
 ]);
@@ -99,7 +99,13 @@ scene.add(floor);
 
 //
 
-function getSource(sourceModel) {
+interface Source {
+    clip: THREE.AnimationClip;
+    skeleton: THREE.Skeleton;
+    mixer: THREE.AnimationMixer;
+}
+
+function getSource(sourceModel: THREE.Group): Source {
     const clip = sourceModel.animations[0];
 
     const helper = new THREE.SkeletonHelper(sourceModel);
@@ -111,10 +117,10 @@ function getSource(sourceModel) {
     return { clip, skeleton, mixer };
 }
 
-function retargetModel(sourceModel, targetModel) {
+function retargetModel(sourceModel: Source, targetModel: GLTF) {
     const targetSkin = targetModel.scene.children[0].children[1];
 
-    const retargetOptions = {
+    const retargetOptions: SkeletonUtils.RetargetClipOptions = {
         // specify the name of the source's hip bone.
         hip: 'mixamorigHips',
 
diff --git a/examples-testing/examples/webgpu_backdrop.ts b/examples-testing/examples/webgpu_backdrop.ts
index 5ae042493..052adf958 100644
--- a/examples-testing/examples/webgpu_backdrop.ts
+++ b/examples-testing/examples/webgpu_backdrop.ts
@@ -22,10 +22,10 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
-let portals,
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let portals: THREE.Group,
     rotate = true;
-let mixer, clock;
+let mixer: THREE.AnimationMixer, clock: THREE.Clock;
 
 init();
 
@@ -51,7 +51,9 @@ function init() {
         const object = gltf.scene;
         mixer = new THREE.AnimationMixer(object);
 
-        const material = object.children[0].children[0].material;
+        const material = (
+            object.children[0].children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhysicalMaterial>
+        ).material;
         material.outputNode = oscSine(time.mul(0.1)).mix(output, posterize(output.add(0.1), 4).mul(2));
 
         const action = mixer.clipAction(gltf.animations[0]);
@@ -67,7 +69,7 @@ function init() {
     portals = new THREE.Group();
     scene.add(portals);
 
-    function addBackdropSphere(backdropNode, backdropAlphaNode = null) {
+    function addBackdropSphere(backdropNode: THREE.Node, backdropAlphaNode: THREE.Node | null = null) {
         const distance = 1;
         const id = portals.children.length;
         const rotation = THREE.MathUtils.degToRad(id * 45);
diff --git a/examples-testing/examples/webgpu_backdrop_area.ts b/examples-testing/examples/webgpu_backdrop_area.ts
index 3ec30a762..5a3faadc2 100644
--- a/examples-testing/examples/webgpu_backdrop_area.ts
+++ b/examples-testing/examples/webgpu_backdrop_area.ts
@@ -20,8 +20,8 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
-let mixer, clock;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let mixer: THREE.AnimationMixer, clock: THREE.Clock;
 
 init();
 
@@ -127,13 +127,13 @@ function init() {
         pixel: pixelMaterial,
     };
 
-    const options = { material: 'blurred' };
+    const options: { material: keyof typeof materials } = { material: 'blurred' };
     box.material = materials[options.material];
 
-    const gui = renderer.inspector.createParameters('Scene settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Scene settings');
     gui.add(box.scale, 'x', 0.1, 2, 0.01).name('box scale x');
     gui.add(box.scale, 'y', 0.1, 2, 0.01).name('box scale y');
-    gui.add(options, 'material', Object.keys(materials)).onChange(name => {
+    gui.add(options, 'material', Object.keys(materials) as (keyof typeof materials)[]).onChange(name => {
         box.material = materials[name];
     });
 }
diff --git a/examples-testing/examples/webgpu_backdrop_water.ts b/examples-testing/examples/webgpu_backdrop_water.ts
index 1b780ce90..63b8469c4 100644
--- a/examples-testing/examples/webgpu_backdrop_water.ts
+++ b/examples-testing/examples/webgpu_backdrop_water.ts
@@ -24,11 +24,13 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
-let mixer, objects, clock;
-let model, floor, floorPosition;
-let postProcessing;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let mixer: THREE.AnimationMixer, objects: THREE.Group, clock: THREE.Clock;
+let model: THREE.Group,
+    floor: THREE.Mesh<THREE.CylinderGeometry, THREE.MeshStandardNodeMaterial>,
+    floorPosition: THREE.Vector3;
+let postProcessing: THREE.PostProcessing;
+let controls: OrbitControls;
 
 init();
 
@@ -164,10 +166,10 @@ function init() {
 
     const waterPosY = positionWorld.y.sub(water.position.y);
 
-    let transition = waterPosY.add(0.1).saturate().oneMinus();
+    let transition: THREE.Node<'float'> = waterPosY.add(0.1).saturate().oneMinus();
     transition = waterPosY.lessThan(0).select(transition, normalWorld.y.mix(transition, 0)).toVar();
 
-    const colorNode = transition.mix(material.colorNode, material.colorNode.add(waterLayer0));
+    const colorNode = transition.mix(material.colorNode as THREE.Node<'vec4'>, material.colorNode!.add(waterLayer0));
 
     //material.colorNode = colorNode;
     floor.material.colorNode = colorNode;
@@ -192,7 +194,7 @@ function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     floorPosition = new THREE.Vector3(0, 0.2, 0);
 
diff --git a/examples-testing/examples/webgpu_camera.ts b/examples-testing/examples/webgpu_camera.ts
index bf4724ac8..b964cc5fd 100644
--- a/examples-testing/examples/webgpu_camera.ts
+++ b/examples-testing/examples/webgpu_camera.ts
@@ -4,11 +4,11 @@ let SCREEN_WIDTH = window.innerWidth;
 let SCREEN_HEIGHT = window.innerHeight;
 let aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
 
-let container;
-let camera, scene, renderer, mesh;
-let cameraRig, activeCamera, activeHelper;
-let cameraPerspective, cameraOrtho;
-let cameraPerspectiveHelper, cameraOrthoHelper;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, mesh: THREE.Mesh;
+let cameraRig: THREE.Group, activeCamera: THREE.Camera, activeHelper: THREE.CameraHelper;
+let cameraPerspective: THREE.PerspectiveCamera, cameraOrtho: THREE.OrthographicCamera;
+let cameraPerspectiveHelper: THREE.CameraHelper, cameraOrthoHelper: THREE.CameraHelper;
 const frustumSize = 600;
 
 init();
@@ -116,7 +116,7 @@ function init() {
 
 //
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     switch (event.keyCode) {
         case 79 /*O*/:
             activeCamera = cameraOrtho;
diff --git a/examples-testing/examples/webgpu_camera_array.ts b/examples-testing/examples/webgpu_camera_array.ts
index 4ae08d66f..14334d410 100644
--- a/examples-testing/examples/webgpu_camera_array.ts
+++ b/examples-testing/examples/webgpu_camera_array.ts
@@ -1,7 +1,7 @@
 import * as THREE from 'three/webgpu';
 
-let camera, scene, renderer;
-let mesh;
+let camera: THREE.ArrayCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let mesh: THREE.Mesh;
 
 const AMOUNT = 6;
 
@@ -74,7 +74,7 @@ function updateCameras() {
             const subcamera = camera.cameras[AMOUNT * y + x];
             subcamera.copy(camera); // copy fov, aspect ratio, near, far from the root camera
 
-            subcamera.viewport.set(Math.floor(x * WIDTH), Math.floor(y * HEIGHT), Math.ceil(WIDTH), Math.ceil(HEIGHT));
+            subcamera.viewport!.set(Math.floor(x * WIDTH), Math.floor(y * HEIGHT), Math.ceil(WIDTH), Math.ceil(HEIGHT));
             subcamera.updateProjectionMatrix();
 
             subcamera.position.x = x / AMOUNT - 0.5;
diff --git a/examples-testing/examples/webgpu_camera_logarithmicdepthbuffer.ts b/examples-testing/examples/webgpu_camera_logarithmicdepthbuffer.ts
index 0a05626a1..0d9d160da 100644
--- a/examples-testing/examples/webgpu_camera_logarithmicdepthbuffer.ts
+++ b/examples-testing/examples/webgpu_camera_logarithmicdepthbuffer.ts
@@ -2,7 +2,7 @@ import * as THREE from 'three/webgpu';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-import { FontLoader } from 'three/addons/loaders/FontLoader.js';
+import { Font, FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
 // 1 micrometer to 100 billion light years in one scene, with 1 unit = 1 meter?  preposterous!  and yet...
@@ -17,8 +17,16 @@ let zoompos = -100,
     minzoomspeed = 0.015;
 let zoomspeed = minzoomspeed;
 
-let container, border;
-const objects = {};
+let container: HTMLElement, border: HTMLElement;
+
+interface ObjectView {
+    container: HTMLElement;
+    renderer: THREE.WebGPURenderer;
+    scene: THREE.Scene;
+    camera: THREE.PerspectiveCamera;
+}
+
+const objects: { normal?: ObjectView; logzbuf?: ObjectView } = {};
 
 // Generate a number of text labels, from 1m in size up to 100,000,000 light years
 // Try to use some descriptive real-world examples of objects at each scale
@@ -44,7 +52,7 @@ const labeldata = [
 init().then(animate);
 
 async function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     const loader = new FontLoader();
     const font = await loader.loadAsync('fonts/helvetiker_regular.typeface.json');
@@ -56,7 +64,7 @@ async function init() {
     objects.logzbuf = await initView(scene, 'logzbuf', true);
 
     // Resize border allows the user to easily compare effects of logarithmic depth buffer over the whole scene
-    border = document.getElementById('renderer_border');
+    border = document.getElementById('renderer_border')!;
     border.addEventListener('pointerdown', onBorderPointerDown);
 
     window.addEventListener('mousemove', onMouseMove);
@@ -64,8 +72,8 @@ async function init() {
     window.addEventListener('wheel', onMouseWheel);
 }
 
-async function initView(scene, name, logDepthBuf) {
-    const framecontainer = document.getElementById('container_' + name);
+async function initView(scene: THREE.Scene, name: string, logDepthBuf: boolean) {
+    const framecontainer = document.getElementById('container_' + name)!;
 
     const camera = new THREE.PerspectiveCamera(50, (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT, NEAR, FAR);
     scene.add(camera);
@@ -83,7 +91,7 @@ async function initView(scene, name, logDepthBuf) {
     return { container: framecontainer, renderer: renderer, scene: scene, camera: camera };
 }
 
-function initScene(font) {
+function initScene(font: Font) {
     const scene = new THREE.Scene();
 
     scene.add(new THREE.AmbientLight(0x777777));
@@ -92,7 +100,7 @@ function initScene(font) {
     light.position.set(100, 100, 100);
     scene.add(light);
 
-    const materialargs = {
+    const materialargs: { color: THREE.ColorRepresentation; specular: number; shininess: number; emissive: number } = {
         color: 0xffffff,
         specular: 0x050505,
         shininess: 50,
@@ -113,7 +121,7 @@ function initScene(font) {
         labelgeo.computeBoundingSphere();
 
         // center text
-        labelgeo.translate(-labelgeo.boundingSphere.radius, 0, 0);
+        labelgeo.translate(-labelgeo.boundingSphere!.radius, 0, 0);
 
         materialargs.color = new THREE.Color().setHSL(Math.random(), 0.5, 0.5);
 
@@ -146,16 +154,16 @@ function updateRendererSizes() {
 
     screensplit_right = 1 - screensplit;
 
-    objects.normal.renderer.setSize(screensplit * SCREEN_WIDTH, SCREEN_HEIGHT);
-    objects.normal.camera.aspect = (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT;
-    objects.normal.camera.updateProjectionMatrix();
-    objects.normal.camera.setViewOffset(SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT);
-    objects.normal.container.style.width = screensplit * 100 + '%';
+    objects.normal!.renderer.setSize(screensplit * SCREEN_WIDTH, SCREEN_HEIGHT);
+    objects.normal!.camera.aspect = (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT;
+    objects.normal!.camera.updateProjectionMatrix();
+    objects.normal!.camera.setViewOffset(SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT);
+    objects.normal!.container.style.width = screensplit * 100 + '%';
 
-    objects.logzbuf.renderer.setSize(screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT);
-    objects.logzbuf.camera.aspect = (screensplit_right * SCREEN_WIDTH) / SCREEN_HEIGHT;
-    objects.logzbuf.camera.updateProjectionMatrix();
-    objects.logzbuf.camera.setViewOffset(
+    objects.logzbuf!.renderer.setSize(screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT);
+    objects.logzbuf!.camera.aspect = (screensplit_right * SCREEN_WIDTH) / SCREEN_HEIGHT;
+    objects.logzbuf!.camera.updateProjectionMatrix();
+    objects.logzbuf!.camera.setViewOffset(
         SCREEN_WIDTH,
         SCREEN_HEIGHT,
         SCREEN_WIDTH * screensplit,
@@ -163,7 +171,7 @@ function updateRendererSizes() {
         SCREEN_WIDTH * screensplit_right,
         SCREEN_HEIGHT,
     );
-    objects.logzbuf.container.style.width = screensplit_right * 100 + '%';
+    objects.logzbuf!.container.style.width = screensplit_right * 100 + '%';
 
     border.style.left = screensplit * 100 + '%';
 }
@@ -188,22 +196,22 @@ function animate() {
     zoompos += zoomspeed;
     zoomspeed *= damping;
 
-    objects.normal.camera.position.x = Math.sin(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
-    objects.normal.camera.position.y = Math.sin(0.25 * Math.PI * (mouse[1] - 0.5)) * zoom;
-    objects.normal.camera.position.z = Math.cos(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
-    objects.normal.camera.lookAt(objects.normal.scene.position);
+    objects.normal!.camera.position.x = Math.sin(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
+    objects.normal!.camera.position.y = Math.sin(0.25 * Math.PI * (mouse[1] - 0.5)) * zoom;
+    objects.normal!.camera.position.z = Math.cos(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
+    objects.normal!.camera.lookAt(objects.normal!.scene.position);
 
     // Clone camera settings across both scenes
-    objects.logzbuf.camera.position.copy(objects.normal.camera.position);
-    objects.logzbuf.camera.quaternion.copy(objects.normal.camera.quaternion);
+    objects.logzbuf!.camera.position.copy(objects.normal!.camera.position);
+    objects.logzbuf!.camera.quaternion.copy(objects.normal!.camera.quaternion);
 
     // Update renderer sizes if the split has changed
     if (screensplit_right != 1 - screensplit) {
         updateRendererSizes();
     }
 
-    objects.normal.renderer.render(objects.normal.scene, objects.normal.camera);
-    objects.logzbuf.renderer.render(objects.logzbuf.scene, objects.logzbuf.camera);
+    objects.normal!.renderer.render(objects.normal!.scene, objects.normal!.camera);
+    objects.logzbuf!.renderer.render(objects.logzbuf!.scene, objects.logzbuf!.camera);
 }
 
 function onWindowResize() {
@@ -216,7 +224,7 @@ function onBorderPointerDown() {
     window.addEventListener('pointerup', onBorderPointerUp);
 }
 
-function onBorderPointerMove(ev) {
+function onBorderPointerMove(ev: PointerEvent) {
     screensplit = Math.max(0, Math.min(1, ev.clientX / window.innerWidth));
 }
 
@@ -225,12 +233,12 @@ function onBorderPointerUp() {
     window.removeEventListener('pointerup', onBorderPointerUp);
 }
 
-function onMouseMove(ev) {
+function onMouseMove(ev: MouseEvent) {
     mouse[0] = ev.clientX / window.innerWidth;
     mouse[1] = ev.clientY / window.innerHeight;
 }
 
-function onMouseWheel(ev) {
+function onMouseWheel(ev: WheelEvent) {
     const amount = ev.deltaY;
     if (amount === 0) return;
     const dir = amount / Math.abs(amount);
diff --git a/examples-testing/examples/webgpu_caustics.ts b/examples-testing/examples/webgpu_caustics.ts
index 7c5f5a5d1..32543f3a1 100644
--- a/examples-testing/examples/webgpu_caustics.ts
+++ b/examples-testing/examples/webgpu_caustics.ts
@@ -20,8 +20,8 @@ import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, controls;
-let gltf;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, controls: OrbitControls;
+let gltf: THREE.Group;
 
 init();
 
@@ -65,7 +65,7 @@ async function init() {
 
     // objects / material
 
-    const duck = gltf.children[0];
+    const duck = gltf.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhysicalNodeMaterial>;
     duck.material = new THREE.MeshPhysicalNodeMaterial();
     duck.material.side = THREE.DoubleSide;
     duck.material.transparent = true;
@@ -162,7 +162,7 @@ async function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(causticOcclusion, 'value', 0, 20).name('caustic occlusion');
     gui.addColor(duck.material, 'color').name('material color');
     gui.add({ model: 'duck' }, 'model', ['duck', 'glass']).onChange(model => {
diff --git a/examples-testing/examples/webgpu_centroid_sampling.ts b/examples-testing/examples/webgpu_centroid_sampling.ts
index ca159d04c..24b0ee885 100644
--- a/examples-testing/examples/webgpu_centroid_sampling.ts
+++ b/examples-testing/examples/webgpu_centroid_sampling.ts
@@ -2,14 +2,22 @@ import * as THREE from 'three/webgpu';
 import { varying, uv, texture, Fn } from 'three/tsl';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
-
-let rendererAntialiasingEnabled;
-let rendererAntialiasingDisabled;
-let camera;
-let scene;
-let gui;
-
-const effectController = {
+import { ParametersGroup } from 'three/addons/inspector/tabs/Parameters.js';
+
+let rendererAntialiasingEnabled: THREE.WebGPURenderer;
+let rendererAntialiasingDisabled: THREE.WebGPURenderer;
+let camera: THREE.PerspectiveCamera;
+let scene: THREE.Scene;
+let gui: ParametersGroup;
+
+const effectController: {
+    sampling:
+        | typeof THREE.InterpolationSamplingMode.NORMAL
+        | typeof THREE.InterpolationSamplingMode.CENTROID
+        | typeof THREE.InterpolationSamplingMode.SAMPLE
+        | 'flat first'
+        | 'flat either';
+} = {
     sampling: 'normal',
 };
 
@@ -17,7 +25,7 @@ const atlasCanvas = document.createElement('canvas');
 atlasCanvas.width = 16;
 atlasCanvas.height = 16;
 
-const ctx = atlasCanvas.getContext('2d');
+const ctx = atlasCanvas.getContext('2d')!;
 ctx.fillStyle = 'red';
 ctx.fillRect(0, 0, 8, 8);
 
@@ -62,7 +70,7 @@ function init() {
 
     scene = new THREE.Scene();
 
-    const makeFaceGeometry = uvs => {
+    const makeFaceGeometry = (uvs: number[]) => {
         const geometry = new THREE.BufferGeometry();
         const positions = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0];
         geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
@@ -78,7 +86,7 @@ function init() {
     const material = new THREE.MeshBasicNodeMaterial();
     const testUV = varying(uv(), 'testUV');
 
-    const createShader = (type, sampling) => {
+    const createShader = (type: THREE.InterpolationSamplingType, sampling: THREE.InterpolationSamplingMode) => {
         return Fn(() => {
             testUV.setInterpolation(type, sampling);
 
@@ -113,7 +121,7 @@ function init() {
 
     material.colorNode = withoutInterpolationShader();
 
-    const faceMeshes = [];
+    const faceMeshes: THREE.Mesh<THREE.BufferGeometry, THREE.MeshBasicNodeMaterial>[] = [];
 
     for (let x = -5; x < 5; x++) {
         for (let y = -5; y < 5; y++) {
@@ -142,20 +150,20 @@ function init() {
         forceWebGL: forceWebGL,
     });
 
-    document.body.querySelector('#antialiasing-enabled').appendChild(rendererAntialiasingEnabled.domElement);
+    document.body.querySelector('#antialiasing-enabled')!.appendChild(rendererAntialiasingEnabled.domElement);
     rendererAntialiasingEnabled.setPixelRatio(window.devicePixelRatio);
     rendererAntialiasingEnabled.setSize(window.innerWidth / 2, window.innerHeight);
     rendererAntialiasingEnabled.setAnimationLoop(animateAliased);
     rendererAntialiasingEnabled.inspector = new Inspector();
 
-    document.body.querySelector('#antialiasing-disabled').appendChild(rendererAntialiasingDisabled.domElement);
-    document.body.querySelector('#antialiasing-disabled').appendChild(rendererAntialiasingDisabled.domElement);
+    document.body.querySelector('#antialiasing-disabled')!.appendChild(rendererAntialiasingDisabled.domElement);
+    document.body.querySelector('#antialiasing-disabled')!.appendChild(rendererAntialiasingDisabled.domElement);
 
     onWindowResize();
 
     window.addEventListener('resize', onWindowResize);
 
-    gui = rendererAntialiasingEnabled.inspector.createParameters('Settings');
+    gui = (rendererAntialiasingEnabled.inspector as Inspector).createParameters('Settings');
     gui.add(effectController, 'sampling', [
         THREE.InterpolationSamplingMode.NORMAL,
         THREE.InterpolationSamplingMode.CENTROID,
diff --git a/examples-testing/examples/webgpu_clearcoat.ts b/examples-testing/examples/webgpu_clearcoat.ts
index 02fbacb9d..d3ee1763c 100644
--- a/examples-testing/examples/webgpu_clearcoat.ts
+++ b/examples-testing/examples/webgpu_clearcoat.ts
@@ -7,10 +7,10 @@ import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.
 
 import { FlakesTexture } from 'three/addons/textures/FlakesTexture.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
-let particleLight;
-let group;
+let particleLight: THREE.Mesh;
+let group: THREE.Group;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_clipping.ts b/examples-testing/examples/webgpu_clipping.ts
index e07e60463..2e0d4855a 100644
--- a/examples-testing/examples/webgpu_clipping.ts
+++ b/examples-testing/examples/webgpu_clipping.ts
@@ -4,7 +4,11 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, startTime, object;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    startTime: number,
+    object: THREE.Mesh;
 
 init();
 
@@ -110,7 +114,7 @@ function init() {
 
     // GUI
 
-    const gui = renderer.inspector.createParameters('Clipping settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Clipping settings');
     const props = {
         alphaToCoverage: true,
     };
@@ -192,7 +196,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function animate(currentTime) {
+function animate(currentTime: DOMHighResTimeStamp) {
     const time = (currentTime - startTime) / 1000;
 
     object.position.y = 0.8;
diff --git a/examples-testing/examples/webgpu_compute_audio.ts b/examples-testing/examples/webgpu_compute_audio.ts
index 229033d79..da8f94d50 100644
--- a/examples-testing/examples/webgpu_compute_audio.ts
+++ b/examples-testing/examples/webgpu_compute_audio.ts
@@ -3,15 +3,15 @@ import { Fn, uniform, instanceIndex, instancedArray, float, texture, screenUV, c
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
-let computeNode;
-let waveBuffer, sampleRate;
-let waveArray;
-let currentAudio, currentAnalyser;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let computeNode: THREE.ComputeNode;
+let waveBuffer: Float32Array<ArrayBuffer>, sampleRate: number;
+let waveArray: THREE.StorageBufferNode<'float'>;
+let currentAudio: AudioBufferSourceNode, currentAnalyser: AnalyserNode;
 const analyserBuffer = new Uint8Array(1024);
-let analyserTexture;
+let analyserTexture: THREE.DataTexture;
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', init);
 
 async function playAudioBuffer() {
@@ -46,7 +46,7 @@ async function playAudioBuffer() {
 }
 
 async function init() {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
     // audio buffer
@@ -92,7 +92,7 @@ async function init() {
 
         const time = index.mul(pitch);
 
-        let wave = originalWave.element(time);
+        let wave: THREE.Node<'float'> = originalWave.element(time);
 
         // delay
 
@@ -149,7 +149,7 @@ async function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Audio');
+    const gui = (renderer.inspector as Inspector).createParameters('Audio');
 
     gui.add(pitch, 'value', 0.5, 2, 0.01).name('pitch');
     gui.add(delayVolume, 'value', 0, 1, 0.01).name('delayVolume');
diff --git a/examples-testing/examples/webgpu_compute_birds.ts b/examples-testing/examples/webgpu_compute_birds.ts
index c602920ee..802afddb6 100644
--- a/examples-testing/examples/webgpu_compute_birds.ts
+++ b/examples-testing/examples/webgpu_compute_birds.ts
@@ -35,13 +35,24 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import WebGPU from 'three/addons/capabilities/WebGPU.js';
 
-let container;
-let camera, scene, renderer;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 let last = performance.now();
 
-let pointer, raycaster;
-let computeVelocity, computePosition, effectController;
+let pointer: THREE.Vector2, raycaster: THREE.Raycaster;
+let computeVelocity: THREE.ComputeNode,
+    computePosition: THREE.ComputeNode,
+    effectController: {
+        separation: THREE.UniformNode<'float', number>;
+        alignment: THREE.UniformNode<'float', number>;
+        cohesion: THREE.UniformNode<'float', number>;
+        freedom: THREE.UniformNode<'float', number>;
+        now: THREE.UniformNode<'float', number>;
+        deltaTime: THREE.UniformNode<'float', number>;
+        rayOrigin: THREE.UniformNode<'vec3', THREE.Vector3>;
+        rayDirection: THREE.UniformNode<'vec3', THREE.Vector3>;
+    };
 
 const BIRDS = 16384;
 const SPEED_LIMIT = 9.0;
@@ -61,7 +72,7 @@ class BirdGeometry extends THREE.BufferGeometry {
 
         let v = 0;
 
-        function verts_push() {
+        function verts_push(...args: number[]) {
             for (let i = 0; i < arguments.length; i++) {
                 vertices.array[v++] = arguments[i];
             }
@@ -374,7 +385,7 @@ function init() {
 
     window.addEventListener('resize', onWindowResize);
 
-    const gui = renderer.inspector.createParameters('Birds settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Birds settings');
     gui.add(effectController.separation, 'value', 0.0, 100.0, 1.0).name('Separation');
     gui.add(effectController.alignment, 'value', 0.0, 100, 0.001).name('Alignment ');
     gui.add(effectController.cohesion, 'value', 0.0, 100, 0.025).name('Cohesion');
@@ -387,7 +398,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointer.x = (event.clientX / window.innerWidth) * 2.0 - 1.0;
diff --git a/examples-testing/examples/webgpu_compute_cloth.ts b/examples-testing/examples/webgpu_compute_cloth.ts
index 6f4c3b61b..ffdcddf00 100644
--- a/examples-testing/examples/webgpu_compute_cloth.ts
+++ b/examples-testing/examples/webgpu_compute_cloth.ts
@@ -24,7 +24,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 import WebGPU from 'three/addons/capabilities/WebGPU.js';
 
-let renderer, scene, camera, controls;
+let renderer: THREE.WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
 
 const clothWidth = 1;
 const clothHeight = 1;
@@ -32,18 +32,41 @@ const clothNumSegmentsX = 30;
 const clothNumSegmentsY = 30;
 const sphereRadius = 0.15;
 
-let vertexPositionBuffer, vertexForceBuffer, vertexParamsBuffer;
-let springVertexIdBuffer, springRestLengthBuffer, springForceBuffer;
-let springListBuffer;
-let computeSpringForces, computeVertexForces;
-let dampeningUniform, spherePositionUniform, stiffnessUniform, sphereUniform, windUniform;
-let vertexWireframeObject, springWireframeObject;
-let clothMesh, clothMaterial, sphere;
+let vertexPositionBuffer: THREE.StorageBufferNode<'vec3'>,
+    vertexForceBuffer: THREE.StorageBufferNode<'vec3'>,
+    vertexParamsBuffer: THREE.StorageBufferNode<'uvec3'>;
+let springVertexIdBuffer: THREE.StorageBufferNode<'uvec2'>,
+    springRestLengthBuffer: THREE.StorageBufferNode<'float'>,
+    springForceBuffer: THREE.StorageBufferNode<'vec3'>;
+let springListBuffer: THREE.StorageBufferNode<'uint'>;
+let computeSpringForces: THREE.ComputeNode, computeVertexForces: THREE.ComputeNode;
+let dampeningUniform: THREE.UniformNode<'float', number>,
+    spherePositionUniform: THREE.UniformNode<'vec3', THREE.Vector3>,
+    stiffnessUniform: THREE.UniformNode<'float', number>,
+    sphereUniform: THREE.UniformNode<'float', number>,
+    windUniform: THREE.UniformNode<'float', number>;
+let vertexWireframeObject: THREE.Mesh, springWireframeObject: THREE.Line;
+let clothMesh: THREE.Mesh, clothMaterial: THREE.MeshPhysicalNodeMaterial, sphere: THREE.Mesh;
 let timeSinceLastStep = 0;
 let timestamp = 0;
-const verletVertices = [];
-const verletSprings = [];
-const verletVertexColumns = [];
+
+interface VerletVertex {
+    id: number;
+    position: THREE.Vector3;
+    isFixed: boolean;
+    springIds: number[];
+}
+
+const verletVertices: VerletVertex[] = [];
+
+interface VerletSpring {
+    id: number;
+    vertex0: VerletVertex;
+    vertex1: VerletVertex;
+}
+
+const verletSprings: VerletSpring[] = [];
+const verletVertexColumns: VerletVertex[][] = [];
 
 const clock = new THREE.Clock();
 
@@ -98,7 +121,7 @@ async function init() {
 
     setupCloth();
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(stiffnessUniform, 'value', 0.1, 0.5, 0.01).name('stiffness');
     gui.add(params, 'wireframe');
     gui.add(params, 'sphere');
@@ -123,7 +146,7 @@ async function init() {
 function setupVerletGeometry() {
     // this function sets up the geometry of the verlet system, a grid of vertices connected by springs
 
-    const addVerletVertex = (x, y, z, isFixed) => {
+    const addVerletVertex = (x: number, y: number, z: number, isFixed: boolean) => {
         const id = verletVertices.length;
         const vertex = {
             id,
@@ -135,7 +158,7 @@ function setupVerletGeometry() {
         return vertex;
     };
 
-    const addVerletSpring = (vertex0, vertex1) => {
+    const addVerletSpring = (vertex0: VerletVertex, vertex1: VerletVertex) => {
         const id = verletSprings.length;
         const spring = {
             id,
@@ -349,7 +372,7 @@ function setupWireframe() {
     const springWireframeMaterial = new THREE.LineBasicNodeMaterial();
     springWireframeMaterial.positionNode = Fn(() => {
         const vertexIds = springVertexIdBuffer.element(instanceIndex);
-        const vertexId = select(attribute('vertexIndex').equal(0), vertexIds.x, vertexIds.y);
+        const vertexId = select(attribute<'uint'>('vertexIndex').equal(0), vertexIds.x, vertexIds.y);
         return vertexPositionBuffer.element(vertexId);
     })();
 
@@ -382,7 +405,7 @@ function setupClothMesh() {
     const verletVertexIdArray = new Uint32Array(vertexCount * 4);
     const indices = [];
 
-    const getIndex = (x, y) => {
+    const getIndex = (x: number, y: number) => {
         return y * clothNumSegmentsX + x;
     };
 
@@ -419,7 +442,7 @@ function setupClothMesh() {
 
     clothMaterial.positionNode = Fn(({ material }) => {
         // gather the position of the 4 verlet vertices and calculate the center position and normal from that
-        const vertexIds = attribute('vertexIds');
+        const vertexIds = attribute<'uvec4'>('vertexIds');
         const v0 = vertexPositionBuffer.element(vertexIds.x).toVar();
         const v1 = vertexPositionBuffer.element(vertexIds.y).toVar();
         const v2 = vertexPositionBuffer.element(vertexIds.z).toVar();
@@ -436,7 +459,7 @@ function setupClothMesh() {
         const normal = cross(tangent, bitangent);
 
         // send the normalView from the vertex shader to the fragment shader
-        material.normalNode = transformNormalToView(normal).toVarying();
+        (material as THREE.MeshPhysicalNodeMaterial).normalNode = transformNormalToView(normal).toVarying();
 
         return v0.add(v1).add(v2).add(v3).mul(0.25);
     })();
diff --git a/examples-testing/examples/webgpu_compute_particles_snow.ts b/examples-testing/examples/webgpu_compute_particles_snow.ts
index 1f76c981c..e21935c61 100644
--- a/examples-testing/examples/webgpu_compute_particles_snow.ts
+++ b/examples-testing/examples/webgpu_compute_particles_snow.ts
@@ -26,12 +26,14 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 const maxParticleCount = 100000;
 
-let camera, scene, renderer;
-let controls;
-let computeParticles;
-let postProcessing;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let controls: OrbitControls;
+let computeParticles: THREE.ComputeNode;
+let postProcessing: THREE.PostProcessing;
 
-let collisionCamera, collisionPosRT, collisionPosMaterial;
+let collisionCamera: THREE.OrthographicCamera,
+    collisionPosRT: THREE.RenderTarget,
+    collisionPosMaterial: THREE.MeshBasicNodeMaterial;
 
 init();
 
@@ -124,7 +126,7 @@ async function init() {
     const speed = 0.4;
 
     const computeUpdate = Fn(() => {
-        const getCoord = pos => pos.add(50).div(100);
+        const getCoord = (pos: THREE.Node<'vec2'>) => pos.add(50).div(100);
 
         const position = positionBuffer.element(instanceIndex);
         const scale = scaleBuffer.element(instanceIndex);
@@ -159,7 +161,7 @@ async function init() {
 
     const geometry = new THREE.SphereGeometry(surfaceOffset, 5, 5);
 
-    function particle(staticParticles) {
+    function particle(staticParticles?: boolean) {
         const posBuffer = staticParticles ? staticPositionBuffer : positionBuffer;
         const layer = staticParticles ? 1 : 2;
 
@@ -291,7 +293,7 @@ async function init() {
 
     // compose
 
-    let totalPass = scenePass.toInspector('Scene');
+    let totalPass: THREE.Node<'vec4'> = scenePass.toInspector('Scene');
     totalPass = totalPass.add(scenePassColorBlurred.mul(0.1));
     totalPass = totalPass.mul(vignette);
     totalPass = totalPass.add(teapotTreePass.mul(10).add(teapotTreePassBlurred).toInspector('Teapot Blur'));
diff --git a/examples-testing/examples/webgpu_compute_points.ts b/examples-testing/examples/webgpu_compute_points.ts
index b51bafeab..34d18d6ef 100644
--- a/examples-testing/examples/webgpu_compute_points.ts
+++ b/examples-testing/examples/webgpu_compute_points.ts
@@ -4,8 +4,8 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 import { Fn, uniform, instancedArray, float, vec2, color, instanceIndex } from 'three/tsl';
 
-let camera, scene, renderer;
-let computeNode;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let computeNode: THREE.ComputeNode;
 
 const pointerVector = new THREE.Vector2(-10.0, -10.0); // Out of bounds first
 const scaleVector = new THREE.Vector2(1, 1);
@@ -96,7 +96,7 @@ async function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     gui.add(scaleVector, 'x', 0, 1, 0.01);
     gui.add(scaleVector, 'y', 0, 1, 0.01);
@@ -108,7 +108,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onMouseMove(event) {
+function onMouseMove(event: MouseEvent) {
     const x = event.clientX;
     const y = event.clientY;
 
diff --git a/examples-testing/examples/webgpu_compute_sort_bitonic.ts b/examples-testing/examples/webgpu_compute_sort_bitonic.ts
index 9a37a9ece..723e4ffbd 100644
--- a/examples-testing/examples/webgpu_compute_sort_bitonic.ts
+++ b/examples-testing/examples/webgpu_compute_sort_bitonic.ts
@@ -18,8 +18,8 @@ const StepType = {
 };
 
 const timestamps = {
-    local_swap: document.getElementById('local_swap'),
-    global_swap: document.getElementById('global_swap'),
+    local_swap: document.getElementById('local_swap')!,
+    global_swap: document.getElementById('global_swap')!,
 };
 
 const localColors = ['rgb(203, 64, 203)', 'rgb(0, 215, 215)'];
@@ -63,7 +63,7 @@ if (WebGPU.isAvailable() === false) {
 
 // Display utilities
 
-const getElementIndex = Fn(
+const getElementIndex = Fn<readonly [THREE.Node<'vec2'>, THREE.Node<'uint'>, THREE.Node<'uint'>], THREE.Node<'uint'>>(
     ([uvNode, gridWidth, gridHeight]) => {
         const newUV = uvNode.mul(vec2(gridWidth, gridHeight));
         const pixel = uvec2(uint(floor(newUV.x)), uint(floor(newUV.y)));
@@ -79,7 +79,7 @@ const getElementIndex = Fn(
     },
 );
 
-const getColor = Fn(
+const getColor = Fn<readonly [THREE.Node<'float'>, THREE.Node<'float'>, THREE.Node<'float'>], THREE.Node<'vec3'>>(
     ([colorChanger, gridWidth, gridHeight]) => {
         const subtracter = colorChanger.div(gridWidth.mul(gridHeight));
         return vec3(subtracter.oneMinus()).toVar();
@@ -92,7 +92,7 @@ const getColor = Fn(
     },
 );
 
-const randomizeDataArray = array => {
+const randomizeDataArray = (array: Uint32Array) => {
     let currentIndex = array.length;
     while (currentIndex !== 0) {
         const randomIndex = Math.floor(Math.random() * currentIndex);
@@ -101,7 +101,7 @@ const randomizeDataArray = array => {
     }
 };
 
-const windowResizeCallback = (renderer, scene, camera) => {
+const windowResizeCallback = (renderer: THREE.WebGPURenderer, scene: THREE.Scene, camera: THREE.OrthographicCamera) => {
     renderer.setSize(window.innerWidth / 2, window.innerHeight);
     const aspect = window.innerWidth / 2 / window.innerHeight;
     const frustumHeight = camera.top - camera.bottom;
@@ -111,7 +111,7 @@ const windowResizeCallback = (renderer, scene, camera) => {
     renderer.render(scene, camera);
 };
 
-const constructInnerHTML = (isGlobal, colorsArr) => {
+const constructInnerHTML = (isGlobal: boolean, colorsArr: string[]) => {
     return `
 
 				Compute ${isGlobal ? 'Global' : 'Local'}:
@@ -123,7 +123,11 @@ const constructInnerHTML = (isGlobal, colorsArr) => {
 				</div>`;
 };
 
-const createDisplayMesh = (elementsStorage, algoStorage = null, blockHeightStorage = null) => {
+const createDisplayMesh = (
+    elementsStorage: THREE.StorageBufferNode<'uint'>,
+    algoStorage: THREE.StorageBufferNode<'uint'> | null = null,
+    blockHeightStorage: THREE.StorageBufferNode<'uint'> | null = null,
+) => {
     const material = new THREE.MeshBasicNodeMaterial({ color: 0x00ff00 });
 
     const display = Fn(() => {
@@ -151,7 +155,10 @@ const createDisplayMesh = (elementsStorage, algoStorage = null, blockHeightStora
     return plane;
 };
 
-const createDisplayMesh2 = (elementsStorage, infoStorage) => {
+const createDisplayMesh2 = (
+    elementsStorage: THREE.StorageBufferNode<'uint'>,
+    infoStorage: THREE.StorageBufferNode<'uint'>,
+) => {
     const material = new THREE.MeshBasicNodeMaterial({ color: 0x00ff00 });
 
     const display = Fn(() => {
@@ -175,7 +182,7 @@ const createDisplayMesh2 = (elementsStorage, infoStorage) => {
     return plane;
 };
 
-const setupDomElement = renderer => {
+const setupDomElement = (renderer: THREE.WebGPURenderer) => {
     document.body.appendChild(renderer.domElement);
     renderer.domElement.style.position = 'absolute';
     renderer.domElement.style.top = '0';
@@ -319,7 +326,7 @@ async function initGlobalSwapOnly() {
         .setName('RandomizedElements');
 
     // Swap the elements in local storage
-    const globalCompareAndSwap = (idxBefore, idxAfter) => {
+    const globalCompareAndSwap = (idxBefore: THREE.Node, idxAfter: THREE.Node) => {
         // If the later element is less than the current element
         If(currentElementsStorage.element(idxAfter).lessThan(currentElementsStorage.element(idxBefore)), () => {
             // Apply the swapped values to temporary storage.
diff --git a/examples-testing/examples/webgpu_compute_texture.ts b/examples-testing/examples/webgpu_compute_texture.ts
index 43d162ab5..81e920f55 100644
--- a/examples-testing/examples/webgpu_compute_texture.ts
+++ b/examples-testing/examples/webgpu_compute_texture.ts
@@ -3,7 +3,7 @@ import { texture, textureStore, Fn, instanceIndex, float, uvec2, vec4 } from 'th
 
 import WebGPU from 'three/addons/capabilities/WebGPU.js';
 
-let camera, scene, renderer;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 init().then(render);
 
@@ -30,7 +30,7 @@ async function init() {
 
     // create function
 
-    const computeTexture = Fn(({ storageTexture }) => {
+    const computeTexture = Fn<{ storageTexture: THREE.Texture }, void>(({ storageTexture }) => {
         const posX = instanceIndex.mod(width);
         const posY = instanceIndex.div(width);
         const indexUV = uvec2(posX, posY);
diff --git a/examples-testing/examples/webgpu_compute_texture_3d.ts b/examples-testing/examples/webgpu_compute_texture_3d.ts
index ccdfba0be..d4ea0e51a 100644
--- a/examples-testing/examples/webgpu_compute_texture_3d.ts
+++ b/examples-testing/examples/webgpu_compute_texture_3d.ts
@@ -23,9 +23,9 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 import WebGPU from 'three/addons/capabilities/WebGPU.js';
 
-let renderer, scene, camera;
-let mesh;
-let computeNode;
+let renderer: THREE.WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let mesh: THREE.Mesh<THREE.BoxGeometry, THREE.NodeMaterial>;
+let computeNode: THREE.ComputeNode;
 
 if (WebGPU.isAvailable() === false) {
     document.body.appendChild(WebGPU.getErrorMessage());
@@ -58,7 +58,7 @@ async function init() {
     canvas.width = 1;
     canvas.height = 32;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     const gradient = context.createLinearGradient(0, 0, 0, 32);
     gradient.addColorStop(0.0, '#014a84');
     gradient.addColorStop(0.5, '#0561a0');
@@ -79,7 +79,7 @@ async function init() {
 
     const size = 200;
 
-    const computeCloud = Fn(({ storageTexture }) => {
+    const computeCloud = Fn<{ storageTexture: THREE.Storage3DTexture }, void>(({ storageTexture }) => {
         const scale = float(0.05);
         const id = instanceIndex;
 
@@ -110,33 +110,40 @@ async function init() {
 
     // Shader
 
-    const transparentRaymarchingTexture = Fn(
-        ({ texture, range = float(0.14), threshold = float(0.08), opacity = float(0.18), steps = float(100) }) => {
-            const finalColor = vec4(0).toVar();
+    const transparentRaymarchingTexture = Fn<
+        {
+            texture: THREE.Texture3DNode;
+            range?: THREE.UniformNode<'float', number>;
+            threshold?: THREE.UniformNode<'float', number>;
+            opacity?: THREE.UniformNode<'float', number>;
+            steps?: THREE.UniformNode<'float', number>;
+        },
+        THREE.Node<'vec4'>
+    >(({ texture, range = float(0.14), threshold = float(0.08), opacity = float(0.18), steps = float(100) }) => {
+        const finalColor = vec4(0).toVar();
 
-            RaymarchingBox(steps, ({ positionRay }) => {
-                const mapValue = float(texture.sample(positionRay.add(0.5)).r).toVar();
+        RaymarchingBox(steps, ({ positionRay }) => {
+            const mapValue = float(texture.sample(positionRay.add(0.5)).r).toVar();
 
-                mapValue.assign(smoothstep(threshold.sub(range), threshold.add(range), mapValue).mul(opacity));
+            mapValue.assign(smoothstep(threshold.sub(range), threshold.add(range), mapValue).mul(opacity));
 
-                const shading = texture
-                    .sample(positionRay.add(vec3(-0.01)))
-                    .r.sub(texture.sample(positionRay.add(vec3(0.01))).r);
+            const shading = texture
+                .sample(positionRay.add(vec3(-0.01)))
+                .r.sub(texture.sample(positionRay.add(vec3(0.01))).r);
 
-                const col = shading.mul(4.0).add(positionRay.x.add(positionRay.y).mul(0.5)).add(0.3);
+            const col = shading.mul(4.0).add(positionRay.x.add(positionRay.y).mul(0.5)).add(0.3);
 
-                finalColor.rgb.addAssign(finalColor.a.oneMinus().mul(mapValue).mul(col));
+            finalColor.rgb.addAssign(finalColor.a.oneMinus().mul(mapValue).mul(col));
 
-                finalColor.a.addAssign(finalColor.a.oneMinus().mul(mapValue));
+            finalColor.a.addAssign(finalColor.a.oneMinus().mul(mapValue));
 
-                If(finalColor.a.greaterThanEqual(0.95), () => {
-                    Break();
-                });
+            If(finalColor.a.greaterThanEqual(0.95), () => {
+                Break();
             });
+        });
 
-            return finalColor;
-        },
-    );
+        return finalColor;
+    });
 
     // Material
 
@@ -171,7 +178,7 @@ async function init() {
 
     renderer.compute(computeNode);
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(threshold, 'value', 0, 1, 0.01).name('threshold');
     gui.add(opacity, 'value', 0, 1, 0.01).name('opacity');
     gui.add(range, 'value', 0, 1, 0.01).name('range');
diff --git a/examples-testing/examples/webgpu_compute_texture_pingpong.ts b/examples-testing/examples/webgpu_compute_texture_pingpong.ts
index 6aee0c755..a49ca05b9 100644
--- a/examples-testing/examples/webgpu_compute_texture_pingpong.ts
+++ b/examples-testing/examples/webgpu_compute_texture_pingpong.ts
@@ -3,10 +3,10 @@ import { storageTexture, wgslFn, code, instanceIndex, uniform, NodeAccess } from
 
 import WebGPU from 'three/addons/capabilities/WebGPU.js';
 
-let camera, scene, renderer;
-let computeInitNode, computeToPing, computeToPong;
-let pingTexture, pongTexture;
-let material;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let computeInitNode: THREE.ComputeNode, computeToPing: THREE.ComputeNode, computeToPong: THREE.ComputeNode;
+let pingTexture: THREE.StorageTexture, pongTexture: THREE.StorageTexture;
+let material: THREE.MeshBasicMaterial;
 let phase = true;
 let lastUpdate = -1;
 
diff --git a/examples-testing/examples/webgpu_cubemap_adjustments.ts b/examples-testing/examples/webgpu_cubemap_adjustments.ts
index 429d2ff40..3cffd2705 100644
--- a/examples-testing/examples/webgpu_cubemap_adjustments.ts
+++ b/examples-testing/examples/webgpu_cubemap_adjustments.ts
@@ -20,7 +20,7 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 init();
 
@@ -59,16 +59,16 @@ async function init() {
         saturation: 1,
     };
 
-    const mixNode = reference('mix', 'float', adjustments);
-    const proceduralNode = reference('procedural', 'float', adjustments);
-    const intensityNode = reference('intensity', 'float', adjustments);
-    const hueNode = reference('hue', 'float', adjustments);
-    const saturationNode = reference('saturation', 'float', adjustments);
+    const mixNode = reference<'float', typeof adjustments>('mix', 'float', adjustments);
+    const proceduralNode = reference<'float', typeof adjustments>('procedural', 'float', adjustments);
+    const intensityNode = reference<'float', typeof adjustments>('intensity', 'float', adjustments);
+    const hueNode = reference<'float', typeof adjustments>('hue', 'float', adjustments);
+    const saturationNode = reference<'float', typeof adjustments>('saturation', 'float', adjustments);
 
     const rotateY1Matrix = new THREE.Matrix4();
     const rotateY2Matrix = new THREE.Matrix4();
 
-    const getEnvironmentNode = (reflectNode, positionNode) => {
+    const getEnvironmentNode = (reflectNode: THREE.Node<'vec3'>, positionNode: THREE.Node<'vec3'>) => {
         const custom1UV = reflectNode.xyz.mul(uniform(rotateY1Matrix));
         const custom2UV = reflectNode.xyz.mul(uniform(rotateY2Matrix));
         const mixCubeMaps = mix(
@@ -134,7 +134,7 @@ async function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     gui.add({ blurBackground: blurNode.value }, 'blurBackground', 0, 1, 0.01).onChange(value => {
         blurNode.value = value;
diff --git a/examples-testing/examples/webgpu_cubemap_dynamic.ts b/examples-testing/examples/webgpu_cubemap_dynamic.ts
index f897b99ec..9b67fca97 100644
--- a/examples-testing/examples/webgpu_cubemap_dynamic.ts
+++ b/examples-testing/examples/webgpu_cubemap_dynamic.ts
@@ -4,12 +4,12 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
-let cube, sphere, torus, material;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let cube: THREE.Mesh, sphere: THREE.Mesh, torus: THREE.Mesh, material: THREE.MeshStandardNodeMaterial;
 
-let cubeCamera, cubeRenderTarget;
+let cubeCamera: THREE.CubeCamera, cubeRenderTarget: THREE.WebGLCubeRenderTarget;
 
-let controls;
+let controls: OrbitControls;
 
 init();
 
@@ -86,7 +86,7 @@ async function init() {
     controls = new OrbitControls(camera, renderer.domElement);
     controls.autoRotate = true;
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(material, 'roughness', 0, 1);
     gui.add(material, 'metalness', 0, 1);
     gui.add(renderer, 'toneMappingExposure', 0, 2).name('exposure');
@@ -101,7 +101,7 @@ function onWindowResized() {
     camera.updateProjectionMatrix();
 }
 
-function animation(msTime) {
+function animation(msTime: DOMHighResTimeStamp) {
     const time = msTime / 1000;
 
     cube.position.x = Math.cos(time) * 30;
diff --git a/examples-testing/examples/webgpu_cubemap_mix.ts b/examples-testing/examples/webgpu_cubemap_mix.ts
index 6fbdb55ae..fd5ec5705 100644
--- a/examples-testing/examples/webgpu_cubemap_mix.ts
+++ b/examples-testing/examples/webgpu_cubemap_mix.ts
@@ -8,7 +8,7 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_custom_fog.ts b/examples-testing/examples/webgpu_custom_fog.ts
index fcae79b96..0ce427a37 100644
--- a/examples-testing/examples/webgpu_custom_fog.ts
+++ b/examples-testing/examples/webgpu_custom_fog.ts
@@ -4,8 +4,8 @@ import { color, fog, float, positionWorld, triNoise3D, positionView, normalWorld
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let controls: OrbitControls;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_custom_fog_background.ts b/examples-testing/examples/webgpu_custom_fog_background.ts
index a5ff84131..b729718f7 100644
--- a/examples-testing/examples/webgpu_custom_fog_background.ts
+++ b/examples-testing/examples/webgpu_custom_fog_background.ts
@@ -6,8 +6,8 @@ import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let camera, scene, renderer;
-let postProcessing;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let postProcessing: THREE.PostProcessing;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_display_stereo.ts b/examples-testing/examples/webgpu_display_stereo.ts
index 90204a3d0..58e2ccffc 100644
--- a/examples-testing/examples/webgpu_display_stereo.ts
+++ b/examples-testing/examples/webgpu_display_stereo.ts
@@ -1,25 +1,28 @@
 import * as THREE from 'three/webgpu';
 
-import { stereoPass } from 'three/addons/tsl/display/StereoPassNode.js';
-import { anaglyphPass } from 'three/addons/tsl/display/AnaglyphPassNode.js';
-import { parallaxBarrierPass } from 'three/addons/tsl/display/ParallaxBarrierPassNode.js';
+import StereoPassNode, { stereoPass } from 'three/addons/tsl/display/StereoPassNode.js';
+import AnaglyphPassNode, { anaglyphPass } from 'three/addons/tsl/display/AnaglyphPassNode.js';
+import ParallaxBarrierPassNode, { parallaxBarrierPass } from 'three/addons/tsl/display/ParallaxBarrierPassNode.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, postProcessing;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    postProcessing: THREE.PostProcessing;
 
-let stereo, anaglyph, parallaxBarrier;
+let stereo: StereoPassNode, anaglyph: AnaglyphPassNode, parallaxBarrier: ParallaxBarrierPassNode;
 
-let mesh, dummy, timer;
+let mesh: THREE.InstancedMesh, dummy: THREE.Mesh, timer: THREE.Timer;
 
 const position = new THREE.Vector3();
 
-const params = {
+const params: { effect: 'stereo' | 'anaglyph' | 'parallaxBarrier'; eyeSep: number } = {
     effect: 'stereo',
     eyeSep: 0.064,
 };
 
-const effects = { Stereo: 'stereo', Anaglyph: 'anaglyph', ParallaxBarrier: 'parallaxBarrier' };
+const effects = { Stereo: 'stereo', Anaglyph: 'anaglyph', ParallaxBarrier: 'parallaxBarrier' } as const;
 
 init();
 
@@ -77,7 +80,7 @@ function init() {
 
     postProcessing.outputNode = stereo;
 
-    const gui = renderer.inspector.createParameters('Stereo Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Stereo Settings');
     gui.add(params, 'effect', effects).onChange(update);
     gui.add(params, 'eyeSep', 0.001, 0.15, 0.001).onChange(function (value) {
         stereo.stereo.eyeSep = value;
@@ -93,7 +96,7 @@ function init() {
     controls.maxDistance = 25;
 }
 
-function update(value) {
+function update(value: 'stereo' | 'anaglyph' | 'parallaxBarrier') {
     if (value === 'stereo') {
         postProcessing.outputNode = stereo;
     } else if (value === 'anaglyph') {
@@ -112,7 +115,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function extractPosition(matrix, position) {
+function extractPosition(matrix: THREE.Matrix4, position: THREE.Vector3) {
     position.x = matrix.elements[12];
     position.y = matrix.elements[13];
     position.z = matrix.elements[14];
diff --git a/examples-testing/examples/webgpu_equirectangular.ts b/examples-testing/examples/webgpu_equirectangular.ts
index 9e159e465..128e18b7b 100644
--- a/examples-testing/examples/webgpu_equirectangular.ts
+++ b/examples-testing/examples/webgpu_equirectangular.ts
@@ -4,8 +4,8 @@ import { texture, equirectUV } from 'three/tsl';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let controls: OrbitControls;
 
 init();
 
@@ -36,7 +36,7 @@ function init() {
 
     // GUI
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     gui.add(scene, 'backgroundIntensity', 0, 1).name('background intensity');
 
diff --git a/examples-testing/examples/webgpu_hdr.ts b/examples-testing/examples/webgpu_hdr.ts
index bb1dd4a15..44814fa58 100644
--- a/examples-testing/examples/webgpu_hdr.ts
+++ b/examples-testing/examples/webgpu_hdr.ts
@@ -17,7 +17,7 @@ const hdrMediaQuery = window.matchMedia('(dynamic-range: high)');
 
 function updateHDRWarning() {
     const displayIsHDR = hdrMediaQuery.matches;
-    document.querySelector('#no-hdr').style.display = displayIsHDR ? 'none' : '';
+    (document.querySelector('#no-hdr') as HTMLDivElement).style.display = displayIsHDR ? 'none' : '';
 }
 
 hdrMediaQuery.addEventListener('change', updateHDRWarning);
@@ -79,7 +79,7 @@ const brushMesh = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), brushMat);
 brushMesh.scale.set(300, 300, 1); // ~300px default brush size
 brushScene.add(brushMesh);
 
-function onPointerMove(e) {
+function onPointerMove(e: PointerEvent) {
     const rect = renderer.domElement.getBoundingClientRect();
     const x = e.clientX - rect.left;
     const y = e.clientY - rect.top;
@@ -96,7 +96,7 @@ renderer.domElement.addEventListener('touchmove', e => e.preventDefault(), { pas
 renderer.domElement.addEventListener('touchend', e => e.preventDefault(), { passive: false });
 
 // GUI setup
-const gui = renderer.inspector.createParameters('Settings');
+const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
 const colorFolder = gui.addFolder('HDR');
 colorFolder.add(params.intensity, 'value', 0, 10, 0.1).name('Intensity');
diff --git a/examples-testing/examples/webgpu_instance_mesh.ts b/examples-testing/examples/webgpu_instance_mesh.ts
index 0abd2f26c..30705fb0c 100644
--- a/examples-testing/examples/webgpu_instance_mesh.ts
+++ b/examples-testing/examples/webgpu_instance_mesh.ts
@@ -3,9 +3,9 @@ import { mix, range, normalWorld, oscSine, time } from 'three/tsl';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
-let mesh;
+let mesh: THREE.InstancedMesh;
 const amount = parseInt(window.location.search.slice(1)) || 10;
 const count = Math.pow(amount, 3);
 const dummy = new THREE.Object3D();
@@ -38,7 +38,7 @@ function init() {
 
         //
 
-        const gui = renderer.inspector.createParameters('Settings');
+        const gui = (renderer.inspector as Inspector).createParameters('Settings');
         gui.add(mesh, 'count', 1, count, 1).name('instance count');
     });
 
diff --git a/examples-testing/examples/webgpu_instance_path.ts b/examples-testing/examples/webgpu_instance_path.ts
index a5bce3225..8b2fa4ad7 100644
--- a/examples-testing/examples/webgpu_instance_path.ts
+++ b/examples-testing/examples/webgpu_instance_path.ts
@@ -19,7 +19,7 @@ import {
     color,
 } from 'three/tsl';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, controls: OrbitControls;
 
 const count = 1000;
 
@@ -63,14 +63,14 @@ async function init() {
     const v = new THREE.Vector3();
     const c = new THREE.Color();
 
-    const positions = [];
-    const times = [];
-    const seeds = [];
-    const colors = [];
+    const positions: number[] = [];
+    const times: number[] = [];
+    const seeds: number[] = [];
+    const colors: number[] = [];
 
     for (let i = 0; i < count; i++) {
         const t = i / count;
-        path.getPointAt(t, v);
+        path.getPointAt(t, v as unknown as THREE.Vector2);
 
         v.x += 0.5 - Math.random();
         v.y += 0.5 - Math.random();
@@ -92,10 +92,10 @@ async function init() {
 
     // TSL
 
-    const instancePosition = instancedBufferAttribute(positionAttribute);
-    const instanceColor = instancedBufferAttribute(colorAttribute);
-    const instanceSeed = instancedBufferAttribute(seedAttribute);
-    const instanceTime = instancedBufferAttribute(timeAttribute);
+    const instancePosition = instancedBufferAttribute<'vec3'>(positionAttribute);
+    const instanceColor = instancedBufferAttribute<'vec3'>(colorAttribute);
+    const instanceSeed = instancedBufferAttribute<'float'>(seedAttribute);
+    const instanceTime = instancedBufferAttribute<'float'>(timeAttribute);
 
     const localTime = instanceTime.add(time);
     const modTime = mod(time.mul(0.4), 1);
diff --git a/examples-testing/examples/webgpu_instance_points.ts b/examples-testing/examples/webgpu_instance_points.ts
index 409129373..d2ce322f4 100644
--- a/examples-testing/examples/webgpu_instance_points.ts
+++ b/examples-testing/examples/webgpu_instance_points.ts
@@ -19,16 +19,25 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 import * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';
 
-let renderer, scene, camera, camera2, controls, backgroundNode;
-let material;
-let effectController;
+let renderer: THREE.WebGPURenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    camera2: THREE.PerspectiveCamera,
+    controls: OrbitControls,
+    backgroundNode: THREE.Node;
+let material: THREE.PointsNodeMaterial;
+let effectController: {
+    pulseSpeed: THREE.UniformNode<'float', number>;
+    minWidth: THREE.UniformNode<'float', number>;
+    maxWidth: THREE.UniformNode<'float', number>;
+};
 
 // viewport
-let insetWidth;
-let insetHeight;
+let insetWidth: number;
+let insetHeight: number;
 
 // compute
-let computeSize;
+let computeSize: THREE.ComputeNode;
 
 init();
 
@@ -94,10 +103,10 @@ async function init() {
 
     // Material / Sprites
 
-    const attributeRange = instancedBufferAttribute(instanceSizeBufferAttribute);
+    const attributeRange = instancedBufferAttribute<'float'>(instanceSizeBufferAttribute);
     const pointColors = mix(
         vec3(0.0),
-        instancedBufferAttribute(colorsAttribute),
+        instancedBufferAttribute<'vec3'>(colorsAttribute),
         attributeRange.div(float(effectController.maxWidth)),
     );
 
@@ -136,7 +145,7 @@ async function init() {
 
     // GUI
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     gui.add(material, 'alphaToCoverage');
 
diff --git a/examples-testing/examples/webgpu_instancing_morph.ts b/examples-testing/examples/webgpu_instancing_morph.ts
index 5a554178b..dd9943ca3 100644
--- a/examples-testing/examples/webgpu_instancing_morph.ts
+++ b/examples-testing/examples/webgpu_instancing_morph.ts
@@ -3,7 +3,12 @@ import * as THREE from 'three/webgpu';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, mesh, mixer, dummy;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    mesh: THREE.InstancedMesh,
+    mixer: THREE.AnimationMixer,
+    dummy: THREE.Mesh;
 
 const offset = 5000;
 
@@ -66,7 +71,7 @@ function init() {
     const loader = new GLTFLoader();
 
     loader.load('models/gltf/Horse.glb', function (glb) {
-        dummy = glb.scene.children[0];
+        dummy = glb.scene.children[0] as THREE.Mesh;
 
         mesh = new THREE.InstancedMesh(
             dummy.geometry,
@@ -137,7 +142,7 @@ function animate() {
             mesh.setMorphAt(i, dummy);
         }
 
-        mesh.morphTexture.needsUpdate = true;
+        mesh.morphTexture!.needsUpdate = true;
     }
 
     renderer.render(scene, camera);
diff --git a/examples-testing/examples/webgpu_layers.ts b/examples-testing/examples/webgpu_layers.ts
index c1db7d60c..319d54e83 100644
--- a/examples-testing/examples/webgpu_layers.ts
+++ b/examples-testing/examples/webgpu_layers.ts
@@ -4,7 +4,7 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 import { positionLocal, time, mod, instancedBufferAttribute, rotate, screenUV, color, vec2 } from 'three/tsl';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 init();
 
@@ -54,7 +54,7 @@ function init() {
         Green: true,
     };
 
-    const gui = renderer.inspector.createParameters('Layers');
+    const gui = (renderer.inspector as Inspector).createParameters('Layers');
 
     gui.add(layers, 'Red').onChange(() => {
         camera.layers.toggle(0);
@@ -73,7 +73,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function getMaterial(count, color, sprite) {
+function getMaterial(count: number, color: number, sprite: THREE.Texture) {
     // instance data
 
     const positions = [];
@@ -117,11 +117,11 @@ function getMaterial(count, color, sprite) {
 
     // TSL
 
-    const instancePosition = instancedBufferAttribute(positionAttribute);
-    const instanceDirection = instancedBufferAttribute(directionAttribute);
-    const instanceRotation = instancedBufferAttribute(rotationAttribute);
+    const instancePosition = instancedBufferAttribute<'vec3'>(positionAttribute);
+    const instanceDirection = instancedBufferAttribute<'vec3'>(directionAttribute);
+    const instanceRotation = instancedBufferAttribute<'vec3'>(rotationAttribute);
 
-    const localTime = instancedBufferAttribute(timeAttribute).add(time.mul(0.02));
+    const localTime = instancedBufferAttribute<'float'>(timeAttribute).add(time.mul(0.02));
     const modTime = mod(localTime, 1.0);
 
     const rotatedPosition = rotate(positionLocal, instanceRotation.mul(modTime.mul(20)));
diff --git a/examples-testing/examples/webgpu_lensflares.ts b/examples-testing/examples/webgpu_lensflares.ts
index cfd67fdee..90af446b8 100644
--- a/examples-testing/examples/webgpu_lensflares.ts
+++ b/examples-testing/examples/webgpu_lensflares.ts
@@ -4,10 +4,10 @@ import { FlyControls } from 'three/addons/controls/FlyControls.js';
 import { LensflareMesh, LensflareElement } from 'three/addons/objects/LensflareMesh.js';
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let controls: FlyControls;
 
 const clock = new THREE.Clock();
 
@@ -72,7 +72,7 @@ function init() {
     addLight(0.1, 0.85, 0.65, 0, 0, -1000);
     addLight(0.995, 0.5, 0.95, 5000, 5000, -1000);
 
-    function addLight(h, s, l, x, y, z) {
+    function addLight(h: number, s: number, l: number, x: number, y: number, z: number) {
         const light = new THREE.PointLight(0xffffff, 1.5, 2000, 0);
         light.color.setHSL(h, s, l);
         light.position.set(x, y, z);
diff --git a/examples-testing/examples/webgpu_lightprobe.ts b/examples-testing/examples/webgpu_lightprobe.ts
index 3e90b6f66..342083547 100644
--- a/examples-testing/examples/webgpu_lightprobe.ts
+++ b/examples-testing/examples/webgpu_lightprobe.ts
@@ -1,6 +1,7 @@
 import * as THREE from 'three/webgpu';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
+import { ParametersGroup } from 'three/addons/inspector/tabs/Parameters.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
@@ -8,12 +9,15 @@ import { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js'
 
 import { LightProbeHelper } from 'three/addons/helpers/LightProbeHelperGPU.js';
 
-let mesh, renderer, scene, camera;
+let mesh: THREE.Mesh<THREE.SphereGeometry, THREE.MeshStandardMaterial>,
+    renderer: THREE.WebGPURenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera;
 
-let gui;
+let gui: ParametersGroup;
 
-let lightProbe;
-let directionalLight;
+let lightProbe: THREE.LightProbe;
+let directionalLight: THREE.DirectionalLight;
 
 // linear color space
 const API = {
@@ -59,7 +63,7 @@ function init() {
     scene.add(directionalLight);
 
     // envmap
-    const genCubeUrls = function (prefix, postfix) {
+    const genCubeUrls = function (prefix: string, postfix: string) {
         return [
             prefix + 'px' + postfix,
             prefix + 'nx' + postfix,
@@ -100,7 +104,7 @@ function init() {
     });
 
     // gui
-    gui = renderer.inspector.createParameters('Intensity');
+    gui = (renderer.inspector as Inspector).createParameters('Intensity');
 
     gui.add(API, 'lightProbeIntensity', 0, 1, 0.02)
         .name('light probe')
diff --git a/examples-testing/examples/webgpu_lightprobe_cubecamera.ts b/examples-testing/examples/webgpu_lightprobe_cubecamera.ts
index 5ea520a5d..839ff0fc3 100644
--- a/examples-testing/examples/webgpu_lightprobe_cubecamera.ts
+++ b/examples-testing/examples/webgpu_lightprobe_cubecamera.ts
@@ -6,9 +6,9 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { LightProbeHelper } from 'three/addons/helpers/LightProbeHelperGPU.js';
 import { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js';
 
-let renderer, scene, camera, cubeCamera;
+let renderer: THREE.WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, cubeCamera: THREE.CubeCamera;
 
-let lightProbe;
+let lightProbe: THREE.LightProbe;
 
 init();
 
@@ -43,7 +43,7 @@ function init() {
     scene.add(lightProbe);
 
     // envmap
-    const genCubeUrls = function (prefix, postfix) {
+    const genCubeUrls = function (prefix: string, postfix: string) {
         return [
             prefix + 'px' + postfix,
             prefix + 'nx' + postfix,
diff --git a/examples-testing/examples/webgpu_lights_ies_spotlight.ts b/examples-testing/examples/webgpu_lights_ies_spotlight.ts
index edfc51efa..d3f6e3779 100644
--- a/examples-testing/examples/webgpu_lights_ies_spotlight.ts
+++ b/examples-testing/examples/webgpu_lights_ies_spotlight.ts
@@ -1,13 +1,13 @@
 import * as THREE from 'three/webgpu';
 
-import { OrbitControls } from './jsm/controls/OrbitControls.js';
+import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import { IESLoader } from 'three/addons/loaders/IESLoader.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let renderer, scene, camera;
-let lights;
+let renderer: THREE.WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let lights: THREE.IESSpotLight[];
 
 async function init() {
     const iesLoader = new IESLoader().setPath('./ies/');
@@ -123,7 +123,7 @@ async function init() {
 
     //
 
-    function setHelperVisible(value) {
+    function setHelperVisible(value: boolean) {
         for (let i = 0; i < lights.length; i++) {
             lights[i].userData.helper.visible = value;
         }
@@ -133,7 +133,7 @@ async function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add({ helper: false }, 'helper').onChange(v => setHelperVisible(v));
 
     //
@@ -148,7 +148,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function render(time) {
+function render(time: number) {
     time = time / 1000;
 
     for (let i = 0; i < lights.length; i++) {
diff --git a/examples-testing/examples/webgpu_lights_phong.ts b/examples-testing/examples/webgpu_lights_phong.ts
index c2cdf4393..64116a21b 100644
--- a/examples-testing/examples/webgpu_lights_phong.ts
+++ b/examples-testing/examples/webgpu_lights_phong.ts
@@ -6,7 +6,14 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';
 
-let camera, scene, renderer, light1, light2, light3, light4, controls;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    light1: THREE.PointLight,
+    light2: THREE.PointLight,
+    light3: THREE.PointLight,
+    light4: THREE.PointLight,
+    controls: OrbitControls;
 
 init();
 
@@ -33,7 +40,7 @@ function init() {
 
     // lights
 
-    const addLight = (hexColor, power = 1700, distance = 100) => {
+    const addLight = (hexColor: number, power = 1700, distance = 100) => {
         const material = new THREE.MeshPhongNodeMaterial();
         material.colorNode = color(hexColor);
         material.lights = false;
diff --git a/examples-testing/examples/webgpu_lights_physical.ts b/examples-testing/examples/webgpu_lights_physical.ts
index 43d7ce723..616ed8e6b 100644
--- a/examples-testing/examples/webgpu_lights_physical.ts
+++ b/examples-testing/examples/webgpu_lights_physical.ts
@@ -4,8 +4,13 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, bulbLight, bulbMat, hemiLight;
-let ballMat, cubeMat, floorMat;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    bulbLight: THREE.PointLight,
+    bulbMat: THREE.MeshStandardMaterial,
+    hemiLight: THREE.HemisphereLight;
+let ballMat: THREE.MeshStandardMaterial, cubeMat: THREE.MeshStandardMaterial, floorMat: THREE.MeshStandardMaterial;
 
 let previousShadowMap = false;
 
@@ -36,17 +41,22 @@ const hemiLuminousIrradiances = {
     '50000 lx (Direct Sun)': 50000,
 };
 
-const params = {
+const params: {
+    shadows: boolean;
+    exposure: number;
+    bulbPower: keyof typeof bulbLuminousPowers;
+    hemiIrradiance: keyof typeof hemiLuminousIrradiances;
+} = {
     shadows: true,
     exposure: 0.68,
-    bulbPower: Object.keys(bulbLuminousPowers)[4],
-    hemiIrradiance: Object.keys(hemiLuminousIrradiances)[0],
+    bulbPower: Object.keys(bulbLuminousPowers)[4] as keyof typeof bulbLuminousPowers,
+    hemiIrradiance: Object.keys(hemiLuminousIrradiances)[0] as keyof typeof hemiLuminousIrradiances,
 };
 
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     //
 
@@ -196,9 +206,9 @@ function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Settings');
-    gui.add(params, 'hemiIrradiance', Object.keys(hemiLuminousIrradiances));
-    gui.add(params, 'bulbPower', Object.keys(bulbLuminousPowers));
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
+    gui.add(params, 'hemiIrradiance', Object.keys(hemiLuminousIrradiances) as (keyof typeof hemiLuminousIrradiances)[]);
+    gui.add(params, 'bulbPower', Object.keys(bulbLuminousPowers) as (keyof typeof bulbLuminousPowers)[]);
     gui.add(params, 'exposure', 0, 1);
     gui.add(params, 'shadows');
 }
diff --git a/examples-testing/examples/webgpu_lights_pointlights.ts b/examples-testing/examples/webgpu_lights_pointlights.ts
index e00d75b21..c0d16ef13 100644
--- a/examples-testing/examples/webgpu_lights_pointlights.ts
+++ b/examples-testing/examples/webgpu_lights_pointlights.ts
@@ -16,9 +16,13 @@ import {
     uniform,
 } from 'three/tsl';
 
-let camera, scene, timer, renderer, controls;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    timer: THREE.Timer,
+    renderer: THREE.WebGPURenderer,
+    controls: OrbitControls;
 
-let light1, light2;
+let light1: THREE.PointLight, light2: THREE.PointLight;
 
 init();
 
@@ -35,7 +39,7 @@ function init() {
 
     const loader = new OBJLoader();
     loader.load('models/obj/walt/WaltHead.obj', function (obj) {
-        const mesh = obj.children[0];
+        const mesh = obj.children[0] as THREE.Mesh;
         mesh.geometry = createGeometry(mesh.geometry);
         mesh.material = createMaterial();
 
@@ -102,10 +106,10 @@ function animate() {
 function createMaterial() {
     const material = new THREE.MeshPhongNodeMaterial();
 
-    const seedAttribute = attribute('seed');
-    const displaceNormalAttribute = attribute('displaceNormal');
+    const seedAttribute = attribute<'float'>('seed');
+    const displaceNormalAttribute = attribute<'vec3'>('displaceNormal');
 
-    const localTime = attribute('time').add(time);
+    const localTime = attribute<'float'>('time').add(time);
 
     const effector1 = uniform(light1.position).toVar();
     const effector2 = uniform(light2.position).toVar();
@@ -125,7 +129,7 @@ function createMaterial() {
     return material;
 }
 
-function createGeometry(geometry) {
+function createGeometry(geometry: THREE.BufferGeometry) {
     const positionAttribute = geometry.getAttribute('position');
 
     const v0 = new THREE.Vector3();
diff --git a/examples-testing/examples/webgpu_lights_rectarealight.ts b/examples-testing/examples/webgpu_lights_rectarealight.ts
index ecb1ec0df..2268ab867 100644
--- a/examples-testing/examples/webgpu_lights_rectarealight.ts
+++ b/examples-testing/examples/webgpu_lights_rectarealight.ts
@@ -6,8 +6,8 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';
 import { RectAreaLightTexturesLib } from 'three/addons/lights/RectAreaLightTexturesLib.js';
 
-let renderer, scene, camera;
-let meshKnot;
+let renderer: THREE.WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let meshKnot: THREE.Mesh;
 
 init();
 
@@ -68,7 +68,7 @@ function onWindowResize() {
     camera.updateProjectionMatrix();
 }
 
-function animation(time) {
+function animation(time: number) {
     meshKnot.rotation.y = time / 1000;
 
     renderer.render(scene, camera);
diff --git a/examples-testing/examples/webgpu_lights_selective.ts b/examples-testing/examples/webgpu_lights_selective.ts
index d00048347..54f94948b 100644
--- a/examples-testing/examples/webgpu_lights_selective.ts
+++ b/examples-testing/examples/webgpu_lights_selective.ts
@@ -6,7 +6,14 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';
 
-let camera, scene, renderer, light1, light2, light3, light4, controls;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    light1: THREE.PointLight,
+    light2: THREE.PointLight,
+    light3: THREE.PointLight,
+    light4: THREE.PointLight,
+    controls: OrbitControls;
 
 init();
 
@@ -33,7 +40,7 @@ function init() {
 
     // lights
 
-    const addLight = (hexColor, power = 1700, distance = 100) => {
+    const addLight = (hexColor: number, power = 1700, distance = 100) => {
         const material = new THREE.MeshStandardNodeMaterial();
         material.colorNode = color(hexColor);
         material.lights = false;
@@ -106,7 +113,7 @@ function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Material');
+    const gui = (renderer.inspector as Inspector).createParameters('Material');
 
     gui.add(centerObject.material, 'roughness', 0, 1, 0.01);
     gui.add(centerObject.material, 'metalness', 0, 1, 0.01);
diff --git a/examples-testing/examples/webgpu_lights_spotlight.ts b/examples-testing/examples/webgpu_lights_spotlight.ts
index db2de8891..0a91b1a14 100644
--- a/examples-testing/examples/webgpu_lights_spotlight.ts
+++ b/examples-testing/examples/webgpu_lights_spotlight.ts
@@ -5,9 +5,9 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let renderer, scene, camera;
+let renderer: THREE.WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
 
-let spotLight;
+let spotLight: THREE.SpotLight & { lightHelper?: THREE.SpotLightHelper; shadowCameraHelper?: THREE.CameraHelper };
 
 init();
 
@@ -47,7 +47,7 @@ function init() {
     const loader = new THREE.TextureLoader().setPath('textures/');
     const filenames = ['disturb.jpg', 'colors.png', 'uv_grid_opengl.jpg'];
 
-    const textures = { none: null };
+    const textures: { [filename: string]: THREE.Texture | null } = { none: null };
 
     for (let i = 0; i < filenames.length; i++) {
         const filename = filenames[i];
@@ -126,7 +126,7 @@ function init() {
 
     // GUI
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     const params = {
         map: textures['disturb.jpg'],
@@ -178,8 +178,8 @@ function init() {
     });
 
     gui.add(params, 'helpers').onChange(function (val) {
-        spotLight.lightHelper.visible = val;
-        spotLight.shadowCameraHelper.visible = val;
+        spotLight.lightHelper!.visible = val;
+        spotLight.shadowCameraHelper!.visible = val;
     });
 }
 
@@ -196,7 +196,7 @@ function animate() {
     spotLight.position.x = Math.cos(time) * 2.5;
     spotLight.position.z = Math.sin(time) * 2.5;
 
-    spotLight.lightHelper.update();
+    spotLight.lightHelper!.update();
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgpu_lights_tiled.ts b/examples-testing/examples/webgpu_lights_tiled.ts
index c30e0bb55..5c950c94b 100644
--- a/examples-testing/examples/webgpu_lights_tiled.ts
+++ b/examples-testing/examples/webgpu_lights_tiled.ts
@@ -3,6 +3,7 @@ import { texture, uv, pass, normalMap, uniform } from 'three/tsl';
 import { bloom } from 'three/addons/tsl/display/BloomNode.js';
 
 import { TiledLighting } from 'three/addons/lighting/TiledLighting.js';
+import TiledLightsNode from 'three/addons/tsl/lighting/TiledLightsNode.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
@@ -10,7 +11,17 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import WebGPU from 'three/addons/capabilities/WebGPU.js';
 
-let camera, scene, renderer, lights, lightDummy, controls, compose, tileInfluence, lighting, count, postProcessing;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    lights: THREE.Group,
+    lightDummy: THREE.InstancedMesh,
+    controls: OrbitControls,
+    compose: THREE.Node<'vec4'>,
+    tileInfluence: THREE.UniformNode<'float', number>,
+    lighting: TiledLighting,
+    count: number,
+    postProcessing: THREE.PostProcessing;
 
 init();
 
@@ -42,7 +53,7 @@ function init() {
     lights = new THREE.Group();
     scene.add(lights);
 
-    const addLight = (hexColor, power = 10, distance = 3) => {
+    const addLight = (hexColor: THREE.ColorRepresentation, power = 10, distance = 3) => {
         const light = new THREE.PointLight(hexColor, 1, distance);
         light.position.set(Math.random() * 300 - 150, 1, Math.random() * 300 - 150);
         light.power = power;
@@ -134,15 +145,14 @@ function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(tileInfluence, 'value', 0, 1).name('tile indexes debug');
 }
 
 function updatePostProcessing() {
     // tile indexes debug, needs to be updated every time the renderer size changes
 
-    const debugBlockIndexes = lighting
-        .getNode(scene, camera)
+    const debugBlockIndexes = (lighting.getNode(scene, camera) as TiledLightsNode)
         .setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio)
         .getBlock()
         .toColor()
diff --git a/examples-testing/examples/webgpu_lines_fat.ts b/examples-testing/examples/webgpu_lines_fat.ts
index 96417888c..2ec8e8b1f 100644
--- a/examples-testing/examples/webgpu_lines_fat.ts
+++ b/examples-testing/examples/webgpu_lines_fat.ts
@@ -9,15 +9,23 @@ import { Line2 } from 'three/addons/lines/webgpu/Line2.js';
 import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
 import * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';
 
-let line, renderer, scene, camera, camera2, controls, backgroundNode;
-let line1;
-let matLine, matLineBasic, matLineDashed;
-let stats;
-let gui;
+let line: Line2,
+    renderer: THREE.WebGPURenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    camera2: THREE.PerspectiveCamera,
+    controls: OrbitControls,
+    backgroundNode: THREE.Node;
+let line1: THREE.Line;
+let matLine: THREE.Line2NodeMaterial,
+    matLineBasic: THREE.LineBasicNodeMaterial,
+    matLineDashed: THREE.LineDashedNodeMaterial;
+let stats: Stats;
+let gui: GUI;
 
 // viewport
-let insetWidth;
-let insetHeight;
+let insetWidth: number;
+let insetHeight: number;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_lines_fat_raycasting.ts b/examples-testing/examples/webgpu_lines_fat_raycasting.ts
index 8ab71af1b..692aa233e 100644
--- a/examples-testing/examples/webgpu_lines_fat_raycasting.ts
+++ b/examples-testing/examples/webgpu_lines_fat_raycasting.ts
@@ -1,6 +1,7 @@
 import * as THREE from 'three/webgpu';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
+import { ParametersGroup } from 'three/addons/inspector/tabs/Parameters.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { LineSegments2 } from 'three/addons/lines/webgpu/LineSegments2.js';
@@ -10,11 +11,12 @@ import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
 
 //
 
-let line, thresholdLine, segments, thresholdSegments;
-let renderer, scene, camera, controls;
-let sphereInter, sphereOnLine;
-let gui;
-let clock;
+let line: Line2, thresholdLine: Line2, segments: LineSegments2, thresholdSegments: LineSegments2;
+let renderer: THREE.WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
+let sphereInter: THREE.Mesh<THREE.SphereGeometry, THREE.MeshBasicMaterial>,
+    sphereOnLine: THREE.Mesh<THREE.SphereGeometry, THREE.MeshBasicMaterial>;
+let gui: ParametersGroup;
+let clock: THREE.Clock;
 
 const color = new THREE.Color();
 
@@ -22,8 +24,8 @@ const pointer = new THREE.Vector2(Infinity, Infinity);
 
 const raycaster = new THREE.Raycaster();
 
-raycaster.params.Line2 = {};
-raycaster.params.Line2.threshold = 0;
+raycaster.params.Line2 = {} as typeof raycaster.params.Line2;
+raycaster.params.Line2!.threshold = 0;
 
 const matLine = new THREE.Line2NodeMaterial({
     color: 0xffffff,
@@ -51,7 +53,7 @@ const params = {
     'visualize threshold': matThresholdLine.visible,
     width: matLine.linewidth,
     alphaToCoverage: matLine.alphaToCoverage,
-    threshold: raycaster.params.Line2.threshold,
+    threshold: raycaster.params.Line2!.threshold,
     translation: 0,
     animate: true,
 };
@@ -168,7 +170,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -197,9 +199,9 @@ async function animate() {
         sphereOnLine.visible = true;
 
         sphereInter.position.copy(intersects[0].point);
-        sphereOnLine.position.copy(intersects[0].pointOnLine);
+        sphereOnLine.position.copy(intersects[0].pointOnLine!);
 
-        const index = intersects[0].faceIndex;
+        const index = intersects[0].faceIndex!;
         const colors = obj.geometry.getAttribute('instanceColorStart');
 
         color.fromBufferAttribute(colors, index);
@@ -219,7 +221,7 @@ async function animate() {
 
 //
 
-function switchLine(val) {
+function switchLine(val: number) {
     switch (val) {
         case 0:
             line.visible = true;
@@ -242,7 +244,7 @@ function switchLine(val) {
 }
 
 function initGui() {
-    gui = renderer.inspector.createParameters('Settings');
+    gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     gui.add(params, 'line type', { LineGeometry: 0, LineSegmentsGeometry: 1 }).onChange(function (val) {
         switchLine(val);
@@ -262,7 +264,7 @@ function initGui() {
 
     gui.add(params, 'width', 1, 10).onChange(function (val) {
         matLine.linewidth = val;
-        matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2.threshold;
+        matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2!.threshold;
     });
 
     gui.add(params, 'alphaToCoverage').onChange(function (val) {
@@ -270,8 +272,8 @@ function initGui() {
     });
 
     gui.add(params, 'threshold', 0, 10).onChange(function (val) {
-        raycaster.params.Line2.threshold = val;
-        matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2.threshold;
+        raycaster.params.Line2!.threshold = val;
+        matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2!.threshold;
     });
 
     gui.add(params, 'translation', 0, 10).onChange(function (val) {
diff --git a/examples-testing/examples/webgpu_lines_fat_wireframe.ts b/examples-testing/examples/webgpu_lines_fat_wireframe.ts
index 9ab5c44c0..dee04a5ae 100644
--- a/examples-testing/examples/webgpu_lines_fat_wireframe.ts
+++ b/examples-testing/examples/webgpu_lines_fat_wireframe.ts
@@ -2,19 +2,26 @@ import * as THREE from 'three/webgpu';
 import { color } from 'three/tsl';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
+import { ParametersGroup } from 'three/addons/inspector/tabs/Parameters.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Wireframe } from 'three/addons/lines/webgpu/Wireframe.js';
 import { WireframeGeometry2 } from 'three/addons/lines/WireframeGeometry2.js';
 
-let wireframe, renderer, scene, camera, camera2, controls, backgroundNode;
-let wireframe1;
-let matLine, matLineBasic, matLineDashed;
-let gui;
+let wireframe: Wireframe,
+    renderer: THREE.WebGPURenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    camera2: THREE.PerspectiveCamera,
+    controls: OrbitControls,
+    backgroundNode: THREE.Node;
+let wireframe1: THREE.LineSegments;
+let matLine: THREE.Line2NodeMaterial, matLineBasic: THREE.LineBasicMaterial, matLineDashed: THREE.LineDashedMaterial;
+let gui: ParametersGroup;
 
 // viewport
-let insetWidth;
-let insetHeight;
+let insetWidth: number;
+let insetHeight: number;
 
 init();
 
@@ -43,7 +50,7 @@ function init() {
 
     // Wireframe ( WireframeGeometry2, Line2NodeMaterial )
 
-    let geo = new THREE.IcosahedronGeometry(20, 1);
+    let geo: THREE.BufferGeometry = new THREE.IcosahedronGeometry(20, 1);
 
     const geometry = new WireframeGeometry2(geo);
 
@@ -135,7 +142,7 @@ function animate() {
 //
 
 function initGui() {
-    gui = renderer.inspector.createParameters('Settings');
+    gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     const param = {
         'line type': 0,
diff --git a/examples-testing/examples/webgpu_loader_gltf.ts b/examples-testing/examples/webgpu_loader_gltf.ts
index 0389e5bdc..a6f6647d2 100644
--- a/examples-testing/examples/webgpu_loader_gltf.ts
+++ b/examples-testing/examples/webgpu_loader_gltf.ts
@@ -5,7 +5,7 @@ import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 init().then(render);
 
diff --git a/examples-testing/examples/webgpu_loader_gltf_anisotropy.ts b/examples-testing/examples/webgpu_loader_gltf_anisotropy.ts
index dfb0e964a..0308a517d 100644
--- a/examples-testing/examples/webgpu_loader_gltf_anisotropy.ts
+++ b/examples-testing/examples/webgpu_loader_gltf_anisotropy.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
-let renderer, scene, camera, controls;
+let renderer: THREE.WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_loader_gltf_compressed.ts b/examples-testing/examples/webgpu_loader_gltf_compressed.ts
index 31d5d0d1a..8a2e68da5 100644
--- a/examples-testing/examples/webgpu_loader_gltf_compressed.ts
+++ b/examples-testing/examples/webgpu_loader_gltf_compressed.ts
@@ -6,7 +6,7 @@ import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_loader_gltf_dispersion.ts b/examples-testing/examples/webgpu_loader_gltf_dispersion.ts
index a2e815ddb..25b08c750 100644
--- a/examples-testing/examples/webgpu_loader_gltf_dispersion.ts
+++ b/examples-testing/examples/webgpu_loader_gltf_dispersion.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_loader_gltf_iridescence.ts b/examples-testing/examples/webgpu_loader_gltf_iridescence.ts
index 8007d5e65..dc83ae61c 100644
--- a/examples-testing/examples/webgpu_loader_gltf_iridescence.ts
+++ b/examples-testing/examples/webgpu_loader_gltf_iridescence.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
-let renderer, scene, camera, controls;
+let renderer: THREE.WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
 
 init().catch(function (err) {
     console.error(err);
diff --git a/examples-testing/examples/webgpu_loader_gltf_sheen.ts b/examples-testing/examples/webgpu_loader_gltf_sheen.ts
index 444a3b4f4..6f440d8a5 100644
--- a/examples-testing/examples/webgpu_loader_gltf_sheen.ts
+++ b/examples-testing/examples/webgpu_loader_gltf_sheen.ts
@@ -6,7 +6,7 @@ import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, controls: OrbitControls;
 
 init();
 
@@ -25,9 +25,12 @@ function init() {
     new GLTFLoader().setPath('models/gltf/').load('SheenChair.glb', function (gltf) {
         scene.add(gltf.scene);
 
-        const object = gltf.scene.getObjectByName('SheenChair_fabric');
+        const object = gltf.scene.getObjectByName('SheenChair_fabric') as THREE.Mesh<
+            THREE.BufferGeometry,
+            THREE.MeshPhysicalMaterial
+        >;
 
-        const gui = renderer.inspector.createParameters('SheenChair_fabric');
+        const gui = (renderer.inspector as Inspector).createParameters('SheenChair_fabric');
 
         gui.add(object.material, 'sheen', 0, 1);
     });
diff --git a/examples-testing/examples/webgpu_loader_gltf_transmission.ts b/examples-testing/examples/webgpu_loader_gltf_transmission.ts
index f32ae7822..33f9d163d 100644
--- a/examples-testing/examples/webgpu_loader_gltf_transmission.ts
+++ b/examples-testing/examples/webgpu_loader_gltf_transmission.ts
@@ -6,7 +6,12 @@ import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 
-let camera, scene, renderer, controls, clock, mixer;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    controls: OrbitControls,
+    clock: THREE.Clock,
+    mixer: THREE.AnimationMixer;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_loader_materialx.ts b/examples-testing/examples/webgpu_loader_materialx.ts
index 4dde35617..03e6d92ad 100644
--- a/examples-testing/examples/webgpu_loader_materialx.ts
+++ b/examples-testing/examples/webgpu_loader_materialx.ts
@@ -61,9 +61,9 @@ const localSamples = [
     'sheen_test.mtlx',
 ];
 
-let camera, scene, renderer;
-let controls, prefab;
-const models = [];
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let controls: OrbitControls, prefab: THREE.Group;
+const models: THREE.Group[] = [];
 
 init();
 
@@ -90,29 +90,33 @@ function init() {
 
     const material = new THREE.MeshBasicNodeMaterial();
 
-    const gridXZ = Fn(([gridSize = float(1.0), dotWidth = float(0.1), lineWidth = float(0.02)]) => {
-        const coord = positionWorld.xz.div(gridSize);
-        const grid = fract(coord);
+    const gridXZ = Fn<[THREE.Node<'float'>, THREE.Node<'float'>, THREE.Node<'float'>], THREE.Node<'float'>>(
+        ([gridSize = float(1.0), dotWidth = float(0.1), lineWidth = float(0.02)]) => {
+            const coord = positionWorld.xz.div(gridSize);
+            const grid = fract(coord);
 
-        // Screen-space derivative for automatic antialiasing
-        const fw = fwidth(coord);
-        const smoothing = max(fw.x, fw.y).mul(0.5);
+            // Screen-space derivative for automatic antialiasing
+            const fw = fwidth(coord);
+            const smoothing = max(fw.x, fw.y).mul(0.5);
 
-        // Create squares at cell centers
-        const squareDist = max(abs(grid.x.sub(0.5)), abs(grid.y.sub(0.5)));
-        const dots = smoothstep(dotWidth.add(smoothing), dotWidth.sub(smoothing), squareDist);
+            // Create squares at cell centers
+            const squareDist = max(abs(grid.x.sub(0.5)), abs(grid.y.sub(0.5)));
+            const dots = smoothstep(dotWidth.add(smoothing), dotWidth.sub(smoothing), squareDist);
 
-        // Create grid lines
-        const lineX = smoothstep(lineWidth.add(smoothing), lineWidth.sub(smoothing), abs(grid.x.sub(0.5)));
-        const lineZ = smoothstep(lineWidth.add(smoothing), lineWidth.sub(smoothing), abs(grid.y.sub(0.5)));
-        const lines = max(lineX, lineZ);
+            // Create grid lines
+            const lineX = smoothstep(lineWidth.add(smoothing), lineWidth.sub(smoothing), abs(grid.x.sub(0.5)));
+            const lineZ = smoothstep(lineWidth.add(smoothing), lineWidth.sub(smoothing), abs(grid.y.sub(0.5)));
+            const lines = max(lineX, lineZ);
 
-        return max(dots, lines);
-    });
+            return max(dots, lines);
+        },
+    );
 
-    const radialGradient = Fn(([radius = float(10.0), falloff = float(1.0)]) => {
-        return smoothstep(radius, radius.sub(falloff), length(positionWorld));
-    });
+    const radialGradient = Fn<[THREE.Node<'float'>, THREE.Node<'float'>], THREE.Node<'float'>>(
+        ([radius = float(10.0), falloff = float(1.0)]) => {
+            return smoothstep(radius, radius.sub(falloff), length(positionWorld));
+        },
+    );
 
     // Create grid pattern
     const gridPattern = gridXZ(1.0, 0.03, 0.005);
@@ -177,7 +181,7 @@ function updateModelsAlign() {
     }
 }
 
-async function addSample(sample, path) {
+async function addSample(sample: string, path: string) {
     const model = prefab.clone();
 
     models.push(model);
@@ -191,12 +195,12 @@ async function addSample(sample, path) {
     const material = await new MaterialXLoader()
         .setPath(path)
         .loadAsync(sample)
-        .then(({ materials }) => Object.values(materials).pop());
+        .then(({ materials }) => Object.values(materials).pop()!);
 
-    const calibrationMesh = model.getObjectByName('Calibration_Mesh');
+    const calibrationMesh = model.getObjectByName('Calibration_Mesh') as THREE.Mesh;
     calibrationMesh.material = material;
 
-    const previewMesh = model.getObjectByName('Preview_Mesh');
+    const previewMesh = model.getObjectByName('Preview_Mesh') as THREE.Mesh;
     previewMesh.material = material;
 
     if (material.transparent) {
@@ -206,7 +210,7 @@ async function addSample(sample, path) {
 }
 
 function addGUI() {
-    const gui = renderer.inspector.createParameters('MaterialX Loader');
+    const gui = (renderer.inspector as Inspector).createParameters('MaterialX Loader');
 
     const API = {
         showCalibrationMesh: true,
@@ -226,9 +230,9 @@ function addGUI() {
         });
 }
 
-function setVisibility(name, visible) {
+function setVisibility(name: string, visible: boolean) {
     scene.traverse(function (node) {
-        if (node.isMesh) {
+        if ((node as THREE.Mesh).isMesh) {
             if (node.name == name) node.visible = visible;
         }
     });
diff --git a/examples-testing/examples/webgpu_loader_texture_ktx2.ts b/examples-testing/examples/webgpu_loader_texture_ktx2.ts
index 1daf0f032..ee2cb370b 100644
--- a/examples-testing/examples/webgpu_loader_texture_ktx2.ts
+++ b/examples-testing/examples/webgpu_loader_texture_ktx2.ts
@@ -1,12 +1,18 @@
-import * as THREE from 'three';
+import * as THREE from 'three/webgpu';
 
 import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
 
-let canvas, renderer;
+let canvas: HTMLCanvasElement, renderer: THREE.WebGPURenderer;
 
-const scenes = [];
+const scenes: THREE.Scene[] = [];
 
-const sections = [
+interface Section {
+    title: string;
+    description: string;
+    textures: { path: string; supported?: boolean }[];
+}
+
+const sections: Section[] = [
     {
         title: 'Uncompressed',
         description:
@@ -52,7 +58,7 @@ const sections = [
 init();
 
 async function init() {
-    canvas = document.getElementById('c');
+    canvas = document.getElementById('c') as HTMLCanvasElement;
 
     renderer = new THREE.WebGPURenderer({ canvas, antialias: true, forceWebGL: false });
     renderer.setClearColor(0xffffff, 1);
@@ -67,7 +73,7 @@ async function init() {
 
     const geometry = flipY(new THREE.PlaneGeometry(1, 1));
 
-    const content = document.getElementById('content');
+    const content = document.getElementById('content')!;
 
     for (const section of sections) {
         const sectionElement = document.createElement('section');
@@ -133,7 +139,7 @@ function updateSize() {
 
 // Rewrite UVs for `flipY=false` textures.
 
-function flipY(geometry) {
+function flipY(geometry: THREE.PlaneGeometry) {
     const uv = geometry.attributes.uv;
 
     for (let i = 0; i < uv.count; i++) {
diff --git a/examples-testing/examples/webgpu_materials_alphahash.ts b/examples-testing/examples/webgpu_materials_alphahash.ts
index 12c014ac0..5052d8825 100644
--- a/examples-testing/examples/webgpu_materials_alphahash.ts
+++ b/examples-testing/examples/webgpu_materials_alphahash.ts
@@ -7,7 +7,13 @@ import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
 
 import { ssaaPass } from 'three/addons/tsl/display/SSAAPassNode.js';
 
-let camera, scene, renderer, controls, mesh, material, postProcessing;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    controls: OrbitControls,
+    mesh: THREE.InstancedMesh,
+    material: THREE.MeshStandardMaterial,
+    postProcessing: THREE.PostProcessing;
 
 const amount = parseInt(window.location.search.slice(1)) || 3;
 const count = Math.pow(amount, 3);
@@ -95,7 +101,7 @@ async function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
 
     gui.add(params, 'alpha', 0, 1).onChange(onMaterialUpdate);
     gui.add(params, 'alphaHash').onChange(onMaterialUpdate);
diff --git a/examples-testing/examples/webgpu_materials_arrays.ts b/examples-testing/examples/webgpu_materials_arrays.ts
index e6d15853e..154e3803c 100644
--- a/examples-testing/examples/webgpu_materials_arrays.ts
+++ b/examples-testing/examples/webgpu_materials_arrays.ts
@@ -4,9 +4,9 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let renderer, scene, camera, controls;
-let planeMesh, boxMesh, boxMeshWireframe, planeMeshWireframe;
-let materials;
+let renderer: THREE.WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
+let planeMesh: THREE.Mesh, boxMesh: THREE.Mesh, boxMeshWireframe: THREE.Mesh, planeMeshWireframe: THREE.Mesh;
+let materials: THREE.MeshBasicMaterial[];
 
 const api = {
     webgpu: true,
@@ -114,7 +114,7 @@ function animate() {
 
 // gui
 
-const gui = renderer.inspector.createParameters('Parameters');
+const gui = (renderer!.inspector as Inspector).createParameters('Parameters');
 
 gui.add(api, 'webgpu').onChange(() => {
     init(!api.webgpu);
diff --git a/examples-testing/examples/webgpu_materials_basic.ts b/examples-testing/examples/webgpu_materials_basic.ts
index 6aca76c97..fe08f13b4 100644
--- a/examples-testing/examples/webgpu_materials_basic.ts
+++ b/examples-testing/examples/webgpu_materials_basic.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three/webgpu';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
 let mouseX = 0;
 let mouseY = 0;
@@ -12,7 +12,13 @@ let mouseY = 0;
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
 
-const params = {
+const params: {
+    color: string;
+    mapping: THREE.CubeTextureMapping;
+    refractionRatio: number;
+    transparent: boolean;
+    opacity: number;
+} = {
     color: '#ffffff',
     mapping: THREE.CubeReflectionMapping,
     refractionRatio: 0.98,
@@ -74,7 +80,7 @@ function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
 
     gui.addColor(params, 'color').onChange(value => material.color.set(value));
     gui.add(params, 'mapping', mappings).onChange(value => {
@@ -103,7 +109,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) / 100;
     mouseY = (event.clientY - windowHalfY) / 100;
 }
diff --git a/examples-testing/examples/webgpu_materials_cubemap_mipmaps.ts b/examples-testing/examples/webgpu_materials_cubemap_mipmaps.ts
index 6c66f9d35..ccc9cd5ec 100644
--- a/examples-testing/examples/webgpu_materials_cubemap_mipmaps.ts
+++ b/examples-testing/examples/webgpu_materials_cubemap_mipmaps.ts
@@ -2,9 +2,9 @@ import * as THREE from 'three/webgpu';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 init();
 
@@ -12,10 +12,10 @@ init();
 async function loadCubeTextureWithMipmaps() {
     const path = 'textures/cube/angus/';
     const format = '.jpg';
-    const mipmaps = [];
+    const mipmaps: THREE.CubeTexture[] = [];
     const maxLevel = 8;
 
-    async function loadCubeTexture(urls) {
+    async function loadCubeTexture(urls: string[]): Promise<THREE.CubeTexture> {
         return new Promise(function (resolve) {
             new THREE.CubeTextureLoader().load(urls, function (cubeTexture) {
                 resolve(cubeTexture);
@@ -24,10 +24,10 @@ async function loadCubeTextureWithMipmaps() {
     }
 
     // load mipmaps
-    const pendings = [];
+    const pendings: Promise<void>[] = [];
 
     for (let level = 0; level <= maxLevel; ++level) {
-        const urls = [];
+        const urls: string[] = [];
 
         for (let face = 0; face < 6; ++face) {
             urls.push(path + 'cube_m0' + level + '_c0' + face + format);
@@ -44,7 +44,7 @@ async function loadCubeTextureWithMipmaps() {
 
     await Promise.all(pendings);
 
-    const customizedCubeTexture = mipmaps.shift();
+    const customizedCubeTexture = mipmaps.shift()!;
     customizedCubeTexture.mipmaps = mipmaps;
     customizedCubeTexture.colorSpace = THREE.SRGBColorSpace;
     customizedCubeTexture.minFilter = THREE.LinearMipMapLinearFilter;
diff --git a/examples-testing/examples/webgpu_materials_displacementmap.ts b/examples-testing/examples/webgpu_materials_displacementmap.ts
index 17a01f324..1ecf1a86f 100644
--- a/examples-testing/examples/webgpu_materials_displacementmap.ts
+++ b/examples-testing/examples/webgpu_materials_displacementmap.ts
@@ -5,7 +5,7 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, controls: OrbitControls;
 
 const settings = {
     metalness: 1.0,
@@ -17,9 +17,9 @@ const settings = {
     normalScale: 1.0,
 };
 
-let mesh, material;
+let mesh: THREE.Mesh, material: THREE.MeshStandardNodeMaterial;
 
-let pointLight, ambientLight;
+let pointLight: THREE.PointLight, ambientLight: THREE.AmbientLight;
 
 const height = 500; // of camera frustum
 
@@ -30,7 +30,7 @@ initGui();
 
 // Init gui
 function initGui() {
-    const gui = renderer.inspector.createParameters('settings');
+    const gui = (renderer.inspector as Inspector).createParameters('settings');
 
     gui.add(settings, 'metalness', 0, 1).onChange(function (value) {
         material.metalness = value;
@@ -151,7 +151,7 @@ function init() {
 
     const loader = new OBJLoader();
     loader.load('models/obj/ninja/ninjaHead_Low.obj', function (group) {
-        const geometry = group.children[0].geometry;
+        const geometry = (group.children[0] as THREE.Mesh).geometry;
         geometry.center();
 
         mesh = new THREE.Mesh(geometry, material);
diff --git a/examples-testing/examples/webgpu_materials_envmaps.ts b/examples-testing/examples/webgpu_materials_envmaps.ts
index 6862caeed..97cae265b 100644
--- a/examples-testing/examples/webgpu_materials_envmaps.ts
+++ b/examples-testing/examples/webgpu_materials_envmaps.ts
@@ -4,9 +4,18 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let controls, camera, scene, renderer;
-let textureEquirec, textureCube;
-let sphereMesh, sphereMaterial, params;
+let controls, camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let textureEquirec: THREE.Texture, textureCube: THREE.CubeTexture;
+let sphereMesh: THREE.Mesh<THREE.IcosahedronGeometry, THREE.MeshBasicMaterial>,
+    sphereMaterial: THREE.MeshBasicMaterial,
+    params: {
+        Type: 'Cube' | 'Equirectangular';
+        Refraction: boolean;
+        backgroundRotationX: boolean;
+        backgroundRotationY: boolean;
+        backgroundRotationZ: boolean;
+        syncMaterial: boolean;
+    };
 
 init();
 
@@ -68,7 +77,7 @@ function init() {
         syncMaterial: false,
     };
 
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
     gui.add(params, 'Type', ['Cube', 'Equirectangular']).onChange(function (value) {
         if (value === 'Cube') {
             scene.background = textureCube;
diff --git a/examples-testing/examples/webgpu_materials_envmaps_bpcem.ts b/examples-testing/examples/webgpu_materials_envmaps_bpcem.ts
index c4cf91d6f..310fc27a8 100644
--- a/examples-testing/examples/webgpu_materials_envmaps_bpcem.ts
+++ b/examples-testing/examples/webgpu_materials_envmaps_bpcem.ts
@@ -16,11 +16,11 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';
 import { RectAreaLightTexturesLib } from 'three/addons/lights/RectAreaLightTexturesLib.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
-let controls, cubeCamera;
+let controls: OrbitControls, cubeCamera: THREE.CubeCamera;
 
-let groundPlane, wallMat;
+let groundPlane: THREE.Mesh, wallMat: THREE.MeshStandardNodeMaterial;
 
 init();
 
@@ -170,7 +170,7 @@ async function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
     const params = {
         'box projected': true,
     };
diff --git a/examples-testing/examples/webgpu_materials_lightmap.ts b/examples-testing/examples/webgpu_materials_lightmap.ts
index 081de95ac..78b575f13 100644
--- a/examples-testing/examples/webgpu_materials_lightmap.ts
+++ b/examples-testing/examples/webgpu_materials_lightmap.ts
@@ -5,8 +5,8 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container;
-let camera, scene, renderer;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 const params = {
     intensity: 1,
@@ -76,12 +76,12 @@ async function init() {
 
     // GUI
 
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
 
     gui.add(params, 'intensity', 0, 1)
         .name('Light Map Intensity')
         .onChange(value => {
-            for (const material of object.material) {
+            for (const material of (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial[]>).material) {
                 material.lightMapIntensity = value;
             }
         });
diff --git a/examples-testing/examples/webgpu_materials_matcap.ts b/examples-testing/examples/webgpu_materials_matcap.ts
index 0a841ae27..847b3df3e 100644
--- a/examples-testing/examples/webgpu_materials_matcap.ts
+++ b/examples-testing/examples/webgpu_materials_matcap.ts
@@ -6,7 +6,10 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';
 
-let mesh, renderer, scene, camera;
+let mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshMatcapNodeMaterial>,
+    renderer: THREE.WebGPURenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera;
 
 const API = {
     color: 0xffffff, // sRGB
@@ -51,7 +54,7 @@ function init() {
 
     // model
     new GLTFLoader().load('models/gltf/LeePerrySmith/LeePerrySmith.glb', function (gltf) {
-        mesh = gltf.scene.children[0];
+        mesh = gltf.scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshMatcapNodeMaterial>;
         mesh.position.y = -0.25;
 
         mesh.material = new THREE.MeshMatcapNodeMaterial({
@@ -64,7 +67,7 @@ function init() {
     });
 
     // gui
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
 
     gui.addColor(API, 'color')
         .listen()
@@ -99,7 +102,7 @@ function animate() {
 // drag and drop anywhere in document
 //
 
-function updateMatcap(texture) {
+function updateMatcap(texture: THREE.Texture) {
     if (mesh.material.matcap) {
         mesh.material.matcap.dispose();
     }
@@ -111,11 +114,11 @@ function updateMatcap(texture) {
     mesh.material.needsUpdate = true; // because the color space can change
 }
 
-function handleJPG(event) {
+function handleJPG(event: ProgressEvent<FileReader>) {
     // PNG, WebP, AVIF, too
 
-    function imgCallback(event) {
-        const texture = new THREE.Texture(event.target);
+    function imgCallback(event: Event) {
+        const texture = new THREE.Texture(event.target!);
 
         texture.colorSpace = THREE.SRGBColorSpace;
 
@@ -126,11 +129,11 @@ function handleJPG(event) {
 
     img.onload = imgCallback;
 
-    img.src = event.target.result;
+    img.src = event.target!.result as string;
 }
 
-function handleEXR(event) {
-    const contents = event.target.result;
+function handleEXR(event: ProgressEvent<FileReader>) {
+    const contents = event.target!.result as ArrayBuffer;
 
     const loader = new EXRLoader();
 
@@ -155,9 +158,9 @@ function handleEXR(event) {
     updateMatcap(texture);
 }
 
-function loadFile(file) {
+function loadFile(file: File) {
     const filename = file.name;
-    const extension = filename.split('.').pop().toLowerCase();
+    const extension = filename.split('.').pop()!.toLowerCase();
 
     if (extension === 'exr') {
         const reader = new FileReader();
@@ -183,12 +186,12 @@ function loadFile(file) {
 function initDragAndDrop() {
     document.addEventListener('dragover', function (event) {
         event.preventDefault();
-        event.dataTransfer.dropEffect = 'copy';
+        event.dataTransfer!.dropEffect = 'copy';
     });
 
     document.addEventListener('drop', function (event) {
         event.preventDefault();
 
-        loadFile(event.dataTransfer.files[0]);
+        loadFile(event.dataTransfer!.files[0]);
     });
 }
diff --git a/examples-testing/examples/webgpu_materials_sss.ts b/examples-testing/examples/webgpu_materials_sss.ts
index c76df99dc..b94767b77 100644
--- a/examples-testing/examples/webgpu_materials_sss.ts
+++ b/examples-testing/examples/webgpu_materials_sss.ts
@@ -6,9 +6,9 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
 
-let container;
-let camera, scene, renderer;
-let model;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let model: THREE.Mesh;
 
 init();
 
@@ -58,7 +58,7 @@ function init() {
     //
 
     renderer.inspector = new Inspector();
-    document.body.appendChild(renderer.inspector.domElement);
+    document.body.appendChild((renderer.inspector as Inspector).domElement);
 
     //
 
@@ -93,7 +93,7 @@ function initMaterial() {
 
     const loaderFBX = new FBXLoader();
     loaderFBX.load('models/fbx/stanford-bunny.fbx', function (object) {
-        model = object.children[0];
+        model = object.children[0] as THREE.Mesh;
         model.position.set(0, 0, 10);
         model.scale.setScalar(1);
         model.material = material;
@@ -103,37 +103,45 @@ function initMaterial() {
     initGUI(material);
 }
 
-function initGUI(material) {
-    const gui = renderer.inspector.createParameters('Parameters');
-
-    const ThicknessControls = function () {
-        this.distortion = material.thicknessDistortionNode.value;
-        this.ambient = material.thicknessAmbientNode.value;
-        this.attenuation = material.thicknessAttenuationNode.value;
-        this.power = material.thicknessPowerNode.value;
-        this.scale = material.thicknessScaleNode.value;
-    };
+function initGUI(material: THREE.MeshSSSNodeMaterial) {
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
+
+    class ThicknessControls {
+        distortion: number;
+        ambient: number;
+        attenuation: number;
+        power: number;
+        scale: number;
+
+        constructor() {
+            this.distortion = (material.thicknessDistortionNode as THREE.UniformNode<'float', number>).value;
+            this.ambient = (material.thicknessAmbientNode as THREE.UniformNode<'float', number>).value;
+            this.attenuation = (material.thicknessAttenuationNode as THREE.UniformNode<'float', number>).value;
+            this.power = (material.thicknessPowerNode as THREE.UniformNode<'float', number>).value;
+            this.scale = (material.thicknessScaleNode as THREE.UniformNode<'float', number>).value;
+        }
+    }
 
     const thicknessControls = new ThicknessControls();
 
     gui.add(thicknessControls, 'distortion', 0.01, 1, 0.01).onChange(function () {
-        material.thicknessDistortionNode.value = thicknessControls.distortion;
+        (material.thicknessDistortionNode as THREE.UniformNode<'float', number>).value = thicknessControls.distortion;
     });
 
     gui.add(thicknessControls, 'ambient', 0.01, 5.0, 0.05).onChange(function () {
-        material.thicknessAmbientNode.value = thicknessControls.ambient;
+        (material.thicknessAmbientNode as THREE.UniformNode<'float', number>).value = thicknessControls.ambient;
     });
 
     gui.add(thicknessControls, 'attenuation', 0.01, 5.0, 0.05).onChange(function () {
-        material.thicknessAttenuationNode.value = thicknessControls.attenuation;
+        (material.thicknessAttenuationNode as THREE.UniformNode<'float', number>).value = thicknessControls.attenuation;
     });
 
     gui.add(thicknessControls, 'power', 0.01, 16.0, 0.1).onChange(function () {
-        material.thicknessPowerNode.value = thicknessControls.power;
+        (material.thicknessPowerNode as THREE.UniformNode<'float', number>).value = thicknessControls.power;
     });
 
     gui.add(thicknessControls, 'scale', 0.01, 50.0, 0.1).onChange(function () {
-        material.thicknessScaleNode.value = thicknessControls.scale;
+        (material.thicknessScaleNode as THREE.UniformNode<'float', number>).value = thicknessControls.scale;
     });
 }
 
diff --git a/examples-testing/examples/webgpu_materials_texture_manualmipmap.ts b/examples-testing/examples/webgpu_materials_texture_manualmipmap.ts
index 090372729..2456b2959 100644
--- a/examples-testing/examples/webgpu_materials_texture_manualmipmap.ts
+++ b/examples-testing/examples/webgpu_materials_texture_manualmipmap.ts
@@ -3,9 +3,9 @@ import * as THREE from 'three/webgpu';
 const SCREEN_WIDTH = window.innerWidth;
 const SCREEN_HEIGHT = window.innerHeight;
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene1, scene2, renderer;
+let camera: THREE.PerspectiveCamera, scene1: THREE.Scene, scene2: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 let mouseX = 0,
     mouseY = 0;
@@ -90,7 +90,7 @@ async function init() {
     addPainting(scene1, mesh1);
     addPainting(scene2, mesh2);
 
-    function addPainting(zscene, zmesh) {
+    function addPainting(zscene: THREE.Scene, zmesh: THREE.Mesh<THREE.PlaneGeometry, THREE.MeshBasicMaterial>) {
         const image = texturePainting1.image;
 
         zmesh.scale.x = image.width / 100;
@@ -131,9 +131,9 @@ async function init() {
     document.addEventListener('mousemove', onDocumentMouseMove);
 }
 
-function mipmap(size, color) {
+function mipmap(size: number, color: string) {
     const imageCanvas = document.createElement('canvas');
-    const context = imageCanvas.getContext('2d');
+    const context = imageCanvas.getContext('2d')!;
 
     imageCanvas.width = imageCanvas.height = size;
 
@@ -146,7 +146,7 @@ function mipmap(size, color) {
     return imageCanvas;
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgpu_materials_toon.ts b/examples-testing/examples/webgpu_materials_toon.ts
index 56ef372ce..f634dff9e 100644
--- a/examples-testing/examples/webgpu_materials_toon.ts
+++ b/examples-testing/examples/webgpu_materials_toon.ts
@@ -6,18 +6,22 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
+import { Font } from 'three/examples/jsm/loaders/FontLoader.js';
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer, postProcessing;
-let particleLight;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    postProcessing: THREE.PostProcessing;
+let particleLight: THREE.Mesh;
 
 const loader = new FontLoader();
 loader.load('fonts/gentilis_regular.typeface.json', function (font) {
     init(font);
 });
 
-function init(font) {
+function init(font: Font) {
     container = document.createElement('div');
     document.body.appendChild(container);
 
@@ -86,7 +90,7 @@ function init(font) {
         }
     }
 
-    function addLabel(name, location) {
+    function addLabel(name: string, location: THREE.Vector3) {
         const textGeo = new TextGeometry(name, {
             font: font,
 
diff --git a/examples-testing/examples/webgpu_materials_transmission.ts b/examples-testing/examples/webgpu_materials_transmission.ts
index 9e8eca5cd..5788d0961 100644
--- a/examples-testing/examples/webgpu_materials_transmission.ts
+++ b/examples-testing/examples/webgpu_materials_transmission.ts
@@ -20,7 +20,7 @@ const params = {
     exposure: 1,
 };
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 let mesh;
 
@@ -89,7 +89,7 @@ function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     gui.addColor(params, 'color').onChange(function () {
         material.color.set(params.color);
@@ -159,7 +159,7 @@ function generateTexture() {
     canvas.width = 2;
     canvas.height = 2;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     context.fillStyle = 'white';
     context.fillRect(0, 1, 2, 1);
 
diff --git a/examples-testing/examples/webgpu_materials_video.ts b/examples-testing/examples/webgpu_materials_video.ts
index bc837653f..3148b5e16 100644
--- a/examples-testing/examples/webgpu_materials_video.ts
+++ b/examples-testing/examples/webgpu_materials_video.ts
@@ -1,10 +1,13 @@
 import * as THREE from 'three/webgpu';
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
-let video, texture, material, mesh;
+let video: HTMLVideoElement,
+    texture: THREE.VideoTexture,
+    material: THREE.MeshPhongMaterial & { hue?: number; saturation?: number },
+    mesh: THREE.Mesh & { dx?: number; dy?: number };
 
 let mouseX = 0;
 let mouseY = 0;
@@ -12,20 +15,20 @@ let mouseY = 0;
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
 
-let cube_count;
+let cube_count: number;
 
-const meshes = [],
-    materials = [],
+const meshes: THREE.Mesh[] = [],
+    materials: (THREE.MeshPhongMaterial & { hue?: number; saturation?: number })[] = [],
     xgrid = 20,
     ygrid = 10;
 
-const startButton = document.getElementById('startButton');
+const startButton = document.getElementById('startButton')!;
 startButton.addEventListener('click', function () {
     init();
 });
 
 function init() {
-    const overlay = document.getElementById('overlay');
+    const overlay = document.getElementById('overlay')!;
     overlay.remove();
 
     container = document.createElement('div');
@@ -46,7 +49,7 @@ function init() {
     renderer.setAnimationLoop(render);
     container.appendChild(renderer.domElement);
 
-    video = document.getElementById('video');
+    video = document.getElementById('video') as HTMLVideoElement;
     video.play();
     video.addEventListener('play', function () {
         this.currentTime = 3;
@@ -123,7 +126,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function change_uvs(geometry, unitx, unity, offsetx, offsety) {
+function change_uvs(geometry: THREE.BoxGeometry, unitx: number, unity: number, offsetx: number, offsety: number) {
     const uvs = geometry.attributes.uv.array;
 
     for (let i = 0; i < uvs.length; i += 2) {
@@ -132,7 +135,7 @@ function change_uvs(geometry, unitx, unity, offsetx, offsety) {
     }
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = (event.clientY - windowHalfY) * 0.3;
 }
@@ -153,20 +156,20 @@ function render() {
     for (let i = 0; i < cube_count; i++) {
         material = materials[i];
 
-        h = ((360 * (material.hue + time)) % 360) / 360;
-        material.color.setHSL(h, material.saturation, 0.5);
+        h = ((360 * (material.hue! + time)) % 360) / 360;
+        material.color.setHSL(h, material.saturation!, 0.5);
     }
 
     if (counter % 1000 > 200) {
         for (let i = 0; i < cube_count; i++) {
             mesh = meshes[i];
 
-            mesh.rotation.x += 10 * mesh.dx;
-            mesh.rotation.y += 10 * mesh.dy;
+            mesh.rotation.x += 10 * mesh.dx!;
+            mesh.rotation.y += 10 * mesh.dy!;
 
-            mesh.position.x -= 150 * mesh.dx;
-            mesh.position.y += 150 * mesh.dy;
-            mesh.position.z += 300 * mesh.dx;
+            mesh.position.x -= 150 * mesh.dx!;
+            mesh.position.y += 150 * mesh.dy!;
+            mesh.position.z += 300 * mesh.dx!;
         }
     }
 
@@ -174,8 +177,8 @@ function render() {
         for (let i = 0; i < cube_count; i++) {
             mesh = meshes[i];
 
-            mesh.dx *= -1;
-            mesh.dy *= -1;
+            mesh.dx! *= -1;
+            mesh.dy! *= -1;
         }
     }
 
diff --git a/examples-testing/examples/webgpu_materialx_noise.ts b/examples-testing/examples/webgpu_materialx_noise.ts
index 229c26a8e..460605135 100644
--- a/examples-testing/examples/webgpu_materialx_noise.ts
+++ b/examples-testing/examples/webgpu_materialx_noise.ts
@@ -13,12 +13,12 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
-let particleLight;
-let group;
+let particleLight: THREE.Mesh;
+let group: THREE.Group;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_mesh_batch.ts b/examples-testing/examples/webgpu_mesh_batch.ts
index c20dc4b57..3c8218646 100644
--- a/examples-testing/examples/webgpu_mesh_batch.ts
+++ b/examples-testing/examples/webgpu_mesh_batch.ts
@@ -1,17 +1,18 @@
 import * as THREE from 'three/webgpu';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
+import { ParametersGroup } from 'three/addons/inspector/tabs/Parameters.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
-import { radixSort } from 'three/addons/utils/SortUtils.js';
+import { radixSort, RadixSortOptions } from 'three/addons/utils/SortUtils.js';
 
 import { normalView, directionToColor, diffuseColor } from 'three/tsl';
 
-let camera, scene, renderer;
-let controls;
-let gui;
-let geometries, mesh, material;
-const ids = [];
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let controls: OrbitControls;
+let gui: ParametersGroup;
+let geometries: THREE.BufferGeometry[], mesh: THREE.BatchedMesh, material: THREE.MeshBasicNodeMaterial;
+const ids: number[] = [];
 
 const matrix = new THREE.Matrix4();
 
@@ -46,7 +47,7 @@ init();
 
 //
 
-function randomizeMatrix(matrix) {
+function randomizeMatrix(matrix: THREE.Matrix4) {
     position.x = Math.random() * 40 - 20;
     position.y = Math.random() * 40 - 20;
     position.z = Math.random() * 40 - 20;
@@ -62,7 +63,7 @@ function randomizeMatrix(matrix) {
     return matrix.compose(position, quaternion, scale);
 }
 
-function randomizeRotationSpeed(rotation) {
+function randomizeRotationSpeed(rotation: THREE.Euler) {
     rotation.x = Math.random() * 0.01;
     rotation.y = Math.random() * 0.01;
     rotation.z = Math.random() * 0.01;
@@ -88,7 +89,7 @@ function createMaterial() {
 
 function cleanup() {
     if (mesh) {
-        mesh.parent.remove(mesh);
+        mesh.parent!.remove(mesh);
 
         if (mesh.dispose) {
             mesh.dispose();
@@ -176,7 +177,7 @@ function init(forceWebGL = false) {
 
     // gui
 
-    gui = renderer.inspector.createParameters('Settings');
+    gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(api, 'webgpu').onChange(() => {
         init(!api.webgpu);
     });
@@ -244,18 +245,26 @@ function init(forceWebGL = false) {
 
 //
 
-function sortFunction(list, camera) {
+type BatchedMeshWithOptions = THREE.BatchedMesh & {
+    _options?: RadixSortOptions<{ start: number; count: number; z: number }>;
+};
+
+function sortFunction(
+    this: THREE.BatchedMesh,
+    list: { start: number; count: number; z: number }[],
+    camera: THREE.Camera,
+) {
     // initialize options
-    this._options = this._options || {
+    (this as BatchedMeshWithOptions)._options = (this as BatchedMeshWithOptions)._options || {
         get: el => el.z,
         aux: new Array(this.maxInstanceCount),
     };
 
-    const options = this._options;
+    const options = (this as BatchedMeshWithOptions)._options!;
     options.reversed = this.material.transparent;
 
     // convert depth to unsigned 32 bit range
-    const factor = (2 ** 32 - 1) / camera.far; // UINT32_MAX / max_depth
+    const factor = (2 ** 32 - 1) / (camera as THREE.PerspectiveCamera).far; // UINT32_MAX / max_depth
     for (let i = 0, l = list.length; i < l; i++) {
         list[i].z *= factor;
     }
diff --git a/examples-testing/examples/webgpu_mirror.ts b/examples-testing/examples/webgpu_mirror.ts
index 56b226193..d0a270bfb 100644
--- a/examples-testing/examples/webgpu_mirror.ts
+++ b/examples-testing/examples/webgpu_mirror.ts
@@ -5,11 +5,11 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
-let cameraControls;
+let cameraControls: OrbitControls;
 
-let sphereGroup, smallSphere;
+let sphereGroup: THREE.Object3D, smallSphere: THREE.Mesh;
 
 init();
 
@@ -74,8 +74,8 @@ function init() {
     const groundUVOffset = texture(decalNormal).xy.mul(2).sub(1).mul(groundNormalScale);
     const verticalUVOffset = texture(floorNormal, uv().mul(5)).xy.mul(2).sub(1).mul(verticalNormalScale);
 
-    groundReflector.uvNode = groundReflector.uvNode.add(groundUVOffset);
-    verticalReflector.uvNode = verticalReflector.uvNode.add(verticalUVOffset);
+    groundReflector.uvNode = groundReflector.uvNode!.add(groundUVOffset);
+    verticalReflector.uvNode = verticalReflector.uvNode!.add(verticalUVOffset);
 
     const groundNode = texture(decalDiffuse).a.mix(color(0xffffff), groundReflector);
     const verticalNode = color(0x0000ff).mul(0.1).add(verticalReflector);
diff --git a/examples-testing/examples/webgpu_modifier_curve.ts b/examples-testing/examples/webgpu_modifier_curve.ts
index c465ddc57..9fa79745b 100644
--- a/examples-testing/examples/webgpu_modifier_curve.ts
+++ b/examples-testing/examples/webgpu_modifier_curve.ts
@@ -7,16 +7,16 @@ import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
 const ACTION_SELECT = 1,
     ACTION_NONE = 0;
-const curveHandles = [];
+const curveHandles: THREE.Object3D[] = [];
 const mouse = new THREE.Vector2();
 
-let scene,
-    camera,
-    renderer,
-    rayCaster,
-    control,
-    flow,
-    action = ACTION_NONE;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGPURenderer,
+    rayCaster: THREE.Raycaster,
+    control: TransformControls,
+    flow: Flow,
+    action: typeof ACTION_SELECT | typeof ACTION_NONE = ACTION_NONE;
 
 init();
 
@@ -124,7 +124,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     action = ACTION_SELECT;
     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
     mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
diff --git a/examples-testing/examples/webgpu_morphtargets.ts b/examples-testing/examples/webgpu_morphtargets.ts
index cde3ae83b..c6e68d052 100644
--- a/examples-testing/examples/webgpu_morphtargets.ts
+++ b/examples-testing/examples/webgpu_morphtargets.ts
@@ -4,12 +4,16 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let container, camera, scene, renderer, mesh;
+let container: HTMLElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    mesh: THREE.Mesh;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     scene = new THREE.Scene();
     scene.background = new THREE.Color(0x8fbcd4);
@@ -64,7 +68,7 @@ function createGeometry() {
     const spherePositions = [];
 
     // for the second morph target, we'll twist the cubes vertices
-    const twistPositions = [];
+    const twistPositions: number[] = [];
     const direction = new THREE.Vector3(1, 0, 0);
     const vertex = new THREE.Vector3();
 
@@ -101,13 +105,13 @@ function initGUI() {
         Twist: 0,
     };
 
-    const gui = renderer.inspector.createParameters('Morph Targets');
+    const gui = (renderer.inspector as Inspector).createParameters('Morph Targets');
 
     gui.add(params, 'Spherify', 0, 1, 0.01).onChange(function (value) {
-        mesh.morphTargetInfluences[0] = value;
+        mesh.morphTargetInfluences![0] = value;
     });
     gui.add(params, 'Twist', 0, 1, 0.01).onChange(function (value) {
-        mesh.morphTargetInfluences[1] = value;
+        mesh.morphTargetInfluences![1] = value;
     });
 }
 
diff --git a/examples-testing/examples/webgpu_morphtargets_face.ts b/examples-testing/examples/webgpu_morphtargets_face.ts
index 5c76ca010..9f265ffa4 100644
--- a/examples-testing/examples/webgpu_morphtargets_face.ts
+++ b/examples-testing/examples/webgpu_morphtargets_face.ts
@@ -12,7 +12,7 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 init();
 
 async function init() {
-    let mixer;
+    let mixer: THREE.AnimationMixer;
 
     const clock = new THREE.Clock();
 
@@ -53,12 +53,12 @@ async function init() {
 
             // GUI
 
-            const head = mesh.getObjectByName('mesh_2');
-            const influences = head.morphTargetInfluences;
+            const head = mesh.getObjectByName('mesh_2') as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
+            const influences = head.morphTargetInfluences!;
 
-            const gui = renderer.inspector.createParameters('Morph Targets');
+            const gui = (renderer.inspector as Inspector).createParameters('Morph Targets');
 
-            for (const [key, value] of Object.entries(head.morphTargetDictionary)) {
+            for (const [key, value] of Object.entries(head.morphTargetDictionary!)) {
                 gui.add(influences, value, 0, 1, 0.01).name(key.replace('blendShape1.', '')).listen();
             }
         });
diff --git a/examples-testing/examples/webgpu_mrt.ts b/examples-testing/examples/webgpu_mrt.ts
index 6cfb990a7..52a80e7f7 100644
--- a/examples-testing/examples/webgpu_mrt.ts
+++ b/examples-testing/examples/webgpu_mrt.ts
@@ -20,8 +20,8 @@ import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let camera, scene, renderer;
-let postProcessing;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let postProcessing: THREE.PostProcessing;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_mrt_mask.ts b/examples-testing/examples/webgpu_mrt_mask.ts
index 6125b9725..f579d3407 100644
--- a/examples-testing/examples/webgpu_mrt_mask.ts
+++ b/examples-testing/examples/webgpu_mrt_mask.ts
@@ -6,11 +6,11 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
-let postProcessing;
-let spheres,
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let postProcessing: THREE.PostProcessing;
+let spheres: THREE.Group,
     rotate = true;
-let mixer, clock;
+let mixer: THREE.AnimationMixer, clock: THREE.Clock;
 
 init();
 
@@ -36,7 +36,9 @@ function init() {
         const object = gltf.scene;
         mixer = new THREE.AnimationMixer(object);
 
-        const material = object.children[0].children[0].material;
+        const material = (
+            object.children[0].children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhysicalMaterial>
+        ).material;
 
         // add glow effect
         material.mrtNode = mrt({ mask: output.add(1) });
@@ -54,7 +56,7 @@ function init() {
     spheres = new THREE.Group();
     scene.add(spheres);
 
-    function addSphere(color, mrtNode = null) {
+    function addSphere(color: number, mrtNode: THREE.MRTNode | null = null) {
         const distance = 1;
         const id = spheres.children.length;
         const rotation = THREE.MathUtils.degToRad(id * 90);
diff --git a/examples-testing/examples/webgpu_multiple_canvas.ts b/examples-testing/examples/webgpu_multiple_canvas.ts
index db55fe165..caeb5d841 100644
--- a/examples-testing/examples/webgpu_multiple_canvas.ts
+++ b/examples-testing/examples/webgpu_multiple_canvas.ts
@@ -1,4 +1,4 @@
-import * as THREE from 'three';
+import * as THREE from 'three/webgpu';
 import { color } from 'three/tsl';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
@@ -15,9 +15,9 @@ if (WebGPU.isAvailable() === false) {
 
 //
 
-let renderer;
+let renderer: THREE.WebGPURenderer;
 
-const scenes = [];
+const scenes: THREE.Scene[] = [];
 
 init();
 
@@ -29,7 +29,7 @@ function init() {
         new THREE.CylinderGeometry(0.5, 0.5, 1, 12),
     ];
 
-    const content = document.getElementById('content');
+    const content = document.getElementById('content')!;
 
     for (let i = 0; i < 40; i++) {
         const scene = new THREE.Scene();
diff --git a/examples-testing/examples/webgpu_multiple_elements.ts b/examples-testing/examples/webgpu_multiple_elements.ts
index 65bd3e75d..3d3f2fd92 100644
--- a/examples-testing/examples/webgpu_multiple_elements.ts
+++ b/examples-testing/examples/webgpu_multiple_elements.ts
@@ -1,16 +1,16 @@
-import * as THREE from 'three';
+import * as THREE from 'three/webgpu';
 import { color } from 'three/tsl';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let canvas, renderer;
+let canvas: HTMLCanvasElement, renderer: THREE.WebGPURenderer;
 
-const scenes = [];
+const scenes: THREE.Object3D[] = [];
 
 init();
 
 function init() {
-    canvas = document.getElementById('c');
+    canvas = document.getElementById('c') as HTMLCanvasElement;
 
     const geometries = [
         new THREE.BoxGeometry(1, 1, 1),
@@ -19,7 +19,7 @@ function init() {
         new THREE.CylinderGeometry(0.5, 0.5, 1, 12),
     ];
 
-    const content = document.getElementById('content');
+    const content = document.getElementById('content')!;
 
     for (let i = 0; i < 40; i++) {
         const scene = new THREE.Scene();
diff --git a/examples-testing/examples/webgpu_multiple_rendertargets.ts b/examples-testing/examples/webgpu_multiple_rendertargets.ts
index 18d48cbf0..8fac58713 100644
--- a/examples-testing/examples/webgpu_multiple_rendertargets.ts
+++ b/examples-testing/examples/webgpu_multiple_rendertargets.ts
@@ -3,8 +3,8 @@ import { mix, vec2, step, texture, uv, screenUV, normalWorld, output, mrt } from
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, torus;
-let postProcessing, renderTarget;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, torus: THREE.Mesh;
+let postProcessing: THREE.PostProcessing, renderTarget: THREE.RenderTarget;
 
 init();
 
@@ -84,7 +84,7 @@ function onWindowResize() {
     renderTarget.setSize(window.innerWidth * dpr, window.innerHeight * dpr);
 }
 
-function render(time) {
+function render(time: DOMHighResTimeStamp) {
     torus.rotation.y = (time / 1000) * 0.4;
 
     // render scene into target
diff --git a/examples-testing/examples/webgpu_multiple_rendertargets_readback.ts b/examples-testing/examples/webgpu_multiple_rendertargets_readback.ts
index 4eee79fbc..520710ba2 100644
--- a/examples-testing/examples/webgpu_multiple_rendertargets_readback.ts
+++ b/examples-testing/examples/webgpu_multiple_rendertargets_readback.ts
@@ -5,8 +5,15 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, torus;
-let quadMesh, sceneMRT, renderTarget, readbackTarget, material, readbackMaterial, pixelBuffer, pixelBufferTexture;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, torus: THREE.Mesh;
+let quadMesh: THREE.QuadMesh,
+    sceneMRT: THREE.MRTNode,
+    renderTarget: THREE.RenderTarget,
+    readbackTarget: THREE.RenderTarget,
+    material: THREE.NodeMaterial,
+    readbackMaterial: THREE.MeshBasicNodeMaterial,
+    pixelBuffer: Uint8Array,
+    pixelBufferTexture: THREE.DataTexture;
 
 const options = {
     selection: 'mrt',
@@ -27,7 +34,7 @@ function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(options, 'selection', ['mrt', 'diffuse', 'normal']);
 
     // Create a multi render target with Float buffers
@@ -114,7 +121,7 @@ function onWindowResize() {
     renderTarget.setSize(window.innerWidth * dpr, window.innerHeight * dpr);
 }
 
-async function render(time) {
+async function render(time: number) {
     const selection = options.selection;
 
     torus.rotation.y = (time / 1000) * 0.4;
@@ -148,12 +155,26 @@ async function readback() {
     const selection = options.selection;
 
     if (selection === 'diffuse') {
-        pixelBuffer = await renderer.readRenderTargetPixelsAsync(readbackTarget, 0, 0, width, height, 0); // zero is optional
+        pixelBuffer = (await renderer.readRenderTargetPixelsAsync(
+            readbackTarget,
+            0,
+            0,
+            width,
+            height,
+            0,
+        )) as Uint8Array; // zero is optional
 
         pixelBufferTexture.image.data = pixelBuffer;
         pixelBufferTexture.needsUpdate = true;
     } else if (selection === 'normal') {
-        pixelBuffer = await renderer.readRenderTargetPixelsAsync(readbackTarget, 0, 0, width, height, 1);
+        pixelBuffer = (await renderer.readRenderTargetPixelsAsync(
+            readbackTarget,
+            0,
+            0,
+            width,
+            height,
+            1,
+        )) as Uint8Array;
 
         pixelBufferTexture.image.data = pixelBuffer;
         pixelBufferTexture.needsUpdate = true;
diff --git a/examples-testing/examples/webgpu_multisampled_renderbuffers.ts b/examples-testing/examples/webgpu_multisampled_renderbuffers.ts
index 05098c8d4..9164cb14b 100644
--- a/examples-testing/examples/webgpu_multisampled_renderbuffers.ts
+++ b/examples-testing/examples/webgpu_multisampled_renderbuffers.ts
@@ -3,12 +3,12 @@ import { texture } from 'three/tsl';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 const mouse = new THREE.Vector2();
 
-let quadMesh, renderTarget;
+let quadMesh: THREE.QuadMesh, renderTarget: THREE.RenderTarget;
 
-let box, box2;
+let box: THREE.InstancedMesh, box2: THREE.InstancedMesh;
 
 const dpr = 1;
 
@@ -22,7 +22,7 @@ const mat4 = new THREE.Matrix4();
 const count = 50;
 const fullRadius = 20; // Radius of the sphere
 const halfRadius = 10; // Radius of the sphere
-const positions = new Array(count).fill().map((_, i) => {
+const positions = new Array(count).fill(undefined).map((_, i) => {
     const radius = i % 2 === 0 ? fullRadius : halfRadius;
 
     const phi = Math.acos(2 * Math.random() - 1) - Math.PI / 2; // phi: latitude, range -/2 to /2
@@ -39,7 +39,7 @@ init();
 initGUI();
 
 function initGUI() {
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(params, 'samples', 0, 4, 1);
     gui.add(params, 'animated');
 }
@@ -98,7 +98,7 @@ function init() {
     quadMesh = new THREE.QuadMesh(materialFX);
 }
 
-function onWindowMouseMove(e) {
+function onWindowMouseMove(e: MouseEvent) {
     mouse.x = e.offsetX / window.innerWidth;
     mouse.y = e.offsetY / window.innerHeight;
 }
diff --git a/examples-testing/examples/webgpu_occlusion.ts b/examples-testing/examples/webgpu_occlusion.ts
index e49f98ce7..e7061f5d2 100644
--- a/examples-testing/examples/webgpu_occlusion.ts
+++ b/examples-testing/examples/webgpu_occlusion.ts
@@ -3,10 +3,16 @@ import { nodeObject, uniform } from 'three/tsl';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, controls: OrbitControls;
 
-class OcclusionNode extends THREE.Node {
-    constructor(testObject, normalColor, occludedColor) {
+class OcclusionNode extends THREE.Node<'vec3'> {
+    uniformNode: THREE.UniformNode<'color', THREE.Color>;
+
+    testObject: THREE.Mesh;
+    normalColor: THREE.Color;
+    occludedColor: THREE.Color;
+
+    constructor(testObject: THREE.Mesh, normalColor: THREE.Color, occludedColor: THREE.Color) {
         super('vec3');
 
         this.updateType = THREE.NodeUpdateType.OBJECT;
@@ -18,8 +24,8 @@ class OcclusionNode extends THREE.Node {
         this.occludedColor = occludedColor;
     }
 
-    async update(frame) {
-        const isOccluded = frame.renderer.isOccluded(this.testObject);
+    async update(frame: THREE.NodeFrame) {
+        const isOccluded = frame.renderer!.isOccluded(this.testObject);
 
         this.uniformNode.value.copy(isOccluded ? this.occludedColor : this.normalColor);
     }
diff --git a/examples-testing/examples/webgpu_ocean.ts b/examples-testing/examples/webgpu_ocean.ts
index 0b8ae7661..2cf5a936f 100644
--- a/examples-testing/examples/webgpu_ocean.ts
+++ b/examples-testing/examples/webgpu_ocean.ts
@@ -6,14 +6,14 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { WaterMesh } from 'three/addons/objects/WaterMesh.js';
 import { SkyMesh } from 'three/addons/objects/SkyMesh.js';
 
-let container;
-let camera, scene, renderer;
-let controls, water, sun, mesh;
+let container: HTMLElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let controls: OrbitControls, water: WaterMesh, sun: THREE.Vector3, mesh: THREE.Mesh;
 
 init();
 
 function init() {
-    container = document.getElementById('container');
+    container = document.getElementById('container')!;
 
     //
 
@@ -75,7 +75,7 @@ function init() {
     const pmremGenerator = new THREE.PMREMGenerator(renderer);
     const sceneEnv = new THREE.Scene();
 
-    let renderTarget;
+    let renderTarget: THREE.RenderTarget | undefined;
 
     function updateSun() {
         const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);
@@ -116,7 +116,7 @@ function init() {
 
     // GUI
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     const folderSky = gui.addFolder('Sky');
     folderSky.add(parameters, 'elevation', 0, 90, 0.1).onChange(updateSun);
diff --git a/examples-testing/examples/webgpu_parallax_uv.ts b/examples-testing/examples/webgpu_parallax_uv.ts
index 658ae08db..adbea4866 100644
--- a/examples-testing/examples/webgpu_parallax_uv.ts
+++ b/examples-testing/examples/webgpu_parallax_uv.ts
@@ -3,9 +3,9 @@ import { texture, parallaxUV, blendOverlay, uv } from 'three/tsl';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
-let controls;
+let controls: OrbitControls;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_particles.ts b/examples-testing/examples/webgpu_particles.ts
index 9e81f0761..da9ee8757 100644
--- a/examples-testing/examples/webgpu_particles.ts
+++ b/examples-testing/examples/webgpu_particles.ts
@@ -7,8 +7,8 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import WebGPU from 'three/addons/capabilities/WebGPU.js';
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let controls: OrbitControls;
 
 init();
 
@@ -92,7 +92,7 @@ function init() {
     // indirect draw ( optional )
     // each indirect draw call is 5 uint32 values for indexes ( different structure for non-indexed draw calls using 4 uint32 values )
 
-    const indexCount = fireGeometry.index.array.length;
+    const indexCount = fireGeometry.index!.array.length;
 
     const uint32 = new Uint32Array(5);
     uint32[0] = indexCount; // indexCount
@@ -132,7 +132,7 @@ function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     gui.add(speed, 'value', 0, 1, 0.01).name('speed');
 }
diff --git a/examples-testing/examples/webgpu_performance.ts b/examples-testing/examples/webgpu_performance.ts
index 570a4dee9..6270f96d5 100644
--- a/examples-testing/examples/webgpu_performance.ts
+++ b/examples-testing/examples/webgpu_performance.ts
@@ -8,17 +8,17 @@ import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
-let camera, scene, renderer;
-let model;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let model: THREE.Group;
 
 const options = { static: true };
 
 init();
 
-function setStatic(object, value) {
+function setStatic(object: THREE.Group, value: boolean) {
     object.traverse(child => {
-        if (child.isMesh) {
-            child.static = value;
+        if ((child as THREE.Mesh).isMesh) {
+            (child as THREE.Mesh).static = value;
         }
     });
 }
@@ -79,7 +79,7 @@ function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(options, 'static').onChange(() => {
         setStatic(model, options.static);
     });
diff --git a/examples-testing/examples/webgpu_performance_renderbundle.ts b/examples-testing/examples/webgpu_performance_renderbundle.ts
index 3b20847b8..bda539989 100644
--- a/examples-testing/examples/webgpu_performance_renderbundle.ts
+++ b/examples-testing/examples/webgpu_performance_renderbundle.ts
@@ -1,13 +1,14 @@
 import * as THREE from 'three/webgpu';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
+import { ParametersGroup } from 'three/addons/inspector/tabs/Parameters.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
-let controls;
-let gui;
-let geometries, group;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let controls: OrbitControls;
+let gui: ParametersGroup;
+let geometries: THREE.BufferGeometry[], group: THREE.Group;
 
 //
 
@@ -30,7 +31,7 @@ init();
 
 //
 
-function randomizeMatrix(matrix) {
+function randomizeMatrix(matrix: THREE.Matrix4) {
     position.x = Math.random() * 80 - 40;
     position.y = Math.random() * 80 - 40;
     position.z = Math.random() * 80 - 40;
@@ -46,7 +47,7 @@ function randomizeMatrix(matrix) {
     return matrix.compose(position, quaternion, scale);
 }
 
-function randomizeRotationSpeed(rotation) {
+function randomizeRotationSpeed(rotation: THREE.Euler) {
     rotation.x = Math.random() * 0.05;
     rotation.y = Math.random() * 0.05;
     rotation.z = Math.random() * 0.05;
@@ -73,11 +74,11 @@ function initGeometries() {
     ];
 }
 
-function initMesh(count) {
+function initMesh(count: number) {
     initRegularMesh(count);
 }
 
-function initRegularMesh(count) {
+function initRegularMesh(count: number) {
     group = api.renderBundle ? new THREE.BundleGroup() : new THREE.Group();
 
     for (let i = 0; i < count; i++) {
@@ -101,7 +102,7 @@ function init() {
     const searchParams = new URLSearchParams(window.location.search);
     api.webgpu = searchParams.get('backend') !== 'webgl';
     api.renderBundle = searchParams.get('renderBundle') !== 'false';
-    api.count = parseFloat(searchParams.get('count') || 4000);
+    api.count = parseFloat(searchParams.get('count') || (4000 as unknown as string));
 
     const count = api.count;
 
@@ -139,7 +140,7 @@ function init() {
 
     // gui
 
-    gui = renderer.inspector.createParameters('Settings');
+    gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(api, 'renderBundle').name('render bundle').onChange(reload);
 
     gui.add(api, 'webgpu').onChange(reload);
@@ -160,7 +161,7 @@ function init() {
         camera.updateProjectionMatrix();
 
         renderer.setSize(width, height);
-        group.needsUpdate = true;
+        (group as THREE.BundleGroup).needsUpdate = true;
     }
 
     function reload() {
diff --git a/examples-testing/examples/webgpu_pmrem_cubemap.ts b/examples-testing/examples/webgpu_pmrem_cubemap.ts
index bd751ba33..9f58dc8b0 100644
--- a/examples-testing/examples/webgpu_pmrem_cubemap.ts
+++ b/examples-testing/examples/webgpu_pmrem_cubemap.ts
@@ -5,7 +5,7 @@ import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_pmrem_equirectangular.ts b/examples-testing/examples/webgpu_pmrem_equirectangular.ts
index 564b7a8d1..a34e25056 100644
--- a/examples-testing/examples/webgpu_pmrem_equirectangular.ts
+++ b/examples-testing/examples/webgpu_pmrem_equirectangular.ts
@@ -5,7 +5,7 @@ import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_pmrem_scene.ts b/examples-testing/examples/webgpu_pmrem_scene.ts
index deab005fc..36ca1c7d1 100644
--- a/examples-testing/examples/webgpu_pmrem_scene.ts
+++ b/examples-testing/examples/webgpu_pmrem_scene.ts
@@ -5,7 +5,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 init();
 
@@ -84,7 +84,7 @@ async function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(pmremRoughness, 'value', 0, 1, 0.001)
         .name('roughness')
         .onChange(() => render());
diff --git a/examples-testing/examples/webgpu_pmrem_test.ts b/examples-testing/examples/webgpu_pmrem_test.ts
index 3e1ea3ef9..e0e11ef81 100644
--- a/examples-testing/examples/webgpu_pmrem_test.ts
+++ b/examples-testing/examples/webgpu_pmrem_test.ts
@@ -1,11 +1,11 @@
-import * as THREE from 'three';
+import * as THREE from 'three/webgpu';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let scene, camera, controls, renderer;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls, renderer: THREE.WebGPURenderer;
 
 async function init() {
     const width = window.innerWidth;
@@ -64,15 +64,17 @@ async function init() {
     // angle of the pixel in steradians. This image is 1024 x 512,
     // so the value is 1 / ( sin( phi ) * ( pi / 512 ) ^ 2 ) = 27,490 nits.
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add({ enabled: true }, 'enabled')
         .name('PMREM')
         .onChange(value => {
             directionalLight.intensity = value ? 0 : 1;
 
             scene.traverse(function (child) {
-                if (child.isMesh) {
-                    child.material.envMapIntensity = 1 - directionalLight.intensity;
+                if ((child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhysicalNodeMaterial>).isMesh) {
+                    (
+                        child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhysicalNodeMaterial>
+                    ).material.envMapIntensity = 1 - directionalLight.intensity;
                 }
             });
         });
diff --git a/examples-testing/examples/webgpu_portal.ts b/examples-testing/examples/webgpu_portal.ts
index 3dc3ceb4f..52882cad2 100644
--- a/examples-testing/examples/webgpu_portal.ts
+++ b/examples-testing/examples/webgpu_portal.ts
@@ -17,10 +17,10 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, sceneMain, scenePortal, renderer;
-let clock;
+let camera: THREE.PerspectiveCamera, sceneMain: THREE.Scene, scenePortal: THREE.Scene, renderer: THREE.WebGPURenderer;
+let clock: THREE.Clock;
 
-const mixers = [];
+const mixers: THREE.AnimationMixer[] = [];
 
 init();
 
@@ -60,7 +60,7 @@ function init() {
 
     const loader = new GLTFLoader();
     loader.load('models/gltf/Xbot.glb', function (gltf) {
-        const createModel = (colorNode = null) => {
+        const createModel = (colorNode: THREE.Node<'vec3'> | null = null) => {
             let object;
 
             if (mixers.length === 0) {
@@ -70,10 +70,17 @@ function init() {
 
                 const children = object.children[0].children;
 
-                const applyFX = index => {
-                    children[index].material = children[index].material.clone();
-                    children[index].material.colorNode = colorNode;
-                    children[index].material.wireframe = true;
+                const applyFX = (index: number) => {
+                    (children[index] as THREE.SkinnedMesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material =
+                        (
+                            children[index] as THREE.SkinnedMesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>
+                        ).material.clone();
+                    (
+                        children[index] as THREE.SkinnedMesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>
+                    ).material.colorNode = colorNode;
+                    (
+                        children[index] as THREE.SkinnedMesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>
+                    ).material.wireframe = true;
                 };
 
                 applyFX(0);
diff --git a/examples-testing/examples/webgpu_postprocessing.ts b/examples-testing/examples/webgpu_postprocessing.ts
index 9bbbceb12..aed754f55 100644
--- a/examples-testing/examples/webgpu_postprocessing.ts
+++ b/examples-testing/examples/webgpu_postprocessing.ts
@@ -4,8 +4,8 @@ import { dotScreen } from 'three/addons/tsl/display/DotScreenNode.js';
 import { rgbShift } from 'three/addons/tsl/display/RGBShiftNode.js';
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, renderer, postProcessing;
-let object;
+let camera: THREE.PerspectiveCamera, renderer: THREE.WebGPURenderer, postProcessing: THREE.PostProcessing;
+let object: THREE.Object3D;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_postprocessing_3dlut.ts b/examples-testing/examples/webgpu_postprocessing_3dlut.ts
index f23b09c18..0bae944cf 100644
--- a/examples-testing/examples/webgpu_postprocessing_3dlut.ts
+++ b/examples-testing/examples/webgpu_postprocessing_3dlut.ts
@@ -18,21 +18,31 @@ import {
     uniform,
     renderOutput,
 } from 'three/tsl';
-import { lut3D } from 'three/addons/tsl/display/Lut3DNode.js';
+import Lut3DNode, { lut3D } from 'three/addons/tsl/display/Lut3DNode.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
-import { LUTCubeLoader } from 'three/addons/loaders/LUTCubeLoader.js';
-import { LUT3dlLoader } from 'three/addons/loaders/LUT3dlLoader.js';
-import { LUTImageLoader } from 'three/addons/loaders/LUTImageLoader.js';
+import { LUTCubeLoader, LUTCubeResult } from 'three/addons/loaders/LUTCubeLoader.js';
+import { LUT3dlLoader, LUT3dlResult } from 'three/addons/loaders/LUT3dlLoader.js';
+import { LUTImageLoader, LUTImageResult } from 'three/addons/loaders/LUTImageLoader.js';
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-const params = {
+const params: { lut: keyof typeof lutMap; intensity: number } = {
     lut: 'Bourbon 64.CUBE',
     intensity: 1,
 };
 
-const lutMap = {
+const lutMap: {
+    'Bourbon 64.CUBE': LUTCubeResult | Promise<LUTCubeResult> | null;
+    'Chemical 168.CUBE': LUTCubeResult | Promise<LUTCubeResult> | null;
+    'Clayton 33.CUBE': LUTCubeResult | Promise<LUTCubeResult> | null;
+    'Cubicle 99.CUBE': LUTCubeResult | Promise<LUTCubeResult> | null;
+    'Remy 24.CUBE': LUTCubeResult | Promise<LUTCubeResult> | null;
+    'Presetpro-Cinematic.3dl': LUT3dlResult | Promise<LUT3dlResult> | null;
+    NeutralLUT: LUTImageResult | Promise<LUTImageResult> | null;
+    'B&WLUT': LUTImageResult | Promise<LUTImageResult> | null;
+    NightLUT: LUTImageResult | Promise<LUTImageResult> | null;
+} = {
     'Bourbon 64.CUBE': null,
     'Chemical 168.CUBE': null,
     'Clayton 33.CUBE': null,
@@ -44,7 +54,12 @@ const lutMap = {
     NightLUT: null,
 };
 
-let camera, scene, renderer, postProcessing, controls, lutPass;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    postProcessing: THREE.PostProcessing,
+    controls: OrbitControls,
+    lutPass: Lut3DNode;
 
 init();
 
@@ -67,11 +82,13 @@ async function init() {
 
     for (const name in lutMap) {
         if (/\.CUBE$/i.test(name)) {
-            lutMap[name] = lutCubeLoader.loadAsync('luts/' + name);
+            (lutMap as unknown as Record<string, Promise<LUTCubeResult>>)[name] = lutCubeLoader.loadAsync(
+                'luts/' + name,
+            );
         } else if (/\LUT$/i.test(name)) {
-            lutMap[name] = lutImageLoader.loadAsync(`luts/${name}.png`);
+            (lutMap as Record<string, Promise<LUTImageResult>>)[name] = lutImageLoader.loadAsync(`luts/${name}.png`);
         } else {
-            lutMap[name] = lut3dlLoader.loadAsync('luts/' + name);
+            (lutMap as Record<string, Promise<LUT3dlResult>>)[name] = lut3dlLoader.loadAsync('luts/' + name);
         }
     }
 
@@ -79,13 +96,17 @@ async function init() {
     await Promise.all(pendings);
 
     for (const name in lutMap) {
-        lutMap[name] = await lutMap[name];
+        (lutMap as Record<string, LUTCubeResult | LUT3dlResult | LUTImageResult>)[name] = await (
+            lutMap as Record<string, Promise<LUTCubeResult | LUT3dlResult | LUTImageResult>>
+        )[name];
     }
 
     // baked model
 
     gltfLoader.load('./models/gltf/coffeeMug.glb', gltf => {
-        gltf.scene.getObjectByName('baked').material.map.anisotropy = 8;
+        (
+            gltf.scene.getObjectByName('baked') as THREE.Mesh<THREE.BufferGeometry, THREE.MeshBasicMaterial>
+        ).material.map!.anisotropy = 8;
         scene.add(gltf.scene);
     });
 
@@ -184,7 +205,7 @@ async function init() {
     const scenePass = pass(scene, camera);
     const outputPass = renderOutput(scenePass);
 
-    const lut = lutMap[params.lut];
+    const lut = lutMap[params.lut] as LUTCubeResult | LUT3dlResult | LUTImageResult;
     lutPass = lut3D(outputPass, texture3D(lut.texture3D), lut.texture3D.image.width, uniform(1));
 
     postProcessing.outputNode = lutPass;
@@ -199,8 +220,8 @@ async function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Settings');
-    gui.add(params, 'lut', Object.keys(lutMap));
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
+    gui.add(params, 'lut', Object.keys(lutMap) as (keyof typeof lutMap)[]);
     gui.add(params, 'intensity', 0, 1);
 
     window.addEventListener('resize', onWindowResize);
@@ -216,10 +237,10 @@ function onWindowResize() {
 async function animate() {
     controls.update();
 
-    lutPass.intensityNode.value = params.intensity;
+    (lutPass.intensityNode as THREE.UniformNode<'float', number>).value = params.intensity;
 
     if (lutMap[params.lut]) {
-        const lut = lutMap[params.lut];
+        const lut = lutMap[params.lut] as LUTCubeResult | LUT3dlResult | LUTImageResult;
         lutPass.lutNode.value = lut.texture3D;
         lutPass.size.value = lut.texture3D.image.width;
     }
diff --git a/examples-testing/examples/webgpu_postprocessing_afterimage.ts b/examples-testing/examples/webgpu_postprocessing_afterimage.ts
index 88a0c635d..fe398d4a1 100644
--- a/examples-testing/examples/webgpu_postprocessing_afterimage.ts
+++ b/examples-testing/examples/webgpu_postprocessing_afterimage.ts
@@ -13,12 +13,12 @@ import {
     sin,
     cos,
 } from 'three/tsl';
-import { afterImage } from 'three/addons/tsl/display/AfterImageNode.js';
+import AfterImageNode, { afterImage } from 'three/addons/tsl/display/AfterImageNode.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, particles;
-let postProcessing, afterImagePass, scenePass;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, particles: THREE.Sprite;
+let postProcessing: THREE.PostProcessing, afterImagePass: AfterImageNode, scenePass: THREE.PassNode;
 
 const params = {
     damp: uniform(0.8, 'float').setName('damp'),
@@ -72,13 +72,13 @@ function init() {
 
     const material = new THREE.SpriteNodeMaterial({ blending: THREE.AdditiveBlending, depthWrite: false });
 
-    const localTime = instancedBufferAttribute(timeAttribute).add(time.mul(0.1));
+    const localTime = instancedBufferAttribute<'float'>(timeAttribute).add(time.mul(0.1));
     const modTime = mod(localTime, 1.0);
     const accTime = modTime.mul(modTime);
 
     const angle = accTime.mul(40.0);
     const pulse = vec2(sin(angle).mul(20.0), cos(angle).mul(20.0));
-    const pos = instancedBufferAttribute(positionAttribute);
+    const pos = instancedBufferAttribute<'vec3'>(positionAttribute);
 
     const animated = vec3(
         pos.x.mul(accTime).add(pulse.x),
@@ -107,8 +107,8 @@ function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Settings');
-    gui.add(afterImagePass.damp, 'value', 0.25, 1);
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
+    gui.add(afterImagePass.damp as THREE.UniformNode<'float', number>, 'value', 0.25, 1);
     gui.add(params, 'enabled').onChange(updatePassChain);
 
     window.addEventListener('resize', onWindowResize);
@@ -124,7 +124,7 @@ function updatePassChain() {
     postProcessing.needsUpdate = true;
 }
 
-function getRandomPointOnSphere(r, v) {
+function getRandomPointOnSphere(r: number, v: THREE.Vector3) {
     const angle = Math.random() * Math.PI * 2;
     const u = Math.random() * 2 - 1;
 
@@ -144,7 +144,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function animate(time) {
+function animate(time: number) {
     particles.rotation.z = time * 0.001;
 
     postProcessing.render();
diff --git a/examples-testing/examples/webgpu_postprocessing_anamorphic.ts b/examples-testing/examples/webgpu_postprocessing_anamorphic.ts
index 65ddd7375..58bbbc744 100644
--- a/examples-testing/examples/webgpu_postprocessing_anamorphic.ts
+++ b/examples-testing/examples/webgpu_postprocessing_anamorphic.ts
@@ -9,8 +9,8 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
-let postProcessing;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let postProcessing: THREE.PostProcessing;
 
 const params = {
     resolutionScale: 0.2,
@@ -77,7 +77,7 @@ async function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(intensity, 'value', 0, 4, 0.1).name('intensity');
     gui.add(threshold, 'value', 0.8, 3, 0.001).name('threshold');
     gui.add(scaleNode, 'value', 1, 10, 0.1).name('scale');
diff --git a/examples-testing/examples/webgpu_postprocessing_ao.ts b/examples-testing/examples/webgpu_postprocessing_ao.ts
index 8464a9ae0..e4b207d2e 100644
--- a/examples-testing/examples/webgpu_postprocessing_ao.ts
+++ b/examples-testing/examples/webgpu_postprocessing_ao.ts
@@ -13,8 +13,8 @@ import {
     colorToDirection,
     colorSpaceToWorking,
 } from 'three/tsl';
-import { ao } from 'three/addons/tsl/display/GTAONode.js';
-import { traa } from 'three/addons/tsl/display/TRAANode.js';
+import GTAONode, { ao } from 'three/addons/tsl/display/GTAONode.js';
+import TRAANode, { traa } from 'three/addons/tsl/display/TRAANode.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
@@ -23,9 +23,13 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, postProcessing, controls;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    postProcessing: THREE.PostProcessing,
+    controls: OrbitControls;
 
-let aoPass, traaPass;
+let aoPass: GTAONode, traaPass: TRAANode;
 
 const params = {
     samples: 16,
@@ -115,7 +119,7 @@ async function init() {
     aoPass.resolutionScale = 0.5; // running AO in half resolution is often sufficient
     aoPass.useTemporalFiltering = true;
 
-    const aoPassOutput = aoPass.getTextureNode('output');
+    const aoPassOutput = aoPass.getTextureNode();
 
     // scene context
 
@@ -162,7 +166,7 @@ async function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(params, 'samples', 4, 32, 1).onChange(updateParameters);
     gui.add(params, 'distanceExponent', 1, 2).onChange(updateParameters);
     gui.add(params, 'distanceFallOff', 0.01, 1).onChange(updateParameters);
diff --git a/examples-testing/examples/webgpu_postprocessing_bloom.ts b/examples-testing/examples/webgpu_postprocessing_bloom.ts
index f0ebcefa4..d0dbc81d4 100644
--- a/examples-testing/examples/webgpu_postprocessing_bloom.ts
+++ b/examples-testing/examples/webgpu_postprocessing_bloom.ts
@@ -7,8 +7,11 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let camera;
-let postProcessing, renderer, mixer, clock;
+let camera: THREE.PerspectiveCamera;
+let postProcessing: THREE.PostProcessing,
+    renderer: THREE.WebGPURenderer,
+    mixer: THREE.AnimationMixer,
+    clock: THREE.Clock;
 
 const params = {
     threshold: 0,
@@ -73,7 +76,7 @@ async function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     const bloomFolder = gui.addFolder('bloom');
 
diff --git a/examples-testing/examples/webgpu_postprocessing_bloom_emissive.ts b/examples-testing/examples/webgpu_postprocessing_bloom_emissive.ts
index 20d0a36eb..3e6d4e06d 100644
--- a/examples-testing/examples/webgpu_postprocessing_bloom_emissive.ts
+++ b/examples-testing/examples/webgpu_postprocessing_bloom_emissive.ts
@@ -9,8 +9,8 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
-let postProcessing;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let postProcessing: THREE.PostProcessing;
 
 init();
 
@@ -79,7 +79,7 @@ function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     const bloomFolder = gui.addFolder('Bloom');
     bloomFolder.add(bloomPass.strength, 'value', 0.0, 5.0).name('strength');
diff --git a/examples-testing/examples/webgpu_postprocessing_bloom_selective.ts b/examples-testing/examples/webgpu_postprocessing_bloom_selective.ts
index 48ea482e6..cd91c5d72 100644
--- a/examples-testing/examples/webgpu_postprocessing_bloom_selective.ts
+++ b/examples-testing/examples/webgpu_postprocessing_bloom_selective.ts
@@ -86,16 +86,17 @@ window.addEventListener('pointerdown', event => {
     const intersects = raycaster.intersectObjects(scene.children, false);
 
     if (intersects.length > 0) {
-        const material = intersects[0].object.material;
+        const material = (intersects[0].object as THREE.Mesh<THREE.IcosahedronGeometry, THREE.MeshBasicNodeMaterial>)
+            .material;
 
-        const bloomIntensity = material.mrtNode.get('bloomIntensity');
+        const bloomIntensity = material.mrtNode!.get('bloomIntensity') as THREE.UniformNode<'float', number>;
         bloomIntensity.value = bloomIntensity.value === 0 ? 1 : 0;
     }
 });
 
 // gui
 
-const gui = renderer.inspector.createParameters('Settings');
+const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
 const bloomFolder = gui.addFolder('Bloom');
 bloomFolder.add(bloomPass.threshold, 'value', 0.0, 1.0).name('threshold');
diff --git a/examples-testing/examples/webgpu_postprocessing_ca.ts b/examples-testing/examples/webgpu_postprocessing_ca.ts
index 646cd7f0f..d3bcec61d 100644
--- a/examples-testing/examples/webgpu_postprocessing_ca.ts
+++ b/examples-testing/examples/webgpu_postprocessing_ca.ts
@@ -17,8 +17,12 @@ const params = {
     cameraDistance: 40,
 };
 
-let camera, scene, renderer, clock, mainGroup;
-let controls, postProcessing;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    clock: THREE.Clock,
+    mainGroup: THREE.Group;
+let controls: OrbitControls, postProcessing: THREE.PostProcessing;
 
 init();
 
@@ -86,7 +90,7 @@ async function init() {
 
     // GUI
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     gui.add(params, 'enabled').onChange(value => {
         postProcessing.outputNode = value ? caPass : outputPass;
@@ -108,8 +112,8 @@ async function init() {
 }
 
 function createShapes() {
-    const shapes = [];
-    const materials = [];
+    const shapes: THREE.Object3D[] = [];
+    const materials: THREE.MeshStandardMaterial[] = [];
 
     // Define colors for different materials
     const colors = [
@@ -245,7 +249,7 @@ function animate() {
                 // Central group
                 child.rotation.y = time * 0.5;
                 child.children.forEach((subChild, subIndex) => {
-                    if (subChild.geometry) {
+                    if ((subChild as THREE.Mesh).geometry) {
                         subChild.rotation.x = time * (1 + subIndex * 0.1);
                         subChild.rotation.z = time * (1 - subIndex * 0.1);
                     }
diff --git a/examples-testing/examples/webgpu_postprocessing_difference.ts b/examples-testing/examples/webgpu_postprocessing_difference.ts
index 9c5a47472..e5e98e026 100644
--- a/examples-testing/examples/webgpu_postprocessing_difference.ts
+++ b/examples-testing/examples/webgpu_postprocessing_difference.ts
@@ -9,8 +9,8 @@ const params = {
     speed: 0,
 };
 
-let camera, renderer, postProcessing;
-let timer, mesh, controls;
+let camera: THREE.PerspectiveCamera, renderer: THREE.WebGPURenderer, postProcessing: THREE.PostProcessing;
+let timer: THREE.Timer, mesh: THREE.Mesh, controls: OrbitControls;
 
 init();
 
@@ -71,7 +71,7 @@ function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(params, 'speed', 0, 2);
 }
 
diff --git a/examples-testing/examples/webgpu_postprocessing_dof.ts b/examples-testing/examples/webgpu_postprocessing_dof.ts
index 1ab1e7cbb..31b407f98 100644
--- a/examples-testing/examples/webgpu_postprocessing_dof.ts
+++ b/examples-testing/examples/webgpu_postprocessing_dof.ts
@@ -7,12 +7,16 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 //
 
-let camera, scene, renderer, mesh, controls;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    mesh: THREE.InstancedMesh,
+    controls: OrbitControls;
 
 let width = window.innerWidth;
 let height = window.innerHeight;
 
-let postProcessing;
+let postProcessing: THREE.PostProcessing;
 
 init();
 
@@ -109,7 +113,7 @@ function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(effectController.focusDistance, 'value', 10.0, 3000.0).name('focus distance');
     gui.add(effectController.focalLength, 'value', 50, 750).name('focal length');
     gui.add(effectController.bokehScale, 'value', 1, 20).name('bokeh scale');
diff --git a/examples-testing/examples/webgpu_postprocessing_dof_basic.ts b/examples-testing/examples/webgpu_postprocessing_dof_basic.ts
index 32a04c2a6..f6fdda04d 100644
--- a/examples-testing/examples/webgpu_postprocessing_dof_basic.ts
+++ b/examples-testing/examples/webgpu_postprocessing_dof_basic.ts
@@ -11,7 +11,15 @@ import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 import TWEEN from 'three/addons/libs/tween.module.js';
 
-let camera, controls, scene, timer, renderer, model, mixer, raycaster, postProcessing;
+let camera: THREE.PerspectiveCamera,
+    controls: OrbitControls,
+    scene: THREE.Scene,
+    timer: THREE.Timer,
+    renderer: THREE.WebGPURenderer,
+    model: THREE.Group,
+    mixer: THREE.AnimationMixer,
+    raycaster: THREE.Raycaster,
+    postProcessing: THREE.PostProcessing;
 
 const pointerCoords = new THREE.Vector2();
 const focusPoint = new THREE.Vector3(1, 1.75, -0.4);
@@ -100,7 +108,7 @@ async function init() {
 
     // GUI
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(minDistance, 'value', 0, 3).name('min distance');
     gui.add(maxDistance, 'value', 0, 5).name('max distance');
     gui.add(blurSize, 'value', 1, 3, 1).name('blur size');
@@ -115,7 +123,7 @@ async function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     pointerCoords.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
 
     raycaster.setFromCamera(pointerCoords, camera);
diff --git a/examples-testing/examples/webgpu_postprocessing_fxaa.ts b/examples-testing/examples/webgpu_postprocessing_fxaa.ts
index ceac24914..5b4a2d98d 100644
--- a/examples-testing/examples/webgpu_postprocessing_fxaa.ts
+++ b/examples-testing/examples/webgpu_postprocessing_fxaa.ts
@@ -9,8 +9,12 @@ const params = {
     animated: false,
 };
 
-let camera, scene, renderer, clock, group;
-let postProcessing;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    clock: THREE.Clock,
+    group: THREE.Group;
+let postProcessing: THREE.PostProcessing;
 
 init();
 
@@ -93,7 +97,7 @@ async function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(params, 'enabled').onChange(value => {
         if (value === true) {
             postProcessing.outputNode = fxaaPass;
diff --git a/examples-testing/examples/webgpu_postprocessing_lensflare.ts b/examples-testing/examples/webgpu_postprocessing_lensflare.ts
index 5cee38e01..141adb21d 100644
--- a/examples-testing/examples/webgpu_postprocessing_lensflare.ts
+++ b/examples-testing/examples/webgpu_postprocessing_lensflare.ts
@@ -11,8 +11,8 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, controls;
-let postProcessing;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, controls: OrbitControls;
+let postProcessing: THREE.PostProcessing;
 
 init();
 
@@ -104,7 +104,7 @@ async function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     const bloomFolder = gui.addFolder('bloom');
     bloomFolder.add(bloomPass.strength, 'value', 0.0, 2.0).name('strength');
diff --git a/examples-testing/examples/webgpu_postprocessing_masking.ts b/examples-testing/examples/webgpu_postprocessing_masking.ts
index 160be467f..1898cd29b 100644
--- a/examples-testing/examples/webgpu_postprocessing_masking.ts
+++ b/examples-testing/examples/webgpu_postprocessing_masking.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three/webgpu';
 import { pass, texture } from 'three/tsl';
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, postProcessing, renderer;
-let box, torus;
+let camera: THREE.PerspectiveCamera, postProcessing: THREE.PostProcessing, renderer: THREE.WebGPURenderer;
+let box: THREE.Mesh, torus: THREE.Mesh;
 
 init();
 
@@ -53,7 +53,7 @@ function init() {
     const sceneMask1 = pass(maskScene1, camera).a;
     const sceneMask2 = pass(maskScene2, camera).a;
 
-    let compose = base;
+    let compose: THREE.Node<'vec4'> = base;
     compose = sceneMask1.mix(compose, texture(texture1));
     compose = sceneMask2.mix(compose, texture(texture2));
 
diff --git a/examples-testing/examples/webgpu_postprocessing_motion_blur.ts b/examples-testing/examples/webgpu_postprocessing_motion_blur.ts
index 0c97476ca..a686ba28e 100644
--- a/examples-testing/examples/webgpu_postprocessing_motion_blur.ts
+++ b/examples-testing/examples/webgpu_postprocessing_motion_blur.ts
@@ -8,10 +8,10 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
-let boxLeft, boxRight, model, mixer, clock;
-let postProcessing;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let boxLeft: THREE.Mesh, boxRight: THREE.Mesh, model: THREE.Group, mixer: THREE.AnimationMixer, clock: THREE.Clock;
+let postProcessing: THREE.PostProcessing;
+let controls: OrbitControls;
 
 const params = {
     speed: 1.0,
@@ -57,7 +57,7 @@ function init() {
         model.rotation.y = Math.PI / 2;
 
         model.traverse(function (child) {
-            if (child.isMesh) {
+            if ((child as THREE.Mesh).isMesh) {
                 child.castShadow = true;
                 child.receiveShadow = true;
             }
@@ -163,7 +163,7 @@ function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Motion Blur Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Motion Blur Settings');
     gui.add(controls, 'autoRotate');
     gui.add(blurAmount, 'value', 0, 3).name('blur amount');
     gui.add(params, 'speed', 0, 2);
diff --git a/examples-testing/examples/webgpu_postprocessing_outline.ts b/examples-testing/examples/webgpu_postprocessing_outline.ts
index e8b1fa489..2fa6c2639 100644
--- a/examples-testing/examples/webgpu_postprocessing_outline.ts
+++ b/examples-testing/examples/webgpu_postprocessing_outline.ts
@@ -1,16 +1,16 @@
 import * as THREE from 'three/webgpu';
 import { pass, uniform, time, oscSine } from 'three/tsl';
-import { outline } from 'three/addons/tsl/display/OutlineNode.js';
+import OutlineNode, { outline } from 'three/addons/tsl/display/OutlineNode.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
 
-let camera, scene, renderer, controls;
-let postProcessing, outlinePass;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, controls: OrbitControls;
+let postProcessing: THREE.PostProcessing, outlinePass: OutlineNode;
 
-let selectedObjects = [];
+let selectedObjects: THREE.Object3D[] = [];
 
 const raycaster = new THREE.Raycaster();
 const mouse = new THREE.Vector2();
@@ -164,7 +164,7 @@ function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(edgeStrength, 'value', 0.01, 10).name('edgeStrength');
     gui.add(edgeGlow, 'value', 0.0, 1).name('edgeGlow');
     gui.add(edgeThickness, 'value', 1, 4).name('edgeThickness');
@@ -187,7 +187,7 @@ function init() {
     renderer.domElement.style.touchAction = 'none';
     renderer.domElement.addEventListener('pointermove', onPointerMove);
 
-    function onPointerMove(event) {
+    function onPointerMove(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
         mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
@@ -196,7 +196,7 @@ function init() {
         checkIntersection();
     }
 
-    function addSelectedObject(object) {
+    function addSelectedObject(object: THREE.Object3D) {
         selectedObjects = [];
         selectedObjects.push(object);
     }
diff --git a/examples-testing/examples/webgpu_postprocessing_pixel.ts b/examples-testing/examples/webgpu_postprocessing_pixel.ts
index 01d72fce9..93cad6f71 100644
--- a/examples-testing/examples/webgpu_postprocessing_pixel.ts
+++ b/examples-testing/examples/webgpu_postprocessing_pixel.ts
@@ -6,8 +6,18 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 import { uniform } from 'three/tsl';
 import { pixelationPass } from 'three/addons/tsl/display/PixelationPassNode.js';
 
-let camera, scene, renderer, postProcessing, crystalMesh, clock;
-let effectController;
+let camera: THREE.OrthographicCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    postProcessing: THREE.PostProcessing,
+    crystalMesh: THREE.Mesh<THREE.IcosahedronGeometry, THREE.MeshPhongMaterial>,
+    clock: THREE.Clock;
+let effectController: {
+    pixelSize: THREE.UniformNode<'float', number>;
+    normalEdgeStrength: THREE.UniformNode<'float', number>;
+    depthEdgeStrength: THREE.UniformNode<'float', number>;
+    pixelAlignedPanning: boolean;
+};
 
 init();
 
@@ -35,7 +45,7 @@ function init() {
 
     const boxMaterial = new THREE.MeshPhongMaterial({ map: texChecker2 });
 
-    function addBox(boxSideLength, x, z, rotation) {
+    function addBox(boxSideLength: number, x: number, z: number, rotation: number) {
         const mesh = new THREE.Mesh(new THREE.BoxGeometry(boxSideLength, boxSideLength, boxSideLength), boxMaterial);
         mesh.castShadow = true;
         mesh.receiveShadow = true;
@@ -125,7 +135,7 @@ function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(effectController.pixelSize, 'value', 1, 16, 1).name('Pixel Size');
     gui.add(effectController.normalEdgeStrength, 'value', 0, 2, 0.05).name('Normal Edge Strength');
     gui.add(effectController.depthEdgeStrength, 'value', 0, 1, 0.05).name('Depth Edge Strength');
@@ -174,7 +184,7 @@ function animate() {
 
 // Helper functions
 
-function pixelTexture(texture) {
+function pixelTexture(texture: THREE.Texture) {
     texture.minFilter = THREE.NearestFilter;
     texture.magFilter = THREE.NearestFilter;
     texture.generateMipmaps = false;
@@ -184,25 +194,30 @@ function pixelTexture(texture) {
     return texture;
 }
 
-function easeInOutCubic(x) {
+function easeInOutCubic(x: number) {
     return x ** 2 * 3 - x ** 3 * 2;
 }
 
-function linearStep(x, edge0, edge1) {
+function linearStep(x: number, edge0: number, edge1: number) {
     const w = edge1 - edge0;
     const m = 1 / w;
     const y0 = -m * edge0;
     return THREE.MathUtils.clamp(y0 + m * x, 0, 1);
 }
 
-function stopGoEased(x, downtime, period) {
+function stopGoEased(x: number, downtime: number, period: number) {
     const cycle = (x / period) | 0;
     const tween = x - cycle * period;
     const linStep = easeInOutCubic(linearStep(tween, downtime, period));
     return cycle + linStep;
 }
 
-function pixelAlignFrustum(camera, aspectRatio, pixelsPerScreenWidth, pixelsPerScreenHeight) {
+function pixelAlignFrustum(
+    camera: THREE.OrthographicCamera,
+    aspectRatio: number,
+    pixelsPerScreenWidth: number,
+    pixelsPerScreenHeight: number,
+) {
     // 0. Get Pixel Grid Units
     const worldScreenWidth = (camera.right - camera.left) / camera.zoom;
     const worldScreenHeight = (camera.top - camera.bottom) / camera.zoom;
diff --git a/examples-testing/examples/webgpu_postprocessing_radial_blur.ts b/examples-testing/examples/webgpu_postprocessing_radial_blur.ts
index 4725ad9cb..a2fdd93fb 100644
--- a/examples-testing/examples/webgpu_postprocessing_radial_blur.ts
+++ b/examples-testing/examples/webgpu_postprocessing_radial_blur.ts
@@ -9,8 +9,12 @@ const params = {
     animated: true,
 };
 
-let camera, scene, renderer, timer, group;
-let postProcessing;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    timer: THREE.Timer,
+    group: THREE.Group;
+let postProcessing: THREE.PostProcessing;
 
 init();
 
@@ -111,7 +115,7 @@ async function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(weightUniform, 'value', 0, 1).name('weight');
     gui.add(decayUniform, 'value', 0, 1).name('decay');
     gui.add(countUniform, 'value', 16, 64, 1).name('sample count');
diff --git a/examples-testing/examples/webgpu_postprocessing_smaa.ts b/examples-testing/examples/webgpu_postprocessing_smaa.ts
index acbb9ffb3..410b804fc 100644
--- a/examples-testing/examples/webgpu_postprocessing_smaa.ts
+++ b/examples-testing/examples/webgpu_postprocessing_smaa.ts
@@ -4,7 +4,10 @@ import { smaa } from 'three/addons/tsl/display/SMAANode.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, postProcessing;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    postProcessing: THREE.PostProcessing;
 
 const params = {
     enabled: true,
@@ -57,7 +60,7 @@ function init() {
 
     window.addEventListener('resize', onWindowResize);
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     const smaaFolder = gui.addFolder('SMAA');
     smaaFolder.add(params, 'enabled').onChange(value => {
diff --git a/examples-testing/examples/webgpu_postprocessing_sobel.ts b/examples-testing/examples/webgpu_postprocessing_sobel.ts
index 21beb67a8..6a95616ec 100644
--- a/examples-testing/examples/webgpu_postprocessing_sobel.ts
+++ b/examples-testing/examples/webgpu_postprocessing_sobel.ts
@@ -7,8 +7,8 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, controls;
-let postProcessing;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, controls: OrbitControls;
+let postProcessing: THREE.PostProcessing;
 
 const params = {
     enabled: true,
@@ -26,7 +26,7 @@ async function init() {
 
     const loader = new GLTFLoader();
     const gltf = await loader.loadAsync('models/gltf/DragonAttenuation.glb');
-    const model = gltf.scene.children[1];
+    const model = gltf.scene.children[1] as THREE.Mesh;
     model.material = new THREE.MeshStandardNodeMaterial();
 
     scene.add(model);
@@ -68,7 +68,7 @@ async function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     gui.add(params, 'enabled');
 
     //
diff --git a/examples-testing/examples/webgpu_postprocessing_ssaa.ts b/examples-testing/examples/webgpu_postprocessing_ssaa.ts
index 68a480683..b6d9684f6 100644
--- a/examples-testing/examples/webgpu_postprocessing_ssaa.ts
+++ b/examples-testing/examples/webgpu_postprocessing_ssaa.ts
@@ -1,11 +1,11 @@
 import * as THREE from 'three/webgpu';
-import { ssaaPass } from 'three/addons/tsl/display/SSAAPassNode.js';
+import SSAAPassNode, { ssaaPass } from 'three/addons/tsl/display/SSAAPassNode.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let scene, mesh, renderer, postProcessing;
-let camera, ssaaRenderPass;
-let timer;
+let scene: THREE.Scene, mesh: THREE.InstancedMesh, renderer: THREE.WebGPURenderer, postProcessing: THREE.PostProcessing;
+let camera: THREE.PerspectiveCamera, ssaaRenderPass: SSAAPassNode;
+let timer: THREE.Timer;
 
 const params = {
     sampleLevel: 3,
@@ -102,7 +102,7 @@ function init() {
 
     // GUI
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     gui.add(params, 'sampleLevel', {
         'Level 0: 1 Sample': 0,
@@ -139,7 +139,7 @@ function animate() {
         mesh.rotation.y += delta * 0.5;
     }
 
-    let newColor = ssaaRenderPass.clearColor;
+    let newColor: THREE.ColorRepresentation = ssaaRenderPass.clearColor;
 
     switch (params.clearColor) {
         case 'blue':
@@ -164,7 +164,7 @@ function animate() {
 
     ssaaRenderPass.sampleLevel = params.sampleLevel;
 
-    camera.view.offsetX = params.viewOffsetX;
+    camera.view!.offsetX = params.viewOffsetX;
 
     postProcessing.render();
 }
diff --git a/examples-testing/examples/webgpu_postprocessing_ssgi.ts b/examples-testing/examples/webgpu_postprocessing_ssgi.ts
index 087a8444e..241471a92 100644
--- a/examples-testing/examples/webgpu_postprocessing_ssgi.ts
+++ b/examples-testing/examples/webgpu_postprocessing_ssgi.ts
@@ -20,7 +20,11 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, postProcessing, controls;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    postProcessing: THREE.PostProcessing,
+    controls: OrbitControls;
 
 init();
 
@@ -199,7 +203,7 @@ async function init() {
 
     const types = { Combined: 0, Direct: 3, AO: 1, GI: 2 };
 
-    const gui = renderer.inspector.createParameters('SSGI settings');
+    const gui = (renderer.inspector as Inspector).createParameters('SSGI settings');
     gui.add(params, 'output', types).onChange(updatePostprocessing);
     gui.add(giPass.sliceCount, 'value', 1, 4, 1).name('slice count');
     gui.add(giPass.stepCount, 'value', 1, 32, 1).name('step count');
@@ -213,7 +217,7 @@ async function init() {
     gui.add(giPass.useScreenSpaceSampling, 'value').name('screen-space sampling');
     gui.add(giPass, 'useTemporalFiltering').name('temporal filtering').onChange(updatePostprocessing);
 
-    function updatePostprocessing(value) {
+    function updatePostprocessing(value: number | boolean) {
         if (value === 1) {
             postProcessing.outputNode = vec4(vec3(ao), 1);
         } else if (value === 2) {
diff --git a/examples-testing/examples/webgpu_postprocessing_ssr.ts b/examples-testing/examples/webgpu_postprocessing_ssr.ts
index 3b96c10c7..ca3e5186e 100644
--- a/examples-testing/examples/webgpu_postprocessing_ssr.ts
+++ b/examples-testing/examples/webgpu_postprocessing_ssr.ts
@@ -15,7 +15,7 @@ import {
     vec2,
     colorSpaceToWorking,
 } from 'three/tsl';
-import { ssr } from 'three/addons/tsl/display/SSRNode.js';
+import SSRNode, { ssr } from 'three/addons/tsl/display/SSRNode.js';
 import { smaa } from 'three/addons/tsl/display/SMAANode.js';
 
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
@@ -34,8 +34,13 @@ const params = {
     enabled: true,
 };
 
-let camera, scene, model, renderer, postProcessing, ssrPass;
-let controls;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    model: THREE.Group,
+    renderer: THREE.WebGPURenderer,
+    postProcessing: THREE.PostProcessing,
+    ssrPass: SSRNode;
+let controls: OrbitControls;
 
 init();
 
@@ -56,13 +61,12 @@ async function init() {
         model = gltf.scene;
 
         model.traverse(function (object) {
-            if (object.material) {
-                if (object.material.name === 'Lense_Casing') {
-                    object.material.transparent = true;
+            if ((object as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material) {
+                if ((object as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.name === 'Lense_Casing') {
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.transparent = true;
                 }
-
                 // Avoid overdrawing
-                object.material.side = THREE.FrontSide;
+                (object as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.side = THREE.FrontSide;
             }
         });
 
@@ -149,7 +153,7 @@ async function init() {
 
     // GUI
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
     const ssrFolder = gui.addFolder('SSR');
     ssrFolder.add(params, 'quality', 0, 1).onChange(updateParameters);
     ssrFolder.add(params, 'blurQuality', 1, 3, 1).onChange(updateParameters);
@@ -168,8 +172,8 @@ async function init() {
     const modelFolder = gui.addFolder('Model');
     modelFolder.add(params, 'roughness', 0, 1).onChange(value => {
         model.traverse(function (object) {
-            if (object.material) {
-                object.material.roughness = value;
+            if ((object as THREE.Mesh).material) {
+                (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.roughness = value;
             }
         });
     });
diff --git a/examples-testing/examples/webgpu_postprocessing_sss.ts b/examples-testing/examples/webgpu_postprocessing_sss.ts
index ac2bb2bae..3c1d3da40 100644
--- a/examples-testing/examples/webgpu_postprocessing_sss.ts
+++ b/examples-testing/examples/webgpu_postprocessing_sss.ts
@@ -8,7 +8,11 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, postProcessing, controls;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    postProcessing: THREE.PostProcessing,
+    controls: OrbitControls;
 
 init();
 
@@ -68,10 +72,10 @@ async function init() {
         scene.add(model);
 
         model.traverse(function (object) {
-            if (object.isMesh) {
+            if ((object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).isMesh) {
                 object.castShadow = true;
                 object.receiveShadow = true;
-                object.material.aoMap = null; // remove AO to better see the effect of shadows
+                (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.aoMap = null; // remove AO to better see the effect of shadows
             }
         });
     });
@@ -135,7 +139,7 @@ async function init() {
 
     const types = { 'Scene with Shadow Maps + SSS': 0, 'Scene with Shadow Maps': 1, SSS: 2 };
 
-    const gui = renderer.inspector.createParameters('SSS settings');
+    const gui = (renderer.inspector as Inspector).createParameters('SSS settings');
     gui.add(params, 'output', types).onChange(updatePostprocessing);
     gui.add(sssPass.shadowIntensity, 'value', 0, 1).name('shadow intensity');
     gui.add(sssPass.maxDistance, 'value', 0.01, 1).name('max ray distance');
diff --git a/examples-testing/examples/webgpu_postprocessing_traa.ts b/examples-testing/examples/webgpu_postprocessing_traa.ts
index eb138a8f3..91ffad479 100644
--- a/examples-testing/examples/webgpu_postprocessing_traa.ts
+++ b/examples-testing/examples/webgpu_postprocessing_traa.ts
@@ -4,7 +4,10 @@ import { traa } from 'three/addons/tsl/display/TRAANode.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, postProcessing;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    postProcessing: THREE.PostProcessing;
 let index = 0;
 
 init();
diff --git a/examples-testing/examples/webgpu_postprocessing_transition.ts b/examples-testing/examples/webgpu_postprocessing_transition.ts
index c4c88665c..ee47e6ddd 100644
--- a/examples-testing/examples/webgpu_postprocessing_transition.ts
+++ b/examples-testing/examples/webgpu_postprocessing_transition.ts
@@ -3,16 +3,32 @@ import * as THREE from 'three/webgpu';
 import TWEEN from 'three/addons/libs/tween.module.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
+import { ValueSlider } from 'three/addons/inspector/ui/Values.js';
 
 import { uniform, pass } from 'three/tsl';
-import { transition } from 'three/addons/tsl/display/TransitionNode.js';
+import TransitionNode, { transition } from 'three/addons/tsl/display/TransitionNode.js';
 
-let renderer, postProcessing, transitionController, transitionPass;
+let renderer: THREE.WebGPURenderer,
+    postProcessing: THREE.PostProcessing,
+    transitionController: ValueSlider<EffectController, 'transition'>,
+    transitionPass: TransitionNode;
 
-const textures = [];
+const textures: THREE.Texture[] = [];
 const clock = new THREE.Clock();
 
-const effectController = {
+interface EffectController {
+    animateScene: boolean;
+    animateTransition: boolean;
+    transition: number;
+    _transition: THREE.UniformNode<'float', number>;
+    useTexture: boolean;
+    _useTexture: THREE.UniformNode<'float', number>;
+    texture: number;
+    cycle: boolean;
+    threshold: THREE.UniformNode<'float', number>;
+}
+
+const effectController: EffectController = {
     animateScene: true,
     animateTransition: true,
     transition: 0,
@@ -24,7 +40,7 @@ const effectController = {
     threshold: uniform(0.1),
 };
 
-function generateInstancedMesh(geometry, material, count) {
+function generateInstancedMesh(geometry: THREE.BufferGeometry, material: THREE.MeshPhongNodeMaterial, count: number) {
     const mesh = new THREE.InstancedMesh(geometry, material, count);
 
     const dummy = new THREE.Object3D();
@@ -58,42 +74,54 @@ function generateInstancedMesh(geometry, material, count) {
     return mesh;
 }
 
-function FXScene(geometry, rotationSpeed, backgroundColor) {
-    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
-    camera.position.z = 20;
+class FXScene {
+    rotationSpeed: THREE.Vector3;
 
-    // Setup scene
-    const scene = new THREE.Scene();
-    scene.background = new THREE.Color(backgroundColor);
-    scene.add(new THREE.AmbientLight(0xaaaaaa, 3));
+    scene: THREE.Scene;
+    camera: THREE.PerspectiveCamera;
+    mesh: THREE.InstancedMesh;
 
-    const light = new THREE.DirectionalLight(0xffffff, 3);
-    light.position.set(0, 1, 4);
-    scene.add(light);
+    update: (delta: number) => void;
 
-    this.rotationSpeed = rotationSpeed;
+    resize: () => void;
 
-    const color = geometry.type === 'BoxGeometry' ? 0x0000ff : 0xff0000;
-    const material = new THREE.MeshPhongNodeMaterial({ color: color, flatShading: true });
-    const mesh = generateInstancedMesh(geometry, material, 500);
-    scene.add(mesh);
+    constructor(geometry: THREE.BufferGeometry, rotationSpeed: THREE.Vector3, backgroundColor: number) {
+        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
+        camera.position.z = 20;
 
-    this.scene = scene;
-    this.camera = camera;
-    this.mesh = mesh;
+        // Setup scene
+        const scene = new THREE.Scene();
+        scene.background = new THREE.Color(backgroundColor);
+        scene.add(new THREE.AmbientLight(0xaaaaaa, 3));
 
-    this.update = function (delta) {
-        if (effectController.animateScene) {
-            mesh.rotation.x += this.rotationSpeed.x * delta;
-            mesh.rotation.y += this.rotationSpeed.y * delta;
-            mesh.rotation.z += this.rotationSpeed.z * delta;
-        }
-    };
+        const light = new THREE.DirectionalLight(0xffffff, 3);
+        light.position.set(0, 1, 4);
+        scene.add(light);
+
+        this.rotationSpeed = rotationSpeed;
+
+        const color = geometry.type === 'BoxGeometry' ? 0x0000ff : 0xff0000;
+        const material = new THREE.MeshPhongNodeMaterial({ color: color, flatShading: true });
+        const mesh = generateInstancedMesh(geometry, material, 500);
+        scene.add(mesh);
 
-    this.resize = function () {
-        camera.aspect = window.innerWidth / window.innerHeight;
-        camera.updateProjectionMatrix();
-    };
+        this.scene = scene;
+        this.camera = camera;
+        this.mesh = mesh;
+
+        this.update = function (delta) {
+            if (effectController.animateScene) {
+                mesh.rotation.x += this.rotationSpeed.x * delta;
+                mesh.rotation.y += this.rotationSpeed.y * delta;
+                mesh.rotation.z += this.rotationSpeed.z * delta;
+            }
+        };
+
+        this.resize = function () {
+            camera.aspect = window.innerWidth / window.innerHeight;
+            camera.updateProjectionMatrix();
+        };
+    }
 }
 
 const fxSceneA = new FXScene(new THREE.BoxGeometry(2, 2, 2), new THREE.Vector3(0, -0.4, 0), 0xffffff);
@@ -131,7 +159,7 @@ function init() {
 
     postProcessing.outputNode = transitionPass;
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     gui.add(effectController, 'animateScene').name('Animate Scene');
     gui.add(effectController, 'animateTransition').name('Animate Transition');
diff --git a/examples-testing/examples/webgpu_procedural_texture.ts b/examples-testing/examples/webgpu_procedural_texture.ts
index 21fb4a3c2..d3a164bef 100644
--- a/examples-testing/examples/webgpu_procedural_texture.ts
+++ b/examples-testing/examples/webgpu_procedural_texture.ts
@@ -4,7 +4,7 @@ import { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 init();
 
@@ -51,7 +51,7 @@ function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Procedural Texture');
+    const gui = (renderer.inspector as Inspector).createParameters('Procedural Texture');
     gui.add(uvScale, 'value', 1, 10).name('uv scale ( before rtt )');
     gui.add(blurAmount, 'value', 0, 2).name('blur amount ( after rtt )');
     gui.add(proceduralToTexture, 'autoUpdate').name('auto update');
diff --git a/examples-testing/examples/webgpu_reflection.ts b/examples-testing/examples/webgpu_reflection.ts
index 76592b8cb..ad9d5018a 100644
--- a/examples-testing/examples/webgpu_reflection.ts
+++ b/examples-testing/examples/webgpu_reflection.ts
@@ -32,9 +32,9 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 import TWEEN from 'three/addons/libs/tween.module.js';
 
-let camera, scene, renderer;
-let postProcessing;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let postProcessing: THREE.PostProcessing;
+let controls: OrbitControls;
 
 // below uniforms will be animated via TWEEN.js
 
@@ -93,10 +93,10 @@ async function init() {
 
     const reflection = reflector({ resolutionScale: 0.2 });
     reflection.target.rotateX(-Math.PI / 2);
-    reflection.uvNode = reflection.uvNode.add(floorNormalOffset);
+    reflection.uvNode = reflection.uvNode!.add(floorNormalOffset);
     scene.add(reflection.target);
 
-    const floorMaterial = new THREE.MeshPhongNodeMaterial();
+    const floorMaterial = new THREE.MeshStandardNodeMaterial();
     floorMaterial.colorNode = texture(floorColor, floorUV);
     floorMaterial.emissiveNode = reflection.mul(0.25);
     floorMaterial.normalMap = floorNormal;
@@ -187,10 +187,10 @@ function createTreeMesh() {
     const maxSteps = 5;
     const lengthMult = 0.8;
 
-    const positions = [];
-    const normals = [];
-    const colors = [];
-    const data = []; // will save seed, size and time
+    const positions: number[] = [];
+    const normals: number[] = [];
+    const colors: number[] = [];
+    const data: number[] = []; // will save seed, size and time
 
     let instanceCount = 0;
 
@@ -199,9 +199,8 @@ function createTreeMesh() {
     const normal = new THREE.Vector3();
     const color = new THREE.Color();
 
-    function createTreePart(angle, x, y, z, length, count) {
+    function createTreePart(angle: number, x: number, y: number, z: number, length: number, count: number) {
         if (Math.random() > (maxSteps / count) * 0.25) return;
-
         if (count < maxSteps) {
             const newLength = length * lengthMult;
             const newX = x + Math.cos(angle) * length;
@@ -288,10 +287,10 @@ function createTreeMesh() {
 
     // TSL
 
-    const instancePosition = instancedBufferAttribute(attributePosition);
-    const instanceNormal = instancedBufferAttribute(attributeNormal);
-    const instanceColor = instancedBufferAttribute(attributeColor);
-    const instanceData = instancedBufferAttribute(attributeData);
+    const instancePosition = instancedBufferAttribute<'vec3'>(attributePosition);
+    const instanceNormal = instancedBufferAttribute<'vec3'>(attributeNormal);
+    const instanceColor = instancedBufferAttribute<'vec3'>(attributeColor);
+    const instanceData = instancedBufferAttribute<'vec3'>(attributeData);
 
     material.positionNode = Fn(() => {
         const instanceSize = instanceData.x;
@@ -308,7 +307,7 @@ function createTreeMesh() {
 
         // accumulate different vertex animations
 
-        let animated = positionLocal.add(instancePosition).toVar();
+        let animated: THREE.Node<'vec3'> = positionLocal.add(instancePosition).toVar();
         const direction = positionGeometry.normalize().toConst();
 
         animated = animated.add(direction.mul(effect.add(instanceSize)));
diff --git a/examples-testing/examples/webgpu_reflection_roughness.ts b/examples-testing/examples/webgpu_reflection_roughness.ts
index 84310f7c8..fbe0e1d22 100644
--- a/examples-testing/examples/webgpu_reflection_roughness.ts
+++ b/examples-testing/examples/webgpu_reflection_roughness.ts
@@ -6,8 +6,8 @@ import { UltraHDRLoader } from 'three/addons/loaders/UltraHDRLoader.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let controls: OrbitControls;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_refraction.ts b/examples-testing/examples/webgpu_refraction.ts
index d475ed2de..3d0c4e82b 100644
--- a/examples-testing/examples/webgpu_refraction.ts
+++ b/examples-testing/examples/webgpu_refraction.ts
@@ -5,11 +5,11 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
-let cameraControls;
+let cameraControls: OrbitControls;
 
-let smallSphere;
+let smallSphere: THREE.Mesh;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_rendertarget_2d-array_3d.ts b/examples-testing/examples/webgpu_rendertarget_2d-array_3d.ts
index 627fd6b18..9dc934c0f 100644
--- a/examples-testing/examples/webgpu_rendertarget_2d-array_3d.ts
+++ b/examples-testing/examples/webgpu_rendertarget_2d-array_3d.ts
@@ -5,11 +5,22 @@ import { TextureHelper } from 'three/addons/helpers/TextureHelperGPU.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { unzipSync } from 'three/addons/libs/fflate.module.js';
 
-let renderer;
-let views = [];
+let renderer: THREE.WebGPURenderer;
+let views: View[] = [];
 
 class View {
-    constructor(left, top, width, height) {
+    left: number;
+    top: number;
+    width: number;
+    height: number;
+
+    camera: THREE.PerspectiveCamera;
+
+    scene: THREE.Scene;
+
+    controls?: OrbitControls;
+
+    constructor(left: number, top: number, width: number, height: number) {
         this.left = left;
         this.top = top;
         this.width = width;
@@ -41,7 +52,7 @@ class View {
     }
 
     // Method to handle viewport resize
-    updateSize(left, top, width, height) {
+    updateSize(left: number, top: number, width: number, height: number) {
         this.left = left;
         this.top = top;
         this.width = width;
@@ -93,8 +104,8 @@ async function init() {
     };
 
     new THREE.FileLoader().setResponseType('arraybuffer').load('textures/3d/head256x256x109.zip', function (data) {
-        const zip = unzipSync(new Uint8Array(data));
-        const array = new Uint8Array(zip['head256x256x109'].buffer);
+        const zip = unzipSync(new Uint8Array(data as ArrayBuffer));
+        const array = new Uint8Array(zip['head256x256x109'].buffer as ArrayBuffer);
 
         const map3D = new THREE.Data3DTexture(array, size.width, size.height, size.depth);
         map3D.name = 'Data3DTexture';
@@ -109,7 +120,7 @@ async function init() {
         // 3D
         const helper3D = new TextureHelper(map3D, 10, 10, depth);
         helper3D.material.outputNode = vec4(
-            vec3(diffuseColor.r.mul(attribute('uvw').z.mul(diffuseColor.r))),
+            vec3(diffuseColor.r.mul(attribute<'vec3'>('uvw').z.mul(diffuseColor.r))),
             diffuseColor.r.mul(diffuseColor.a),
         );
         views[1].scene.add(helper3D);
@@ -135,7 +146,7 @@ async function init() {
 
         const helperArray = new TextureHelper(mapArray, 10, 10, depth);
         helperArray.material.outputNode = vec4(
-            vec3(diffuseColor.r.mul(attribute('uvw').z.div(size.depth).mul(diffuseColor.r))),
+            vec3(diffuseColor.r.mul(attribute<'vec3'>('uvw').z.div(size.depth).mul(diffuseColor.r))),
             diffuseColor.r.mul(diffuseColor.a),
         );
         views[0].scene.add(helperArray);
@@ -159,7 +170,7 @@ async function init() {
         const quadMesh = new THREE.QuadMesh(materialQuad);
 
         // In WebGPU we need to clear all the layers of the 3D render target before rendering to it (WebGPU limitation?)
-        if (renderer.backend.isWebGPUBackend) {
+        if ((renderer.backend as { isWebGPUBackend?: boolean }).isWebGPUBackend) {
             const materialClear = new THREE.NodeMaterial();
             materialClear.outputNode = vec4(0);
             const clearQuadMesh = new THREE.QuadMesh(materialClear);
@@ -218,7 +229,7 @@ function onWindowResize() {
 
 function animate() {
     views.forEach(view => {
-        view.controls.update();
+        view.controls!.update();
 
         const left = Math.floor(view.left * window.innerWidth);
         const bottom = Math.floor((1 - view.top - view.height) * window.innerHeight);
diff --git a/examples-testing/examples/webgpu_rtt.ts b/examples-testing/examples/webgpu_rtt.ts
index fa7577ea8..b4c7a8c39 100644
--- a/examples-testing/examples/webgpu_rtt.ts
+++ b/examples-testing/examples/webgpu_rtt.ts
@@ -3,12 +3,12 @@ import { texture, uniform, saturation, hue } from 'three/tsl';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 const mouse = new THREE.Vector2();
 
-let quadMesh, renderTarget;
+let quadMesh: THREE.QuadMesh, renderTarget: THREE.RenderTarget;
 
-let box;
+let box: THREE.Mesh;
 
 const dpr = window.devicePixelRatio;
 
@@ -65,7 +65,7 @@ function init() {
     quadMesh.name = 'Post-Processing';
 }
 
-function onWindowMouseMove(e) {
+function onWindowMouseMove(e: MouseEvent) {
     mouse.x = e.offsetX / window.innerWidth;
     mouse.y = e.offsetY / window.innerHeight;
 }
diff --git a/examples-testing/examples/webgpu_shadow_contact.ts b/examples-testing/examples/webgpu_shadow_contact.ts
index ac3e4fbd8..642347107 100644
--- a/examples-testing/examples/webgpu_shadow_contact.ts
+++ b/examples-testing/examples/webgpu_shadow_contact.ts
@@ -4,13 +4,13 @@ import { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer;
-let shadowCamera, shadowGroup;
-let renderTarget;
-let plane, fillPlane, cameraHelper;
-let depthMaterial, shadowPlaneMaterial, fillPlaneMaterial;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let shadowCamera: THREE.OrthographicCamera, shadowGroup: THREE.Group;
+let renderTarget: THREE.RenderTarget;
+let plane: THREE.Mesh<THREE.PlaneGeometry, THREE.NodeMaterial>, fillPlane, cameraHelper: THREE.CameraHelper;
+let depthMaterial: THREE.NodeMaterial, shadowPlaneMaterial: THREE.NodeMaterial, fillPlaneMaterial: THREE.NodeMaterial;
 
-const meshes = [];
+const meshes: THREE.Mesh[] = [];
 
 const PLANE_WIDTH = 2.5;
 const PLANE_HEIGHT = 2.5;
@@ -131,7 +131,7 @@ function init() {
         showWireframe: state.showWireframe,
     };
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     gui.add(params, 'shadowBlur', 0, 15, 0.1).onChange(() => {
         state.shadow.blur = params.shadowBlur;
diff --git a/examples-testing/examples/webgpu_shadowmap.ts b/examples-testing/examples/webgpu_shadowmap.ts
index 2d91d5843..d24bb27c0 100644
--- a/examples-testing/examples/webgpu_shadowmap.ts
+++ b/examples-testing/examples/webgpu_shadowmap.ts
@@ -5,9 +5,9 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, clock;
-let dirLight, spotLight;
-let torusKnot, dirGroup;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, clock: THREE.Clock;
+let dirLight: THREE.DirectionalLight, spotLight: THREE.SpotLight;
+let torusKnot: THREE.Mesh<THREE.TorusKnotGeometry, THREE.MeshPhongNodeMaterial>, dirGroup: THREE.Group;
 
 init();
 
@@ -163,7 +163,7 @@ function resize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function animate(time) {
+function animate(time: number) {
     const delta = clock.getDelta();
 
     torusKnot.rotation.x += 0.25 * delta;
diff --git a/examples-testing/examples/webgpu_shadowmap_array.ts b/examples-testing/examples/webgpu_shadowmap_array.ts
index 3797d5a9e..2274476f4 100644
--- a/examples-testing/examples/webgpu_shadowmap_array.ts
+++ b/examples-testing/examples/webgpu_shadowmap_array.ts
@@ -8,10 +8,10 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, clock;
-let dirLight;
-let torusKnot, dirGroup;
-let tsmHelper;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, clock: THREE.Clock;
+let dirLight: THREE.DirectionalLight;
+let torusKnot: THREE.Mesh<THREE.TorusKnotGeometry, THREE.MeshPhongNodeMaterial>, dirGroup: THREE.Group;
+let tsmHelper: TileShadowNodeHelper;
 
 init();
 
@@ -311,7 +311,7 @@ function resize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-async function animate(time) {
+async function animate(time: number) {
     const delta = clock.getDelta();
 
     // Rotate the central torus knot
diff --git a/examples-testing/examples/webgpu_shadowmap_csm.ts b/examples-testing/examples/webgpu_shadowmap_csm.ts
index 00a486a3a..d9c57bba5 100644
--- a/examples-testing/examples/webgpu_shadowmap_csm.ts
+++ b/examples-testing/examples/webgpu_shadowmap_csm.ts
@@ -4,12 +4,33 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-import { CSMShadowNode } from 'three/addons/csm/CSMShadowNode.js';
+import { CSMShadowNode, CSMShadowNodeMode } from 'three/addons/csm/CSMShadowNode.js';
 import { CSMHelper } from 'three/addons/csm/CSMHelper.js';
 
-let renderer, scene, camera, orthoCamera, controls, csm, csmHelper, csmDirectionalLight;
-
-const params = {
+let renderer: THREE.WebGPURenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    orthoCamera: THREE.OrthographicCamera,
+    controls: OrbitControls,
+    csm: CSMShadowNode,
+    csmHelper: CSMHelper,
+    csmDirectionalLight: THREE.DirectionalLight;
+
+const params: {
+    orthographic: boolean;
+    fade: boolean;
+    shadows: boolean;
+    maxFar: number;
+    mode: CSMShadowNodeMode;
+    lightX: number;
+    lightY: number;
+    lightZ: number;
+    margin: number;
+    shadowNear: number;
+    shadowFar: number;
+    autoUpdateHelper: boolean;
+    updateHelper: () => void;
+} = {
     orthographic: false,
     fade: false,
     shadows: true,
@@ -131,7 +152,7 @@ function init() {
         cube2.scale.y = Math.random() * 2 + 6;
     }
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     gui.add(params, 'orthographic').onChange(function (value) {
         csm.camera = value ? orthoCamera : camera;
@@ -201,8 +222,8 @@ function init() {
         .name('shadow near')
         .onChange(function (value) {
             for (let i = 0; i < csm.lights.length; i++) {
-                csm.lights[i].shadow.camera.near = value;
-                csm.lights[i].shadow.camera.updateProjectionMatrix();
+                csm.lights[i].shadow!.camera.near = value;
+                csm.lights[i].shadow!.camera.updateProjectionMatrix();
             }
         });
 
@@ -210,8 +231,8 @@ function init() {
         .name('shadow far')
         .onChange(function (value) {
             for (let i = 0; i < csm.lights.length; i++) {
-                csm.lights[i].shadow.camera.far = value;
-                csm.lights[i].shadow.camera.updateProjectionMatrix();
+                csm.lights[i].shadow!.camera.far = value;
+                csm.lights[i].shadow!.camera.updateProjectionMatrix();
             }
         });
 
diff --git a/examples-testing/examples/webgpu_shadowmap_progressive.ts b/examples-testing/examples/webgpu_shadowmap_progressive.ts
index 567f5288b..583c8f33a 100644
--- a/examples-testing/examples/webgpu_shadowmap_progressive.ts
+++ b/examples-testing/examples/webgpu_shadowmap_progressive.ts
@@ -11,17 +11,17 @@ import { ProgressiveLightMap } from 'three/addons/misc/ProgressiveLightMapGPU.js
 const shadowMapRes = 1024,
     lightMapRes = 1024,
     lightCount = 4;
-let camera,
-    scene,
-    renderer,
-    controls,
-    control,
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    controls: OrbitControls,
+    control: TransformControls,
     control2,
-    object = new THREE.Mesh(),
-    lightOrigin = null,
-    progressiveSurfacemap;
-const dirLights = [],
-    lightmapObjects = [];
+    object: THREE.Object3D = new THREE.Mesh(),
+    lightOrigin: THREE.Group,
+    progressiveSurfacemap: ProgressiveLightMap;
+const dirLights: THREE.DirectionalLight[] = [],
+    lightmapObjects: THREE.Object3D[] = [];
 const params = {
     Enable: true,
     'Blur Edges': true,
@@ -102,14 +102,14 @@ function init() {
     // model
     function loadModel() {
         object.traverse(function (child) {
-            if (child.isMesh) {
+            if ((child as THREE.Mesh).isMesh) {
                 child.name = 'Loaded Mesh';
                 child.castShadow = true;
                 child.receiveShadow = true;
-                child.material = new THREE.MeshPhongMaterial();
+                (child as THREE.Mesh).material = new THREE.MeshPhongMaterial();
 
                 // This adds the model to the lightmap
-                lightmapObjects.push(child);
+                lightmapObjects.push(child as THREE.Mesh);
                 progressiveSurfacemap.addObjectsToLightMap(lightmapObjects);
             } else {
                 child.layers.disableAll(); // Disable Rendering for this
@@ -153,7 +153,7 @@ function init() {
 }
 
 function createGUI() {
-    const gui = renderer.inspector.createParameters('Accumulation Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Accumulation Settings');
     gui.add(params, 'Enable');
     gui.add(params, 'Blur Edges');
     gui.add(params, 'Blend Window', 1, 500, 1);
diff --git a/examples-testing/examples/webgpu_shadowmap_vsm.ts b/examples-testing/examples/webgpu_shadowmap_vsm.ts
index 12fe5fe4a..8342b4af0 100644
--- a/examples-testing/examples/webgpu_shadowmap_vsm.ts
+++ b/examples-testing/examples/webgpu_shadowmap_vsm.ts
@@ -4,9 +4,9 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, clock;
-let dirLight, spotLight;
-let torusKnot, dirGroup;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, clock: THREE.Clock;
+let dirLight: THREE.DirectionalLight, spotLight: THREE.SpotLight;
+let torusKnot: THREE.Mesh, dirGroup: THREE.Group;
 
 const config = {
     spotlightRadius: 4,
@@ -23,7 +23,7 @@ function init() {
     initMisc();
 
     // Init gui
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     const spotlightFolder = gui.addFolder('Spotlight');
     spotlightFolder
@@ -178,7 +178,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function animate(time) {
+function animate(time: DOMHighResTimeStamp) {
     const delta = clock.getDelta();
 
     if (config.animate === true) {
diff --git a/examples-testing/examples/webgpu_skinning.ts b/examples-testing/examples/webgpu_skinning.ts
index e9c0548bd..0895db7fe 100644
--- a/examples-testing/examples/webgpu_skinning.ts
+++ b/examples-testing/examples/webgpu_skinning.ts
@@ -3,9 +3,9 @@ import { color, screenUV } from 'three/tsl';
 
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
-let mixer, clock;
+let mixer: THREE.AnimationMixer, clock: THREE.Clock;
 
 init();
 
diff --git a/examples-testing/examples/webgpu_skinning_instancing.ts b/examples-testing/examples/webgpu_skinning_instancing.ts
index 235f42404..e274d5f2d 100644
--- a/examples-testing/examples/webgpu_skinning_instancing.ts
+++ b/examples-testing/examples/webgpu_skinning_instancing.ts
@@ -4,10 +4,10 @@ import { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';
 
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let camera, scene, renderer;
-let postProcessing;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let postProcessing: THREE.PostProcessing;
 
-let mixer, clock;
+let mixer: THREE.AnimationMixer, clock: THREE.Clock;
 
 init();
 
@@ -52,7 +52,7 @@ function init() {
         const dummy = new THREE.Object3D();
 
         object.traverse(child => {
-            if (child.isMesh) {
+            if ((child as THREE.Mesh).isMesh) {
                 const oscNode = oscSine(time.mul(0.1));
 
                 // random colors between instances from 0x000000 to 0xFFFFFF
@@ -61,13 +61,20 @@ function init() {
                 // random [ 0, 1 ] values between instances
                 const randomMetalness = range(0, 1);
 
-                child.material = new THREE.MeshStandardNodeMaterial();
-                child.material.roughness = 0.1;
-                child.material.metalnessNode = mix(0.0, randomMetalness, oscNode);
-                child.material.colorNode = mix(color(0xffffff), randomColors, oscNode);
-
-                child.isInstancedMesh = true;
-                child.instanceMatrix = new THREE.InstancedBufferAttribute(new Float32Array(instanceCount * 16), 16);
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardNodeMaterial>).material =
+                    new THREE.MeshStandardNodeMaterial();
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardNodeMaterial>).material.roughness = 0.1;
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardNodeMaterial>).material.metalnessNode =
+                    mix(0.0, randomMetalness, oscNode);
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardNodeMaterial>).material.colorNode = mix(
+                    color(0xffffff),
+                    randomColors,
+                    oscNode,
+                );
+
+                (child as { isInstancedMesh?: boolean }).isInstancedMesh = true;
+                (child as THREE.InstancedMesh<THREE.BufferGeometry, THREE.MeshStandardNodeMaterial>).instanceMatrix =
+                    new THREE.InstancedBufferAttribute(new Float32Array(instanceCount * 16), 16);
                 child.count = instanceCount;
 
                 for (let i = 0; i < instanceCount; i++) {
@@ -76,7 +83,11 @@ function init() {
 
                     dummy.updateMatrix();
 
-                    dummy.matrix.toArray(child.instanceMatrix.array, i * 16);
+                    dummy.matrix.toArray(
+                        (child as THREE.InstancedMesh<THREE.BufferGeometry, THREE.MeshStandardNodeMaterial>)
+                            .instanceMatrix.array,
+                        i * 16,
+                    );
                 }
             }
         });
diff --git a/examples-testing/examples/webgpu_sky.ts b/examples-testing/examples/webgpu_sky.ts
index cd865eefe..5c7515e9a 100644
--- a/examples-testing/examples/webgpu_sky.ts
+++ b/examples-testing/examples/webgpu_sky.ts
@@ -5,9 +5,9 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { SkyMesh } from 'three/addons/objects/SkyMesh.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
-let sky, sun;
+let sky: SkyMesh, sun: THREE.Vector3;
 
 init();
 
@@ -47,7 +47,7 @@ function initSky() {
         renderer.toneMappingExposure = effectController.exposure;
     }
 
-    const gui = renderer.inspector.createParameters('Settings');
+    const gui = (renderer.inspector as Inspector).createParameters('Settings');
 
     gui.add(effectController, 'turbidity', 0.0, 20.0, 0.1).onChange(guiChanged);
     gui.add(effectController, 'rayleigh', 0.0, 4, 0.001).onChange(guiChanged);
diff --git a/examples-testing/examples/webgpu_sprites.ts b/examples-testing/examples/webgpu_sprites.ts
index de9f219b8..68a7b73a8 100644
--- a/examples-testing/examples/webgpu_sprites.ts
+++ b/examples-testing/examples/webgpu_sprites.ts
@@ -1,11 +1,11 @@
 import * as THREE from 'three/webgpu';
 import { texture, uv, userData, fog, rangeFogFactor, color } from 'three/tsl';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
-let map;
+let map: THREE.Texture;
 
-let group;
+let group: THREE.Group;
 
 let imageWidth = 1,
     imageHeight = 1;
diff --git a/examples-testing/examples/webgpu_storage_buffer.ts b/examples-testing/examples/webgpu_storage_buffer.ts
index 1b4461d33..0d3c1af80 100644
--- a/examples-testing/examples/webgpu_storage_buffer.ts
+++ b/examples-testing/examples/webgpu_storage_buffer.ts
@@ -2,8 +2,8 @@ import * as THREE from 'three/webgpu';
 import { storage, If, vec3, uv, uint, float, Fn, instanceIndex, workgroupBarrier } from 'three/tsl';
 
 const timestamps = {
-    webgpu: document.getElementById('timestamps'),
-    webgl: document.getElementById('timestamps_webgl'),
+    webgpu: document.getElementById('timestamps')!,
+    webgl: document.getElementById('timestamps_webgl')!,
 };
 
 // WebGPU Backend
@@ -26,7 +26,7 @@ async function init(forceWebGL = false) {
 
     const type = ['float', 'vec2', 'vec3', 'vec4'];
 
-    const arrayBufferNodes = [];
+    const arrayBufferNodes: THREE.StorageBufferNode<unknown>[] = [];
 
     for (let i = 0; i < type.length; i++) {
         const typeSize = i + 1;
@@ -34,7 +34,7 @@ async function init(forceWebGL = false) {
 
         const arrayBuffer = new THREE.StorageInstancedBufferAttribute(new Float32Array(array), typeSize);
 
-        arrayBufferNodes.push(storage(arrayBuffer, type[i], size).setPBO(true));
+        arrayBufferNodes.push(storage(arrayBuffer, type[i] as 'float', size).setPBO(true));
     }
 
     const computeInitOrder = Fn(() => {
diff --git a/examples-testing/examples/webgpu_struct_drawindirect.ts b/examples-testing/examples/webgpu_struct_drawindirect.ts
index b0d1139db..0f951bf23 100644
--- a/examples-testing/examples/webgpu_struct_drawindirect.ts
+++ b/examples-testing/examples/webgpu_struct_drawindirect.ts
@@ -45,7 +45,7 @@ scene.background = new THREE.Color(0x00001f);
 camera.position.set(1, 1, 1);
 const controls = new OrbitControls(camera, renderer.domElement);
 
-let computeDrawBuffer, computeInitDrawBuffer;
+let computeDrawBuffer: THREE.ComputeNode, computeInitDrawBuffer: THREE.ComputeNode;
 
 init();
 
@@ -139,15 +139,15 @@ async function init() {
         drawInfo.get('offset').assign(0);
     })().compute(1);
 
-    const vPosition = varyingProperty('vec3', 'vPosition');
-    const vColor = varyingProperty('vec4', 'vColor');
+    const vPosition = varyingProperty<'vec3'>('vec3', 'vPosition');
+    const vColor = varyingProperty<'vec4'>('vec4', 'vColor');
 
     const positionShaderParams = {
-        position: attribute('position'),
-        offset: attribute('offset'),
-        color: attribute('color'),
-        orientationStart: attribute('orientationStart'),
-        orientationEnd: attribute('orientationEnd'),
+        position: attribute<'vec3'>('position'),
+        offset: attribute<'vec3'>('offset'),
+        color: attribute<'vec4'>('color'),
+        orientationStart: attribute<'vec4'>('orientationStart'),
+        orientationEnd: attribute<'vec4'>('orientationEnd'),
         time: time,
     };
 
diff --git a/examples-testing/examples/webgpu_textures_2d-array.ts b/examples-testing/examples/webgpu_textures_2d-array.ts
index a1a354ff7..940a35c89 100644
--- a/examples-testing/examples/webgpu_textures_2d-array.ts
+++ b/examples-testing/examples/webgpu_textures_2d-array.ts
@@ -5,7 +5,10 @@ import { unzipSync } from 'three/addons/libs/fflate.module.js';
 
 //
 
-let camera, scene, mesh, renderer;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    mesh: THREE.Mesh<THREE.PlaneGeometry, THREE.MeshBasicNodeMaterial>,
+    renderer: THREE.WebGPURenderer;
 
 const planeWidth = 50;
 const planeHeight = 50;
@@ -24,14 +27,14 @@ function init() {
     // width 256, height 256, depth 109, 8-bit, zip archived raw data
 
     new THREE.FileLoader().setResponseType('arraybuffer').load('textures/3d/head256x256x109.zip', function (data) {
-        const zip = unzipSync(new Uint8Array(data));
-        const array = new Uint8Array(zip['head256x256x109'].buffer);
+        const zip = unzipSync(new Uint8Array(data as ArrayBuffer));
+        const array = new Uint8Array(zip['head256x256x109'].buffer as ArrayBuffer);
 
         const map = new THREE.DataArrayTexture(array, 256, 256, 109);
         map.format = THREE.RedFormat;
         map.needsUpdate = true;
 
-        let coord = uv();
+        let coord: THREE.Node<'vec2'> = uv();
         coord = coord.setY(coord.y.oneMinus()); // flip y
 
         let oscLayers = oscTriangle(time.mul(0.5)); // [ /\/ ] triangle osc animation
diff --git a/examples-testing/examples/webgpu_textures_2d-array_compressed.ts b/examples-testing/examples/webgpu_textures_2d-array_compressed.ts
index cb8ea8f3d..d17d8b487 100644
--- a/examples-testing/examples/webgpu_textures_2d-array_compressed.ts
+++ b/examples-testing/examples/webgpu_textures_2d-array_compressed.ts
@@ -6,7 +6,11 @@ import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
 
 //
 
-let camera, scene, mesh, renderer, clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    mesh: THREE.Mesh,
+    renderer: THREE.WebGPURenderer,
+    clock: THREE.Clock;
 
 const depth = uniform(0);
 
diff --git a/examples-testing/examples/webgpu_textures_anisotropy.ts b/examples-testing/examples/webgpu_textures_anisotropy.ts
index 0444823f5..fdcb1a01a 100644
--- a/examples-testing/examples/webgpu_textures_anisotropy.ts
+++ b/examples-testing/examples/webgpu_textures_anisotropy.ts
@@ -1,8 +1,8 @@
 import * as THREE from 'three/webgpu';
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene1, scene2, renderer;
+let camera: THREE.PerspectiveCamera, scene1: THREE.Scene, scene2: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 let mouseX = 0,
     mouseY = 0;
@@ -73,11 +73,11 @@ function init() {
     texture2.repeat.set(512, 512);
 
     if (maxAnisotropy > 0) {
-        document.getElementById('val_left').innerHTML = texture1.anisotropy;
-        document.getElementById('val_right').innerHTML = texture2.anisotropy;
+        document.getElementById('val_left')!.innerHTML = texture1.anisotropy.toString();
+        document.getElementById('val_right')!.innerHTML = texture2.anisotropy.toString();
     } else {
-        document.getElementById('val_left').innerHTML = 'not supported';
-        document.getElementById('val_right').innerHTML = 'not supported';
+        document.getElementById('val_left')!.innerHTML = 'not supported';
+        document.getElementById('val_right')!.innerHTML = 'not supported';
     }
 
     //
@@ -109,7 +109,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     const windowHalfX = window.innerWidth / 2;
     const windowHalfY = window.innerHeight / 2;
 
diff --git a/examples-testing/examples/webgpu_textures_partialupdate.ts b/examples-testing/examples/webgpu_textures_partialupdate.ts
index b989670df..9512c0c64 100644
--- a/examples-testing/examples/webgpu_textures_partialupdate.ts
+++ b/examples-testing/examples/webgpu_textures_partialupdate.ts
@@ -1,6 +1,11 @@
 import * as THREE from 'three/webgpu';
 
-let camera, scene, renderer, clock, dataTexture, diffuseMap;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    clock: THREE.Clock,
+    dataTexture: THREE.DataTexture,
+    diffuseMap: THREE.Texture;
 
 let last = 0;
 const position = new THREE.Vector2();
@@ -76,9 +81,9 @@ function animate() {
     }
 }
 
-function updateDataTexture(texture) {
+function updateDataTexture(texture: THREE.DataTexture) {
     const size = texture.image.width * texture.image.height;
-    const data = texture.image.data;
+    const data = texture.image.data as Uint8Array;
 
     // generate a random color and update texture data
 
diff --git a/examples-testing/examples/webgpu_tonemapping.ts b/examples-testing/examples/webgpu_tonemapping.ts
index 4140a49fd..e371e494c 100644
--- a/examples-testing/examples/webgpu_tonemapping.ts
+++ b/examples-testing/examples/webgpu_tonemapping.ts
@@ -1,23 +1,33 @@
 import * as THREE from 'three/webgpu';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
+import { ParametersGroup } from 'three/addons/inspector/tabs/Parameters.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
-let renderer, scene, camera, controls;
-let gui;
+type ToneMapping = 'None' | 'Linear' | 'Reinhard' | 'Cineon' | 'ACESFilmic' | 'AgX' | 'Neutral';
 
-const params = {
+interface Params {
+    exposure: number;
+    toneMapping: ToneMapping;
+    blurriness: number;
+    intensity: number;
+}
+
+let renderer: THREE.WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
+let gui: ParametersGroup;
+
+const params: Params = {
     exposure: 1.0,
     toneMapping: 'Neutral',
     blurriness: 0.3,
     intensity: 1.0,
 };
 
-const toneMappingOptions = {
+const toneMappingOptions: { [K in ToneMapping]: THREE.ToneMapping } = {
     None: THREE.NoToneMapping,
     Linear: THREE.LinearToneMapping,
     Reinhard: THREE.ReinhardToneMapping,
@@ -91,11 +101,11 @@ async function init() {
 
     //
 
-    gui = renderer.inspector.createParameters('Settings');
+    gui = (renderer.inspector as Inspector).createParameters('Settings');
     const toneMappingFolder = gui.addFolder('Tone Mapping');
 
     toneMappingFolder
-        .add(params, 'toneMapping', Object.keys(toneMappingOptions))
+        .add(params, 'toneMapping', Object.keys(toneMappingOptions) as ToneMapping[])
 
         .name('type')
         .onChange(function () {
diff --git a/examples-testing/examples/webgpu_tsl_angular_slicing.ts b/examples-testing/examples/webgpu_tsl_angular_slicing.ts
index f0711aba3..31a703891 100644
--- a/examples-testing/examples/webgpu_tsl_angular_slicing.ts
+++ b/examples-testing/examples/webgpu_tsl_angular_slicing.ts
@@ -8,7 +8,7 @@ import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, controls: OrbitControls;
 
 init();
 
@@ -45,10 +45,12 @@ function init() {
 
     // TSL functions
 
-    const inAngle = Fn(([position, angleStart, angleArc]) => {
-        const angle = atan(position.y, position.x).sub(angleStart).mod(TWO_PI).toVar();
-        return angle.greaterThan(0).and(angle.lessThan(angleArc));
-    });
+    const inAngle = Fn<[THREE.Node<'vec2'>, THREE.Node<'float'>, THREE.Node<'float'>], THREE.Node<'bool'>>(
+        ([position, angleStart, angleArc]) => {
+            const angle = atan(position.y, position.x).sub(angleStart).mod(TWO_PI).toVar();
+            return angle.greaterThan(0).and(angle.lessThan(angleArc));
+        },
+    );
 
     // materials
 
@@ -112,9 +114,9 @@ function init() {
         const model = gltf.scene;
 
         model.traverse(child => {
-            if (child.isMesh) {
-                if (child.name === 'outerHull') child.material = slicedMaterial;
-                else child.material = defaultMaterial;
+            if ((child as THREE.Mesh).isMesh) {
+                if (child.name === 'outerHull') (child as THREE.Mesh).material = slicedMaterial;
+                else (child as THREE.Mesh).material = defaultMaterial;
 
                 child.castShadow = true;
                 child.receiveShadow = true;
@@ -160,7 +162,7 @@ function init() {
 
     // debug
 
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
     gui.add(sliceStart, 'value', -Math.PI, Math.PI, 0.001).name('sliceStart');
     gui.add(sliceArc, 'value', 0, Math.PI * 2, 0.001).name('sliceArc');
     gui.addColor({ color: sliceColor.value.getHexString(THREE.SRGBColorSpace) }, 'color').onChange(value =>
diff --git a/examples-testing/examples/webgpu_tsl_earth.ts b/examples-testing/examples/webgpu_tsl_earth.ts
index 14c148902..07a99252d 100644
--- a/examples-testing/examples/webgpu_tsl_earth.ts
+++ b/examples-testing/examples/webgpu_tsl_earth.ts
@@ -21,7 +21,12 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, controls, globe, clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    controls: OrbitControls,
+    globe: THREE.Mesh<THREE.SphereGeometry, THREE.MeshStandardNodeMaterial>,
+    clock: THREE.Clock;
 
 init();
 
@@ -136,7 +141,7 @@ function init() {
 
     // debug
 
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
 
     gui.addColor({ color: atmosphereDayColor.value.getHex(THREE.SRGBColorSpace) }, 'color')
         .onChange(value => {
diff --git a/examples-testing/examples/webgpu_tsl_galaxy.ts b/examples-testing/examples/webgpu_tsl_galaxy.ts
index 739138504..46c0eead5 100644
--- a/examples-testing/examples/webgpu_tsl_galaxy.ts
+++ b/examples-testing/examples/webgpu_tsl_galaxy.ts
@@ -5,7 +5,7 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, controls: OrbitControls;
 
 init();
 
@@ -68,7 +68,7 @@ function init() {
 
     // debug
 
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
 
     gui.add(size, 'value', 0, 1, 0.001).name('size');
 
diff --git a/examples-testing/examples/webgpu_tsl_halftone.ts b/examples-testing/examples/webgpu_tsl_halftone.ts
index 143d577f1..ea49a87ee 100644
--- a/examples-testing/examples/webgpu_tsl_halftone.ts
+++ b/examples-testing/examples/webgpu_tsl_halftone.ts
@@ -6,7 +6,36 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let camera, scene, renderer, controls, clock, halftoneSettings;
+interface HalftoneSettings {
+    count: number;
+    color: string;
+    direction: THREE.Vector3;
+    start: number;
+    end: number;
+    mixLow: number;
+    mixHigh: number;
+    radius: number;
+
+    uniforms?: Uniforms;
+}
+
+interface Uniforms {
+    count: THREE.UniformNode<'float', number>;
+    color: THREE.UniformNode<'color', THREE.Color>;
+    direction: THREE.UniformNode<'vec3', THREE.Vector3>;
+    start: THREE.UniformNode<'float', number>;
+    end: THREE.UniformNode<'float', number>;
+    mixLow: THREE.UniformNode<'float', number>;
+    mixHigh: THREE.UniformNode<'float', number>;
+    radius: THREE.UniformNode<'float', number>;
+}
+
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    controls: OrbitControls,
+    clock: THREE.Clock,
+    halftoneSettings: HalftoneSettings[];
 
 init();
 
@@ -31,7 +60,7 @@ function init() {
 
     renderer.inspector = new Inspector();
 
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
 
     // lights
 
@@ -81,7 +110,7 @@ function init() {
 
         // uniforms
 
-        const uniforms = {};
+        const uniforms = {} as Uniforms;
 
         uniforms.count = uniform(settings.count);
         uniforms.color = uniform(color(settings.color));
@@ -112,7 +141,19 @@ function init() {
 
     // halftone functions
 
-    const halftone = Fn(([count, color, direction, start, end, radius, mixLow, mixHigh]) => {
+    const halftone = Fn<
+        [
+            THREE.UniformNode<'float', number>,
+            THREE.UniformNode<'vec3', THREE.Node<'vec3'>>,
+            THREE.UniformNode<'vec3', THREE.Vector3>,
+            THREE.UniformNode<'float', number>,
+            THREE.UniformNode<'float', number>,
+            THREE.UniformNode<'float', number>,
+            THREE.UniformNode<'float', number>,
+            THREE.UniformNode<'float', number>,
+        ],
+        THREE.Node<'vec4'>
+    >(([count, color, direction, start, end, radius, mixLow, mixHigh]) => {
         // grid pattern
 
         let gridUv = screenCoordinate.xy.div(screenSize.yy).mul(count);
@@ -133,19 +174,19 @@ function init() {
         return vec4(color, mask);
     });
 
-    const halftones = Fn(([input]) => {
+    const halftones = Fn<[THREE.PropertyNode<'vec4'>], THREE.PropertyNode<'vec4'>>(([input]) => {
         const halftonesOutput = input;
 
         for (const settings of halftoneSettings) {
             const halfToneOutput = halftone(
-                settings.uniforms.count,
-                settings.uniforms.color,
-                settings.uniforms.direction,
-                settings.uniforms.start,
-                settings.uniforms.end,
-                settings.uniforms.radius,
-                settings.uniforms.mixLow,
-                settings.uniforms.mixHigh,
+                settings.uniforms!.count,
+                settings.uniforms!.color,
+                settings.uniforms!.direction,
+                settings.uniforms!.start,
+                settings.uniforms!.end,
+                settings.uniforms!.radius,
+                settings.uniforms!.mixLow,
+                settings.uniforms!.mixHigh,
             );
             halftonesOutput.rgb.assign(mix(halftonesOutput.rgb, halfToneOutput.rgb, halfToneOutput.a));
         }
@@ -177,7 +218,9 @@ function init() {
         model.position.y = -2;
         model.scale.setScalar(2.5);
         model.traverse(child => {
-            if (child.isMesh) child.material.outputNode = halftones(output);
+            if ((child as THREE.Mesh).isMesh)
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhysicalMaterial>).material.outputNode =
+                    halftones(output);
         });
 
         scene.add(model);
@@ -204,8 +247,8 @@ async function animate() {
     controls.update();
 
     const time = clock.getElapsedTime();
-    halftoneSettings[1].uniforms.direction.value.x = Math.cos(time);
-    halftoneSettings[1].uniforms.direction.value.y = Math.sin(time);
+    halftoneSettings[1].uniforms!.direction.value.x = Math.cos(time);
+    halftoneSettings[1].uniforms!.direction.value.y = Math.sin(time);
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgpu_tsl_interoperability.ts b/examples-testing/examples/webgpu_tsl_interoperability.ts
index e57c66eeb..e414f5f0c 100644
--- a/examples-testing/examples/webgpu_tsl_interoperability.ts
+++ b/examples-testing/examples/webgpu_tsl_interoperability.ts
@@ -23,13 +23,13 @@ import WebGPU from 'three/addons/capabilities/WebGPU.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let renderer, camera, scene;
+let renderer: THREE.WebGPURenderer, camera: THREE.OrthographicCamera, scene: THREE.Scene;
 const dpr = window.devicePixelRatio;
 
 const crtWidthUniform = uniform(1608);
 const crtHeightUniform = uniform(1608);
 
-const canvas = document.getElementById('c');
+const canvas = document.getElementById('c') as HTMLCanvasElement;
 
 function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
@@ -46,7 +46,7 @@ function init() {
         throw new Error('No WebGPU support');
     }
 
-    const vUv = varyingProperty('vec2', 'vUv');
+    const vUv = varyingProperty<'vec2'>('vec2', 'vUv');
 
     // In WGSL, access varying properties from the varying struct
     const wgslVertexShader = wgslFn(
@@ -195,7 +195,7 @@ function init() {
         samplePoint.x = samplePoint.x.add(fract(scaledTime.div(20)));
         samplePoint.y = samplePoint.y.sub(1.5);
 
-        let color = texture(planetTexture, samplePoint);
+        let color: THREE.Node<'vec4'> = texture(planetTexture, samplePoint);
 
         const ind = floor(subCoord.x).mod(3);
 
@@ -249,7 +249,7 @@ function init() {
 
     window.addEventListener('resize', onWindowResize);
 
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
 
     gui.add(cellSizeUniform, 'value', 6, 50, 1).name('Cell Size');
     gui.add(cellOffsetUniform, 'value', 0, 1, 0.1).name('Cell Offset');
diff --git a/examples-testing/examples/webgpu_tsl_procedural_terrain.ts b/examples-testing/examples/webgpu_tsl_procedural_terrain.ts
index ef87d67ba..d2639cafc 100644
--- a/examples-testing/examples/webgpu_tsl_procedural_terrain.ts
+++ b/examples-testing/examples/webgpu_tsl_procedural_terrain.ts
@@ -22,7 +22,26 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 
-let camera, scene, renderer, controls, drag;
+interface Drag {
+    screenCoords: THREE.Vector2;
+    prevWorldCoords: THREE.Vector3;
+    worldCoords: THREE.Vector3;
+    raycaster: THREE.Raycaster;
+    down: boolean;
+    hover: boolean;
+
+    object: THREE.Mesh;
+
+    getIntersect: () => THREE.Intersection | null;
+
+    update: () => void;
+}
+
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    controls: OrbitControls,
+    drag: Drag;
 
 init();
 
@@ -83,7 +102,7 @@ function init() {
     const vNormal = varying(vec3());
     const vPosition = varying(vec3());
 
-    const terrainElevation = Fn(([position]) => {
+    const terrainElevation = Fn<[THREE.Node<'vec2'>], THREE.Node<'float'>>(([position]) => {
         const warpedPosition = position.add(offset).toVar();
         warpedPosition.addAssign(
             mx_noise_float(warpedPosition.mul(positionFrequency).mul(warpFrequency), 1, 0).mul(warpStrength),
@@ -183,7 +202,7 @@ function init() {
 
     // drag
 
-    drag = {};
+    drag = {} as Drag;
     drag.screenCoords = new THREE.Vector2();
     drag.prevWorldCoords = new THREE.Vector3();
     drag.worldCoords = new THREE.Vector3();
@@ -217,7 +236,7 @@ function init() {
         }
 
         if (drag.hover && drag.down) {
-            drag.worldCoords.copy(intersect.point);
+            drag.worldCoords.copy(intersect!.point);
             const delta = drag.prevWorldCoords.sub(drag.worldCoords);
 
             offset.value.x += delta.x;
@@ -240,7 +259,7 @@ function init() {
     // inspector
 
     renderer.inspector = new Inspector();
-    document.body.appendChild(renderer.inspector.domElement);
+    document.body.appendChild((renderer.inspector as Inspector).domElement);
 
     // controls
 
@@ -253,7 +272,7 @@ function init() {
 
     // debug
 
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
 
     const terrainGui = gui.addFolder(' terrain');
 
@@ -288,7 +307,7 @@ function init() {
             drag.down = true;
             drag.object.scale.setScalar(10);
 
-            const intersect = drag.getIntersect();
+            const intersect = drag.getIntersect()!;
             drag.prevWorldCoords.copy(intersect.point);
             drag.worldCoords.copy(intersect.point);
         }
diff --git a/examples-testing/examples/webgpu_tsl_raging_sea.ts b/examples-testing/examples/webgpu_tsl_raging_sea.ts
index cb513d075..b032e3c2e 100644
--- a/examples-testing/examples/webgpu_tsl_raging_sea.ts
+++ b/examples-testing/examples/webgpu_tsl_raging_sea.ts
@@ -19,7 +19,7 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, controls: OrbitControls;
 
 init();
 
@@ -54,7 +54,7 @@ function init() {
 
     // TSL functions
 
-    const wavesElevation = Fn(([position]) => {
+    const wavesElevation = Fn<[THREE.Node<'vec3'>], THREE.Node<'float'>>(([position]) => {
         // large waves
 
         const elevation = mul(
@@ -132,7 +132,7 @@ function init() {
 
     // debug
 
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
 
     gui.addColor({ color: material.color.getHex(THREE.SRGBColorSpace) }, 'color')
         .name('color')
diff --git a/examples-testing/examples/webgpu_tsl_vfx_flames.ts b/examples-testing/examples/webgpu_tsl_vfx_flames.ts
index f1e423444..34df22c9f 100644
--- a/examples-testing/examples/webgpu_tsl_vfx_flames.ts
+++ b/examples-testing/examples/webgpu_tsl_vfx_flames.ts
@@ -20,7 +20,15 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, controls: OrbitControls;
+
+interface Gradient {
+    element: HTMLCanvasElement;
+    context: CanvasRenderingContext2D;
+    colors: string[];
+    texture: THREE.CanvasTexture;
+    update: () => void;
+}
 
 init();
 
@@ -40,11 +48,11 @@ function init() {
 
     // gradient canvas
 
-    const gradient = {};
+    const gradient = {} as Gradient;
     gradient.element = document.createElement('canvas');
     gradient.element.width = 128;
     gradient.element.height = 1;
-    gradient.context = gradient.element.getContext('2d');
+    gradient.context = gradient.element.getContext('2d')!;
 
     gradient.colors = ['#090033', '#5f1f93', '#e02e96', '#ffbd80', '#fff0db'];
 
diff --git a/examples-testing/examples/webgpu_tsl_vfx_linkedparticles.ts b/examples-testing/examples/webgpu_tsl_vfx_linkedparticles.ts
index 4c4ee68ee..736edf556 100644
--- a/examples-testing/examples/webgpu_tsl_vfx_linkedparticles.ts
+++ b/examples-testing/examples/webgpu_tsl_vfx_linkedparticles.ts
@@ -37,10 +37,16 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 
 import WebGPU from 'three/addons/capabilities/WebGPU.js';
 
-let camera, scene, renderer, postProcessing, controls, timer, light;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    postProcessing: THREE.PostProcessing,
+    controls: OrbitControls,
+    timer: THREE.Timer,
+    light: THREE.PointLight;
 
-let updateParticles, spawnParticles; // TSL compute nodes
-let getInstanceColor; // TSL function
+let updateParticles: THREE.ComputeNode, spawnParticles: THREE.ComputeNode; // TSL compute nodes
+let getInstanceColor: THREE.TSL.FnNode<[THREE.Node<'uint'>], THREE.Node<'vec3'>>; // TSL function
 
 const screenPointer = new THREE.Vector2();
 const scenePointer = new THREE.Vector3();
@@ -102,7 +108,7 @@ async function init() {
 
     // TSL function
     // current color from index
-    getInstanceColor = Fn(([i]) => {
+    getInstanceColor = Fn<[THREE.IndexNode], THREE.Node<'vec3'>>(([i]) => {
         return hue(
             color(0x0000ff),
             colorOffset.add(mx_fractal_noise_float(i.toFloat().mul(0.1), 2, 2.0, 0.5, colorVariance)),
@@ -366,7 +372,7 @@ async function init() {
 
     // GUI
 
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
 
     gui.add(controls, 'autoRotate').name('Auto Rotate');
     gui.add(controls, 'autoRotateSpeed', -10.0, 10.0, 0.01).name('Auto Rotate Speed');
@@ -401,7 +407,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(e) {
+function onPointerMove(e: PointerEvent) {
     screenPointer.x = (e.clientX / window.innerWidth) * 2 - 1;
     screenPointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
 }
diff --git a/examples-testing/examples/webgpu_tsl_vfx_tornado.ts b/examples-testing/examples/webgpu_tsl_vfx_tornado.ts
index 571b7ea0b..85552d4f8 100644
--- a/examples-testing/examples/webgpu_tsl_vfx_tornado.ts
+++ b/examples-testing/examples/webgpu_tsl_vfx_tornado.ts
@@ -25,7 +25,11 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let camera, scene, renderer, postProcessing, controls;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGPURenderer,
+    postProcessing: THREE.PostProcessing,
+    controls: OrbitControls;
 
 init();
 
@@ -44,7 +48,10 @@ function init() {
 
     // TSL functions
 
-    const toRadialUv = Fn(([uv, multiplier, rotation, offset]) => {
+    const toRadialUv = Fn<
+        [THREE.Node<'vec2'>, THREE.Node<'vec2'>, THREE.Node<'float'>, THREE.Node<'float'>],
+        THREE.Node<'vec2'>
+    >(([uv, multiplier, rotation, offset]) => {
         const centeredUv = uv.sub(0.5).toVar();
         const distanceToCenter = centeredUv.length();
         const angle = atan(centeredUv.y, centeredUv.x);
@@ -56,11 +63,14 @@ function init() {
         return radialUv;
     });
 
-    const toSkewedUv = Fn(([uv, skew]) => {
+    const toSkewedUv = Fn<[THREE.Node<'vec2'>, THREE.Node<'vec2'>], THREE.Node<'vec2'>>(([uv, skew]) => {
         return vec2(uv.x.add(uv.y.mul(skew.x)), uv.y.add(uv.x.mul(skew.y)));
     });
 
-    const twistedCylinder = Fn(([position, parabolStrength, parabolOffset, parabolAmplitude, time]) => {
+    const twistedCylinder = Fn<
+        [THREE.Node<'vec3'>, THREE.Node<'float'>, THREE.Node<'float'>, THREE.Node<'float'>, THREE.Node<'float'>],
+        THREE.Node<'vec3'>
+    >(([position, parabolStrength, parabolOffset, parabolAmplitude, time]) => {
         const angle = atan(position.z, position.x).toVar();
         const elevation = position.y;
 
@@ -260,7 +270,7 @@ function init() {
 
     // debug
 
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
 
     gui.addColor({ color: emissiveColor.value.getHexString(THREE.SRGBColorSpace) }, 'color')
         .onChange(value => emissiveColor.value.set(value))
diff --git a/examples-testing/examples/webgpu_tsl_wood.ts b/examples-testing/examples/webgpu_tsl_wood.ts
index 5a4e06502..d6ebdc5a4 100644
--- a/examples-testing/examples/webgpu_tsl_wood.ts
+++ b/examples-testing/examples/webgpu_tsl_wood.ts
@@ -1,22 +1,30 @@
-import * as THREE from 'three';
+import * as THREE from 'three/webgpu';
 import * as TSL from 'three/tsl';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
+import { ParametersGroup } from 'three/addons/inspector/tabs/Parameters.js';
 
 import WebGPU from 'three/addons/capabilities/WebGPU.js';
 
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
-import { FontLoader } from 'three/addons/loaders/FontLoader.js';
+import { FontLoader, Font } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
 import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
 import { WoodNodeMaterial, WoodGenuses, Finishes } from 'three/addons/materials/WoodNodeMaterial.js';
 
-let scene, base, camera, renderer, controls, font, blockGeometry, gui;
+let scene: THREE.Scene,
+    base: THREE.Group,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGPURenderer,
+    controls: OrbitControls,
+    font: Font,
+    blockGeometry: RoundedBoxGeometry,
+    gui: ParametersGroup;
 
 // Helper function to get grid position
-function getGridPosition(woodIndex, finishIndex) {
+function getGridPosition(woodIndex: number, finishIndex: number) {
     return {
         x: 0,
         y: (finishIndex - Finishes.length / 2) * 1.0,
@@ -28,27 +36,32 @@ function getGridPosition(woodIndex, finishIndex) {
 function createGridPlane() {
     const material = new THREE.MeshBasicNodeMaterial();
 
-    const gridXZ = TSL.Fn(([gridSize = TSL.float(1.0), dotWidth = TSL.float(0.1), lineWidth = TSL.float(0.02)]) => {
-        const coord = TSL.positionWorld.xz.div(gridSize);
-        const grid = TSL.fract(coord);
+    const gridXZ = TSL.Fn<[THREE.Node<'float'>, THREE.Node<'float'>, THREE.Node<'float'>], THREE.Node<'float'>>(
+        ([gridSize = TSL.float(1.0), dotWidth = TSL.float(0.1), lineWidth = TSL.float(0.02)]) => {
+            const coord = TSL.positionWorld.xz.div(gridSize);
+            const grid = TSL.fract(coord);
 
-        // Screen-space derivative for automatic antialiasing
-        const fw = TSL.fwidth(coord);
-        const smoothing = TSL.max(fw.x, fw.y).mul(0.5);
+            // Screen-space derivative for automatic antialiasing
+            const fw = TSL.fwidth(coord);
+            const smoothing = TSL.max(fw.x, fw.y).mul(0.5);
 
-        // Create squares at cell centers
-        const squareDist = TSL.max(TSL.abs(grid.x.sub(0.5)), TSL.abs(grid.y.sub(0.5)));
-        const dots = TSL.smoothstep(dotWidth.add(smoothing), dotWidth.sub(smoothing), squareDist);
+            // Create squares at cell centers
+            const squareDist = TSL.max(TSL.abs(grid.x.sub(0.5)), TSL.abs(grid.y.sub(0.5)));
+            const dots = TSL.smoothstep(dotWidth.add(smoothing), dotWidth.sub(smoothing), squareDist);
 
-        // Create grid lines
-        const lineX = TSL.smoothstep(lineWidth.add(smoothing), lineWidth.sub(smoothing), TSL.abs(grid.x.sub(0.5)));
-        const lineZ = TSL.smoothstep(lineWidth.add(smoothing), lineWidth.sub(smoothing), TSL.abs(grid.y.sub(0.5)));
-        const lines = TSL.max(lineX, lineZ);
+            // Create grid lines
+            const lineX = TSL.smoothstep(lineWidth.add(smoothing), lineWidth.sub(smoothing), TSL.abs(grid.x.sub(0.5)));
+            const lineZ = TSL.smoothstep(lineWidth.add(smoothing), lineWidth.sub(smoothing), TSL.abs(grid.y.sub(0.5)));
+            const lines = TSL.max(lineX, lineZ);
 
-        return TSL.max(dots, lines);
-    });
+            return TSL.max(dots, lines);
+        },
+    );
 
-    const radialGradient = TSL.Fn(([radius = TSL.float(10.0), falloff = TSL.float(1.0)]) => {
+    const radialGradient = TSL.Fn<
+        [THREE.Node<'float'>, THREE.Node<'float'>, THREE.Node<'float'>] | [THREE.Node<'float'>, THREE.Node<'float'>],
+        THREE.Node<'float'>
+    >(([radius = TSL.float(10.0), falloff = TSL.float(1.0)]) => {
         return TSL.smoothstep(radius, radius.sub(falloff), TSL.length(TSL.positionWorld));
     });
 
@@ -69,7 +82,12 @@ function createGridPlane() {
 }
 
 // Helper function to create and position labels
-function createLabel(text, font, material, position) {
+function createLabel(
+    text: string,
+    font: Font,
+    material: THREE.MeshStandardMaterial,
+    position: { x: number; y: number; z: number },
+) {
     const txt_geo = new TextGeometry(text, {
         font: font,
         size: 0.1,
@@ -79,9 +97,9 @@ function createLabel(text, font, material, position) {
     });
 
     txt_geo.computeBoundingBox();
-    const offx = -0.5 * (txt_geo.boundingBox.max.x - txt_geo.boundingBox.min.x);
-    const offy = -0.5 * (txt_geo.boundingBox.max.y - txt_geo.boundingBox.min.y);
-    const offz = -0.5 * (txt_geo.boundingBox.max.z - txt_geo.boundingBox.min.z);
+    const offx = -0.5 * (txt_geo.boundingBox!.max.x - txt_geo.boundingBox!.min.x);
+    const offy = -0.5 * (txt_geo.boundingBox!.max.y - txt_geo.boundingBox!.min.y);
+    const offz = -0.5 * (txt_geo.boundingBox!.max.z - txt_geo.boundingBox!.min.z);
     txt_geo.translate(offx, offy, offz);
 
     const label = new THREE.Group();
@@ -91,7 +109,7 @@ function createLabel(text, font, material, position) {
     // Apply default rotation for labels
     label.rotateY(-Math.PI / 2);
 
-    label.children[0].material = material;
+    (label.children[0] as THREE.Mesh<TextGeometry, THREE.MeshStandardMaterial>).material = material;
     label.position.copy(position);
     base.add(label);
 }
@@ -115,7 +133,7 @@ async function init() {
     controls = new OrbitControls(camera, renderer.domElement);
     controls.target.set(0, 0, 0.548);
 
-    gui = renderer.inspector.createParameters('Parameters');
+    gui = (renderer.inspector as Inspector).createParameters('Parameters');
 
     font = await new FontLoader().loadAsync('./fonts/helvetiker_regular.typeface.json');
 
@@ -189,7 +207,7 @@ if (WebGPU.isAvailable()) {
     document.body.appendChild(WebGPU.getErrorMessage());
 }
 
-function add_custom_wood(text_mat) {
+function add_custom_wood(text_mat: THREE.MeshStandardMaterial) {
     // Add "Custom" label (positioned at the end of the grid)
     createLabel('custom', font, text_mat, getGridPosition(Math.round(WoodGenuses.length / 2 - 1), 5));
 
diff --git a/examples-testing/examples/webgpu_video_panorama.ts b/examples-testing/examples/webgpu_video_panorama.ts
index f52b15ffe..78885bec4 100644
--- a/examples-testing/examples/webgpu_video_panorama.ts
+++ b/examples-testing/examples/webgpu_video_panorama.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three/webgpu';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
 
 let isUserInteracting = false,
     lon = 0,
@@ -17,7 +17,7 @@ const distance = 0.5;
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.25, 10);
 
@@ -27,7 +27,7 @@ function init() {
     // invert the geometry on the x-axis so that all of the faces point inward
     geometry.scale(-1, 1, 1);
 
-    const video = document.getElementById('video');
+    const video = document.getElementById('video') as HTMLVideoElement;
     video.play();
 
     const texture = new THREE.VideoTexture(video);
@@ -59,7 +59,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     isUserInteracting = true;
 
     onPointerDownPointerX = event.clientX;
@@ -69,7 +69,7 @@ function onPointerDown(event) {
     onPointerDownLat = lat;
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (isUserInteracting === true) {
         lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
         lat = (onPointerDownPointerY - event.clientY) * 0.1 + onPointerDownLat;
diff --git a/examples-testing/examples/webgpu_volume_caustics.ts b/examples-testing/examples/webgpu_volume_caustics.ts
index 5250dc919..062c1f9cc 100644
--- a/examples-testing/examples/webgpu_volume_caustics.ts
+++ b/examples-testing/examples/webgpu_volume_caustics.ts
@@ -31,9 +31,9 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 import { bayer16 } from 'three/addons/tsl/math/Bayer.js';
 import { bloom } from 'three/addons/tsl/display/BloomNode.js';
 
-let camera, scene, renderer, controls;
-let postProcessing;
-let gltf;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer, controls: OrbitControls;
+let postProcessing: THREE.PostProcessing;
+let gltf: THREE.Group;
 
 init();
 
@@ -80,7 +80,7 @@ async function init() {
 
     // Material
 
-    const duck = gltf.children[0];
+    const duck = gltf.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhysicalNodeMaterial>;
     duck.material = new THREE.MeshPhysicalNodeMaterial();
     duck.material.side = THREE.DoubleSide;
     duck.material.transparent = true;
@@ -160,7 +160,7 @@ async function init() {
 
     // GUI
 
-    const gui = renderer.inspector.createParameters('Volumetric Caustics');
+    const gui = (renderer.inspector as Inspector).createParameters('Volumetric Caustics');
     gui.add(causticOcclusion, 'value', 0, 20).name('caustic occlusion');
     gui.addColor(duck.material, 'color').name('material color');
 
@@ -224,20 +224,22 @@ async function init() {
     const volumetricMaterial = new THREE.VolumeNodeMaterial();
     volumetricMaterial.steps = 20;
     volumetricMaterial.offsetNode = bayer16(screenCoordinate.add(frameId)); // Add dithering to reduce banding
-    volumetricMaterial.scatteringNode = Fn(({ positionRay }) => {
-        // Return the amount of fog based on the noise texture
+    volumetricMaterial.scatteringNode = Fn<{ positionRay: THREE.Node<'vec3'> }, THREE.Node<'float'>>(
+        ({ positionRay }) => {
+            // Return the amount of fog based on the noise texture
 
-        const timeScaled = vec3(time.mul(0.01), 0, time.mul(0.03));
+            const timeScaled = vec3(time.mul(0.01), 0, time.mul(0.03));
 
-        const sampleGrain = (scale, timeScale = 1) =>
-            texture3D(noiseTexture3D, positionRay.add(timeScaled.mul(timeScale)).mul(scale).mod(1), 0).r.add(0.5);
+            const sampleGrain = (scale: number, timeScale = 1) =>
+                texture3D(noiseTexture3D, positionRay.add(timeScaled.mul(timeScale)).mul(scale).mod(1), 0).r.add(0.5);
 
-        let density = sampleGrain(1);
-        density = density.mul(sampleGrain(0.5, 1));
-        density = density.mul(sampleGrain(0.2, 2));
+            let density = sampleGrain(1);
+            density = density.mul(sampleGrain(0.5, 1));
+            density = density.mul(sampleGrain(0.2, 2));
 
-        return smokeAmount.mix(1, density);
-    });
+            return smokeAmount.mix(1, density);
+        },
+    );
 
     const volumetricMesh = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 1.5), volumetricMaterial);
     volumetricMesh.receiveShadow = true;
diff --git a/examples-testing/examples/webgpu_volume_cloud.ts b/examples-testing/examples/webgpu_volume_cloud.ts
index 1d46c3543..3f7da644c 100644
--- a/examples-testing/examples/webgpu_volume_cloud.ts
+++ b/examples-testing/examples/webgpu_volume_cloud.ts
@@ -8,8 +8,8 @@ import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let renderer, scene, camera;
-let mesh;
+let renderer: THREE.WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let mesh: THREE.Mesh;
 
 init();
 
@@ -34,7 +34,7 @@ function init() {
     canvas.width = 1;
     canvas.height = 32;
 
-    const context = canvas.getContext('2d');
+    const context = canvas.getContext('2d')!;
     const gradient = context.createLinearGradient(0, 0, 0, 32);
     gradient.addColorStop(0.0, '#014a84');
     gradient.addColorStop(0.5, '#0561a0');
@@ -86,33 +86,40 @@ function init() {
 
     // Shader
 
-    const transparentRaymarchingTexture = Fn(
-        ({ texture, range = float(0.1), threshold = float(0.25), opacity = float(0.25), steps = float(100) }) => {
-            const finalColor = vec4(0).toVar();
+    const transparentRaymarchingTexture = Fn<
+        {
+            texture: THREE.TextureNode;
+            range: THREE.UniformNode<'float', number>;
+            threshold: THREE.UniformNode<'float', number>;
+            opacity: THREE.UniformNode<'float', number>;
+            steps: THREE.UniformNode<'float', number>;
+        },
+        THREE.Node<'vec4'>
+    >(({ texture, range = float(0.1), threshold = float(0.25), opacity = float(0.25), steps = float(100) }) => {
+        const finalColor = vec4(0).toVar();
 
-            RaymarchingBox(steps, ({ positionRay }) => {
-                const mapValue = float(texture.sample(positionRay.add(0.5)).r).toVar();
+        RaymarchingBox(steps, ({ positionRay }) => {
+            const mapValue = float(texture.sample(positionRay.add(0.5)).r).toVar();
 
-                mapValue.assign(smoothstep(threshold.sub(range), threshold.add(range), mapValue).mul(opacity));
+            mapValue.assign(smoothstep(threshold.sub(range), threshold.add(range), mapValue).mul(opacity));
 
-                const shading = texture
-                    .sample(positionRay.add(vec3(-0.01)))
-                    .r.sub(texture.sample(positionRay.add(vec3(0.01))).r);
+            const shading = texture
+                .sample(positionRay.add(vec3(-0.01)))
+                .r.sub(texture.sample(positionRay.add(vec3(0.01))).r);
 
-                const col = shading.mul(3.0).add(positionRay.x.add(positionRay.y).mul(0.25)).add(0.2);
+            const col = shading.mul(3.0).add(positionRay.x.add(positionRay.y).mul(0.25)).add(0.2);
 
-                finalColor.rgb.addAssign(finalColor.a.oneMinus().mul(mapValue).mul(col));
+            finalColor.rgb.addAssign(finalColor.a.oneMinus().mul(mapValue).mul(col));
 
-                finalColor.a.addAssign(finalColor.a.oneMinus().mul(mapValue));
+            finalColor.a.addAssign(finalColor.a.oneMinus().mul(mapValue));
 
-                If(finalColor.a.greaterThanEqual(0.95), () => {
-                    Break();
-                });
+            If(finalColor.a.greaterThanEqual(0.95), () => {
+                Break();
             });
+        });
 
-            return finalColor;
-        },
-    );
+        return finalColor;
+    });
 
     // Material
 
@@ -142,7 +149,7 @@ function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
     gui.add(threshold, 'value', 0, 1, 0.01).name('threshold');
     gui.add(opacity, 'value', 0, 1, 0.01).name('opacity');
     gui.add(range, 'value', 0, 1, 0.01).name('range');
diff --git a/examples-testing/examples/webgpu_volume_lighting.ts b/examples-testing/examples/webgpu_volume_lighting.ts
index 3edecb902..de39970e0 100644
--- a/examples-testing/examples/webgpu_volume_lighting.ts
+++ b/examples-testing/examples/webgpu_volume_lighting.ts
@@ -10,9 +10,9 @@ import { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';
 import { bayer16 } from 'three/addons/tsl/math/Bayer.js';
 import { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';
 
-let renderer, scene, camera;
-let volumetricMesh, teapot, pointLight, spotLight;
-let postProcessing;
+let renderer: THREE.WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let volumetricMesh: THREE.Mesh, teapot: THREE.Mesh, pointLight: THREE.PointLight, spotLight: THREE.SpotLight;
+let postProcessing: THREE.PostProcessing;
 
 init();
 
@@ -86,20 +86,22 @@ function init() {
     const volumetricMaterial = new THREE.VolumeNodeMaterial();
     volumetricMaterial.steps = 12;
     volumetricMaterial.offsetNode = bayer16(screenCoordinate); // Add dithering to reduce banding
-    volumetricMaterial.scatteringNode = Fn(({ positionRay }) => {
-        // Return the amount of fog based on the noise texture
+    volumetricMaterial.scatteringNode = Fn(
+        ({ positionRay }: { positionRay: THREE.Node<'vec3'> }): THREE.Node<'float'> => {
+            // Return the amount of fog based on the noise texture
 
-        const timeScaled = vec3(time, 0, time.mul(0.3));
+            const timeScaled = vec3(time, 0, time.mul(0.3));
 
-        const sampleGrain = (scale, timeScale = 1) =>
-            texture3D(noiseTexture3D, positionRay.add(timeScaled.mul(timeScale)).mul(scale).mod(1), 0).r.add(0.5);
+            const sampleGrain = (scale: number, timeScale = 1) =>
+                texture3D(noiseTexture3D, positionRay.add(timeScaled.mul(timeScale)).mul(scale).mod(1), 0).r.add(0.5);
 
-        let density = sampleGrain(0.1);
-        density = density.mul(sampleGrain(0.05, 1));
-        density = density.mul(sampleGrain(0.02, 2));
+            let density = sampleGrain(0.1);
+            density = density.mul(sampleGrain(0.05, 1));
+            density = density.mul(sampleGrain(0.02, 2));
 
-        return smokeAmount.mix(1, density);
-    });
+            return smokeAmount.mix(1, density);
+        },
+    );
 
     volumetricMesh = new THREE.Mesh(new THREE.BoxGeometry(20, 10, 20), volumetricMaterial);
     volumetricMesh.receiveShadow = true;
@@ -199,7 +201,7 @@ function init() {
         denoise: true,
     };
 
-    const gui = renderer.inspector.createParameters('Volumetric Lighting');
+    const gui = (renderer.inspector as Inspector).createParameters('Volumetric Lighting');
 
     const rayMarching = gui.addFolder('Ray Marching');
     rayMarching.add(params, 'resolution', 0.1, 0.5).onChange(resolution => {
diff --git a/examples-testing/examples/webgpu_volume_lighting_rectarea.ts b/examples-testing/examples/webgpu_volume_lighting_rectarea.ts
index 4089b3f72..de4c74a53 100644
--- a/examples-testing/examples/webgpu_volume_lighting_rectarea.ts
+++ b/examples-testing/examples/webgpu_volume_lighting_rectarea.ts
@@ -10,11 +10,11 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 import { bayer16 } from 'three/addons/tsl/math/Bayer.js';
 import { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';
 
-let renderer, scene, camera;
-let volumetricMesh, meshKnot;
-let rectLight1, rectLight2, rectLight3;
-let clock;
-let postProcessing;
+let renderer: THREE.WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let volumetricMesh: THREE.Mesh, meshKnot: THREE.Mesh;
+let rectLight1: THREE.RectAreaLight, rectLight2: THREE.RectAreaLight, rectLight3: THREE.RectAreaLight;
+let clock: THREE.Clock;
+let postProcessing: THREE.PostProcessing;
 
 init();
 
@@ -88,20 +88,22 @@ function init() {
     const volumetricMaterial = new THREE.VolumeNodeMaterial();
     volumetricMaterial.steps = 12;
     volumetricMaterial.offsetNode = bayer16(screenCoordinate); // Add dithering to reduce banding
-    volumetricMaterial.scatteringNode = Fn(({ positionRay }) => {
-        // Return the amount of fog based on the noise texture
+    volumetricMaterial.scatteringNode = Fn(
+        ({ positionRay }: { positionRay: THREE.Node<'vec3'> }): THREE.Node<'float'> => {
+            // Return the amount of fog based on the noise texture
 
-        const timeScaled = vec3(time, 0, time.mul(0.3));
+            const timeScaled = vec3(time, 0, time.mul(0.3));
 
-        const sampleGrain = (scale, timeScale = 1) =>
-            texture3D(noiseTexture3D, positionRay.add(timeScaled.mul(timeScale)).mul(scale).mod(1), 0).r.add(0.5);
+            const sampleGrain = (scale: number, timeScale = 1) =>
+                texture3D(noiseTexture3D, positionRay.add(timeScaled.mul(timeScale)).mul(scale).mod(1), 0).r.add(0.5);
 
-        let density = sampleGrain(0.1);
-        density = density.mul(sampleGrain(0.05, 1));
-        density = density.mul(sampleGrain(0.02, 2));
+            let density = sampleGrain(0.1);
+            density = density.mul(sampleGrain(0.05, 1));
+            density = density.mul(sampleGrain(0.02, 2));
 
-        return smokeAmount.mix(1, density);
-    });
+            return smokeAmount.mix(1, density);
+        },
+    );
 
     volumetricMesh = new THREE.Mesh(new THREE.BoxGeometry(50, 40, 50), volumetricMaterial);
     volumetricMesh.receiveShadow = true;
@@ -129,7 +131,7 @@ function init() {
 
     //
 
-    const createRectLightMesh = rectLight => {
+    const createRectLightMesh = (rectLight: THREE.RectAreaLight) => {
         const geometry = new THREE.PlaneGeometry(4, 10);
         const frontMaterial = new THREE.MeshBasicMaterial({ color: rectLight.color, side: THREE.BackSide });
         const backMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
@@ -211,7 +213,7 @@ function init() {
         denoise: true,
     };
 
-    const gui = renderer.inspector.createParameters('Volumetric Lighting');
+    const gui = (renderer.inspector as Inspector).createParameters('Volumetric Lighting');
 
     const rayMarching = gui.addFolder('Ray Marching');
     rayMarching.add(params, 'resolution', 0.1, 0.5).onChange(resolution => {
diff --git a/examples-testing/examples/webgpu_volume_perlin.ts b/examples-testing/examples/webgpu_volume_perlin.ts
index fb6f2bbd5..05639c677 100644
--- a/examples-testing/examples/webgpu_volume_perlin.ts
+++ b/examples-testing/examples/webgpu_volume_perlin.ts
@@ -8,8 +8,8 @@ import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
 
 import { Inspector } from 'three/addons/inspector/Inspector.js';
 
-let renderer, scene, camera;
-let mesh;
+let renderer: THREE.WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let mesh: THREE.Mesh<THREE.BoxGeometry, THREE.NodeMaterial>;
 
 init();
 
@@ -58,7 +58,14 @@ function init() {
 
     // Shader
 
-    const opaqueRaymarchingTexture = Fn(({ texture, steps, threshold }) => {
+    const opaqueRaymarchingTexture = Fn<
+        {
+            texture: THREE.Texture3DNode;
+            steps: THREE.Node<'float'>;
+            threshold: THREE.Node<'float'>;
+        },
+        THREE.Node<'vec4'>
+    >(({ texture, steps, threshold }) => {
         const finalColor = vec4(0).toVar();
 
         RaymarchingBox(steps, ({ positionRay }) => {
@@ -95,7 +102,7 @@ function init() {
 
     //
 
-    const gui = renderer.inspector.createParameters('Parameters');
+    const gui = (renderer.inspector as Inspector).createParameters('Parameters');
     gui.add(threshold, 'value', 0, 1, 0.01).name('threshold');
     gui.add(steps, 'value', 0, 300, 1).name('steps');
 
diff --git a/examples-testing/examples/webgpu_water.ts b/examples-testing/examples/webgpu_water.ts
index 0f9db99ee..9d7abec18 100644
--- a/examples-testing/examples/webgpu_water.ts
+++ b/examples-testing/examples/webgpu_water.ts
@@ -9,11 +9,16 @@ import { Inspector } from 'three/addons/inspector/Inspector.js';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { UltraHDRLoader } from 'three/addons/loaders/UltraHDRLoader.js';
 
-import { WaterMesh } from 'three/addons/objects/Water2Mesh.js';
+import { WaterMesh, WaterNode } from 'three/addons/objects/Water2Mesh.js';
 import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
 import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
 
-let scene, camera, renderer, water, postProcessing, controls;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGPURenderer,
+    water: WaterMesh,
+    postProcessing: THREE.PostProcessing,
+    controls: OrbitControls;
 
 const params = {
     color: '#99e0ff',
@@ -157,8 +162,8 @@ async function init() {
 
     // gui
 
-    const gui = renderer.inspector.createParameters('Water');
-    const waterNode = water.material.colorNode;
+    const gui = (renderer.inspector as Inspector).createParameters('Water');
+    const waterNode = water.material.colorNode as WaterNode;
 
     gui.addColor(params, 'color').onChange(function (value) {
         waterNode.color.value.set(value);
diff --git a/examples-testing/examples/webgpu_xr_cubes.ts b/examples-testing/examples/webgpu_xr_cubes.ts
index 27108eaeb..3481437a6 100644
--- a/examples-testing/examples/webgpu_xr_cubes.ts
+++ b/examples-testing/examples/webgpu_xr_cubes.ts
@@ -4,15 +4,19 @@ import { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';
 import { XRButton } from 'three/addons/webxr/XRButton.js';
 import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
 
+type CubeMesh = THREE.Mesh<THREE.BufferGeometry, THREE.MeshLambertMaterial> & {
+    currentHex: number;
+};
+
 const clock = new THREE.Clock();
 
-let container;
-let camera, scene, raycaster, renderer;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, raycaster: THREE.Raycaster, renderer: THREE.WebGPURenderer;
 
-let room;
+let room: THREE.LineSegments;
 
-let controller, controllerGrip;
-let INTERSECTED;
+let controller: THREE.XRTargetRaySpace, controllerGrip: THREE.XRGripSpace;
+let INTERSECTED: CubeMesh | undefined;
 
 init();
 
@@ -80,25 +84,25 @@ function init() {
 
     //
 
-    function onSelectStart() {
+    function onSelectStart(this: THREE.XRTargetRaySpace) {
         this.userData.isSelecting = true;
     }
 
-    function onSelectEnd() {
+    function onSelectEnd(this: THREE.XRTargetRaySpace) {
         this.userData.isSelecting = false;
     }
 
     controller = renderer.xr.getController(0);
     controller.addEventListener('selectstart', onSelectStart);
     controller.addEventListener('selectend', onSelectEnd);
-    controller.addEventListener('connected', function (event) {
+    controller.addEventListener('connected', function (this: THREE.XRTargetRaySpace, event) {
         const targetRayMode = event.data.targetRayMode;
 
         if (targetRayMode === 'tracked-pointer' || targetRayMode === 'gaze') {
-            this.add(buildController(event.data));
+            this.add(buildController(event.data)!);
         }
     });
-    controller.addEventListener('disconnected', function () {
+    controller.addEventListener('disconnected', function (this: THREE.XRTargetRaySpace) {
         this.remove(this.children[0]);
     });
     scene.add(controller);
@@ -116,7 +120,7 @@ function init() {
     document.body.appendChild(XRButton.createButton(renderer));
 }
 
-function buildController(data) {
+function buildController(data: XRInputSource) {
     let geometry, material;
 
     switch (data.targetRayMode) {
@@ -170,7 +174,7 @@ function animate() {
         if (INTERSECTED != intersects[0].object) {
             if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
 
-            INTERSECTED = intersects[0].object;
+            INTERSECTED = intersects[0].object as CubeMesh;
             INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
             INTERSECTED.material.emissive.setHex(0xff0000);
         }
diff --git a/examples-testing/examples/webgpu_xr_native_layers.ts b/examples-testing/examples/webgpu_xr_native_layers.ts
index b7beda04e..029d6a7e0 100644
--- a/examples-testing/examples/webgpu_xr_native_layers.ts
+++ b/examples-testing/examples/webgpu_xr_native_layers.ts
@@ -15,11 +15,11 @@ import {
 import { HTMLMesh } from 'three/addons/interactive/HTMLMesh.js';
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 
-let camera, scene, renderer;
-let controller1, controller2;
-let controllerGrip1, controllerGrip2;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGPURenderer;
+let controller1: THREE.XRTargetRaySpace, controller2: THREE.XRTargetRaySpace;
+let controllerGrip1: THREE.XRGripSpace, controllerGrip2: THREE.XRGripSpace;
 
-let room;
+let room: THREE.LineSegments;
 
 let count = 0;
 const radius = 0.08;
@@ -27,22 +27,22 @@ let normal = new THREE.Vector3();
 const relativeVelocity = new THREE.Vector3();
 
 const clock = new THREE.Clock();
-const funfairs = [];
+const funfairs: THREE.Mesh[] = [];
 const train = new THREE.Object3D();
 const rcdelta = clock.getDelta() * 0.8; // slow down simulation
 const PI2 = Math.PI * 2;
-let rccamera = null;
-let rcscene = null;
+let rccamera: THREE.PerspectiveCamera | null = null;
+let rcscene: THREE.Scene | null = null;
 
 const tempMatrix = new THREE.Matrix4();
-let raycaster = null;
+let raycaster: THREE.Raycaster | null = null;
 
 const curve = (function () {
     const vector = new THREE.Vector3();
     const vector2 = new THREE.Vector3();
 
     return {
-        getPointAt: function (t) {
+        getPointAt: function (t: number) {
             t = t * PI2;
 
             const x = Math.sin(t * 3) * Math.cos(t * 4) * 50;
@@ -52,7 +52,7 @@ const curve = (function () {
             return vector.set(x, y, z).multiplyScalar(2);
         },
 
-        getTangentAt: function (t) {
+        getTangentAt: function (t: number) {
             const delta = 0.0001;
             const t1 = Math.max(0, t - delta);
             const t2 = Math.min(1, t + delta);
@@ -62,20 +62,20 @@ const curve = (function () {
     };
 })();
 
-let horseCamera = null;
-let horseScene = null;
-let horseMixer = null;
+let horseCamera: THREE.PerspectiveCamera | null = null;
+let horseScene: THREE.Scene | null = null;
+let horseMixer: THREE.AnimationMixer | null = null;
 let horseTheta = 0;
 let horseMesh = null;
 const horseRadius = 600;
 
-let guiScene = null;
-let guiCamera = null;
-let guiGroup = null;
+let guiScene: THREE.Scene | null = null;
+let guiCamera: THREE.OrthographicCamera | null = null;
+let guiGroup: InteractiveGroup | null = null;
 
-let rollercoasterLayer = null;
-let horseLayer = null;
-let guiLayer = null;
+let rollercoasterLayer: THREE.Mesh | null = null;
+let horseLayer: THREE.Mesh | null = null;
+let guiLayer: THREE.Mesh | null = null;
 
 const parameters = {
     radius: 0.6,
@@ -89,13 +89,13 @@ const parameters = {
 
 init();
 
-function getIntersections(controller) {
+function getIntersections(controller: THREE.XRTargetRaySpace) {
     tempMatrix.identity().extractRotation(controller.matrixWorld);
 
-    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
-    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
+    raycaster!.ray.origin.setFromMatrixPosition(controller.matrixWorld);
+    raycaster!.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
 
-    return raycaster.intersectObjects(scene.children, false);
+    return raycaster!.intersectObjects(scene.children, false);
 }
 
 function init() {
@@ -157,15 +157,15 @@ function init() {
 
     // controllers
 
-    function onSqueezeStart() {
+    function onSqueezeStart(this: THREE.XRTargetRaySpace) {
         this.userData.isSelecting = true;
     }
 
-    function onSqueezeEnd() {
+    function onSqueezeEnd(this: THREE.XRTargetRaySpace) {
         this.userData.isSelecting = false;
     }
 
-    function onSelectStart(event) {
+    function onSelectStart(this: THREE.XRTargetRaySpace, event: { target: THREE.XRTargetRaySpace }) {
         const controller = event.target;
 
         const intersections = getIntersections(controller);
@@ -183,11 +183,10 @@ function init() {
             }
 
             if (intersections[x].object == guiLayer) {
-                const uv = intersections[x].uv;
-                guiGroup.children[0].dispatchEvent({
+                const uv = intersections[x].uv!;
+                (guiGroup!.children[0] as HTMLMesh).dispatchEvent({
                     type: 'mousedown',
                     data: { x: uv.x, y: 1 - uv.y },
-                    target: guiGroup,
                 });
                 hadSelection = true;
             }
@@ -196,10 +195,10 @@ function init() {
         this.userData.isSelecting = hadSelection === false;
     }
 
-    function onSelectEnd() {
-        horseLayer.visible = true;
-        scene.attach(rollercoasterLayer);
-        guiGroup.children[0].dispatchEvent({ type: 'mouseup', data: { x: 0, y: 0 }, target: guiGroup });
+    function onSelectEnd(this: THREE.XRTargetRaySpace) {
+        horseLayer!.visible = true;
+        scene.attach(rollercoasterLayer!);
+        (guiGroup!.children[0] as HTMLMesh).dispatchEvent({ type: 'mouseup', data: { x: 0, y: 0 } });
         this.userData.isSelecting = false;
     }
 
@@ -208,10 +207,10 @@ function init() {
     controller1.addEventListener('selectend', onSelectEnd);
     controller1.addEventListener('squeezestart', onSqueezeStart);
     controller1.addEventListener('squeezeend', onSqueezeEnd);
-    controller1.addEventListener('connected', function (event) {
-        this.add(buildController(event.data));
+    controller1.addEventListener('connected', function (this: THREE.XRTargetRaySpace, event: { data: XRInputSource }) {
+        this.add(buildController(event.data)!);
     });
-    controller1.addEventListener('disconnected', function () {
+    controller1.addEventListener('disconnected', function (this: THREE.XRTargetRaySpace) {
         this.remove(this.children[0]);
     });
     scene.add(controller1);
@@ -221,10 +220,10 @@ function init() {
     controller2.addEventListener('selectend', onSelectEnd);
     controller2.addEventListener('squeezestart', onSqueezeStart);
     controller2.addEventListener('squeezeend', onSqueezeEnd);
-    controller2.addEventListener('connected', function (event) {
-        this.add(buildController(event.data));
+    controller2.addEventListener('connected', function (this: THREE.XRTargetRaySpace, event: { data: XRInputSource }) {
+        this.add(buildController(event.data)!);
     });
-    controller2.addEventListener('disconnected', function () {
+    controller2.addEventListener('disconnected', function (this: THREE.XRTargetRaySpace) {
         this.remove(this.children[0]);
     });
     scene.add(controller2);
@@ -275,7 +274,7 @@ function init() {
 
     // environment
 
-    let rcgeometry = new THREE.PlaneGeometry(500, 500, 15, 15);
+    let rcgeometry: THREE.BufferGeometry = new THREE.PlaneGeometry(500, 500, 15, 15);
     rcgeometry.rotateX(-Math.PI / 2);
 
     const positions = rcgeometry.attributes.position.array;
@@ -295,7 +294,7 @@ function init() {
 
     rcgeometry.computeVertexNormals();
 
-    let rcmaterial = new THREE.MeshLambertMaterial({
+    let rcmaterial: THREE.Material = new THREE.MeshLambertMaterial({
         color: 0x407000,
     });
 
@@ -397,7 +396,7 @@ function init() {
     loader.load('models/gltf/Horse.glb', function (gltf) {
         horseMesh = gltf.scene.children[0];
         horseMesh.scale.set(1.5, 1.5, 1.5);
-        horseScene.add(horseMesh);
+        horseScene!.add(horseMesh);
 
         horseMixer = new THREE.AnimationMixer(horseMesh);
 
@@ -452,16 +451,16 @@ function init() {
 }
 
 function renderGui() {
-    renderer.render(guiScene, guiCamera);
+    renderer.render(guiScene!, guiCamera!);
 }
 
 function renderQuad() {
     horseTheta += 0.1;
 
-    horseCamera.position.x = horseRadius * Math.sin(THREE.MathUtils.degToRad(horseTheta));
-    horseCamera.position.z = horseRadius * Math.cos(THREE.MathUtils.degToRad(horseTheta));
+    horseCamera!.position.x = horseRadius * Math.sin(THREE.MathUtils.degToRad(horseTheta));
+    horseCamera!.position.z = horseRadius * Math.cos(THREE.MathUtils.degToRad(horseTheta));
 
-    horseCamera.lookAt(0, 150, 0);
+    horseCamera!.lookAt(0, 150, 0);
 
     if (horseMixer) {
         const time = Date.now();
@@ -471,7 +470,7 @@ function renderQuad() {
         prevTime = time;
     }
 
-    renderer.render(horseScene, horseCamera);
+    renderer.render(horseScene!, horseCamera!);
 }
 
 const rcposition = new THREE.Vector3();
@@ -509,11 +508,11 @@ function renderRollercoaster() {
 
     //
 
-    renderer.render(rcscene, rccamera);
+    renderer.render(rcscene!, rccamera!);
 }
 
-function buildController(data) {
-    let geometry, material;
+function buildController(data: XRInputSource) {
+    let geometry: THREE.BufferGeometry, material: THREE.Material;
 
     switch (data.targetRayMode) {
         case 'tracked-pointer':
@@ -539,7 +538,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function handleController(controller) {
+function handleController(controller: THREE.XRTargetRaySpace) {
     if (controller.userData.isSelecting) {
         const object = room.children[count++];
 
@@ -555,8 +554,8 @@ function handleController(controller) {
     const intersections = getIntersections(controller);
     for (let x = 0; x < intersections.length; x++) {
         if (intersections[x].object == guiLayer) {
-            const uv = intersections[x].uv;
-            guiGroup.children[0].dispatchEvent({ type: 'mousemove', data: { x: uv.x, y: 1 - uv.y }, target: guiGroup });
+            const uv = intersections[x].uv!;
+            (guiGroup!.children[0] as HTMLMesh).dispatchEvent({ type: 'mousemove', data: { x: uv.x, y: 1 - uv.y } });
         }
     }
 }
@@ -570,7 +569,7 @@ function render() {
     handleController(controller2);
 
     // rotate horse
-    horseLayer.rotation.y -= 0.02;
+    horseLayer!.rotation.y -= 0.02;
 
     //
     const delta = clock.getDelta() * 0.8;
diff --git a/examples-testing/examples/webgpu_xr_rollercoaster.ts b/examples-testing/examples/webgpu_xr_rollercoaster.ts
index 17dfa040f..444d4f315 100644
--- a/examples-testing/examples/webgpu_xr_rollercoaster.ts
+++ b/examples-testing/examples/webgpu_xr_rollercoaster.ts
@@ -9,7 +9,7 @@ import {
 } from 'three/addons/misc/RollerCoaster.js';
 import { VRButton } from 'three/addons/webxr/VRButton.js';
 
-let mesh, material, geometry;
+let mesh: THREE.Mesh, material: THREE.Material, geometry: THREE.BufferGeometry;
 
 const renderer = new THREE.WebGPURenderer({
     antialias: true,
@@ -92,7 +92,7 @@ const curve = (function () {
     const vector2 = new THREE.Vector3();
 
     return {
-        getPointAt: function (t) {
+        getPointAt: function (t: number) {
             t = t * PI2;
 
             const x = Math.sin(t * 3) * Math.cos(t * 4) * 50;
@@ -102,7 +102,7 @@ const curve = (function () {
             return vector.set(x, y, z).multiplyScalar(2);
         },
 
-        getTangentAt: function (t) {
+        getTangentAt: function (t: number) {
             const delta = 0.0001;
             const t1 = Math.max(0, t - delta);
             const t2 = Math.min(1, t + delta);
@@ -135,7 +135,7 @@ mesh = new THREE.Mesh(geometry, material);
 mesh.position.y = 0.1;
 scene.add(mesh);
 
-const funfairs = [];
+const funfairs: THREE.Mesh[] = [];
 
 //
 
diff --git a/examples-testing/examples/webxr_ar_cones.ts b/examples-testing/examples/webxr_ar_cones.ts
index 95eb34393..0e641cdb3 100644
--- a/examples-testing/examples/webxr_ar_cones.ts
+++ b/examples-testing/examples/webxr_ar_cones.ts
@@ -1,8 +1,8 @@
 import * as THREE from 'three';
 import { ARButton } from 'three/addons/webxr/ARButton.js';
 
-let camera, scene, renderer;
-let controller;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controller: THREE.XRTargetRaySpace;
 
 init();
 
diff --git a/examples-testing/examples/webxr_ar_hittest.ts b/examples-testing/examples/webxr_ar_hittest.ts
index 009b4b976..ffb711306 100644
--- a/examples-testing/examples/webxr_ar_hittest.ts
+++ b/examples-testing/examples/webxr_ar_hittest.ts
@@ -1,13 +1,13 @@
 import * as THREE from 'three';
 import { ARButton } from 'three/addons/webxr/ARButton.js';
 
-let container;
-let camera, scene, renderer;
-let controller1, controller2;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controller1: THREE.XRTargetRaySpace, controller2: THREE.XRTargetRaySpace;
 
-let reticle;
+let reticle: THREE.Mesh;
 
-let hitTestSource = null;
+let hitTestSource: XRHitTestSource | null = null;
 let hitTestSourceRequested = false;
 
 init();
@@ -81,14 +81,14 @@ function onWindowResize() {
 
 //
 
-function animate(timestamp, frame) {
+function animate(timestamp: DOMHighResTimeStamp, frame: XRFrame) {
     if (frame) {
         const referenceSpace = renderer.xr.getReferenceSpace();
-        const session = renderer.xr.getSession();
+        const session = renderer.xr.getSession()!;
 
         if (hitTestSourceRequested === false) {
             session.requestReferenceSpace('viewer').then(function (referenceSpace) {
-                session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
+                session.requestHitTestSource!({ space: referenceSpace })!.then(function (source) {
                     hitTestSource = source;
                 });
             });
@@ -108,7 +108,7 @@ function animate(timestamp, frame) {
                 const hit = hitTestResults[0];
 
                 reticle.visible = true;
-                reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
+                reticle.matrix.fromArray(hit.getPose(referenceSpace!)!.transform.matrix);
             } else {
                 reticle.visible = false;
             }
diff --git a/examples-testing/examples/webxr_ar_lighting.ts b/examples-testing/examples/webxr_ar_lighting.ts
index dda8ce5db..f97b431bc 100644
--- a/examples-testing/examples/webxr_ar_lighting.ts
+++ b/examples-testing/examples/webxr_ar_lighting.ts
@@ -3,9 +3,9 @@ import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 import { ARButton } from 'three/addons/webxr/ARButton.js';
 import { XREstimatedLight } from 'three/addons/webxr/XREstimatedLight.js';
 
-let camera, scene, renderer;
-let controller;
-let defaultEnvironment;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controller: THREE.XRTargetRaySpace;
+let defaultEnvironment: THREE.DataTexture;
 
 init();
 
diff --git a/examples-testing/examples/webxr_vr_handinput.ts b/examples-testing/examples/webxr_vr_handinput.ts
index d746e4582..af438f0f6 100644
--- a/examples-testing/examples/webxr_vr_handinput.ts
+++ b/examples-testing/examples/webxr_vr_handinput.ts
@@ -4,13 +4,13 @@ import { VRButton } from 'three/addons/webxr/VRButton.js';
 import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
 import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';
 
-let container;
-let camera, scene, renderer;
-let hand1, hand2;
-let controller1, controller2;
-let controllerGrip1, controllerGrip2;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let hand1: THREE.XRHandSpace, hand2: THREE.XRHandSpace;
+let controller1: THREE.XRTargetRaySpace, controller2: THREE.XRTargetRaySpace;
+let controllerGrip1: THREE.XRGripSpace, controllerGrip2: THREE.XRGripSpace;
 
-let controls;
+let controls: OrbitControls;
 
 init();
 
diff --git a/examples-testing/examples/webxr_vr_panorama.ts b/examples-testing/examples/webxr_vr_panorama.ts
index 535e1c937..ab2e4ee0d 100644
--- a/examples-testing/examples/webxr_vr_panorama.ts
+++ b/examples-testing/examples/webxr_vr_panorama.ts
@@ -1,9 +1,9 @@
 import * as THREE from 'three';
 import { VRButton } from 'three/addons/webxr/VRButton.js';
 
-let camera;
-let renderer;
-let scene;
+let camera: THREE.PerspectiveCamera;
+let renderer: THREE.WebGLRenderer;
+let scene: THREE.Scene;
 
 init();
 
@@ -53,8 +53,8 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function getTexturesFromAtlasFile(atlasImgUrl, tilesNum) {
-    const textures = [];
+function getTexturesFromAtlasFile(atlasImgUrl: string, tilesNum: number) {
+    const textures: THREE.Texture[] = [];
 
     for (let i = 0; i < tilesNum; i++) {
         textures[i] = new THREE.Texture();
@@ -67,7 +67,7 @@ function getTexturesFromAtlasFile(atlasImgUrl, tilesNum) {
 
         for (let i = 0; i < textures.length; i++) {
             canvas = document.createElement('canvas');
-            context = canvas.getContext('2d');
+            context = canvas.getContext('2d')!;
             canvas.height = tileWidth;
             canvas.width = tileWidth;
             context.drawImage(imageObj, tileWidth * i, 0, tileWidth, tileWidth, 0, 0, tileWidth, tileWidth);
diff --git a/examples-testing/examples/webxr_vr_panorama_depth.ts b/examples-testing/examples/webxr_vr_panorama_depth.ts
index 42ac83326..093dcd93e 100644
--- a/examples-testing/examples/webxr_vr_panorama_depth.ts
+++ b/examples-testing/examples/webxr_vr_panorama_depth.ts
@@ -1,12 +1,16 @@
 import * as THREE from 'three';
 import { VRButton } from 'three/addons/webxr/VRButton.js';
 
-let camera, scene, renderer, sphere, clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    sphere: THREE.Mesh<THREE.SphereGeometry, THREE.MeshStandardMaterial>,
+    clock: THREE.Clock;
 
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
 
     clock = new THREE.Clock();
 
diff --git a/examples-testing/examples/webxr_vr_rollercoaster.ts b/examples-testing/examples/webxr_vr_rollercoaster.ts
index b8c35a9e3..ee5f02daf 100644
--- a/examples-testing/examples/webxr_vr_rollercoaster.ts
+++ b/examples-testing/examples/webxr_vr_rollercoaster.ts
@@ -9,7 +9,7 @@ import {
 } from 'three/addons/misc/RollerCoaster.js';
 import { VRButton } from 'three/addons/webxr/VRButton.js';
 
-let mesh, material, geometry;
+let mesh: THREE.Mesh, material: THREE.Material, geometry: SkyGeometry;
 
 const renderer = new THREE.WebGLRenderer({ antialias: true });
 renderer.setPixelRatio(window.devicePixelRatio);
@@ -87,7 +87,7 @@ const curve = (function () {
     const vector2 = new THREE.Vector3();
 
     return {
-        getPointAt: function (t) {
+        getPointAt: function (t: number) {
             t = t * PI2;
 
             const x = Math.sin(t * 3) * Math.cos(t * 4) * 50;
@@ -97,7 +97,7 @@ const curve = (function () {
             return vector.set(x, y, z).multiplyScalar(2);
         },
 
-        getTangentAt: function (t) {
+        getTangentAt: function (t: number) {
             const delta = 0.0001;
             const t1 = Math.max(0, t - delta);
             const t2 = Math.min(1, t + delta);
@@ -130,7 +130,7 @@ mesh = new THREE.Mesh(geometry, material);
 mesh.position.y = 0.1;
 scene.add(mesh);
 
-const funfairs = [];
+const funfairs: THREE.Mesh[] = [];
 
 //
 
diff --git a/examples-testing/examples/webxr_vr_sandbox.ts b/examples-testing/examples/webxr_vr_sandbox.ts
index d348d5421..9f063c1a6 100644
--- a/examples-testing/examples/webxr_vr_sandbox.ts
+++ b/examples-testing/examples/webxr_vr_sandbox.ts
@@ -11,9 +11,9 @@ import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFa
 import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
 import Stats from 'three/addons/libs/stats.module.js';
 
-let camera, scene, renderer;
-let reflector;
-let stats, statsMesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let reflector: Reflector;
+let stats: Stats, statsMesh: HTMLMesh;
 
 const parameters = {
     radius: 0.6,
@@ -180,7 +180,7 @@ function onWindowResize() {
 
 function animate() {
     const time = performance.now() * 0.0002;
-    const torus = scene.getObjectByName('torus');
+    const torus = scene.getObjectByName('torus')!;
     torus.rotation.x = time * 0.4;
     torus.rotation.y = time;
 
@@ -188,5 +188,9 @@ function animate() {
     stats.update();
 
     // Canvas elements doesn't trigger DOM updates, so we have to update the texture
-    statsMesh.material.map.update();
+    (statsMesh.material.map as HTMLTexture).update();
+}
+
+interface HTMLTexture extends THREE.CanvasTexture {
+    update(): void;
 }
diff --git a/examples-testing/examples/webxr_vr_video.ts b/examples-testing/examples/webxr_vr_video.ts
index 50a990412..b5925eb18 100644
--- a/examples-testing/examples/webxr_vr_video.ts
+++ b/examples-testing/examples/webxr_vr_video.ts
@@ -1,12 +1,12 @@
 import * as THREE from 'three';
 import { VRButton } from 'three/addons/webxr/VRButton.js';
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
 function init() {
-    const container = document.getElementById('container');
+    const container = document.getElementById('container')!;
     container.addEventListener('click', function () {
         video.play();
     });
@@ -16,7 +16,7 @@ function init() {
 
     // video
 
-    const video = document.getElementById('video');
+    const video = document.getElementById('video') as HTMLVideoElement;
     video.play();
 
     const texture = new THREE.VideoTexture(video);
diff --git a/examples-testing/examples/webxr_xr_controls_transform.ts b/examples-testing/examples/webxr_xr_controls_transform.ts
index 6e6901416..ee8cabbd2 100644
--- a/examples-testing/examples/webxr_xr_controls_transform.ts
+++ b/examples-testing/examples/webxr_xr_controls_transform.ts
@@ -3,14 +3,14 @@ import { TransformControls } from 'three/addons/controls/TransformControls.js';
 import { XRButton } from 'three/addons/webxr/XRButton.js';
 import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
 
-let container;
-let camera, scene, renderer;
-let controller1, controller2, line;
-let controllerGrip1, controllerGrip2;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controller1: THREE.XRTargetRaySpace, controller2: THREE.XRTargetRaySpace, line: THREE.Line;
+let controllerGrip1: THREE.XRGripSpace, controllerGrip2: THREE.XRGripSpace;
 
-let raycaster;
+let raycaster: THREE.Raycaster;
 
-let controls, group;
+let controls: TransformControls, group: THREE.Group;
 
 init();
 
@@ -148,7 +148,7 @@ function init() {
     window.addEventListener('resize', onWindowResize);
 }
 
-function onSelect(event) {
+function onSelect(event: THREE.Event<'select', THREE.XRTargetRaySpace>) {
     const controller = event.target;
 
     controller1.userData.active = false;
@@ -173,7 +173,7 @@ function onSelect(event) {
     }
 }
 
-function onControllerEvent(event) {
+function onControllerEvent(event: THREE.Event<'selectstart' | 'selectend' | 'move', THREE.XRTargetRaySpace>) {
     const controller = event.target;
 
     if (controller.userData.active === false) return;
diff --git a/examples-testing/examples/webxr_xr_dragging_custom_depth.ts b/examples-testing/examples/webxr_xr_dragging_custom_depth.ts
index 2cd50ba4c..b97f3eee2 100644
--- a/examples-testing/examples/webxr_xr_dragging_custom_depth.ts
+++ b/examples-testing/examples/webxr_xr_dragging_custom_depth.ts
@@ -3,18 +3,18 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { XRButton } from 'three/addons/webxr/XRButton.js';
 import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
 
-let container;
-let camera, scene, renderer;
-let controller1, controller2;
-let controllerGrip1, controllerGrip2;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controller1: THREE.XRTargetRaySpace, controller2: THREE.XRTargetRaySpace;
+let controllerGrip1: THREE.XRGripSpace, controllerGrip2: THREE.XRGripSpace;
 let isDepthSupplied = false;
 
-let raycaster;
+let raycaster: THREE.Raycaster;
 
-const intersected = [];
+const intersected: THREE.Object3D[] = [];
 const tempMatrix = new THREE.Matrix4();
 
-let controls, group;
+let controls: OrbitControls, group: THREE.Group;
 
 init();
 animate();
@@ -289,7 +289,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onSelectStart(event) {
+function onSelectStart(event: THREE.Event<'selectstart', THREE.XRTargetRaySpace> & { data: XRInputSource }) {
     const controller = event.target;
 
     const intersections = getIntersections(controller);
@@ -297,7 +297,7 @@ function onSelectStart(event) {
     if (intersections.length > 0) {
         const intersection = intersections[0];
 
-        const object = intersection.object;
+        const object = intersection.object as THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>;
         object.material.uniforms.emissive.value = 1;
         controller.attach(object);
 
@@ -307,7 +307,7 @@ function onSelectStart(event) {
     controller.userData.targetRayMode = event.data.targetRayMode;
 }
 
-function onSelectEnd(event) {
+function onSelectEnd(event: THREE.Event<'selectend', THREE.XRTargetRaySpace> & { data: XRInputSource }) {
     const controller = event.target;
 
     if (controller.userData.selected !== undefined) {
@@ -319,7 +319,7 @@ function onSelectEnd(event) {
     }
 }
 
-function getIntersections(controller) {
+function getIntersections(controller: THREE.XRTargetRaySpace) {
     controller.updateMatrixWorld();
 
     tempMatrix.identity().extractRotation(controller.matrixWorld);
@@ -330,7 +330,7 @@ function getIntersections(controller) {
     return raycaster.intersectObjects(group.children, false);
 }
 
-function intersectObjects(controller) {
+function intersectObjects(controller: THREE.XRTargetRaySpace) {
     // Do not highlight in mobile-ar
 
     if (controller.userData.targetRayMode === 'screen') return;
@@ -345,19 +345,19 @@ function intersectObjects(controller) {
     if (intersections.length > 0) {
         const intersection = intersections[0];
 
-        const object = intersection.object;
+        const object = intersection.object as THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>;
         object.material.uniforms.emissive.value = 1;
         intersected.push(object);
 
-        line.scale.z = intersection.distance;
+        line!.scale.z = intersection.distance;
     } else {
-        line.scale.z = 5;
+        line!.scale.z = 5;
     }
 }
 
 function cleanIntersected() {
     while (intersected.length) {
-        const object = intersected.pop();
+        const object = intersected.pop() as THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>;
         object.material.uniforms.emissive.value = 0;
     }
 }
@@ -371,16 +371,18 @@ function animate() {
 function render() {
     if (renderer.xr.hasDepthSensing() && !isDepthSupplied) {
         group.children.forEach(child => {
-            child.material.uniforms.depthColor.value = renderer.xr.getDepthTexture();
-            child.material.uniforms.depthWidth.value = 1680;
-            child.material.uniforms.depthHeight.value = 1760;
+            (child as THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>).material.uniforms.depthColor.value =
+                renderer.xr.getDepthTexture();
+            (child as THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>).material.uniforms.depthWidth.value = 1680;
+            (child as THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>).material.uniforms.depthHeight.value =
+                1760;
 
             isDepthSupplied = true;
         });
     } else if (!renderer.xr.hasDepthSensing() && isDepthSupplied) {
         group.children.forEach(child => {
-            child.material.uniforms.depthWidth.value = 0;
-            child.material.uniforms.depthHeight.value = 0;
+            (child as THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>).material.uniforms.depthWidth.value = 0;
+            (child as THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>).material.uniforms.depthHeight.value = 0;
 
             isDepthSupplied = false;
         });
diff --git a/types/three/src/nodes/core/ContextNode.d.ts b/types/three/src/nodes/core/ContextNode.d.ts
index e671c94dc..f975f30cd 100644
--- a/types/three/src/nodes/core/ContextNode.d.ts
+++ b/types/three/src/nodes/core/ContextNode.d.ts
@@ -21,7 +21,7 @@ interface ContextFunction {
     <TNodeType>(node: Node<TNodeType>, value?: NodeBuilderContext): ContextNode<TNodeType>;
 }
 
-export const context: <TNodeType>(node: Node<TNodeType>, context?: NodeBuilderContext) => ContextNode<TNodeType>;
+export const context: ContextFunction;
 
 export const uniformFlow: <TNodeType>(node: Node<TNodeType>) => ContextNode<TNodeType>;
 
diff --git a/types/three/src/nodes/math/MathNode.d.ts b/types/three/src/nodes/math/MathNode.d.ts
index d670df602..9d8a446d2 100644
--- a/types/three/src/nodes/math/MathNode.d.ts
+++ b/types/three/src/nodes/math/MathNode.d.ts
@@ -535,11 +535,16 @@ declare module "../core/Node.js" {
 }
 
 export const dot: (x: FloatVector, y: FloatVector) => Node<"float">;
-export const cross: (x: FloatVector, y: FloatVector) => Node<"float">;
 declare module "../core/Node.js" {
     interface FloatVectorExtensions<TVec extends FloatVectorType> {
         dot: (y: FloatVector) => Node<"float">;
-        cross: (y: FloatVector) => Node<"float">;
+    }
+}
+
+export const cross: (x: Node<"vec3">, y: Node<"vec3">) => Node<"vec3">;
+declare module "../core/Node.js" {
+    interface Vec3Extensions {
+        cross: (y: Node<"vec3">) => Node<"vec3">;
     }
 }
 
