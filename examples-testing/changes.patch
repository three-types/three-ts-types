diff --git a/examples-testing/examples/css2d_label.ts b/examples-testing/examples/css2d_label.ts
index 3a84abc..b1f86bc 100644
--- a/examples-testing/examples/css2d_label.ts
+++ b/examples-testing/examples/css2d_label.ts
@@ -7,20 +7,20 @@ import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
 let gui;
 
-let camera, scene, renderer, labelRenderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, labelRenderer: CSS2DRenderer;
 
 const layers = {
-    "Toggle Name": function () {
+    "Toggle Name": function() {
         camera.layers.toggle(0);
     },
-    "Toggle Mass": function () {
+    "Toggle Mass": function() {
         camera.layers.toggle(1);
     },
-    "Enable All": function () {
+    "Enable All": function() {
         camera.layers.enableAll();
     },
 
-    "Disable All": function () {
+    "Disable All": function() {
         camera.layers.disableAll();
     },
 };
@@ -28,7 +28,7 @@ const layers = {
 const clock = new THREE.Clock();
 const textureLoader = new THREE.TextureLoader();
 
-let moon;
+let moon: THREE.Mesh;
 
 init();
 animate();
@@ -63,7 +63,7 @@ function init() {
         normalMap: textureLoader.load("textures/planets/earth_normal_2048.jpg"),
         normalScale: new THREE.Vector2(0.85, 0.85),
     });
-    earthMaterial.map.colorSpace = THREE.SRGBColorSpace;
+    earthMaterial.map!.colorSpace = THREE.SRGBColorSpace;
     const earth = new THREE.Mesh(earthGeometry, earthMaterial);
     scene.add(earth);
 
@@ -72,7 +72,7 @@ function init() {
         shininess: 5,
         map: textureLoader.load("textures/planets/moon_1024.jpg"),
     });
-    moonMaterial.map.colorSpace = THREE.SRGBColorSpace;
+    moonMaterial.map!.colorSpace = THREE.SRGBColorSpace;
     moon = new THREE.Mesh(moonGeometry, moonMaterial);
     scene.add(moon);
 
diff --git a/examples-testing/examples/css3d_molecules.ts b/examples-testing/examples/css3d_molecules.ts
index 91303fb..e090ea8 100644
--- a/examples-testing/examples/css3d_molecules.ts
+++ b/examples-testing/examples/css3d_molecules.ts
@@ -1,15 +1,15 @@
 import * as THREE from "three";
 
 import { TrackballControls } from "three/addons/controls/TrackballControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { PDBLoader } from "three/addons/loaders/PDBLoader.js";
 import { CSS3DObject, CSS3DRenderer, CSS3DSprite } from "three/addons/renderers/CSS3DRenderer.js";
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let camera, scene, renderer;
-let controls;
-let root;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: CSS3DRenderer;
+let controls: TrackballControls;
+let root: THREE.Object3D;
 
-const objects = [];
+const objects: Array<CSS3DObject | CSS3DSprite> = [];
 const tmpVec1 = new THREE.Vector3();
 const tmpVec2 = new THREE.Vector3();
 const tmpVec3 = new THREE.Vector3();
@@ -17,30 +17,30 @@ const tmpVec4 = new THREE.Vector3();
 const offset = new THREE.Vector3();
 
 const VIZ_TYPE = {
-    "Atoms": 0,
-    "Bonds": 1,
+    Atoms: 0,
+    Bonds: 1,
     "Atoms + Bonds": 2,
 };
 
 const MOLECULES = {
-    "Ethanol": "ethanol.pdb",
-    "Aspirin": "aspirin.pdb",
-    "Caffeine": "caffeine.pdb",
-    "Nicotine": "nicotine.pdb",
-    "LSD": "lsd.pdb",
-    "Cocaine": "cocaine.pdb",
-    "Cholesterol": "cholesterol.pdb",
-    "Lycopene": "lycopene.pdb",
-    "Glucose": "glucose.pdb",
+    Ethanol: "ethanol.pdb",
+    Aspirin: "aspirin.pdb",
+    Caffeine: "caffeine.pdb",
+    Nicotine: "nicotine.pdb",
+    LSD: "lsd.pdb",
+    Cocaine: "cocaine.pdb",
+    Cholesterol: "cholesterol.pdb",
+    Lycopene: "lycopene.pdb",
+    Glucose: "glucose.pdb",
     "Aluminium oxide": "Al2O3.pdb",
-    "Cubane": "cubane.pdb",
-    "Copper": "cu.pdb",
-    "Fluorite": "caf2.pdb",
-    "Salt": "nacl.pdb",
+    Cubane: "cubane.pdb",
+    Copper: "cu.pdb",
+    Fluorite: "caf2.pdb",
+    Salt: "nacl.pdb",
     "YBCO superconductor": "ybco.pdb",
-    "Buckyball": "buckyball.pdb",
+    Buckyball: "buckyball.pdb",
     // 'Diamond': 'diamond.pdb',
-    "Graphite": "graphite.pdb",
+    Graphite: "graphite.pdb",
 };
 
 const params = {
@@ -49,7 +49,7 @@ const params = {
 };
 
 const loader = new PDBLoader();
-const colorSpriteMap = {};
+const colorSpriteMap: { [element: string]: string | undefined } = {};
 const baseSprite = document.createElement("img");
 
 init();
@@ -68,7 +68,7 @@ function init() {
 
     renderer = new CSS3DRenderer();
     renderer.setSize(window.innerWidth, window.innerHeight);
-    document.getElementById("container").appendChild(renderer.domElement);
+    document.getElementById("container")!.appendChild(renderer.domElement);
 
     //
 
@@ -77,7 +77,7 @@ function init() {
 
     //
 
-    baseSprite.onload = function () {
+    baseSprite.onload = function() {
         loadMolecule(params.molecule);
     };
 
@@ -96,7 +96,7 @@ function init() {
     gui.open();
 }
 
-function changeVizType(value) {
+function changeVizType(value: number) {
     if (value === 0) showAtoms();
     else if (value === 1) showBonds();
     else showAtomsBonds();
@@ -148,8 +148,10 @@ function showAtomsBonds() {
 
 //
 
-function colorify(ctx, width, height, color) {
-    const r = color.r, g = color.g, b = color.b;
+function colorify(ctx: CanvasRenderingContext2D, width: number, height: number, color: THREE.Color) {
+    const r = color.r,
+        g = color.g,
+        b = color.b;
 
     const imageData = ctx.getImageData(0, 0, width, height);
     const data = imageData.data;
@@ -163,7 +165,7 @@ function colorify(ctx, width, height, color) {
     ctx.putImageData(imageData, 0, 0);
 }
 
-function imageToCanvas(image) {
+function imageToCanvas(image: HTMLImageElement) {
     const width = image.width;
     const height = image.height;
 
@@ -172,7 +174,7 @@ function imageToCanvas(image) {
     canvas.width = width;
     canvas.height = height;
 
-    const context = canvas.getContext("2d");
+    const context = canvas.getContext("2d")!;
     context.drawImage(image, 0, 0, width, height);
 
     return canvas;
@@ -180,23 +182,23 @@ function imageToCanvas(image) {
 
 //
 
-function loadMolecule(model) {
+function loadMolecule(model: string) {
     const url = "models/pdb/" + model;
 
     for (let i = 0; i < objects.length; i++) {
         const object = objects[i];
-        object.parent.remove(object);
+        object.parent!.remove(object);
     }
 
     objects.length = 0;
 
-    loader.load(url, function (pdb) {
+    loader.load(url, function(pdb) {
         const geometryAtoms = pdb.geometryAtoms;
         const geometryBonds = pdb.geometryBonds;
         const json = pdb.json;
 
         geometryAtoms.computeBoundingBox();
-        geometryAtoms.boundingBox.getCenter(offset).negate();
+        geometryAtoms.boundingBox!.getCenter(offset).negate();
 
         geometryAtoms.translate(offset.x, offset.y, offset.z);
         geometryBonds.translate(offset.x, offset.y, offset.z);
@@ -216,7 +218,7 @@ function loadMolecule(model) {
 
             if (!colorSpriteMap[element]) {
                 const canvas = imageToCanvas(baseSprite);
-                const context = canvas.getContext("2d");
+                const context = canvas.getContext("2d")!;
 
                 colorify(context, canvas.width, canvas.height, color);
 
@@ -225,7 +227,7 @@ function loadMolecule(model) {
                 colorSpriteMap[element] = dataUrl;
             }
 
-            const colorSprite = colorSpriteMap[element];
+            const colorSprite = colorSpriteMap[element]!;
 
             const atom = document.createElement("img");
             atom.src = colorSprite;
@@ -268,7 +270,7 @@ function loadMolecule(model) {
             object.position.lerp(end, 0.5);
 
             object.userData.bondLengthShort = bondLength + "px";
-            object.userData.bondLengthFull = (bondLength + 55) + "px";
+            object.userData.bondLengthFull = bondLength + 55 + "px";
 
             //
 
@@ -309,7 +311,7 @@ function loadMolecule(model) {
             object.updateMatrix();
 
             object.userData.bondLengthShort = bondLength + "px";
-            object.userData.bondLengthFull = (bondLength + 55) + "px";
+            object.userData.bondLengthFull = bondLength + 55 + "px";
 
             object.userData.joint = joint;
 
@@ -319,7 +321,7 @@ function loadMolecule(model) {
             objects.push(object);
         }
 
-        //console.log( "CSS3DObjects:", objects.length );
+        // console.log( "CSS3DObjects:", objects.length );
 
         changeVizType(params.vizType);
     });
diff --git a/examples-testing/examples/css3d_orthographic.ts b/examples-testing/examples/css3d_orthographic.ts
index 793926f..7f2ea61 100644
--- a/examples-testing/examples/css3d_orthographic.ts
+++ b/examples-testing/examples/css3d_orthographic.ts
@@ -1,12 +1,12 @@
 import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { Controller, GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { CSS3DObject, CSS3DRenderer } from "three/addons/renderers/CSS3DRenderer.js";
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let camera, scene, renderer;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let scene2, renderer2;
+let scene2: THREE.Scene, renderer2: CSS3DRenderer;
 
 const frustumSize = 500;
 
@@ -16,8 +16,8 @@ animate();
 function init() {
     const aspect = window.innerWidth / window.innerHeight;
     camera = new THREE.OrthographicCamera(
-        frustumSize * aspect / -2,
-        frustumSize * aspect / 2,
+        (frustumSize * aspect) / -2,
+        (frustumSize * aspect) / 2,
         frustumSize / 2,
         frustumSize / -2,
         1,
@@ -47,13 +47,7 @@ function init() {
         new THREE.Euler(0, -90 * THREE.MathUtils.DEG2RAD, 0),
     );
     // right
-    createPlane(
-        100,
-        100,
-        "saddlebrown",
-        new THREE.Vector3(0, 0, 50),
-        new THREE.Euler(0, 0, 0),
-    );
+    createPlane(100, 100, "saddlebrown", new THREE.Vector3(0, 0, 50), new THREE.Euler(0, 0, 0));
     // top
     createPlane(
         100,
@@ -81,18 +75,18 @@ function init() {
     renderer2 = new CSS3DRenderer();
     renderer2.setSize(window.innerWidth, window.innerHeight);
     renderer2.domElement.style.position = "absolute";
-    renderer2.domElement.style.top = 0;
+    renderer2.domElement.style.top = "0";
     document.body.appendChild(renderer2.domElement);
 
     const controls = new OrbitControls(camera, renderer2.domElement);
     controls.minZoom = 0.5;
     controls.maxZoom = 2;
 
-    function createPlane(width, height, cssColor, pos, rot) {
+    function createPlane(width: number, height: number, cssColor: string, pos: THREE.Vector3, rot: THREE.Euler) {
         const element = document.createElement("div");
         element.style.width = width + "px";
         element.style.height = height + "px";
-        element.style.opacity = 0.75;
+        element.style.opacity = "0.75";
         element.style.background = cssColor;
 
         const object = new CSS3DObject(element);
@@ -114,8 +108,8 @@ function init() {
 function onWindowResize() {
     const aspect = window.innerWidth / window.innerHeight;
 
-    camera.left = -frustumSize * aspect / 2;
-    camera.right = frustumSize * aspect / 2;
+    camera.left = (-frustumSize * aspect) / 2;
+    camera.right = (frustumSize * aspect) / 2;
     camera.top = frustumSize / 2;
     camera.bottom = -frustumSize / 2;
 
@@ -138,50 +132,74 @@ function createPanel() {
     const folder1 = panel.addFolder("camera setViewOffset").close();
 
     const settings = {
-        "setViewOffset"() {
-            folder1.children[1].enable().setValue(window.innerWidth);
-            folder1.children[2].enable().setValue(window.innerHeight);
-            folder1.children[3].enable().setValue(0);
-            folder1.children[4].enable().setValue(0);
-            folder1.children[5].enable().setValue(window.innerWidth);
-            folder1.children[6].enable().setValue(window.innerHeight);
+        setViewOffset() {
+            (folder1.children[1] as Controller).enable().setValue(window.innerWidth);
+            (folder1.children[2] as Controller).enable().setValue(window.innerHeight);
+            (folder1.children[3] as Controller).enable().setValue(0);
+            (folder1.children[4] as Controller).enable().setValue(0);
+            (folder1.children[5] as Controller).enable().setValue(window.innerWidth);
+            (folder1.children[6] as Controller).enable().setValue(window.innerHeight);
         },
-        "fullWidth": 0,
-        "fullHeight": 0,
-        "offsetX": 0,
-        "offsetY": 0,
-        "width": 0,
-        "height": 0,
-        "clearViewOffset"() {
-            folder1.children[1].setValue(0).disable();
-            folder1.children[2].setValue(0).disable();
-            folder1.children[3].setValue(0).disable();
-            folder1.children[4].setValue(0).disable();
-            folder1.children[5].setValue(0).disable();
-            folder1.children[6].setValue(0).disable();
+        fullWidth: 0,
+        fullHeight: 0,
+        offsetX: 0,
+        offsetY: 0,
+        width: 0,
+        height: 0,
+        clearViewOffset() {
+            (folder1.children[1] as Controller).setValue(0).disable();
+            (folder1.children[2] as Controller).setValue(0).disable();
+            (folder1.children[3] as Controller).setValue(0).disable();
+            (folder1.children[4] as Controller).setValue(0).disable();
+            (folder1.children[5] as Controller).setValue(0).disable();
+            (folder1.children[6] as Controller).setValue(0).disable();
             camera.clearViewOffset();
         },
     };
 
     folder1.add(settings, "setViewOffset");
-    folder1.add(settings, "fullWidth", window.screen.width / 4, window.screen.width * 2, 1).onChange((val) =>
-        updateCameraViewOffset({ fullWidth: val })
-    ).disable();
-    folder1.add(settings, "fullHeight", window.screen.height / 4, window.screen.height * 2, 1).onChange((val) =>
-        updateCameraViewOffset({ fullHeight: val })
-    ).disable();
-    folder1.add(settings, "offsetX", 0, 256, 1).onChange((val) => updateCameraViewOffset({ x: val })).disable();
-    folder1.add(settings, "offsetY", 0, 256, 1).onChange((val) => updateCameraViewOffset({ y: val })).disable();
-    folder1.add(settings, "width", window.screen.width / 4, window.screen.width * 2, 1).onChange((val) =>
-        updateCameraViewOffset({ width: val })
-    ).disable();
-    folder1.add(settings, "height", window.screen.height / 4, window.screen.height * 2, 1).onChange((val) =>
-        updateCameraViewOffset({ height: val })
-    ).disable();
+    folder1
+        .add(settings, "fullWidth", window.screen.width / 4, window.screen.width * 2, 1)
+        .onChange(val => updateCameraViewOffset({ fullWidth: val }))
+        .disable();
+    folder1
+        .add(settings, "fullHeight", window.screen.height / 4, window.screen.height * 2, 1)
+        .onChange(val => updateCameraViewOffset({ fullHeight: val }))
+        .disable();
+    folder1
+        .add(settings, "offsetX", 0, 256, 1)
+        .onChange(val => updateCameraViewOffset({ x: val }))
+        .disable();
+    folder1
+        .add(settings, "offsetY", 0, 256, 1)
+        .onChange(val => updateCameraViewOffset({ y: val }))
+        .disable();
+    folder1
+        .add(settings, "width", window.screen.width / 4, window.screen.width * 2, 1)
+        .onChange(val => updateCameraViewOffset({ width: val }))
+        .disable();
+    folder1
+        .add(settings, "height", window.screen.height / 4, window.screen.height * 2, 1)
+        .onChange(val => updateCameraViewOffset({ height: val }))
+        .disable();
     folder1.add(settings, "clearViewOffset");
 }
 
-function updateCameraViewOffset({ fullWidth, fullHeight, x, y, width, height }) {
+function updateCameraViewOffset({
+    fullWidth,
+    fullHeight,
+    x,
+    y,
+    width,
+    height,
+}: {
+    fullWidth?: number;
+    fullHeight?: number;
+    x?: number;
+    y?: number;
+    width?: number;
+    height?: number;
+}) {
     if (!camera.view) {
         camera.setViewOffset(
             fullWidth || window.innerWidth,
diff --git a/examples-testing/examples/css3d_periodictable.ts b/examples-testing/examples/css3d_periodictable.ts
index 1050598..ded4320 100644
--- a/examples-testing/examples/css3d_periodictable.ts
+++ b/examples-testing/examples/css3d_periodictable.ts
@@ -1,7 +1,7 @@
 import * as THREE from "three";
 
-import TWEEN from "three/addons/libs/tween.module.js";
 import { TrackballControls } from "three/addons/controls/TrackballControls.js";
+import TWEEN from "three/addons/libs/tween.module.js";
 import { CSS3DObject, CSS3DRenderer } from "three/addons/renderers/CSS3DRenderer.js";
 
 const table = [
@@ -597,11 +597,16 @@ const table = [
     7,
 ];
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: CSS3DRenderer;
+let controls: TrackballControls;
 
-const objects = [];
-const targets = { table: [], sphere: [], helix: [], grid: [] };
+const objects: CSS3DObject[] = [];
+const targets: {
+    table: THREE.Object3D[];
+    sphere: THREE.Object3D[];
+    helix: THREE.Object3D[];
+    grid: THREE.Object3D[];
+} = { table: [], sphere: [], helix: [], grid: [] };
 
 init();
 animate();
@@ -621,12 +626,12 @@ function init() {
 
         const number = document.createElement("div");
         number.className = "number";
-        number.textContent = (i / 5) + 1;
+        number.textContent = `${i / 5 + 1}`;
         element.appendChild(number);
 
         const symbol = document.createElement("div");
         symbol.className = "symbol";
-        symbol.textContent = table[i];
+        symbol.textContent = table[i] as string;
         element.appendChild(symbol);
 
         const details = document.createElement("div");
@@ -645,8 +650,8 @@ function init() {
         //
 
         const object = new THREE.Object3D();
-        object.position.x = (table[i + 3] * 140) - 1330;
-        object.position.y = -(table[i + 4] * 180) + 990;
+        object.position.x = (table[i + 3] as number) * 140 - 1330;
+        object.position.y = -((table[i + 4] as number) * 180) + 990;
 
         targets.table.push(object);
     }
@@ -694,9 +699,9 @@ function init() {
     for (let i = 0; i < objects.length; i++) {
         const object = new THREE.Object3D();
 
-        object.position.x = ((i % 5) * 400) - 800;
-        object.position.y = (-(Math.floor(i / 5) % 5) * 400) + 800;
-        object.position.z = (Math.floor(i / 25)) * 1000 - 2000;
+        object.position.x = (i % 5) * 400 - 800;
+        object.position.y = -(Math.floor(i / 5) % 5) * 400 + 800;
+        object.position.z = Math.floor(i / 25) * 1000 - 2000;
 
         targets.grid.push(object);
     }
@@ -705,7 +710,7 @@ function init() {
 
     renderer = new CSS3DRenderer();
     renderer.setSize(window.innerWidth, window.innerHeight);
-    document.getElementById("container").appendChild(renderer.domElement);
+    document.getElementById("container")!.appendChild(renderer.domElement);
 
     //
 
@@ -714,23 +719,23 @@ function init() {
     controls.maxDistance = 6000;
     controls.addEventListener("change", render);
 
-    const buttonTable = document.getElementById("table");
-    buttonTable.addEventListener("click", function () {
+    const buttonTable = document.getElementById("table")!;
+    buttonTable.addEventListener("click", function() {
         transform(targets.table, 2000);
     });
 
-    const buttonSphere = document.getElementById("sphere");
-    buttonSphere.addEventListener("click", function () {
+    const buttonSphere = document.getElementById("sphere")!;
+    buttonSphere.addEventListener("click", function() {
         transform(targets.sphere, 2000);
     });
 
-    const buttonHelix = document.getElementById("helix");
-    buttonHelix.addEventListener("click", function () {
+    const buttonHelix = document.getElementById("helix")!;
+    buttonHelix.addEventListener("click", function() {
         transform(targets.helix, 2000);
     });
 
-    const buttonGrid = document.getElementById("grid");
-    buttonGrid.addEventListener("click", function () {
+    const buttonGrid = document.getElementById("grid")!;
+    buttonGrid.addEventListener("click", function() {
         transform(targets.grid, 2000);
     });
 
@@ -741,7 +746,7 @@ function init() {
     window.addEventListener("resize", onWindowResize);
 }
 
-function transform(targets, duration) {
+function transform(targets: THREE.Object3D[], duration: number) {
     TWEEN.removeAll();
 
     for (let i = 0; i < objects.length; i++) {
@@ -765,7 +770,7 @@ function transform(targets, duration) {
             .start();
     }
 
-    new TWEEN.Tween(this)
+    new TWEEN.Tween({})
         .to({}, duration * 2)
         .onUpdate(render)
         .start();
diff --git a/examples-testing/examples/css3d_sandbox.ts b/examples-testing/examples/css3d_sandbox.ts
index bfd592e..1e3c22b 100644
--- a/examples-testing/examples/css3d_sandbox.ts
+++ b/examples-testing/examples/css3d_sandbox.ts
@@ -1,14 +1,14 @@
 import * as THREE from "three";
 
 import { TrackballControls } from "three/addons/controls/TrackballControls.js";
+import { Controller, GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { CSS3DObject, CSS3DRenderer } from "three/addons/renderers/CSS3DRenderer.js";
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let scene2, renderer2;
+let scene2: THREE.Scene, renderer2: CSS3DRenderer;
 
-let controls;
+let controls: TrackballControls;
 
 init();
 animate();
@@ -35,7 +35,7 @@ function init() {
         const element = document.createElement("div");
         element.style.width = "100px";
         element.style.height = "100px";
-        element.style.opacity = (i < 5) ? 0.5 : 1;
+        element.style.opacity = `${i < 5 ? 0.5 : 1}`;
         element.style.background = new THREE.Color(Math.random() * 0xffffff).getStyle();
 
         const object = new CSS3DObject(element);
@@ -67,7 +67,7 @@ function init() {
     renderer2 = new CSS3DRenderer();
     renderer2.setSize(window.innerWidth, window.innerHeight);
     renderer2.domElement.style.position = "absolute";
-    renderer2.domElement.style.top = 0;
+    renderer2.domElement.style.top = "0";
     document.body.appendChild(renderer2.domElement);
 
     controls = new TrackballControls(camera, renderer2.domElement);
@@ -100,50 +100,74 @@ function createPanel() {
     const folder1 = panel.addFolder("camera setViewOffset").close();
 
     const settings = {
-        "setViewOffset"() {
-            folder1.children[1].enable().setValue(window.innerWidth);
-            folder1.children[2].enable().setValue(window.innerHeight);
-            folder1.children[3].enable().setValue(0);
-            folder1.children[4].enable().setValue(0);
-            folder1.children[5].enable().setValue(window.innerWidth);
-            folder1.children[6].enable().setValue(window.innerHeight);
+        setViewOffset() {
+            (folder1.children[1] as Controller).enable().setValue(window.innerWidth);
+            (folder1.children[2] as Controller).enable().setValue(window.innerHeight);
+            (folder1.children[3] as Controller).enable().setValue(0);
+            (folder1.children[4] as Controller).enable().setValue(0);
+            (folder1.children[5] as Controller).enable().setValue(window.innerWidth);
+            (folder1.children[6] as Controller).enable().setValue(window.innerHeight);
         },
-        "fullWidth": 0,
-        "fullHeight": 0,
-        "offsetX": 0,
-        "offsetY": 0,
-        "width": 0,
-        "height": 0,
-        "clearViewOffset"() {
-            folder1.children[1].setValue(0).disable();
-            folder1.children[2].setValue(0).disable();
-            folder1.children[3].setValue(0).disable();
-            folder1.children[4].setValue(0).disable();
-            folder1.children[5].setValue(0).disable();
-            folder1.children[6].setValue(0).disable();
+        fullWidth: 0,
+        fullHeight: 0,
+        offsetX: 0,
+        offsetY: 0,
+        width: 0,
+        height: 0,
+        clearViewOffset() {
+            (folder1.children[1] as Controller).setValue(0).disable();
+            (folder1.children[2] as Controller).setValue(0).disable();
+            (folder1.children[3] as Controller).setValue(0).disable();
+            (folder1.children[4] as Controller).setValue(0).disable();
+            (folder1.children[5] as Controller).setValue(0).disable();
+            (folder1.children[6] as Controller).setValue(0).disable();
             camera.clearViewOffset();
         },
     };
 
     folder1.add(settings, "setViewOffset");
-    folder1.add(settings, "fullWidth", window.screen.width / 4, window.screen.width * 2, 1).onChange((val) =>
-        updateCameraViewOffset({ fullWidth: val })
-    ).disable();
-    folder1.add(settings, "fullHeight", window.screen.height / 4, window.screen.height * 2, 1).onChange((val) =>
-        updateCameraViewOffset({ fullHeight: val })
-    ).disable();
-    folder1.add(settings, "offsetX", 0, 256, 1).onChange((val) => updateCameraViewOffset({ x: val })).disable();
-    folder1.add(settings, "offsetY", 0, 256, 1).onChange((val) => updateCameraViewOffset({ y: val })).disable();
-    folder1.add(settings, "width", window.screen.width / 4, window.screen.width * 2, 1).onChange((val) =>
-        updateCameraViewOffset({ width: val })
-    ).disable();
-    folder1.add(settings, "height", window.screen.height / 4, window.screen.height * 2, 1).onChange((val) =>
-        updateCameraViewOffset({ height: val })
-    ).disable();
+    folder1
+        .add(settings, "fullWidth", window.screen.width / 4, window.screen.width * 2, 1)
+        .onChange(val => updateCameraViewOffset({ fullWidth: val }))
+        .disable();
+    folder1
+        .add(settings, "fullHeight", window.screen.height / 4, window.screen.height * 2, 1)
+        .onChange(val => updateCameraViewOffset({ fullHeight: val }))
+        .disable();
+    folder1
+        .add(settings, "offsetX", 0, 256, 1)
+        .onChange(val => updateCameraViewOffset({ x: val }))
+        .disable();
+    folder1
+        .add(settings, "offsetY", 0, 256, 1)
+        .onChange(val => updateCameraViewOffset({ y: val }))
+        .disable();
+    folder1
+        .add(settings, "width", window.screen.width / 4, window.screen.width * 2, 1)
+        .onChange(val => updateCameraViewOffset({ width: val }))
+        .disable();
+    folder1
+        .add(settings, "height", window.screen.height / 4, window.screen.height * 2, 1)
+        .onChange(val => updateCameraViewOffset({ height: val }))
+        .disable();
     folder1.add(settings, "clearViewOffset");
 }
 
-function updateCameraViewOffset({ fullWidth, fullHeight, x, y, width, height }) {
+function updateCameraViewOffset({
+    fullWidth,
+    fullHeight,
+    x,
+    y,
+    width,
+    height,
+}: {
+    fullWidth?: number;
+    fullHeight?: number;
+    x?: number;
+    y?: number;
+    width?: number;
+    height?: number;
+}) {
     if (!camera.view) {
         camera.setViewOffset(
             fullWidth || window.innerWidth,
diff --git a/examples-testing/examples/css3d_sprites.ts b/examples-testing/examples/css3d_sprites.ts
index 42fc448..b36de07 100644
--- a/examples-testing/examples/css3d_sprites.ts
+++ b/examples-testing/examples/css3d_sprites.ts
@@ -1,15 +1,15 @@
 import * as THREE from "three";
 
-import TWEEN from "three/addons/libs/tween.module.js";
 import { TrackballControls } from "three/addons/controls/TrackballControls.js";
+import TWEEN from "three/addons/libs/tween.module.js";
 import { CSS3DRenderer, CSS3DSprite } from "three/addons/renderers/CSS3DRenderer.js";
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: CSS3DRenderer;
+let controls: TrackballControls;
 
 const particlesTotal = 512;
-const positions = [];
-const objects = [];
+const positions: number[] = [];
+const objects: CSS3DSprite[] = [];
 let current = 0;
 
 init();
@@ -23,12 +23,12 @@ function init() {
     scene = new THREE.Scene();
 
     const image = document.createElement("img");
-    image.addEventListener("load", function () {
+    image.addEventListener("load", function() {
         for (let i = 0; i < particlesTotal; i++) {
-            const object = new CSS3DSprite(image.cloneNode());
-            object.position.x = Math.random() * 4000 - 2000,
-                object.position.y = Math.random() * 4000 - 2000,
-                object.position.z = Math.random() * 4000 - 2000;
+            const object = new CSS3DSprite(image.cloneNode() as typeof image);
+            (object.position.x = Math.random() * 4000 - 2000),
+                (object.position.y = Math.random() * 4000 - 2000),
+                (object.position.z = Math.random() * 4000 - 2000);
             scene.add(object);
 
             objects.push(object);
@@ -71,11 +71,7 @@ function init() {
     // Random
 
     for (let i = 0; i < particlesTotal; i++) {
-        positions.push(
-            Math.random() * 4000 - 2000,
-            Math.random() * 4000 - 2000,
-            Math.random() * 4000 - 2000,
-        );
+        positions.push(Math.random() * 4000 - 2000, Math.random() * 4000 - 2000, Math.random() * 4000 - 2000);
     }
 
     // Sphere
@@ -97,7 +93,7 @@ function init() {
 
     renderer = new CSS3DRenderer();
     renderer.setSize(window.innerWidth, window.innerHeight);
-    document.getElementById("container").appendChild(renderer.domElement);
+    document.getElementById("container")!.appendChild(renderer.domElement);
 
     //
 
@@ -123,16 +119,19 @@ function transition() {
         const object = objects[i];
 
         new TWEEN.Tween(object.position)
-            .to({
-                x: positions[j],
-                y: positions[j + 1],
-                z: positions[j + 2],
-            }, Math.random() * duration + duration)
+            .to(
+                {
+                    x: positions[j],
+                    y: positions[j + 1],
+                    z: positions[j + 2],
+                },
+                Math.random() * duration + duration,
+            )
             .easing(TWEEN.Easing.Exponential.InOut)
             .start();
     }
 
-    new TWEEN.Tween(this)
+    new TWEEN.Tween({})
         .to({}, duration * 3)
         .onComplete(transition)
         .start();
diff --git a/examples-testing/examples/css3d_youtube.ts b/examples-testing/examples/css3d_youtube.ts
index 5bb1a6f..173745e 100644
--- a/examples-testing/examples/css3d_youtube.ts
+++ b/examples-testing/examples/css3d_youtube.ts
@@ -3,10 +3,10 @@ import * as THREE from "three";
 import { TrackballControls } from "three/addons/controls/TrackballControls.js";
 import { CSS3DObject, CSS3DRenderer } from "three/addons/renderers/CSS3DRenderer.js";
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: CSS3DRenderer;
+let controls: TrackballControls;
 
-function Element(id, x, y, z, ry) {
+function Element(id: string, x: number, y: number, z: number, ry: number) {
     const div = document.createElement("div");
     div.style.width = "480px";
     div.style.height = "360px";
@@ -30,7 +30,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 5000);
     camera.position.set(500, 350, 750);
@@ -42,10 +42,10 @@ function init() {
     container.appendChild(renderer.domElement);
 
     const group = new THREE.Group();
-    group.add(new Element("SJOz3qjfQXU", 0, 0, 240, 0));
-    group.add(new Element("Y2-xZ-1HE-Q", 240, 0, 0, Math.PI / 2));
-    group.add(new Element("IrydklNpcFI", 0, 0, -240, Math.PI));
-    group.add(new Element("9ubytEsCaS0", -240, 0, 0, -Math.PI / 2));
+    group.add(Element("SJOz3qjfQXU", 0, 0, 240, 0));
+    group.add(Element("Y2-xZ-1HE-Q", 240, 0, 0, Math.PI / 2));
+    group.add(Element("IrydklNpcFI", 0, 0, -240, Math.PI));
+    group.add(Element("9ubytEsCaS0", -240, 0, 0, -Math.PI / 2));
     scene.add(group);
 
     controls = new TrackballControls(camera, renderer.domElement);
@@ -55,13 +55,13 @@ function init() {
 
     // Block iframe events when dragging camera
 
-    const blocker = document.getElementById("blocker");
+    const blocker = document.getElementById("blocker")!;
     blocker.style.display = "none";
 
-    controls.addEventListener("start", function () {
+    controls.addEventListener("start", function() {
         blocker.style.display = "";
     });
-    controls.addEventListener("end", function () {
+    controls.addEventListener("end", function() {
         blocker.style.display = "none";
     });
 }
diff --git a/examples-testing/examples/games_fps.ts b/examples-testing/examples/games_fps.ts
index 62f1712..a779f00 100644
--- a/examples-testing/examples/games_fps.ts
+++ b/examples-testing/examples/games_fps.ts
@@ -4,8 +4,8 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-import { Octree } from "three/addons/math/Octree.js";
 import { OctreeHelper } from "three/addons/helpers/OctreeHelper.js";
+import { Octree } from "three/addons/math/Octree.js";
 
 import { Capsule } from "three/addons/math/Capsule.js";
 
@@ -39,7 +39,7 @@ directionalLight.shadow.radius = 4;
 directionalLight.shadow.bias = -0.00006;
 scene.add(directionalLight);
 
-const container = document.getElementById("container");
+const container = document.getElementById("container")!;
 
 const renderer = new THREE.WebGLRenderer({ antialias: true });
 renderer.setPixelRatio(window.devicePixelRatio);
@@ -50,9 +50,9 @@ renderer.toneMapping = THREE.ACESFilmicToneMapping;
 container.appendChild(renderer.domElement);
 
 const stats = new Stats();
-stats.domElement.style.position = "absolute";
-stats.domElement.style.top = "0px";
-container.appendChild(stats.domElement);
+stats.dom.style.position = "absolute";
+stats.dom.style.top = "0px";
+container.appendChild(stats.dom);
 
 const GRAVITY = 30;
 
@@ -64,7 +64,13 @@ const STEPS_PER_FRAME = 5;
 const sphereGeometry = new THREE.IcosahedronGeometry(SPHERE_RADIUS, 5);
 const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0xdede8d });
 
-const spheres = [];
+interface Sphere {
+    mesh: THREE.Mesh;
+    collider: THREE.Sphere;
+    velocity: THREE.Vector3;
+}
+
+const spheres: Sphere[] = [];
 let sphereIdx = 0;
 
 for (let i = 0; i < NUM_SPHERES; i++) {
@@ -91,17 +97,17 @@ const playerDirection = new THREE.Vector3();
 let playerOnFloor = false;
 let mouseTime = 0;
 
-const keyStates = {};
+const keyStates: { [eventCode: string]: boolean | undefined } = {};
 
 const vector1 = new THREE.Vector3();
 const vector2 = new THREE.Vector3();
 const vector3 = new THREE.Vector3();
 
-document.addEventListener("keydown", (event) => {
+document.addEventListener("keydown", event => {
     keyStates[event.code] = true;
 });
 
-document.addEventListener("keyup", (event) => {
+document.addEventListener("keyup", event => {
     keyStates[event.code] = false;
 });
 
@@ -115,7 +121,7 @@ document.addEventListener("mouseup", () => {
     if (document.pointerLockElement !== null) throwBall();
 });
 
-document.body.addEventListener("mousemove", (event) => {
+document.body.addEventListener("mousemove", event => {
     if (document.pointerLockElement === document.body) {
         camera.rotation.y -= event.movementX / 500;
         camera.rotation.x -= event.movementY / 500;
@@ -164,7 +170,7 @@ function playerCollisions() {
     }
 }
 
-function updatePlayer(deltaTime) {
+function updatePlayer(deltaTime: number) {
     let damping = Math.exp(-4 * deltaTime) - 1;
 
     if (!playerOnFloor) {
@@ -184,7 +190,7 @@ function updatePlayer(deltaTime) {
     camera.position.copy(playerCollider.end);
 }
 
-function playerSphereCollision(sphere) {
+function playerSphereCollision(sphere: Sphere) {
     const center = vector1.addVectors(playerCollider.start, playerCollider.end).multiplyScalar(0.5);
 
     const sphere_center = sphere.collider.center;
@@ -239,8 +245,8 @@ function spheresCollisions() {
     }
 }
 
-function updateSpheres(deltaTime) {
-    spheres.forEach((sphere) => {
+function updateSpheres(deltaTime: number) {
+    spheres.forEach(sphere => {
         sphere.collider.center.addScaledVector(sphere.velocity, deltaTime);
 
         const result = worldOctree.sphereIntersect(sphere.collider);
@@ -282,7 +288,7 @@ function getSideVector() {
     return playerDirection;
 }
 
-function controls(deltaTime) {
+function controls(deltaTime: number) {
     // gives a bit of air control
     const speedDelta = deltaTime * (playerOnFloor ? 25 : 8);
 
@@ -311,18 +317,18 @@ function controls(deltaTime) {
 
 const loader = new GLTFLoader().setPath("./models/gltf/");
 
-loader.load("collision-world.glb", (gltf) => {
+loader.load("collision-world.glb", gltf => {
     scene.add(gltf.scene);
 
     worldOctree.fromGraphNode(gltf.scene);
 
-    gltf.scene.traverse((child) => {
-        if (child.isMesh) {
+    gltf.scene.traverse(child => {
+        if ((child as THREE.Mesh).isMesh) {
             child.castShadow = true;
             child.receiveShadow = true;
 
-            if (child.material.map) {
-                child.material.map.anisotropy = 4;
+            if (((child as THREE.Mesh).material as THREE.MeshStandardMaterial).map) {
+                ((child as THREE.Mesh).material as THREE.MeshStandardMaterial).map!.anisotropy = 4;
             }
         }
     });
@@ -332,10 +338,9 @@ loader.load("collision-world.glb", (gltf) => {
     scene.add(helper);
 
     const gui = new GUI({ width: 200 });
-    gui.add({ debug: false }, "debug")
-        .onChange(function (value) {
-            helper.visible = value;
-        });
+    gui.add({ debug: false }, "debug").onChange(function(value) {
+        helper.visible = value;
+    });
 
     animate();
 });
diff --git a/examples-testing/examples/misc_animation_groups.ts b/examples-testing/examples/misc_animation_groups.ts
index 0754063..406333c 100644
--- a/examples-testing/examples/misc_animation_groups.ts
+++ b/examples-testing/examples/misc_animation_groups.ts
@@ -2,8 +2,8 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let stats, clock;
-let scene, camera, renderer, mixer;
+let stats: Stats, clock: THREE.Clock;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, mixer: THREE.AnimationMixer;
 
 init();
 animate();
@@ -32,9 +32,9 @@ function init() {
         for (let j = 0; j < 5; j++) {
             const mesh = new THREE.Mesh(geometry, material);
 
-            mesh.position.x = 32 - (16 * i);
+            mesh.position.x = 32 - 16 * i;
             mesh.position.y = 0;
-            mesh.position.z = 32 - (16 * j);
+            mesh.position.z = 32 - 16 * j;
 
             scene.add(mesh);
             animationGroup.add(mesh);
@@ -46,20 +46,24 @@ function init() {
     const xAxis = new THREE.Vector3(1, 0, 0);
     const qInitial = new THREE.Quaternion().setFromAxisAngle(xAxis, 0);
     const qFinal = new THREE.Quaternion().setFromAxisAngle(xAxis, Math.PI);
-    const quaternionKF = new THREE.QuaternionKeyframeTrack(".quaternion", [0, 1, 2], [
-        qInitial.x,
-        qInitial.y,
-        qInitial.z,
-        qInitial.w,
-        qFinal.x,
-        qFinal.y,
-        qFinal.z,
-        qFinal.w,
-        qInitial.x,
-        qInitial.y,
-        qInitial.z,
-        qInitial.w,
-    ]);
+    const quaternionKF = new THREE.QuaternionKeyframeTrack(
+        ".quaternion",
+        [0, 1, 2],
+        [
+            qInitial.x,
+            qInitial.y,
+            qInitial.z,
+            qInitial.w,
+            qFinal.x,
+            qFinal.y,
+            qFinal.z,
+            qFinal.w,
+            qInitial.x,
+            qInitial.y,
+            qInitial.z,
+            qInitial.w,
+        ],
+    );
 
     const colorKF = new THREE.ColorKeyframeTrack(
         ".material.color",
diff --git a/examples-testing/examples/misc_animation_keys.ts b/examples-testing/examples/misc_animation_keys.ts
index 1764209..0fa8303 100644
--- a/examples-testing/examples/misc_animation_keys.ts
+++ b/examples-testing/examples/misc_animation_keys.ts
@@ -2,8 +2,8 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let stats, clock;
-let scene, camera, renderer, mixer;
+let stats: Stats, clock: THREE.Clock;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, mixer: THREE.AnimationMixer;
 
 init();
 animate();
@@ -25,7 +25,10 @@ function init() {
     //
 
     const geometry = new THREE.BoxGeometry(5, 5, 5);
-    const material = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true });
+    const material = new THREE.MeshBasicMaterial({
+        color: 0xffffff,
+        transparent: true,
+    });
     const mesh = new THREE.Mesh(geometry, material);
     scene.add(mesh);
 
@@ -47,20 +50,24 @@ function init() {
 
     const qInitial = new THREE.Quaternion().setFromAxisAngle(xAxis, 0);
     const qFinal = new THREE.Quaternion().setFromAxisAngle(xAxis, Math.PI);
-    const quaternionKF = new THREE.QuaternionKeyframeTrack(".quaternion", [0, 1, 2], [
-        qInitial.x,
-        qInitial.y,
-        qInitial.z,
-        qInitial.w,
-        qFinal.x,
-        qFinal.y,
-        qFinal.z,
-        qFinal.w,
-        qInitial.x,
-        qInitial.y,
-        qInitial.z,
-        qInitial.w,
-    ]);
+    const quaternionKF = new THREE.QuaternionKeyframeTrack(
+        ".quaternion",
+        [0, 1, 2],
+        [
+            qInitial.x,
+            qInitial.y,
+            qInitial.z,
+            qInitial.w,
+            qFinal.x,
+            qFinal.y,
+            qFinal.z,
+            qFinal.w,
+            qInitial.x,
+            qInitial.y,
+            qInitial.z,
+            qInitial.w,
+        ],
+    );
 
     // COLOR
     const colorKF = new THREE.ColorKeyframeTrack(
diff --git a/examples-testing/examples/misc_boxselection.ts b/examples-testing/examples/misc_boxselection.ts
index 5163d40..47c6e69 100644
--- a/examples-testing/examples/misc_boxselection.ts
+++ b/examples-testing/examples/misc_boxselection.ts
@@ -5,8 +5,8 @@ import Stats from "three/addons/libs/stats.module.js";
 import { SelectionBox } from "three/addons/interactive/SelectionBox.js";
 import { SelectionHelper } from "three/addons/interactive/SelectionHelper.js";
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -92,12 +92,12 @@ function render() {
     renderer.render(scene, camera);
 }
 
-const selectionBox = new SelectionBox(camera, scene);
-const helper = new SelectionHelper(renderer, "selectBox");
+const selectionBox = new SelectionBox(camera!, scene!);
+const helper = new SelectionHelper(renderer!, "selectBox");
 
-document.addEventListener("pointerdown", function (event) {
+document.addEventListener("pointerdown", function(event) {
     for (const item of selectionBox.collection) {
-        item.material.emissive.set(0x000000);
+        (item.material as THREE.MeshLambertMaterial).emissive.set(0x000000);
     }
 
     selectionBox.startPoint.set(
@@ -107,10 +107,10 @@ document.addEventListener("pointerdown", function (event) {
     );
 });
 
-document.addEventListener("pointermove", function (event) {
+document.addEventListener("pointermove", function(event) {
     if (helper.isDown) {
         for (let i = 0; i < selectionBox.collection.length; i++) {
-            selectionBox.collection[i].material.emissive.set(0x000000);
+            (selectionBox.collection[i].material as THREE.MeshLambertMaterial).emissive.set(0x000000);
         }
 
         selectionBox.endPoint.set(
@@ -122,12 +122,12 @@ document.addEventListener("pointermove", function (event) {
         const allSelected = selectionBox.select();
 
         for (let i = 0; i < allSelected.length; i++) {
-            allSelected[i].material.emissive.set(0xffffff);
+            (allSelected[i].material as THREE.MeshLambertMaterial).emissive.set(0xffffff);
         }
     }
 });
 
-document.addEventListener("pointerup", function (event) {
+document.addEventListener("pointerup", function(event) {
     selectionBox.endPoint.set(
         (event.clientX / window.innerWidth) * 2 - 1,
         -(event.clientY / window.innerHeight) * 2 + 1,
@@ -137,6 +137,6 @@ document.addEventListener("pointerup", function (event) {
     const allSelected = selectionBox.select();
 
     for (let i = 0; i < allSelected.length; i++) {
-        allSelected[i].material.emissive.set(0xffffff);
+        (allSelected[i].material as THREE.MeshLambertMaterial).emissive.set(0xffffff);
     }
 });
diff --git a/examples-testing/examples/misc_controls_arcball.ts b/examples-testing/examples/misc_controls_arcball.ts
index cd61ef0..68b975e 100644
--- a/examples-testing/examples/misc_controls_arcball.ts
+++ b/examples-testing/examples/misc_controls_arcball.ts
@@ -12,13 +12,17 @@ const cameraType = { type: "Perspective" };
 
 const perspectiveDistance = 2.5;
 const orthographicDistance = 120;
-let camera, controls, scene, renderer, gui;
-let folderOptions, folderAnimations;
+let camera: THREE.OrthographicCamera | THREE.PerspectiveCamera,
+    controls: ArcballControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    gui: GUI;
+let folderOptions: GUI, folderAnimations: GUI;
 
 const arcballGui = {
     gizmoVisible: true,
 
-    setArcballControls: function () {
+    setArcballControls: function() {
         controls = new ArcballControls(camera, renderer.domElement, scene);
         controls.addEventListener("change", render);
 
@@ -27,7 +31,7 @@ const arcballGui = {
         this.populateGui();
     },
 
-    populateGui: function () {
+    populateGui: function() {
         folderOptions.add(controls, "enabled").name("Enable controls");
         folderOptions.add(controls, "enableGrid").name("Enable Grid");
         folderOptions.add(controls, "enableRotate").name("Enable rotate");
@@ -40,9 +44,12 @@ const arcballGui = {
         folderOptions.add(controls, "maxDistance", 0, 50, 0.5).name("Max distance");
         folderOptions.add(controls, "minZoom", 0, 50, 0.5).name("Min zoom");
         folderOptions.add(controls, "maxZoom", 0, 50, 0.5).name("Max zoom");
-        folderOptions.add(arcballGui, "gizmoVisible").name("Show gizmos").onChange(function () {
-            controls.setGizmosVisible(arcballGui.gizmoVisible);
-        });
+        folderOptions
+            .add(arcballGui, "gizmoVisible")
+            .name("Show gizmos")
+            .onChange(function() {
+                controls.setGizmosVisible(arcballGui.gizmoVisible);
+            });
         folderOptions.add(controls, "copyState").name("Copy state(ctrl+c)");
         folderOptions.add(controls, "pasteState").name("Paste state(ctrl+v)");
         folderOptions.add(controls, "reset").name("Reset");
@@ -75,64 +82,62 @@ function init() {
 
     const material = new THREE.MeshStandardMaterial();
 
-    new OBJLoader()
-        .setPath("models/obj/cerberus/")
-        .load("Cerberus.obj", function (group) {
-            const textureLoader = new THREE.TextureLoader().setPath("models/obj/cerberus/");
+    new OBJLoader().setPath("models/obj/cerberus/").load("Cerberus.obj", function(group) {
+        const textureLoader = new THREE.TextureLoader().setPath("models/obj/cerberus/");
 
-            material.roughness = 1;
-            material.metalness = 1;
+        material.roughness = 1;
+        material.metalness = 1;
 
-            const diffuseMap = textureLoader.load("Cerberus_A.jpg", render);
-            diffuseMap.colorSpace = THREE.SRGBColorSpace;
-            material.map = diffuseMap;
+        const diffuseMap = textureLoader.load("Cerberus_A.jpg", render);
+        diffuseMap.colorSpace = THREE.SRGBColorSpace;
+        material.map = diffuseMap;
 
-            material.metalnessMap = material.roughnessMap = textureLoader.load("Cerberus_RM.jpg", render);
-            material.normalMap = textureLoader.load("Cerberus_N.jpg", render);
+        material.metalnessMap = material.roughnessMap = textureLoader.load("Cerberus_RM.jpg", render);
+        material.normalMap = textureLoader.load("Cerberus_N.jpg", render);
 
-            material.map.wrapS = THREE.RepeatWrapping;
-            material.roughnessMap.wrapS = THREE.RepeatWrapping;
-            material.metalnessMap.wrapS = THREE.RepeatWrapping;
-            material.normalMap.wrapS = THREE.RepeatWrapping;
+        material.map.wrapS = THREE.RepeatWrapping;
+        material.roughnessMap.wrapS = THREE.RepeatWrapping;
+        material.metalnessMap.wrapS = THREE.RepeatWrapping;
+        material.normalMap.wrapS = THREE.RepeatWrapping;
 
-            group.traverse(function (child) {
-                if (child.isMesh) {
-                    child.material = material;
-                }
-            });
+        group.traverse(function(child) {
+            if ((child as THREE.Mesh).isMesh) {
+                (child as THREE.Mesh).material = material;
+            }
+        });
 
-            group.rotation.y = Math.PI / 2;
-            group.position.x += 0.25;
-            scene.add(group);
-            render();
+        group.rotation.y = Math.PI / 2;
+        group.position.x += 0.25;
+        scene.add(group);
+        render();
 
-            new RGBELoader()
-                .setPath("textures/equirectangular/")
-                .load("venice_sunset_1k.hdr", function (hdrEquirect) {
-                    hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;
+        new RGBELoader().setPath("textures/equirectangular/").load("venice_sunset_1k.hdr", function(hdrEquirect) {
+            hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;
 
-                    scene.environment = hdrEquirect;
+            scene.environment = hdrEquirect;
 
-                    render();
-                });
+            render();
+        });
 
-            window.addEventListener("keydown", onKeyDown);
-            window.addEventListener("resize", onWindowResize);
+        window.addEventListener("keydown", onKeyDown);
+        window.addEventListener("resize", onWindowResize);
 
-            //
+        //
 
-            gui = new GUI();
-            gui.add(cameraType, "type", cameras).name("Choose Camera").onChange(function () {
+        gui = new GUI();
+        gui.add(cameraType, "type", cameras)
+            .name("Choose Camera")
+            .onChange(function() {
                 setCamera(cameraType.type);
             });
 
-            folderOptions = gui.addFolder("Arcball parameters");
-            folderAnimations = folderOptions.addFolder("Animations");
+        folderOptions = gui.addFolder("Arcball parameters");
+        folderAnimations = folderOptions.addFolder("Animations");
 
-            arcballGui.setArcballControls();
+        arcballGui.setArcballControls();
 
-            render();
-        });
+        render();
+    });
 }
 
 function makeOrthographicCamera() {
@@ -163,12 +168,12 @@ function onWindowResize() {
 
         const halfW = perspectiveDistance * Math.tan(halfFovH);
         const halfH = perspectiveDistance * Math.tan(halfFovV);
-        camera.left = -halfW;
-        camera.right = halfW;
-        camera.top = halfH;
-        camera.bottom = -halfH;
+        (camera as THREE.OrthographicCamera).left = -halfW;
+        (camera as THREE.OrthographicCamera).right = halfW;
+        (camera as THREE.OrthographicCamera).top = halfH;
+        (camera as THREE.OrthographicCamera).bottom = -halfH;
     } else if (camera.type == "PerspectiveCamera") {
-        camera.aspect = window.innerWidth / window.innerHeight;
+        (camera as THREE.PerspectiveCamera).aspect = window.innerWidth / window.innerHeight;
     }
 
     camera.updateProjectionMatrix();
@@ -182,7 +187,7 @@ function render() {
     renderer.render(scene, camera);
 }
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     if (event.key === "c") {
         if (event.ctrlKey || event.metaKey) {
             controls.copyState();
@@ -194,7 +199,7 @@ function onKeyDown(event) {
     }
 }
 
-function setCamera(type) {
+function setCamera(type: string) {
     if (type == "Orthographic") {
         camera = makeOrthographicCamera();
         camera.position.set(0, 0, orthographicDistance);
diff --git a/examples-testing/examples/misc_controls_drag.ts b/examples-testing/examples/misc_controls_drag.ts
index 7eb651b..db0c014 100644
--- a/examples-testing/examples/misc_controls_drag.ts
+++ b/examples-testing/examples/misc_controls_drag.ts
@@ -2,14 +2,15 @@ import * as THREE from "three";
 
 import { DragControls } from "three/addons/controls/DragControls.js";
 
-let container;
-let camera, scene, renderer;
-let controls, group;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controls: DragControls, group: THREE.Group;
 let enableSelection = false;
 
-const objects = [];
+const objects: THREE.Object3D[] = [];
 
-const mouse = new THREE.Vector2(), raycaster = new THREE.Raycaster();
+const mouse = new THREE.Vector2(),
+    raycaster = new THREE.Raycaster();
 
 init();
 
@@ -96,15 +97,15 @@ function onWindowResize() {
     render();
 }
 
-function onKeyDown(event) {
-    enableSelection = (event.keyCode === 16) ? true : false;
+function onKeyDown(event: KeyboardEvent) {
+    enableSelection = event.keyCode === 16 ? true : false;
 }
 
 function onKeyUp() {
     enableSelection = false;
 }
 
-function onClick(event) {
+function onClick(event: MouseEvent) {
     event.preventDefault();
 
     if (enableSelection === true) {
@@ -122,10 +123,10 @@ function onClick(event) {
             const object = intersections[0].object;
 
             if (group.children.includes(object) === true) {
-                object.material.emissive.set(0x000000);
+                ((object as THREE.Mesh).material as THREE.MeshLambertMaterial).emissive.set(0x000000);
                 scene.attach(object);
             } else {
-                object.material.emissive.set(0xaaaaaa);
+                ((object as THREE.Mesh).material as THREE.MeshLambertMaterial).emissive.set(0xaaaaaa);
                 group.attach(object);
             }
 
diff --git a/examples-testing/examples/misc_controls_fly.ts b/examples-testing/examples/misc_controls_fly.ts
index 7cacf0c..b46617b 100644
--- a/examples-testing/examples/misc_controls_fly.ts
+++ b/examples-testing/examples/misc_controls_fly.ts
@@ -4,9 +4,9 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { FlyControls } from "three/addons/controls/FlyControls.js";
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
-import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { FilmPass } from "three/addons/postprocessing/FilmPass.js";
 import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
+import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 
 const radius = 6371;
 const tilt = 0.41;
@@ -19,11 +19,15 @@ const MARGIN = 0;
 let SCREEN_HEIGHT = window.innerHeight - MARGIN * 2;
 let SCREEN_WIDTH = window.innerWidth;
 
-let camera, controls, scene, renderer, stats;
-let geometry, meshPlanet, meshClouds, meshMoon;
-let dirLight;
+let camera: THREE.PerspectiveCamera,
+    controls: FlyControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats;
+let geometry: THREE.SphereGeometry, meshPlanet: THREE.Mesh, meshClouds: THREE.Mesh, meshMoon: THREE.Mesh;
+let dirLight: THREE.DirectionalLight;
 
-let composer;
+let composer: EffectComposer;
 
 const textureLoader = new THREE.TextureLoader();
 
@@ -56,7 +60,7 @@ function init() {
         // y scale is negated to compensate for normal map handedness.
         normalScale: new THREE.Vector2(0.85, -0.85),
     });
-    materialNormalMap.map.colorSpace = THREE.SRGBColorSpace;
+    materialNormalMap.map!.colorSpace = THREE.SRGBColorSpace;
 
     // planet
 
@@ -73,7 +77,7 @@ function init() {
         map: textureLoader.load("textures/planets/earth_clouds_1024.png"),
         transparent: true,
     });
-    materialClouds.map.colorSpace = THREE.SRGBColorSpace;
+    materialClouds.map!.colorSpace = THREE.SRGBColorSpace;
 
     meshClouds = new THREE.Mesh(geometry, materialClouds);
     meshClouds.scale.set(cloudsScale, cloudsScale, cloudsScale);
@@ -85,7 +89,7 @@ function init() {
     const materialMoon = new THREE.MeshPhongMaterial({
         map: textureLoader.load("textures/planets/moon_1024.jpg"),
     });
-    materialMoon.map.colorSpace = THREE.SRGBColorSpace;
+    materialMoon.map!.colorSpace = THREE.SRGBColorSpace;
 
     meshMoon = new THREE.Mesh(geometry, materialMoon);
     meshMoon.position.set(radius * 5, 0, 0);
@@ -94,7 +98,8 @@ function init() {
 
     // stars
 
-    const r = radius, starsGeometry = [new THREE.BufferGeometry(), new THREE.BufferGeometry()];
+    const r = radius,
+        starsGeometry = [new THREE.BufferGeometry(), new THREE.BufferGeometry()];
 
     const vertices1 = [];
     const vertices2 = [];
diff --git a/examples-testing/examples/misc_controls_map.ts b/examples-testing/examples/misc_controls_map.ts
index 34bc6e2..3d81ea9 100644
--- a/examples-testing/examples/misc_controls_map.ts
+++ b/examples-testing/examples/misc_controls_map.ts
@@ -4,10 +4,10 @@ import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
 import { MapControls } from "three/addons/controls/MapControls.js";
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: MapControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
-//render(); // remove when using next line for animation loop (requestAnimationFrame)
+// render(); // remove when using next line for animation loop (requestAnimationFrame)
 animate();
 
 function init() {
@@ -27,7 +27,7 @@ function init() {
 
     controls = new MapControls(camera, renderer.domElement);
 
-    //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)
+    // controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)
 
     controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
     controls.dampingFactor = 0.05;
diff --git a/examples-testing/examples/misc_controls_orbit.ts b/examples-testing/examples/misc_controls_orbit.ts
index 064996b..c859bda 100644
--- a/examples-testing/examples/misc_controls_orbit.ts
+++ b/examples-testing/examples/misc_controls_orbit.ts
@@ -2,10 +2,10 @@ import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
-//render(); // remove when using next line for animation loop (requestAnimationFrame)
+// render(); // remove when using next line for animation loop (requestAnimationFrame)
 animate();
 
 function init() {
@@ -26,7 +26,7 @@ function init() {
     controls = new OrbitControls(camera, renderer.domElement);
     controls.listenToKeyEvents(window); // optional
 
-    //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)
+    // controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)
 
     controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
     controls.dampingFactor = 0.05;
diff --git a/examples-testing/examples/misc_controls_pointerlock.ts b/examples-testing/examples/misc_controls_pointerlock.ts
index 7c03111..1e97c97 100644
--- a/examples-testing/examples/misc_controls_pointerlock.ts
+++ b/examples-testing/examples/misc_controls_pointerlock.ts
@@ -2,11 +2,11 @@ import * as THREE from "three";
 
 import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: PointerLockControls;
 
-const objects = [];
+const objects: THREE.Mesh[] = [];
 
-let raycaster;
+let raycaster: THREE.Raycaster;
 
 let moveForward = false;
 let moveBackward = false;
@@ -37,26 +37,26 @@ function init() {
 
     controls = new PointerLockControls(camera, document.body);
 
-    const blocker = document.getElementById("blocker");
-    const instructions = document.getElementById("instructions");
+    const blocker = document.getElementById("blocker")!;
+    const instructions = document.getElementById("instructions")!;
 
-    instructions.addEventListener("click", function () {
+    instructions.addEventListener("click", function() {
         controls.lock();
     });
 
-    controls.addEventListener("lock", function () {
+    controls.addEventListener("lock", function() {
         instructions.style.display = "none";
         blocker.style.display = "none";
     });
 
-    controls.addEventListener("unlock", function () {
+    controls.addEventListener("unlock", function() {
         blocker.style.display = "block";
         instructions.style.display = "";
     });
 
     scene.add(controls.getObject());
 
-    const onKeyDown = function (event) {
+    const onKeyDown = function(event: KeyboardEvent) {
         switch (event.code) {
             case "ArrowUp":
             case "KeyW":
@@ -85,7 +85,7 @@ function init() {
         }
     };
 
-    const onKeyUp = function (event) {
+    const onKeyUp = function(event: KeyboardEvent) {
         switch (event.code) {
             case "ArrowUp":
             case "KeyW":
@@ -116,7 +116,7 @@ function init() {
 
     // floor
 
-    let floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
+    let floorGeometry: THREE.BufferGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
     floorGeometry.rotateX(-Math.PI / 2);
 
     // vertex displacement
@@ -165,7 +165,11 @@ function init() {
     boxGeometry.setAttribute("color", new THREE.Float32BufferAttribute(colorsBox, 3));
 
     for (let i = 0; i < 500; i++) {
-        const boxMaterial = new THREE.MeshPhongMaterial({ specular: 0xffffff, flatShading: true, vertexColors: true });
+        const boxMaterial = new THREE.MeshPhongMaterial({
+            specular: 0xffffff,
+            flatShading: true,
+            vertexColors: true,
+        });
         boxMaterial.color.setHSL(Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75, THREE.SRGBColorSpace);
 
         const box = new THREE.Mesh(boxGeometry, boxMaterial);
diff --git a/examples-testing/examples/misc_controls_trackball.ts b/examples-testing/examples/misc_controls_trackball.ts
index 080ca1d..c8bb4f4 100644
--- a/examples-testing/examples/misc_controls_trackball.ts
+++ b/examples-testing/examples/misc_controls_trackball.ts
@@ -1,11 +1,16 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { TrackballControls } from "three/addons/controls/TrackballControls.js";
 
-let perspectiveCamera, orthographicCamera, controls, scene, renderer, stats;
+let perspectiveCamera: THREE.PerspectiveCamera,
+    orthographicCamera: THREE.OrthographicCamera,
+    controls: TrackballControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats;
 
 const params = {
     orthographicCamera: false,
@@ -23,8 +28,8 @@ function init() {
     perspectiveCamera.position.z = 500;
 
     orthographicCamera = new THREE.OrthographicCamera(
-        frustumSize * aspect / -2,
-        frustumSize * aspect / 2,
+        (frustumSize * aspect) / -2,
+        (frustumSize * aspect) / 2,
         frustumSize / 2,
         frustumSize / -2,
         1,
@@ -77,11 +82,13 @@ function init() {
     //
 
     const gui = new GUI();
-    gui.add(params, "orthographicCamera").name("use orthographic").onChange(function (value) {
-        controls.dispose();
+    gui.add(params, "orthographicCamera")
+        .name("use orthographic")
+        .onChange(function(value) {
+            controls.dispose();
 
-        createControls(value ? orthographicCamera : perspectiveCamera);
-    });
+            createControls(value ? orthographicCamera : perspectiveCamera);
+        });
 
     //
 
@@ -90,7 +97,7 @@ function init() {
     createControls(perspectiveCamera);
 }
 
-function createControls(camera) {
+function createControls(camera: THREE.Camera) {
     controls = new TrackballControls(camera, renderer.domElement);
 
     controls.rotateSpeed = 1.0;
@@ -106,8 +113,8 @@ function onWindowResize() {
     perspectiveCamera.aspect = aspect;
     perspectiveCamera.updateProjectionMatrix();
 
-    orthographicCamera.left = -frustumSize * aspect / 2;
-    orthographicCamera.right = frustumSize * aspect / 2;
+    orthographicCamera.left = (-frustumSize * aspect) / 2;
+    orthographicCamera.right = (frustumSize * aspect) / 2;
     orthographicCamera.top = frustumSize / 2;
     orthographicCamera.bottom = -frustumSize / 2;
     orthographicCamera.updateProjectionMatrix();
@@ -128,7 +135,7 @@ function animate() {
 }
 
 function render() {
-    const camera = (params.orthographicCamera) ? orthographicCamera : perspectiveCamera;
+    const camera = params.orthographicCamera ? orthographicCamera : perspectiveCamera;
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/misc_controls_transform.ts b/examples-testing/examples/misc_controls_transform.ts
index f04331b..26c1ed9 100644
--- a/examples-testing/examples/misc_controls_transform.ts
+++ b/examples-testing/examples/misc_controls_transform.ts
@@ -3,8 +3,8 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { TransformControls } from "three/addons/controls/TransformControls.js";
 
-let cameraPersp, cameraOrtho, currentCamera;
-let scene, renderer, control, orbit;
+let cameraPersp: THREE.PerspectiveCamera, cameraOrtho: THREE.OrthographicCamera, currentCamera: THREE.Camera;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer, control: TransformControls, orbit: OrbitControls;
 
 init();
 render();
@@ -47,7 +47,7 @@ function init() {
     control = new TransformControls(currentCamera, renderer.domElement);
     control.addEventListener("change", render);
 
-    control.addEventListener("dragging-changed", function (event) {
+    control.addEventListener("dragging-changed", function(event) {
         orbit.enabled = !event.value;
     });
 
@@ -59,7 +59,7 @@ function init() {
 
     window.addEventListener("resize", onWindowResize);
 
-    window.addEventListener("keydown", function (event) {
+    window.addEventListener("keydown", function(event) {
         switch (event.keyCode) {
             case 81: // Q
                 control.setSpace(control.space === "local" ? "world" : "local");
@@ -86,7 +86,9 @@ function init() {
             case 67: // C
                 const position = currentCamera.position.clone();
 
-                currentCamera = currentCamera.isPerspectiveCamera ? cameraOrtho : cameraPersp;
+                currentCamera = (currentCamera as THREE.PerspectiveCamera).isPerspectiveCamera
+                    ? cameraOrtho
+                    : cameraPersp;
                 currentCamera.position.copy(position);
 
                 orbit.object = currentCamera;
@@ -141,7 +143,7 @@ function init() {
         }
     });
 
-    window.addEventListener("keyup", function (event) {
+    window.addEventListener("keyup", function(event) {
         switch (event.keyCode) {
             case 16: // Shift
                 control.setTranslationSnap(null);
diff --git a/examples-testing/examples/misc_exporter_draco.ts b/examples-testing/examples/misc_exporter_draco.ts
index b37f8ae..8f8b1ec 100644
--- a/examples-testing/examples/misc_exporter_draco.ts
+++ b/examples-testing/examples/misc_exporter_draco.ts
@@ -4,7 +4,11 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { DRACOExporter } from "three/addons/exporters/DRACOExporter.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let scene, camera, renderer, exporter, mesh;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGLRenderer,
+    exporter: DRACOExporter,
+    mesh: THREE.Mesh;
 
 const params = {
     export: exportFile,
@@ -107,12 +111,12 @@ const link = document.createElement("a");
 link.style.display = "none";
 document.body.appendChild(link);
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: BufferSource, filename: string) {
     save(new Blob([buffer], { type: "application/octet-stream" }), filename);
 }
diff --git a/examples-testing/examples/misc_exporter_exr.ts b/examples-testing/examples/misc_exporter_exr.ts
index 71d7429..61be582 100644
--- a/examples-testing/examples/misc_exporter_exr.ts
+++ b/examples-testing/examples/misc_exporter_exr.ts
@@ -2,10 +2,17 @@ import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { EXRExporter, NO_COMPRESSION, ZIP_COMPRESSION, ZIPS_COMPRESSION } from "three/addons/exporters/EXRExporter.js";
-import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 
-let scene, camera, renderer, exporter, mesh, controls, renderTarget, dataTexture;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGLRenderer,
+    exporter: EXRExporter,
+    mesh: THREE.Mesh,
+    controls: OrbitControls,
+    renderTarget: THREE.WebGLRenderTarget,
+    dataTexture: THREE.DataTexture;
 
 const params = {
     target: "pmrem",
@@ -38,7 +45,7 @@ function init() {
     const pmremGenerator = new THREE.PMREMGenerator(renderer);
     pmremGenerator.compileEquirectangularShader();
 
-    rgbeloader.load("textures/equirectangular/san_giuseppe_bridge_2k.hdr", function (texture) {
+    rgbeloader.load("textures/equirectangular/san_giuseppe_bridge_2k.hdr", function(texture) {
         texture.mapping = THREE.EquirectangularReflectionMapping;
 
         renderTarget = pmremGenerator.fromEquirectangular(texture);
@@ -86,7 +93,9 @@ function animate() {
 function createDataTexture() {
     const normal = new THREE.Vector3();
     const coord = new THREE.Vector2();
-    const size = 800, radius = 320, factor = Math.PI * 0.5 / radius;
+    const size = 800,
+        radius = 320,
+        factor = (Math.PI * 0.5) / radius;
     const data = new Float32Array(4 * size * size);
 
     for (let i = 0; i < size; i++) {
@@ -95,19 +104,13 @@ function createDataTexture() {
             coord.set(j, i).subScalar(size / 2);
 
             if (coord.length() < radius) {
-                normal.set(
-                    Math.sin(coord.x * factor),
-                    Math.sin(coord.y * factor),
-                    Math.cos(coord.x * factor),
-                );
-            } else {
-                normal.set(0, 0, 1);
-            }
-
-            data[idx + 0] = .5 + .5 * normal.x;
-            data[idx + 1] = .5 + .5 * normal.y;
-            data[idx + 2] = .5 + .5 * normal.z;
-            data[idx + 3] = 1.;
+                normal.set(Math.sin(coord.x * factor), Math.sin(coord.y * factor), Math.cos(coord.x * factor));
+            } else normal.set(0, 0, 1);
+
+            data[idx + 0] = 0.5 + 0.5 * normal.x;
+            data[idx + 1] = 0.5 + 0.5 * normal.y;
+            data[idx + 2] = 0.5 + 0.5 * normal.z;
+            data[idx + 3] = 1;
         }
     }
 
@@ -139,30 +142,21 @@ function swapScene() {
 function exportFile() {
     let result, exportType, exportCompression;
 
-    if (params.type == "HalfFloatType") {
-        exportType = THREE.HalfFloatType;
-    } else {
-        exportType = THREE.FloatType;
-    }
+    if (params.type == "HalfFloatType") exportType = THREE.HalfFloatType;
+    else exportType = THREE.FloatType;
 
-    if (params.compression == "ZIP") {
-        exportCompression = ZIP_COMPRESSION;
-    } else if (params.compression == "ZIPS") {
-        exportCompression = ZIPS_COMPRESSION;
-    } else {
-        exportCompression = NO_COMPRESSION;
-    }
+    if (params.compression == "ZIP") exportCompression = ZIP_COMPRESSION;
+    else if (params.compression == "ZIPS") exportCompression = ZIPS_COMPRESSION;
+    else exportCompression = NO_COMPRESSION;
 
     if (params.target == "pmrem") {
         result = exporter.parse(renderer, renderTarget, { type: exportType, compression: exportCompression });
-    } else {
-        result = exporter.parse(dataTexture, { type: exportType, compression: exportCompression });
-    }
+    } else result = exporter.parse(dataTexture, { type: exportType, compression: exportCompression });
 
     saveArrayBuffer(result, params.target + ".exr");
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: Uint8Array, filename: string) {
     const blob = new Blob([buffer], { type: "image/x-exr" });
     const link = document.createElement("a");
 
diff --git a/examples-testing/examples/misc_exporter_gltf.ts b/examples-testing/examples/misc_exporter_gltf.ts
index 59e2425..78857ad 100644
--- a/examples-testing/examples/misc_exporter_gltf.ts
+++ b/examples-testing/examples/misc_exporter_gltf.ts
@@ -1,12 +1,12 @@
 import * as THREE from "three";
 
 import { GLTFExporter } from "three/addons/exporters/GLTFExporter.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
-import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-function exportGLTF(input) {
+function exportGLTF(input: THREE.Object3D | THREE.Object3D[]) {
     const gltfExporter = new GLTFExporter();
 
     const options = {
@@ -17,7 +17,7 @@ function exportGLTF(input) {
     };
     gltfExporter.parse(
         input,
-        function (result) {
+        function(result) {
             if (result instanceof ArrayBuffer) {
                 saveArrayBuffer(result, "scene.glb");
             } else {
@@ -26,7 +26,7 @@ function exportGLTF(input) {
                 saveString(output, "scene.gltf");
             }
         },
-        function (error) {
+        function(error) {
             console.log("An error happened during parsing", error);
         },
         options,
@@ -37,7 +37,7 @@ const link = document.createElement("a");
 link.style.display = "none";
 document.body.appendChild(link); // Firefox workaround, see #6594
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
@@ -45,18 +45,25 @@ function save(blob, filename) {
     // URL.revokeObjectURL( url ); breaks Firefox...
 }
 
-function saveString(text, filename) {
+function saveString(text: string, filename: string) {
     save(new Blob([text], { type: "text/plain" }), filename);
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: BufferSource, filename: string) {
     save(new Blob([buffer], { type: "application/octet-stream" }), filename);
 }
 
-let container;
+let container: HTMLDivElement;
 
-let camera, object, object2, material, geometry, scene1, scene2, renderer;
-let gridHelper, sphere, model, coffeemat;
+let camera: THREE.PerspectiveCamera,
+    object: THREE.Object3D,
+    object2: THREE.Mesh,
+    material: THREE.MeshBasicMaterial | THREE.MeshLambertMaterial | THREE.MeshStandardMaterial,
+    geometry: THREE.BufferGeometry,
+    scene1: THREE.Scene,
+    scene2: THREE.Scene,
+    renderer: THREE.WebGLRenderer;
+let gridHelper: THREE.GridHelper, sphere: THREE.Mesh, model: THREE.Group, coffeemat: THREE.Group;
 
 const params = {
     trs: false,
@@ -87,8 +94,8 @@ function init() {
         for (let x = 0; x < 100; x++) {
             const stride = 4 * (100 * y + x);
 
-            data[stride] = Math.round(255 * y / 99);
-            data[stride + 1] = Math.round(255 - 255 * y / 99);
+            data[stride] = Math.round((255 * y) / 99);
+            data[stride + 1] = Math.round(255 - (255 * y) / 99);
             data[stride + 2] = 0;
             data[stride + 3] = 255;
         }
@@ -280,7 +287,7 @@ function init() {
     positions = new Float32Array(numPoints * 3);
 
     for (let i = 0; i < numPoints; i++) {
-        const s = i * Math.PI * 2 / numPoints;
+        const s = (i * Math.PI * 2) / numPoints;
         positions[i * 3] = radius * Math.sin(s);
         positions[i * 3 + 1] = radius * Math.cos(s);
         positions[i * 3 + 2] = 0;
@@ -370,7 +377,7 @@ function init() {
     // Model requiring KHR_mesh_quantization
     // ---------------------------------------------------------------------
     const loader = new GLTFLoader();
-    loader.load("models/gltf/ShaderBall.glb", function (gltf) {
+    loader.load("models/gltf/ShaderBall.glb", function(gltf) {
         model = gltf.scene;
         model.scale.setScalar(50);
         model.position.set(200, -40, -200);
@@ -389,8 +396,8 @@ function init() {
     const color = new THREE.Color();
     for (let i = 0; i < 50; i++) {
         matrix.setPosition(Math.random() * 100 - 50, Math.random() * 100 - 50, Math.random() * 100 - 50);
-        object.setMatrixAt(i, matrix);
-        object.setColorAt(i, color.setHSL(i / 50, 1, 0.5));
+        (object as THREE.InstancedMesh).setMatrixAt(i, matrix);
+        (object as THREE.InstancedMesh).setColorAt(i, color.setHSL(i / 50, 1, 0.5));
     }
 
     object.position.set(400, 0, 200);
@@ -423,14 +430,12 @@ function init() {
     // ---------------------------------------------------------------------
     // Exporting compressed textures and meshes (KTX2 / Draco / Meshopt)
     // ---------------------------------------------------------------------
-    const ktx2Loader = new KTX2Loader()
-        .setTranscoderPath("jsm/libs/basis/")
-        .detectSupport(renderer);
+    const ktx2Loader = new KTX2Loader().setTranscoderPath("jsm/libs/basis/").detectSupport(renderer);
 
     const gltfLoader = new GLTFLoader().setPath("models/gltf/");
     gltfLoader.setKTX2Loader(ktx2Loader);
     gltfLoader.setMeshoptDecoder(MeshoptDecoder);
-    gltfLoader.load("coffeemat.glb", function (gltf) {
+    gltfLoader.load("coffeemat.glb", function(gltf) {
         gltf.scene.position.x = 400;
         gltf.scene.position.z = -200;
 
diff --git a/examples-testing/examples/misc_exporter_obj.ts b/examples-testing/examples/misc_exporter_obj.ts
index 354dded..1e4abd6 100644
--- a/examples-testing/examples/misc_exporter_obj.ts
+++ b/examples-testing/examples/misc_exporter_obj.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { OBJExporter } from "three/addons/exporters/OBJExporter.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const params = {
     addTriangle: addTriangle,
@@ -66,12 +66,12 @@ function exportToObj() {
     saveString(result, "object.obj");
 }
 
-function addGeometry(type) {
+function addGeometry(type: number) {
     for (let i = 0; i < scene.children.length; i++) {
         const child = scene.children[i];
 
-        if (child.isMesh || child.isPoints) {
-            child.geometry.dispose();
+        if ((child as THREE.Mesh).isMesh || (child as THREE.Points).isPoints) {
+            (child as THREE.Mesh | THREE.Points).geometry.dispose();
             scene.remove(child);
             i--;
         }
@@ -156,13 +156,13 @@ const link = document.createElement("a");
 link.style.display = "none";
 document.body.appendChild(link);
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
 }
 
-function saveString(text, filename) {
+function saveString(text: string, filename: string) {
     save(new Blob([text], { type: "text/plain" }), filename);
 }
 
diff --git a/examples-testing/examples/misc_exporter_ply.ts b/examples-testing/examples/misc_exporter_ply.ts
index 819e9e0..ffb1c38 100644
--- a/examples-testing/examples/misc_exporter_ply.ts
+++ b/examples-testing/examples/misc_exporter_ply.ts
@@ -4,7 +4,11 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { PLYExporter } from "three/addons/exporters/PLYExporter.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let scene, camera, renderer, exporter, mesh;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGLRenderer,
+    exporter: PLYExporter,
+    mesh: THREE.Mesh;
 
 const params = {
     exportASCII: exportASCII,
@@ -113,37 +117,45 @@ function animate() {
 }
 
 function exportASCII() {
-    exporter.parse(mesh, function (result) {
+    exporter.parse(mesh, function(result) {
         saveString(result, "box.ply");
     });
 }
 
 function exportBinaryBigEndian() {
-    exporter.parse(mesh, function (result) {
-        saveArrayBuffer(result, "box.ply");
-    }, { binary: true });
+    exporter.parse(
+        mesh,
+        function(result) {
+            saveArrayBuffer(result, "box.ply");
+        },
+        { binary: true },
+    );
 }
 
 function exportBinaryLittleEndian() {
-    exporter.parse(mesh, function (result) {
-        saveArrayBuffer(result, "box.ply");
-    }, { binary: true, littleEndian: true });
+    exporter.parse(
+        mesh,
+        function(result) {
+            saveArrayBuffer(result, "box.ply");
+        },
+        { binary: true, littleEndian: true },
+    );
 }
 
 const link = document.createElement("a");
 link.style.display = "none";
 document.body.appendChild(link);
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
 }
 
-function saveString(text, filename) {
+function saveString(text: string, filename: string) {
     save(new Blob([text], { type: "text/plain" }), filename);
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: BufferSource, filename: string) {
     save(new Blob([buffer], { type: "application/octet-stream" }), filename);
 }
diff --git a/examples-testing/examples/misc_exporter_stl.ts b/examples-testing/examples/misc_exporter_stl.ts
index 5bd32ce..03057bd 100644
--- a/examples-testing/examples/misc_exporter_stl.ts
+++ b/examples-testing/examples/misc_exporter_stl.ts
@@ -4,7 +4,11 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { STLExporter } from "three/addons/exporters/STLExporter.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let scene, camera, renderer, exporter, mesh;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    renderer: THREE.WebGLRenderer,
+    exporter: STLExporter,
+    mesh: THREE.Mesh;
 
 const params = {
     exportASCII: exportASCII,
@@ -115,16 +119,16 @@ const link = document.createElement("a");
 link.style.display = "none";
 document.body.appendChild(link);
 
-function save(blob, filename) {
+function save(blob: Blob, filename: string) {
     link.href = URL.createObjectURL(blob);
     link.download = filename;
     link.click();
 }
 
-function saveString(text, filename) {
+function saveString(text: string, filename: string) {
     save(new Blob([text], { type: "text/plain" }), filename);
 }
 
-function saveArrayBuffer(buffer, filename) {
+function saveArrayBuffer(buffer: BufferSource, filename: string) {
     save(new Blob([buffer], { type: "application/octet-stream" }), filename);
 }
diff --git a/examples-testing/examples/misc_exporter_usdz.ts b/examples-testing/examples/misc_exporter_usdz.ts
index 6e673aa..2012fd4 100644
--- a/examples-testing/examples/misc_exporter_usdz.ts
+++ b/examples-testing/examples/misc_exporter_usdz.ts
@@ -3,11 +3,11 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
 
-import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { USDZExporter } from "three/addons/exporters/USDZExporter.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const params = {
     exportUSDZ: exportUSDZ,
@@ -33,7 +33,7 @@ function init() {
     scene.environment = pmremGenerator.fromScene(new RoomEnvironment(renderer), 0.04).texture;
 
     const loader = new GLTFLoader().setPath("models/gltf/DamagedHelmet/glTF/");
-    loader.load("DamagedHelmet.gltf", async function (gltf) {
+    loader.load("DamagedHelmet.gltf", async function(gltf) {
         scene.add(gltf.scene);
 
         const shadowMesh = createSpotShadowMesh();
@@ -50,7 +50,7 @@ function init() {
         const arraybuffer = await exporter.parse(gltf.scene);
         const blob = new Blob([arraybuffer], { type: "application/octet-stream" });
 
-        const link = document.getElementById("link");
+        const link = document.getElementById("link") as HTMLAnchorElement;
         link.href = URL.createObjectURL(blob);
     });
 
@@ -78,7 +78,7 @@ function createSpotShadowMesh() {
     canvas.width = 128;
     canvas.height = 128;
 
-    const context = canvas.getContext("2d");
+    const context = canvas.getContext("2d")!;
     const gradient = context.createRadialGradient(
         canvas.width / 2,
         canvas.height / 2,
@@ -118,7 +118,7 @@ function onWindowResize() {
 }
 
 function exportUSDZ() {
-    const link = document.getElementById("link");
+    const link = document.getElementById("link")!;
     link.click();
 }
 
diff --git a/examples-testing/examples/misc_lookat.ts b/examples-testing/examples/misc_lookat.ts
index 0ebd7ed..c8407b8 100644
--- a/examples-testing/examples/misc_lookat.ts
+++ b/examples-testing/examples/misc_lookat.ts
@@ -2,11 +2,12 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
-let sphere;
+let sphere: THREE.Mesh;
 
-let mouseX = 0, mouseY = 0;
+let mouseX = 0,
+    mouseY = 0;
 
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
@@ -63,7 +64,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) * 10;
     mouseY = (event.clientY - windowHalfY) * 10;
 }
@@ -88,8 +89,8 @@ function render() {
         scene.children[i].lookAt(sphere.position);
     }
 
-    camera.position.x += (mouseX - camera.position.x) * .05;
-    camera.position.y += (-mouseY - camera.position.y) * .05;
+    camera.position.x += (mouseX - camera.position.x) * 0.05;
+    camera.position.y += (-mouseY - camera.position.y) * 0.05;
     camera.lookAt(scene.position);
 
     renderer.render(scene, camera);
diff --git a/examples-testing/examples/misc_uv_tests.ts b/examples-testing/examples/misc_uv_tests.ts
index 917604c..320ee39 100644
--- a/examples-testing/examples/misc_uv_tests.ts
+++ b/examples-testing/examples/misc_uv_tests.ts
@@ -7,7 +7,7 @@ import { UVsDebug } from "three/addons/utils/UVsDebug.js";
  * as well as allow a new user to visualize what UVs are about.
  */
 
-function test(name, geometry) {
+function test(name: string, geometry: THREE.BufferGeometry) {
     const d = document.createElement("div");
 
     d.innerHTML = "<h3>" + name + "</h3>";
diff --git a/examples-testing/examples/physics_ammo_instancing.ts b/examples-testing/examples/physics_ammo_instancing.ts
index 82002ce..7126996 100644
--- a/examples-testing/examples/physics_ammo_instancing.ts
+++ b/examples-testing/examples/physics_ammo_instancing.ts
@@ -1,12 +1,12 @@
 import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { AmmoPhysics } from "three/addons/physics/AmmoPhysics.js";
 import Stats from "three/addons/libs/stats.module.js";
+import { AmmoPhysics, AmmoPhysicsObject } from "three/addons/physics/AmmoPhysics.js";
 
-let camera, scene, renderer, stats;
-let physics, position;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let physics: AmmoPhysicsObject, position: THREE.Vector3;
 
-let boxes, spheres;
+let boxes: THREE.InstancedMesh, spheres: THREE.InstancedMesh;
 
 init();
 
@@ -32,10 +32,7 @@ async function init() {
     dirLight.shadow.camera.zoom = 2;
     scene.add(dirLight);
 
-    const floor = new THREE.Mesh(
-        new THREE.BoxGeometry(10, 5, 10),
-        new THREE.ShadowMaterial({ color: 0x444444 }),
-    );
+    const floor = new THREE.Mesh(new THREE.BoxGeometry(10, 5, 10), new THREE.ShadowMaterial({ color: 0x444444 }));
     floor.position.y = -2.5;
     floor.receiveShadow = true;
     floor.userData.physics = { mass: 0 };
diff --git a/examples-testing/examples/physics_rapier_instancing.ts b/examples-testing/examples/physics_rapier_instancing.ts
index df71124..f339f01 100644
--- a/examples-testing/examples/physics_rapier_instancing.ts
+++ b/examples-testing/examples/physics_rapier_instancing.ts
@@ -1,12 +1,12 @@
 import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { RapierPhysics } from "three/addons/physics/RapierPhysics.js";
 import Stats from "three/addons/libs/stats.module.js";
+import { RapierPhysics, RapierPhysicsObject } from "three/addons/physics/RapierPhysics.js";
 
-let camera, scene, renderer, stats;
-let physics, position;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let physics: RapierPhysicsObject, position: THREE.Vector3;
 
-let boxes, spheres;
+let boxes: THREE.InstancedMesh, spheres: THREE.InstancedMesh;
 
 init();
 
@@ -32,10 +32,7 @@ async function init() {
     dirLight.shadow.camera.zoom = 2;
     scene.add(dirLight);
 
-    const floor = new THREE.Mesh(
-        new THREE.BoxGeometry(10, 5, 10),
-        new THREE.ShadowMaterial({ color: 0x444444 }),
-    );
+    const floor = new THREE.Mesh(new THREE.BoxGeometry(10, 5, 10), new THREE.ShadowMaterial({ color: 0x444444 }));
     floor.position.y = -2.5;
     floor.receiveShadow = true;
     floor.userData.physics = { mass: 0 };
diff --git a/examples-testing/examples/svg_lines.ts b/examples-testing/examples/svg_lines.ts
index ee626a7..43da9c6 100644
--- a/examples-testing/examples/svg_lines.ts
+++ b/examples-testing/examples/svg_lines.ts
@@ -4,7 +4,7 @@ import { SVGRenderer } from "three/addons/renderers/SVGRenderer.js";
 
 THREE.ColorManagement.enabled = false;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: SVGRenderer;
 
 init();
 animate();
@@ -75,9 +75,9 @@ function animate() {
     let count = 0;
     const time = performance.now() / 1000;
 
-    scene.traverse(function (child) {
-        child.rotation.x = count + (time / 3);
-        child.rotation.z = count + (time / 4);
+    scene.traverse(function(child) {
+        child.rotation.x = count + time / 3;
+        child.rotation.z = count + time / 4;
 
         count++;
     });
diff --git a/examples-testing/examples/svg_sandbox.ts b/examples-testing/examples/svg_sandbox.ts
index 7019cf4..1a5bcc7 100644
--- a/examples-testing/examples/svg_sandbox.ts
+++ b/examples-testing/examples/svg_sandbox.ts
@@ -6,9 +6,9 @@ import { SVGObject, SVGRenderer } from "three/addons/renderers/SVGRenderer.js";
 
 THREE.ColorManagement.enabled = false;
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: SVGRenderer, stats: Stats;
 
-let group;
+let group: THREE.Mesh;
 
 init();
 animate();
@@ -23,7 +23,7 @@ function init() {
     // QRCODE
 
     const loader = new THREE.BufferGeometryLoader();
-    loader.load("models/json/QRCode_buffergeometry.json", function (geometry) {
+    loader.load("models/json/QRCode_buffergeometry.json", function(geometry) {
         mesh = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({ vertexColors: true }));
         mesh.scale.x = mesh.scale.y = mesh.scale.z = 2;
         scene.add(mesh);
@@ -33,9 +33,13 @@ function init() {
 
     const boxGeometry = new THREE.BoxGeometry(100, 100, 100);
 
-    let mesh = new THREE.Mesh(
+    let mesh: THREE.Mesh = new THREE.Mesh(
         boxGeometry,
-        new THREE.MeshBasicMaterial({ color: 0x0000ff, opacity: 0.5, transparent: true }),
+        new THREE.MeshBasicMaterial({
+            color: 0x0000ff,
+            opacity: 0.5,
+            transparent: true,
+        }),
     );
     mesh.position.x = 500;
     mesh.rotation.x = Math.random();
@@ -55,7 +59,10 @@ function init() {
 
     mesh = new THREE.Mesh(
         new THREE.PlaneGeometry(100, 100),
-        new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff, side: THREE.DoubleSide }),
+        new THREE.MeshBasicMaterial({
+            color: Math.random() * 0xffffff,
+            side: THREE.DoubleSide,
+        }),
     );
     mesh.position.y = -500;
     mesh.scale.x = mesh.scale.y = mesh.scale.z = 2;
@@ -75,7 +82,10 @@ function init() {
     // POLYFIELD
 
     const geometry = new THREE.BufferGeometry();
-    const material = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide });
+    const material = new THREE.MeshBasicMaterial({
+        vertexColors: true,
+        side: THREE.DoubleSide,
+    });
 
     const v = new THREE.Vector3();
     const v0 = new THREE.Vector3();
@@ -87,29 +97,13 @@ function init() {
     const colors = [];
 
     for (let i = 0; i < 100; i++) {
-        v.set(
-            Math.random() * 1000 - 500,
-            Math.random() * 1000 - 500,
-            Math.random() * 1000 - 500,
-        );
-
-        v0.set(
-            Math.random() * 100 - 50,
-            Math.random() * 100 - 50,
-            Math.random() * 100 - 50,
-        );
-
-        v1.set(
-            Math.random() * 100 - 50,
-            Math.random() * 100 - 50,
-            Math.random() * 100 - 50,
-        );
-
-        v2.set(
-            Math.random() * 100 - 50,
-            Math.random() * 100 - 50,
-            Math.random() * 100 - 50,
-        );
+        v.set(Math.random() * 1000 - 500, Math.random() * 1000 - 500, Math.random() * 1000 - 500);
+
+        v0.set(Math.random() * 100 - 50, Math.random() * 100 - 50, Math.random() * 100 - 50);
+
+        v1.set(Math.random() * 100 - 50, Math.random() * 100 - 50, Math.random() * 100 - 50);
+
+        v2.set(Math.random() * 100 - 50, Math.random() * 100 - 50, Math.random() * 100 - 50);
 
         v0.add(v);
         v1.add(v);
@@ -138,7 +132,9 @@ function init() {
     // SPRITES
 
     for (let i = 0; i < 50; i++) {
-        const material = new THREE.SpriteMaterial({ color: Math.random() * 0xffffff });
+        const material = new THREE.SpriteMaterial({
+            color: Math.random() * 0xffffff,
+        });
         const sprite = new THREE.Sprite(material);
         sprite.position.x = Math.random() * 1000 - 500;
         sprite.position.y = Math.random() * 1000 - 500;
@@ -155,7 +151,7 @@ function init() {
     node.setAttribute("r", "40");
 
     for (let i = 0; i < 50; i++) {
-        const object = new SVGObject(node.cloneNode());
+        const object = new SVGObject(node.cloneNode() as SVGCircleElement);
         object.position.x = Math.random() * 1000 - 500;
         object.position.y = Math.random() * 1000 - 500;
         object.position.z = Math.random() * 1000 - 500;
@@ -165,10 +161,10 @@ function init() {
     // CUSTOM FROM FILE
 
     const fileLoader = new THREE.FileLoader();
-    fileLoader.load("models/svg/hexagon.svg", function (svg) {
+    fileLoader.load("models/svg/hexagon.svg", function(svg) {
         const node = document.createElementNS("http://www.w3.org/2000/svg", "g");
         const parser = new DOMParser();
-        const doc = parser.parseFromString(svg, "image/svg+xml");
+        const doc = parser.parseFromString(svg as string, "image/svg+xml");
 
         node.appendChild(doc.documentElement);
 
diff --git a/examples-testing/examples/webaudio_orientation.ts b/examples-testing/examples/webaudio_orientation.ts
index e497818..c84e887 100644
--- a/examples-testing/examples/webaudio_orientation.ts
+++ b/examples-testing/examples/webaudio_orientation.ts
@@ -4,16 +4,16 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { PositionalAudioHelper } from "three/addons/helpers/PositionalAudioHelper.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-let scene, camera, renderer;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer;
 
-const startButton = document.getElementById("startButton");
+const startButton = document.getElementById("startButton")!;
 startButton.addEventListener("click", init);
 
 function init() {
-    const overlay = document.getElementById("overlay");
+    const overlay = document.getElementById("overlay")!;
     overlay.remove();
 
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     //
 
@@ -65,7 +65,7 @@ function init() {
     const listener = new THREE.AudioListener();
     camera.add(listener);
 
-    const audioElement = document.getElementById("music");
+    const audioElement = document.getElementById("music") as HTMLAudioElement;
     audioElement.play();
 
     const positionalAudio = new THREE.PositionalAudio(listener);
@@ -79,16 +79,16 @@ function init() {
     //
 
     const gltfLoader = new GLTFLoader();
-    gltfLoader.load("models/gltf/BoomBox.glb", function (gltf) {
+    gltfLoader.load("models/gltf/BoomBox.glb", function(gltf) {
         const boomBox = gltf.scene;
         boomBox.position.set(0, 0.2, 0);
         boomBox.scale.set(20, 20, 20);
 
-        boomBox.traverse(function (object) {
-            if (object.isMesh) {
-                object.material.envMap = reflectionCube;
-                object.geometry.rotateY(-Math.PI);
-                object.castShadow = true;
+        boomBox.traverse(function(object) {
+            if ((object as THREE.Mesh).isMesh) {
+                ((object as THREE.Mesh).material as THREE.MeshStandardMaterial).envMap = reflectionCube;
+                (object as THREE.Mesh).geometry.rotateY(-Math.PI);
+                (object as THREE.Mesh).castShadow = true;
             }
         });
 
@@ -100,7 +100,11 @@ function init() {
     // sound is damped behind this wall
 
     const wallGeometry = new THREE.BoxGeometry(2, 1, 0.1);
-    const wallMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
+    const wallMaterial = new THREE.MeshBasicMaterial({
+        color: 0xff0000,
+        transparent: true,
+        opacity: 0.5,
+    });
 
     const wall = new THREE.Mesh(wallGeometry, wallMaterial);
     wall.position.set(0, 0.5, -0.5);
diff --git a/examples-testing/examples/webaudio_sandbox.ts b/examples-testing/examples/webaudio_sandbox.ts
index 7903239..158aac9 100644
--- a/examples-testing/examples/webaudio_sandbox.ts
+++ b/examples-testing/examples/webaudio_sandbox.ts
@@ -4,19 +4,23 @@ import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
 import { FirstPersonControls } from "three/addons/controls/FirstPersonControls.js";
 
-let camera, controls, scene, renderer, light;
+let camera: THREE.PerspectiveCamera,
+    controls: FirstPersonControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    light: THREE.DirectionalLight;
 
-let material1, material2, material3;
+let material1: THREE.MeshPhongMaterial, material2: THREE.MeshPhongMaterial, material3: THREE.MeshPhongMaterial;
 
-let analyser1, analyser2, analyser3;
+let analyser1: THREE.AudioAnalyser, analyser2: THREE.AudioAnalyser, analyser3: THREE.AudioAnalyser;
 
 const clock = new THREE.Clock();
 
-const startButton = document.getElementById("startButton");
+const startButton = document.getElementById("startButton")!;
 startButton.addEventListener("click", init);
 
 function init() {
-    const overlay = document.getElementById("overlay");
+    const overlay = document.getElementById("overlay")!;
     overlay.remove();
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
@@ -45,7 +49,7 @@ function init() {
     scene.add(mesh1);
 
     const sound1 = new THREE.PositionalAudio(listener);
-    const songElement = document.getElementById("song");
+    const songElement = document.getElementById("song") as HTMLAudioElement;
     sound1.setMediaElementSource(songElement);
     sound1.setRefDistance(20);
     songElement.play();
@@ -58,7 +62,7 @@ function init() {
     scene.add(mesh2);
 
     const sound2 = new THREE.PositionalAudio(listener);
-    const skullbeatzElement = document.getElementById("skullbeatz");
+    const skullbeatzElement = document.getElementById("skullbeatz") as HTMLAudioElement;
     sound2.setMediaElementSource(skullbeatzElement);
     sound2.setRefDistance(20);
     skullbeatzElement.play();
@@ -89,7 +93,7 @@ function init() {
     // global ambient audio
 
     const sound4 = new THREE.Audio(listener);
-    const utopiaElement = document.getElementById("utopia");
+    const utopiaElement = document.getElementById("utopia") as HTMLAudioElement;
     sound4.setMediaElementSource(utopiaElement);
     sound4.setVolume(0.5);
     utopiaElement.play();
@@ -102,18 +106,31 @@ function init() {
 
     //
 
-    const SoundControls = function () {
-        this.master = listener.getMasterVolume();
-        this.firstSphere = sound1.getVolume();
-        this.secondSphere = sound2.getVolume();
-        this.thirdSphere = sound3.getVolume();
-        this.Ambient = sound4.getVolume();
-    };
-
-    const GeneratorControls = function () {
-        this.frequency = oscillator.frequency.value;
-        this.wavetype = oscillator.type;
-    };
+    class SoundControls {
+        master: number;
+        firstSphere: number;
+        secondSphere: number;
+        thirdSphere: number;
+        Ambient: number;
+
+        constructor() {
+            this.master = listener.getMasterVolume();
+            this.firstSphere = sound1.getVolume();
+            this.secondSphere = sound2.getVolume();
+            this.thirdSphere = sound3.getVolume();
+            this.Ambient = sound4.getVolume();
+        }
+    }
+
+    class GeneratorControls {
+        frequency: number;
+        wavetype: OscillatorType;
+
+        constructor() {
+            this.frequency = oscillator.frequency.value;
+            this.wavetype = oscillator.type;
+        }
+    }
 
     const gui = new GUI();
     const soundControls = new SoundControls();
@@ -121,31 +138,61 @@ function init() {
     const volumeFolder = gui.addFolder("sound volume");
     const generatorFolder = gui.addFolder("sound generator");
 
-    volumeFolder.add(soundControls, "master").min(0.0).max(1.0).step(0.01).onChange(function () {
-        listener.setMasterVolume(soundControls.master);
-    });
-    volumeFolder.add(soundControls, "firstSphere").min(0.0).max(1.0).step(0.01).onChange(function () {
-        sound1.setVolume(soundControls.firstSphere);
-    });
-    volumeFolder.add(soundControls, "secondSphere").min(0.0).max(1.0).step(0.01).onChange(function () {
-        sound2.setVolume(soundControls.secondSphere);
-    });
-
-    volumeFolder.add(soundControls, "thirdSphere").min(0.0).max(1.0).step(0.01).onChange(function () {
-        sound3.setVolume(soundControls.thirdSphere);
-    });
-    volumeFolder.add(soundControls, "Ambient").min(0.0).max(1.0).step(0.01).onChange(function () {
-        sound4.setVolume(soundControls.Ambient);
-    });
+    volumeFolder
+        .add(soundControls, "master")
+        .min(0.0)
+        .max(1.0)
+        .step(0.01)
+        .onChange(function() {
+            listener.setMasterVolume(soundControls.master);
+        });
+    volumeFolder
+        .add(soundControls, "firstSphere")
+        .min(0.0)
+        .max(1.0)
+        .step(0.01)
+        .onChange(function() {
+            sound1.setVolume(soundControls.firstSphere);
+        });
+    volumeFolder
+        .add(soundControls, "secondSphere")
+        .min(0.0)
+        .max(1.0)
+        .step(0.01)
+        .onChange(function() {
+            sound2.setVolume(soundControls.secondSphere);
+        });
+
+    volumeFolder
+        .add(soundControls, "thirdSphere")
+        .min(0.0)
+        .max(1.0)
+        .step(0.01)
+        .onChange(function() {
+            sound3.setVolume(soundControls.thirdSphere);
+        });
+    volumeFolder
+        .add(soundControls, "Ambient")
+        .min(0.0)
+        .max(1.0)
+        .step(0.01)
+        .onChange(function() {
+            sound4.setVolume(soundControls.Ambient);
+        });
     volumeFolder.open();
-    generatorFolder.add(generatorControls, "frequency").min(50.0).max(5000.0).step(1.0).onChange(function () {
-        oscillator.frequency.setValueAtTime(generatorControls.frequency, listener.context.currentTime);
-    });
-    generatorFolder.add(generatorControls, "wavetype", ["sine", "square", "sawtooth", "triangle"]).onChange(
-        function () {
+    generatorFolder
+        .add(generatorControls, "frequency")
+        .min(50.0)
+        .max(5000.0)
+        .step(1.0)
+        .onChange(function() {
+            oscillator.frequency.setValueAtTime(generatorControls.frequency, listener.context.currentTime);
+        });
+    generatorFolder
+        .add(generatorControls, "wavetype", ["sine", "square", "sawtooth", "triangle"])
+        .onChange(function() {
             oscillator.type = generatorControls.wavetype;
-        },
-    );
+        });
 
     generatorFolder.open();
 
diff --git a/examples-testing/examples/webaudio_timing.ts b/examples-testing/examples/webaudio_timing.ts
index 3490d9c..9e8cf31 100644
--- a/examples-testing/examples/webaudio_timing.ts
+++ b/examples-testing/examples/webaudio_timing.ts
@@ -2,22 +2,22 @@ import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let scene, camera, renderer, clock;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
 
-const objects = [];
+const objects: THREE.Mesh[] = [];
 
 const speed = 2.5;
 const height = 3;
 const offset = 0.5;
 
-const startButton = document.getElementById("startButton");
+const startButton = document.getElementById("startButton")!;
 startButton.addEventListener("click", init);
 
 function init() {
-    const overlay = document.getElementById("overlay");
+    const overlay = document.getElementById("overlay")!;
     overlay.remove();
 
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     scene = new THREE.Scene();
 
@@ -78,9 +78,9 @@ function init() {
 
     // create objects when audio buffer is loaded
 
-    audioLoader.load("sounds/ping_pong.mp3", function (buffer) {
+    audioLoader.load("sounds/ping_pong.mp3", function(buffer) {
         for (let i = 0; i < count; i++) {
-            const s = i / count * Math.PI * 2;
+            const s = (i / count) * Math.PI * 2;
 
             const ball = new THREE.Mesh(ballGeometry, ballMaterial);
             ball.castShadow = true;
@@ -139,7 +139,7 @@ function render() {
         const ball = objects[i];
 
         const previousHeight = ball.position.y;
-        ball.position.y = Math.abs(Math.sin(i * offset + (time * speed)) * height);
+        ball.position.y = Math.abs(Math.sin(i * offset + time * speed) * height);
 
         if (ball.position.y < previousHeight) {
             ball.userData.down = true;
@@ -147,7 +147,7 @@ function render() {
             if (ball.userData.down === true) {
                 // ball changed direction from down to up
 
-                const audio = ball.children[0];
+                const audio = ball.children[0] as THREE.Audio;
                 audio.play(); // play audio with perfect timing when ball hits the surface
                 ball.userData.down = false;
             }
diff --git a/examples-testing/examples/webaudio_visualizer.ts b/examples-testing/examples/webaudio_visualizer.ts
index b8dfe04..c2903c8 100644
--- a/examples-testing/examples/webaudio_visualizer.ts
+++ b/examples-testing/examples/webaudio_visualizer.ts
@@ -1,8 +1,13 @@
 import * as THREE from "three";
+import { IUniform } from "three";
 
-let scene, camera, renderer, analyser, uniforms;
+let scene: THREE.Scene,
+    camera: THREE.Camera,
+    renderer: THREE.WebGLRenderer,
+    analyser: THREE.AudioAnalyser,
+    uniforms: { [uniform: string]: IUniform };
 
-const startButton = document.getElementById("startButton");
+const startButton = document.getElementById("startButton")!;
 startButton.addEventListener("click", init);
 
 function init() {
@@ -10,12 +15,12 @@ function init() {
 
     //
 
-    const overlay = document.getElementById("overlay");
+    const overlay = document.getElementById("overlay")!;
     overlay.remove();
 
     //
 
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -35,7 +40,7 @@ function init() {
 
     if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent)) {
         const loader = new THREE.AudioLoader();
-        loader.load(file, function (buffer) {
+        loader.load(file, function(buffer) {
             audio.setBuffer(buffer);
             audio.play();
         });
@@ -50,7 +55,7 @@ function init() {
 
     //
 
-    const format = (renderer.capabilities.isWebGL2) ? THREE.RedFormat : THREE.LuminanceFormat;
+    const format = renderer.capabilities.isWebGL2 ? THREE.RedFormat : THREE.LuminanceFormat;
 
     uniforms = {
         tAudioData: { value: new THREE.DataTexture(analyser.data, fftSize / 2, 1, format) },
@@ -58,8 +63,8 @@ function init() {
 
     const material = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById("vertexShader").textContent,
-        fragmentShader: document.getElementById("fragmentShader").textContent,
+        vertexShader: document.getElementById("vertexShader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentShader")!.textContent!,
     });
 
     const geometry = new THREE.PlaneGeometry(1, 1);
@@ -87,7 +92,7 @@ function animate() {
 function render() {
     analyser.getFrequencyData();
 
-    uniforms.tAudioData.value.needsUpdate = true;
+    (uniforms.tAudioData.value as THREE.DataTexture).needsUpdate = true;
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl2_buffergeometry_attributes_integer.ts b/examples-testing/examples/webgl2_buffergeometry_attributes_integer.ts
index 41fcb7a..1d1d6d5 100644
--- a/examples-testing/examples/webgl2_buffergeometry_attributes_integer.ts
+++ b/examples-testing/examples/webgl2_buffergeometry_attributes_integer.ts
@@ -6,7 +6,7 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let camera, scene, renderer, mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mesh: THREE.Mesh;
 
 init();
 animate();
@@ -29,8 +29,10 @@ function init() {
     const uvs = [];
     const textureIndices = [];
 
-    const n = 800, n2 = n / 2; // triangles spread in the cube
-    const d = 50, d2 = d / 2; // individual triangle size
+    const n = 800,
+        n2 = n / 2; // triangles spread in the cube
+    const d = 50,
+        d2 = d / 2; // individual triangle size
 
     for (let i = 0; i < triangles; i++) {
         // positions
@@ -70,7 +72,7 @@ function init() {
     geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
     geometry.setAttribute("uv", new THREE.Float32BufferAttribute(uvs, 2));
     geometry.setAttribute("textureIndex", new THREE.Int16BufferAttribute(textureIndices, 1));
-    geometry.attributes.textureIndex.gpuType = THREE.IntType;
+    (geometry.attributes.textureIndex as THREE.BufferAttribute).gpuType = THREE.IntType;
 
     geometry.computeBoundingSphere();
 
@@ -88,8 +90,8 @@ function init() {
                 value: [map1, map2, map3],
             },
         },
-        vertexShader: document.getElementById("vertexShader").textContent,
-        fragmentShader: document.getElementById("fragmentShader").textContent,
+        vertexShader: document.getElementById("vertexShader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentShader")!.textContent!,
         side: THREE.DoubleSide,
         glslVersion: THREE.GLSL3,
     });
diff --git a/examples-testing/examples/webgl2_buffergeometry_attributes_none.ts b/examples-testing/examples/webgl2_buffergeometry_attributes_none.ts
index 400d1f7..5d45a47 100644
--- a/examples-testing/examples/webgl2_buffergeometry_attributes_none.ts
+++ b/examples-testing/examples/webgl2_buffergeometry_attributes_none.ts
@@ -6,7 +6,7 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let camera, scene, renderer, mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mesh: THREE.Mesh;
 
 init();
 animate();
@@ -34,8 +34,8 @@ function init() {
         uniforms: {
             seed: { value: 42 },
         },
-        vertexShader: document.getElementById("vertexShader").textContent,
-        fragmentShader: document.getElementById("fragmentShader").textContent,
+        vertexShader: document.getElementById("vertexShader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentShader")!.textContent!,
         side: THREE.DoubleSide,
         glslVersion: THREE.GLSL3,
     });
@@ -54,11 +54,11 @@ function init() {
     document.body.appendChild(renderer.domElement);
 }
 
-function animate(time) {
+function animate(time?: number) {
     requestAnimationFrame(animate);
 
-    mesh.rotation.x = time / 1000.0 * 0.25;
-    mesh.rotation.y = time / 1000.0 * 0.50;
+    mesh.rotation.x = time != null ? (time / 1000.0) * 0.25 : NaN;
+    mesh.rotation.y = time != null ? (time / 1000.0) * 0.5 : NaN;
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl2_clipculldistance.ts b/examples-testing/examples/webgl2_clipculldistance.ts
index ec9d19c..0458c34 100644
--- a/examples-testing/examples/webgl2_clipculldistance.ts
+++ b/examples-testing/examples/webgl2_clipculldistance.ts
@@ -2,9 +2,14 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import Stats from "three/addons/libs/stats.module.js";
 
-let camera, controls, clock, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera,
+    controls: OrbitControls,
+    clock: THREE.Clock,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats;
 
-let material;
+let material: THREE.ShaderMaterial;
 
 init();
 animate();
@@ -25,13 +30,11 @@ function init() {
     document.body.appendChild(renderer.domElement);
 
     if (renderer.extensions.has("WEBGL_clip_cull_distance") === false) {
-        document.getElementById("notSupported").style.display = "";
+        document.getElementById("notSupported")!.style.display = "";
         return;
     }
 
-    const ext = renderer
-        .getContext()
-        .getExtension("WEBGL_clip_cull_distance");
+    const ext = renderer.getContext().getExtension("WEBGL_clip_cull_distance");
     const gl = renderer.getContext();
 
     gl.enable(ext.CLIP_DISTANCE0_WEBGL);
@@ -71,8 +74,8 @@ function init() {
         uniforms: {
             time: { value: 1.0 },
         },
-        vertexShader: document.getElementById("vertexShader").textContent,
-        fragmentShader: document.getElementById("fragmentShader").textContent,
+        vertexShader: document.getElementById("vertexShader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentShader")!.textContent!,
         side: THREE.DoubleSide,
         transparent: true,
         vertexColors: true,
diff --git a/examples-testing/examples/webgl2_materials_texture3d.ts b/examples-testing/examples/webgl2_materials_texture3d.ts
index 007f3d2..10ea53d 100644
--- a/examples-testing/examples/webgl2_materials_texture3d.ts
+++ b/examples-testing/examples/webgl2_materials_texture3d.ts
@@ -1,22 +1,24 @@
 import * as THREE from "three";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import WebGL from "three/addons/capabilities/WebGL.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { NRRDLoader } from "three/addons/loaders/NRRDLoader.js";
 import { VolumeRenderShader1 } from "three/addons/shaders/VolumeShader.js";
-import WebGL from "three/addons/capabilities/WebGL.js";
 
 if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let renderer,
-    scene,
-    camera,
-    controls,
-    material,
-    volconfig,
-    cmtextures;
+type ColorMap = "gray" | "viridis";
+
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.OrthographicCamera,
+    controls: OrbitControls,
+    material: THREE.ShaderMaterial,
+    volconfig: { clim1: number; clim2: number; renderstyle: string; isothreshold: number; colormap: ColorMap },
+    cmtextures: { [K in ColorMap]: THREE.Texture };
 
 init();
 
@@ -32,7 +34,7 @@ function init() {
     // Create camera (The volume renderer does not work very well with perspective yet)
     const h = 512; // frustum height
     const aspect = window.innerWidth / window.innerHeight;
-    camera = new THREE.OrthographicCamera(-h * aspect / 2, h * aspect / 2, h / 2, -h / 2, 1, 1000);
+    camera = new THREE.OrthographicCamera((-h * aspect) / 2, (h * aspect) / 2, h / 2, -h / 2, 1, 1000);
     camera.position.set(-64, -64, 128);
     camera.up.set(0, 0, 1); // In our data, z is up
 
@@ -60,7 +62,7 @@ function init() {
     gui.add(volconfig, "isothreshold", 0, 1, 0.01).onChange(updateUniforms);
 
     // Load the data ...
-    new NRRDLoader().load("models/nrrd/stent.nrrd", function (volume) {
+    new NRRDLoader().load("models/nrrd/stent.nrrd", function(volume) {
         // Texture to hold the volume. We have scalars, so we put our data in the red channel.
         // THREEJS will select R32F (33326) based on the THREE.RedFormat and THREE.FloatType.
         // Also see https://www.khronos.org/registry/webgl/specs/latest/2.0/#TEXTURE_TYPES_FORMATS_FROM_DOM_ELEMENTS_TABLE
@@ -111,7 +113,7 @@ function init() {
 }
 
 function updateUniforms() {
-    material.uniforms["u_clim"].value.set(volconfig.clim1, volconfig.clim2);
+    (material.uniforms["u_clim"].value as THREE.Vector2).set(volconfig.clim1, volconfig.clim2);
     material.uniforms["u_renderstyle"].value = volconfig.renderstyle == "mip" ? 0 : 1; // 0: MIP, 1: ISO
     material.uniforms["u_renderthreshold"].value = volconfig.isothreshold; // For ISO renderstyle
     material.uniforms["u_cmdata"].value = cmtextures[volconfig.colormap];
@@ -126,8 +128,8 @@ function onWindowResize() {
 
     const frustumHeight = camera.top - camera.bottom;
 
-    camera.left = -frustumHeight * aspect / 2;
-    camera.right = frustumHeight * aspect / 2;
+    camera.left = (-frustumHeight * aspect) / 2;
+    camera.right = (frustumHeight * aspect) / 2;
 
     camera.updateProjectionMatrix();
 
diff --git a/examples-testing/examples/webgl2_materials_texture3d_partialupdate.ts b/examples-testing/examples/webgl2_materials_texture3d_partialupdate.ts
index 621766d..af047e0 100644
--- a/examples-testing/examples/webgl2_materials_texture3d_partialupdate.ts
+++ b/examples-testing/examples/webgl2_materials_texture3d_partialupdate.ts
@@ -2,8 +2,8 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { ImprovedNoise } from "three/addons/math/ImprovedNoise.js";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import WebGL from "three/addons/capabilities/WebGL.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
 if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
@@ -11,17 +11,17 @@ if (WebGL.isWebGL2Available() === false) {
 
 const INITIAL_CLOUD_SIZE = 128;
 
-let renderer, scene, camera;
-let mesh;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let mesh: THREE.Mesh<THREE.BoxGeometry, THREE.RawShaderMaterial>;
 let prevTime = performance.now();
-let cloudTexture = null;
+let cloudTexture: THREE.Data3DTexture | null = null;
 
 init();
 animate();
 
-function generateCloudTexture(size, scaleFactor = 1.0) {
+function generateCloudTexture(size: number, scaleFactor = 1.0) {
     const data = new Uint8Array(size * size * size);
-    const scale = scaleFactor * 10.0 / size;
+    const scale = (scaleFactor * 10.0) / size;
 
     let i = 0;
     const perlin = new ImprovedNoise();
@@ -30,9 +30,13 @@ function generateCloudTexture(size, scaleFactor = 1.0) {
     for (let z = 0; z < size; z++) {
         for (let y = 0; y < size; y++) {
             for (let x = 0; x < size; x++) {
-                const dist = vector.set(x, y, z).subScalar(size / 2).divideScalar(size).length();
+                const dist = vector
+                    .set(x, y, z)
+                    .subScalar(size / 2)
+                    .divideScalar(size)
+                    .length();
                 const fadingFactor = (1.0 - dist) * (1.0 - dist);
-                data[i] = (128 + 128 * perlin.noise(x * scale / 1.5, y * scale, z * scale / 1.5)) * fadingFactor;
+                data[i] = (128 + 128 * perlin.noise((x * scale) / 1.5, y * scale, (z * scale) / 1.5)) * fadingFactor;
 
                 i++;
             }
@@ -61,7 +65,7 @@ function init() {
     canvas.width = 1;
     canvas.height = 32;
 
-    const context = canvas.getContext("2d");
+    const context = canvas.getContext("2d")!;
     const gradient = context.createLinearGradient(0, 0, 0, 32);
     gradient.addColorStop(0.0, "#014a84");
     gradient.addColorStop(0.5, "#0561a0");
@@ -301,7 +305,7 @@ function animate() {
     if (time - prevTime > 1500.0 && curr < totalCount) {
         const position = new THREE.Vector3(
             Math.floor(curr % countPerRow) * perElementSize + margins * 0.5,
-            (Math.floor((curr % countPerSlice) / countPerRow)) * perElementSize + margins * 0.5,
+            Math.floor((curr % countPerSlice) / countPerRow) * perElementSize + margins * 0.5,
             Math.floor(curr / countPerSlice) * perElementSize + margins * 0.5,
         ).floor();
 
@@ -313,17 +317,17 @@ function animate() {
         const scaleFactor = (Math.random() + 0.5) * 0.5;
         const source = generateCloudTexture(perElementPaddedSize, scaleFactor);
 
-        renderer.copyTextureToTexture3D(box, position, source, cloudTexture);
+        renderer.copyTextureToTexture3D(box, position, source, cloudTexture!);
 
         prevTime = time;
 
         curr++;
     }
 
-    mesh.material.uniforms.cameraPos.value.copy(camera.position);
+    (mesh.material.uniforms.cameraPos.value as THREE.Vector3).copy(camera.position);
     // mesh.rotation.y = - performance.now() / 7500;
 
-    mesh.material.uniforms.frame.value++;
+    (mesh.material.uniforms.frame.value as number)++;
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl2_multiple_rendertargets.ts b/examples-testing/examples/webgl2_multiple_rendertargets.ts
index a1c8dab..d246f0a 100644
--- a/examples-testing/examples/webgl2_multiple_rendertargets.ts
+++ b/examples-testing/examples/webgl2_multiple_rendertargets.ts
@@ -4,9 +4,9 @@ import WebGL from "three/addons/capabilities/WebGL.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let camera, scene, renderer, controls;
-let renderTarget;
-let postScene, postCamera;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
+let renderTarget: THREE.WebGLMultipleRenderTargets;
+let postScene: THREE.Scene, postCamera: THREE.OrthographicCamera;
 
 const parameters = {
     samples: 4,
@@ -69,8 +69,8 @@ function init() {
             new THREE.TorusKnotGeometry(1, 0.3, 128, 32),
             new THREE.RawShaderMaterial({
                 name: "G-Buffer Shader",
-                vertexShader: document.querySelector("#gbuffer-vert").textContent.trim(),
-                fragmentShader: document.querySelector("#gbuffer-frag").textContent.trim(),
+                vertexShader: document.querySelector("#gbuffer-vert")!.textContent!.trim(),
+                fragmentShader: document.querySelector("#gbuffer-frag")!.textContent!.trim(),
                 uniforms: {
                     tDiffuse: { value: diffuse },
                     repeat: { value: new THREE.Vector2(5, 0.5) },
@@ -90,8 +90,8 @@ function init() {
             new THREE.PlaneGeometry(2, 2),
             new THREE.RawShaderMaterial({
                 name: "Post-FX Shader",
-                vertexShader: document.querySelector("#render-vert").textContent.trim(),
-                fragmentShader: document.querySelector("#render-frag").textContent.trim(),
+                vertexShader: document.querySelector("#render-vert")!.textContent!.trim(),
+                fragmentShader: document.querySelector("#render-frag")!.textContent!.trim(),
                 uniforms: {
                     tDiffuse: { value: renderTarget.texture[0] },
                     tNormal: { value: renderTarget.texture[1] },
@@ -105,7 +105,7 @@ function init() {
 
     controls = new OrbitControls(camera, renderer.domElement);
     controls.addEventListener("change", render);
-    //controls.enableZoom = false;
+    // controls.enableZoom = false;
 
     window.addEventListener("resize", onWindowResize);
 }
@@ -125,9 +125,9 @@ function onWindowResize() {
 function render() {
     renderTarget.samples = parameters.samples;
 
-    scene.traverse(function (child) {
-        if (child.material !== undefined) {
-            child.material.wireframe = parameters.wireframe;
+    scene.traverse(function(child) {
+        if ((child as THREE.Mesh).material !== undefined) {
+            ((child as THREE.Mesh).material as THREE.RawShaderMaterial).wireframe = parameters.wireframe;
         }
     });
 
diff --git a/examples-testing/examples/webgl2_multisampled_renderbuffers.ts b/examples-testing/examples/webgl2_multisampled_renderbuffers.ts
index ce2e82c..0b3a8d8 100644
--- a/examples-testing/examples/webgl2_multisampled_renderbuffers.ts
+++ b/examples-testing/examples/webgl2_multisampled_renderbuffers.ts
@@ -1,14 +1,14 @@
 import * as THREE from "three";
 
-import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
-import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
-import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 import WebGL from "three/addons/capabilities/WebGL.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
+import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
+import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 
-let camera, renderer, group, container;
+let camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, group: THREE.Group, container: HTMLElement;
 
-let composer1, composer2;
+let composer1: EffectComposer, composer2: EffectComposer;
 
 const params = {
     animate: true,
@@ -22,7 +22,7 @@ function init() {
         return;
     }
 
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 10, 2000);
     camera.position.z = 500;
diff --git a/examples-testing/examples/webgl2_texture2darray_compressed.ts b/examples-testing/examples/webgl2_texture2darray_compressed.ts
index 30c6c37..9246f71 100644
--- a/examples-testing/examples/webgl2_texture2darray_compressed.ts
+++ b/examples-testing/examples/webgl2_texture2darray_compressed.ts
@@ -9,7 +9,12 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let camera, scene, mesh, renderer, stats, clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    mesh: THREE.Mesh<THREE.PlaneGeometry, THREE.ShaderMaterial>,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    clock: THREE.Clock;
 
 const planeWidth = 50;
 const planeHeight = 25;
@@ -42,15 +47,15 @@ function init() {
     ktx2Loader.setTranscoderPath("jsm/libs/basis/");
     ktx2Loader.detectSupport(renderer);
 
-    ktx2Loader.load("textures/spiritedaway.ktx2", function (texturearray) {
+    ktx2Loader.load("textures/spiritedaway.ktx2", function(texturearray) {
         const material = new THREE.ShaderMaterial({
             uniforms: {
                 diffuse: { value: texturearray },
                 depth: { value: 55 },
                 size: { value: new THREE.Vector2(planeWidth, planeHeight) },
             },
-            vertexShader: document.getElementById("vs").textContent.trim(),
-            fragmentShader: document.getElementById("fs").textContent.trim(),
+            vertexShader: document.getElementById("vs")!.textContent!.trim(),
+            fragmentShader: document.getElementById("fs")!.textContent!.trim(),
             glslVersion: THREE.GLSL3,
         });
 
diff --git a/examples-testing/examples/webgl2_ubo.ts b/examples-testing/examples/webgl2_ubo.ts
index 9e6a751..350b809 100644
--- a/examples-testing/examples/webgl2_ubo.ts
+++ b/examples-testing/examples/webgl2_ubo.ts
@@ -2,7 +2,7 @@ import * as THREE from "three";
 
 import WebGL from "three/addons/capabilities/WebGL.js";
 
-let camera, scene, renderer, clock;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
 
 init();
 animate();
@@ -13,7 +13,7 @@ function init() {
         return;
     }
 
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
     camera.position.set(0, 0, 25);
@@ -59,8 +59,8 @@ function init() {
             normalMatrix: { value: null },
             color: { value: null },
         },
-        vertexShader: document.getElementById("vertexShader1").textContent,
-        fragmentShader: document.getElementById("fragmentShader1").textContent,
+        vertexShader: document.getElementById("vertexShader1")!.textContent!,
+        fragmentShader: document.getElementById("fragmentShader1")!.textContent!,
         glslVersion: THREE.GLSL3,
     });
 
@@ -69,8 +69,8 @@ function init() {
             modelMatrix: { value: null },
             diffuseMap: { value: null },
         },
-        vertexShader: document.getElementById("vertexShader2").textContent,
-        fragmentShader: document.getElementById("fragmentShader2").textContent,
+        vertexShader: document.getElementById("vertexShader2")!.textContent!,
+        fragmentShader: document.getElementById("fragmentShader2")!.textContent!,
         glslVersion: THREE.GLSL3,
     });
 
@@ -135,8 +135,8 @@ function animate() {
 
     const delta = clock.getDelta();
 
-    scene.traverse(function (child) {
-        if (child.isMesh) {
+    scene.traverse(function(child) {
+        if ((child as THREE.Mesh).isMesh) {
             child.rotation.x += delta * 0.5;
             child.rotation.y += delta * 0.3;
         }
diff --git a/examples-testing/examples/webgl2_ubo_arrays.ts b/examples-testing/examples/webgl2_ubo_arrays.ts
index e964aab..5a82611 100644
--- a/examples-testing/examples/webgl2_ubo_arrays.ts
+++ b/examples-testing/examples/webgl2_ubo_arrays.ts
@@ -1,15 +1,19 @@
 import * as THREE from "three";
 
 import WebGL from "three/addons/capabilities/WebGL.js";
-import Stats from "three/addons/libs/stats.module.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
-let camera, scene, renderer, clock, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    stats: Stats;
 
-let lightingUniformsGroup, lightCenters;
+let lightingUniformsGroup: THREE.UniformsGroup, lightCenters: { x: number; z: number }[];
 
-const container = document.getElementById("container");
+const container = document.getElementById("container")!;
 
 const pointLightsMax = 300;
 
@@ -78,8 +82,8 @@ function init() {
         defines: {
             POINTLIGHTS_MAX: pointLightsMax,
         },
-        vertexShader: document.getElementById("vertexShader").textContent,
-        fragmentShader: document.getElementById("fragmentShader").textContent,
+        vertexShader: document.getElementById("vertexShader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentShader")!.textContent!,
         glslVersion: THREE.GLSL3,
     });
 
@@ -132,9 +136,11 @@ function init() {
 
     // gui
     const gui = new GUI();
-    gui.add(api, "count", 1, pointLightsMax).step(1).onChange(function () {
-        lightingUniformsGroup.uniforms[2].value = api.count;
-    });
+    gui.add(api, "count", 1, pointLightsMax)
+        .step(1)
+        .onChange(function() {
+            (lightingUniformsGroup.uniforms[2] as THREE.Uniform).value = api.count;
+        });
 }
 
 function onWindowResize() {
@@ -153,7 +159,7 @@ function animate() {
 
     const elapsedTime = clock.getElapsedTime();
 
-    const lights = lightingUniformsGroup.uniforms[0];
+    const lights = lightingUniformsGroup.uniforms[0] as THREE.Uniform[];
 
     // Parameters for circular movement
     const radius = 5; // Smaller radius for individual circular movements
diff --git a/examples-testing/examples/webgl2_volume_cloud.ts b/examples-testing/examples/webgl2_volume_cloud.ts
index bd8471d..cc73abc 100644
--- a/examples-testing/examples/webgl2_volume_cloud.ts
+++ b/examples-testing/examples/webgl2_volume_cloud.ts
@@ -2,15 +2,15 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { ImprovedNoise } from "three/addons/math/ImprovedNoise.js";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import WebGL from "three/addons/capabilities/WebGL.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
 if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let renderer, scene, camera;
-let mesh;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let mesh: THREE.Mesh<THREE.BoxGeometry, THREE.RawShaderMaterial>;
 
 init();
 animate();
@@ -34,7 +34,7 @@ function init() {
     canvas.width = 1;
     canvas.height = 32;
 
-    const context = canvas.getContext("2d");
+    const context = canvas.getContext("2d")!;
     const gradient = context.createLinearGradient(0, 0, 0, 32);
     gradient.addColorStop(0.0, "#014a84");
     gradient.addColorStop(0.5, "#0561a0");
@@ -64,8 +64,13 @@ function init() {
     for (let z = 0; z < size; z++) {
         for (let y = 0; y < size; y++) {
             for (let x = 0; x < size; x++) {
-                const d = 1.0 - vector.set(x, y, z).subScalar(size / 2).divideScalar(size).length();
-                data[i] = (128 + 128 * perlin.noise(x * scale / 1.5, y * scale, z * scale / 1.5)) * d * d;
+                const d = 1.0
+                    - vector
+                        .set(x, y, z)
+                        .subScalar(size / 2)
+                        .divideScalar(size)
+                        .length();
+                data[i] = (128 + 128 * perlin.noise((x * scale) / 1.5, y * scale, (z * scale) / 1.5)) * d * d;
                 i++;
             }
         }
@@ -271,10 +276,10 @@ function onWindowResize() {
 function animate() {
     requestAnimationFrame(animate);
 
-    mesh.material.uniforms.cameraPos.value.copy(camera.position);
+    (mesh.material.uniforms.cameraPos.value as THREE.Vector3).copy(camera.position);
     mesh.rotation.y = -performance.now() / 7500;
 
-    mesh.material.uniforms.frame.value++;
+    (mesh.material.uniforms.frame.value as number)++;
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl2_volume_instancing.ts b/examples-testing/examples/webgl2_volume_instancing.ts
index 87455f7..60dbba7 100644
--- a/examples-testing/examples/webgl2_volume_instancing.ts
+++ b/examples-testing/examples/webgl2_volume_instancing.ts
@@ -8,7 +8,11 @@ if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let renderer, scene, camera, controls, clock;
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    controls: OrbitControls,
+    clock: THREE.Clock;
 
 init();
 animate();
@@ -143,7 +147,7 @@ function init() {
 				`;
 
     const loader = new VOXLoader();
-    loader.load("models/vox/menger.vox", function (chunks) {
+    loader.load("models/vox/menger.vox", function(chunks) {
         for (let i = 0; i < chunks.length; i++) {
             const chunk = chunks[i];
 
@@ -160,8 +164,8 @@ function init() {
             });
 
             const mesh = new THREE.InstancedMesh(geometry, material, 50000);
-            mesh.onBeforeRender = function () {
-                this.material.uniforms.cameraPos.value.copy(camera.position);
+            mesh.onBeforeRender = function() {
+                (this.material.uniforms.cameraPos.value as THREE.Vector3).copy(camera.position);
             };
 
             const transform = new THREE.Object3D();
diff --git a/examples-testing/examples/webgl2_volume_perlin.ts b/examples-testing/examples/webgl2_volume_perlin.ts
index 9f3ff3d..82f90be 100644
--- a/examples-testing/examples/webgl2_volume_perlin.ts
+++ b/examples-testing/examples/webgl2_volume_perlin.ts
@@ -2,15 +2,15 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { ImprovedNoise } from "three/addons/math/ImprovedNoise.js";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import WebGL from "three/addons/capabilities/WebGL.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
 if (WebGL.isWebGL2Available() === false) {
     document.body.appendChild(WebGL.getWebGL2ErrorMessage());
 }
 
-let renderer, scene, camera;
-let mesh;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let mesh: THREE.Mesh<THREE.BoxGeometry, THREE.RawShaderMaterial>;
 
 init();
 animate();
@@ -209,7 +209,7 @@ function onWindowResize() {
 function animate() {
     requestAnimationFrame(animate);
 
-    mesh.material.uniforms.cameraPos.value.copy(camera.position);
+    (mesh.material.uniforms.cameraPos.value as THREE.Vector3).copy(camera.position);
 
     renderer.render(scene, camera);
 }
diff --git a/examples-testing/examples/webgl_animation_keyframes.ts b/examples-testing/examples/webgl_animation_keyframes.ts
index 3e2fd88..100115d 100644
--- a/examples-testing/examples/webgl_animation_keyframes.ts
+++ b/examples-testing/examples/webgl_animation_keyframes.ts
@@ -5,13 +5,13 @@ import Stats from "three/addons/libs/stats.module.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
 
-import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
+import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-let mixer;
+let mixer: THREE.AnimationMixer;
 
 const clock = new THREE.Clock();
-const container = document.getElementById("container");
+const container = document.getElementById("container")!;
 
 const stats = new Stats();
 container.appendChild(stats.dom);
@@ -43,7 +43,7 @@ const loader = new GLTFLoader();
 loader.setDRACOLoader(dracoLoader);
 loader.load(
     "models/gltf/LittlestTokyo.glb",
-    function (gltf) {
+    function(gltf) {
         const model = gltf.scene;
         model.position.set(1, 1, 0);
         model.scale.set(0.01, 0.01, 0.01);
@@ -55,12 +55,12 @@ loader.load(
         animate();
     },
     undefined,
-    function (e) {
+    function(e) {
         console.error(e);
     },
 );
 
-window.onresize = function () {
+window.onresize = function() {
     camera.aspect = window.innerWidth / window.innerHeight;
     camera.updateProjectionMatrix();
 
diff --git a/examples-testing/examples/webgl_animation_multiple.ts b/examples-testing/examples/webgl_animation_multiple.ts
index e86f009..33e772f 100644
--- a/examples-testing/examples/webgl_animation_multiple.ts
+++ b/examples-testing/examples/webgl_animation_multiple.ts
@@ -1,13 +1,14 @@
 import * as THREE from "three";
 
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import * as SkeletonUtils from "three/addons/utils/SkeletonUtils.js";
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let camera, scene, renderer, clock;
-let model, animations;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
+let model: THREE.Group, animations: THREE.AnimationClip[];
 
-const mixers = [], objects = [];
+const mixers: THREE.AnimationMixer[] = [],
+    objects: THREE.Object3D[] = [];
 
 const params = {
     sharedSkeleton: false,
@@ -55,12 +56,12 @@ function init() {
     scene.add(mesh);
 
     const loader = new GLTFLoader();
-    loader.load("models/gltf/Soldier.glb", function (gltf) {
+    loader.load("models/gltf/Soldier.glb", function(gltf) {
         model = gltf.scene;
         animations = gltf.animations;
 
-        model.traverse(function (object) {
-            if (object.isMesh) object.castShadow = true;
+        model.traverse(function(object) {
+            if ((object as THREE.Mesh).isMesh) object.castShadow = true;
         });
 
         setupDefaultScene();
@@ -76,7 +77,7 @@ function init() {
 
     const gui = new GUI();
 
-    gui.add(params, "sharedSkeleton").onChange(function () {
+    gui.add(params, "sharedSkeleton").onChange(function() {
         clearScene();
 
         if (params.sharedSkeleton === true) {
@@ -100,8 +101,8 @@ function clearScene() {
     for (const object of objects) {
         scene.remove(object);
 
-        scene.traverse(function (child) {
-            if (child.isSkinnedMesh) child.skeleton.dispose();
+        scene.traverse(function(child) {
+            if ((child as THREE.SkinnedMesh).isSkinnedMesh) (child as THREE.SkinnedMesh).skeleton.dispose();
         });
     }
 }
@@ -137,9 +138,9 @@ function setupSharedSkeletonScene() {
     // all models share the same animation state
 
     const sharedModel = SkeletonUtils.clone(model);
-    const shareSkinnedMesh = sharedModel.getObjectByName("vanguard_Mesh");
+    const shareSkinnedMesh = sharedModel.getObjectByName("vanguard_Mesh") as THREE.SkinnedMesh;
     const sharedSkeleton = shareSkinnedMesh.skeleton;
-    const sharedParentBone = sharedModel.getObjectByName("mixamorigHips");
+    const sharedParentBone = sharedModel.getObjectByName("mixamorigHips")!;
     scene.add(sharedParentBone); // the bones need to be in the scene for the animation to work
 
     const model1 = shareSkinnedMesh.clone();
diff --git a/examples-testing/examples/webgl_animation_skinning_morph.ts b/examples-testing/examples/webgl_animation_skinning_morph.ts
index cb684b3..dd8d78c 100644
--- a/examples-testing/examples/webgl_animation_skinning_morph.ts
+++ b/examples-testing/examples/webgl_animation_skinning_morph.ts
@@ -1,14 +1,33 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-let container, stats, clock, gui, mixer, actions, activeAction, previousAction;
-let camera, scene, renderer, model, face;
-
-const api = { state: "Walking" };
+let container: HTMLDivElement,
+    stats: Stats,
+    clock: THREE.Clock,
+    gui: GUI,
+    mixer: THREE.AnimationMixer,
+    actions: Record<string, THREE.AnimationAction>,
+    activeAction: THREE.AnimationAction,
+    previousAction: THREE.AnimationAction;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    model: THREE.Group,
+    face: THREE.Mesh;
+
+const api: {
+    state: string;
+    Jump?: () => void;
+    Yes?: () => void;
+    No?: () => void;
+    Wave?: () => void;
+    Punch?: () => void;
+    ThumbsUp?: () => void;
+} = { state: "Walking" };
 
 init();
 animate();
@@ -56,14 +75,14 @@ function init() {
     const loader = new GLTFLoader();
     loader.load(
         "models/gltf/RobotExpressive/RobotExpressive.glb",
-        function (gltf) {
+        function(gltf) {
             model = gltf.scene;
             scene.add(model);
 
             createGUI(model, gltf.animations);
         },
         undefined,
-        function (e) {
+        function(e) {
             console.error(e);
         },
     );
@@ -80,9 +99,9 @@ function init() {
     container.appendChild(stats.dom);
 }
 
-function createGUI(model, animations) {
+function createGUI(model: THREE.Group, animations: THREE.AnimationClip[]) {
     const states = ["Idle", "Walking", "Running", "Dance", "Death", "Sitting", "Standing"];
-    const emotes = ["Jump", "Yes", "No", "Wave", "Punch", "ThumbsUp"];
+    const emotes = ["Jump", "Yes", "No", "Wave", "Punch", "ThumbsUp"] as const;
 
     gui = new GUI();
 
@@ -95,7 +114,7 @@ function createGUI(model, animations) {
         const action = mixer.clipAction(clip);
         actions[clip.name] = action;
 
-        if (emotes.indexOf(clip.name) >= 0 || states.indexOf(clip.name) >= 4) {
+        if (emotes.indexOf(clip.name as (typeof emotes)[number]) >= 0 || states.indexOf(clip.name) >= 4) {
             action.clampWhenFinished = true;
             action.loop = THREE.LoopOnce;
         }
@@ -107,7 +126,7 @@ function createGUI(model, animations) {
 
     const clipCtrl = statesFolder.add(api, "state").options(states);
 
-    clipCtrl.onChange(function () {
+    clipCtrl.onChange(function() {
         fadeToAction(api.state, 0.5);
     });
 
@@ -117,14 +136,14 @@ function createGUI(model, animations) {
 
     const emoteFolder = gui.addFolder("Emotes");
 
-    function createEmoteCallback(name) {
-        api[name] = function () {
+    function createEmoteCallback(name: (typeof emotes)[number]) {
+        api[name] = function() {
             fadeToAction(name, 0.2);
 
             mixer.addEventListener("finished", restoreState);
         };
 
-        emoteFolder.add(api, name);
+        emoteFolder.add(api as Required<typeof api>, name);
     }
 
     function restoreState() {
@@ -141,13 +160,13 @@ function createGUI(model, animations) {
 
     // expressions
 
-    face = model.getObjectByName("Head_4");
+    face = model.getObjectByName("Head_4") as THREE.Mesh;
 
-    const expressions = Object.keys(face.morphTargetDictionary);
+    const expressions = Object.keys(face.morphTargetDictionary!);
     const expressionFolder = gui.addFolder("Expressions");
 
     for (let i = 0; i < expressions.length; i++) {
-        expressionFolder.add(face.morphTargetInfluences, i, 0, 1, 0.01).name(expressions[i]);
+        expressionFolder.add(face.morphTargetInfluences!, i, 0, 1, 0.01).name(expressions[i]);
     }
 
     activeAction = actions["Walking"];
@@ -156,7 +175,7 @@ function createGUI(model, animations) {
     expressionFolder.open();
 }
 
-function fadeToAction(name, duration) {
+function fadeToAction(name: string, duration: number) {
     previousAction = activeAction;
     activeAction = actions[name];
 
@@ -164,12 +183,7 @@ function fadeToAction(name, duration) {
         previousAction.fadeOut(duration);
     }
 
-    activeAction
-        .reset()
-        .setEffectiveTimeScale(1)
-        .setEffectiveWeight(1)
-        .fadeIn(duration)
-        .play();
+    activeAction.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(duration).play();
 }
 
 function onWindowResize() {
diff --git a/examples-testing/examples/webgl_buffergeometry.ts b/examples-testing/examples/webgl_buffergeometry.ts
index e199b57..238f7f5 100644
--- a/examples-testing/examples/webgl_buffergeometry.ts
+++ b/examples-testing/examples/webgl_buffergeometry.ts
@@ -2,17 +2,17 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh;
+let mesh: THREE.Mesh;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     //
 
@@ -47,8 +47,10 @@ function init() {
 
     const color = new THREE.Color();
 
-    const n = 800, n2 = n / 2; // triangles spread in the cube
-    const d = 12, d2 = d / 2; // individual triangle size
+    const n = 800,
+        n2 = n / 2; // triangles spread in the cube
+    const d = 12,
+        d2 = d / 2; // individual triangle size
 
     const pA = new THREE.Vector3();
     const pB = new THREE.Vector3();
@@ -102,9 +104,9 @@ function init() {
 
         // colors
 
-        const vx = (x / n) + 0.5;
-        const vy = (y / n) + 0.5;
-        const vz = (z / n) + 0.5;
+        const vx = x / n + 0.5;
+        const vy = y / n + 0.5;
+        const vz = z / n + 0.5;
 
         color.setRGB(vx, vy, vz);
 
@@ -115,8 +117,8 @@ function init() {
         colors.push(color.r, color.g, color.b, alpha);
     }
 
-    function disposeArray() {
-        this.array = null;
+    function disposeArray(this: THREE.BufferAttribute) {
+        this.array = null as unknown as THREE.TypedArray;
     }
 
     geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3).onUpload(disposeArray));
diff --git a/examples-testing/examples/webgl_buffergeometry_custom_attributes_particles.ts b/examples-testing/examples/webgl_buffergeometry_custom_attributes_particles.ts
index 26f9a4c..918f67d 100644
--- a/examples-testing/examples/webgl_buffergeometry_custom_attributes_particles.ts
+++ b/examples-testing/examples/webgl_buffergeometry_custom_attributes_particles.ts
@@ -2,9 +2,11 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let particleSystem, uniforms, geometry;
+let particleSystem: THREE.Points,
+    uniforms: { pointTexture: THREE.IUniform<THREE.Texture> },
+    geometry: THREE.BufferGeometry;
 
 const particles = 100000;
 
@@ -23,8 +25,8 @@ function init() {
 
     const shaderMaterial = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById("vertexshader").textContent,
-        fragmentShader: document.getElementById("fragmentshader").textContent,
+        vertexShader: document.getElementById("vertexshader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentshader")!.textContent!,
 
         blending: THREE.AdditiveBlending,
         depthTest: false,
@@ -66,7 +68,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
 
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_buffergeometry_drawrange.ts b/examples-testing/examples/webgl_buffergeometry_drawrange.ts
index 596f543..a0b3746 100644
--- a/examples-testing/examples/webgl_buffergeometry_drawrange.ts
+++ b/examples-testing/examples/webgl_buffergeometry_drawrange.ts
@@ -1,19 +1,19 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let group;
-let container, stats;
-const particlesData = [];
-let camera, scene, renderer;
-let positions, colors;
-let particles;
-let pointCloud;
-let particlePositions;
-let linesMesh;
+let group: THREE.Group;
+let container: HTMLElement, stats: Stats;
+const particlesData: { velocity: THREE.Vector3; numConnections: number }[] = [];
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let positions: Float32Array, colors: Float32Array;
+let particles: THREE.BufferGeometry;
+let pointCloud: THREE.Points;
+let particlePositions: Float32Array;
+let linesMesh: THREE.LineSegments;
 
 const maxParticleCount = 1000;
 let particleCount = 500;
@@ -35,16 +35,16 @@ animate();
 function initGUI() {
     const gui = new GUI();
 
-    gui.add(effectController, "showDots").onChange(function (value) {
+    gui.add(effectController, "showDots").onChange(function(value) {
         pointCloud.visible = value;
     });
-    gui.add(effectController, "showLines").onChange(function (value) {
+    gui.add(effectController, "showLines").onChange(function(value) {
         linesMesh.visible = value;
     });
     gui.add(effectController, "minDistance", 10, 300);
     gui.add(effectController, "limitConnections");
     gui.add(effectController, "maxConnections", 0, 30, 1);
-    gui.add(effectController, "particleCount", 0, maxParticleCount, 1).onChange(function (value) {
+    gui.add(effectController, "particleCount", 0, maxParticleCount, 1).onChange(function(value) {
         particleCount = value;
         particles.setDrawRange(0, particleCount);
     });
@@ -53,7 +53,7 @@ function initGUI() {
 function init() {
     initGUI();
 
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 4000);
     camera.position.z = 1750;
@@ -79,7 +79,7 @@ function init() {
     colors = new Float32Array(segments * 3);
 
     const pMaterial = new THREE.PointsMaterial({
-        color: 0xFFFFFF,
+        color: 0xffffff,
         size: 3,
         blending: THREE.AdditiveBlending,
         transparent: true,
@@ -161,9 +161,7 @@ function animate() {
     let colorpos = 0;
     let numConnected = 0;
 
-    for (let i = 0; i < particleCount; i++) {
-        particlesData[i].numConnections = 0;
-    }
+    for (let i = 0; i < particleCount; i++) particlesData[i].numConnections = 0;
 
     for (let i = 0; i < particleCount; i++) {
         // get the particle
diff --git a/examples-testing/examples/webgl_buffergeometry_glbufferattribute.ts b/examples-testing/examples/webgl_buffergeometry_glbufferattribute.ts
index 892c400..f72353c 100644
--- a/examples-testing/examples/webgl_buffergeometry_glbufferattribute.ts
+++ b/examples-testing/examples/webgl_buffergeometry_glbufferattribute.ts
@@ -2,11 +2,11 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let points;
+let points: THREE.Points<THREE.BufferGeometry<THREE.NormalOrGLBufferAttributes>, THREE.PointsMaterial>;
 
 const particles = 300000;
 let drawCount = 10000;
@@ -15,7 +15,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     //
 
@@ -36,7 +36,7 @@ function init() {
 
     //
 
-    const geometry = new THREE.BufferGeometry();
+    const geometry = new THREE.BufferGeometry<THREE.NormalOrGLBufferAttributes>();
 
     const positions = [];
     const positions2 = [];
@@ -44,7 +44,8 @@ function init() {
 
     const color = new THREE.Color();
 
-    const n = 1000, n2 = n / 2; // particles spread in the cube
+    const n = 1000,
+        n2 = n / 2; // particles spread in the cube
 
     for (let i = 0; i < particles; i++) {
         // positions
@@ -58,9 +59,9 @@ function init() {
 
         // colors
 
-        const vx = (x / n) + 0.5;
-        const vy = (y / n) + 0.5;
-        const vz = (z / n) + 0.5;
+        const vx = x / n + 0.5;
+        const vy = y / n + 0.5;
+        const vz = z / n + 0.5;
 
         color.setRGB(vx, vy, vz, THREE.SRGBColorSpace);
 
@@ -69,15 +70,15 @@ function init() {
 
     const gl = renderer.getContext();
 
-    const pos = gl.createBuffer();
+    const pos = gl.createBuffer()!;
     gl.bindBuffer(gl.ARRAY_BUFFER, pos);
     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
 
-    const pos2 = gl.createBuffer();
+    const pos2 = gl.createBuffer()!;
     gl.bindBuffer(gl.ARRAY_BUFFER, pos2);
     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions2), gl.STATIC_DRAW);
 
-    const rgb = gl.createBuffer();
+    const rgb = gl.createBuffer()!;
     gl.bindBuffer(gl.ARRAY_BUFFER, rgb);
     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
 
@@ -85,10 +86,10 @@ function init() {
     const posAttr2 = new THREE.GLBufferAttribute(pos2, gl.FLOAT, 3, 4, particles);
     geometry.setAttribute("position", posAttr1);
 
-    setInterval(function () {
+    setInterval(function() {
         const attr = geometry.getAttribute("position");
 
-        geometry.setAttribute("position", (attr === posAttr1) ? posAttr2 : posAttr1);
+        geometry.setAttribute("position", attr === posAttr1 ? posAttr2 : posAttr1);
     }, 2000);
 
     geometry.setAttribute("color", new THREE.GLBufferAttribute(rgb, gl.FLOAT, 3, 4, particles));
diff --git a/examples-testing/examples/webgl_buffergeometry_indexed.ts b/examples-testing/examples/webgl_buffergeometry_indexed.ts
index e05c5cf..5f6c7a5 100644
--- a/examples-testing/examples/webgl_buffergeometry_indexed.ts
+++ b/examples-testing/examples/webgl_buffergeometry_indexed.ts
@@ -1,11 +1,11 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
-let mesh;
+let mesh: THREE.Mesh;
 
 init();
 animate();
@@ -46,16 +46,16 @@ function init() {
     // generate vertices, normals and color data for a simple grid geometry
 
     for (let i = 0; i <= segments; i++) {
-        const y = (i * segmentSize) - halfSize;
+        const y = i * segmentSize - halfSize;
 
         for (let j = 0; j <= segments; j++) {
-            const x = (j * segmentSize) - halfSize;
+            const x = j * segmentSize - halfSize;
 
             vertices.push(x, -y, 0);
             normals.push(0, 0, 1);
 
-            const r = (x / size) + 0.5;
-            const g = (y / size) + 0.5;
+            const r = x / size + 0.5;
+            const g = y / size + 0.5;
 
             _color.setRGB(r, g, 1, THREE.SRGBColorSpace);
 
diff --git a/examples-testing/examples/webgl_buffergeometry_instancing.ts b/examples-testing/examples/webgl_buffergeometry_instancing.ts
index 8b0272c..cc73317 100644
--- a/examples-testing/examples/webgl_buffergeometry_instancing.ts
+++ b/examples-testing/examples/webgl_buffergeometry_instancing.ts
@@ -1,17 +1,17 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10);
     camera.position.z = 2;
@@ -77,11 +77,11 @@ function init() {
 
     const material = new THREE.RawShaderMaterial({
         uniforms: {
-            "time": { value: 1.0 },
-            "sineTime": { value: 1.0 },
+            time: { value: 1.0 },
+            sineTime: { value: 1.0 },
         },
-        vertexShader: document.getElementById("vertexShader").textContent,
-        fragmentShader: document.getElementById("fragmentShader").textContent,
+        vertexShader: document.getElementById("vertexShader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentShader")!.textContent!,
         side: THREE.DoubleSide,
         forceSinglePass: true,
         transparent: true,
@@ -100,7 +100,7 @@ function init() {
     container.appendChild(renderer.domElement);
 
     if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has("ANGLE_instanced_arrays") === false) {
-        document.getElementById("notSupported").style.display = "";
+        document.getElementById("notSupported")!.style.display = "";
         return;
     }
 
@@ -138,7 +138,7 @@ function animate() {
 function render() {
     const time = performance.now();
 
-    const object = scene.children[0];
+    const object = scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.RawShaderMaterial>;
 
     object.rotation.y = time * 0.0005;
     object.material.uniforms["time"].value = time * 0.005;
diff --git a/examples-testing/examples/webgl_buffergeometry_instancing_billboards.ts b/examples-testing/examples/webgl_buffergeometry_instancing_billboards.ts
index 40be46d..87273d8 100644
--- a/examples-testing/examples/webgl_buffergeometry_instancing_billboards.ts
+++ b/examples-testing/examples/webgl_buffergeometry_instancing_billboards.ts
@@ -2,16 +2,16 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
-let geometry, material, mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let geometry: THREE.InstancedBufferGeometry, material: THREE.RawShaderMaterial, mesh: THREE.Mesh;
 
 function init() {
     renderer = new THREE.WebGLRenderer();
 
     if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has("ANGLE_instanced_arrays") === false) {
-        document.getElementById("notSupported").style.display = "";
+        document.getElementById("notSupported")!.style.display = "";
         return false;
     }
 
@@ -43,11 +43,11 @@ function init() {
 
     material = new THREE.RawShaderMaterial({
         uniforms: {
-            "map": { value: new THREE.TextureLoader().load("textures/sprites/circle.png") },
-            "time": { value: 0.0 },
+            map: { value: new THREE.TextureLoader().load("textures/sprites/circle.png") },
+            time: { value: 0.0 },
         },
-        vertexShader: document.getElementById("vshader").textContent,
-        fragmentShader: document.getElementById("fshader").textContent,
+        vertexShader: document.getElementById("vshader")!.textContent!,
+        fragmentShader: document.getElementById("fshader")!.textContent!,
         depthTest: true,
         depthWrite: true,
     });
diff --git a/examples-testing/examples/webgl_buffergeometry_instancing_interleaved.ts b/examples-testing/examples/webgl_buffergeometry_instancing_interleaved.ts
index 8ca2d9a..81d86c3 100644
--- a/examples-testing/examples/webgl_buffergeometry_instancing_interleaved.ts
+++ b/examples-testing/examples/webgl_buffergeometry_instancing_interleaved.ts
@@ -2,8 +2,8 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
-let camera, scene, renderer, mesh;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mesh: THREE.InstancedMesh;
 
 const instances = 5000;
 let lastTime = 0;
@@ -17,7 +17,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
 
@@ -332,7 +332,7 @@ function init() {
     container.appendChild(renderer.domElement);
 
     if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has("ANGLE_instanced_arrays") === false) {
-        document.getElementById("notSupported").style.display = "";
+        document.getElementById("notSupported")!.style.display = "";
         return;
     }
 
diff --git a/examples-testing/examples/webgl_buffergeometry_lines.ts b/examples-testing/examples/webgl_buffergeometry_lines.ts
index e240665..2cd144d 100644
--- a/examples-testing/examples/webgl_buffergeometry_lines.ts
+++ b/examples-testing/examples/webgl_buffergeometry_lines.ts
@@ -2,11 +2,11 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats, clock;
+let container: HTMLElement, stats: Stats, clock: THREE.Clock;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let line;
+let line: THREE.Line;
 
 const segments = 10000;
 const r = 800;
@@ -16,7 +16,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     //
 
@@ -44,9 +44,9 @@ function init() {
 
         // colors
 
-        colors.push((x / r) + 0.5);
-        colors.push((y / r) + 0.5);
-        colors.push((z / r) + 0.5);
+        colors.push(x / r + 0.5);
+        colors.push(y / r + 0.5);
+        colors.push(z / r + 0.5);
     }
 
     geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
@@ -100,12 +100,12 @@ function render() {
     line.rotation.y = time * 0.5;
 
     t += delta * 0.5;
-    line.morphTargetInfluences[0] = Math.abs(Math.sin(t));
+    line.morphTargetInfluences![0] = Math.abs(Math.sin(t));
 
     renderer.render(scene, camera);
 }
 
-function generateMorphTargets(geometry) {
+function generateMorphTargets(geometry: THREE.BufferGeometry) {
     const data = [];
 
     for (let i = 0; i < segments; i++) {
diff --git a/examples-testing/examples/webgl_buffergeometry_lines_indexed.ts b/examples-testing/examples/webgl_buffergeometry_lines_indexed.ts
index dc49e9e..298b374 100644
--- a/examples-testing/examples/webgl_buffergeometry_lines_indexed.ts
+++ b/examples-testing/examples/webgl_buffergeometry_lines_indexed.ts
@@ -2,17 +2,17 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let parent_node;
+let parent_node: THREE.Object3D;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 9000;
@@ -22,18 +22,18 @@ function init() {
     const geometry = new THREE.BufferGeometry();
     const material = new THREE.LineBasicMaterial({ vertexColors: true });
 
-    const indices = [];
-    const positions = [];
-    const colors = [];
+    const indices: number[] = [];
+    const positions: number[] = [];
+    const colors: number[] = [];
 
     let next_positions_index = 0;
 
     //
 
     const iteration_count = 4;
-    const rangle = 60 * Math.PI / 180.0;
+    const rangle = (60 * Math.PI) / 180.0;
 
-    function add_vertex(v) {
+    function add_vertex(v: THREE.Vector3) {
         positions.push(v.x, v.y, v.z);
         colors.push(Math.random() * 0.5 + 0.5, Math.random() * 0.5 + 0.5, 1);
 
@@ -42,7 +42,7 @@ function init() {
 
     // simple Koch curve
 
-    function snowflake_iteration(p0, p4, depth) {
+    function snowflake_iteration(p0: THREE.Vector3, p4: THREE.Vector3, depth: number) {
         if (--depth < 0) {
             const i = next_positions_index - 1; // p0 already there
             add_vertex(p4);
@@ -69,7 +69,7 @@ function init() {
         snowflake_iteration(p3, p4, depth);
     }
 
-    function snowflake(points, loop, x_offset) {
+    function snowflake(points: THREE.Vector3[], loop: boolean, x_offset: number) {
         for (let iteration = 0; iteration != iteration_count; iteration++) {
             add_vertex(points[0]);
 
@@ -89,22 +89,11 @@ function init() {
 
     let y = 0;
 
-    snowflake(
-        [
-            new THREE.Vector3(0, y, 0),
-            new THREE.Vector3(500, y, 0),
-        ],
-        false,
-        600,
-    );
+    snowflake([new THREE.Vector3(0, y, 0), new THREE.Vector3(500, y, 0)], false, 600);
 
     y += 600;
     snowflake(
-        [
-            new THREE.Vector3(0, y, 0),
-            new THREE.Vector3(250, y + 400, 0),
-            new THREE.Vector3(500, y, 0),
-        ],
+        [new THREE.Vector3(0, y, 0), new THREE.Vector3(250, y + 400, 0), new THREE.Vector3(500, y, 0)],
         true,
         600,
     );
diff --git a/examples-testing/examples/webgl_buffergeometry_points.ts b/examples-testing/examples/webgl_buffergeometry_points.ts
index 0d52a9d..0983e36 100644
--- a/examples-testing/examples/webgl_buffergeometry_points.ts
+++ b/examples-testing/examples/webgl_buffergeometry_points.ts
@@ -2,17 +2,17 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let points;
+let points: THREE.Points;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     //
 
@@ -34,7 +34,8 @@ function init() {
 
     const color = new THREE.Color();
 
-    const n = 1000, n2 = n / 2; // particles spread in the cube
+    const n = 1000,
+        n2 = n / 2; // particles spread in the cube
 
     for (let i = 0; i < particles; i++) {
         // positions
@@ -47,9 +48,9 @@ function init() {
 
         // colors
 
-        const vx = (x / n) + 0.5;
-        const vy = (y / n) + 0.5;
-        const vz = (z / n) + 0.5;
+        const vx = x / n + 0.5;
+        const vy = y / n + 0.5;
+        const vz = z / n + 0.5;
 
         color.setRGB(vx, vy, vz, THREE.SRGBColorSpace);
 
diff --git a/examples-testing/examples/webgl_buffergeometry_points_interleaved.ts b/examples-testing/examples/webgl_buffergeometry_points_interleaved.ts
index 63015ee..dcbeb7a 100644
--- a/examples-testing/examples/webgl_buffergeometry_points_interleaved.ts
+++ b/examples-testing/examples/webgl_buffergeometry_points_interleaved.ts
@@ -2,17 +2,17 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let points;
+let points: THREE.Points;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 5, 3500);
     camera.position.z = 2750;
@@ -40,7 +40,8 @@ function init() {
 
     const color = new THREE.Color();
 
-    const n = 1000, n2 = n / 2; // particles spread in the cube
+    const n = 1000,
+        n2 = n / 2; // particles spread in the cube
 
     for (let i = 0; i < interleavedFloat32Buffer.length; i += 4) {
         // position (first 12 bytes)
@@ -55,9 +56,9 @@ function init() {
 
         // color (last 4 bytes)
 
-        const vx = (x / n) + 0.5;
-        const vy = (y / n) + 0.5;
-        const vz = (z / n) + 0.5;
+        const vx = x / n + 0.5;
+        const vy = y / n + 0.5;
+        const vz = z / n + 0.5;
 
         color.setRGB(vx, vy, vz, THREE.SRGBColorSpace);
 
diff --git a/examples-testing/examples/webgl_buffergeometry_rawshader.ts b/examples-testing/examples/webgl_buffergeometry_rawshader.ts
index cdc1ed9..78a3121 100644
--- a/examples-testing/examples/webgl_buffergeometry_rawshader.ts
+++ b/examples-testing/examples/webgl_buffergeometry_rawshader.ts
@@ -2,15 +2,15 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10);
     camera.position.z = 2;
@@ -54,8 +54,8 @@ function init() {
         uniforms: {
             time: { value: 1.0 },
         },
-        vertexShader: document.getElementById("vertexShader").textContent,
-        fragmentShader: document.getElementById("fragmentShader").textContent,
+        vertexShader: document.getElementById("vertexShader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentShader")!.textContent!,
         side: THREE.DoubleSide,
         transparent: true,
     });
@@ -93,7 +93,7 @@ function animate() {
 function render() {
     const time = performance.now();
 
-    const object = scene.children[0];
+    const object = scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.RawShaderMaterial>;
 
     object.rotation.y = time * 0.0005;
     object.material.uniforms.time.value = time * 0.005;
diff --git a/examples-testing/examples/webgl_buffergeometry_selective_draw.ts b/examples-testing/examples/webgl_buffergeometry_selective_draw.ts
index e9d9a33..0b60fd2 100644
--- a/examples-testing/examples/webgl_buffergeometry_selective_draw.ts
+++ b/examples-testing/examples/webgl_buffergeometry_selective_draw.ts
@@ -2,8 +2,8 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let camera, scene, renderer, stats;
-let geometry, mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let geometry: THREE.BufferGeometry, mesh: THREE.LineSegments;
 const numLat = 100;
 const numLng = 200;
 let numLinesCulled = 0;
@@ -29,14 +29,14 @@ function init() {
 
     addLines(1.0);
 
-    const hideLinesButton = document.getElementById("hideLines");
+    const hideLinesButton = document.getElementById("hideLines")!;
     hideLinesButton.addEventListener("click", hideLines);
 
-    const showAllLinesButton = document.getElementById("showAllLines");
+    const showAllLinesButton = document.getElementById("showAllLines")!;
     showAllLinesButton.addEventListener("click", showAllLines);
 }
 
-function addLines(radius) {
+function addLines(radius: number) {
     geometry = new THREE.BufferGeometry();
     const linePositions = new Float32Array(numLat * numLng * 3 * 2);
     const lineColors = new Float32Array(numLat * numLng * 3 * 2);
@@ -44,8 +44,8 @@ function addLines(radius) {
 
     for (let i = 0; i < numLat; ++i) {
         for (let j = 0; j < numLng; ++j) {
-            const lat = (Math.random() * Math.PI) / 50.0 + i / numLat * Math.PI;
-            const lng = (Math.random() * Math.PI) / 50.0 + j / numLng * 2 * Math.PI;
+            const lat = (Math.random() * Math.PI) / 50.0 + (i / numLat) * Math.PI;
+            const lng = (Math.random() * Math.PI) / 50.0 + (j / numLng) * 2 * Math.PI;
 
             const index = i * numLng + j;
 
@@ -81,8 +81,8 @@ function addLines(radius) {
     geometry.computeBoundingSphere();
 
     const shaderMaterial = new THREE.ShaderMaterial({
-        vertexShader: document.getElementById("vertexshader").textContent,
-        fragmentShader: document.getElementById("fragmentshader").textContent,
+        vertexShader: document.getElementById("vertexshader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentshader")!.textContent!,
     });
 
     mesh = new THREE.LineSegments(geometry, shaderMaterial);
@@ -92,9 +92,12 @@ function addLines(radius) {
 }
 
 function updateCount() {
-    const str = "1 draw call, " + numLat * numLng + " lines, " + numLinesCulled +
-        ' culled (<a target="_blank" href="http://callum.com">author</a>)';
-    document.getElementById("title").innerHTML = str.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
+    const str = "1 draw call, "
+        + numLat * numLng
+        + " lines, "
+        + numLinesCulled
+        + " culled (<a target=\"_blank\" href=\"http://callum.com\">author</a>)";
+    document.getElementById("title")!.innerHTML = str.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
 }
 
 function hideLines() {
diff --git a/examples-testing/examples/webgl_buffergeometry_uint.ts b/examples-testing/examples/webgl_buffergeometry_uint.ts
index 57b2f01..b112f60 100644
--- a/examples-testing/examples/webgl_buffergeometry_uint.ts
+++ b/examples-testing/examples/webgl_buffergeometry_uint.ts
@@ -2,17 +2,17 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh;
+let mesh: THREE.Mesh;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     //
 
@@ -47,8 +47,10 @@ function init() {
 
     const color = new THREE.Color();
 
-    const n = 800, n2 = n / 2; // triangles spread in the cube
-    const d = 12, d2 = d / 2; // individual triangle size
+    const n = 800,
+        n2 = n / 2; // triangles spread in the cube
+    const d = 12,
+        d2 = d / 2; // individual triangle size
 
     const pA = new THREE.Vector3();
     const pB = new THREE.Vector3();
@@ -102,9 +104,9 @@ function init() {
 
         // colors
 
-        const vx = (x / n) + 0.5;
-        const vy = (y / n) + 0.5;
-        const vz = (z / n) + 0.5;
+        const vx = x / n + 0.5;
+        const vy = y / n + 0.5;
+        const vz = z / n + 0.5;
 
         color.setRGB(vx, vy, vz);
 
diff --git a/examples-testing/examples/webgl_camera.ts b/examples-testing/examples/webgl_camera.ts
index 08356aa..dfd0960 100644
--- a/examples-testing/examples/webgl_camera.ts
+++ b/examples-testing/examples/webgl_camera.ts
@@ -6,11 +6,11 @@ let SCREEN_WIDTH = window.innerWidth;
 let SCREEN_HEIGHT = window.innerHeight;
 let aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
 
-let container, stats;
-let camera, scene, renderer, mesh;
-let cameraRig, activeCamera, activeHelper;
-let cameraPerspective, cameraOrtho;
-let cameraPerspectiveHelper, cameraOrthoHelper;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mesh: THREE.Mesh;
+let cameraRig: THREE.Group, activeCamera: THREE.Camera, activeHelper: THREE.CameraHelper;
+let cameraPerspective: THREE.PerspectiveCamera, cameraOrtho: THREE.OrthographicCamera;
+let cameraPerspectiveHelper: THREE.CameraHelper, cameraOrthoHelper: THREE.CameraHelper;
 const frustumSize = 600;
 
 init();
@@ -34,8 +34,8 @@ function init() {
 
     //
     cameraOrtho = new THREE.OrthographicCamera(
-        0.5 * frustumSize * aspect / -2,
-        0.5 * frustumSize * aspect / 2,
+        (0.5 * frustumSize * aspect) / -2,
+        (0.5 * frustumSize * aspect) / 2,
         frustumSize / 2,
         frustumSize / -2,
         150,
@@ -123,15 +123,15 @@ function init() {
 
 //
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     switch (event.keyCode) {
-        case 79: /*O*/
+        case 79 /*O*/:
             activeCamera = cameraOrtho;
             activeHelper = cameraOrthoHelper;
 
             break;
 
-        case 80: /*P*/
+        case 80 /*P*/:
             activeCamera = cameraPerspective;
             activeHelper = cameraPerspectiveHelper;
 
@@ -154,8 +154,8 @@ function onWindowResize() {
     cameraPerspective.aspect = 0.5 * aspect;
     cameraPerspective.updateProjectionMatrix();
 
-    cameraOrtho.left = -0.5 * frustumSize * aspect / 2;
-    cameraOrtho.right = 0.5 * frustumSize * aspect / 2;
+    cameraOrtho.left = (-0.5 * frustumSize * aspect) / 2;
+    cameraOrtho.right = (0.5 * frustumSize * aspect) / 2;
     cameraOrtho.top = frustumSize / 2;
     cameraOrtho.bottom = -frustumSize / 2;
     cameraOrtho.updateProjectionMatrix();
diff --git a/examples-testing/examples/webgl_camera_logarithmicdepthbuffer.ts b/examples-testing/examples/webgl_camera_logarithmicdepthbuffer.ts
index 6138044..6d01a77 100644
--- a/examples-testing/examples/webgl_camera_logarithmicdepthbuffer.ts
+++ b/examples-testing/examples/webgl_camera_logarithmicdepthbuffer.ts
@@ -1,29 +1,40 @@
 import * as THREE from "three";
 
-import { FontLoader } from "three/addons/loaders/FontLoader.js";
 import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
+import { Font, FontLoader } from "three/addons/loaders/FontLoader.js";
 
 import Stats from "three/addons/libs/stats.module.js";
 
 // 1 micrometer to 100 billion light years in one scene, with 1 unit = 1 meter?  preposterous!  and yet...
-const NEAR = 1e-6, FAR = 1e27;
+const NEAR = 1e-6,
+    FAR = 1e27;
 let SCREEN_WIDTH = window.innerWidth;
 let SCREEN_HEIGHT = window.innerHeight;
-let screensplit = .25, screensplit_right = 0;
-const mouse = [.5, .5];
-let zoompos = -100, minzoomspeed = .015;
+let screensplit = 0.25,
+    screensplit_right = 0;
+const mouse = [0.5, 0.5];
+let zoompos = -100,
+    minzoomspeed = 0.015;
 let zoomspeed = minzoomspeed;
 
-let container, border, stats;
-const objects = {};
+let container: HTMLElement, border: HTMLElement, stats: Stats;
+
+interface ObjectView {
+    container: HTMLElement;
+    renderer: THREE.WebGLRenderer;
+    scene: THREE.Scene;
+    camera: THREE.PerspectiveCamera;
+}
+
+const objects: { normal?: ObjectView; logzbuf?: ObjectView } = {};
 
 // Generate a number of text labels, from 1m in size up to 100,000,000 light years
 // Try to use some descriptive real-world examples of objects at each scale
 
 const labeldata = [
-    { size: .01, scale: 0.0001, label: "microscopic (1m)" }, // FIXME - triangulating text fails at this size, so we scale instead
-    { size: .01, scale: 0.1, label: "minuscule (1mm)" },
-    { size: .01, scale: 1.0, label: "tiny (1cm)" },
+    { size: 0.01, scale: 0.0001, label: "microscopic (1m)" }, // FIXME - triangulating text fails at this size, so we scale instead
+    { size: 0.01, scale: 0.1, label: "minuscule (1mm)" },
+    { size: 0.01, scale: 1.0, label: "tiny (1cm)" },
     { size: 1, scale: 1.0, label: "child-sized (1m)" },
     { size: 10, scale: 1.0, label: "tree-sized (10m)" },
     { size: 100, scale: 1.0, label: "building-sized (100m)" },
@@ -41,10 +52,10 @@ const labeldata = [
 init();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     const loader = new FontLoader();
-    loader.load("fonts/helvetiker_regular.typeface.json", function (font) {
+    loader.load("fonts/helvetiker_regular.typeface.json", function(font) {
         const scene = initScene(font);
 
         // Initialize two copies of the same scene, one with normal z-buffer and one with logarithmic z-buffer
@@ -58,7 +69,7 @@ function init() {
     container.appendChild(stats.dom);
 
     // Resize border allows the user to easily compare effects of logarithmic depth buffer over the whole scene
-    border = document.getElementById("renderer_border");
+    border = document.getElementById("renderer_border")!;
     border.addEventListener("pointerdown", onBorderPointerDown);
 
     window.addEventListener("mousemove", onMouseMove);
@@ -66,10 +77,10 @@ function init() {
     window.addEventListener("wheel", onMouseWheel);
 }
 
-function initView(scene, name, logDepthBuf) {
-    const framecontainer = document.getElementById("container_" + name);
+function initView(scene: THREE.Scene, name: string, logDepthBuf: boolean) {
+    const framecontainer = document.getElementById("container_" + name)!;
 
-    const camera = new THREE.PerspectiveCamera(50, screensplit * SCREEN_WIDTH / SCREEN_HEIGHT, NEAR, FAR);
+    const camera = new THREE.PerspectiveCamera(50, (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT, NEAR, FAR);
     scene.add(camera);
 
     const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: logDepthBuf });
@@ -82,7 +93,7 @@ function initView(scene, name, logDepthBuf) {
     return { container: framecontainer, renderer: renderer, scene: scene, camera: camera };
 }
 
-function initScene(font) {
+function initScene(font: Font) {
     const scene = new THREE.Scene();
 
     scene.add(new THREE.AmbientLight(0x777777));
@@ -91,7 +102,7 @@ function initScene(font) {
     light.position.set(100, 100, 100);
     scene.add(light);
 
-    const materialargs = {
+    const materialargs: { color: THREE.ColorRepresentation; specular: number; shininess: number; emissive: number } = {
         color: 0xffffff,
         specular: 0x050505,
         shininess: 50,
@@ -112,7 +123,7 @@ function initScene(font) {
         labelgeo.computeBoundingSphere();
 
         // center text
-        labelgeo.translate(-labelgeo.boundingSphere.radius, 0, 0);
+        labelgeo.translate(-labelgeo.boundingSphere!.radius, 0, 0);
 
         materialargs.color = new THREE.Color().setHSL(Math.random(), 0.5, 0.5);
 
@@ -125,11 +136,11 @@ function initScene(font) {
         const textmesh = new THREE.Mesh(labelgeo, material);
         textmesh.scale.set(scale, scale, scale);
         textmesh.position.z = -labeldata[i].size * scale;
-        textmesh.position.y = labeldata[i].size / 4 * scale;
+        textmesh.position.y = (labeldata[i].size / 4) * scale;
         group.add(textmesh);
 
         const dotmesh = new THREE.Mesh(geometry, material);
-        dotmesh.position.y = -labeldata[i].size / 4 * scale;
+        dotmesh.position.y = (-labeldata[i].size / 4) * scale;
         dotmesh.scale.multiplyScalar(labeldata[i].size * scale);
         group.add(dotmesh);
     }
@@ -145,16 +156,16 @@ function updateRendererSizes() {
 
     screensplit_right = 1 - screensplit;
 
-    objects.normal.renderer.setSize(screensplit * SCREEN_WIDTH, SCREEN_HEIGHT);
-    objects.normal.camera.aspect = screensplit * SCREEN_WIDTH / SCREEN_HEIGHT;
-    objects.normal.camera.updateProjectionMatrix();
-    objects.normal.camera.setViewOffset(SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT);
-    objects.normal.container.style.width = (screensplit * 100) + "%";
+    objects.normal!.renderer.setSize(screensplit * SCREEN_WIDTH, SCREEN_HEIGHT);
+    objects.normal!.camera.aspect = (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT;
+    objects.normal!.camera.updateProjectionMatrix();
+    objects.normal!.camera.setViewOffset(SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT);
+    objects.normal!.container.style.width = screensplit * 100 + "%";
 
-    objects.logzbuf.renderer.setSize(screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT);
-    objects.logzbuf.camera.aspect = screensplit_right * SCREEN_WIDTH / SCREEN_HEIGHT;
-    objects.logzbuf.camera.updateProjectionMatrix();
-    objects.logzbuf.camera.setViewOffset(
+    objects.logzbuf!.renderer.setSize(screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT);
+    objects.logzbuf!.camera.aspect = (screensplit_right * SCREEN_WIDTH) / SCREEN_HEIGHT;
+    objects.logzbuf!.camera.updateProjectionMatrix();
+    objects.logzbuf!.camera.setViewOffset(
         SCREEN_WIDTH,
         SCREEN_HEIGHT,
         SCREEN_WIDTH * screensplit,
@@ -162,9 +173,9 @@ function updateRendererSizes() {
         SCREEN_WIDTH * screensplit_right,
         SCREEN_HEIGHT,
     );
-    objects.logzbuf.container.style.width = (screensplit_right * 100) + "%";
+    objects.logzbuf!.container.style.width = screensplit_right * 100 + "%";
 
-    border.style.left = (screensplit * 100) + "%";
+    border.style.left = screensplit * 100 + "%";
 }
 
 function animate() {
@@ -176,7 +187,7 @@ function render() {
     // Put some limits on zooming
     const minzoom = labeldata[0].size * labeldata[0].scale * 1;
     const maxzoom = labeldata[labeldata.length - 1].size * labeldata[labeldata.length - 1].scale * 100;
-    let damping = Math.abs(zoomspeed) > minzoomspeed ? .95 : 1.0;
+    let damping = Math.abs(zoomspeed) > minzoomspeed ? 0.95 : 1.0;
 
     // Zoom out faster the further out you go
     const zoom = THREE.MathUtils.clamp(Math.pow(Math.E, zoompos), minzoom, maxzoom);
@@ -184,28 +195,28 @@ function render() {
 
     // Slow down quickly at the zoom limits
     if ((zoom == minzoom && zoomspeed < 0) || (zoom == maxzoom && zoomspeed > 0)) {
-        damping = .85;
+        damping = 0.85;
     }
 
     zoompos += zoomspeed;
     zoomspeed *= damping;
 
-    objects.normal.camera.position.x = Math.sin(.5 * Math.PI * (mouse[0] - .5)) * zoom;
-    objects.normal.camera.position.y = Math.sin(.25 * Math.PI * (mouse[1] - .5)) * zoom;
-    objects.normal.camera.position.z = Math.cos(.5 * Math.PI * (mouse[0] - .5)) * zoom;
-    objects.normal.camera.lookAt(objects.normal.scene.position);
+    objects.normal!.camera.position.x = Math.sin(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
+    objects.normal!.camera.position.y = Math.sin(0.25 * Math.PI * (mouse[1] - 0.5)) * zoom;
+    objects.normal!.camera.position.z = Math.cos(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
+    objects.normal!.camera.lookAt(objects.normal!.scene.position);
 
     // Clone camera settings across both scenes
-    objects.logzbuf.camera.position.copy(objects.normal.camera.position);
-    objects.logzbuf.camera.quaternion.copy(objects.normal.camera.quaternion);
+    objects.logzbuf!.camera.position.copy(objects.normal!.camera.position);
+    objects.logzbuf!.camera.quaternion.copy(objects.normal!.camera.quaternion);
 
     // Update renderer sizes if the split has changed
     if (screensplit_right != 1 - screensplit) {
         updateRendererSizes();
     }
 
-    objects.normal.renderer.render(objects.normal.scene, objects.normal.camera);
-    objects.logzbuf.renderer.render(objects.logzbuf.scene, objects.logzbuf.camera);
+    objects.normal!.renderer.render(objects.normal!.scene, objects.normal!.camera);
+    objects.logzbuf!.renderer.render(objects.logzbuf!.scene, objects.logzbuf!.camera);
 
     stats.update();
 }
@@ -220,7 +231,7 @@ function onBorderPointerDown() {
     window.addEventListener("pointerup", onBorderPointerUp);
 }
 
-function onBorderPointerMove(ev) {
+function onBorderPointerMove(ev: PointerEvent) {
     screensplit = Math.max(0, Math.min(1, ev.clientX / window.innerWidth));
 }
 
@@ -229,12 +240,12 @@ function onBorderPointerUp() {
     window.removeEventListener("pointerup", onBorderPointerUp);
 }
 
-function onMouseMove(ev) {
+function onMouseMove(ev: MouseEvent) {
     mouse[0] = ev.clientX / window.innerWidth;
     mouse[1] = ev.clientY / window.innerHeight;
 }
 
-function onMouseWheel(ev) {
+function onMouseWheel(ev: WheelEvent) {
     const amount = ev.deltaY;
     if (amount === 0) return;
     const dir = amount / Math.abs(amount);
diff --git a/examples-testing/examples/webgl_clipping.ts b/examples-testing/examples/webgl_clipping.ts
index f1ca0a1..d76a04a 100644
--- a/examples-testing/examples/webgl_clipping.ts
+++ b/examples-testing/examples/webgl_clipping.ts
@@ -1,11 +1,16 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let camera, scene, renderer, startTime, object, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    startTime: number,
+    object: THREE.Mesh,
+    stats: Stats;
 
 init();
 animate();
@@ -115,45 +120,45 @@ function init() {
         },
         folderLocal = gui.addFolder("Local Clipping"),
         propsLocal = {
-            get "Enabled"() {
+            get Enabled() {
                 return renderer.localClippingEnabled;
             },
-            set "Enabled"(v) {
+            set Enabled(v) {
                 renderer.localClippingEnabled = v;
             },
 
-            get "Shadows"() {
+            get Shadows() {
                 return material.clipShadows;
             },
-            set "Shadows"(v) {
+            set Shadows(v) {
                 material.clipShadows = v;
             },
 
-            get "Plane"() {
+            get Plane() {
                 return localPlane.constant;
             },
-            set "Plane"(v) {
+            set Plane(v) {
                 localPlane.constant = v;
             },
         },
         folderGlobal = gui.addFolder("Global Clipping"),
         propsGlobal = {
-            get "Enabled"() {
+            get Enabled() {
                 return renderer.clippingPlanes !== Empty;
             },
-            set "Enabled"(v) {
+            set Enabled(v) {
                 renderer.clippingPlanes = v ? globalPlanes : Empty;
             },
 
-            get "Plane"() {
+            get Plane() {
                 return globalPlane.constant;
             },
-            set "Plane"(v) {
+            set Plane(v) {
                 globalPlane.constant = v;
             },
         };
 
-    gui.add(props, "alphaToCoverage").onChange(function (value) {
+    gui.add(props, "alphaToCoverage").onChange(function(value) {
         ground.material.alphaToCoverage = value;
         ground.material.needsUpdate = true;
 
diff --git a/examples-testing/examples/webgl_clipping_advanced.ts b/examples-testing/examples/webgl_clipping_advanced.ts
index 0e65da1..dac2096 100644
--- a/examples-testing/examples/webgl_clipping_advanced.ts
+++ b/examples-testing/examples/webgl_clipping_advanced.ts
@@ -1,11 +1,11 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-function planesFromMesh(vertices, indices) {
+function planesFromMesh(vertices: THREE.Vector3[], indices: number[]) {
     // creates a clipping volume from a convex triangular mesh
     // specified by the arrays 'vertices' and 'indices'
 
@@ -17,45 +17,36 @@ function planesFromMesh(vertices, indices) {
             b = vertices[indices[j + 1]],
             c = vertices[indices[j + 2]];
 
-        result[i] = new THREE.Plane()
-            .setFromCoplanarPoints(a, b, c);
+        result[i] = new THREE.Plane().setFromCoplanarPoints(a, b, c);
     }
 
     return result;
 }
 
-function createPlanes(n) {
+function createPlanes(n: number) {
     // creates an array of n uninitialized plane objects
 
-    const result = new Array(n);
+    const result = new Array<THREE.Plane>(n);
 
-    for (let i = 0; i !== n; ++i) {
-        result[i] = new THREE.Plane();
-    }
+    for (let i = 0; i !== n; ++i) result[i] = new THREE.Plane();
 
     return result;
 }
 
-function assignTransformedPlanes(planesOut, planesIn, matrix) {
+function assignTransformedPlanes(planesOut: THREE.Plane[], planesIn: THREE.Plane[], matrix: THREE.Matrix4) {
     // sets an array of existing planes to transformed 'planesIn'
 
-    for (let i = 0, n = planesIn.length; i !== n; ++i) {
-        planesOut[i].copy(planesIn[i]).applyMatrix4(matrix);
-    }
+    for (let i = 0, n = planesIn.length; i !== n; ++i) planesOut[i].copy(planesIn[i]).applyMatrix4(matrix);
 }
 
-function cylindricalPlanes(n, innerRadius) {
+function cylindricalPlanes(n: number, innerRadius: number) {
     const result = createPlanes(n);
 
     for (let i = 0; i !== n; ++i) {
         const plane = result[i],
-            angle = i * Math.PI * 2 / n;
+            angle = (i * Math.PI * 2) / n;
 
-        plane.normal.set(
-            Math.cos(angle),
-            0,
-            Math.sin(angle),
-        );
+        plane.normal.set(Math.cos(angle), 0, Math.sin(angle));
 
         plane.constant = innerRadius;
     }
@@ -63,7 +54,7 @@ function cylindricalPlanes(n, innerRadius) {
     return result;
 }
 
-const planeToMatrix = (function () {
+const planeToMatrix = (function() {
     // creates a matrix that aligns X/Y to a given plane
 
     // temporaries:
@@ -71,7 +62,7 @@ const planeToMatrix = (function () {
         yAxis = new THREE.Vector3(),
         trans = new THREE.Vector3();
 
-    return function planeToMatrix(plane) {
+    return function planeToMatrix(plane: THREE.Plane) {
         const zAxis = plane.normal,
             matrix = new THREE.Matrix4();
 
@@ -116,34 +107,24 @@ const Vertices = [
         new THREE.Vector3(0, +1, -Math.SQRT1_2),
         new THREE.Vector3(0, -1, -Math.SQRT1_2),
     ],
-    Indices = [
-        0,
-        1,
-        2,
-        0,
-        2,
-        3,
-        0,
-        3,
-        1,
-        1,
-        3,
-        2,
-    ],
+    Indices = [0, 1, 2, 0, 2, 3, 0, 3, 1, 1, 3, 2],
     Planes = planesFromMesh(Vertices, Indices),
     PlaneMatrices = Planes.map(planeToMatrix),
     GlobalClippingPlanes = cylindricalPlanes(5, 2.5),
     Empty = Object.freeze([]);
 
-let camera, scene, renderer, startTime, stats, object, clipMaterial, volumeVisualization, globalClippingPlanes;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    startTime: number,
+    stats: Stats,
+    object: THREE.Group,
+    clipMaterial: THREE.MeshPhongMaterial,
+    volumeVisualization: THREE.Group,
+    globalClippingPlanes: THREE.Plane[];
 
 function init() {
-    camera = new THREE.PerspectiveCamera(
-        36,
-        window.innerWidth / window.innerHeight,
-        0.25,
-        16,
-    );
+    camera = new THREE.PerspectiveCamera(36, window.innerWidth / window.innerHeight, 0.25, 16);
 
     camera.position.set(0, 1.5, 3);
 
@@ -223,10 +204,9 @@ function init() {
 
             // clip to the others to show the volume (wildly
             // intersecting transparent planes look bad)
-            clippingPlanes: clipMaterial.clippingPlanes
-                .filter(function (_, j) {
-                    return j !== i;
-                }),
+            clippingPlanes: clipMaterial.clippingPlanes!.filter(function(_, j) {
+                return j !== i;
+            }),
             // no need to enable shadow clipping - the plane
             // visualization does not cast shadows
         });
@@ -284,28 +264,26 @@ function init() {
     const gui = new GUI(),
         folder = gui.addFolder("Local Clipping"),
         props = {
-            get "Enabled"() {
+            get Enabled() {
                 return renderer.localClippingEnabled;
             },
-            set "Enabled"(v) {
+            set Enabled(v) {
                 renderer.localClippingEnabled = v;
                 if (!v) volumeVisualization.visible = false;
             },
 
-            get "Shadows"() {
+            get Shadows() {
                 return clipMaterial.clipShadows;
             },
-            set "Shadows"(v) {
+            set Shadows(v) {
                 clipMaterial.clipShadows = v;
             },
 
-            get "Visualize"() {
+            get Visualize() {
                 return volumeVisualization.visible;
             },
-            set "Visualize"(v) {
-                if (renderer.localClippingEnabled) {
-                    volumeVisualization.visible = v;
-                }
+            set Visualize(v) {
+                if (renderer.localClippingEnabled) volumeVisualization.visible = v;
             },
         };
 
@@ -313,15 +291,17 @@ function init() {
     folder.add(props, "Shadows");
     folder.add(props, "Visualize").listen();
 
-    gui.addFolder("Global Clipping")
-        .add({
-            get "Enabled"() {
+    gui.addFolder("Global Clipping").add(
+        {
+            get Enabled() {
                 return renderer.clippingPlanes !== Empty;
             },
-            set "Enabled"(v) {
+            set Enabled(v) {
                 renderer.clippingPlanes = v ? globalClippingPlanes : Empty;
             },
-        }, "Enabled");
+        },
+        "Enabled",
+    );
 
     // Start
 
@@ -335,12 +315,12 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function setObjectWorldMatrix(object, matrix) {
+function setObjectWorldMatrix(object: THREE.Object3D, matrix: THREE.Matrix4) {
     // set the orientation of an object based on a world matrix
 
     const parent = object.parent;
     scene.updateMatrixWorld();
-    object.matrix.copy(parent.matrixWorld).invert();
+    object.matrix.copy(parent!.matrixWorld).invert();
     object.applyMatrix4(matrix);
 }
 
@@ -360,16 +340,10 @@ function animate() {
     object.updateMatrix();
     transform.copy(object.matrix);
 
-    const bouncy = Math.cos(time * .5) * 0.5 + 0.7;
-    transform.multiply(
-        tmpMatrix.makeScale(bouncy, bouncy, bouncy),
-    );
+    const bouncy = Math.cos(time * 0.5) * 0.5 + 0.7;
+    transform.multiply(tmpMatrix.makeScale(bouncy, bouncy, bouncy));
 
-    assignTransformedPlanes(
-        clipMaterial.clippingPlanes,
-        Planes,
-        transform,
-    );
+    assignTransformedPlanes(clipMaterial.clippingPlanes!, Planes, transform);
 
     const planeMeshes = volumeVisualization.children;
 
diff --git a/examples-testing/examples/webgl_clipping_intersection.ts b/examples-testing/examples/webgl_clipping_intersection.ts
index adda9c2..c65b041 100644
--- a/examples-testing/examples/webgl_clipping_intersection.ts
+++ b/examples-testing/examples/webgl_clipping_intersection.ts
@@ -4,7 +4,7 @@ import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const params = {
     clipIntersection: true,
@@ -78,38 +78,45 @@ function init() {
 
     const gui = new GUI();
 
-    gui.add(params, "alphaToCoverage").onChange(function (value) {
-        group.children.forEach((c) => {
-            c.material.alphaToCoverage = Boolean(value);
-            c.material.needsUpdate = true;
+    gui.add(params, "alphaToCoverage").onChange(function(value) {
+        group.children.forEach(c => {
+            (c as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.alphaToCoverage = Boolean(value);
+            (c as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.needsUpdate = true;
         });
 
         render();
     });
 
-    gui.add(params, "clipIntersection").name("clip intersection").onChange(function (value) {
-        const children = group.children;
+    gui.add(params, "clipIntersection")
+        .name("clip intersection")
+        .onChange(function(value) {
+            const children = group.children;
 
-        for (let i = 0; i < children.length; i++) {
-            children[i].material.clipIntersection = value;
-        }
+            for (let i = 0; i < children.length; i++) {
+                ((children[i] as THREE.Mesh).material as THREE.Material).clipIntersection = value;
+            }
 
-        render();
-    });
+            render();
+        });
 
-    gui.add(params, "planeConstant", -1, 1).step(0.01).name("plane constant").onChange(function (value) {
-        for (let j = 0; j < clipPlanes.length; j++) {
-            clipPlanes[j].constant = value;
-        }
+    gui.add(params, "planeConstant", -1, 1)
+        .step(0.01)
+        .name("plane constant")
+        .onChange(function(value) {
+            for (let j = 0; j < clipPlanes.length; j++) {
+                clipPlanes[j].constant = value;
+            }
 
-        render();
-    });
+            render();
+        });
 
-    gui.add(params, "showHelpers").name("show helpers").onChange(function (value) {
-        helpers.visible = value;
+    gui.add(params, "showHelpers")
+        .name("show helpers")
+        .onChange(function(value) {
+            helpers.visible = value;
 
-        render();
-    });
+            render();
+        });
 
     //
 
diff --git a/examples-testing/examples/webgl_clipping_stencil.ts b/examples-testing/examples/webgl_clipping_stencil.ts
index 5ec3115..76af06d 100644
--- a/examples-testing/examples/webgl_clipping_stencil.ts
+++ b/examples-testing/examples/webgl_clipping_stencil.ts
@@ -3,9 +3,13 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import Stats from "three/addons/libs/stats.module.js";
 
-let camera, scene, renderer, object, stats;
-let planes, planeObjects, planeHelpers;
-let clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    object: THREE.Group,
+    stats: Stats;
+let planes: THREE.Plane[], planeObjects: THREE.Mesh[], planeHelpers: THREE.PlaneHelper[];
+let clock: THREE.Clock;
 
 const params = {
     animate: true,
@@ -29,7 +33,7 @@ const params = {
 init();
 animate();
 
-function createPlaneStencilGroup(geometry, plane, renderOrder) {
+function createPlaneStencilGroup(geometry: THREE.TorusKnotGeometry, plane: THREE.Plane, renderOrder: number) {
     const group = new THREE.Group();
     const baseMat = new THREE.MeshBasicMaterial();
     baseMat.depthWrite = false;
@@ -94,8 +98,8 @@ function init() {
         new THREE.Plane(new THREE.Vector3(0, 0, -1), 0),
     ];
 
-    planeHelpers = planes.map((p) => new THREE.PlaneHelper(p, 2, 0xffffff));
-    planeHelpers.forEach((ph) => {
+    planeHelpers = planes.map(p => new THREE.PlaneHelper(p, 2, 0xffffff));
+    planeHelpers.forEach(ph => {
         ph.visible = false;
         scene.add(ph);
     });
@@ -115,10 +119,10 @@ function init() {
 
         // plane is clipped by the other clipping planes
         const planeMat = new THREE.MeshStandardMaterial({
-            color: 0xE91E63,
+            color: 0xe91e63,
             metalness: 0.1,
             roughness: 0.75,
-            clippingPlanes: planes.filter((p) => p !== plane),
+            clippingPlanes: planes.filter(p => p !== plane),
 
             stencilWrite: true,
             stencilRef: 0,
@@ -128,7 +132,7 @@ function init() {
             stencilZPass: THREE.ReplaceStencilOp,
         });
         const po = new THREE.Mesh(planeGeom, planeMat);
-        po.onAfterRender = function (renderer) {
+        po.onAfterRender = function(renderer) {
             renderer.clearStencil();
         };
 
@@ -141,7 +145,7 @@ function init() {
     }
 
     const material = new THREE.MeshStandardMaterial({
-        color: 0xFFC107,
+        color: 0xffc107,
         metalness: 0.1,
         roughness: 0.75,
         clippingPlanes: planes,
@@ -191,8 +195,12 @@ function init() {
     gui.add(params, "animate");
 
     const planeX = gui.addFolder("planeX");
-    planeX.add(params.planeX, "displayHelper").onChange((v) => planeHelpers[0].visible = v);
-    planeX.add(params.planeX, "constant").min(-1).max(1).onChange((d) => planes[0].constant = d);
+    planeX.add(params.planeX, "displayHelper").onChange(v => (planeHelpers[0].visible = v));
+    planeX
+        .add(params.planeX, "constant")
+        .min(-1)
+        .max(1)
+        .onChange(d => (planes[0].constant = d));
     planeX.add(params.planeX, "negated").onChange(() => {
         planes[0].negate();
         params.planeX.constant = planes[0].constant;
@@ -200,8 +208,12 @@ function init() {
     planeX.open();
 
     const planeY = gui.addFolder("planeY");
-    planeY.add(params.planeY, "displayHelper").onChange((v) => planeHelpers[1].visible = v);
-    planeY.add(params.planeY, "constant").min(-1).max(1).onChange((d) => planes[1].constant = d);
+    planeY.add(params.planeY, "displayHelper").onChange(v => (planeHelpers[1].visible = v));
+    planeY
+        .add(params.planeY, "constant")
+        .min(-1)
+        .max(1)
+        .onChange(d => (planes[1].constant = d));
     planeY.add(params.planeY, "negated").onChange(() => {
         planes[1].negate();
         params.planeY.constant = planes[1].constant;
@@ -209,8 +221,12 @@ function init() {
     planeY.open();
 
     const planeZ = gui.addFolder("planeZ");
-    planeZ.add(params.planeZ, "displayHelper").onChange((v) => planeHelpers[2].visible = v);
-    planeZ.add(params.planeZ, "constant").min(-1).max(1).onChange((d) => planes[2].constant = d);
+    planeZ.add(params.planeZ, "displayHelper").onChange(v => (planeHelpers[2].visible = v));
+    planeZ
+        .add(params.planeZ, "constant")
+        .min(-1)
+        .max(1)
+        .onChange(d => (planes[2].constant = d));
     planeZ.add(params.planeZ, "negated").onChange(() => {
         planes[2].negate();
         params.planeZ.constant = planes[2].constant;
@@ -239,11 +255,7 @@ function animate() {
         const plane = planes[i];
         const po = planeObjects[i];
         plane.coplanarPoint(po.position);
-        po.lookAt(
-            po.position.x - plane.normal.x,
-            po.position.y - plane.normal.y,
-            po.position.z - plane.normal.z,
-        );
+        po.lookAt(po.position.x - plane.normal.x, po.position.y - plane.normal.y, po.position.z - plane.normal.z);
     }
 
     stats.begin();
diff --git a/examples-testing/examples/webgl_custom_attributes.ts b/examples-testing/examples/webgl_custom_attributes.ts
index 25ee050..c5fe226 100644
--- a/examples-testing/examples/webgl_custom_attributes.ts
+++ b/examples-testing/examples/webgl_custom_attributes.ts
@@ -2,11 +2,16 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let sphere, uniforms;
+let sphere: THREE.Mesh,
+    uniforms: {
+        amplitude: THREE.IUniform<number>;
+        color: THREE.IUniform<THREE.Color>;
+        colorTexture: THREE.IUniform<THREE.Texture>;
+    };
 
-let displacement, noise;
+let displacement: Float32Array, noise: Float32Array;
 
 init();
 animate();
@@ -19,20 +24,22 @@ function init() {
     scene.background = new THREE.Color(0x050505);
 
     uniforms = {
-        "amplitude": { value: 1.0 },
-        "color": { value: new THREE.Color(0xff2200) },
-        "colorTexture": { value: new THREE.TextureLoader().load("textures/water.jpg") },
+        amplitude: { value: 1.0 },
+        color: { value: new THREE.Color(0xff2200) },
+        colorTexture: { value: new THREE.TextureLoader().load("textures/water.jpg") },
     };
 
     uniforms["colorTexture"].value.wrapS = uniforms["colorTexture"].value.wrapT = THREE.RepeatWrapping;
 
     const shaderMaterial = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById("vertexshader").textContent,
-        fragmentShader: document.getElementById("fragmentshader").textContent,
+        vertexShader: document.getElementById("vertexshader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentshader")!.textContent!,
     });
 
-    const radius = 50, segments = 128, rings = 64;
+    const radius = 50,
+        segments = 128,
+        rings = 64;
 
     const geometry = new THREE.SphereGeometry(radius, segments, rings);
 
@@ -52,7 +59,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
 
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_custom_attributes_lines.ts b/examples-testing/examples/webgl_custom_attributes_lines.ts
index 12a9a61..a7fc57f 100644
--- a/examples-testing/examples/webgl_custom_attributes_lines.ts
+++ b/examples-testing/examples/webgl_custom_attributes_lines.ts
@@ -1,21 +1,26 @@
 import * as THREE from "three";
 
-import { FontLoader } from "three/addons/loaders/FontLoader.js";
 import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
+import { Font, FontLoader } from "three/addons/loaders/FontLoader.js";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let line, uniforms;
+let line: THREE.Line,
+    uniforms: {
+        amplitude: THREE.IUniform<number>;
+        opacity: THREE.IUniform<number>;
+        color: THREE.IUniform<THREE.Color>;
+    };
 
 const loader = new FontLoader();
-loader.load("fonts/helvetiker_bold.typeface.json", function (font) {
+loader.load("fonts/helvetiker_bold.typeface.json", function(font) {
     init(font);
     animate();
 });
 
-function init(font) {
+function init(font: Font) {
     camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 400;
 
@@ -30,8 +35,8 @@ function init(font) {
 
     const shaderMaterial = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById("vertexshader").textContent,
-        fragmentShader: document.getElementById("fragmentshader").textContent,
+        vertexShader: document.getElementById("vertexshader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentshader")!.textContent!,
         blending: THREE.AdditiveBlending,
         depthTest: false,
         transparent: true,
@@ -75,7 +80,7 @@ function init(font) {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
 
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_custom_attributes_points.ts b/examples-testing/examples/webgl_custom_attributes_points.ts
index 75dc2f2..8fd99c4 100644
--- a/examples-testing/examples/webgl_custom_attributes_points.ts
+++ b/examples-testing/examples/webgl_custom_attributes_points.ts
@@ -2,9 +2,9 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let sphere;
+let sphere: THREE.Points;
 
 const WIDTH = window.innerWidth;
 const HEIGHT = window.innerHeight;
@@ -57,8 +57,8 @@ function init() {
             color: { value: new THREE.Color(0xffffff) },
             pointTexture: { value: new THREE.TextureLoader().load("textures/sprites/spark1.png") },
         },
-        vertexShader: document.getElementById("vertexshader").textContent,
-        fragmentShader: document.getElementById("fragmentshader").textContent,
+        vertexShader: document.getElementById("vertexshader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentshader")!.textContent!,
 
         blending: THREE.AdditiveBlending,
         depthTest: false,
@@ -76,7 +76,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(WIDTH, HEIGHT);
 
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_custom_attributes_points2.ts b/examples-testing/examples/webgl_custom_attributes_points2.ts
index 3400bfe..cd1a369 100644
--- a/examples-testing/examples/webgl_custom_attributes_points2.ts
+++ b/examples-testing/examples/webgl_custom_attributes_points2.ts
@@ -4,8 +4,8 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import * as BufferGeometryUtils from "three/addons/utils/BufferGeometryUtils.js";
 
-let renderer, scene, camera, stats;
-let sphere, length1;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
+let sphere: THREE.Points, length1: number;
 
 const WIDTH = window.innerWidth;
 const HEIGHT = window.innerHeight;
@@ -19,10 +19,12 @@ function init() {
 
     scene = new THREE.Scene();
 
-    const radius = 100, segments = 68, rings = 38;
+    const radius = 100,
+        segments = 68,
+        rings = 38;
 
-    let sphereGeometry = new THREE.SphereGeometry(radius, segments, rings);
-    let boxGeometry = new THREE.BoxGeometry(0.8 * radius, 0.8 * radius, 0.8 * radius, 10, 10, 10);
+    let sphereGeometry: THREE.BufferGeometry = new THREE.SphereGeometry(radius, segments, rings);
+    let boxGeometry: THREE.BufferGeometry = new THREE.BoxGeometry(0.8 * radius, 0.8 * radius, 0.8 * radius, 10, 10, 10);
 
     // if normal and uv attributes are not removed, mergeVertices() can't consolidate identical vertices with different normal/uv data
 
@@ -38,8 +40,8 @@ function init() {
     const combinedGeometry = BufferGeometryUtils.mergeGeometries([sphereGeometry, boxGeometry]);
     const positionAttribute = combinedGeometry.getAttribute("position");
 
-    const colors = [];
-    const sizes = [];
+    const colors: number[] = [];
+    const sizes: number[] = [];
 
     const color = new THREE.Color();
     const vertex = new THREE.Vector3();
@@ -76,8 +78,8 @@ function init() {
             color: { value: new THREE.Color(0xffffff) },
             pointTexture: { value: texture },
         },
-        vertexShader: document.getElementById("vertexshader").textContent,
-        fragmentShader: document.getElementById("fragmentshader").textContent,
+        vertexShader: document.getElementById("vertexshader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentshader")!.textContent!,
         transparent: true,
     });
 
@@ -92,7 +94,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(WIDTH, HEIGHT);
 
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
@@ -148,7 +150,7 @@ function sortPoints() {
         sortArray.push([vector.z, i]);
     }
 
-    function numericalSort(a, b) {
+    function numericalSort(a: number[], b: number[]) {
         return b[0] - a[0];
     }
 
@@ -160,7 +162,7 @@ function sortPoints() {
         indices[i] = sortArray[i][1];
     }
 
-    geometry.index.needsUpdate = true;
+    geometry.index!.needsUpdate = true;
 }
 
 function animate() {
diff --git a/examples-testing/examples/webgl_custom_attributes_points3.ts b/examples-testing/examples/webgl_custom_attributes_points3.ts
index 216624c..2ad332b 100644
--- a/examples-testing/examples/webgl_custom_attributes_points3.ts
+++ b/examples-testing/examples/webgl_custom_attributes_points3.ts
@@ -4,11 +4,11 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import * as BufferGeometryUtils from "three/addons/utils/BufferGeometryUtils.js";
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let object;
+let object: THREE.Points;
 
-let vertices1;
+let vertices1: number;
 
 const WIDTH = window.innerWidth;
 const HEIGHT = window.innerHeight;
@@ -34,9 +34,12 @@ function init() {
         vertex.multiplyScalar(radius);
 
         if (
-            (vertex.x > inner || vertex.x < -inner) ||
-            (vertex.y > inner || vertex.y < -inner) ||
-            (vertex.z > inner || vertex.z < -inner)
+            vertex.x > inner
+            || vertex.x < -inner
+            || vertex.y > inner
+            || vertex.y < -inner
+            || vertex.z > inner
+            || vertex.z < -inner
         ) {
             vertices.push(vertex.x, vertex.y, vertex.z);
         }
@@ -46,7 +49,7 @@ function init() {
 
     radius = 200;
 
-    let boxGeometry1 = new THREE.BoxGeometry(radius, 0.1 * radius, 0.1 * radius, 50, 5, 5);
+    let boxGeometry1: THREE.BufferGeometry = new THREE.BoxGeometry(radius, 0.1 * radius, 0.1 * radius, 50, 5, 5);
 
     // if normal and uv attributes are not removed, mergeVertices() can't consolidate indentical vertices with different normal/uv data
 
@@ -61,7 +64,7 @@ function init() {
     const quaternion = new THREE.Quaternion();
     const scale = new THREE.Vector3(1, 1, 1);
 
-    function addGeo(geo, x, y, z, ry) {
+    function addGeo(geo: THREE.BufferGeometry, x: number, y: number, z: number, ry: number) {
         position.set(x, y, z);
         rotation.set(0, ry, 0);
 
@@ -92,7 +95,7 @@ function init() {
 
     // corner edges
 
-    let boxGeometry2 = new THREE.BoxGeometry(0.1 * radius, radius * 1.2, 0.1 * radius, 5, 60, 5);
+    let boxGeometry2: THREE.BufferGeometry = new THREE.BoxGeometry(0.1 * radius, radius * 1.2, 0.1 * radius, 5, 60, 5);
 
     boxGeometry2.deleteAttribute("normal");
     boxGeometry2.deleteAttribute("uv");
@@ -106,8 +109,8 @@ function init() {
 
     const positionAttribute = new THREE.Float32BufferAttribute(vertices, 3);
 
-    const colors = [];
-    const sizes = [];
+    const colors: number[] = [];
+    const sizes: number[] = [];
 
     const color = new THREE.Color();
 
@@ -140,8 +143,8 @@ function init() {
             color: { value: new THREE.Color(0xffffff) },
             pointTexture: { value: texture },
         },
-        vertexShader: document.getElementById("vertexshader").textContent,
-        fragmentShader: document.getElementById("fragmentshader").textContent,
+        vertexShader: document.getElementById("vertexshader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentshader")!.textContent!,
     });
 
     //
@@ -155,7 +158,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(WIDTH, HEIGHT);
 
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
     container.appendChild(renderer.domElement);
 
     stats = new Stats();
diff --git a/examples-testing/examples/webgl_decals.ts b/examples-testing/examples/webgl_decals.ts
index 3c770bf..5dcc850 100644
--- a/examples-testing/examples/webgl_decals.ts
+++ b/examples-testing/examples/webgl_decals.ts
@@ -1,18 +1,18 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { DecalGeometry } from "three/addons/geometries/DecalGeometry.js";
+import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-const container = document.getElementById("container");
+const container = document.getElementById("container")!;
 
-let renderer, scene, camera, stats;
-let mesh;
-let raycaster;
-let line;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
+let mesh: THREE.Mesh;
+let raycaster: THREE.Raycaster;
+let line: THREE.Line;
 
 const intersection = {
     intersects: false,
@@ -20,7 +20,7 @@ const intersection = {
     normal: new THREE.Vector3(),
 };
 const mouse = new THREE.Vector2();
-const intersects = [];
+const intersects: THREE.Intersection[] = [];
 
 const textureLoader = new THREE.TextureLoader();
 const decalDiffuse = textureLoader.load("textures/decal/decal-diffuse.png");
@@ -41,8 +41,8 @@ const decalMaterial = new THREE.MeshPhongMaterial({
     wireframe: false,
 });
 
-const decals = [];
-let mouseHelper;
+const decals: THREE.Mesh[] = [];
+let mouseHelper: THREE.Mesh;
 const position = new THREE.Vector3();
 const orientation = new THREE.Euler();
 const size = new THREE.Vector3(10, 10, 10);
@@ -51,7 +51,7 @@ const params = {
     minScale: 10,
     maxScale: 20,
     rotate: true,
-    clear: function () {
+    clear: function() {
         removeDecals();
     },
 };
@@ -105,15 +105,15 @@ function init() {
 
     let moved = false;
 
-    controls.addEventListener("change", function () {
+    controls.addEventListener("change", function() {
         moved = true;
     });
 
-    window.addEventListener("pointerdown", function () {
+    window.addEventListener("pointerdown", function() {
         moved = false;
     });
 
-    window.addEventListener("pointerup", function (event) {
+    window.addEventListener("pointerup", function(event) {
         if (moved === false) {
             checkIntersection(event.clientX, event.clientY);
 
@@ -123,13 +123,13 @@ function init() {
 
     window.addEventListener("pointermove", onPointerMove);
 
-    function onPointerMove(event) {
+    function onPointerMove(event: PointerEvent) {
         if (event.isPrimary) {
             checkIntersection(event.clientX, event.clientY);
         }
     }
 
-    function checkIntersection(x, y) {
+    function checkIntersection(x: number, y: number) {
         if (mesh === undefined) return;
 
         mouse.x = (x / window.innerWidth) * 2 - 1;
@@ -143,12 +143,12 @@ function init() {
             mouseHelper.position.copy(p);
             intersection.point.copy(p);
 
-            const n = intersects[0].face.normal.clone();
+            const n = intersects[0].face!.normal.clone();
             n.transformDirection(mesh.matrixWorld);
             n.multiplyScalar(10);
             n.add(intersects[0].point);
 
-            intersection.normal.copy(intersects[0].face.normal);
+            intersection.normal.copy(intersects[0].face!.normal);
             mouseHelper.lookAt(n);
 
             const positions = line.geometry.attributes.position;
@@ -181,8 +181,8 @@ function loadLeePerrySmith() {
 
     const loader = new GLTFLoader();
 
-    loader.load("models/gltf/LeePerrySmith/LeePerrySmith.glb", function (gltf) {
-        mesh = gltf.scene.children[0];
+    loader.load("models/gltf/LeePerrySmith/LeePerrySmith.glb", function(gltf) {
+        mesh = gltf.scene.children[0] as THREE.Mesh;
         mesh.material = new THREE.MeshPhongMaterial({
             specular: 0x111111,
             map: map,
@@ -216,7 +216,7 @@ function shoot() {
 }
 
 function removeDecals() {
-    decals.forEach(function (d) {
+    decals.forEach(function(d) {
         scene.remove(d);
     });
 
diff --git a/examples-testing/examples/webgl_effects_anaglyph.ts b/examples-testing/examples/webgl_effects_anaglyph.ts
index 1b6db02..82c40be 100644
--- a/examples-testing/examples/webgl_effects_anaglyph.ts
+++ b/examples-testing/examples/webgl_effects_anaglyph.ts
@@ -2,9 +2,13 @@ import * as THREE from "three";
 
 import { AnaglyphEffect } from "three/addons/effects/AnaglyphEffect.js";
 
-let container, camera, scene, renderer, effect;
+let container: HTMLDivElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    effect: AnaglyphEffect;
 
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
 let mouseX = 0;
 let mouseY = 0;
@@ -84,7 +88,7 @@ function onWindowResize() {
     effect.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) / 100;
     mouseY = (event.clientY - windowHalfY) / 100;
 }
@@ -100,8 +104,8 @@ function animate() {
 function render() {
     const timer = 0.0001 * Date.now();
 
-    camera.position.x += (mouseX - camera.position.x) * .05;
-    camera.position.y += (-mouseY - camera.position.y) * .05;
+    camera.position.x += (mouseX - camera.position.x) * 0.05;
+    camera.position.y += (-mouseY - camera.position.y) * 0.05;
 
     camera.lookAt(scene.position);
 
diff --git a/examples-testing/examples/webgl_effects_ascii.ts b/examples-testing/examples/webgl_effects_ascii.ts
index bce9405..8a48a48 100644
--- a/examples-testing/examples/webgl_effects_ascii.ts
+++ b/examples-testing/examples/webgl_effects_ascii.ts
@@ -1,11 +1,15 @@
 import * as THREE from "three";
 
-import { AsciiEffect } from "three/addons/effects/AsciiEffect.js";
 import { TrackballControls } from "three/addons/controls/TrackballControls.js";
+import { AsciiEffect } from "three/addons/effects/AsciiEffect.js";
 
-let camera, controls, scene, renderer, effect;
+let camera: THREE.PerspectiveCamera,
+    controls: TrackballControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    effect: AsciiEffect;
 
-let sphere, plane;
+let sphere: THREE.Mesh, plane: THREE.Mesh;
 
 const start = Date.now();
 
diff --git a/examples-testing/examples/webgl_effects_parallaxbarrier.ts b/examples-testing/examples/webgl_effects_parallaxbarrier.ts
index fef3b87..24d7f3b 100644
--- a/examples-testing/examples/webgl_effects_parallaxbarrier.ts
+++ b/examples-testing/examples/webgl_effects_parallaxbarrier.ts
@@ -2,9 +2,13 @@ import * as THREE from "three";
 
 import { ParallaxBarrierEffect } from "three/addons/effects/ParallaxBarrierEffect.js";
 
-let container, camera, scene, renderer, effect;
+let container: HTMLDivElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    effect: ParallaxBarrierEffect;
 
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
 let mouseX = 0;
 let mouseY = 0;
@@ -84,7 +88,7 @@ function onWindowResize() {
     effect.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) / 100;
     mouseY = (event.clientY - windowHalfY) / 100;
 }
@@ -100,8 +104,8 @@ function animate() {
 function render() {
     const timer = 0.0001 * Date.now();
 
-    camera.position.x += (mouseX - camera.position.x) * .05;
-    camera.position.y += (-mouseY - camera.position.y) * .05;
+    camera.position.x += (mouseX - camera.position.x) * 0.05;
+    camera.position.y += (-mouseY - camera.position.y) * 0.05;
 
     camera.lookAt(scene.position);
 
diff --git a/examples-testing/examples/webgl_effects_peppersghost.ts b/examples-testing/examples/webgl_effects_peppersghost.ts
index 3b5407b..8b77ad8 100644
--- a/examples-testing/examples/webgl_effects_peppersghost.ts
+++ b/examples-testing/examples/webgl_effects_peppersghost.ts
@@ -2,10 +2,10 @@ import * as THREE from "three";
 
 import { PeppersGhostEffect } from "three/addons/effects/PeppersGhostEffect.js";
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer, effect;
-let group;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, effect: PeppersGhostEffect;
+let group: THREE.Group;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_effects_stereo.ts b/examples-testing/examples/webgl_effects_stereo.ts
index 7b80785..68e96f9 100644
--- a/examples-testing/examples/webgl_effects_stereo.ts
+++ b/examples-testing/examples/webgl_effects_stereo.ts
@@ -2,11 +2,16 @@ import * as THREE from "three";
 
 import { StereoEffect } from "three/addons/effects/StereoEffect.js";
 
-let container, camera, scene, renderer, effect;
+let container: HTMLDivElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    effect: StereoEffect;
 
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
-let mouseX = 0, mouseY = 0;
+let mouseX = 0,
+    mouseY = 0;
 
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
@@ -72,7 +77,7 @@ function onWindowResize() {
     effect.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) * 10;
     mouseY = (event.clientY - windowHalfY) * 10;
 }
@@ -88,8 +93,8 @@ function animate() {
 function render() {
     const timer = 0.0001 * Date.now();
 
-    camera.position.x += (mouseX - camera.position.x) * .05;
-    camera.position.y += (-mouseY - camera.position.y) * .05;
+    camera.position.x += (mouseX - camera.position.x) * 0.05;
+    camera.position.y += (-mouseY - camera.position.y) * 0.05;
     camera.lookAt(scene.position);
 
     for (let i = 0, il = spheres.length; i < il; i++) {
diff --git a/examples-testing/examples/webgl_framebuffer_texture.ts b/examples-testing/examples/webgl_framebuffer_texture.ts
index ed0ab13..13073a5 100644
--- a/examples-testing/examples/webgl_framebuffer_texture.ts
+++ b/examples-testing/examples/webgl_framebuffer_texture.ts
@@ -3,10 +3,10 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import * as GeometryUtils from "three/addons/utils/GeometryUtils.js";
 
-let camera, scene, renderer;
-let line, sprite, texture;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let line: THREE.Line, sprite: THREE.Sprite, texture: THREE.FramebufferTexture;
 
-let cameraOrtho, sceneOrtho;
+let cameraOrtho: THREE.OrthographicCamera, sceneOrtho: THREE.Scene;
 
 let offset = 0;
 
@@ -76,7 +76,7 @@ function init() {
 
     //
 
-    const selection = document.getElementById("selection");
+    const selection = document.getElementById("selection")!;
     const controls = new OrbitControls(camera, selection);
     controls.enablePan = false;
 
@@ -126,8 +126,8 @@ function animate() {
 
     // calculate start position for copying data
 
-    vector.x = (window.innerWidth * dpr / 2) - (textureSize / 2);
-    vector.y = (window.innerHeight * dpr / 2) - (textureSize / 2);
+    vector.x = (window.innerWidth * dpr) / 2 - textureSize / 2;
+    vector.y = (window.innerHeight * dpr) / 2 - textureSize / 2;
 
     renderer.copyFramebufferToTexture(vector, texture);
 
@@ -135,7 +135,7 @@ function animate() {
     renderer.render(sceneOrtho, cameraOrtho);
 }
 
-function updateColors(colorAttribute) {
+function updateColors(colorAttribute: THREE.BufferAttribute | THREE.InterleavedBufferAttribute) {
     const l = colorAttribute.count;
 
     for (let i = 0; i < l; i++) {
diff --git a/examples-testing/examples/webgl_furnace_test.ts b/examples-testing/examples/webgl_furnace_test.ts
index 5268423..2976779 100644
--- a/examples-testing/examples/webgl_furnace_test.ts
+++ b/examples-testing/examples/webgl_furnace_test.ts
@@ -1,6 +1,6 @@
 import * as THREE from "three";
 
-let scene, camera, renderer, radianceMap;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, radianceMap: THREE.Texture;
 
 const COLOR = 0xcccccc;
 
@@ -18,17 +18,21 @@ function init() {
 
     window.addEventListener("resize", onWindowResize);
 
-    document.body.addEventListener("mouseover", function () {
-        scene.traverse(function (child) {
-            if (child.isMesh) child.material.color.setHex(0xffffff);
+    document.body.addEventListener("mouseover", function() {
+        scene.traverse(function(child) {
+            if ((child as THREE.Mesh).isMesh) {
+                ((child as THREE.Mesh).material as THREE.MeshStandardMaterial).color.setHex(0xffffff);
+            }
         });
 
         render();
     });
 
-    document.body.addEventListener("mouseout", function () {
-        scene.traverse(function (child) {
-            if (child.isMesh) child.material.color.setHex(0xccccff); // tinted for visibility
+    document.body.addEventListener("mouseout", function() {
+        scene.traverse(function(child) {
+            if ((child as THREE.Mesh).isMesh) {
+                ((child as THREE.Mesh).material as THREE.MeshStandardMaterial).color.setHex(0xccccff); // tinted for visibility
+            }
         });
 
         render();
@@ -93,8 +97,4 @@ function render() {
     renderer.render(scene, camera);
 }
 
-Promise.resolve()
-    .then(init)
-    .then(createEnvironment)
-    .then(createObjects)
-    .then(render);
+Promise.resolve().then(init).then(createEnvironment).then(createObjects).then(render);
diff --git a/examples-testing/examples/webgl_geometries.ts b/examples-testing/examples/webgl_geometries.ts
index 9d7bcdd..b692679 100644
--- a/examples-testing/examples/webgl_geometries.ts
+++ b/examples-testing/examples/webgl_geometries.ts
@@ -2,7 +2,7 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 animate();
@@ -128,8 +128,8 @@ function render() {
 
     camera.lookAt(scene.position);
 
-    scene.traverse(function (object) {
-        if (object.isMesh === true) {
+    scene.traverse(function(object) {
+        if ((object as THREE.Mesh).isMesh === true) {
             object.rotation.x = timer * 5;
             object.rotation.y = timer * 2.5;
         }
diff --git a/examples-testing/examples/webgl_geometries_parametric.ts b/examples-testing/examples/webgl_geometries_parametric.ts
index efcce33..6a63080 100644
--- a/examples-testing/examples/webgl_geometries_parametric.ts
+++ b/examples-testing/examples/webgl_geometries_parametric.ts
@@ -3,16 +3,16 @@ import * as THREE from "three";
 import Stats from "three/addons/libs/stats.module.js";
 
 import * as Curves from "three/addons/curves/CurveExtras.js";
-import { ParametricGeometry } from "three/addons/geometries/ParametricGeometry.js";
 import { ParametricGeometries } from "three/addons/geometries/ParametricGeometries.js";
+import { ParametricGeometry } from "three/addons/geometries/ParametricGeometry.js";
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
     camera.position.y = 400;
@@ -115,8 +115,8 @@ function render() {
 
     camera.lookAt(scene.position);
 
-    scene.traverse(function (object) {
-        if (object.isMesh === true) {
+    scene.traverse(function(object) {
+        if ((object as THREE.Mesh).isMesh === true) {
             object.rotation.x = timer * 5;
             object.rotation.y = timer * 2.5;
         }
diff --git a/examples-testing/examples/webgl_geometry_colors.ts b/examples-testing/examples/webgl_geometry_colors.ts
index 65c868a..5c9ea54 100644
--- a/examples-testing/examples/webgl_geometry_colors.ts
+++ b/examples-testing/examples/webgl_geometry_colors.ts
@@ -2,11 +2,12 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mouseX = 0, mouseY = 0;
+let mouseX = 0,
+    mouseY = 0;
 
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
@@ -15,7 +16,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 1800;
@@ -33,7 +34,7 @@ function init() {
     canvas.width = 128;
     canvas.height = 128;
 
-    const context = canvas.getContext("2d");
+    const context = canvas.getContext("2d")!;
     const gradient = context.createRadialGradient(
         canvas.width / 2,
         canvas.height / 2,
@@ -153,7 +154,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgl_geometry_colors_lookuptable.ts b/examples-testing/examples/webgl_geometry_colors_lookuptable.ts
index c4ad3b2..ddd7cce 100644
--- a/examples-testing/examples/webgl_geometry_colors_lookuptable.ts
+++ b/examples-testing/examples/webgl_geometry_colors_lookuptable.ts
@@ -5,19 +5,19 @@ import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { Lut } from "three/addons/math/Lut.js";
 
-let container;
+let container: HTMLElement;
 
-let perpCamera, orthoCamera, renderer, lut;
+let perpCamera: THREE.PerspectiveCamera, orthoCamera: THREE.OrthographicCamera, renderer: THREE.WebGLRenderer, lut: Lut;
 
-let mesh, sprite;
-let scene, uiScene;
+let mesh: THREE.Mesh, sprite: THREE.Sprite;
+let scene: THREE.Scene, uiScene: THREE.Scene;
 
-let params;
+let params: { colorMap: string };
 
 init();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     scene = new THREE.Scene();
     scene.background = new THREE.Color(0xffffff);
@@ -41,7 +41,7 @@ function init() {
             map: new THREE.CanvasTexture(lut.createCanvas()),
         }),
     );
-    sprite.material.map.colorSpace = THREE.SRGBColorSpace;
+    sprite.material.map!.colorSpace = THREE.SRGBColorSpace;
     sprite.scale.x = 0.125;
     uiScene.add(sprite);
 
@@ -49,7 +49,7 @@ function init() {
         undefined,
         new THREE.MeshLambertMaterial({
             side: THREE.DoubleSide,
-            color: 0xF5F5F5,
+            color: 0xf5f5f5,
             vertexColors: true,
         }),
     );
@@ -76,7 +76,7 @@ function init() {
 
     const gui = new GUI();
 
-    gui.add(params, "colorMap", ["rainbow", "cooltowarm", "blackbody", "grayscale"]).onChange(function () {
+    gui.add(params, "colorMap", ["rainbow", "cooltowarm", "blackbody", "grayscale"]).onChange(function() {
         updateColors();
         render();
     });
@@ -101,7 +101,7 @@ function render() {
 
 function loadModel() {
     const loader = new THREE.BufferGeometryLoader();
-    loader.load("models/json/pressure.json", function (geometry) {
+    loader.load("models/json/pressure.json", function(geometry) {
         geometry.center();
         geometry.computeVertexNormals();
 
@@ -142,7 +142,7 @@ function updateColors() {
 
     colors.needsUpdate = true;
 
-    const map = sprite.material.map;
+    const map = sprite.material.map!;
     lut.updateCanvas(map.image);
     map.needsUpdate = true;
 }
diff --git a/examples-testing/examples/webgl_geometry_convex.ts b/examples-testing/examples/webgl_geometry_convex.ts
index 93113eb..5c9d370 100644
--- a/examples-testing/examples/webgl_geometry_convex.ts
+++ b/examples-testing/examples/webgl_geometry_convex.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { ConvexGeometry } from "three/addons/geometries/ConvexGeometry.js";
 import * as BufferGeometryUtils from "three/addons/utils/BufferGeometryUtils.js";
 
-let group, camera, scene, renderer;
+let group: THREE.Group, camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -54,7 +54,7 @@ function init() {
 
     // points
 
-    let dodecahedronGeometry = new THREE.DodecahedronGeometry(10);
+    let dodecahedronGeometry: THREE.BufferGeometry = new THREE.DodecahedronGeometry(10);
 
     // if normal and uv attributes are not removed, mergeVertices() can't consolidate indentical vertices with different normal/uv data
 
diff --git a/examples-testing/examples/webgl_geometry_cube.ts b/examples-testing/examples/webgl_geometry_cube.ts
index d9d7b1a..04b8bd4 100644
--- a/examples-testing/examples/webgl_geometry_cube.ts
+++ b/examples-testing/examples/webgl_geometry_cube.ts
@@ -1,7 +1,7 @@
 import * as THREE from "three";
 
-let camera, scene, renderer;
-let mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mesh: THREE.Mesh;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_geometry_dynamic.ts b/examples-testing/examples/webgl_geometry_dynamic.ts
index 96042c5..4fe25e8 100644
--- a/examples-testing/examples/webgl_geometry_dynamic.ts
+++ b/examples-testing/examples/webgl_geometry_dynamic.ts
@@ -4,11 +4,16 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { FirstPersonControls } from "three/addons/controls/FirstPersonControls.js";
 
-let camera, controls, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera,
+    controls: FirstPersonControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats;
 
-let mesh, geometry, material, clock;
+let mesh: THREE.Mesh, geometry: THREE.PlaneGeometry, material: THREE.MeshBasicMaterial, clock: THREE.Clock;
 
-const worldWidth = 128, worldDepth = 128;
+const worldWidth = 128,
+    worldDepth = 128;
 
 init();
 animate();
@@ -26,7 +31,7 @@ function init() {
     geometry = new THREE.PlaneGeometry(20000, 20000, worldWidth - 1, worldDepth - 1);
     geometry.rotateX(-Math.PI / 2);
 
-    const position = geometry.attributes.position;
+    const position = geometry.attributes.position as THREE.BufferAttribute;
     position.usage = THREE.DynamicDrawUsage;
 
     for (let i = 0; i < position.count; i++) {
diff --git a/examples-testing/examples/webgl_geometry_extrude_shapes.ts b/examples-testing/examples/webgl_geometry_extrude_shapes.ts
index f0e192d..900b881 100644
--- a/examples-testing/examples/webgl_geometry_extrude_shapes.ts
+++ b/examples-testing/examples/webgl_geometry_extrude_shapes.ts
@@ -2,7 +2,7 @@ import * as THREE from "three";
 
 import { TrackballControls } from "three/addons/controls/TrackballControls.js";
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: TrackballControls;
 
 init();
 animate();
@@ -14,9 +14,9 @@ function init() {
     info.style.width = "100%";
     info.style.textAlign = "center";
     info.style.color = "#fff";
-    info.style.link = "#f80";
+    (info.style as any).link = "#f80";
     info.innerHTML =
-        '<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - geometry extrude shapes';
+        "<a href=\"https://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a> webgl - geometry extrude shapes";
     document.body.appendChild(info);
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -59,12 +59,13 @@ function init() {
         extrudePath: closedSpline,
     };
 
-    const pts1 = [], count = 3;
+    const pts1 = [],
+        count = 3;
 
     for (let i = 0; i < count; i++) {
         const l = 20;
 
-        const a = 2 * i / count * Math.PI;
+        const a = ((2 * i) / count) * Math.PI;
 
         pts1.push(new THREE.Vector2(Math.cos(a) * l, Math.sin(a) * l));
     }
@@ -99,12 +100,13 @@ function init() {
         extrudePath: randomSpline,
     };
 
-    const pts2 = [], numPts = 5;
+    const pts2 = [],
+        numPts = 5;
 
     for (let i = 0; i < numPts * 2; i++) {
         const l = i % 2 == 1 ? 10 : 20;
 
-        const a = i / numPts * Math.PI;
+        const a = (i / numPts) * Math.PI;
 
         pts2.push(new THREE.Vector2(Math.cos(a) * l, Math.sin(a) * l));
     }
diff --git a/examples-testing/examples/webgl_geometry_extrude_splines.ts b/examples-testing/examples/webgl_geometry_extrude_splines.ts
index 7873aa0..cab24ec 100644
--- a/examples-testing/examples/webgl_geometry_extrude_splines.ts
+++ b/examples-testing/examples/webgl_geometry_extrude_splines.ts
@@ -1,14 +1,19 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
-import * as Curves from "three/addons/curves/CurveExtras.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import * as Curves from "three/addons/curves/CurveExtras.js";
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer, splineCamera, cameraHelper, cameraEye;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    splineCamera: THREE.PerspectiveCamera,
+    cameraHelper: THREE.CameraHelper,
+    cameraEye: THREE.Mesh;
 
 const direction = new THREE.Vector3();
 const binormal = new THREE.Vector3();
@@ -78,9 +83,18 @@ const splines = {
     SampleClosedSpline: sampleClosedSpline,
 };
 
-let parent, tubeGeometry, mesh;
-
-const params = {
+let parent: THREE.Object3D, tubeGeometry: THREE.TubeGeometry, mesh: THREE.Mesh;
+
+const params: {
+    spline: keyof typeof splines;
+    scale: number;
+    extrusionSegments: number;
+    radiusSegments: number;
+    closed: boolean;
+    animationView: boolean;
+    lookAhead: boolean;
+    cameraHelper: boolean;
+} = {
     spline: "GrannyKnot",
     scale: 4,
     extrusionSegments: 100,
@@ -125,7 +139,7 @@ function setScale() {
     mesh.scale.set(params.scale, params.scale, params.scale);
 }
 
-function addGeometry(geometry) {
+function addGeometry(geometry: THREE.BufferGeometry) {
     // 3D shape
 
     mesh = new THREE.Mesh(geometry, material);
@@ -144,7 +158,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     // camera
 
@@ -202,31 +216,40 @@ function init() {
     const gui = new GUI({ width: 285 });
 
     const folderGeometry = gui.addFolder("Geometry");
-    folderGeometry.add(params, "spline", Object.keys(splines)).onChange(function () {
-        addTube();
-    });
-    folderGeometry.add(params, "scale", 2, 10).step(2).onChange(function () {
-        setScale();
-    });
-    folderGeometry.add(params, "extrusionSegments", 50, 500).step(50).onChange(function () {
-        addTube();
-    });
-    folderGeometry.add(params, "radiusSegments", 2, 12).step(1).onChange(function () {
+    folderGeometry.add(params, "spline", Object.keys(splines) as (keyof typeof splines)[]).onChange(function() {
         addTube();
     });
-    folderGeometry.add(params, "closed").onChange(function () {
+    folderGeometry
+        .add(params, "scale", 2, 10)
+        .step(2)
+        .onChange(function() {
+            setScale();
+        });
+    folderGeometry
+        .add(params, "extrusionSegments", 50, 500)
+        .step(50)
+        .onChange(function() {
+            addTube();
+        });
+    folderGeometry
+        .add(params, "radiusSegments", 2, 12)
+        .step(1)
+        .onChange(function() {
+            addTube();
+        });
+    folderGeometry.add(params, "closed").onChange(function() {
         addTube();
     });
     folderGeometry.open();
 
     const folderCamera = gui.addFolder("Camera");
-    folderCamera.add(params, "animationView").onChange(function () {
+    folderCamera.add(params, "animationView").onChange(function() {
         animateCamera();
     });
-    folderCamera.add(params, "lookAhead").onChange(function () {
+    folderCamera.add(params, "lookAhead").onChange(function() {
         animateCamera();
     });
-    folderCamera.add(params, "cameraHelper").onChange(function () {
+    folderCamera.add(params, "cameraHelper").onChange(function() {
         animateCamera();
     });
     folderCamera.open();
diff --git a/examples-testing/examples/webgl_geometry_minecraft.ts b/examples-testing/examples/webgl_geometry_minecraft.ts
index 73a4da2..d677208 100644
--- a/examples-testing/examples/webgl_geometry_minecraft.ts
+++ b/examples-testing/examples/webgl_geometry_minecraft.ts
@@ -6,11 +6,12 @@ import { FirstPersonControls } from "three/addons/controls/FirstPersonControls.j
 import { ImprovedNoise } from "three/addons/math/ImprovedNoise.js";
 import * as BufferGeometryUtils from "three/addons/utils/BufferGeometryUtils.js";
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: FirstPersonControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-const worldWidth = 128, worldDepth = 128;
+const worldWidth = 128,
+    worldDepth = 128;
 const worldHalfWidth = worldWidth / 2;
 const worldHalfDepth = worldDepth / 2;
 const data = generateHeight(worldWidth, worldDepth);
@@ -21,7 +22,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);
     camera.position.y = getY(worldHalfWidth, worldHalfDepth) * 100 + 100;
@@ -70,11 +71,7 @@ function init() {
         for (let x = 0; x < worldWidth; x++) {
             const h = getY(x, z);
 
-            matrix.makeTranslation(
-                x * 100 - worldHalfWidth * 100,
-                h * 100,
-                z * 100 - worldHalfDepth * 100,
-            );
+            matrix.makeTranslation(x * 100 - worldHalfWidth * 100, h * 100, z * 100 - worldHalfDepth * 100);
 
             const px = getY(x + 1, z);
             const nx = getY(x - 1, z);
@@ -146,8 +143,11 @@ function onWindowResize() {
     controls.handleResize();
 }
 
-function generateHeight(width, height) {
-    const data = [], perlin = new ImprovedNoise(), size = width * height, z = Math.random() * 100;
+function generateHeight(width: number, height: number) {
+    const data = [],
+        perlin = new ImprovedNoise(),
+        size = width * height,
+        z = Math.random() * 100;
 
     let quality = 2;
 
@@ -155,7 +155,8 @@ function generateHeight(width, height) {
         if (j === 0) for (let i = 0; i < size; i++) data[i] = 0;
 
         for (let i = 0; i < size; i++) {
-            const x = i % width, y = (i / width) | 0;
+            const x = i % width,
+                y = (i / width) | 0;
             data[i] += perlin.noise(x / quality, y / quality, z) * quality;
         }
 
@@ -165,7 +166,7 @@ function generateHeight(width, height) {
     return data;
 }
 
-function getY(x, z) {
+function getY(x: number, z: number) {
     return (data[x + z * worldWidth] * 0.15) | 0;
 }
 
diff --git a/examples-testing/examples/webgl_geometry_nurbs.ts b/examples-testing/examples/webgl_geometry_nurbs.ts
index e050d4c..4f5f9fe 100644
--- a/examples-testing/examples/webgl_geometry_nurbs.ts
+++ b/examples-testing/examples/webgl_geometry_nurbs.ts
@@ -7,10 +7,10 @@ import { NURBSSurface } from "three/addons/curves/NURBSSurface.js";
 import { NURBSVolume } from "three/addons/curves/NURBSVolume.js";
 import { ParametricGeometry } from "three/addons/geometries/ParametricGeometry.js";
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
-let group;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let group: THREE.Group;
 
 let targetRotation = 0;
 let targetRotationOnPointerDown = 0;
@@ -79,7 +79,7 @@ function init() {
     group.add(nurbsLine);
 
     const nurbsControlPointsGeometry = new THREE.BufferGeometry();
-    nurbsControlPointsGeometry.setFromPoints(nurbsCurve.controlPoints);
+    nurbsControlPointsGeometry.setFromPoints(nurbsCurve.controlPoints as THREE.Vector3[]);
 
     const nurbsControlPointsMaterial = new THREE.LineBasicMaterial({
         color: 0x333333,
@@ -124,7 +124,7 @@ function init() {
         map.anisotropy = 16;
         map.colorSpace = THREE.SRGBColorSpace;
 
-        function getSurfacePoint(u, v, target) {
+        function getSurfacePoint(u: number, v: number, target: THREE.Vector3) {
             return nurbsSurface.getPoint(u, v, target);
         }
 
@@ -140,58 +140,22 @@ function init() {
     {
         const nsControlPoints = [
             [
-                [
-                    new THREE.Vector4(-200, -200, -200, 1),
-                    new THREE.Vector4(-200, -200, 200, 1),
-                ],
-                [
-                    new THREE.Vector4(-200, -100, -200, 1),
-                    new THREE.Vector4(-200, -100, 200, 1),
-                ],
-                [
-                    new THREE.Vector4(-200, 100, -200, 1),
-                    new THREE.Vector4(-200, 100, 200, 1),
-                ],
-                [
-                    new THREE.Vector4(-200, 200, -200, 1),
-                    new THREE.Vector4(-200, 200, 200, 1),
-                ],
+                [new THREE.Vector4(-200, -200, -200, 1), new THREE.Vector4(-200, -200, 200, 1)],
+                [new THREE.Vector4(-200, -100, -200, 1), new THREE.Vector4(-200, -100, 200, 1)],
+                [new THREE.Vector4(-200, 100, -200, 1), new THREE.Vector4(-200, 100, 200, 1)],
+                [new THREE.Vector4(-200, 200, -200, 1), new THREE.Vector4(-200, 200, 200, 1)],
             ],
             [
-                [
-                    new THREE.Vector4(0, -200, -200, 1),
-                    new THREE.Vector4(0, -200, 200, 1),
-                ],
-                [
-                    new THREE.Vector4(0, -100, -200, 1),
-                    new THREE.Vector4(0, -100, 200, 1),
-                ],
-                [
-                    new THREE.Vector4(0, 100, -200, 1),
-                    new THREE.Vector4(0, 100, 200, 1),
-                ],
-                [
-                    new THREE.Vector4(0, 200, -200, 1),
-                    new THREE.Vector4(0, 200, 200, 1),
-                ],
+                [new THREE.Vector4(0, -200, -200, 1), new THREE.Vector4(0, -200, 200, 1)],
+                [new THREE.Vector4(0, -100, -200, 1), new THREE.Vector4(0, -100, 200, 1)],
+                [new THREE.Vector4(0, 100, -200, 1), new THREE.Vector4(0, 100, 200, 1)],
+                [new THREE.Vector4(0, 200, -200, 1), new THREE.Vector4(0, 200, 200, 1)],
             ],
             [
-                [
-                    new THREE.Vector4(200, -200, -200, 1),
-                    new THREE.Vector4(200, -200, 200, 1),
-                ],
-                [
-                    new THREE.Vector4(200, -100, 0, 1),
-                    new THREE.Vector4(200, -100, 100, 1),
-                ],
-                [
-                    new THREE.Vector4(200, 100, 0, 1),
-                    new THREE.Vector4(200, 100, 100, 1),
-                ],
-                [
-                    new THREE.Vector4(200, 200, 0, 1),
-                    new THREE.Vector4(200, 200, 100, 1),
-                ],
+                [new THREE.Vector4(200, -200, -200, 1), new THREE.Vector4(200, -200, 200, 1)],
+                [new THREE.Vector4(200, -100, 0, 1), new THREE.Vector4(200, -100, 100, 1)],
+                [new THREE.Vector4(200, 100, 0, 1), new THREE.Vector4(200, 100, 100, 1)],
+                [new THREE.Vector4(200, 200, 0, 1), new THREE.Vector4(200, 200, 100, 1)],
             ],
         ];
         const degree1 = 2;
@@ -211,23 +175,23 @@ function init() {
         // we create evaluation functions for different surfaces with one of the three
         // parameter values (u, v, w) kept constant and create multiple THREE.Mesh
         // objects one for each surface
-        function getSurfacePointFront(u, v, target) {
+        function getSurfacePointFront(u: number, v: number, target: THREE.Vector3) {
             return nurbsVolume.getPoint(u, v, 0, target);
         }
 
-        function getSurfacePointMiddle(u, v, target) {
+        function getSurfacePointMiddle(u: number, v: number, target: THREE.Vector3) {
             return nurbsVolume.getPoint(u, v, 0.5, target);
         }
 
-        function getSurfacePointBack(u, v, target) {
+        function getSurfacePointBack(u: number, v: number, target: THREE.Vector3) {
             return nurbsVolume.getPoint(u, v, 1, target);
         }
 
-        function getSurfacePointTop(u, w, target) {
+        function getSurfacePointTop(u: number, w: number, target: THREE.Vector3) {
             return nurbsVolume.getPoint(u, 1, w, target);
         }
 
-        function getSurfacePointSide(v, w, target) {
+        function getSurfacePointSide(v: number, w: number, target: THREE.Vector3) {
             return nurbsVolume.getPoint(0, v, w, target);
         }
 
@@ -296,7 +260,7 @@ function onWindowResize() {
 
 //
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerXOnPointerDown = event.clientX - windowHalfX;
@@ -306,7 +270,7 @@ function onPointerDown(event) {
     document.addEventListener("pointerup", onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerX = event.clientX - windowHalfX;
@@ -314,7 +278,7 @@ function onPointerMove(event) {
     targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
 }
 
-function onPointerUp() {
+function onPointerUp(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     document.removeEventListener("pointermove", onPointerMove);
diff --git a/examples-testing/examples/webgl_geometry_sdf.ts b/examples-testing/examples/webgl_geometry_sdf.ts
index 9e91826..2b5b031 100644
--- a/examples-testing/examples/webgl_geometry_sdf.ts
+++ b/examples-testing/examples/webgl_geometry_sdf.ts
@@ -1,10 +1,19 @@
 import * as THREE from "three";
-import { OrbitControls } from "./jsm/controls/OrbitControls.js";
+import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { SDFGeometryGenerator } from "three/addons/geometries/SDFGeometryGenerator.js";
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
-let renderer, stats, meshFromSDF, scene, camera, clock, controls;
+let renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    meshFromSDF: THREE.Mesh<
+        THREE.BufferGeometry,
+        THREE.MeshBasicMaterial | THREE.MeshDepthMaterial | THREE.MeshNormalMaterial
+    >,
+    scene: THREE.Scene,
+    camera: THREE.OrthographicCamera,
+    clock: THREE.Clock,
+    controls: OrbitControls;
 
 const settings = {
     res: 4,
@@ -12,7 +21,7 @@ const settings = {
     autoRotate: true,
     wireframe: true,
     material: "depth",
-    vertexCount: "0",
+    vertexCount: 0,
 };
 
 // Example SDF from https://www.shadertoy.com/view/MdXSWn -->
@@ -101,14 +110,18 @@ function compile() {
     const geometry = generator.generate(Math.pow(2, settings.res + 2), shader, settings.bounds);
     geometry.computeVertexNormals();
 
-    if (meshFromSDF) { // updates mesh
+    if (meshFromSDF) {
+        // updates mesh
+
         meshFromSDF.geometry.dispose();
         meshFromSDF.geometry = geometry;
-    } else { // inits meshFromSDF : THREE.Mesh
+    } else {
+        // inits meshFromSDF : THREE.Mesh
+
         meshFromSDF = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial());
         scene.add(meshFromSDF);
 
-        const scale = Math.min(window.innerWidth, window.innerHeight) / 2 * 0.66;
+        const scale = (Math.min(window.innerWidth, window.innerHeight) / 2) * 0.66;
         meshFromSDF.scale.set(scale, scale, scale);
 
         setMaterial();
diff --git a/examples-testing/examples/webgl_geometry_shapes.ts b/examples-testing/examples/webgl_geometry_shapes.ts
index 44df487..d8d9458 100644
--- a/examples-testing/examples/webgl_geometry_shapes.ts
+++ b/examples-testing/examples/webgl_geometry_shapes.ts
@@ -2,11 +2,11 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let group;
+let group: THREE.Group;
 
 let targetRotation = 0;
 let targetRotationOnPointerDown = 0;
@@ -46,11 +46,22 @@ function init() {
     texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
     texture.repeat.set(0.008, 0.008);
 
-    function addShape(shape, extrudeSettings, color, x, y, z, rx, ry, rz, s) {
+    function addShape(
+        shape: THREE.Shape,
+        extrudeSettings: THREE.ExtrudeGeometryOptions,
+        color: number,
+        x: number,
+        y: number,
+        z: number,
+        rx: number,
+        ry: number,
+        rz: number,
+        s: number,
+    ) {
         // flat shape with texture
         // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices
 
-        let geometry = new THREE.ShapeGeometry(shape);
+        let geometry: THREE.BufferGeometry = new THREE.ShapeGeometry(shape);
 
         let mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ side: THREE.DoubleSide, map: texture }));
         mesh.position.set(x, y, z - 175);
@@ -81,7 +92,17 @@ function init() {
         addLineShape(shape, color, x, y, z, rx, ry, rz, s);
     }
 
-    function addLineShape(shape, color, x, y, z, rx, ry, rz, s) {
+    function addLineShape(
+        shape: THREE.Path,
+        color: number,
+        x: number,
+        y: number,
+        z: number,
+        rx: number,
+        ry: number,
+        rz: number,
+        s: number,
+    ) {
         // lines
 
         shape.autoClose = true;
@@ -158,15 +179,12 @@ function init() {
 
     // Triangle
 
-    const triangleShape = new THREE.Shape()
-        .moveTo(80, 20)
-        .lineTo(40, 80)
-        .lineTo(120, 80)
-        .lineTo(80, 20); // close path
+    const triangleShape = new THREE.Shape().moveTo(80, 20).lineTo(40, 80).lineTo(120, 80).lineTo(80, 20); // close path
 
     // Heart
 
-    const x = 0, y = 0;
+    const x = 0,
+        y = 0;
 
     const heartShape = new THREE.Shape()
         .moveTo(x + 25, y + 25)
@@ -235,29 +253,19 @@ function init() {
 
     // Arc circle
 
-    const arcShape = new THREE.Shape()
-        .moveTo(50, 10)
-        .absarc(10, 10, 40, 0, Math.PI * 2, false);
+    const arcShape = new THREE.Shape().moveTo(50, 10).absarc(10, 10, 40, 0, Math.PI * 2, false);
 
-    const holePath = new THREE.Path()
-        .moveTo(20, 10)
-        .absarc(10, 10, 10, 0, Math.PI * 2, true);
+    const holePath = new THREE.Path().moveTo(20, 10).absarc(10, 10, 10, 0, Math.PI * 2, true);
 
     arcShape.holes.push(holePath);
 
     // Smiley
 
-    const smileyShape = new THREE.Shape()
-        .moveTo(80, 40)
-        .absarc(40, 40, 40, 0, Math.PI * 2, false);
+    const smileyShape = new THREE.Shape().moveTo(80, 40).absarc(40, 40, 40, 0, Math.PI * 2, false);
 
-    const smileyEye1Path = new THREE.Path()
-        .moveTo(35, 20)
-        .absellipse(25, 20, 10, 10, 0, Math.PI * 2, true);
+    const smileyEye1Path = new THREE.Path().moveTo(35, 20).absellipse(25, 20, 10, 10, 0, Math.PI * 2, true);
 
-    const smileyEye2Path = new THREE.Path()
-        .moveTo(65, 20)
-        .absarc(55, 20, 10, 0, Math.PI * 2, true);
+    const smileyEye2Path = new THREE.Path().moveTo(65, 20).absarc(55, 20, 10, 0, Math.PI * 2, true);
 
     const smileyMouthPath = new THREE.Path()
         .moveTo(20, 40)
@@ -278,9 +286,7 @@ function init() {
     splinepts.push(new THREE.Vector2(-30, 70));
     splinepts.push(new THREE.Vector2(0, 0));
 
-    const splineShape = new THREE.Shape()
-        .moveTo(0, 0)
-        .splineThru(splinepts);
+    const splineShape = new THREE.Shape().moveTo(0, 0).splineThru(splinepts);
 
     const extrudeSettings = {
         depth: 8,
@@ -340,7 +346,7 @@ function onWindowResize() {
 
 //
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerXOnPointerDown = event.clientX - windowHalfX;
@@ -350,7 +356,7 @@ function onPointerDown(event) {
     document.addEventListener("pointerup", onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerX = event.clientX - windowHalfX;
@@ -358,7 +364,7 @@ function onPointerMove(event) {
     targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
 }
 
-function onPointerUp() {
+function onPointerUp(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     document.removeEventListener("pointermove", onPointerMove);
diff --git a/examples-testing/examples/webgl_geometry_teapot.ts b/examples-testing/examples/webgl_geometry_teapot.ts
index dfb402f..f52a77c 100644
--- a/examples-testing/examples/webgl_geometry_teapot.ts
+++ b/examples-testing/examples/webgl_geometry_teapot.ts
@@ -5,22 +5,30 @@ import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { TeapotGeometry } from "three/addons/geometries/TeapotGeometry.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 let cameraControls;
-let effectController;
+let effectController: {
+    newTess: number;
+    bottom: boolean;
+    lid: boolean;
+    body: boolean;
+    fitLid: boolean;
+    nonblinn: boolean;
+    newShading: string;
+};
 const teapotSize = 300;
-let ambientLight, light;
+let ambientLight: THREE.AmbientLight, light: THREE.DirectionalLight;
 
 let tess = -1; // force initialization
-let bBottom;
-let bLid;
-let bBody;
-let bFitLid;
-let bNonBlinn;
-let shading;
+let bBottom: boolean;
+let bLid: boolean;
+let bBody: boolean;
+let bFitLid: boolean;
+let bNonBlinn: boolean;
+let shading: string;
 
-let teapot, textureCube;
-const materials = {};
+let teapot: THREE.Mesh, textureCube: THREE.CubeTexture;
+const materials: Record<string, THREE.Material> = {};
 
 init();
 render();
@@ -39,7 +47,7 @@ function init() {
     // LIGHTS
     ambientLight = new THREE.AmbientLight(0x7c7c7c, 3.0);
 
-    light = new THREE.DirectionalLight(0xFFFFFF, 3.0);
+    light = new THREE.DirectionalLight(0xffffff, 3.0);
     light.position.set(0.32, 0.39, 0.7);
 
     // RENDERER
@@ -76,7 +84,7 @@ function init() {
 
     // scene itself
     scene = new THREE.Scene();
-    scene.background = new THREE.Color(0xAAAAAA);
+    scene.background = new THREE.Color(0xaaaaaa);
 
     scene.add(ambientLight);
     scene.add(light);
@@ -111,29 +119,30 @@ function setupGui() {
     };
 
     const gui = new GUI();
-    gui.add(effectController, "newTess", [2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50]).name("Tessellation Level")
+    gui.add(effectController, "newTess", [2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 40, 50])
+        .name("Tessellation Level")
         .onChange(render);
     gui.add(effectController, "lid").name("display lid").onChange(render);
     gui.add(effectController, "body").name("display body").onChange(render);
     gui.add(effectController, "bottom").name("display bottom").onChange(render);
     gui.add(effectController, "fitLid").name("snug lid").onChange(render);
     gui.add(effectController, "nonblinn").name("original scale").onChange(render);
-    gui.add(effectController, "newShading", ["wireframe", "flat", "smooth", "glossy", "textured", "reflective"]).name(
-        "Shading",
-    ).onChange(render);
+    gui.add(effectController, "newShading", ["wireframe", "flat", "smooth", "glossy", "textured", "reflective"])
+        .name("Shading")
+        .onChange(render);
 }
 
 //
 
 function render() {
     if (
-        effectController.newTess !== tess ||
-        effectController.bottom !== bBottom ||
-        effectController.lid !== bLid ||
-        effectController.body !== bBody ||
-        effectController.fitLid !== bFitLid ||
-        effectController.nonblinn !== bNonBlinn ||
-        effectController.newShading !== shading
+        effectController.newTess !== tess
+        || effectController.bottom !== bBottom
+        || effectController.lid !== bLid
+        || effectController.body !== bBody
+        || effectController.fitLid !== bFitLid
+        || effectController.nonblinn !== bNonBlinn
+        || effectController.newShading !== shading
     ) {
         tess = effectController.newTess;
         bBottom = effectController.bottom;
diff --git a/examples-testing/examples/webgl_geometry_terrain.ts b/examples-testing/examples/webgl_geometry_terrain.ts
index 68bf8c8..b25949c 100644
--- a/examples-testing/examples/webgl_geometry_terrain.ts
+++ b/examples-testing/examples/webgl_geometry_terrain.ts
@@ -5,18 +5,19 @@ import Stats from "three/addons/libs/stats.module.js";
 import { FirstPersonControls } from "three/addons/controls/FirstPersonControls.js";
 import { ImprovedNoise } from "three/addons/math/ImprovedNoise.js";
 
-let container, stats;
-let camera, controls, scene, renderer;
-let mesh, texture;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, controls: FirstPersonControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mesh: THREE.Mesh, texture: THREE.CanvasTexture;
 
-const worldWidth = 256, worldDepth = 256;
+const worldWidth = 256,
+    worldDepth = 256;
 const clock = new THREE.Clock();
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
 
@@ -72,21 +73,24 @@ function onWindowResize() {
     controls.handleResize();
 }
 
-function generateHeight(width, height) {
+function generateHeight(width: number, height: number) {
     let seed = Math.PI / 4;
-    window.Math.random = function () {
+    window.Math.random = function() {
         const x = Math.sin(seed++) * 10000;
         return x - Math.floor(x);
     };
 
-    const size = width * height, data = new Uint8Array(size);
-    const perlin = new ImprovedNoise(), z = Math.random() * 100;
+    const size = width * height,
+        data = new Uint8Array(size);
+    const perlin = new ImprovedNoise(),
+        z = Math.random() * 100;
 
     let quality = 1;
 
     for (let j = 0; j < 4; j++) {
         for (let i = 0; i < size; i++) {
-            const x = i % width, y = ~~(i / width);
+            const x = i % width,
+                y = ~~(i / width);
             data[i] += Math.abs(perlin.noise(x / quality, y / quality, z) * quality * 1.75);
         }
 
@@ -96,7 +100,7 @@ function generateHeight(width, height) {
     return data;
 }
 
-function generateTexture(data, width, height) {
+function generateTexture(data: Uint8Array, width: number, height: number) {
     let context, image, imageData, shade;
 
     const vector3 = new THREE.Vector3(0, 0, 0);
@@ -108,7 +112,7 @@ function generateTexture(data, width, height) {
     canvas.width = width;
     canvas.height = height;
 
-    context = canvas.getContext("2d");
+    context = canvas.getContext("2d")!;
     context.fillStyle = "#000";
     context.fillRect(0, 0, width, height);
 
@@ -125,7 +129,7 @@ function generateTexture(data, width, height) {
 
         imageData[i] = (96 + shade * 128) * (0.5 + data[j] * 0.007);
         imageData[i + 1] = (32 + shade * 96) * (0.5 + data[j] * 0.007);
-        imageData[i + 2] = (shade * 96) * (0.5 + data[j] * 0.007);
+        imageData[i + 2] = shade * 96 * (0.5 + data[j] * 0.007);
     }
 
     context.putImageData(image, 0, 0);
@@ -136,7 +140,7 @@ function generateTexture(data, width, height) {
     canvasScaled.width = width * 4;
     canvasScaled.height = height * 4;
 
-    context = canvasScaled.getContext("2d");
+    context = canvasScaled.getContext("2d")!;
     context.scale(4, 4);
     context.drawImage(canvas, 0, 0);
 
diff --git a/examples-testing/examples/webgl_geometry_terrain_raycast.ts b/examples-testing/examples/webgl_geometry_terrain_raycast.ts
index 379bb2f..9aeda26 100644
--- a/examples-testing/examples/webgl_geometry_terrain_raycast.ts
+++ b/examples-testing/examples/webgl_geometry_terrain_raycast.ts
@@ -5,15 +5,18 @@ import Stats from "three/addons/libs/stats.module.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { ImprovedNoise } from "three/addons/math/ImprovedNoise.js";
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh, texture;
+let mesh: THREE.Mesh, texture: THREE.CanvasTexture;
 
-const worldWidth = 256, worldDepth = 256, worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;
+const worldWidth = 256,
+    worldDepth = 256,
+    worldHalfWidth = worldWidth / 2,
+    worldHalfDepth = worldDepth / 2;
 
-let helper;
+let helper: THREE.Mesh;
 
 const raycaster = new THREE.Raycaster();
 const pointer = new THREE.Vector2();
@@ -22,7 +25,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
     container.innerHTML = "";
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -91,14 +94,18 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function generateHeight(width, height) {
-    const size = width * height, data = new Uint8Array(size), perlin = new ImprovedNoise(), z = Math.random() * 100;
+function generateHeight(width: number, height: number) {
+    const size = width * height,
+        data = new Uint8Array(size),
+        perlin = new ImprovedNoise(),
+        z = Math.random() * 100;
 
     let quality = 1;
 
     for (let j = 0; j < 4; j++) {
         for (let i = 0; i < size; i++) {
-            const x = i % width, y = ~~(i / width);
+            const x = i % width,
+                y = ~~(i / width);
             data[i] += Math.abs(perlin.noise(x / quality, y / quality, z) * quality * 1.75);
         }
 
@@ -108,7 +115,7 @@ function generateHeight(width, height) {
     return data;
 }
 
-function generateTexture(data, width, height) {
+function generateTexture(data: Uint8Array, width: number, height: number) {
     // bake lighting into texture
 
     let context, image, imageData, shade;
@@ -122,7 +129,7 @@ function generateTexture(data, width, height) {
     canvas.width = width;
     canvas.height = height;
 
-    context = canvas.getContext("2d");
+    context = canvas.getContext("2d")!;
     context.fillStyle = "#000";
     context.fillRect(0, 0, width, height);
 
@@ -139,7 +146,7 @@ function generateTexture(data, width, height) {
 
         imageData[i] = (96 + shade * 128) * (0.5 + data[j] * 0.007);
         imageData[i + 1] = (32 + shade * 96) * (0.5 + data[j] * 0.007);
-        imageData[i + 2] = (shade * 96) * (0.5 + data[j] * 0.007);
+        imageData[i + 2] = shade * 96 * (0.5 + data[j] * 0.007);
     }
 
     context.putImageData(image, 0, 0);
@@ -150,7 +157,7 @@ function generateTexture(data, width, height) {
     canvasScaled.width = width * 4;
     canvasScaled.height = height * 4;
 
-    context = canvasScaled.getContext("2d");
+    context = canvasScaled.getContext("2d")!;
     context.scale(4, 4);
     context.drawImage(canvas, 0, 0);
 
@@ -183,7 +190,7 @@ function render() {
     renderer.render(scene, camera);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
     pointer.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
     raycaster.setFromCamera(pointer, camera);
@@ -194,7 +201,7 @@ function onPointerMove(event) {
     // Toggle rotation bool for meshes that we clicked
     if (intersects.length > 0) {
         helper.position.set(0, 0, 0);
-        helper.lookAt(intersects[0].face.normal);
+        helper.lookAt(intersects[0].face!.normal);
 
         helper.position.copy(intersects[0].point);
     }
diff --git a/examples-testing/examples/webgl_geometry_text.ts b/examples-testing/examples/webgl_geometry_text.ts
index 2c6ca77..469a432 100644
--- a/examples-testing/examples/webgl_geometry_text.ts
+++ b/examples-testing/examples/webgl_geometry_text.ts
@@ -1,23 +1,23 @@
 import * as THREE from "three";
 
-import { FontLoader } from "three/addons/loaders/FontLoader.js";
 import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
+import { Font, FontLoader } from "three/addons/loaders/FontLoader.js";
 
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
 THREE.Cache.enabled = true;
 
-let container;
+let container: HTMLDivElement;
 
-let camera, cameraTarget, scene, renderer;
+let camera: THREE.PerspectiveCamera, cameraTarget: THREE.Vector3, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let group, textMesh1, textMesh2, textGeo, materials;
+let group: THREE.Group, textMesh1: THREE.Mesh, textMesh2: THREE.Mesh, textGeo, materials: THREE.MeshPhongMaterial[];
 
 let firstLetter = true;
 
 let text = "three.js",
     bevelEnabled = true,
-    font = undefined,
+    font: Font | undefined = undefined,
     fontName = "optimer", // helvetiker, optimer, gentilis, droid sans, droid serif
     fontWeight = "bold"; // normal bold
 
@@ -31,23 +31,23 @@ const height = 20,
 const mirror = true;
 
 const fontMap = {
-    "helvetiker": 0,
-    "optimer": 1,
-    "gentilis": 2,
+    helvetiker: 0,
+    optimer: 1,
+    gentilis: 2,
     "droid/droid_sans": 3,
     "droid/droid_serif": 4,
 };
 
 const weightMap = {
-    "regular": 0,
-    "bold": 1,
+    regular: 0,
+    bold: 1,
 };
 
-const reverseFontMap = [];
-const reverseWeightMap = [];
+const reverseFontMap: string[] = [];
+const reverseWeightMap: string[] = [];
 
-for (const i in fontMap) reverseFontMap[fontMap[i]] = i;
-for (const i in weightMap) reverseWeightMap[weightMap[i]] = i;
+for (const i in fontMap) reverseFontMap[fontMap[i as keyof typeof fontMap]] = i;
+for (const i in weightMap) reverseWeightMap[weightMap[i as keyof typeof weightMap]] = i;
 
 let targetRotation = 0;
 let targetRotationOnPointerDown = 0;
@@ -128,17 +128,17 @@ function init() {
     //
 
     const params = {
-        changeColor: function () {
+        changeColor: function() {
             pointLight.color.setHSL(Math.random(), 1, 0.5);
         },
-        changeFont: function () {
+        changeFont: function() {
             fontIndex++;
 
             fontName = reverseFontMap[fontIndex % reverseFontMap.length];
 
             loadFont();
         },
-        changeWeight: function () {
+        changeWeight: function() {
             if (fontWeight === "bold") {
                 fontWeight = "regular";
             } else {
@@ -147,7 +147,7 @@ function init() {
 
             loadFont();
         },
-        changeBevel: function () {
+        changeBevel: function() {
             bevelEnabled = !bevelEnabled;
 
             refreshText();
@@ -180,7 +180,7 @@ function onWindowResize() {
 
 //
 
-function onDocumentKeyDown(event) {
+function onDocumentKeyDown(event: KeyboardEvent) {
     if (firstLetter) {
         firstLetter = false;
         text = "";
@@ -200,7 +200,7 @@ function onDocumentKeyDown(event) {
     }
 }
 
-function onDocumentKeyPress(event) {
+function onDocumentKeyPress(event: KeyboardEvent) {
     const keyCode = event.which;
 
     // backspace
@@ -217,7 +217,7 @@ function onDocumentKeyPress(event) {
 
 function loadFont() {
     const loader = new FontLoader();
-    loader.load("fonts/" + fontName + "_" + fontWeight + ".typeface.json", function (response) {
+    loader.load("fonts/" + fontName + "_" + fontWeight + ".typeface.json", function(response) {
         font = response;
 
         refreshText();
@@ -226,7 +226,7 @@ function loadFont() {
 
 function createText() {
     textGeo = new TextGeometry(text, {
-        font: font,
+        font: font!,
 
         size: size,
         height: height,
@@ -239,7 +239,7 @@ function createText() {
 
     textGeo.computeBoundingBox();
 
-    const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
+    const centerOffset = -0.5 * (textGeo.boundingBox!.max.x - textGeo.boundingBox!.min.x);
 
     textMesh1 = new THREE.Mesh(textGeo, materials);
 
@@ -275,7 +275,7 @@ function refreshText() {
     createText();
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerXOnPointerDown = event.clientX - windowHalfX;
@@ -285,7 +285,7 @@ function onPointerDown(event) {
     document.addEventListener("pointerup", onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerX = event.clientX - windowHalfX;
@@ -293,7 +293,7 @@ function onPointerMove(event) {
     targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
 }
 
-function onPointerUp() {
+function onPointerUp(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     document.removeEventListener("pointermove", onPointerMove);
diff --git a/examples-testing/examples/webgl_geometry_text_shapes.ts b/examples-testing/examples/webgl_geometry_text_shapes.ts
index 8812f9d..6aa2c3b 100644
--- a/examples-testing/examples/webgl_geometry_text_shapes.ts
+++ b/examples-testing/examples/webgl_geometry_text_shapes.ts
@@ -3,7 +3,7 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { FontLoader } from "three/addons/loaders/FontLoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -15,7 +15,7 @@ function init() {
     scene.background = new THREE.Color(0xf0f0f0);
 
     const loader = new FontLoader();
-    loader.load("fonts/helvetiker_regular.typeface.json", function (font) {
+    loader.load("fonts/helvetiker_regular.typeface.json", function(font) {
         const color = 0x006699;
 
         const matDark = new THREE.LineBasicMaterial({
@@ -32,13 +32,13 @@ function init() {
 
         const message = "   Three.js\nSimple text.";
 
-        const shapes = font.generateShapes(message, 100);
+        const shapes: THREE.Path[] = font.generateShapes(message, 100);
 
-        const geometry = new THREE.ShapeGeometry(shapes);
+        const geometry = new THREE.ShapeGeometry(shapes as THREE.Shape[]);
 
         geometry.computeBoundingBox();
 
-        const xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
+        const xMid = -0.5 * (geometry.boundingBox!.max.x - geometry.boundingBox!.min.x);
 
         geometry.translate(xMid, 0, 0);
 
@@ -50,10 +50,10 @@ function init() {
 
         // make line shape ( N.B. edge view remains visible )
 
-        const holeShapes = [];
+        const holeShapes: THREE.Path[] = [];
 
         for (let i = 0; i < shapes.length; i++) {
-            const shape = shapes[i];
+            const shape = shapes[i] as THREE.Shape;
 
             if (shape.holes && shape.holes.length > 0) {
                 for (let j = 0; j < shape.holes.length; j++) {
@@ -82,7 +82,7 @@ function init() {
         scene.add(lineText);
 
         render();
-    }); //end load function
+    }); // end load function
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
diff --git a/examples-testing/examples/webgl_geometry_text_stroke.ts b/examples-testing/examples/webgl_geometry_text_stroke.ts
index 2fdd651..39147ac 100644
--- a/examples-testing/examples/webgl_geometry_text_stroke.ts
+++ b/examples-testing/examples/webgl_geometry_text_stroke.ts
@@ -1,10 +1,10 @@
 import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { SVGLoader } from "three/addons/loaders/SVGLoader.js";
 import { FontLoader } from "three/addons/loaders/FontLoader.js";
+import { SVGLoader } from "three/addons/loaders/SVGLoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -16,7 +16,7 @@ function init() {
     scene.background = new THREE.Color(0xf0f0f0);
 
     const loader = new FontLoader();
-    loader.load("fonts/helvetiker_regular.typeface.json", function (font) {
+    loader.load("fonts/helvetiker_regular.typeface.json", function(font) {
         const color = new THREE.Color(0x006699);
 
         const matDark = new THREE.MeshBasicMaterial({
@@ -33,13 +33,13 @@ function init() {
 
         const message = "   Three.js\nStroke text.";
 
-        const shapes = font.generateShapes(message, 100);
+        const shapes: THREE.Path[] = font.generateShapes(message, 100);
 
-        const geometry = new THREE.ShapeGeometry(shapes);
+        const geometry = new THREE.ShapeGeometry(shapes as THREE.Shape[]);
 
         geometry.computeBoundingBox();
 
-        const xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
+        const xMid = -0.5 * (geometry.boundingBox!.max.x - geometry.boundingBox!.min.x);
 
         geometry.translate(xMid, 0, 0);
 
@@ -51,10 +51,10 @@ function init() {
 
         // make line shape ( N.B. edge view remains visible )
 
-        const holeShapes = [];
+        const holeShapes: THREE.Path[] = [];
 
         for (let i = 0; i < shapes.length; i++) {
-            const shape = shapes[i];
+            const shape = shapes[i] as THREE.Shape;
 
             if (shape.holes && shape.holes.length > 0) {
                 for (let j = 0; j < shape.holes.length; j++) {
@@ -86,7 +86,7 @@ function init() {
         scene.add(strokeText);
 
         render();
-    }); //end load function
+    }); // end load function
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
diff --git a/examples-testing/examples/webgl_gpgpu_birds.ts b/examples-testing/examples/webgl_gpgpu_birds.ts
index 13c3ba7..f99a5f8 100644
--- a/examples-testing/examples/webgl_gpgpu_birds.ts
+++ b/examples-testing/examples/webgl_gpgpu_birds.ts
@@ -1,9 +1,9 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
-import { GPUComputationRenderer } from "three/addons/misc/GPUComputationRenderer.js";
+import { GPUComputationRenderer, Variable } from "three/addons/misc/GPUComputationRenderer.js";
 
 /* TEXTURE WIDTH FOR SIMULATION */
 const WIDTH = 32;
@@ -33,9 +33,9 @@ class BirdGeometry extends THREE.BufferGeometry {
 
         let v = 0;
 
-        function verts_push() {
-            for (let i = 0; i < arguments.length; i++) {
-                vertices.array[v++] = arguments[i];
+        function verts_push(...args: number[]) {
+            for (let i = 0; i < args.length; i++) {
+                vertices.array[v++] = args[i];
             }
         }
 
@@ -44,43 +44,13 @@ class BirdGeometry extends THREE.BufferGeometry {
         for (let f = 0; f < BIRDS; f++) {
             // Body
 
-            verts_push(
-                0,
-                -0,
-                -20,
-                0,
-                4,
-                -20,
-                0,
-                0,
-                30,
-            );
+            verts_push(0, -0, -20, 0, 4, -20, 0, 0, 30);
 
             // Wings
 
-            verts_push(
-                0,
-                0,
-                -15,
-                -wingsSpan,
-                0,
-                0,
-                0,
-                0,
-                15,
-            );
-
-            verts_push(
-                0,
-                0,
-                15,
-                wingsSpan,
-                0,
-                0,
-                0,
-                0,
-                -15,
-            );
+            verts_push(0, 0, -15, -wingsSpan, 0, 0, 0, 0, 15);
+
+            verts_push(0, 0, 15, wingsSpan, 0, 0, 0, 0, -15);
         }
 
         for (let v = 0; v < triangles * 3; v++) {
@@ -89,10 +59,7 @@ class BirdGeometry extends THREE.BufferGeometry {
             const x = (birdIndex % WIDTH) / WIDTH;
             const y = ~~(birdIndex / WIDTH) / WIDTH;
 
-            const c = new THREE.Color(
-                0x666666 +
-                    ~~(v / 9) / BIRDS * 0x666666,
-            );
+            const c = new THREE.Color(0x666666 + (~~(v / 9) / BIRDS) * 0x666666);
 
             birdColors.array[v * 3 + 0] = c.r;
             birdColors.array[v * 3 + 1] = c.g;
@@ -110,23 +77,25 @@ class BirdGeometry extends THREE.BufferGeometry {
 
 //
 
-let container, stats;
-let camera, scene, renderer;
-let mouseX = 0, mouseY = 0;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mouseX = 0,
+    mouseY = 0;
 
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
 
-const BOUNDS = 800, BOUNDS_HALF = BOUNDS / 2;
+const BOUNDS = 800,
+    BOUNDS_HALF = BOUNDS / 2;
 
 let last = performance.now();
 
-let gpuCompute;
-let velocityVariable;
-let positionVariable;
-let positionUniforms;
-let velocityUniforms;
-let birdUniforms;
+let gpuCompute: GPUComputationRenderer;
+let velocityVariable: Variable;
+let positionVariable: Variable;
+let positionUniforms: Record<string, THREE.IUniform>;
+let velocityUniforms: Record<string, THREE.IUniform>;
+let birdUniforms: Record<string, THREE.IUniform>;
 
 init();
 animate();
@@ -168,7 +137,7 @@ function init() {
         freedom: 0.75,
     };
 
-    const valuesChanger = function () {
+    const valuesChanger = function() {
         velocityUniforms["separationDistance"].value = effectController.separation;
         velocityUniforms["alignmentDistance"].value = effectController.alignment;
         velocityUniforms["cohesionDistance"].value = effectController.cohesion;
@@ -199,12 +168,12 @@ function initComputeRenderer() {
 
     velocityVariable = gpuCompute.addVariable(
         "textureVelocity",
-        document.getElementById("fragmentShaderVelocity").textContent,
+        document.getElementById("fragmentShaderVelocity")!.textContent!,
         dtVelocity,
     );
     positionVariable = gpuCompute.addVariable(
         "texturePosition",
-        document.getElementById("fragmentShaderPosition").textContent,
+        document.getElementById("fragmentShaderPosition")!.textContent!,
         dtPosition,
     );
 
@@ -243,18 +212,18 @@ function initBirds() {
 
     // For Vertex and Fragment
     birdUniforms = {
-        "color": { value: new THREE.Color(0xff2200) },
-        "texturePosition": { value: null },
-        "textureVelocity": { value: null },
-        "time": { value: 1.0 },
-        "delta": { value: 0.0 },
+        color: { value: new THREE.Color(0xff2200) },
+        texturePosition: { value: null },
+        textureVelocity: { value: null },
+        time: { value: 1.0 },
+        delta: { value: 0.0 },
     };
 
     // THREE.ShaderMaterial
     const material = new THREE.ShaderMaterial({
         uniforms: birdUniforms,
-        vertexShader: document.getElementById("birdVS").textContent,
-        fragmentShader: document.getElementById("birdFS").textContent,
+        vertexShader: document.getElementById("birdVS")!.textContent!,
+        fragmentShader: document.getElementById("birdFS")!.textContent!,
         side: THREE.DoubleSide,
     });
 
@@ -266,7 +235,7 @@ function initBirds() {
     scene.add(birdMesh);
 }
 
-function fillPositionTexture(texture) {
+function fillPositionTexture(texture: THREE.DataTexture) {
     const theArray = texture.image.data;
 
     for (let k = 0, kl = theArray.length; k < kl; k += 4) {
@@ -281,7 +250,7 @@ function fillPositionTexture(texture) {
     }
 }
 
-function fillVelocityTexture(texture) {
+function fillVelocityTexture(texture: THREE.DataTexture) {
     const theArray = texture.image.data;
 
     for (let k = 0, kl = theArray.length; k < kl; k += 4) {
@@ -306,7 +275,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
@@ -336,7 +305,7 @@ function render() {
     birdUniforms["time"].value = now;
     birdUniforms["delta"].value = delta;
 
-    velocityUniforms["predator"].value.set(0.5 * mouseX / windowHalfX, -0.5 * mouseY / windowHalfY, 0);
+    velocityUniforms["predator"].value.set((0.5 * mouseX) / windowHalfX, (-0.5 * mouseY) / windowHalfY, 0);
 
     mouseX = 10000;
     mouseY = 10000;
diff --git a/examples-testing/examples/webgl_gpgpu_birds_gltf.ts b/examples-testing/examples/webgl_gpgpu_birds_gltf.ts
index daf3dfc..b09e257 100644
--- a/examples-testing/examples/webgl_gpgpu_birds_gltf.ts
+++ b/examples-testing/examples/webgl_gpgpu_birds_gltf.ts
@@ -1,8 +1,8 @@
 import * as THREE from "three";
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
-import { GPUComputationRenderer } from "three/addons/misc/GPUComputationRenderer.js";
+import { GPUComputationRenderer, Variable } from "three/addons/misc/GPUComputationRenderer.js";
 
 /* TEXTURE WIDTH FOR SIMULATION */
 const WIDTH = 64;
@@ -10,38 +10,43 @@ const BIRDS = WIDTH * WIDTH;
 
 /* BAKE ANIMATION INTO TEXTURE and CREATE GEOMETRY FROM BASE MODEL */
 const BirdGeometry = new THREE.BufferGeometry();
-let textureAnimation, durationAnimation, birdMesh, materialShader, indicesPerBird;
+let textureAnimation: THREE.DataTexture,
+    durationAnimation: number,
+    birdMesh: THREE.Mesh,
+    materialShader: THREE.WebGLProgramParametersWithUniforms,
+    indicesPerBird: number;
 
-function nextPowerOf2(n) {
+function nextPowerOf2(n: number) {
     return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)));
 }
 
-Math.lerp = function (value1, value2, amount) {
+function lerp(value1: number, value2: number, amount: number) {
     amount = Math.max(Math.min(amount, 1), 0);
     return value1 + (value2 - value1) * amount;
-};
+}
 
 const gltfs = ["models/gltf/Parrot.glb", "models/gltf/Flamingo.glb"];
-const colors = [0xccFFFF, 0xffdeff];
+const colors = [0xccffff, 0xffdeff];
 const sizes = [0.2, 0.1];
 const selectModel = Math.floor(Math.random() * gltfs.length);
-new GLTFLoader().load(gltfs[selectModel], function (gltf) {
+new GLTFLoader().load(gltfs[selectModel], function(gltf) {
     const animations = gltf.animations;
     durationAnimation = Math.round(animations[0].duration * 60);
-    const birdGeo = gltf.scene.children[0].geometry;
+    const birdGeo = (gltf.scene.children[0] as THREE.Mesh).geometry;
     const morphAttributes = birdGeo.morphAttributes.position;
     const tHeight = nextPowerOf2(durationAnimation);
     const tWidth = nextPowerOf2(birdGeo.getAttribute("position").count);
-    indicesPerBird = birdGeo.index.count;
+    indicesPerBird = birdGeo.index!.count;
     const tData = new Float32Array(4 * tWidth * tHeight);
 
     for (let i = 0; i < tWidth; i++) {
         for (let j = 0; j < tHeight; j++) {
             const offset = j * tWidth * 4;
 
-            const curMorph = Math.floor(j / durationAnimation * morphAttributes.length);
-            const nextMorph = (Math.floor(j / durationAnimation * morphAttributes.length) + 1) % morphAttributes.length;
-            const lerpAmount = j / durationAnimation * morphAttributes.length % 1;
+            const curMorph = Math.floor((j / durationAnimation) * morphAttributes.length);
+            const nextMorph = (Math.floor((j / durationAnimation) * morphAttributes.length) + 1)
+                % morphAttributes.length;
+            const lerpAmount = ((j / durationAnimation) * morphAttributes.length) % 1;
 
             if (j < durationAnimation) {
                 let d0, d1;
@@ -49,17 +54,17 @@ new GLTFLoader().load(gltfs[selectModel], function (gltf) {
                 d0 = morphAttributes[curMorph].array[i * 3];
                 d1 = morphAttributes[nextMorph].array[i * 3];
 
-                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4] = Math.lerp(d0, d1, lerpAmount);
+                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4] = lerp(d0, d1, lerpAmount);
 
                 d0 = morphAttributes[curMorph].array[i * 3 + 1];
                 d1 = morphAttributes[nextMorph].array[i * 3 + 1];
 
-                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4 + 1] = Math.lerp(d0, d1, lerpAmount);
+                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4 + 1] = lerp(d0, d1, lerpAmount);
 
                 d0 = morphAttributes[curMorph].array[i * 3 + 2];
                 d1 = morphAttributes[nextMorph].array[i * 3 + 2];
 
-                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4 + 2] = Math.lerp(d0, d1, lerpAmount);
+                if (d0 !== undefined && d1 !== undefined) tData[offset + i * 4 + 2] = lerp(d0, d1, lerpAmount);
 
                 tData[offset + i * 4 + 3] = 1;
             }
@@ -69,7 +74,11 @@ new GLTFLoader().load(gltfs[selectModel], function (gltf) {
     textureAnimation = new THREE.DataTexture(tData, tWidth, tHeight, THREE.RGBAFormat, THREE.FloatType);
     textureAnimation.needsUpdate = true;
 
-    const vertices = [], color = [], reference = [], seeds = [], indices = [];
+    const vertices = [],
+        color = [],
+        reference = [],
+        seeds = [],
+        indices = [];
     const totalVertices = birdGeo.getAttribute("position").count * 3 * BIRDS;
     for (let i = 0; i < totalVertices; i++) {
         const bIndex = i % (birdGeo.getAttribute("position").count * 3);
@@ -79,7 +88,7 @@ new GLTFLoader().load(gltfs[selectModel], function (gltf) {
 
     let r = Math.random();
     for (let i = 0; i < birdGeo.getAttribute("position").count * BIRDS; i++) {
-        const bIndex = i % (birdGeo.getAttribute("position").count);
+        const bIndex = i % birdGeo.getAttribute("position").count;
         const bird = Math.floor(i / birdGeo.getAttribute("position").count);
         if (bIndex == 0) r = Math.random();
         const j = ~~bird;
@@ -89,9 +98,9 @@ new GLTFLoader().load(gltfs[selectModel], function (gltf) {
         seeds.push(bird, r, Math.random(), Math.random());
     }
 
-    for (let i = 0; i < birdGeo.index.array.length * BIRDS; i++) {
-        const offset = Math.floor(i / birdGeo.index.array.length) * (birdGeo.getAttribute("position").count);
-        indices.push(birdGeo.index.array[i % birdGeo.index.array.length] + offset);
+    for (let i = 0; i < birdGeo.index!.array.length * BIRDS; i++) {
+        const offset = Math.floor(i / birdGeo.index!.array.length) * birdGeo.getAttribute("position").count;
+        indices.push(birdGeo.index!.array[i % birdGeo.index!.array.length] + offset);
     }
 
     BirdGeometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(vertices), 3));
@@ -106,22 +115,33 @@ new GLTFLoader().load(gltfs[selectModel], function (gltf) {
     animate();
 });
 
-let container, stats;
-let camera, scene, renderer;
-let mouseX = 0, mouseY = 0;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mouseX = 0,
+    mouseY = 0;
 
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
 
-const BOUNDS = 800, BOUNDS_HALF = BOUNDS / 2;
+const BOUNDS = 800,
+    BOUNDS_HALF = BOUNDS / 2;
 
 let last = performance.now();
 
-let gpuCompute;
-let velocityVariable;
-let positionVariable;
-let positionUniforms;
-let velocityUniforms;
+let gpuCompute: GPUComputationRenderer;
+let velocityVariable: Variable;
+let positionVariable: Variable;
+let positionUniforms: Record<string, THREE.IUniform>;
+let velocityUniforms: Record<string, THREE.IUniform>;
+
+interface EffectController {
+    separation: number;
+    alignment: number;
+    cohesion: number;
+    freedom: number;
+    size: number;
+    count: number;
+}
 
 function init() {
     container = document.createElement("div");
@@ -142,7 +162,7 @@ function init() {
     hemiLight.position.set(0, 50, 0);
     scene.add(hemiLight);
 
-    const dirLight = new THREE.DirectionalLight(0x00CED1, 2.0);
+    const dirLight = new THREE.DirectionalLight(0x00ced1, 2.0);
     dirLight.color.setHSL(0.1, 1, 0.95, THREE.SRGBColorSpace);
     dirLight.position.set(-1, 1.75, 1);
     dirLight.position.multiplyScalar(30);
@@ -174,7 +194,7 @@ function init() {
         count: Math.floor(BIRDS / 4),
     };
 
-    const valuesChanger = function () {
+    const valuesChanger = function() {
         velocityUniforms["separationDistance"].value = effectController.separation;
         velocityUniforms["alignmentDistance"].value = effectController.alignment;
         velocityUniforms["cohesionDistance"].value = effectController.cohesion;
@@ -209,12 +229,12 @@ function initComputeRenderer() {
 
     velocityVariable = gpuCompute.addVariable(
         "textureVelocity",
-        document.getElementById("fragmentShaderVelocity").textContent,
+        document.getElementById("fragmentShaderVelocity")!.textContent!,
         dtVelocity,
     );
     positionVariable = gpuCompute.addVariable(
         "texturePosition",
-        document.getElementById("fragmentShaderPosition").textContent,
+        document.getElementById("fragmentShaderPosition")!.textContent!,
         dtPosition,
     );
 
@@ -248,7 +268,7 @@ function initComputeRenderer() {
     }
 }
 
-function initBirds(effectController) {
+function initBirds(effectController: EffectController) {
     const geometry = BirdGeometry;
 
     const m = new THREE.MeshStandardMaterial({
@@ -258,7 +278,7 @@ function initBirds(effectController) {
         metalness: 0,
     });
 
-    m.onBeforeCompile = (shader) => {
+    m.onBeforeCompile = shader => {
         shader.uniforms.texturePosition = { value: null };
         shader.uniforms.textureVelocity = { value: null };
         shader.uniforms.textureAnimation = { value: textureAnimation };
@@ -328,7 +348,7 @@ function initBirds(effectController) {
     scene.add(birdMesh);
 }
 
-function fillPositionTexture(texture) {
+function fillPositionTexture(texture: THREE.DataTexture) {
     const theArray = texture.image.data;
 
     for (let k = 0, kl = theArray.length; k < kl; k += 4) {
@@ -343,7 +363,7 @@ function fillPositionTexture(texture) {
     }
 }
 
-function fillVelocityTexture(texture) {
+function fillVelocityTexture(texture: THREE.DataTexture) {
     const theArray = texture.image.data;
 
     for (let k = 0, kl = theArray.length; k < kl; k += 4) {
@@ -368,7 +388,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
@@ -398,7 +418,7 @@ function render() {
     if (materialShader) materialShader.uniforms["time"].value = now / 1000;
     if (materialShader) materialShader.uniforms["delta"].value = delta;
 
-    velocityUniforms["predator"].value.set(0.5 * mouseX / windowHalfX, -0.5 * mouseY / windowHalfY, 0);
+    velocityUniforms["predator"].value.set((0.5 * mouseX) / windowHalfX, (-0.5 * mouseY) / windowHalfY, 0);
 
     mouseX = 10000;
     mouseY = 10000;
diff --git a/examples-testing/examples/webgl_gpgpu_protoplanet.ts b/examples-testing/examples/webgl_gpgpu_protoplanet.ts
index 22c9eee..79727d7 100644
--- a/examples-testing/examples/webgl_gpgpu_protoplanet.ts
+++ b/examples-testing/examples/webgl_gpgpu_protoplanet.ts
@@ -1,25 +1,35 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { GPUComputationRenderer } from "three/addons/misc/GPUComputationRenderer.js";
+import { GPUComputationRenderer, Variable } from "three/addons/misc/GPUComputationRenderer.js";
 
 // Texture width for simulation (each texel is a debris particle)
 const WIDTH = 64;
 
-let container, stats;
-let camera, scene, renderer, geometry;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, geometry;
 
 const PARTICLES = WIDTH * WIDTH;
 
-let gpuCompute;
-let velocityVariable;
-let positionVariable;
-let velocityUniforms;
-let particleUniforms;
-let effectController;
+let gpuCompute: GPUComputationRenderer;
+let velocityVariable: Variable;
+let positionVariable: Variable;
+let velocityUniforms: Record<string, THREE.IUniform>;
+let particleUniforms: Record<string, THREE.IUniform>;
+let effectController: {
+    gravityConstant: number;
+    density: number;
+    radius: number;
+    height: number;
+    exponent: number;
+    maxMass: number;
+    velocity: number;
+    velocityExponent: number;
+    randVelocity: number;
+};
 
 init();
 animate();
@@ -86,12 +96,12 @@ function initComputeRenderer() {
 
     velocityVariable = gpuCompute.addVariable(
         "textureVelocity",
-        document.getElementById("computeShaderVelocity").textContent,
+        document.getElementById("computeShaderVelocity")!.textContent!,
         dtVelocity,
     );
     positionVariable = gpuCompute.addVariable(
         "texturePosition",
-        document.getElementById("computeShaderPosition").textContent,
+        document.getElementById("computeShaderPosition")!.textContent!,
         dtPosition,
     );
 
@@ -130,7 +140,7 @@ function initProtoplanets() {
 
     for (let i = 0; i < PARTICLES; i++) {
         positions[p++] = (Math.random() * 2 - 1) * effectController.radius;
-        positions[p++] = 0; //( Math.random() * 2 - 1 ) * effectController.radius;
+        positions[p++] = 0; // ( Math.random() * 2 - 1 ) * effectController.radius;
         positions[p++] = (Math.random() * 2 - 1) * effectController.radius;
     }
 
@@ -148,17 +158,17 @@ function initProtoplanets() {
     geometry.setAttribute("uv", new THREE.BufferAttribute(uvs, 2));
 
     particleUniforms = {
-        "texturePosition": { value: null },
-        "textureVelocity": { value: null },
-        "cameraConstant": { value: getCameraConstant(camera) },
-        "density": { value: 0.0 },
+        texturePosition: { value: null },
+        textureVelocity: { value: null },
+        cameraConstant: { value: getCameraConstant(camera) },
+        density: { value: 0.0 },
     };
 
     // THREE.ShaderMaterial
     const material = new THREE.ShaderMaterial({
         uniforms: particleUniforms,
-        vertexShader: document.getElementById("particleVertexShader").textContent,
-        fragmentShader: document.getElementById("particleFragmentShader").textContent,
+        vertexShader: document.getElementById("particleVertexShader")!.textContent!,
+        fragmentShader: document.getElementById("particleFragmentShader")!.textContent!,
     });
 
     material.extensions.drawBuffers = true;
@@ -170,14 +180,14 @@ function initProtoplanets() {
     scene.add(particles);
 }
 
-function fillTextures(texturePosition, textureVelocity) {
+function fillTextures(texturePosition: THREE.DataTexture, textureVelocity: THREE.DataTexture) {
     const posArray = texturePosition.image.data;
     const velArray = textureVelocity.image.data;
 
     const radius = effectController.radius;
     const height = effectController.height;
     const exponent = effectController.exponent;
-    const maxMass = effectController.maxMass * 1024 / PARTICLES;
+    const maxMass = (effectController.maxMass * 1024) / PARTICLES;
     const maxVel = effectController.velocity;
     const velExponent = effectController.velocityExponent;
     const randVel = effectController.randVelocity;
@@ -256,7 +266,7 @@ function initGUI() {
     folder2.add(effectController, "randVelocity", 0.0, 50.0, 0.1);
 
     const buttonRestart = {
-        restartSimulation: function () {
+        restartSimulation: function() {
             restartSimulation();
         },
     };
@@ -267,7 +277,7 @@ function initGUI() {
     folder2.open();
 }
 
-function getCameraConstant(camera) {
+function getCameraConstant(camera: THREE.PerspectiveCamera) {
     return window.innerHeight / (Math.tan(THREE.MathUtils.DEG2RAD * 0.5 * camera.fov) / camera.zoom);
 }
 
diff --git a/examples-testing/examples/webgl_gpgpu_water.ts b/examples-testing/examples/webgl_gpgpu_water.ts
index e5511a2..e18dee5 100644
--- a/examples-testing/examples/webgl_gpgpu_water.ts
+++ b/examples-testing/examples/webgl_gpgpu_water.ts
@@ -1,10 +1,10 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
-import { GPUComputationRenderer } from "three/addons/misc/GPUComputationRenderer.js";
 import { SimplexNoise } from "three/addons/math/SimplexNoise.js";
+import { GPUComputationRenderer, Variable } from "three/addons/misc/GPUComputationRenderer.js";
 
 // Texture width for simulation
 const WIDTH = 128;
@@ -13,25 +13,25 @@ const WIDTH = 128;
 const BOUNDS = 512;
 const BOUNDS_HALF = BOUNDS * 0.5;
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 let mouseMoved = false;
 const mouseCoords = new THREE.Vector2();
 const raycaster = new THREE.Raycaster();
 
-let waterMesh;
-let meshRay;
-let gpuCompute;
-let heightmapVariable;
-let waterUniforms;
-let smoothShader;
-let readWaterLevelShader;
-let readWaterLevelRenderTarget;
-let readWaterLevelImage;
+let waterMesh: THREE.Mesh<THREE.PlaneGeometry, THREE.ShaderMaterial>;
+let meshRay: THREE.Mesh;
+let gpuCompute: GPUComputationRenderer;
+let heightmapVariable: Variable;
+let waterUniforms: Record<string, THREE.IUniform>;
+let smoothShader: THREE.ShaderMaterial;
+let readWaterLevelShader: THREE.ShaderMaterial;
+let readWaterLevelRenderTarget: THREE.WebGLRenderTarget;
+let readWaterLevelImage: Uint8Array;
 const waterNormal = new THREE.Vector3();
 
 const NUM_SPHERES = 5;
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 let spheresEnabled = true;
 
 const simplex = new SimplexNoise();
@@ -49,11 +49,11 @@ function init() {
 
     scene = new THREE.Scene();
 
-    const sun = new THREE.DirectionalLight(0xFFFFFF, 3.0);
+    const sun = new THREE.DirectionalLight(0xffffff, 3.0);
     sun.position.set(300, 400, 175);
     scene.add(sun);
 
-    const sun2 = new THREE.DirectionalLight(0x40A040, 2.0);
+    const sun2 = new THREE.DirectionalLight(0x40a040, 2.0);
     sun2.position.set(-100, 350, -200);
     scene.add(sun2);
 
@@ -68,7 +68,7 @@ function init() {
     container.style.touchAction = "none";
     container.addEventListener("pointermove", onPointerMove);
 
-    document.addEventListener("keydown", function (event) {
+    document.addEventListener("keydown", function(event) {
         // W Pressed: Toggle wireframe
         if (event.keyCode === 87) {
             waterMesh.material.wireframe = !waterMesh.material.wireframe;
@@ -86,7 +86,7 @@ function init() {
         spheresEnabled: spheresEnabled,
     };
 
-    const valuesChanger = function () {
+    const valuesChanger = function() {
         heightmapVariable.material.uniforms["mouseSize"].value = effectController.mouseSize;
         heightmapVariable.material.uniforms["viscosityConstant"].value = effectController.viscosity;
         spheresEnabled = effectController.spheresEnabled;
@@ -101,7 +101,7 @@ function init() {
     gui.add(effectController, "viscosity", 0.9, 0.999, 0.001).onChange(valuesChanger);
     gui.add(effectController, "spheresEnabled").onChange(valuesChanger);
     const buttonSmooth = {
-        smoothWater: function () {
+        smoothWater: function() {
             smoothWater();
         },
     };
@@ -115,7 +115,7 @@ function init() {
 }
 
 function initWater() {
-    const materialColor = 0x0040C0;
+    const materialColor = 0x0040c0;
 
     const geometry = new THREE.PlaneGeometry(BOUNDS, BOUNDS, WIDTH - 1, WIDTH - 1);
 
@@ -124,10 +124,10 @@ function initWater() {
         uniforms: THREE.UniformsUtils.merge([
             THREE.ShaderLib["phong"].uniforms,
             {
-                "heightmap": { value: null },
+                heightmap: { value: null },
             },
         ]),
-        vertexShader: document.getElementById("waterVertexShader").textContent,
+        vertexShader: document.getElementById("waterVertexShader")!.textContent!,
         fragmentShader: THREE.ShaderChunk["meshphong_frag"],
     });
 
@@ -155,7 +155,7 @@ function initWater() {
 
     // THREE.Mesh just for mouse raycasting
     const geometryRay = new THREE.PlaneGeometry(BOUNDS, BOUNDS, 1, 1);
-    meshRay = new THREE.Mesh(geometryRay, new THREE.MeshBasicMaterial({ color: 0xFFFFFF, visible: false }));
+    meshRay = new THREE.Mesh(geometryRay, new THREE.MeshBasicMaterial({ color: 0xffffff, visible: false }));
     meshRay.rotation.x = -Math.PI / 2;
     meshRay.matrixAutoUpdate = false;
     meshRay.updateMatrix();
@@ -175,7 +175,7 @@ function initWater() {
 
     heightmapVariable = gpuCompute.addVariable(
         "heightmap",
-        document.getElementById("heightmapFragmentShader").textContent,
+        document.getElementById("heightmapFragmentShader")!.textContent!,
         heightmap0,
     );
 
@@ -193,13 +193,13 @@ function initWater() {
     }
 
     // Create compute shader to smooth the water surface and velocity
-    smoothShader = gpuCompute.createShaderMaterial(document.getElementById("smoothFragmentShader").textContent, {
+    smoothShader = gpuCompute.createShaderMaterial(document.getElementById("smoothFragmentShader")!.textContent!, {
         smoothTexture: { value: null },
     });
 
     // Create compute shader to read water level
     readWaterLevelShader = gpuCompute.createShaderMaterial(
-        document.getElementById("readWaterLevelFragmentShader").textContent,
+        document.getElementById("readWaterLevelFragmentShader")!.textContent!,
         {
             point1: { value: new THREE.Vector2() },
             levelTexture: { value: null },
@@ -222,10 +222,10 @@ function initWater() {
     });
 }
 
-function fillTexture(texture) {
+function fillTexture(texture: THREE.DataTexture) {
     const waterMaxHeight = 10;
 
-    function noise(x, y) {
+    function noise(x: number, y: number) {
         let multR = waterMaxHeight;
         let mult = 0.025;
         let r = 0;
@@ -243,8 +243,8 @@ function fillTexture(texture) {
     let p = 0;
     for (let j = 0; j < WIDTH; j++) {
         for (let i = 0; i < WIDTH; i++) {
-            const x = i * 128 / WIDTH;
-            const y = j * 128 / WIDTH;
+            const x = (i * 128) / WIDTH;
+            const y = (j * 128) / WIDTH;
 
             pixels[p + 0] = noise(x, y);
             pixels[p + 1] = pixels[p + 0];
@@ -272,7 +272,7 @@ function smoothWater() {
 function createSpheres() {
     const sphereTemplate = new THREE.Mesh(
         new THREE.SphereGeometry(4, 24, 12),
-        new THREE.MeshPhongMaterial({ color: 0xFFFF00 }),
+        new THREE.MeshPhongMaterial({ color: 0xffff00 }),
     );
 
     for (let i = 0; i < NUM_SPHERES; i++) {
@@ -302,8 +302,8 @@ function sphereDynamics() {
 
         if (sphere) {
             // Read water level and orientation
-            const u = 0.5 * sphere.position.x / BOUNDS_HALF + 0.5;
-            const v = 1 - (0.5 * sphere.position.z / BOUNDS_HALF + 0.5);
+            const u = (0.5 * sphere.position.x) / BOUNDS_HALF + 0.5;
+            const v = 1 - ((0.5 * sphere.position.z) / BOUNDS_HALF + 0.5);
             readWaterLevelShader.uniforms["point1"].value.set(u, v);
             gpuCompute.doRenderTarget(readWaterLevelShader, readWaterLevelRenderTarget);
 
@@ -350,12 +350,12 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function setMouseCoords(x, y) {
+function setMouseCoords(x: number, y: number) {
     mouseCoords.set((x / renderer.domElement.clientWidth) * 2 - 1, -(y / renderer.domElement.clientHeight) * 2 + 1);
     mouseMoved = true;
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     setMouseCoords(event.clientX, event.clientY);
diff --git a/examples-testing/examples/webgl_helpers.ts b/examples-testing/examples/webgl_helpers.ts
index f2bc839..1c245af 100644
--- a/examples-testing/examples/webgl_helpers.ts
+++ b/examples-testing/examples/webgl_helpers.ts
@@ -5,10 +5,10 @@ import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { VertexNormalsHelper } from "three/addons/helpers/VertexNormalsHelper.js";
 import { VertexTangentsHelper } from "three/addons/helpers/VertexTangentsHelper.js";
 
-let scene, renderer;
-let camera, light;
-let vnh;
-let vth;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let camera: THREE.PerspectiveCamera, light: THREE.PointLight;
+let vnh: VertexNormalsHelper;
+let vth: VertexTangentsHelper;
 
 init();
 animate();
@@ -43,8 +43,8 @@ function init() {
     scene.add(polarGridHelper);
 
     const loader = new GLTFLoader();
-    loader.load("models/gltf/LeePerrySmith/LeePerrySmith.glb", function (gltf) {
-        const mesh = gltf.scene.children[0];
+    loader.load("models/gltf/LeePerrySmith/LeePerrySmith.glb", function(gltf) {
+        const mesh = gltf.scene.children[0] as THREE.Mesh;
 
         mesh.geometry.computeTangents(); // generates bad data due to degenerate UVs
 
@@ -66,7 +66,7 @@ function init() {
         scene.add(new THREE.BoxHelper(mesh));
 
         const wireframe = new THREE.WireframeGeometry(mesh.geometry);
-        let line = new THREE.LineSegments(wireframe);
+        let line: THREE.LineSegments<THREE.BufferGeometry, THREE.LineBasicMaterial> = new THREE.LineSegments(wireframe);
         line.material.depthTest = false;
         line.material.opacity = 0.25;
         line.material.transparent = true;
diff --git a/examples-testing/examples/webgl_instancing_dynamic.ts b/examples-testing/examples/webgl_instancing_dynamic.ts
index bab2382..b92b6ef 100644
--- a/examples-testing/examples/webgl_instancing_dynamic.ts
+++ b/examples-testing/examples/webgl_instancing_dynamic.ts
@@ -1,11 +1,11 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
-let mesh;
+let mesh: THREE.InstancedMesh;
 const amount = parseInt(window.location.search.slice(1)) || 10;
 const count = Math.pow(amount, 3);
 const dummy = new THREE.Object3D();
@@ -21,7 +21,7 @@ function init() {
     scene = new THREE.Scene();
 
     const loader = new THREE.BufferGeometryLoader();
-    loader.load("models/json/suzanne_buffergeometry.json", function (geometry) {
+    loader.load("models/json/suzanne_buffergeometry.json", function(geometry) {
         geometry.computeVertexNormals();
         geometry.scale(0.5, 0.5, 0.5);
 
diff --git a/examples-testing/examples/webgl_instancing_performance.ts b/examples-testing/examples/webgl_instancing_performance.ts
index 514a560..7430cdc 100644
--- a/examples-testing/examples/webgl_instancing_performance.ts
+++ b/examples-testing/examples/webgl_instancing_performance.ts
@@ -1,13 +1,17 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import * as BufferGeometryUtils from "three/addons/utils/BufferGeometryUtils.js";
 
-let container, stats, gui, guiStatsEl;
-let camera, controls, scene, renderer, material;
+let container: HTMLElement, stats: Stats, gui: GUI, guiStatsEl: HTMLDivElement;
+let camera: THREE.PerspectiveCamera,
+    controls: OrbitControls,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    material: THREE.MeshNormalMaterial;
 
 // gui
 
@@ -31,27 +35,27 @@ animate();
 //
 
 function clean() {
-    const meshes = [];
+    const meshes: THREE.Mesh[] = [];
 
-    scene.traverse(function (object) {
-        if (object.isMesh) meshes.push(object);
+    scene.traverse(function(object) {
+        if ((object as THREE.Mesh).isMesh) meshes.push(object as THREE.Mesh);
     });
 
     for (let i = 0; i < meshes.length; i++) {
         const mesh = meshes[i];
-        mesh.material.dispose();
+        (mesh.material as THREE.Material).dispose();
         mesh.geometry.dispose();
 
         scene.remove(mesh);
     }
 }
 
-const randomizeMatrix = function () {
+const randomizeMatrix = (function() {
     const position = new THREE.Vector3();
     const quaternion = new THREE.Quaternion();
     const scale = new THREE.Vector3();
 
-    return function (matrix) {
+    return function(matrix: THREE.Matrix4) {
         position.x = Math.random() * 40 - 20;
         position.y = Math.random() * 40 - 20;
         position.z = Math.random() * 40 - 20;
@@ -62,40 +66,38 @@ const randomizeMatrix = function () {
 
         matrix.compose(position, quaternion, scale);
     };
-}();
+})();
 
 function initMesh() {
     clean();
 
     // make instances
-    new THREE.BufferGeometryLoader()
-        .setPath("models/json/")
-        .load("suzanne_buffergeometry.json", function (geometry) {
-            material = new THREE.MeshNormalMaterial();
+    new THREE.BufferGeometryLoader().setPath("models/json/").load("suzanne_buffergeometry.json", function(geometry) {
+        material = new THREE.MeshNormalMaterial();
 
-            geometry.computeVertexNormals();
+        geometry.computeVertexNormals();
 
-            console.time(api.method + " (build)");
+        console.time(api.method + " (build)");
 
-            switch (api.method) {
-                case Method.INSTANCED:
-                    makeInstanced(geometry);
-                    break;
+        switch (api.method) {
+            case Method.INSTANCED:
+                makeInstanced(geometry);
+                break;
 
-                case Method.MERGED:
-                    makeMerged(geometry);
-                    break;
+            case Method.MERGED:
+                makeMerged(geometry);
+                break;
 
-                case Method.NAIVE:
-                    makeNaive(geometry);
-                    break;
-            }
+            case Method.NAIVE:
+                makeNaive(geometry);
+                break;
+        }
 
-            console.timeEnd(api.method + " (build)");
-        });
+        console.timeEnd(api.method + " (build)");
+    });
 }
 
-function makeInstanced(geometry) {
+function makeInstanced(geometry: THREE.BufferGeometry) {
     const matrix = new THREE.Matrix4();
     const mesh = new THREE.InstancedMesh(geometry, material, api.count);
 
@@ -116,7 +118,7 @@ function makeInstanced(geometry) {
     ].join("<br/>");
 }
 
-function makeMerged(geometry) {
+function makeMerged(geometry: THREE.BufferGeometry) {
     const geometries = [];
     const matrix = new THREE.Matrix4();
 
@@ -141,7 +143,7 @@ function makeMerged(geometry) {
     ].join("<br/>");
 }
 
-function makeNaive(geometry) {
+function makeNaive(geometry: THREE.BufferGeometry) {
     const matrix = new THREE.Matrix4();
 
     for (let i = 0; i < api.count; i++) {
@@ -177,7 +179,7 @@ function init() {
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(width, height);
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
     container.appendChild(renderer.domElement);
 
     // scene
@@ -243,7 +245,7 @@ function render() {
 
 //
 
-function getGeometryByteLength(geometry) {
+function getGeometryByteLength(geometry: THREE.BufferGeometry) {
     let total = 0;
 
     if (geometry.index) total += geometry.index.array.byteLength;
@@ -256,7 +258,7 @@ function getGeometryByteLength(geometry) {
 }
 
 // Source: https://stackoverflow.com/a/18650828/1314762
-function formatBytes(bytes, decimals) {
+function formatBytes(bytes: number, decimals: number) {
     if (bytes === 0) return "0 bytes";
 
     const k = 1024;
diff --git a/examples-testing/examples/webgl_instancing_raycast.ts b/examples-testing/examples/webgl_instancing_raycast.ts
index a65bba6..28bddd3 100644
--- a/examples-testing/examples/webgl_instancing_raycast.ts
+++ b/examples-testing/examples/webgl_instancing_raycast.ts
@@ -1,12 +1,16 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
-let camera, scene, renderer, controls, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    controls: OrbitControls,
+    stats: Stats;
 
-let mesh;
+let mesh: THREE.InstancedMesh;
 const amount = parseInt(window.location.search.slice(1)) || 10;
 const count = Math.pow(amount, 3);
 
@@ -84,7 +88,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onMouseMove(event) {
+function onMouseMove(event: MouseEvent) {
     event.preventDefault();
 
     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
@@ -101,14 +105,14 @@ function animate() {
     const intersection = raycaster.intersectObject(mesh);
 
     if (intersection.length > 0) {
-        const instanceId = intersection[0].instanceId;
+        const instanceId = intersection[0].instanceId!;
 
         mesh.getColorAt(instanceId, color);
 
         if (color.equals(white)) {
             mesh.setColorAt(instanceId, color.setHex(Math.random() * 0xffffff));
 
-            mesh.instanceColor.needsUpdate = true;
+            mesh.instanceColor!.needsUpdate = true;
         }
     }
 
diff --git a/examples-testing/examples/webgl_instancing_scatter.ts b/examples-testing/examples/webgl_instancing_scatter.ts
index dbef230..e79692b 100644
--- a/examples-testing/examples/webgl_instancing_scatter.ts
+++ b/examples-testing/examples/webgl_instancing_scatter.ts
@@ -1,25 +1,25 @@
 import * as THREE from "three";
 
-import { MeshSurfaceSampler } from "three/addons/math/MeshSurfaceSampler.js";
-import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
+import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
+import { MeshSurfaceSampler } from "three/addons/math/MeshSurfaceSampler.js";
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 const api = {
     count: 2000,
     distribution: "random",
     resample: resample,
-    surfaceColor: 0xFFF784,
-    backgroundColor: 0xE39469,
+    surfaceColor: 0xfff784,
+    backgroundColor: 0xe39469,
 };
 
-let stemMesh, blossomMesh;
-let stemGeometry, blossomGeometry;
-let stemMaterial, blossomMaterial;
+let stemMesh: THREE.InstancedMesh, blossomMesh: THREE.InstancedMesh;
+let stemGeometry: THREE.BufferGeometry, blossomGeometry: THREE.BufferGeometry;
+let stemMaterial: THREE.Material | THREE.Material[], blossomMaterial: THREE.Material | THREE.Material[];
 
-let sampler;
+let sampler: MeshSurfaceSampler;
 const count = api.count;
 const ages = new Float32Array(count);
 const scales = new Float32Array(count);
@@ -35,21 +35,21 @@ const surfaceMaterial = new THREE.MeshLambertMaterial({ color: api.surfaceColor,
 const surface = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
 
 // Source: https://gist.github.com/gre/1650294
-const easeOutCubic = function (t) {
-    return (--t) * t * t + 1;
+const easeOutCubic = function(t: number) {
+    return --t * t * t + 1;
 };
 
 // Scaling curve causes particles to grow quickly, ease gradually into full scale, then
 // disappear quickly. More of the particle's lifetime is spent around full scale.
-const scaleCurve = function (t) {
+const scaleCurve = function(t: number) {
     return Math.abs(easeOutCubic((t > 0.5 ? 1 - t : t) * 2));
 };
 
 const loader = new GLTFLoader();
 
-loader.load("./models/gltf/Flower/Flower.glb", function (gltf) {
-    const _stemMesh = gltf.scene.getObjectByName("Stem");
-    const _blossomMesh = gltf.scene.getObjectByName("Blossom");
+loader.load("./models/gltf/Flower/Flower.glb", function(gltf) {
+    const _stemMesh = gltf.scene.getObjectByName("Stem") as THREE.Mesh;
+    const _blossomMesh = gltf.scene.getObjectByName("Blossom") as THREE.Mesh;
 
     stemGeometry = _stemMesh.geometry.clone();
     blossomGeometry = _blossomMesh.geometry.clone();
@@ -69,7 +69,7 @@ loader.load("./models/gltf/Flower/Flower.glb", function (gltf) {
 
     // Assign random colors to the blossoms.
     const color = new THREE.Color();
-    const blossomPalette = [0xF20587, 0xF2D479, 0xF2C879, 0xF2B077, 0xF24405];
+    const blossomPalette = [0xf20587, 0xf2d479, 0xf2c879, 0xf2b077, 0xf24405];
 
     for (let i = 0; i < count; i++) {
         color.setHex(blossomPalette[Math.floor(Math.random() * blossomPalette.length)]);
@@ -96,7 +96,7 @@ function init() {
     scene = new THREE.Scene();
     scene.background = new THREE.Color(api.backgroundColor);
 
-    const pointLight = new THREE.PointLight(0xAA8899, 2.5, 0, 0);
+    const pointLight = new THREE.PointLight(0xaa8899, 2.5, 0, 0);
     pointLight.position.set(50, -25, 75);
     scene.add(pointLight);
 
@@ -112,7 +112,7 @@ function init() {
     //
 
     const gui = new GUI();
-    gui.add(api, "count", 0, count).onChange(function () {
+    gui.add(api, "count", 0, count).onChange(function() {
         stemMesh.count = api.count;
         blossomMesh.count = api.count;
     });
@@ -158,9 +158,7 @@ function resample() {
 
     console.time(".build()");
 
-    sampler = new MeshSurfaceSampler(surface)
-        .setWeightAttribute(api.distribution === "weighted" ? "uv" : null)
-        .build();
+    sampler = new MeshSurfaceSampler(surface).setWeightAttribute(api.distribution === "weighted" ? "uv" : null).build();
 
     console.timeEnd(".build()");
 
@@ -181,7 +179,7 @@ function resample() {
     blossomMesh.instanceMatrix.needsUpdate = true;
 }
 
-function resampleParticle(i) {
+function resampleParticle(i: number) {
     sampler.sample(_position, _normal);
     _normal.add(_position);
 
@@ -194,7 +192,7 @@ function resampleParticle(i) {
     blossomMesh.setMatrixAt(i, dummy.matrix);
 }
 
-function updateParticle(i) {
+function updateParticle(i: number) {
     // Update lifecycle.
 
     ages[i] += 0.005;
diff --git a/examples-testing/examples/webgl_interactive_buffergeometry.ts b/examples-testing/examples/webgl_interactive_buffergeometry.ts
index a9a1305..47412a4 100644
--- a/examples-testing/examples/webgl_interactive_buffergeometry.ts
+++ b/examples-testing/examples/webgl_interactive_buffergeometry.ts
@@ -2,19 +2,19 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let raycaster, pointer;
+let raycaster: THREE.Raycaster, pointer: THREE.Vector2;
 
-let mesh, line;
+let mesh: THREE.Mesh, line: THREE.Line;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     //
 
@@ -49,8 +49,10 @@ function init() {
 
     const color = new THREE.Color();
 
-    const n = 800, n2 = n / 2; // triangles spread in the cube
-    const d = 120, d2 = d / 2; // individual triangle size
+    const n = 800,
+        n2 = n / 2; // triangles spread in the cube
+    const d = 120,
+        d2 = d / 2; // individual triangle size
 
     const pA = new THREE.Vector3();
     const pB = new THREE.Vector3();
@@ -120,9 +122,9 @@ function init() {
 
         // colors
 
-        const vx = (x / n) + 0.5;
-        const vy = (y / n) + 0.5;
-        const vz = (z / n) + 0.5;
+        const vx = x / n + 0.5;
+        const vy = y / n + 0.5;
+        const vz = z / n + 0.5;
 
         color.setRGB(vx, vy, vz);
 
@@ -145,7 +147,7 @@ function init() {
 
     geometry.computeBoundingSphere();
 
-    let material = new THREE.MeshPhongMaterial({
+    let material: THREE.Material = new THREE.MeshPhongMaterial({
         color: 0xaaaaaa,
         specular: 0xffffff,
         shininess: 250,
@@ -195,7 +197,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -221,10 +223,10 @@ function render() {
 
     if (intersects.length > 0) {
         const intersect = intersects[0];
-        const face = intersect.face;
+        const face = intersect.face!;
 
-        const linePosition = line.geometry.attributes.position;
-        const meshPosition = mesh.geometry.attributes.position;
+        const linePosition = line.geometry.attributes.position as THREE.BufferAttribute;
+        const meshPosition = mesh.geometry.attributes.position as THREE.BufferAttribute;
 
         linePosition.copyAt(0, meshPosition, face.a);
         linePosition.copyAt(1, meshPosition, face.b);
diff --git a/examples-testing/examples/webgl_interactive_cubes.ts b/examples-testing/examples/webgl_interactive_cubes.ts
index a187fb3..a7a46e4 100644
--- a/examples-testing/examples/webgl_interactive_cubes.ts
+++ b/examples-testing/examples/webgl_interactive_cubes.ts
@@ -2,10 +2,10 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let stats;
-let camera, scene, raycaster, renderer;
+let stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, raycaster: THREE.Raycaster, renderer: THREE.WebGLRenderer;
 
-let INTERSECTED;
+let INTERSECTED: (THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial> & { currentHex?: number }) | null;
 let theta = 0;
 
 const pointer = new THREE.Vector2();
@@ -68,7 +68,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: MouseEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -100,14 +100,14 @@ function render() {
 
     if (intersects.length > 0) {
         if (INTERSECTED != intersects[0].object) {
-            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
+            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex!);
 
-            INTERSECTED = intersects[0].object;
+            INTERSECTED = intersects[0].object as THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial>;
             INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
             INTERSECTED.material.emissive.setHex(0xff0000);
         }
     } else {
-        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
+        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex!);
 
         INTERSECTED = null;
     }
diff --git a/examples-testing/examples/webgl_interactive_cubes_gpu.ts b/examples-testing/examples/webgl_interactive_cubes_gpu.ts
index 6dd8f9d..67fa443 100644
--- a/examples-testing/examples/webgl_interactive_cubes_gpu.ts
+++ b/examples-testing/examples/webgl_interactive_cubes_gpu.ts
@@ -5,12 +5,12 @@ import Stats from "three/addons/libs/stats.module.js";
 import { TrackballControls } from "three/addons/controls/TrackballControls.js";
 import * as BufferGeometryUtils from "three/addons/utils/BufferGeometryUtils.js";
 
-let container, stats;
-let camera, controls, scene, renderer;
-let pickingTexture, pickingScene;
-let highlightBox;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, controls: TrackballControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let pickingTexture: THREE.WebGLRenderTarget, pickingScene: THREE.Scene;
+let highlightBox: THREE.Mesh;
 
-const pickingData = [];
+const pickingData: { position: THREE.Vector3; rotation: THREE.Euler; scale: THREE.Vector3 }[] = [];
 
 const pointer = new THREE.Vector2();
 const offset = new THREE.Vector3(10, 10, 10);
@@ -20,7 +20,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 1000;
@@ -74,7 +74,7 @@ function init() {
 					`,
     });
 
-    function applyId(geometry, id) {
+    function applyId(geometry: THREE.BoxGeometry, id: number) {
         const position = geometry.attributes.position;
         const array = new Int16Array(position.count);
         array.fill(id);
@@ -84,7 +84,7 @@ function init() {
         geometry.setAttribute("id", bufferAttribute);
     }
 
-    function applyVertexColors(geometry, color) {
+    function applyVertexColors(geometry: THREE.BoxGeometry, color: THREE.Color) {
         const position = geometry.attributes.position;
         const colors = [];
 
@@ -141,10 +141,7 @@ function init() {
     scene.add(new THREE.Mesh(mergedGeometry, defaultMaterial));
     pickingScene.add(new THREE.Mesh(mergedGeometry, pickingMaterial));
 
-    highlightBox = new THREE.Mesh(
-        new THREE.BoxGeometry(),
-        new THREE.MeshLambertMaterial({ color: 0xffff00 }),
-    );
+    highlightBox = new THREE.Mesh(new THREE.BoxGeometry(), new THREE.MeshLambertMaterial({ color: 0xffff00 }));
     scene.add(highlightBox);
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -169,7 +166,7 @@ function init() {
 
 //
 
-function onPointerMove(e) {
+function onPointerMove(e: PointerEvent) {
     pointer.x = e.clientX;
     pointer.y = e.clientY;
 }
diff --git a/examples-testing/examples/webgl_interactive_cubes_ortho.ts b/examples-testing/examples/webgl_interactive_cubes_ortho.ts
index 75eb849..dc10218 100644
--- a/examples-testing/examples/webgl_interactive_cubes_ortho.ts
+++ b/examples-testing/examples/webgl_interactive_cubes_ortho.ts
@@ -2,11 +2,11 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let stats;
-let camera, scene, raycaster, renderer;
+let stats: Stats;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, raycaster: THREE.Raycaster, renderer: THREE.WebGLRenderer;
 
 let theta = 0;
-let INTERSECTED;
+let INTERSECTED: (THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial> & { currentHex?: number }) | null;
 
 const pointer = new THREE.Vector2();
 const radius = 25;
@@ -18,8 +18,8 @@ animate();
 function init() {
     const aspect = window.innerWidth / window.innerHeight;
     camera = new THREE.OrthographicCamera(
-        frustumSize * aspect / -2,
-        frustumSize * aspect / 2,
+        (frustumSize * aspect) / -2,
+        (frustumSize * aspect) / 2,
         frustumSize / 2,
         frustumSize / -2,
         0.1,
@@ -73,8 +73,8 @@ function init() {
 function onWindowResize() {
     const aspect = window.innerWidth / window.innerHeight;
 
-    camera.left = -frustumSize * aspect / 2;
-    camera.right = frustumSize * aspect / 2;
+    camera.left = (-frustumSize * aspect) / 2;
+    camera.right = (frustumSize * aspect) / 2;
     camera.top = frustumSize / 2;
     camera.bottom = -frustumSize / 2;
 
@@ -83,7 +83,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -115,14 +115,14 @@ function render() {
 
     if (intersects.length > 0) {
         if (INTERSECTED != intersects[0].object) {
-            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
+            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex!);
 
-            INTERSECTED = intersects[0].object;
+            INTERSECTED = intersects[0].object as THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial>;
             INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
             INTERSECTED.material.emissive.setHex(0xff0000);
         }
     } else {
-        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
+        if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex!);
 
         INTERSECTED = null;
     }
diff --git a/examples-testing/examples/webgl_interactive_lines.ts b/examples-testing/examples/webgl_interactive_lines.ts
index ec59a0f..d30836d 100644
--- a/examples-testing/examples/webgl_interactive_lines.ts
+++ b/examples-testing/examples/webgl_interactive_lines.ts
@@ -2,8 +2,13 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
-let camera, scene, raycaster, renderer, parentTransform, sphereInter;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    raycaster: THREE.Raycaster,
+    renderer: THREE.WebGLRenderer,
+    parentTransform: THREE.Object3D,
+    sphereInter: THREE.Mesh;
 
 const pointer = new THREE.Vector2();
 const radius = 100;
@@ -22,7 +27,7 @@ function init() {
     info.style.width = "100%";
     info.style.textAlign = "center";
     info.innerHTML =
-        '<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - interactive lines';
+        "<a href=\"https://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a> webgl - interactive lines";
     container.appendChild(info);
 
     camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
@@ -121,7 +126,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
diff --git a/examples-testing/examples/webgl_interactive_points.ts b/examples-testing/examples/webgl_interactive_points.ts
index 104f075..f1a6db1 100644
--- a/examples-testing/examples/webgl_interactive_points.ts
+++ b/examples-testing/examples/webgl_interactive_points.ts
@@ -4,20 +4,20 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import * as BufferGeometryUtils from "three/addons/utils/BufferGeometryUtils.js";
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let particles;
+let particles: THREE.Points;
 
 const PARTICLE_SIZE = 20;
 
-let raycaster, intersects;
-let pointer, INTERSECTED;
+let raycaster: THREE.Raycaster, intersects;
+let pointer: THREE.Vector2, INTERSECTED: number | null;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     scene = new THREE.Scene();
 
@@ -26,7 +26,7 @@ function init() {
 
     //
 
-    let boxGeometry = new THREE.BoxGeometry(200, 200, 200, 16, 16, 16);
+    let boxGeometry: THREE.BufferGeometry = new THREE.BoxGeometry(200, 200, 200, 16, 16, 16);
 
     // if normal and uv attributes are not removed, mergeVertices() can't consolidate indentical vertices with different normal/uv data
 
@@ -39,8 +39,8 @@ function init() {
 
     const positionAttribute = boxGeometry.getAttribute("position");
 
-    const colors = [];
-    const sizes = [];
+    const colors: number[] = [];
+    const sizes: number[] = [];
 
     const color = new THREE.Color();
 
@@ -64,8 +64,8 @@ function init() {
             pointTexture: { value: new THREE.TextureLoader().load("textures/sprites/disc.png") },
             alphaTest: { value: 0.9 },
         },
-        vertexShader: document.getElementById("vertexshader").textContent,
-        fragmentShader: document.getElementById("fragmentshader").textContent,
+        vertexShader: document.getElementById("vertexshader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentshader")!.textContent!,
     });
 
     //
@@ -96,7 +96,7 @@ function init() {
     document.addEventListener("pointermove", onPointerMove);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -128,9 +128,9 @@ function render() {
 
     if (intersects.length > 0) {
         if (INTERSECTED != intersects[0].index) {
-            attributes.size.array[INTERSECTED] = PARTICLE_SIZE;
+            attributes.size.array[INTERSECTED!] = PARTICLE_SIZE;
 
-            INTERSECTED = intersects[0].index;
+            INTERSECTED = intersects[0].index!;
 
             attributes.size.array[INTERSECTED] = PARTICLE_SIZE * 1.25;
             attributes.size.needsUpdate = true;
diff --git a/examples-testing/examples/webgl_interactive_raycasting_points.ts b/examples-testing/examples/webgl_interactive_raycasting_points.ts
index cd1b0ce..127ce85 100644
--- a/examples-testing/examples/webgl_interactive_raycasting_points.ts
+++ b/examples-testing/examples/webgl_interactive_raycasting_points.ts
@@ -2,16 +2,16 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let renderer, scene, camera, stats;
-let pointclouds;
-let raycaster;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
+let pointclouds: THREE.Points[];
+let raycaster: THREE.Raycaster;
 let intersection = null;
 let spheresIndex = 0;
-let clock;
+let clock: THREE.Clock;
 let toggle = 0;
 
 const pointer = new THREE.Vector2();
-const spheres = [];
+const spheres: THREE.Mesh[] = [];
 
 const threshold = 0.1;
 const pointSize = 0.05;
@@ -22,7 +22,7 @@ const rotateY = new THREE.Matrix4().makeRotationY(0.005);
 init();
 animate();
 
-function generatePointCloudGeometry(color, width, length) {
+function generatePointCloudGeometry(color: THREE.Color, width: number, length: number) {
     const geometry = new THREE.BufferGeometry();
     const numPoints = width * length;
 
@@ -59,14 +59,14 @@ function generatePointCloudGeometry(color, width, length) {
     return geometry;
 }
 
-function generatePointcloud(color, width, length) {
+function generatePointcloud(color: THREE.Color, width: number, length: number) {
     const geometry = generatePointCloudGeometry(color, width, length);
     const material = new THREE.PointsMaterial({ size: pointSize, vertexColors: true });
 
     return new THREE.Points(geometry, material);
 }
 
-function generateIndexedPointcloud(color, width, length) {
+function generateIndexedPointcloud(color: THREE.Color, width: number, length: number) {
     const geometry = generatePointCloudGeometry(color, width, length);
     const numPoints = width * length;
     const indices = new Uint16Array(numPoints);
@@ -87,7 +87,7 @@ function generateIndexedPointcloud(color, width, length) {
     return new THREE.Points(geometry, material);
 }
 
-function generateIndexedWithOffsetPointcloud(color, width, length) {
+function generateIndexedWithOffsetPointcloud(color: THREE.Color, width: number, length: number) {
     const geometry = generatePointCloudGeometry(color, width, length);
     const numPoints = width * length;
     const indices = new Uint16Array(numPoints);
@@ -110,7 +110,7 @@ function generateIndexedWithOffsetPointcloud(color, width, length) {
 }
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     scene = new THREE.Scene();
 
@@ -174,7 +174,7 @@ function init() {
     document.addEventListener("pointermove", onPointerMove);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -200,7 +200,7 @@ function render() {
     raycaster.setFromCamera(pointer, camera);
 
     const intersections = raycaster.intersectObjects(pointclouds, false);
-    intersection = (intersections.length) > 0 ? intersections[0] : null;
+    intersection = intersections.length > 0 ? intersections[0] : null;
 
     if (toggle > 0.02 && intersection !== null) {
         spheres[spheresIndex].position.copy(intersection.point);
diff --git a/examples-testing/examples/webgl_interactive_voxelpainter.ts b/examples-testing/examples/webgl_interactive_voxelpainter.ts
index 3508271..a363dd3 100644
--- a/examples-testing/examples/webgl_interactive_voxelpainter.ts
+++ b/examples-testing/examples/webgl_interactive_voxelpainter.ts
@@ -1,13 +1,15 @@
 import * as THREE from "three";
 
-let camera, scene, renderer;
-let plane;
-let pointer, raycaster, isShiftDown = false;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let plane: THREE.Mesh;
+let pointer: THREE.Vector2,
+    raycaster: THREE.Raycaster,
+    isShiftDown = false;
 
-let rollOverMesh, rollOverMaterial;
-let cubeGeo, cubeMaterial;
+let rollOverMesh: THREE.Mesh, rollOverMaterial: THREE.MeshBasicMaterial;
+let cubeGeo: THREE.BoxGeometry, cubeMaterial: THREE.MeshLambertMaterial;
 
-const objects = [];
+const objects: THREE.Object3D[] = [];
 
 init();
 render();
@@ -85,7 +87,7 @@ function onWindowResize() {
     render();
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
 
     raycaster.setFromCamera(pointer, camera);
@@ -95,14 +97,14 @@ function onPointerMove(event) {
     if (intersects.length > 0) {
         const intersect = intersects[0];
 
-        rollOverMesh.position.copy(intersect.point).add(intersect.face.normal);
+        rollOverMesh.position.copy(intersect.point).add(intersect.face!.normal);
         rollOverMesh.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
 
         render();
     }
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     pointer.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
 
     raycaster.setFromCamera(pointer, camera);
@@ -124,7 +126,7 @@ function onPointerDown(event) {
             // create cube
         } else {
             const voxel = new THREE.Mesh(cubeGeo, cubeMaterial);
-            voxel.position.copy(intersect.point).add(intersect.face.normal);
+            voxel.position.copy(intersect.point).add(intersect.face!.normal);
             voxel.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
             scene.add(voxel);
 
@@ -135,7 +137,7 @@ function onPointerDown(event) {
     }
 }
 
-function onDocumentKeyDown(event) {
+function onDocumentKeyDown(event: KeyboardEvent) {
     switch (event.keyCode) {
         case 16:
             isShiftDown = true;
@@ -143,7 +145,7 @@ function onDocumentKeyDown(event) {
     }
 }
 
-function onDocumentKeyUp(event) {
+function onDocumentKeyUp(event: KeyboardEvent) {
     switch (event.keyCode) {
         case 16:
             isShiftDown = false;
diff --git a/examples-testing/examples/webgl_layers.ts b/examples-testing/examples/webgl_layers.ts
index 25d73c1..1991e16 100644
--- a/examples-testing/examples/webgl_layers.ts
+++ b/examples-testing/examples/webgl_layers.ts
@@ -1,10 +1,10 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let theta = 0;
 const radius = 5;
@@ -66,23 +66,23 @@ function init() {
     container.appendChild(stats.dom);
 
     const layers = {
-        "toggle red": function () {
+        "toggle red": function() {
             camera.layers.toggle(0);
         },
 
-        "toggle green": function () {
+        "toggle green": function() {
             camera.layers.toggle(1);
         },
 
-        "toggle blue": function () {
+        "toggle blue": function() {
             camera.layers.toggle(2);
         },
 
-        "enable all": function () {
+        "enable all": function() {
             camera.layers.enableAll();
         },
 
-        "disable all": function () {
+        "disable all": function() {
             camera.layers.disableAll();
         },
     };
diff --git a/examples-testing/examples/webgl_lensflares.ts b/examples-testing/examples/webgl_lensflares.ts
index 204a187..4c5e465 100644
--- a/examples-testing/examples/webgl_lensflares.ts
+++ b/examples-testing/examples/webgl_lensflares.ts
@@ -5,10 +5,10 @@ import Stats from "three/addons/libs/stats.module.js";
 import { FlyControls } from "three/addons/controls/FlyControls.js";
 import { Lensflare, LensflareElement } from "three/addons/objects/Lensflare.js";
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controls: FlyControls;
 
 const clock = new THREE.Clock();
 
@@ -71,7 +71,7 @@ function init() {
     addLight(0.08, 0.8, 0.5, 0, 0, -1000);
     addLight(0.995, 0.5, 0.9, 5000, 5000, -1000);
 
-    function addLight(h, s, l, x, y, z) {
+    function addLight(h: number, s: number, l: number, x: number, y: number, z: number) {
         const light = new THREE.PointLight(0xffffff, 1.5, 2000, 0);
         light.color.setHSL(h, s, l);
         light.position.set(x, y, z);
diff --git a/examples-testing/examples/webgl_lightprobe.ts b/examples-testing/examples/webgl_lightprobe.ts
index 7bef451..a4b772e 100644
--- a/examples-testing/examples/webgl_lightprobe.ts
+++ b/examples-testing/examples/webgl_lightprobe.ts
@@ -5,12 +5,15 @@ import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { LightProbeGenerator } from "three/addons/lights/LightProbeGenerator.js";
 
-let mesh, renderer, scene, camera;
+let mesh: THREE.Mesh<THREE.SphereGeometry, THREE.MeshStandardMaterial>,
+    renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera;
 
 let gui;
 
-let lightProbe;
-let directionalLight;
+let lightProbe: THREE.LightProbe;
+let directionalLight: THREE.DirectionalLight;
 
 // linear color space
 const API = {
@@ -55,7 +58,7 @@ function init() {
     scene.add(directionalLight);
 
     // envmap
-    const genCubeUrls = function (prefix, postfix) {
+    const genCubeUrls = function(prefix: string, postfix: string) {
         return [
             prefix + "px" + postfix,
             prefix + "nx" + postfix,
@@ -68,13 +71,13 @@ function init() {
 
     const urls = genCubeUrls("textures/cube/pisa/", ".png");
 
-    new THREE.CubeTextureLoader().load(urls, function (cubeTexture) {
+    new THREE.CubeTextureLoader().load(urls, function(cubeTexture) {
         scene.background = cubeTexture;
 
         lightProbe.copy(LightProbeGenerator.fromCubeTexture(cubeTexture));
 
         const geometry = new THREE.SphereGeometry(5, 64, 32);
-        //const geometry = new THREE.TorusKnotGeometry( 4, 1.5, 256, 32, 2, 3 );
+        // const geometry = new THREE.TorusKnotGeometry( 4, 1.5, 256, 32, 2, 3 );
 
         const material = new THREE.MeshStandardMaterial({
             color: 0xffffff,
@@ -96,21 +99,21 @@ function init() {
 
     gui.add(API, "lightProbeIntensity", 0, 1, 0.02)
         .name("light probe")
-        .onChange(function () {
+        .onChange(function() {
             lightProbe.intensity = API.lightProbeIntensity;
             render();
         });
 
     gui.add(API, "directionalLightIntensity", 0, 1, 0.02)
         .name("directional light")
-        .onChange(function () {
+        .onChange(function() {
             directionalLight.intensity = API.directionalLightIntensity;
             render();
         });
 
     gui.add(API, "envMapIntensity", 0, 1, 0.02)
         .name("envMap")
-        .onChange(function () {
+        .onChange(function() {
             mesh.material.envMapIntensity = API.envMapIntensity;
             render();
         });
diff --git a/examples-testing/examples/webgl_lightprobe_cubecamera.ts b/examples-testing/examples/webgl_lightprobe_cubecamera.ts
index da3912f..1acc05d 100644
--- a/examples-testing/examples/webgl_lightprobe_cubecamera.ts
+++ b/examples-testing/examples/webgl_lightprobe_cubecamera.ts
@@ -4,9 +4,9 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { LightProbeHelper } from "three/addons/helpers/LightProbeHelper.js";
 import { LightProbeGenerator } from "three/addons/lights/LightProbeGenerator.js";
 
-let renderer, scene, camera, cubeCamera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, cubeCamera: THREE.CubeCamera;
 
-let lightProbe;
+let lightProbe: THREE.LightProbe;
 
 init();
 
@@ -40,7 +40,7 @@ function init() {
     scene.add(lightProbe);
 
     // envmap
-    const genCubeUrls = function (prefix, postfix) {
+    const genCubeUrls = function(prefix: string, postfix: string) {
         return [
             prefix + "px" + postfix,
             prefix + "nx" + postfix,
@@ -53,7 +53,7 @@ function init() {
 
     const urls = genCubeUrls("textures/cube/pisa/", ".png");
 
-    new THREE.CubeTextureLoader().load(urls, function (cubeTexture) {
+    new THREE.CubeTextureLoader().load(urls, function(cubeTexture) {
         scene.background = cubeTexture;
 
         cubeCamera.update(renderer, scene);
diff --git a/examples-testing/examples/webgl_lights_hemisphere.ts b/examples-testing/examples/webgl_lights_hemisphere.ts
index 4dbdd0f..7f917a8 100644
--- a/examples-testing/examples/webgl_lights_hemisphere.ts
+++ b/examples-testing/examples/webgl_lights_hemisphere.ts
@@ -1,13 +1,13 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-let camera, scene, renderer;
-const mixers = [];
-let stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+const mixers: THREE.AnimationMixer[] = [];
+let stats: Stats;
 
 const clock = new THREE.Clock();
 
@@ -15,7 +15,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 5000);
     camera.position.set(0, 0, 250);
@@ -75,13 +75,13 @@ function init() {
 
     // SKYDOME
 
-    const vertexShader = document.getElementById("vertexShader").textContent;
-    const fragmentShader = document.getElementById("fragmentShader").textContent;
+    const vertexShader = document.getElementById("vertexShader")!.textContent!;
+    const fragmentShader = document.getElementById("fragmentShader")!.textContent!;
     const uniforms = {
-        "topColor": { value: new THREE.Color(0x0077ff) },
-        "bottomColor": { value: new THREE.Color(0xffffff) },
-        "offset": { value: 33 },
-        "exponent": { value: 0.6 },
+        topColor: { value: new THREE.Color(0x0077ff) },
+        bottomColor: { value: new THREE.Color(0xffffff) },
+        offset: { value: 33 },
+        exponent: { value: 0.6 },
     };
     uniforms["topColor"].value.copy(hemiLight.color);
 
@@ -102,7 +102,7 @@ function init() {
 
     const loader = new GLTFLoader();
 
-    loader.load("models/gltf/Flamingo.glb", function (gltf) {
+    loader.load("models/gltf/Flamingo.glb", function(gltf) {
         const mesh = gltf.scene.children[0];
 
         const s = 0.35;
@@ -136,11 +136,11 @@ function init() {
     //
 
     const params = {
-        toggleHemisphereLight: function () {
+        toggleHemisphereLight: function() {
             hemiLight.visible = !hemiLight.visible;
             hemiLightHelper.visible = !hemiLightHelper.visible;
         },
-        toggleDirectionalLight: function () {
+        toggleDirectionalLight: function() {
             dirLight.visible = !dirLight.visible;
             dirLightHelper.visible = !dirLightHelper.visible;
         },
diff --git a/examples-testing/examples/webgl_lights_physical.ts b/examples-testing/examples/webgl_lights_physical.ts
index 4709795..910f9de 100644
--- a/examples-testing/examples/webgl_lights_physical.ts
+++ b/examples-testing/examples/webgl_lights_physical.ts
@@ -1,17 +1,23 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let camera, scene, renderer, bulbLight, bulbMat, hemiLight, stats;
-let ballMat, cubeMat, floorMat;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    bulbLight: THREE.PointLight,
+    bulbMat: THREE.MeshStandardMaterial,
+    hemiLight: THREE.HemisphereLight,
+    stats: Stats;
+let ballMat: THREE.MeshStandardMaterial, cubeMat: THREE.MeshStandardMaterial, floorMat: THREE.MeshStandardMaterial;
 
 let previousShadowMap = false;
 
 // ref for lumens: http://www.power-sure.com/lumens.htm
-const bulbLuminousPowers = {
+const bulbLuminousPowers: Record<string, number> = {
     "110000 lm (1000W)": 110000,
     "3500 lm (300W)": 3500,
     "1700 lm (100W)": 1700,
@@ -19,11 +25,11 @@ const bulbLuminousPowers = {
     "400 lm (40W)": 400,
     "180 lm (25W)": 180,
     "20 lm (4W)": 20,
-    "Off": 0,
+    Off: 0,
 };
 
 // ref for solar irradiances: https://en.wikipedia.org/wiki/Lux
-const hemiLuminousIrradiances = {
+const hemiLuminousIrradiances: Record<string, number> = {
     "0.0001 lx (Moonless Night)": 0.0001,
     "0.002 lx (Night Airglow)": 0.002,
     "0.5 lx (Full Moon)": 0.5,
@@ -48,7 +54,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     stats = new Stats();
     container.appendChild(stats.dom);
@@ -83,7 +89,7 @@ function init() {
         bumpScale: 1,
     });
     const textureLoader = new THREE.TextureLoader();
-    textureLoader.load("textures/hardwood2_diffuse.jpg", function (map) {
+    textureLoader.load("textures/hardwood2_diffuse.jpg", function(map) {
         map.wrapS = THREE.RepeatWrapping;
         map.wrapT = THREE.RepeatWrapping;
         map.anisotropy = 4;
@@ -92,7 +98,7 @@ function init() {
         floorMat.map = map;
         floorMat.needsUpdate = true;
     });
-    textureLoader.load("textures/hardwood2_bump.jpg", function (map) {
+    textureLoader.load("textures/hardwood2_bump.jpg", function(map) {
         map.wrapS = THREE.RepeatWrapping;
         map.wrapT = THREE.RepeatWrapping;
         map.anisotropy = 4;
@@ -100,7 +106,7 @@ function init() {
         floorMat.bumpMap = map;
         floorMat.needsUpdate = true;
     });
-    textureLoader.load("textures/hardwood2_roughness.jpg", function (map) {
+    textureLoader.load("textures/hardwood2_roughness.jpg", function(map) {
         map.wrapS = THREE.RepeatWrapping;
         map.wrapT = THREE.RepeatWrapping;
         map.anisotropy = 4;
@@ -115,7 +121,7 @@ function init() {
         bumpScale: 1,
         metalness: 0.2,
     });
-    textureLoader.load("textures/brick_diffuse.jpg", function (map) {
+    textureLoader.load("textures/brick_diffuse.jpg", function(map) {
         map.wrapS = THREE.RepeatWrapping;
         map.wrapT = THREE.RepeatWrapping;
         map.anisotropy = 4;
@@ -124,7 +130,7 @@ function init() {
         cubeMat.map = map;
         cubeMat.needsUpdate = true;
     });
-    textureLoader.load("textures/brick_bump.jpg", function (map) {
+    textureLoader.load("textures/brick_bump.jpg", function(map) {
         map.wrapS = THREE.RepeatWrapping;
         map.wrapT = THREE.RepeatWrapping;
         map.anisotropy = 4;
@@ -138,13 +144,13 @@ function init() {
         roughness: 0.5,
         metalness: 1.0,
     });
-    textureLoader.load("textures/planets/earth_atmos_2048.jpg", function (map) {
+    textureLoader.load("textures/planets/earth_atmos_2048.jpg", function(map) {
         map.anisotropy = 4;
         map.colorSpace = THREE.SRGBColorSpace;
         ballMat.map = map;
         ballMat.needsUpdate = true;
     });
-    textureLoader.load("textures/planets/earth_specular_2048.jpg", function (map) {
+    textureLoader.load("textures/planets/earth_specular_2048.jpg", function(map) {
         map.anisotropy = 4;
         map.colorSpace = THREE.SRGBColorSpace;
         ballMat.metalnessMap = map;
diff --git a/examples-testing/examples/webgl_lights_pointlights.ts b/examples-testing/examples/webgl_lights_pointlights.ts
index 35b86b5..fc949ad 100644
--- a/examples-testing/examples/webgl_lights_pointlights.ts
+++ b/examples-testing/examples/webgl_lights_pointlights.ts
@@ -4,7 +4,15 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
 
-let camera, scene, renderer, light1, light2, light3, light4, object, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    light1: THREE.PointLight,
+    light2: THREE.PointLight,
+    light3: THREE.PointLight,
+    light4: THREE.PointLight,
+    object: THREE.Group,
+    stats: Stats;
 
 const clock = new THREE.Clock();
 
@@ -17,10 +25,10 @@ function init() {
 
     scene = new THREE.Scene();
 
-    //model
+    // model
 
     const loader = new OBJLoader();
-    loader.load("models/obj/walt/WaltHead.obj", function (obj) {
+    loader.load("models/obj/walt/WaltHead.obj", function(obj) {
         object = obj;
         object.scale.multiplyScalar(0.8);
         object.position.y = -30;
@@ -29,7 +37,7 @@ function init() {
 
     const sphere = new THREE.SphereGeometry(0.5, 16, 8);
 
-    //lights
+    // lights
 
     light1 = new THREE.PointLight(0xff0040, 400);
     light1.add(new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({ color: 0xff0040 })));
@@ -47,14 +55,14 @@ function init() {
     light4.add(new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({ color: 0xffaa00 })));
     scene.add(light4);
 
-    //renderer
+    // renderer
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
     document.body.appendChild(renderer.domElement);
 
-    //stats
+    // stats
 
     stats = new Stats();
     document.body.appendChild(stats.dom);
diff --git a/examples-testing/examples/webgl_lights_rectarealight.ts b/examples-testing/examples/webgl_lights_rectarealight.ts
index cf73b23..28972cf 100644
--- a/examples-testing/examples/webgl_lights_rectarealight.ts
+++ b/examples-testing/examples/webgl_lights_rectarealight.ts
@@ -6,8 +6,8 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { RectAreaLightHelper } from "three/addons/helpers/RectAreaLightHelper.js";
 import { RectAreaLightUniformsLib } from "three/addons/lights/RectAreaLightUniformsLib.js";
 
-let renderer, scene, camera;
-let stats, meshKnot;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let stats: Stats, meshKnot: THREE.Mesh;
 
 init();
 
@@ -70,7 +70,7 @@ function onWindowResize() {
     camera.updateProjectionMatrix();
 }
 
-function animation(time) {
+function animation(time: DOMHighResTimeStamp) {
     meshKnot.rotation.y = time / 1000;
 
     renderer.render(scene, camera);
diff --git a/examples-testing/examples/webgl_lights_spotlight.ts b/examples-testing/examples/webgl_lights_spotlight.ts
index 077cd9f..942fc1b 100644
--- a/examples-testing/examples/webgl_lights_spotlight.ts
+++ b/examples-testing/examples/webgl_lights_spotlight.ts
@@ -2,12 +2,12 @@ import * as THREE from "three";
 
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-import { PLYLoader } from "three/addons/loaders/PLYLoader.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { PLYLoader } from "three/addons/loaders/PLYLoader.js";
 
-let renderer, scene, camera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
 
-let spotLight, lightHelper;
+let spotLight: THREE.SpotLight, lightHelper: THREE.SpotLightHelper;
 
 init();
 
@@ -43,7 +43,7 @@ function init() {
     const loader = new THREE.TextureLoader().setPath("textures/");
     const filenames = ["disturb.jpg", "colors.png", "uv_grid_opengl.jpg"];
 
-    const textures = { none: null };
+    const textures: Record<string, THREE.Texture | null> = { none: null };
 
     for (let i = 0; i < filenames.length; i++) {
         const filename = filenames[i];
@@ -88,7 +88,7 @@ function init() {
 
     //
 
-    new PLYLoader().load("models/ply/binary/Lucy100k.ply", function (geometry) {
+    new PLYLoader().load("models/ply/binary/Lucy100k.ply", function(geometry) {
         geometry.scale(0.0024, 0.0024, 0.0024);
         geometry.computeVertexNormals();
 
@@ -120,44 +120,44 @@ function init() {
         shadows: true,
     };
 
-    gui.add(params, "map", textures).onChange(function (val) {
+    gui.add(params, "map", textures).onChange(function(val) {
         spotLight.map = val;
     });
 
-    gui.addColor(params, "color").onChange(function (val) {
+    gui.addColor(params, "color").onChange(function(val) {
         spotLight.color.setHex(val);
     });
 
-    gui.add(params, "intensity", 0, 500).onChange(function (val) {
+    gui.add(params, "intensity", 0, 500).onChange(function(val) {
         spotLight.intensity = val;
     });
 
-    gui.add(params, "distance", 50, 200).onChange(function (val) {
+    gui.add(params, "distance", 50, 200).onChange(function(val) {
         spotLight.distance = val;
     });
 
-    gui.add(params, "angle", 0, Math.PI / 3).onChange(function (val) {
+    gui.add(params, "angle", 0, Math.PI / 3).onChange(function(val) {
         spotLight.angle = val;
     });
 
-    gui.add(params, "penumbra", 0, 1).onChange(function (val) {
+    gui.add(params, "penumbra", 0, 1).onChange(function(val) {
         spotLight.penumbra = val;
     });
 
-    gui.add(params, "decay", 1, 2).onChange(function (val) {
+    gui.add(params, "decay", 1, 2).onChange(function(val) {
         spotLight.decay = val;
     });
 
-    gui.add(params, "focus", 0, 1).onChange(function (val) {
+    gui.add(params, "focus", 0, 1).onChange(function(val) {
         spotLight.shadow.focus = val;
     });
 
-    gui.add(params, "shadows").onChange(function (val) {
+    gui.add(params, "shadows").onChange(function(val) {
         renderer.shadowMap.enabled = val;
 
-        scene.traverse(function (child) {
-            if (child.material) {
-                child.material.needsUpdate = true;
+        scene.traverse(function(child) {
+            if ((child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material) {
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.needsUpdate = true;
             }
         });
     });
diff --git a/examples-testing/examples/webgl_lights_spotlights.ts b/examples-testing/examples/webgl_lights_spotlights.ts
index 48d99c2..8f77971 100644
--- a/examples-testing/examples/webgl_lights_spotlights.ts
+++ b/examples-testing/examples/webgl_lights_spotlights.ts
@@ -1,6 +1,6 @@
 import * as THREE from "three";
-import TWEEN from "three/addons/libs/tween.module.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import TWEEN from "three/addons/libs/tween.module.js";
 
 const renderer = new THREE.WebGLRenderer({ antialias: true });
 renderer.setPixelRatio(window.devicePixelRatio);
@@ -24,11 +24,11 @@ const mshBox = new THREE.Mesh(geoBox, matBox);
 
 const ambient = new THREE.AmbientLight(0x444444);
 
-const spotLight1 = createSpotlight(0xFF7F00);
-const spotLight2 = createSpotlight(0x00FF7F);
-const spotLight3 = createSpotlight(0x7F00FF);
+const spotLight1 = createSpotlight(0xff7f00);
+const spotLight2 = createSpotlight(0x00ff7f);
+const spotLight3 = createSpotlight(0x7f00ff);
 
-let lightHelper1, lightHelper2, lightHelper3;
+let lightHelper1: THREE.SpotLightHelper, lightHelper2: THREE.SpotLightHelper, lightHelper3: THREE.SpotLightHelper;
 
 function init() {
     renderer.shadowMap.enabled = true;
@@ -67,7 +67,7 @@ function init() {
     controls.update();
 }
 
-function createSpotlight(color) {
+function createSpotlight(color: number) {
     const newObj = new THREE.SpotLight(color, 10);
 
     newObj.castShadow = true;
@@ -85,19 +85,29 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function tween(light) {
-    new TWEEN.Tween(light).to({
-        angle: (Math.random() * 0.7) + 0.1,
-        penumbra: Math.random() + 1,
-    }, Math.random() * 3000 + 2000)
-        .easing(TWEEN.Easing.Quadratic.Out).start();
-
-    new TWEEN.Tween(light.position).to({
-        x: (Math.random() * 3) - 1.5,
-        y: (Math.random() * 1) + 1.5,
-        z: (Math.random() * 3) - 1.5,
-    }, Math.random() * 3000 + 2000)
-        .easing(TWEEN.Easing.Quadratic.Out).start();
+function tween(light: THREE.SpotLight) {
+    new TWEEN.Tween(light)
+        .to(
+            {
+                angle: Math.random() * 0.7 + 0.1,
+                penumbra: Math.random() + 1,
+            },
+            Math.random() * 3000 + 2000,
+        )
+        .easing(TWEEN.Easing.Quadratic.Out)
+        .start();
+
+    new TWEEN.Tween(light.position)
+        .to(
+            {
+                x: Math.random() * 3 - 1.5,
+                y: Math.random() * 1 + 1.5,
+                z: Math.random() * 3 - 1.5,
+            },
+            Math.random() * 3000 + 2000,
+        )
+        .easing(TWEEN.Easing.Quadratic.Out)
+        .start();
 }
 
 function animate() {
diff --git a/examples-testing/examples/webgl_lines_colors.ts b/examples-testing/examples/webgl_lines_colors.ts
index 70d3c50..e163dcc 100644
--- a/examples-testing/examples/webgl_lines_colors.ts
+++ b/examples-testing/examples/webgl_lines_colors.ts
@@ -2,12 +2,13 @@ import * as THREE from "three";
 
 import * as GeometryUtils from "three/addons/utils/GeometryUtils.js";
 
-let mouseX = 0, mouseY = 0;
+let mouseX = 0,
+    mouseY = 0;
 
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -106,9 +107,10 @@ function init() {
     const material = new THREE.LineBasicMaterial({ color: 0xffffff, vertexColors: true });
 
     let line, p;
-    const scale = 0.3, d = 225;
+    const scale = 0.3,
+        d = 225;
 
-    const parameters = [
+    const parameters: [THREE.Material, number, [number, number, number], THREE.BufferGeometry][] = [
         [material, scale * 1.5, [-d, -d / 2, 0], geometry1],
         [material, scale * 1.5, [0, -d / 2, 0], geometry2],
         [material, scale * 1.5, [d, -d / 2, 0], geometry3],
@@ -150,7 +152,7 @@ function onWindowResize() {
 
 //
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
@@ -175,7 +177,7 @@ function render() {
     for (let i = 0; i < scene.children.length; i++) {
         const object = scene.children[i];
 
-        if (object.isLine) {
+        if ((object as THREE.Line).isLine) {
             object.rotation.y = time * (i % 2 ? 1 : -1);
         }
     }
diff --git a/examples-testing/examples/webgl_lines_dashed.ts b/examples-testing/examples/webgl_lines_dashed.ts
index f5c0871..c4f54aa 100644
--- a/examples-testing/examples/webgl_lines_dashed.ts
+++ b/examples-testing/examples/webgl_lines_dashed.ts
@@ -4,10 +4,11 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import * as GeometryUtils from "three/addons/utils/GeometryUtils.js";
 
-let renderer, scene, camera, stats;
-const objects = [];
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
+const objects: THREE.Object3D[] = [];
 
-const WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
+const WIDTH = window.innerWidth,
+    HEIGHT = window.innerHeight;
 
 init();
 animate();
@@ -62,8 +63,8 @@ function init() {
     window.addEventListener("resize", onWindowResize);
 }
 
-function box(width, height, depth) {
-    width = width * 0.5, height = height * 0.5, depth = depth * 0.5;
+function box(width: number, height: number, depth: number) {
+    (width = width * 0.5), (height = height * 0.5), (depth = depth * 0.5);
 
     const geometry = new THREE.BufferGeometry();
     const position = [];
@@ -165,8 +166,8 @@ function animate() {
 function render() {
     const time = Date.now() * 0.001;
 
-    scene.traverse(function (object) {
-        if (object.isLine) {
+    scene.traverse(function(object) {
+        if ((object as THREE.Line).isLine) {
             object.rotation.x = 0.25 * time;
             object.rotation.y = 0.25 * time;
         }
diff --git a/examples-testing/examples/webgl_lines_fat.ts b/examples-testing/examples/webgl_lines_fat.ts
index 725b7a8..9e4f578 100644
--- a/examples-testing/examples/webgl_lines_fat.ts
+++ b/examples-testing/examples/webgl_lines_fat.ts
@@ -3,22 +3,27 @@ import * as THREE from "three";
 import Stats from "three/addons/libs/stats.module.js";
 import { GPUStatsPanel } from "three/addons/utils/GPUStatsPanel.js";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { Line2 } from "three/addons/lines/Line2.js";
-import { LineMaterial } from "three/addons/lines/LineMaterial.js";
 import { LineGeometry } from "three/addons/lines/LineGeometry.js";
+import { LineMaterial } from "three/addons/lines/LineMaterial.js";
 import * as GeometryUtils from "three/addons/utils/GeometryUtils.js";
 
-let line, renderer, scene, camera, camera2, controls;
-let line1;
-let matLine, matLineBasic, matLineDashed;
-let stats, gpuPanel;
-let gui;
+let line: Line2,
+    renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    camera2: THREE.PerspectiveCamera,
+    controls: OrbitControls;
+let line1: THREE.Line;
+let matLine: LineMaterial, matLineBasic: THREE.LineBasicMaterial, matLineDashed: THREE.LineDashedMaterial;
+let stats: Stats, gpuPanel: GPUStatsPanel;
+let gui: GUI;
 
 // viewport
-let insetWidth;
-let insetHeight;
+let insetWidth: number;
+let insetHeight: number;
 
 init();
 animate();
@@ -76,7 +81,7 @@ function init() {
         linewidth: 5, // in world units with size attenuation, pixels otherwise
         vertexColors: true,
 
-        //resolution:  // to be set by renderer, eventually
+        // resolution:  // to be set by renderer, eventually
         dashed: false,
         alphaToCoverage: true,
     });
@@ -179,14 +184,14 @@ function initGui() {
     const param = {
         "line type": 0,
         "world units": false,
-        "width": 5,
-        "alphaToCoverage": true,
-        "dashed": false,
+        width: 5,
+        alphaToCoverage: true,
+        dashed: false,
         "dash scale": 1,
         "dash / gap": 1,
     };
 
-    gui.add(param, "line type", { "LineGeometry": 0, "gl.LINE": 1 }).onChange(function (val) {
+    gui.add(param, "line type", { LineGeometry: 0, "gl.LINE": 1 }).onChange(function(val) {
         switch (val) {
             case 0:
                 line.visible = true;
@@ -204,30 +209,30 @@ function initGui() {
         }
     });
 
-    gui.add(param, "world units").onChange(function (val) {
+    gui.add(param, "world units").onChange(function(val) {
         matLine.worldUnits = val;
         matLine.needsUpdate = true;
     });
 
-    gui.add(param, "width", 1, 10).onChange(function (val) {
+    gui.add(param, "width", 1, 10).onChange(function(val) {
         matLine.linewidth = val;
     });
 
-    gui.add(param, "alphaToCoverage").onChange(function (val) {
+    gui.add(param, "alphaToCoverage").onChange(function(val) {
         matLine.alphaToCoverage = val;
     });
 
-    gui.add(param, "dashed").onChange(function (val) {
+    gui.add(param, "dashed").onChange(function(val) {
         matLine.dashed = val;
         line1.material = val ? matLineDashed : matLineBasic;
     });
 
-    gui.add(param, "dash scale", 0.5, 2, 0.1).onChange(function (val) {
+    gui.add(param, "dash scale", 0.5, 2, 0.1).onChange(function(val) {
         matLine.dashScale = val;
         matLineDashed.scale = val;
     });
 
-    gui.add(param, "dash / gap", { "2 : 1": 0, "1 : 1": 1, "1 : 2": 2 }).onChange(function (val) {
+    gui.add(param, "dash / gap", { "2 : 1": 0, "1 : 1": 1, "1 : 2": 2 }).onChange(function(val) {
         switch (val) {
             case 0:
                 matLine.dashSize = 2;
diff --git a/examples-testing/examples/webgl_lines_fat_raycasting.ts b/examples-testing/examples/webgl_lines_fat_raycasting.ts
index cc8441f..7fbe928 100644
--- a/examples-testing/examples/webgl_lines_fat_raycasting.ts
+++ b/examples-testing/examples/webgl_lines_fat_raycasting.ts
@@ -3,20 +3,21 @@ import * as THREE from "three";
 import Stats from "three/addons/libs/stats.module.js";
 import { GPUStatsPanel } from "three/addons/utils/GPUStatsPanel.js";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import { Line2 } from "three/addons/lines/Line2.js";
+import { LineGeometry } from "three/addons/lines/LineGeometry.js";
 import { LineMaterial } from "three/addons/lines/LineMaterial.js";
 import { LineSegments2 } from "three/addons/lines/LineSegments2.js";
 import { LineSegmentsGeometry } from "three/addons/lines/LineSegmentsGeometry.js";
-import { Line2 } from "three/addons/lines/Line2.js";
-import { LineGeometry } from "three/addons/lines/LineGeometry.js";
 
-let line, thresholdLine, segments, thresholdSegments;
-let renderer, scene, camera, controls;
-let sphereInter, sphereOnLine;
-let stats, gpuPanel;
-let gui;
-let clock;
+let line: Line2, thresholdLine: Line2, segments: LineSegments2, thresholdSegments: LineSegments2;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
+let sphereInter: THREE.Mesh<THREE.SphereGeometry, THREE.MeshBasicMaterial>,
+    sphereOnLine: THREE.Mesh<THREE.SphereGeometry, THREE.MeshBasicMaterial>;
+let stats: Stats, gpuPanel: GPUStatsPanel;
+let gui: GUI;
+let clock: THREE.Clock;
 
 const color = new THREE.Color();
 
@@ -24,8 +25,7 @@ const pointer = new THREE.Vector2(Infinity, Infinity);
 
 const raycaster = new THREE.Raycaster();
 
-raycaster.params.Line2 = {};
-raycaster.params.Line2.threshold = 0;
+raycaster.params.Line2 = { threshold: 0 };
 
 const matLine = new LineMaterial({
     color: 0xffffff,
@@ -33,7 +33,7 @@ const matLine = new LineMaterial({
     worldUnits: true,
     vertexColors: true,
 
-    //resolution:  // to be set by renderer, eventually
+    // resolution:  // to be set by renderer, eventually
     alphaToCoverage: true,
 });
 
@@ -46,18 +46,18 @@ const matThresholdLine = new LineMaterial({
     opacity: 0.2,
     depthTest: false,
     visible: false,
-    //resolution:  // to be set by renderer, eventually
+    // resolution:  // to be set by renderer, eventually
 });
 
 const params = {
     "line type": 0,
     "world units": matLine.worldUnits,
     "visualize threshold": matThresholdLine.visible,
-    "width": matLine.linewidth,
-    "alphaToCoverage": matLine.alphaToCoverage,
-    "threshold": raycaster.params.Line2.threshold,
-    "translation": raycaster.params.Line2.threshold,
-    "animate": true,
+    width: matLine.linewidth,
+    alphaToCoverage: matLine.alphaToCoverage,
+    threshold: raycaster.params.Line2.threshold,
+    translation: raycaster.params.Line2.threshold,
+    animate: true,
 };
 
 init();
@@ -179,7 +179,7 @@ function onWindowResize() {
     matThresholdLine.resolution.set(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
     pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
 }
@@ -212,9 +212,9 @@ function animate() {
         sphereOnLine.visible = true;
 
         sphereInter.position.copy(intersects[0].point);
-        sphereOnLine.position.copy(intersects[0].pointOnLine);
+        sphereOnLine.position.copy(intersects[0].pointOnLine!);
 
-        const index = intersects[0].faceIndex;
+        const index = intersects[0].faceIndex!;
         const colors = obj.geometry.getAttribute("instanceColorStart");
 
         color.fromBufferAttribute(colors, index);
@@ -236,7 +236,7 @@ function animate() {
 
 //
 
-function switchLine(val) {
+function switchLine(val: number) {
     switch (val) {
         case 0:
             line.visible = true;
@@ -261,11 +261,13 @@ function switchLine(val) {
 function initGui() {
     gui = new GUI();
 
-    gui.add(params, "line type", { "LineGeometry": 0, "LineSegmentsGeometry": 1 }).onChange(function (val) {
-        switchLine(val);
-    }).setValue(1);
+    gui.add(params, "line type", { LineGeometry: 0, LineSegmentsGeometry: 1 })
+        .onChange(function(val) {
+            switchLine(val);
+        })
+        .setValue(1);
 
-    gui.add(params, "world units").onChange(function (val) {
+    gui.add(params, "world units").onChange(function(val) {
         matLine.worldUnits = val;
         matLine.needsUpdate = true;
 
@@ -273,25 +275,25 @@ function initGui() {
         matThresholdLine.needsUpdate = true;
     });
 
-    gui.add(params, "visualize threshold").onChange(function (val) {
+    gui.add(params, "visualize threshold").onChange(function(val) {
         matThresholdLine.visible = val;
     });
 
-    gui.add(params, "width", 1, 10).onChange(function (val) {
+    gui.add(params, "width", 1, 10).onChange(function(val) {
         matLine.linewidth = val;
-        matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2.threshold;
+        matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2!.threshold;
     });
 
-    gui.add(params, "alphaToCoverage").onChange(function (val) {
+    gui.add(params, "alphaToCoverage").onChange(function(val) {
         matLine.alphaToCoverage = val;
     });
 
-    gui.add(params, "threshold", 0, 10).onChange(function (val) {
-        raycaster.params.Line2.threshold = val;
-        matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2.threshold;
+    gui.add(params, "threshold", 0, 10).onChange(function(val) {
+        raycaster.params.Line2!.threshold = val;
+        matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2!.threshold;
     });
 
-    gui.add(params, "translation", 0, 10).onChange(function (val) {
+    gui.add(params, "translation", 0, 10).onChange(function(val) {
         line.position.x = val;
         segments.position.x = val;
     });
diff --git a/examples-testing/examples/webgl_lines_fat_wireframe.ts b/examples-testing/examples/webgl_lines_fat_wireframe.ts
index b6cf30d..4612a87 100644
--- a/examples-testing/examples/webgl_lines_fat_wireframe.ts
+++ b/examples-testing/examples/webgl_lines_fat_wireframe.ts
@@ -2,21 +2,26 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { LineMaterial } from "three/addons/lines/LineMaterial.js";
 import { Wireframe } from "three/addons/lines/Wireframe.js";
 import { WireframeGeometry2 } from "three/addons/lines/WireframeGeometry2.js";
 
-let wireframe, renderer, scene, camera, camera2, controls;
-let wireframe1;
-let matLine, matLineBasic, matLineDashed;
-let stats;
-let gui;
+let wireframe: Wireframe,
+    renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    camera2: THREE.PerspectiveCamera,
+    controls: OrbitControls;
+let wireframe1: THREE.LineSegments;
+let matLine: LineMaterial, matLineBasic: THREE.LineBasicMaterial, matLineDashed: THREE.LineDashedMaterial;
+let stats: Stats;
+let gui: GUI;
 
 // viewport
-let insetWidth;
-let insetHeight;
+let insetWidth: number;
+let insetHeight: number;
 
 init();
 animate();
@@ -42,14 +47,14 @@ function init() {
 
     // Wireframe ( WireframeGeometry2, LineMaterial )
 
-    let geo = new THREE.IcosahedronGeometry(20, 1);
+    let geo: THREE.BufferGeometry = new THREE.IcosahedronGeometry(20, 1);
 
     const geometry = new WireframeGeometry2(geo);
 
     matLine = new LineMaterial({
         color: 0x4080ff,
         linewidth: 5, // in pixels
-        //resolution:  // to be set by renderer, eventually
+        // resolution:  // to be set by renderer, eventually
         dashed: false,
     });
 
@@ -141,12 +146,12 @@ function initGui() {
     const param = {
         "line type": 0,
         "width (px)": 5,
-        "dashed": false,
+        dashed: false,
         "dash scale": 1,
         "dash / gap": 1,
     };
 
-    gui.add(param, "line type", { "LineGeometry": 0, "gl.LINE": 1 }).onChange(function (val) {
+    gui.add(param, "line type", { LineGeometry: 0, "gl.LINE": 1 }).onChange(function(val) {
         switch (val) {
             case 0:
                 wireframe.visible = true;
@@ -164,11 +169,11 @@ function initGui() {
         }
     });
 
-    gui.add(param, "width (px)", 1, 10).onChange(function (val) {
+    gui.add(param, "width (px)", 1, 10).onChange(function(val) {
         matLine.linewidth = val;
     });
 
-    gui.add(param, "dashed").onChange(function (val) {
+    gui.add(param, "dashed").onChange(function(val) {
         matLine.dashed = val;
 
         // dashed is implemented as a defines -- not as a uniform. this could be changed.
@@ -181,12 +186,12 @@ function initGui() {
         wireframe1.material = val ? matLineDashed : matLineBasic;
     });
 
-    gui.add(param, "dash scale", 0.5, 1, 0.1).onChange(function (val) {
+    gui.add(param, "dash scale", 0.5, 1, 0.1).onChange(function(val) {
         matLine.dashScale = val;
         matLineDashed.scale = val;
     });
 
-    gui.add(param, "dash / gap", { "2 : 1": 0, "1 : 1": 1, "1 : 2": 2 }).onChange(function (val) {
+    gui.add(param, "dash / gap", { "2 : 1": 0, "1 : 1": 1, "1 : 2": 2 }).onChange(function(val) {
         switch (val) {
             case 0:
                 matLine.dashSize = 2;
diff --git a/examples-testing/examples/webgl_loader_3dm.ts b/examples-testing/examples/webgl_loader_3dm.ts
index 25fbc03..cfbc176 100644
--- a/examples-testing/examples/webgl_loader_3dm.ts
+++ b/examples-testing/examples/webgl_loader_3dm.ts
@@ -5,8 +5,8 @@ import { Rhino3dmLoader } from "three/addons/loaders/3DMLoader.js";
 
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let camera, scene, renderer;
-let controls, gui;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controls: OrbitControls, gui: GUI;
 
 init();
 animate();
@@ -29,14 +29,14 @@ function init() {
     scene.add(directionalLight);
 
     const loader = new Rhino3dmLoader();
-    //generally, use this for the Library Path: https://cdn.jsdelivr.net/npm/rhino3dm@8.0.1
+    // generally, use this for the Library Path: https://cdn.jsdelivr.net/npm/rhino3dm@8.0.1
     loader.setLibraryPath("jsm/libs/rhino3dm/");
-    loader.load("models/3dm/Rhino_Logo.3dm", function (object) {
+    loader.load("models/3dm/Rhino_Logo.3dm", function(object) {
         scene.add(object);
         initGUI(object.userData.layers);
 
         // hide spinner
-        document.getElementById("loader").style.display = "none";
+        document.getElementById("loader")!.style.display = "none";
     });
 
     controls = new OrbitControls(camera, renderer.domElement);
@@ -61,26 +61,28 @@ function animate() {
     requestAnimationFrame(animate);
 }
 
-function initGUI(layers) {
+function initGUI(layers: { name: string; visible: boolean }[]) {
     gui = new GUI({ title: "layers" });
 
     for (let i = 0; i < layers.length; i++) {
         const layer = layers[i];
-        gui.add(layer, "visible").name(layer.name).onChange(function (val) {
-            const name = this.object.name;
-
-            scene.traverse(function (child) {
-                if (child.userData.hasOwnProperty("attributes")) {
-                    if ("layerIndex" in child.userData.attributes) {
-                        const layerName = layers[child.userData.attributes.layerIndex].name;
-
-                        if (layerName === name) {
-                            child.visible = val;
-                            layer.visible = val;
+        gui.add(layer, "visible")
+            .name(layer.name)
+            .onChange(function(val) {
+                const name = this.object.name;
+
+                scene.traverse(function(child) {
+                    if (child.userData.hasOwnProperty("attributes")) {
+                        if ("layerIndex" in child.userData.attributes) {
+                            const layerName = layers[child.userData.attributes.layerIndex].name;
+
+                            if (layerName === name) {
+                                child.visible = val;
+                                layer.visible = val;
+                            }
                         }
                     }
-                }
+                });
             });
-        });
     }
 }
diff --git a/examples-testing/examples/webgl_loader_3ds.ts b/examples-testing/examples/webgl_loader_3ds.ts
index 97577b9..0606bf9 100644
--- a/examples-testing/examples/webgl_loader_3ds.ts
+++ b/examples-testing/examples/webgl_loader_3ds.ts
@@ -3,8 +3,8 @@ import * as THREE from "three";
 import { TrackballControls } from "three/addons/controls/TrackballControls.js";
 import { TDSLoader } from "three/addons/loaders/TDSLoader.js";
 
-let container, controls;
-let camera, scene, renderer;
+let container: HTMLDivElement, controls: TrackballControls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -23,16 +23,16 @@ function init() {
     directionalLight.position.set(0, 0, 2);
     scene.add(directionalLight);
 
-    //3ds files dont store normal maps
+    // 3ds files dont store normal maps
     const normal = new THREE.TextureLoader().load("models/3ds/portalgun/textures/normal.jpg");
 
     const loader = new TDSLoader();
     loader.setResourcePath("models/3ds/portalgun/textures/");
-    loader.load("models/3ds/portalgun/portalgun.3ds", function (object) {
-        object.traverse(function (child) {
-            if (child.isMesh) {
-                child.material.specular.setScalar(0.1);
-                child.material.normalMap = normal;
+    loader.load("models/3ds/portalgun/portalgun.3ds", function(object) {
+        object.traverse(function(child) {
+            if ((child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).isMesh) {
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).material.specular.setScalar(0.1);
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).material.normalMap = normal;
             }
         });
 
diff --git a/examples-testing/examples/webgl_loader_3mf.ts b/examples-testing/examples/webgl_loader_3mf.ts
index 9a915c6..72ce7e3 100644
--- a/examples-testing/examples/webgl_loader_3mf.ts
+++ b/examples-testing/examples/webgl_loader_3mf.ts
@@ -1,21 +1,21 @@
 import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { ThreeMFLoader } from "three/addons/loaders/3MFLoader.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import { ThreeMFLoader } from "three/addons/loaders/3MFLoader.js";
 
-let camera, scene, renderer, object, loader, controls;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    object: THREE.Group,
+    loader: ThreeMFLoader,
+    controls: OrbitControls;
 
 const params = {
     asset: "cube_gears",
 };
 
-const assets = [
-    "cube_gears",
-    "facecolors",
-    "multipletextures",
-    "vertexcolors",
-];
+const assets = ["cube_gears", "facecolors", "multipletextures", "vertexcolors"];
 
 init();
 
@@ -51,7 +51,7 @@ function init() {
 
     const manager = new THREE.LoadingManager();
 
-    manager.onLoad = function () {
+    manager.onLoad = function() {
         const aabb = new THREE.Box3().setFromObject(object);
         const center = aabb.getCenter(new THREE.Vector3());
 
@@ -73,18 +73,25 @@ function init() {
     //
 
     const gui = new GUI();
-    gui.add(params, "asset", assets).onChange(function (value) {
+    gui.add(params, "asset", assets).onChange(function(value) {
         loadAsset(value);
     });
 }
 
-function loadAsset(asset) {
-    loader.load("models/3mf/" + asset + ".3mf", function (group) {
+function loadAsset(asset: string) {
+    loader.load("models/3mf/" + asset + ".3mf", function(group) {
         if (object) {
-            object.traverse(function (child) {
-                if (child.material) child.material.dispose();
-                if (child.material && child.material.map) child.material.map.dispose();
-                if (child.geometry) child.geometry.dispose();
+            object.traverse(function(child) {
+                if ((child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material) {
+                    (child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.dispose();
+                }
+                if (
+                    (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material
+                    && (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.map
+                ) {
+                    (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.map!.dispose();
+                }
+                if ((child as THREE.Mesh).geometry) (child as THREE.Mesh).geometry.dispose();
             });
 
             scene.remove(object);
diff --git a/examples-testing/examples/webgl_loader_3mf_materials.ts b/examples-testing/examples/webgl_loader_3mf_materials.ts
index c97bf92..4b3f4b3 100644
--- a/examples-testing/examples/webgl_loader_3mf_materials.ts
+++ b/examples-testing/examples/webgl_loader_3mf_materials.ts
@@ -3,7 +3,7 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { ThreeMFLoader } from "three/addons/loaders/3MFLoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -41,10 +41,10 @@ function init() {
     const manager = new THREE.LoadingManager();
 
     const loader = new ThreeMFLoader(manager);
-    loader.load("./models/3mf/truck.3mf", function (object) {
+    loader.load("./models/3mf/truck.3mf", function(object) {
         object.rotation.set(-Math.PI / 2, 0, 0); // z-up conversion
 
-        object.traverse(function (child) {
+        object.traverse(function(child) {
             child.castShadow = true;
         });
 
@@ -53,7 +53,7 @@ function init() {
 
     //
 
-    manager.onLoad = function () {
+    manager.onLoad = function() {
         render();
     };
 
diff --git a/examples-testing/examples/webgl_loader_amf.ts b/examples-testing/examples/webgl_loader_amf.ts
index 43bdd2f..3c7c084 100644
--- a/examples-testing/examples/webgl_loader_amf.ts
+++ b/examples-testing/examples/webgl_loader_amf.ts
@@ -3,7 +3,7 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { AMFLoader } from "three/addons/loaders/AMFLoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -34,7 +34,7 @@ function init() {
     document.body.appendChild(renderer.domElement);
 
     const loader = new AMFLoader();
-    loader.load("./models/amf/rook.amf", function (amfobject) {
+    loader.load("./models/amf/rook.amf", function(amfobject) {
         scene.add(amfobject);
         render();
     });
diff --git a/examples-testing/examples/webgl_loader_bvh.ts b/examples-testing/examples/webgl_loader_bvh.ts
index c0e8a66..460d585 100644
--- a/examples-testing/examples/webgl_loader_bvh.ts
+++ b/examples-testing/examples/webgl_loader_bvh.ts
@@ -5,14 +5,14 @@ import { BVHLoader } from "three/addons/loaders/BVHLoader.js";
 
 const clock = new THREE.Clock();
 
-let camera, controls, scene, renderer;
-let mixer;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mixer: THREE.AnimationMixer;
 
 init();
 animate();
 
 const loader = new BVHLoader();
-loader.load("models/bvh/pirouette.bvh", function (result) {
+loader.load("models/bvh/pirouette.bvh", function(result) {
     const skeletonHelper = new THREE.SkeletonHelper(result.skeleton.bones[0]);
 
     scene.add(result.skeleton.bones[0]);
diff --git a/examples-testing/examples/webgl_loader_collada.ts b/examples-testing/examples/webgl_loader_collada.ts
index 5407a33..26dfb18 100644
--- a/examples-testing/examples/webgl_loader_collada.ts
+++ b/examples-testing/examples/webgl_loader_collada.ts
@@ -4,14 +4,14 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { ColladaLoader } from "three/addons/loaders/ColladaLoader.js";
 
-let container, stats, clock;
-let camera, scene, renderer, elf;
+let container: HTMLElement, stats: Stats, clock: THREE.Clock;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, elf: THREE.Scene;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
     camera.position.set(8, 10, 8);
@@ -23,14 +23,14 @@ function init() {
 
     // loading manager
 
-    const loadingManager = new THREE.LoadingManager(function () {
+    const loadingManager = new THREE.LoadingManager(function() {
         scene.add(elf);
     });
 
     // collada
 
     const loader = new ColladaLoader(loadingManager);
-    loader.load("./models/collada/elf/elf.dae", function (collada) {
+    loader.load("./models/collada/elf/elf.dae", function(collada) {
         elf = collada.scene;
     });
 
diff --git a/examples-testing/examples/webgl_loader_collada_skinning.ts b/examples-testing/examples/webgl_loader_collada_skinning.ts
index f544a23..b472db0 100644
--- a/examples-testing/examples/webgl_loader_collada_skinning.ts
+++ b/examples-testing/examples/webgl_loader_collada_skinning.ts
@@ -2,17 +2,17 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-import { ColladaLoader } from "three/addons/loaders/ColladaLoader.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { ColladaLoader } from "three/addons/loaders/ColladaLoader.js";
 
-let container, stats, clock, controls;
-let camera, scene, renderer, mixer;
+let container: HTMLElement, stats: Stats, clock: THREE.Clock, controls: OrbitControls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, mixer: THREE.AnimationMixer;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 1, 1000);
     camera.position.set(15, 10, -15);
@@ -24,7 +24,7 @@ function init() {
     // collada
 
     const loader = new ColladaLoader();
-    loader.load("./models/collada/stormtrooper/stormtrooper.dae", function (collada) {
+    loader.load("./models/collada/stormtrooper/stormtrooper.dae", function(collada) {
         const avatar = collada.scene;
         const animations = avatar.animations;
 
diff --git a/examples-testing/examples/webgl_loader_draco.ts b/examples-testing/examples/webgl_loader_draco.ts
index 5bcdd54..b77ae12 100644
--- a/examples-testing/examples/webgl_loader_draco.ts
+++ b/examples-testing/examples/webgl_loader_draco.ts
@@ -2,9 +2,9 @@ import * as THREE from "three";
 
 import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-const container = document.querySelector("#container");
+const container = document.querySelector("#container")!;
 
 // Configure and create Draco decoder.
 const dracoLoader = new DRACOLoader();
@@ -44,7 +44,7 @@ function init() {
     spotLight.position.set(-1, 1, 1);
     scene.add(spotLight);
 
-    dracoLoader.load("models/draco/bunny.drc", function (geometry) {
+    dracoLoader.load("models/draco/bunny.drc", function(geometry) {
         geometry.computeVertexNormals();
 
         const material = new THREE.MeshStandardMaterial({ color: 0xa5a5a5 });
diff --git a/examples-testing/examples/webgl_loader_fbx.ts b/examples-testing/examples/webgl_loader_fbx.ts
index 97e5147..f8fc81a 100644
--- a/examples-testing/examples/webgl_loader_fbx.ts
+++ b/examples-testing/examples/webgl_loader_fbx.ts
@@ -5,11 +5,11 @@ import Stats from "three/addons/libs/stats.module.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 const clock = new THREE.Clock();
 
-let mixer;
+let mixer: THREE.AnimationMixer;
 
 init();
 animate();
@@ -56,14 +56,14 @@ function init() {
 
     // model
     const loader = new FBXLoader();
-    loader.load("models/fbx/Samba Dancing.fbx", function (object) {
+    loader.load("models/fbx/Samba Dancing.fbx", function(object) {
         mixer = new THREE.AnimationMixer(object);
 
         const action = mixer.clipAction(object.animations[0]);
         action.play();
 
-        object.traverse(function (child) {
-            if (child.isMesh) {
+        object.traverse(function(child) {
+            if ((child as THREE.Mesh).isMesh) {
                 child.castShadow = true;
                 child.receiveShadow = true;
             }
diff --git a/examples-testing/examples/webgl_loader_fbx_nurbs.ts b/examples-testing/examples/webgl_loader_fbx_nurbs.ts
index b4e3f4f..1dc4897 100644
--- a/examples-testing/examples/webgl_loader_fbx_nurbs.ts
+++ b/examples-testing/examples/webgl_loader_fbx_nurbs.ts
@@ -5,7 +5,7 @@ import Stats from "three/addons/libs/stats.module.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 animate();
@@ -29,7 +29,7 @@ function init() {
 
     // model
     const loader = new FBXLoader();
-    loader.load("models/fbx/nurbs.fbx", function (object) {
+    loader.load("models/fbx/nurbs.fbx", function(object) {
         scene.add(object);
     });
 
diff --git a/examples-testing/examples/webgl_loader_gcode.ts b/examples-testing/examples/webgl_loader_gcode.ts
index ad4c5d2..82e6ab1 100644
--- a/examples-testing/examples/webgl_loader_gcode.ts
+++ b/examples-testing/examples/webgl_loader_gcode.ts
@@ -3,7 +3,7 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GCodeLoader } from "three/addons/loaders/GCodeLoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 render();
@@ -15,7 +15,7 @@ function init() {
     scene = new THREE.Scene();
 
     const loader = new GCodeLoader();
-    loader.load("models/gcode/benchy.gcode", function (object) {
+    loader.load("models/gcode/benchy.gcode", function(object) {
         object.position.set(-100, -20, 100);
         scene.add(object);
 
diff --git a/examples-testing/examples/webgl_loader_gltf.ts b/examples-testing/examples/webgl_loader_gltf.ts
index 19f6789..2a454fc 100644
--- a/examples-testing/examples/webgl_loader_gltf.ts
+++ b/examples-testing/examples/webgl_loader_gltf.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -17,31 +17,29 @@ function init() {
 
     scene = new THREE.Scene();
 
-    new RGBELoader()
-        .setPath("textures/equirectangular/")
-        .load("royal_esplanade_1k.hdr", function (texture) {
-            texture.mapping = THREE.EquirectangularReflectionMapping;
+    new RGBELoader().setPath("textures/equirectangular/").load("royal_esplanade_1k.hdr", function(texture) {
+        texture.mapping = THREE.EquirectangularReflectionMapping;
 
-            scene.background = texture;
-            scene.environment = texture;
+        scene.background = texture;
+        scene.environment = texture;
 
-            render();
+        render();
 
-            // model
+        // model
 
-            const loader = new GLTFLoader().setPath("models/gltf/DamagedHelmet/glTF/");
-            loader.load("DamagedHelmet.gltf", async function (gltf) {
-                const model = gltf.scene;
+        const loader = new GLTFLoader().setPath("models/gltf/DamagedHelmet/glTF/");
+        loader.load("DamagedHelmet.gltf", async function(gltf) {
+            const model = gltf.scene;
 
-                // wait until the model can be added to the scene without blocking due to shader compilation
+            // wait until the model can be added to the scene without blocking due to shader compilation
 
-                await renderer.compileAsync(model, camera, scene);
+            await renderer.compileAsync(model, camera, scene);
 
-                scene.add(model);
+            scene.add(model);
 
-                render();
-            });
+            render();
         });
+    });
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
diff --git a/examples-testing/examples/webgl_loader_gltf_anisotropy.ts b/examples-testing/examples/webgl_loader_gltf_anisotropy.ts
index 79ece70..60f3d28 100644
--- a/examples-testing/examples/webgl_loader_gltf_anisotropy.ts
+++ b/examples-testing/examples/webgl_loader_gltf_anisotropy.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 
-let renderer, scene, camera, controls;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
 
 init();
 
diff --git a/examples-testing/examples/webgl_loader_gltf_avif.ts b/examples-testing/examples/webgl_loader_gltf_avif.ts
index 6d90945..9d509b6 100644
--- a/examples-testing/examples/webgl_loader_gltf_avif.ts
+++ b/examples-testing/examples/webgl_loader_gltf_avif.ts
@@ -1,10 +1,10 @@
 import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
+import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 render();
@@ -24,7 +24,7 @@ function init() {
     const loader = new GLTFLoader();
     loader.setDRACOLoader(dracoLoader);
     loader.setPath("models/gltf/AVIFTest/");
-    loader.load("forest_house.glb", function (gltf) {
+    loader.load("forest_house.glb", function(gltf) {
         scene.add(gltf.scene);
 
         render();
diff --git a/examples-testing/examples/webgl_loader_gltf_compressed.ts b/examples-testing/examples/webgl_loader_gltf_compressed.ts
index ccc3b16..f6ae354 100644
--- a/examples-testing/examples/webgl_loader_gltf_compressed.ts
+++ b/examples-testing/examples/webgl_loader_gltf_compressed.ts
@@ -1,13 +1,13 @@
 import * as THREE from "three";
 
-import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
 import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";
+import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 render();
@@ -40,14 +40,12 @@ function init() {
     grid.material.transparent = true;
     scene.add(grid);
 
-    const ktx2Loader = new KTX2Loader()
-        .setTranscoderPath("jsm/libs/basis/")
-        .detectSupport(renderer);
+    const ktx2Loader = new KTX2Loader().setTranscoderPath("jsm/libs/basis/").detectSupport(renderer);
 
     const loader = new GLTFLoader().setPath("models/gltf/");
     loader.setKTX2Loader(ktx2Loader);
     loader.setMeshoptDecoder(MeshoptDecoder);
-    loader.load("coffeemat.glb", function (gltf) {
+    loader.load("coffeemat.glb", function(gltf) {
         // coffeemat.glb was produced from the source scene using gltfpack:
         // gltfpack -i coffeemat/scene.gltf -o coffeemat.glb -cc -tc
         // The resulting model uses EXT_meshopt_compression (for geometry) and KHR_texture_basisu (for texture compression using ETC1S/BasisLZ)
diff --git a/examples-testing/examples/webgl_loader_gltf_instancing.ts b/examples-testing/examples/webgl_loader_gltf_instancing.ts
index 117820d..13d4633 100644
--- a/examples-testing/examples/webgl_loader_gltf_instancing.ts
+++ b/examples-testing/examples/webgl_loader_gltf_instancing.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 render();
@@ -14,29 +14,27 @@ function init() {
     document.body.appendChild(container);
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 20);
-    camera.position.set(-0.90, 0.41, -0.89);
+    camera.position.set(-0.9, 0.41, -0.89);
 
     scene = new THREE.Scene();
 
-    new RGBELoader()
-        .setPath("textures/equirectangular/")
-        .load("royal_esplanade_1k.hdr", function (texture) {
-            texture.mapping = THREE.EquirectangularReflectionMapping;
+    new RGBELoader().setPath("textures/equirectangular/").load("royal_esplanade_1k.hdr", function(texture) {
+        texture.mapping = THREE.EquirectangularReflectionMapping;
 
-            scene.background = texture;
-            scene.environment = texture;
+        scene.background = texture;
+        scene.environment = texture;
 
-            render();
+        render();
 
-            // model
+        // model
 
-            const loader = new GLTFLoader().setPath("models/gltf/DamagedHelmet/glTF-instancing/");
-            loader.load("DamagedHelmetGpuInstancing.gltf", function (gltf) {
-                scene.add(gltf.scene);
+        const loader = new GLTFLoader().setPath("models/gltf/DamagedHelmet/glTF-instancing/");
+        loader.load("DamagedHelmetGpuInstancing.gltf", function(gltf) {
+            scene.add(gltf.scene);
 
-                render();
-            });
+            render();
         });
+    });
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
diff --git a/examples-testing/examples/webgl_loader_gltf_iridescence.ts b/examples-testing/examples/webgl_loader_gltf_iridescence.ts
index 623289c..965b23b 100644
--- a/examples-testing/examples/webgl_loader_gltf_iridescence.ts
+++ b/examples-testing/examples/webgl_loader_gltf_iridescence.ts
@@ -4,9 +4,9 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 
-let renderer, scene, camera, controls;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
 
-init().catch(function (err) {
+init().catch(function(err) {
     console.error(err);
 });
 
@@ -29,8 +29,7 @@ async function init() {
     controls.target.set(0, 0.2, 0);
     controls.update();
 
-    const rgbeLoader = new RGBELoader()
-        .setPath("textures/equirectangular/");
+    const rgbeLoader = new RGBELoader().setPath("textures/equirectangular/");
 
     const gltfLoader = new GLTFLoader().setPath("models/gltf/");
 
diff --git a/examples-testing/examples/webgl_loader_gltf_lights.ts b/examples-testing/examples/webgl_loader_gltf_lights.ts
index 62e7cb7..116d317 100644
--- a/examples-testing/examples/webgl_loader_gltf_lights.ts
+++ b/examples-testing/examples/webgl_loader_gltf_lights.ts
@@ -6,7 +6,7 @@ import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const params = {
     punctualLightsEnabled: true,
@@ -66,9 +66,9 @@ function onWindowResize() {
     render();
 }
 
-function toggleLights(visible) {
-    scene.traverse(function (object) {
-        if (object.isLight) {
+function toggleLights(visible: boolean) {
+    scene.traverse(function(object) {
+        if ((object as THREE.Light).isLight) {
             object.visible = visible;
         }
     });
diff --git a/examples-testing/examples/webgl_loader_gltf_sheen.ts b/examples-testing/examples/webgl_loader_gltf_sheen.ts
index 20d01cf..b16352f 100644
--- a/examples-testing/examples/webgl_loader_gltf_sheen.ts
+++ b/examples-testing/examples/webgl_loader_gltf_sheen.ts
@@ -1,12 +1,12 @@
 import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
+import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
 
 init();
 animate();
@@ -22,18 +22,19 @@ function init() {
 
     // model
 
-    new GLTFLoader()
-        .setPath("models/gltf/")
-        .load("SheenChair.glb", function (gltf) {
-            scene.add(gltf.scene);
+    new GLTFLoader().setPath("models/gltf/").load("SheenChair.glb", function(gltf) {
+        scene.add(gltf.scene);
 
-            const object = gltf.scene.getObjectByName("SheenChair_fabric");
+        const object = gltf.scene.getObjectByName("SheenChair_fabric") as THREE.Mesh<
+            THREE.BufferGeometry,
+            THREE.MeshPhysicalMaterial
+        >;
 
-            const gui = new GUI();
+        const gui = new GUI();
 
-            gui.add(object.material, "sheen", 0, 1);
-            gui.open();
-        });
+        gui.add(object.material, "sheen", 0, 1);
+        gui.open();
+    });
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
diff --git a/examples-testing/examples/webgl_loader_gltf_transmission.ts b/examples-testing/examples/webgl_loader_gltf_transmission.ts
index 507a6c6..84744ca 100644
--- a/examples-testing/examples/webgl_loader_gltf_transmission.ts
+++ b/examples-testing/examples/webgl_loader_gltf_transmission.ts
@@ -6,7 +6,12 @@ import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 
 import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
 
-let camera, scene, renderer, controls, clock, mixer;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    controls: OrbitControls,
+    clock: THREE.Clock,
+    mixer: THREE.AnimationMixer;
 
 init();
 
@@ -21,28 +26,26 @@ function init() {
 
     scene = new THREE.Scene();
 
-    new RGBELoader()
-        .setPath("textures/equirectangular/")
-        .load("royal_esplanade_1k.hdr", function (texture) {
-            texture.mapping = THREE.EquirectangularReflectionMapping;
+    new RGBELoader().setPath("textures/equirectangular/").load("royal_esplanade_1k.hdr", function(texture) {
+        texture.mapping = THREE.EquirectangularReflectionMapping;
 
-            scene.background = texture;
-            scene.backgroundBlurriness = 0.35;
+        scene.background = texture;
+        scene.backgroundBlurriness = 0.35;
 
-            scene.environment = texture;
+        scene.environment = texture;
 
-            // model
+        // model
 
-            new GLTFLoader()
-                .setPath("models/gltf/")
-                .setDRACOLoader(new DRACOLoader().setDecoderPath("jsm/libs/draco/gltf/"))
-                .load("IridescentDishWithOlives.glb", function (gltf) {
-                    mixer = new THREE.AnimationMixer(gltf.scene);
-                    mixer.clipAction(gltf.animations[0]).play();
+        new GLTFLoader()
+            .setPath("models/gltf/")
+            .setDRACOLoader(new DRACOLoader().setDecoderPath("jsm/libs/draco/gltf/"))
+            .load("IridescentDishWithOlives.glb", function(gltf) {
+                mixer = new THREE.AnimationMixer(gltf.scene);
+                mixer.clipAction(gltf.animations[0]).play();
 
-                    scene.add(gltf.scene);
-                });
-        });
+                scene.add(gltf.scene);
+            });
+    });
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setAnimationLoop(render);
diff --git a/examples-testing/examples/webgl_loader_imagebitmap.ts b/examples-testing/examples/webgl_loader_imagebitmap.ts
index 089e80f..bd287b3 100644
--- a/examples-testing/examples/webgl_loader_imagebitmap.ts
+++ b/examples-testing/examples/webgl_loader_imagebitmap.ts
@@ -1,14 +1,15 @@
 import * as THREE from "three";
 
-let camera, scene, renderer;
-let group, cubes;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let group: THREE.Group, cubes: THREE.Group;
 
 init();
 animate();
 
 function addImageBitmap() {
-    new THREE.ImageBitmapLoader()
-        .load("textures/planets/earth_atmos_2048.jpg?" + performance.now(), function (imageBitmap) {
+    new THREE.ImageBitmapLoader().load(
+        "textures/planets/earth_atmos_2048.jpg?" + performance.now(),
+        function(imageBitmap) {
             const texture = new THREE.CanvasTexture(imageBitmap);
             texture.colorSpace = THREE.SRGBColorSpace;
             const material = new THREE.MeshBasicMaterial({ map: texture });
@@ -19,17 +20,20 @@ function addImageBitmap() {
             // imageBitmap.close();
 
             addCube(material);
-        }, function (p) {
+        },
+        function(p) {
             console.log(p);
-        }, function (e) {
+        },
+        function(e) {
             console.log(e);
-        });
+        },
+    );
 }
 
 function addImage() {
     new THREE.ImageLoader()
         .setCrossOrigin("*")
-        .load("textures/planets/earth_atmos_2048.jpg?" + performance.now(), function (image) {
+        .load("textures/planets/earth_atmos_2048.jpg?" + performance.now(), function(image) {
             const texture = new THREE.CanvasTexture(image);
             texture.colorSpace = THREE.SRGBColorSpace;
             const material = new THREE.MeshBasicMaterial({ color: 0xff8888, map: texture });
@@ -39,7 +43,7 @@ function addImage() {
 
 const geometry = new THREE.BoxGeometry();
 
-function addCube(material) {
+function addCube(material: THREE.MeshBasicMaterial) {
     const cube = new THREE.Mesh(geometry, material);
     cube.position.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
     cube.rotation.set(Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI);
diff --git a/examples-testing/examples/webgl_loader_kmz.ts b/examples-testing/examples/webgl_loader_kmz.ts
index f92b59e..665c202 100644
--- a/examples-testing/examples/webgl_loader_kmz.ts
+++ b/examples-testing/examples/webgl_loader_kmz.ts
@@ -3,7 +3,7 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { KMZLoader } from "three/addons/loaders/KMZLoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -32,7 +32,7 @@ function init() {
     document.body.appendChild(renderer.domElement);
 
     const loader = new KMZLoader();
-    loader.load("./models/kmz/Box.kmz", function (kmz) {
+    loader.load("./models/kmz/Box.kmz", function(kmz) {
         kmz.scene.position.y = 0.5;
         scene.add(kmz.scene);
         render();
diff --git a/examples-testing/examples/webgl_loader_lwo.ts b/examples-testing/examples/webgl_loader_lwo.ts
index 623858f..3de45cc 100644
--- a/examples-testing/examples/webgl_loader_lwo.ts
+++ b/examples-testing/examples/webgl_loader_lwo.ts
@@ -3,7 +3,7 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { LWOLoader } from "three/addons/loaders/LWOLoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -30,7 +30,7 @@ function init() {
     scene.add(grid);
 
     const loader = new LWOLoader();
-    loader.load("models/lwo/Objects/LWO3/Demo.lwo", function (object) {
+    loader.load("models/lwo/Objects/LWO3/Demo.lwo", function(object) {
         const phong = object.meshes[0];
         phong.position.set(-2, 12, 0);
 
diff --git a/examples-testing/examples/webgl_loader_md2_control.ts b/examples-testing/examples/webgl_loader_md2_control.ts
index d58c287..1358c65 100644
--- a/examples-testing/examples/webgl_loader_md2_control.ts
+++ b/examples-testing/examples/webgl_loader_md2_control.ts
@@ -3,16 +3,16 @@ import * as THREE from "three";
 import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { MD2CharacterComplex } from "three/addons/misc/MD2CharacterComplex.js";
 import { Gyroscope } from "three/addons/misc/Gyroscope.js";
+import { MD2CharacterComplex } from "three/addons/misc/MD2CharacterComplex.js";
 
 let SCREEN_WIDTH = window.innerWidth;
 let SCREEN_HEIGHT = window.innerHeight;
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-const characters = [];
+const characters: MD2CharacterComplex[] = [];
 let nCharacters = 0;
 
 let cameraControls;
@@ -77,10 +77,10 @@ function init() {
 
     const ground = new THREE.Mesh(gg, gm);
     ground.rotation.x = -Math.PI / 2;
-    ground.material.map.repeat.set(64, 64);
-    ground.material.map.wrapS = THREE.RepeatWrapping;
-    ground.material.map.wrapT = THREE.RepeatWrapping;
-    ground.material.map.colorSpace = THREE.SRGBColorSpace;
+    ground.material.map!.repeat.set(64, 64);
+    ground.material.map!.wrapS = THREE.RepeatWrapping;
+    ground.material.map!.wrapT = THREE.RepeatWrapping;
+    ground.material.map!.colorSpace = THREE.SRGBColorSpace;
     // note that because the ground does not cast a shadow, .castShadow is left false
     ground.receiveShadow = true;
 
@@ -166,7 +166,7 @@ function init() {
     const baseCharacter = new MD2CharacterComplex();
     baseCharacter.scale = 3;
 
-    baseCharacter.onLoadComplete = function () {
+    baseCharacter.onLoadComplete = function() {
         let k = 0;
 
         for (let j = 0; j < nRows; j++) {
@@ -212,7 +212,7 @@ function onWindowResize() {
     camera.updateProjectionMatrix();
 }
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     switch (event.code) {
         case "ArrowUp":
         case "KeyW":
@@ -241,7 +241,7 @@ function onKeyDown(event) {
     }
 }
 
-function onKeyUp(event) {
+function onKeyUp(event: KeyboardEvent) {
     switch (event.code) {
         case "ArrowUp":
         case "KeyW":
diff --git a/examples-testing/examples/webgl_loader_mdd.ts b/examples-testing/examples/webgl_loader_mdd.ts
index 4e21a72..f25cd62 100644
--- a/examples-testing/examples/webgl_loader_mdd.ts
+++ b/examples-testing/examples/webgl_loader_mdd.ts
@@ -2,7 +2,11 @@ import * as THREE from "three";
 
 import { MDDLoader } from "three/addons/loaders/MDDLoader.js";
 
-let camera, scene, renderer, mixer, clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    mixer: THREE.AnimationMixer,
+    clock: THREE.Clock;
 
 init();
 
@@ -18,7 +22,7 @@ function init() {
     //
 
     const loader = new MDDLoader();
-    loader.load("models/mdd/cube.mdd", function (result) {
+    loader.load("models/mdd/cube.mdd", function(result) {
         const morphTargets = result.morphTargets;
         const clip = result.clip;
         // clip.optimize(); // optional
diff --git a/examples-testing/examples/webgl_loader_obj.ts b/examples-testing/examples/webgl_loader_obj.ts
index f8d1854..175af37 100644
--- a/examples-testing/examples/webgl_loader_obj.ts
+++ b/examples-testing/examples/webgl_loader_obj.ts
@@ -1,11 +1,11 @@
 import * as THREE from "three";
 
-import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let object;
+let object: THREE.Group;
 
 init();
 
@@ -27,8 +27,10 @@ function init() {
     // manager
 
     function loadModel() {
-        object.traverse(function (child) {
-            if (child.isMesh) child.material.map = texture;
+        object.traverse(function(child) {
+            if ((child as THREE.Mesh).isMesh) {
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).material.map = texture;
+            }
         });
 
         object.position.y = -0.95;
@@ -48,9 +50,9 @@ function init() {
 
     // model
 
-    function onProgress(xhr) {
+    function onProgress(xhr: ProgressEvent) {
         if (xhr.lengthComputable) {
-            const percentComplete = xhr.loaded / xhr.total * 100;
+            const percentComplete = (xhr.loaded / xhr.total) * 100;
             console.log("model " + percentComplete.toFixed(2) + "% downloaded");
         }
     }
@@ -60,7 +62,7 @@ function init() {
     const loader = new OBJLoader(manager);
     loader.load(
         "models/obj/male02/male02.obj",
-        function (obj) {
+        function(obj) {
             object = obj;
         },
         onProgress,
diff --git a/examples-testing/examples/webgl_loader_obj_mtl.ts b/examples-testing/examples/webgl_loader_obj_mtl.ts
index a106d31..c5c2bf2 100644
--- a/examples-testing/examples/webgl_loader_obj_mtl.ts
+++ b/examples-testing/examples/webgl_loader_obj_mtl.ts
@@ -1,10 +1,10 @@
 import * as THREE from "three";
 
+import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { MTLLoader } from "three/addons/loaders/MTLLoader.js";
 import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
-import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -26,27 +26,29 @@ function init() {
 
     // model
 
-    const onProgress = function (xhr) {
+    const onProgress = function(xhr: ProgressEvent) {
         if (xhr.lengthComputable) {
-            const percentComplete = xhr.loaded / xhr.total * 100;
+            const percentComplete = (xhr.loaded / xhr.total) * 100;
             console.log(percentComplete.toFixed(2) + "% downloaded");
         }
     };
 
-    new MTLLoader()
-        .setPath("models/obj/male02/")
-        .load("male02.mtl", function (materials) {
-            materials.preload();
+    new MTLLoader().setPath("models/obj/male02/").load("male02.mtl", function(materials) {
+        materials.preload();
 
-            new OBJLoader()
-                .setMaterials(materials)
-                .setPath("models/obj/male02/")
-                .load("male02.obj", function (object) {
+        new OBJLoader()
+            .setMaterials(materials)
+            .setPath("models/obj/male02/")
+            .load(
+                "male02.obj",
+                function(object) {
                     object.position.y = -0.95;
                     object.scale.setScalar(0.01);
                     scene.add(object);
-                }, onProgress);
-        });
+                },
+                onProgress,
+            );
+    });
 
     //
 
diff --git a/examples-testing/examples/webgl_loader_pcd.ts b/examples-testing/examples/webgl_loader_pcd.ts
index 3b04681..ebc2f7b 100644
--- a/examples-testing/examples/webgl_loader_pcd.ts
+++ b/examples-testing/examples/webgl_loader_pcd.ts
@@ -1,10 +1,10 @@
 import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { PCDLoader } from "three/addons/loaders/PCDLoader.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import { PCDLoader } from "three/addons/loaders/PCDLoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 render();
@@ -26,10 +26,10 @@ function init() {
     controls.minDistance = 0.5;
     controls.maxDistance = 10;
 
-    //scene.add( new THREE.AxesHelper( 1 ) );
+    // scene.add( new THREE.AxesHelper( 1 ) );
 
     const loader = new PCDLoader();
-    loader.load("./models/pcd/binary/Zaghetto.pcd", function (points) {
+    loader.load("./models/pcd/binary/Zaghetto.pcd", function(points) {
         points.geometry.center();
         points.geometry.rotateX(Math.PI);
         points.name = "Zaghetto.pcd";
diff --git a/examples-testing/examples/webgl_loader_pdb.ts b/examples-testing/examples/webgl_loader_pdb.ts
index 05b28f2..13515ec 100644
--- a/examples-testing/examples/webgl_loader_pdb.ts
+++ b/examples-testing/examples/webgl_loader_pdb.ts
@@ -1,33 +1,33 @@
 import * as THREE from "three";
 
 import { TrackballControls } from "three/addons/controls/TrackballControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { PDBLoader } from "three/addons/loaders/PDBLoader.js";
 import { CSS2DObject, CSS2DRenderer } from "three/addons/renderers/CSS2DRenderer.js";
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let camera, scene, renderer, labelRenderer;
-let controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, labelRenderer: CSS2DRenderer;
+let controls: TrackballControls;
 
-let root;
+let root: THREE.Group;
 
 const MOLECULES = {
-    "Ethanol": "ethanol.pdb",
-    "Aspirin": "aspirin.pdb",
-    "Caffeine": "caffeine.pdb",
-    "Nicotine": "nicotine.pdb",
-    "LSD": "lsd.pdb",
-    "Cocaine": "cocaine.pdb",
-    "Cholesterol": "cholesterol.pdb",
-    "Lycopene": "lycopene.pdb",
-    "Glucose": "glucose.pdb",
+    Ethanol: "ethanol.pdb",
+    Aspirin: "aspirin.pdb",
+    Caffeine: "caffeine.pdb",
+    Nicotine: "nicotine.pdb",
+    LSD: "lsd.pdb",
+    Cocaine: "cocaine.pdb",
+    Cholesterol: "cholesterol.pdb",
+    Lycopene: "lycopene.pdb",
+    Glucose: "glucose.pdb",
     "Aluminium oxide": "Al2O3.pdb",
-    "Cubane": "cubane.pdb",
-    "Copper": "cu.pdb",
-    "Fluorite": "caf2.pdb",
-    "Salt": "nacl.pdb",
+    Cubane: "cubane.pdb",
+    Copper: "cu.pdb",
+    Fluorite: "caf2.pdb",
+    Salt: "nacl.pdb",
     "YBCO superconductor": "ybco.pdb",
-    "Buckyball": "buckyball.pdb",
-    "Graphite": "graphite.pdb",
+    Buckyball: "buckyball.pdb",
+    Graphite: "graphite.pdb",
 };
 
 const params = {
@@ -64,14 +64,14 @@ function init() {
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
-    document.getElementById("container").appendChild(renderer.domElement);
+    document.getElementById("container")!.appendChild(renderer.domElement);
 
     labelRenderer = new CSS2DRenderer();
     labelRenderer.setSize(window.innerWidth, window.innerHeight);
     labelRenderer.domElement.style.position = "absolute";
     labelRenderer.domElement.style.top = "0px";
     labelRenderer.domElement.style.pointerEvents = "none";
-    document.getElementById("container").appendChild(labelRenderer.domElement);
+    document.getElementById("container")!.appendChild(labelRenderer.domElement);
 
     //
 
@@ -97,15 +97,15 @@ function init() {
 
 //
 
-function loadMolecule(model) {
+function loadMolecule(model: string) {
     const url = "models/pdb/" + model;
 
     while (root.children.length > 0) {
         const object = root.children[0];
-        object.parent.remove(object);
+        object.parent!.remove(object);
     }
 
-    loader.load(url, function (pdb) {
+    loader.load(url, function(pdb) {
         const geometryAtoms = pdb.geometryAtoms;
         const geometryBonds = pdb.geometryBonds;
         const json = pdb.json;
@@ -114,7 +114,7 @@ function loadMolecule(model) {
         const sphereGeometry = new THREE.IcosahedronGeometry(1, 3);
 
         geometryAtoms.computeBoundingBox();
-        geometryAtoms.boundingBox.getCenter(offset).negate();
+        geometryAtoms.boundingBox!.getCenter(offset).negate();
 
         geometryAtoms.translate(offset.x, offset.y, offset.z);
         geometryBonds.translate(offset.x, offset.y, offset.z);
diff --git a/examples-testing/examples/webgl_loader_ply.ts b/examples-testing/examples/webgl_loader_ply.ts
index 0d2ee7a..4aa5e5d 100644
--- a/examples-testing/examples/webgl_loader_ply.ts
+++ b/examples-testing/examples/webgl_loader_ply.ts
@@ -4,9 +4,9 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { PLYLoader } from "three/addons/loaders/PLYLoader.js";
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, cameraTarget, scene, renderer;
+let camera: THREE.PerspectiveCamera, cameraTarget: THREE.Vector3, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -39,7 +39,7 @@ function init() {
     // PLY file
 
     const loader = new PLYLoader();
-    loader.load("./models/ply/ascii/dolphins.ply", function (geometry) {
+    loader.load("./models/ply/ascii/dolphins.ply", function(geometry) {
         geometry.computeVertexNormals();
 
         const material = new THREE.MeshStandardMaterial({ color: 0x009cff, flatShading: true });
@@ -56,7 +56,7 @@ function init() {
         scene.add(mesh);
     });
 
-    loader.load("./models/ply/binary/Lucy100k.ply", function (geometry) {
+    loader.load("./models/ply/binary/Lucy100k.ply", function(geometry) {
         geometry.computeVertexNormals();
 
         const material = new THREE.MeshStandardMaterial({ color: 0x009cff, flatShading: true });
@@ -100,7 +100,7 @@ function init() {
     window.addEventListener("resize", onWindowResize);
 }
 
-function addShadowedLight(x, y, z, color, intensity) {
+function addShadowedLight(x: number, y: number, z: number, color: number, intensity: number) {
     const directionalLight = new THREE.DirectionalLight(color, intensity);
     directionalLight.position.set(x, y, z);
     scene.add(directionalLight);
diff --git a/examples-testing/examples/webgl_loader_svg.ts b/examples-testing/examples/webgl_loader_svg.ts
index 00ac526..dd2b1e9 100644
--- a/examples-testing/examples/webgl_loader_svg.ts
+++ b/examples-testing/examples/webgl_loader_svg.ts
@@ -1,16 +1,26 @@
 import * as THREE from "three";
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { SVGLoader } from "three/addons/loaders/SVGLoader.js";
 
-let renderer, scene, camera, gui, guiData;
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    gui: GUI,
+    guiData: {
+        currentURL: string;
+        drawFillShapes: boolean;
+        drawStrokes: boolean;
+        fillShapesWireframe: boolean;
+        strokesWireframe: boolean;
+    };
 
 init();
 
 //
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     //
 
@@ -53,10 +63,10 @@ function createGUI() {
     gui = new GUI();
 
     gui.add(guiData, "currentURL", {
-        "Tiger": "models/svg/tiger.svg",
+        Tiger: "models/svg/tiger.svg",
         "Joins and caps": "models/svg/lineJoinsAndCaps.svg",
-        "Hexagon": "models/svg/hexagon.svg",
-        "Energy": "models/svg/energy.svg",
+        Hexagon: "models/svg/hexagon.svg",
+        Energy: "models/svg/energy.svg",
         "Test 1": "models/svg/tests/1.svg",
         "Test 2": "models/svg/tests/2.svg",
         "Test 3": "models/svg/tests/3.svg",
@@ -66,24 +76,26 @@ function createGUI() {
         "Test 7": "models/svg/tests/7.svg",
         "Test 8": "models/svg/tests/8.svg",
         "Test 9": "models/svg/tests/9.svg",
-        "Units": "models/svg/tests/units.svg",
-        "Ordering": "models/svg/tests/ordering.svg",
-        "Defs": "models/svg/tests/testDefs/Svg-defs.svg",
-        "Defs2": "models/svg/tests/testDefs/Svg-defs2.svg",
-        "Defs3": "models/svg/tests/testDefs/Wave-defs.svg",
-        "Defs4": "models/svg/tests/testDefs/defs4.svg",
-        "Defs5": "models/svg/tests/testDefs/defs5.svg",
+        Units: "models/svg/tests/units.svg",
+        Ordering: "models/svg/tests/ordering.svg",
+        Defs: "models/svg/tests/testDefs/Svg-defs.svg",
+        Defs2: "models/svg/tests/testDefs/Svg-defs2.svg",
+        Defs3: "models/svg/tests/testDefs/Wave-defs.svg",
+        Defs4: "models/svg/tests/testDefs/defs4.svg",
+        Defs5: "models/svg/tests/testDefs/defs5.svg",
         "Style CSS inside defs": "models/svg/style-css-inside-defs.svg",
         "Multiple CSS classes": "models/svg/multiple-css-classes.svg",
         "Zero Radius": "models/svg/zero-radius.svg",
         "Styles in svg tag": "models/svg/tests/styles.svg",
         "Round join": "models/svg/tests/roundJoinPrecisionIssue.svg",
         "Ellipse Transformations": "models/svg/tests/ellipseTransform.svg",
-        "singlePointTest": "models/svg/singlePointTest.svg",
-        "singlePointTest2": "models/svg/singlePointTest2.svg",
-        "singlePointTest3": "models/svg/singlePointTest3.svg",
-        "emptyPath": "models/svg/emptyPath.svg",
-    }).name("SVG File").onChange(update);
+        singlePointTest: "models/svg/singlePointTest.svg",
+        singlePointTest2: "models/svg/singlePointTest2.svg",
+        singlePointTest3: "models/svg/singlePointTest3.svg",
+        emptyPath: "models/svg/emptyPath.svg",
+    })
+        .name("SVG File")
+        .onChange(update);
 
     gui.add(guiData, "drawStrokes").name("Draw strokes").onChange(update);
 
@@ -98,7 +110,7 @@ function createGUI() {
     }
 }
 
-function loadSVG(url) {
+function loadSVG(url: string) {
     //
 
     scene = new THREE.Scene();
@@ -114,7 +126,7 @@ function loadSVG(url) {
 
     const loader = new SVGLoader();
 
-    loader.load(url, function (data) {
+    loader.load(url, function(data) {
         const group = new THREE.Group();
         group.scale.multiplyScalar(0.25);
         group.position.x = -70;
@@ -124,12 +136,12 @@ function loadSVG(url) {
         let renderOrder = 0;
 
         for (const path of data.paths) {
-            const fillColor = path.userData.style.fill;
+            const fillColor = path.userData!.style.fill;
 
             if (guiData.drawFillShapes && fillColor !== undefined && fillColor !== "none") {
                 const material = new THREE.MeshBasicMaterial({
                     color: new THREE.Color().setStyle(fillColor),
-                    opacity: path.userData.style.fillOpacity,
+                    opacity: path.userData!.style.fillOpacity,
                     transparent: true,
                     side: THREE.DoubleSide,
                     depthWrite: false,
@@ -147,12 +159,12 @@ function loadSVG(url) {
                 }
             }
 
-            const strokeColor = path.userData.style.stroke;
+            const strokeColor = path.userData!.style.stroke;
 
             if (guiData.drawStrokes && strokeColor !== undefined && strokeColor !== "none") {
                 const material = new THREE.MeshBasicMaterial({
                     color: new THREE.Color().setStyle(strokeColor),
-                    opacity: path.userData.style.strokeOpacity,
+                    opacity: path.userData!.style.strokeOpacity,
                     transparent: true,
                     side: THREE.DoubleSide,
                     depthWrite: false,
@@ -160,7 +172,7 @@ function loadSVG(url) {
                 });
 
                 for (const subPath of path.subPaths) {
-                    const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style);
+                    const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData!.style);
 
                     if (geometry) {
                         const mesh = new THREE.Mesh(geometry, material);
diff --git a/examples-testing/examples/webgl_loader_texture_dds.ts b/examples-testing/examples/webgl_loader_texture_dds.ts
index 3a73d4d..4514138 100644
--- a/examples-testing/examples/webgl_loader_texture_dds.ts
+++ b/examples-testing/examples/webgl_loader_texture_dds.ts
@@ -2,8 +2,8 @@ import * as THREE from "three";
 
 import { DDSLoader } from "three/addons/loaders/DDSLoader.js";
 
-let camera, scene, renderer;
-const meshes = [];
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+const meshes: THREE.Mesh[] = [];
 
 init();
 animate();
@@ -64,7 +64,7 @@ function init() {
     const map10 = loader.load("textures/compressed/disturb_dx10_bc6h_unsigned_mip.dds");
     map10.anisotropy = 4;
 
-    const cubemap1 = loader.load("textures/compressed/Mountains.dds", function (texture) {
+    const cubemap1 = loader.load("textures/compressed/Mountains.dds", function(texture) {
         texture.magFilter = THREE.LinearFilter;
         texture.minFilter = THREE.LinearFilter;
         texture.mapping = THREE.CubeReflectionMapping;
@@ -72,7 +72,7 @@ function init() {
         material1.needsUpdate = true;
     });
 
-    const cubemap2 = loader.load("textures/compressed/Mountains_argb_mip.dds", function (texture) {
+    const cubemap2 = loader.load("textures/compressed/Mountains_argb_mip.dds", function(texture) {
         texture.magFilter = THREE.LinearFilter;
         texture.minFilter = THREE.LinearFilter;
         texture.mapping = THREE.CubeReflectionMapping;
@@ -80,7 +80,7 @@ function init() {
         material5.needsUpdate = true;
     });
 
-    const cubemap3 = loader.load("textures/compressed/Mountains_argb_nomip.dds", function (texture) {
+    const cubemap3 = loader.load("textures/compressed/Mountains_argb_nomip.dds", function(texture) {
         texture.magFilter = THREE.LinearFilter;
         texture.minFilter = THREE.LinearFilter;
         texture.mapping = THREE.CubeReflectionMapping;
@@ -107,7 +107,7 @@ function init() {
     const material11 = new THREE.MeshBasicMaterial({ map: map9 });
     const material12 = new THREE.MeshBasicMaterial({ map: map10 });
 
-    let mesh = new THREE.Mesh(new THREE.TorusGeometry(), material1);
+    let mesh: THREE.Mesh = new THREE.Mesh(new THREE.TorusGeometry(), material1);
     mesh.position.x = -10;
     mesh.position.y = -2;
     scene.add(mesh);
diff --git a/examples-testing/examples/webgl_loader_texture_ktx.ts b/examples-testing/examples/webgl_loader_texture_ktx.ts
index 6f9d9c3..a0661af 100644
--- a/examples-testing/examples/webgl_loader_texture_ktx.ts
+++ b/examples-testing/examples/webgl_loader_texture_ktx.ts
@@ -17,8 +17,8 @@ import { KTXLoader } from "three/addons/loaders/KTXLoader.js";
 	ASTC_4x4, ASTC8x8 - transparent textures with full alpha range
 	*/
 
-let camera, scene, renderer;
-const meshes = [];
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+const meshes: THREE.Mesh[] = [];
 
 init();
 animate();
@@ -51,14 +51,14 @@ function init() {
         material1 = new THREE.MeshBasicMaterial({
             map: loader.load("textures/compressed/disturb_PVR2bpp.ktx"),
         });
-        material1.map.colorSpace = THREE.SRGBColorSpace;
+        material1.map!.colorSpace = THREE.SRGBColorSpace;
         material2 = new THREE.MeshBasicMaterial({
             map: loader.load("textures/compressed/lensflare_PVR4bpp.ktx"),
             depthTest: false,
             transparent: true,
             side: THREE.DoubleSide,
         });
-        material2.map.colorSpace = THREE.SRGBColorSpace;
+        material2.map!.colorSpace = THREE.SRGBColorSpace;
 
         meshes.push(new THREE.Mesh(geometry, material1));
         meshes.push(new THREE.Mesh(geometry, material2));
@@ -68,14 +68,14 @@ function init() {
         material1 = new THREE.MeshBasicMaterial({
             map: loader.load("textures/compressed/disturb_BC1.ktx"),
         });
-        material1.map.colorSpace = THREE.SRGBColorSpace;
+        material1.map!.colorSpace = THREE.SRGBColorSpace;
         material2 = new THREE.MeshBasicMaterial({
             map: loader.load("textures/compressed/lensflare_BC3.ktx"),
             depthTest: false,
             transparent: true,
             side: THREE.DoubleSide,
         });
-        material2.map.colorSpace = THREE.SRGBColorSpace;
+        material2.map!.colorSpace = THREE.SRGBColorSpace;
 
         meshes.push(new THREE.Mesh(geometry, material1));
         meshes.push(new THREE.Mesh(geometry, material2));
@@ -93,20 +93,20 @@ function init() {
         material1 = new THREE.MeshBasicMaterial({
             map: loader.load("textures/compressed/disturb_ASTC4x4.ktx"),
         });
-        material1.map.colorSpace = THREE.SRGBColorSpace;
+        material1.map!.colorSpace = THREE.SRGBColorSpace;
         material2 = new THREE.MeshBasicMaterial({
             map: loader.load("textures/compressed/lensflare_ASTC8x8.ktx"),
             depthTest: false,
             transparent: true,
             side: THREE.DoubleSide,
         });
-        material2.map.colorSpace = THREE.SRGBColorSpace;
+        material2.map!.colorSpace = THREE.SRGBColorSpace;
 
         meshes.push(new THREE.Mesh(geometry, material1));
         meshes.push(new THREE.Mesh(geometry, material2));
     }
 
-    let x = -meshes.length / 2 * 150;
+    let x = (-meshes.length / 2) * 150;
     for (let i = 0; i < meshes.length; ++i, x += 300) {
         const mesh = meshes[i];
         mesh.position.x = x;
diff --git a/examples-testing/examples/webgl_loader_texture_logluv.ts b/examples-testing/examples/webgl_loader_texture_logluv.ts
index 71c1d71..99c2de3 100644
--- a/examples-testing/examples/webgl_loader_texture_logluv.ts
+++ b/examples-testing/examples/webgl_loader_texture_logluv.ts
@@ -8,7 +8,7 @@ const params = {
     exposure: 2.0,
 };
 
-let renderer, scene, camera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.OrthographicCamera;
 
 init();
 
@@ -27,7 +27,7 @@ function init() {
 
     camera = new THREE.OrthographicCamera(-aspect, aspect, 1, -1, 0, 1);
 
-    new LogLuvLoader().load("textures/memorial.tif", function (texture) {
+    new LogLuvLoader().load("textures/memorial.tif", function(texture) {
         const material = new THREE.MeshBasicMaterial({ map: texture });
 
         const quad = new THREE.PlaneGeometry(1, 1.5);
@@ -56,8 +56,8 @@ function onWindowResize() {
 
     const frustumHeight = camera.top - camera.bottom;
 
-    camera.left = -frustumHeight * aspect / 2;
-    camera.right = frustumHeight * aspect / 2;
+    camera.left = (-frustumHeight * aspect) / 2;
+    camera.right = (frustumHeight * aspect) / 2;
 
     camera.updateProjectionMatrix();
 
diff --git a/examples-testing/examples/webgl_loader_texture_rgbm.ts b/examples-testing/examples/webgl_loader_texture_rgbm.ts
index 2379855..2bbf8d9 100644
--- a/examples-testing/examples/webgl_loader_texture_rgbm.ts
+++ b/examples-testing/examples/webgl_loader_texture_rgbm.ts
@@ -8,7 +8,7 @@ const params = {
     exposure: 2.0,
 };
 
-let renderer, scene, camera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.OrthographicCamera;
 
 init();
 
@@ -27,7 +27,7 @@ function init() {
 
     camera = new THREE.OrthographicCamera(-aspect, aspect, 1, -1, 0, 1);
 
-    new RGBMLoader().setMaxRange(16).load("textures/memorial.png", function (texture) {
+    new RGBMLoader().setMaxRange(16).load("textures/memorial.png", function(texture) {
         const material = new THREE.MeshBasicMaterial({ map: texture });
 
         const quad = new THREE.PlaneGeometry(1, 1.5);
@@ -56,8 +56,8 @@ function onWindowResize() {
 
     const frustumHeight = camera.top - camera.bottom;
 
-    camera.left = -frustumHeight * aspect / 2;
-    camera.right = frustumHeight * aspect / 2;
+    camera.left = (-frustumHeight * aspect) / 2;
+    camera.right = (frustumHeight * aspect) / 2;
 
     camera.updateProjectionMatrix();
 
diff --git a/examples-testing/examples/webgl_loader_texture_tga.ts b/examples-testing/examples/webgl_loader_texture_tga.ts
index 3f5c9d4..d56b161 100644
--- a/examples-testing/examples/webgl_loader_texture_tga.ts
+++ b/examples-testing/examples/webgl_loader_texture_tga.ts
@@ -5,7 +5,7 @@ import Stats from "three/addons/libs/stats.module.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { TGALoader } from "three/addons/loaders/TGALoader.js";
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_loader_texture_tiff.ts b/examples-testing/examples/webgl_loader_texture_tiff.ts
index ea7b966..90197de 100644
--- a/examples-testing/examples/webgl_loader_texture_tiff.ts
+++ b/examples-testing/examples/webgl_loader_texture_tiff.ts
@@ -2,7 +2,7 @@ import * as THREE from "three";
 
 import { TIFFLoader } from "three/addons/loaders/TIFFLoader.js";
 
-let renderer, scene, camera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
 
 init();
 
@@ -23,7 +23,7 @@ function init() {
 
     // uncompressed
 
-    loader.load("textures/tiff/crate_uncompressed.tif", function (texture) {
+    loader.load("textures/tiff/crate_uncompressed.tif", function(texture) {
         texture.colorSpace = THREE.SRGBColorSpace;
 
         const material = new THREE.MeshBasicMaterial({ map: texture });
@@ -38,7 +38,7 @@ function init() {
 
     // LZW
 
-    loader.load("textures/tiff/crate_lzw.tif", function (texture) {
+    loader.load("textures/tiff/crate_lzw.tif", function(texture) {
         texture.colorSpace = THREE.SRGBColorSpace;
 
         const material = new THREE.MeshBasicMaterial({ map: texture });
@@ -53,7 +53,7 @@ function init() {
 
     // JPEG
 
-    loader.load("textures/tiff/crate_jpeg.tif", function (texture) {
+    loader.load("textures/tiff/crate_jpeg.tif", function(texture) {
         texture.colorSpace = THREE.SRGBColorSpace;
 
         const material = new THREE.MeshBasicMaterial({ map: texture });
diff --git a/examples-testing/examples/webgl_loader_tilt.ts b/examples-testing/examples/webgl_loader_tilt.ts
index 75b16c4..21b22ff 100644
--- a/examples-testing/examples/webgl_loader_tilt.ts
+++ b/examples-testing/examples/webgl_loader_tilt.ts
@@ -3,7 +3,7 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { TiltLoader } from "three/addons/loaders/TiltLoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 
@@ -26,7 +26,7 @@ function init() {
     document.body.appendChild(renderer.domElement);
 
     const loader = new TiltLoader();
-    loader.load("./models/tilt/BRUSH_DOME.tilt", function (object) {
+    loader.load("./models/tilt/BRUSH_DOME.tilt", function(object) {
         // console.log( object.children.length );
         scene.add(object);
         render();
diff --git a/examples-testing/examples/webgl_loader_ttf.ts b/examples-testing/examples/webgl_loader_ttf.ts
index b064b27..1c114bd 100644
--- a/examples-testing/examples/webgl_loader_ttf.ts
+++ b/examples-testing/examples/webgl_loader_ttf.ts
@@ -1,12 +1,12 @@
 import * as THREE from "three";
 
-import { TTFLoader } from "three/addons/loaders/TTFLoader.js";
-import { Font } from "three/addons/loaders/FontLoader.js";
 import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
+import { Font } from "three/addons/loaders/FontLoader.js";
+import { TTFLoader } from "three/addons/loaders/TTFLoader.js";
 
-let container;
-let camera, cameraTarget, scene, renderer;
-let group, textMesh1, textMesh2, textGeo, material;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, cameraTarget: THREE.Vector3, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let group: THREE.Group, textMesh1: THREE.Mesh, textMesh2: THREE.Mesh, textGeo, material: THREE.MeshPhongMaterial;
 let firstLetter = true;
 
 let text = "three.js";
@@ -17,7 +17,7 @@ const height = 20,
     bevelThickness = 2,
     bevelSize = 1.5;
 
-let font = null;
+let font: Font | null = null;
 const mirror = true;
 
 let targetRotation = 0;
@@ -68,7 +68,7 @@ function init() {
 
     const loader = new TTFLoader();
 
-    loader.load("fonts/ttf/kenpixel.ttf", function (json) {
+    loader.load("fonts/ttf/kenpixel.ttf", function(json) {
         font = new Font(json);
         createText();
     });
@@ -108,7 +108,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentKeyDown(event) {
+function onDocumentKeyDown(event: KeyboardEvent) {
     if (firstLetter) {
         firstLetter = false;
         text = "";
@@ -128,7 +128,7 @@ function onDocumentKeyDown(event) {
     }
 }
 
-function onDocumentKeyPress(event) {
+function onDocumentKeyPress(event: KeyboardEvent) {
     const keyCode = event.which;
 
     // backspace
@@ -145,7 +145,7 @@ function onDocumentKeyPress(event) {
 
 function createText() {
     textGeo = new TextGeometry(text, {
-        font: font,
+        font: font!,
 
         size: size,
         height: height,
@@ -159,7 +159,7 @@ function createText() {
     textGeo.computeBoundingBox();
     textGeo.computeVertexNormals();
 
-    const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
+    const centerOffset = -0.5 * (textGeo.boundingBox!.max.x - textGeo.boundingBox!.min.x);
 
     textMesh1 = new THREE.Mesh(textGeo, material);
 
@@ -195,7 +195,7 @@ function refreshText() {
     createText();
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerXOnPointerDown = event.clientX - windowHalfX;
@@ -205,7 +205,7 @@ function onPointerDown(event) {
     document.addEventListener("pointerup", onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     pointerX = event.clientX - windowHalfX;
@@ -214,7 +214,7 @@ function onPointerMove(event) {
 }
 
 function onPointerUp() {
-    if (event.isPrimary === false) return;
+    if ((event as PointerEvent).isPrimary === false) return;
 
     document.removeEventListener("pointermove", onPointerMove);
     document.removeEventListener("pointerup", onPointerUp);
diff --git a/examples-testing/examples/webgl_loader_usdz.ts b/examples-testing/examples/webgl_loader_usdz.ts
index e0aa5b4..9ba12f7 100644
--- a/examples-testing/examples/webgl_loader_usdz.ts
+++ b/examples-testing/examples/webgl_loader_usdz.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 import { USDZLoader } from "three/addons/loaders/USDZLoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -28,11 +28,9 @@ async function init() {
     // controls.target.y = 15;
     // controls.update();
 
-    const rgbeLoader = new RGBELoader()
-        .setPath("textures/equirectangular/");
+    const rgbeLoader = new RGBELoader().setPath("textures/equirectangular/");
 
-    const usdzLoader = new USDZLoader()
-        .setPath("models/usdz/");
+    const usdzLoader = new USDZLoader().setPath("models/usdz/");
 
     const [texture, model] = await Promise.all([
         rgbeLoader.loadAsync("venice_sunset_1k.hdr"),
diff --git a/examples-testing/examples/webgl_loader_vox.ts b/examples-testing/examples/webgl_loader_vox.ts
index 78886ec..46550ca 100644
--- a/examples-testing/examples/webgl_loader_vox.ts
+++ b/examples-testing/examples/webgl_loader_vox.ts
@@ -3,7 +3,7 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { VOXLoader, VOXMesh } from "three/addons/loaders/VOXLoader.js";
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -29,7 +29,7 @@ function init() {
     scene.add(dirLight2);
 
     const loader = new VOXLoader();
-    loader.load("models/vox/monu10.vox", function (chunks) {
+    loader.load("models/vox/monu10.vox", function(chunks) {
         for (let i = 0; i < chunks.length; i++) {
             const chunk = chunks[i];
 
@@ -51,7 +51,7 @@ function init() {
     // controls
 
     controls = new OrbitControls(camera, renderer.domElement);
-    controls.minDistance = .1;
+    controls.minDistance = 0.1;
     controls.maxDistance = 0.5;
 
     //
diff --git a/examples-testing/examples/webgl_loader_vrml.ts b/examples-testing/examples/webgl_loader_vrml.ts
index 31c836b..a9ee47e 100644
--- a/examples-testing/examples/webgl_loader_vrml.ts
+++ b/examples-testing/examples/webgl_loader_vrml.ts
@@ -3,10 +3,15 @@ import * as THREE from "three";
 import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { VRMLLoader } from "three/addons/loaders/VRMLLoader.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import { VRMLLoader } from "three/addons/loaders/VRMLLoader.js";
 
-let camera, scene, renderer, stats, controls, loader;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    controls: OrbitControls,
+    loader: VRMLLoader;
 
 const params = {
     asset: "house",
@@ -28,7 +33,7 @@ const assets = [
     "points",
 ];
 
-let vrmlScene;
+let vrmlScene: THREE.Scene;
 
 init();
 animate();
@@ -78,12 +83,19 @@ function init() {
     //
 
     const gui = new GUI();
-    gui.add(params, "asset", assets).onChange(function (value) {
+    gui.add(params, "asset", assets).onChange(function(value) {
         if (vrmlScene) {
-            vrmlScene.traverse(function (object) {
-                if (object.material) object.material.dispose();
-                if (object.material && object.material.map) object.material.map.dispose();
-                if (object.geometry) object.geometry.dispose();
+            vrmlScene.traverse(function(object) {
+                if ((object as THREE.Mesh).material) {
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.dispose();
+                }
+                if (
+                    (object as THREE.Mesh).material
+                    && (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).material.map
+                ) {
+                    (object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhongMaterial>).material.map!.dispose();
+                }
+                if ((object as THREE.Mesh).geometry) (object as THREE.Mesh).geometry.dispose();
             });
 
             scene.remove(vrmlScene);
@@ -93,8 +105,8 @@ function init() {
     });
 }
 
-function loadAsset(asset) {
-    loader.load("models/vrml/" + asset + ".wrl", function (object) {
+function loadAsset(asset: string) {
+    loader.load("models/vrml/" + asset + ".wrl", function(object) {
         vrmlScene = object;
         scene.add(object);
         controls.reset();
diff --git a/examples-testing/examples/webgl_loader_vtk.ts b/examples-testing/examples/webgl_loader_vtk.ts
index f86f415..b14d616 100644
--- a/examples-testing/examples/webgl_loader_vtk.ts
+++ b/examples-testing/examples/webgl_loader_vtk.ts
@@ -5,9 +5,9 @@ import Stats from "three/addons/libs/stats.module.js";
 import { TrackballControls } from "three/addons/controls/TrackballControls.js";
 import { VTKLoader } from "three/addons/loaders/VTKLoader.js";
 
-let stats;
+let stats: Stats;
 
-let camera, controls, scene, renderer;
+let camera: THREE.PerspectiveCamera, controls: TrackballControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -30,7 +30,7 @@ function init() {
     scene.add(dirLight);
 
     const loader = new VTKLoader();
-    loader.load("models/vtk/bunny.vtk", function (geometry) {
+    loader.load("models/vtk/bunny.vtk", function(geometry) {
         geometry.center();
         geometry.computeVertexNormals();
 
@@ -42,7 +42,7 @@ function init() {
     });
 
     const loader1 = new VTKLoader();
-    loader1.load("models/vtk/cube_ascii.vtp", function (geometry) {
+    loader1.load("models/vtk/cube_ascii.vtp", function(geometry) {
         geometry.computeVertexNormals();
         geometry.center();
 
@@ -56,7 +56,7 @@ function init() {
     });
 
     const loader2 = new VTKLoader();
-    loader2.load("models/vtk/cube_binary.vtp", function (geometry) {
+    loader2.load("models/vtk/cube_binary.vtp", function(geometry) {
         geometry.computeVertexNormals();
         geometry.center();
 
@@ -70,7 +70,7 @@ function init() {
     });
 
     const loader3 = new VTKLoader();
-    loader3.load("models/vtk/cube_no_compression.vtp", function (geometry) {
+    loader3.load("models/vtk/cube_no_compression.vtp", function(geometry) {
         geometry.computeVertexNormals();
         geometry.center();
 
@@ -93,7 +93,7 @@ function init() {
     // controls
 
     controls = new TrackballControls(camera, renderer.domElement);
-    controls.minDistance = .1;
+    controls.minDistance = 0.1;
     controls.maxDistance = 0.5;
     controls.rotateSpeed = 5.0;
 
diff --git a/examples-testing/examples/webgl_loader_xyz.ts b/examples-testing/examples/webgl_loader_xyz.ts
index 2f3a950..bfe3109 100644
--- a/examples-testing/examples/webgl_loader_xyz.ts
+++ b/examples-testing/examples/webgl_loader_xyz.ts
@@ -2,9 +2,9 @@ import * as THREE from "three";
 
 import { XYZLoader } from "three/addons/loaders/XYZLoader.js";
 
-let camera, scene, renderer, clock;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
 
-let points;
+let points: THREE.Points;
 
 init();
 animate();
@@ -20,7 +20,7 @@ function init() {
     clock = new THREE.Clock();
 
     const loader = new XYZLoader();
-    loader.load("models/xyz/helix_201.xyz", function (geometry) {
+    loader.load("models/xyz/helix_201.xyz", function(geometry) {
         geometry.center();
 
         const vertexColors = geometry.hasAttribute("color") === true;
diff --git a/examples-testing/examples/webgl_lod.ts b/examples-testing/examples/webgl_lod.ts
index 6a494b0..c600666 100644
--- a/examples-testing/examples/webgl_lod.ts
+++ b/examples-testing/examples/webgl_lod.ts
@@ -2,9 +2,9 @@ import * as THREE from "three";
 
 import { FlyControls } from "three/addons/controls/FlyControls.js";
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: FlyControls;
 
 const clock = new THREE.Clock();
 
@@ -29,7 +29,7 @@ function init() {
     dirLight.position.set(0, 0, 1).normalize();
     scene.add(dirLight);
 
-    const geometry = [
+    const geometry: [THREE.IcosahedronGeometry, number][] = [
         [new THREE.IcosahedronGeometry(100, 16), 50],
         [new THREE.IcosahedronGeometry(100, 8), 300],
         [new THREE.IcosahedronGeometry(100, 4), 1000],
diff --git a/examples-testing/examples/webgl_marchingcubes.ts b/examples-testing/examples/webgl_marchingcubes.ts
index 529e6b0..7f28648 100644
--- a/examples-testing/examples/webgl_marchingcubes.ts
+++ b/examples-testing/examples/webgl_marchingcubes.ts
@@ -2,22 +2,47 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { MarchingCubes } from "three/addons/objects/MarchingCubes.js";
 import { ToonShader1, ToonShader2, ToonShaderDotted, ToonShaderHatching } from "three/addons/shaders/ToonShader.js";
 
-let container, stats;
-
-let camera, scene, renderer;
-
-let materials, current_material;
-
-let light, pointLight, ambientLight;
-
-let effect, resolution;
-
-let effectController;
+let container: HTMLElement, stats: Stats;
+
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+
+type Material =
+    | "shiny"
+    | "chrome"
+    | "liquid"
+    | "matte"
+    | "flat"
+    | "textured"
+    | "colors"
+    | "multiColors"
+    | "plastic"
+    | "toon1"
+    | "toon2"
+    | "hatching"
+    | "dotted";
+
+let materials: { [M in Material]: THREE.Material }, current_material: Material;
+
+let light: THREE.DirectionalLight, pointLight: THREE.PointLight, ambientLight: THREE.AmbientLight;
+
+let effect: MarchingCubes, resolution: number;
+
+let effectController: {
+    material: Material;
+    speed: number;
+    numBlobs: number;
+    resolution: number;
+    isolation: number;
+    floor: boolean;
+    wallx: boolean;
+    wallz: boolean;
+    dummy: () => void;
+} & { [M in Material]?: () => void };
 
 let time = 0;
 
@@ -27,7 +52,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     // CAMERA
 
@@ -139,35 +164,36 @@ function generateMaterials() {
     texture.colorSpace = THREE.SRGBColorSpace;
 
     const materials = {
-        "shiny": new THREE.MeshStandardMaterial({
+        shiny: new THREE.MeshStandardMaterial({
             color: 0x9c0000,
             envMap: reflectionCube,
             roughness: 0.1,
             metalness: 1.0,
         }),
-        "chrome": new THREE.MeshLambertMaterial({ color: 0xffffff, envMap: reflectionCube }),
-        "liquid": new THREE.MeshLambertMaterial({ color: 0xffffff, envMap: refractionCube, refractionRatio: 0.85 }),
-        "matte": new THREE.MeshPhongMaterial({ specular: 0x494949, shininess: 1 }),
-        "flat": new THREE.MeshLambertMaterial({/*TODO flatShading: true */}),
-        "textured": new THREE.MeshPhongMaterial({ color: 0xffffff, specular: 0x111111, shininess: 1, map: texture }),
-        "colors": new THREE.MeshPhongMaterial({
-            color: 0xffffff,
-            specular: 0xffffff,
-            shininess: 2,
-            vertexColors: true,
+        chrome: new THREE.MeshLambertMaterial({ color: 0xffffff, envMap: reflectionCube }),
+        liquid: new THREE.MeshLambertMaterial({ color: 0xffffff, envMap: refractionCube, refractionRatio: 0.85 }),
+        matte: new THREE.MeshPhongMaterial({ specular: 0x494949, shininess: 1 }),
+        flat: new THREE.MeshLambertMaterial({
+            /*TODO flatShading: true */
         }),
-        "multiColors": new THREE.MeshPhongMaterial({ shininess: 2, vertexColors: true }),
-        "plastic": new THREE.MeshPhongMaterial({ specular: 0xc1c1c1, shininess: 250 }),
-        "toon1": toonMaterial1,
-        "toon2": toonMaterial2,
-        "hatching": hatchingMaterial,
-        "dotted": dottedMaterial,
+        textured: new THREE.MeshPhongMaterial({ color: 0xffffff, specular: 0x111111, shininess: 1, map: texture }),
+        colors: new THREE.MeshPhongMaterial({ color: 0xffffff, specular: 0xffffff, shininess: 2, vertexColors: true }),
+        multiColors: new THREE.MeshPhongMaterial({ shininess: 2, vertexColors: true }),
+        plastic: new THREE.MeshPhongMaterial({ specular: 0xc1c1c1, shininess: 250 }),
+        toon1: toonMaterial1,
+        toon2: toonMaterial2,
+        hatching: hatchingMaterial,
+        dotted: dottedMaterial,
     };
 
     return materials;
 }
 
-function createShaderMaterial(shader, light, ambientLight) {
+function createShaderMaterial(
+    shader: { uniforms: Record<string, THREE.IUniform>; vertexShader: string; fragmentShader: string },
+    light: THREE.DirectionalLight,
+    ambientLight: THREE.AmbientLight,
+) {
     const u = THREE.UniformsUtils.clone(shader.uniforms);
 
     const vs = shader.vertexShader;
@@ -186,13 +212,13 @@ function createShaderMaterial(shader, light, ambientLight) {
 //
 
 function setupGui() {
-    const createHandler = function (id) {
-        return function () {
+    const createHandler = function(id: Material) {
+        return function() {
             current_material = id;
 
             effect.material = materials[id];
-            effect.enableUvs = (current_material === "textured") ? true : false;
-            effect.enableColors = (current_material === "colors" || current_material === "multiColors") ? true : false;
+            effect.enableUvs = current_material === "textured" ? true : false;
+            effect.enableColors = current_material === "colors" || current_material === "multiColors" ? true : false;
         };
     };
 
@@ -208,7 +234,7 @@ function setupGui() {
         wallx: false,
         wallz: false,
 
-        dummy: function () {},
+        dummy: function() {},
     };
 
     let h;
@@ -220,8 +246,8 @@ function setupGui() {
     h = gui.addFolder("Materials");
 
     for (const m in materials) {
-        effectController[m] = createHandler(m);
-        h.add(effectController, m).name(m);
+        effectController[m as Material] = createHandler(m as Material);
+        h.add(effectController as Required<typeof effectController>, m as Material).name(m);
     }
 
     // simulation
@@ -240,7 +266,14 @@ function setupGui() {
 
 // this controls content of marching cubes voxel field
 
-function updateCubes(object, time, numblobs, floor, wallx, wallz) {
+function updateCubes(
+    object: MarchingCubes,
+    time: number,
+    numblobs: number,
+    floor: boolean,
+    wallx: boolean,
+    wallz: boolean,
+) {
     object.reset();
 
     // fill the field with some metaballs
diff --git a/examples-testing/examples/webgl_materials_alphahash.ts b/examples-testing/examples/webgl_materials_alphahash.ts
index 84b7b41..8ea07e8 100644
--- a/examples-testing/examples/webgl_materials_alphahash.ts
+++ b/examples-testing/examples/webgl_materials_alphahash.ts
@@ -1,18 +1,24 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
+import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { TAARenderPass } from "three/addons/postprocessing/TAARenderPass.js";
-import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 
-let camera, scene, renderer, controls, stats, mesh, material;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    controls,
+    stats: Stats,
+    mesh: THREE.InstancedMesh,
+    material: THREE.MeshStandardMaterial;
 
-let composer, renderPass, taaRenderPass, outputPass;
+let composer: EffectComposer, renderPass: RenderPass, taaRenderPass: TAARenderPass, outputPass: OutputPass;
 
 let needsUpdate = false;
 
@@ -115,14 +121,17 @@ function init() {
 
     const taaFolder = gui.addFolder("Temporal Anti-Aliasing");
 
-    taaFolder.add(params, "taa").name("enabled").onChange(() => {
-        renderPass.enabled = !params.taa;
-        taaRenderPass.enabled = params.taa;
+    taaFolder
+        .add(params, "taa")
+        .name("enabled")
+        .onChange(() => {
+            renderPass.enabled = !params.taa;
+            taaRenderPass.enabled = params.taa;
 
-        sampleLevelCtrl.enable(params.taa);
+            sampleLevelCtrl.enable(params.taa);
 
-        needsUpdate = true;
-    });
+            needsUpdate = true;
+        });
 
     const sampleLevelCtrl = taaFolder.add(params, "sampleLevel", 0, 6, 1).onChange(() => (needsUpdate = true));
 
diff --git a/examples-testing/examples/webgl_materials_blending.ts b/examples-testing/examples/webgl_materials_blending.ts
index c0218d2..01f833b 100644
--- a/examples-testing/examples/webgl_materials_blending.ts
+++ b/examples-testing/examples/webgl_materials_blending.ts
@@ -1,7 +1,7 @@
 import * as THREE from "three";
 
-let camera, scene, renderer;
-let mapBg;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mapBg: THREE.CanvasTexture;
 
 const textureLoader = new THREE.TextureLoader();
 
@@ -21,7 +21,7 @@ function init() {
     // BACKGROUND
 
     const canvas = document.createElement("canvas");
-    const ctx = canvas.getContext("2d");
+    const ctx = canvas.getContext("2d")!;
     canvas.width = canvas.height = 128;
     ctx.fillStyle = "#ddd";
     ctx.fillRect(0, 0, 128, 128);
@@ -51,7 +51,7 @@ function init() {
         { name: "Multiply", constant: THREE.MultiplyBlending },
     ];
 
-    const assignSRGB = (texture) => {
+    const assignSRGB = (texture: THREE.Texture) => {
         texture.colorSpace = THREE.SRGBColorSpace;
     };
 
@@ -70,7 +70,7 @@ function init() {
     addImageRow(map3, -150);
     addImageRow(map4, -300);
 
-    function addImageRow(map, y) {
+    function addImageRow(map: THREE.Texture, y: number) {
         for (let i = 0; i < blendings.length; i++) {
             const blending = blendings[i];
 
@@ -115,9 +115,9 @@ function onWindowResize() {
     camera.updateProjectionMatrix();
 }
 
-function generateLabelMaterial(text) {
+function generateLabelMaterial(text: string) {
     const canvas = document.createElement("canvas");
-    const ctx = canvas.getContext("2d");
+    const ctx = canvas.getContext("2d")!;
     canvas.width = 128;
     canvas.height = 32;
 
diff --git a/examples-testing/examples/webgl_materials_blending_custom.ts b/examples-testing/examples/webgl_materials_blending_custom.ts
index 8106f64..7519985 100644
--- a/examples-testing/examples/webgl_materials_blending_custom.ts
+++ b/examples-testing/examples/webgl_materials_blending_custom.ts
@@ -2,12 +2,12 @@ import * as THREE from "three";
 
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mapBg;
-const materials = [];
+let mapBg: THREE.CanvasTexture;
+const materials: THREE.Material[] = [];
 
-const params = {
+const params: { blendEquation: THREE.BlendingEquation } = {
     blendEquation: THREE.AddEquation,
 };
 
@@ -35,7 +35,7 @@ function init() {
     // BACKGROUND
 
     const canvas = document.createElement("canvas");
-    const ctx = canvas.getContext("2d");
+    const ctx = canvas.getContext("2d")!;
     canvas.width = canvas.height = 128;
     ctx.fillStyle = "#ddd";
     ctx.fillRect(0, 0, 128, 128);
@@ -177,9 +177,9 @@ function onWindowResize() {
 
 //
 
-function generateLabelMaterial(text, bg) {
+function generateLabelMaterial(text: string, bg: string) {
     const canvas = document.createElement("canvas");
-    const ctx = canvas.getContext("2d");
+    const ctx = canvas.getContext("2d")!;
     canvas.width = 128;
     canvas.height = 32;
 
@@ -197,7 +197,7 @@ function generateLabelMaterial(text, bg) {
     return material;
 }
 
-function updateBlendEquation(value) {
+function updateBlendEquation(value: THREE.BlendingEquation) {
     for (const material of materials) {
         material.blendEquation = value;
     }
diff --git a/examples-testing/examples/webgl_materials_bumpmap.ts b/examples-testing/examples/webgl_materials_bumpmap.ts
index 8916906..d58b551 100644
--- a/examples-testing/examples/webgl_materials_bumpmap.ts
+++ b/examples-testing/examples/webgl_materials_bumpmap.ts
@@ -4,13 +4,13 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-let container, stats, loader;
+let container: HTMLDivElement, stats: Stats, loader: GLTFLoader;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh;
+let mesh: THREE.Mesh;
 
-let spotLight;
+let spotLight: THREE.SpotLight;
 
 let mouseX = 0;
 let mouseY = 0;
@@ -71,8 +71,8 @@ function init() {
     });
 
     loader = new GLTFLoader();
-    loader.load("models/gltf/LeePerrySmith/LeePerrySmith.glb", function (gltf) {
-        createScene(gltf.scene.children[0].geometry, 1, material);
+    loader.load("models/gltf/LeePerrySmith/LeePerrySmith.glb", function(gltf) {
+        createScene((gltf.scene.children[0] as THREE.Mesh).geometry, 1, material);
     });
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -93,7 +93,7 @@ function init() {
     window.addEventListener("resize", onWindowResize);
 }
 
-function createScene(geometry, scale, material) {
+function createScene(geometry: THREE.BufferGeometry, scale: number, material: THREE.Material) {
     mesh = new THREE.Mesh(geometry, material);
 
     mesh.position.y = -0.5;
@@ -114,7 +114,7 @@ function onWindowResize() {
     camera.updateProjectionMatrix();
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
@@ -130,8 +130,8 @@ function animate() {
 }
 
 function render() {
-    targetX = mouseX * .001;
-    targetY = mouseY * .001;
+    targetX = mouseX * 0.001;
+    targetY = mouseY * 0.001;
 
     if (mesh) {
         mesh.rotation.y += 0.05 * (targetX - mesh.rotation.y);
diff --git a/examples-testing/examples/webgl_materials_car.ts b/examples-testing/examples/webgl_materials_car.ts
index be3d20b..d9b4a49 100644
--- a/examples-testing/examples/webgl_materials_car.ts
+++ b/examples-testing/examples/webgl_materials_car.ts
@@ -4,20 +4,20 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
+import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 
-let camera, scene, renderer;
-let stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let stats: Stats;
 
-let grid;
-let controls;
+let grid: THREE.GridHelper;
+let controls: OrbitControls;
 
-const wheels = [];
+const wheels: THREE.Object3D[] = [];
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -78,18 +78,18 @@ function init() {
         transmission: 1.0,
     });
 
-    const bodyColorInput = document.getElementById("body-color");
-    bodyColorInput.addEventListener("input", function () {
+    const bodyColorInput = document.getElementById("body-color") as HTMLInputElement;
+    bodyColorInput.addEventListener("input", function() {
         bodyMaterial.color.set(this.value);
     });
 
-    const detailsColorInput = document.getElementById("details-color");
-    detailsColorInput.addEventListener("input", function () {
+    const detailsColorInput = document.getElementById("details-color") as HTMLInputElement;
+    detailsColorInput.addEventListener("input", function() {
         detailsMaterial.color.set(this.value);
     });
 
-    const glassColorInput = document.getElementById("glass-color");
-    glassColorInput.addEventListener("input", function () {
+    const glassColorInput = document.getElementById("glass-color") as HTMLInputElement;
+    glassColorInput.addEventListener("input", function() {
         glassMaterial.color.set(this.value);
     });
 
@@ -103,24 +103,24 @@ function init() {
     const loader = new GLTFLoader();
     loader.setDRACOLoader(dracoLoader);
 
-    loader.load("models/gltf/ferrari.glb", function (gltf) {
+    loader.load("models/gltf/ferrari.glb", function(gltf) {
         const carModel = gltf.scene.children[0];
 
-        carModel.getObjectByName("body").material = bodyMaterial;
+        (carModel.getObjectByName("body") as THREE.Mesh).material = bodyMaterial;
 
-        carModel.getObjectByName("rim_fl").material = detailsMaterial;
-        carModel.getObjectByName("rim_fr").material = detailsMaterial;
-        carModel.getObjectByName("rim_rr").material = detailsMaterial;
-        carModel.getObjectByName("rim_rl").material = detailsMaterial;
-        carModel.getObjectByName("trim").material = detailsMaterial;
+        (carModel.getObjectByName("rim_fl") as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName("rim_fr") as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName("rim_rr") as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName("rim_rl") as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName("trim") as THREE.Mesh).material = detailsMaterial;
 
-        carModel.getObjectByName("glass").material = glassMaterial;
+        (carModel.getObjectByName("glass") as THREE.Mesh).material = glassMaterial;
 
         wheels.push(
-            carModel.getObjectByName("wheel_fl"),
-            carModel.getObjectByName("wheel_fr"),
-            carModel.getObjectByName("wheel_rl"),
-            carModel.getObjectByName("wheel_rr"),
+            carModel.getObjectByName("wheel_fl")!,
+            carModel.getObjectByName("wheel_fr")!,
+            carModel.getObjectByName("wheel_rl")!,
+            carModel.getObjectByName("wheel_rr")!,
         );
 
         // shadow
diff --git a/examples-testing/examples/webgl_materials_cubemap.ts b/examples-testing/examples/webgl_materials_cubemap.ts
index 6475a0f..418cf37 100644
--- a/examples-testing/examples/webgl_materials_cubemap.ts
+++ b/examples-testing/examples/webgl_materials_cubemap.ts
@@ -5,9 +5,9 @@ import Stats from "three/addons/libs/stats.module.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let pointLight;
 
@@ -21,7 +21,7 @@ function init() {
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
     camera.position.z = 13;
 
-    //cubemap
+    // cubemap
     const path = "textures/cube/SwedishRoyalCastle/";
     const format = ".jpg";
     const urls = [
@@ -40,14 +40,14 @@ function init() {
     scene = new THREE.Scene();
     scene.background = reflectionCube;
 
-    //lights
+    // lights
     const ambient = new THREE.AmbientLight(0xffffff, 3);
     scene.add(ambient);
 
     pointLight = new THREE.PointLight(0xffffff, 200);
     scene.add(pointLight);
 
-    //materials
+    // materials
     const cubeMaterial3 = new THREE.MeshLambertMaterial({
         color: 0xffaa00,
         envMap: reflectionCube,
@@ -61,12 +61,12 @@ function init() {
     });
     const cubeMaterial1 = new THREE.MeshLambertMaterial({ color: 0xffffff, envMap: reflectionCube });
 
-    //models
+    // models
     const objLoader = new OBJLoader();
 
     objLoader.setPath("models/obj/walt/");
-    objLoader.load("WaltHead.obj", function (object) {
-        const head = object.children[0];
+    objLoader.load("WaltHead.obj", function(object) {
+        const head = object.children[0] as THREE.Mesh;
         head.scale.setScalar(0.1);
         head.position.y = -3;
         head.material = cubeMaterial1;
@@ -82,20 +82,20 @@ function init() {
         scene.add(head, head2, head3);
     });
 
-    //renderer
+    // renderer
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
     container.appendChild(renderer.domElement);
 
-    //controls
+    // controls
     const controls = new OrbitControls(camera, renderer.domElement);
     controls.enableZoom = false;
     controls.enablePan = false;
     controls.minPolarAngle = Math.PI / 4;
     controls.maxPolarAngle = Math.PI / 1.5;
 
-    //stats
+    // stats
     stats = new Stats();
     container.appendChild(stats.dom);
 
diff --git a/examples-testing/examples/webgl_materials_cubemap_dynamic.ts b/examples-testing/examples/webgl_materials_cubemap_dynamic.ts
index 1665276..2e1daf6 100644
--- a/examples-testing/examples/webgl_materials_cubemap_dynamic.ts
+++ b/examples-testing/examples/webgl_materials_cubemap_dynamic.ts
@@ -6,12 +6,12 @@ import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import Stats from "three/addons/libs/stats.module.js";
 
-let camera, scene, renderer, stats;
-let cube, sphere, torus, material;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let cube: THREE.Mesh, sphere: THREE.Mesh, torus: THREE.Mesh, material: THREE.MeshStandardMaterial;
 
-let cubeCamera, cubeRenderTarget;
+let cubeCamera: THREE.CubeCamera, cubeRenderTarget: THREE.WebGLCubeRenderTarget;
 
-let controls;
+let controls: OrbitControls;
 
 init();
 
@@ -34,14 +34,12 @@ function init() {
     scene = new THREE.Scene();
     scene.rotation.y = 0.5; // avoid flying objects occluding the sun
 
-    new RGBELoader()
-        .setPath("textures/equirectangular/")
-        .load("quarry_01_1k.hdr", function (texture) {
-            texture.mapping = THREE.EquirectangularReflectionMapping;
+    new RGBELoader().setPath("textures/equirectangular/").load("quarry_01_1k.hdr", function(texture) {
+        texture.mapping = THREE.EquirectangularReflectionMapping;
 
-            scene.background = texture;
-            scene.environment = texture;
-        });
+        scene.background = texture;
+        scene.environment = texture;
+    });
 
     //
 
@@ -90,7 +88,7 @@ function onWindowResized() {
     camera.updateProjectionMatrix();
 }
 
-function animation(msTime) {
+function animation(msTime: DOMHighResTimeStamp) {
     const time = msTime / 1000;
 
     cube.position.x = Math.cos(time) * 30;
diff --git a/examples-testing/examples/webgl_materials_cubemap_mipmaps.ts b/examples-testing/examples/webgl_materials_cubemap_mipmaps.ts
index d8eea5b..66ae0a3 100644
--- a/examples-testing/examples/webgl_materials_cubemap_mipmaps.ts
+++ b/examples-testing/examples/webgl_materials_cubemap_mipmaps.ts
@@ -2,23 +2,23 @@ import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
 
-//load customized cube texture
+// load customized cube texture
 async function loadCubeTextureWithMipmaps() {
     const path = "textures/cube/angus/";
     const format = ".jpg";
-    const mipmaps = [];
+    const mipmaps: THREE.CubeTexture[] = [];
     const maxLevel = 8;
 
-    async function loadCubeTexture(urls) {
-        return new Promise(function (resolve) {
-            new THREE.CubeTextureLoader().load(urls, function (cubeTexture) {
+    async function loadCubeTexture(urls: string[]) {
+        return new Promise<THREE.CubeTexture>(function(resolve) {
+            new THREE.CubeTextureLoader().load(urls, function(cubeTexture) {
                 resolve(cubeTexture);
             });
         });
@@ -37,7 +37,7 @@ async function loadCubeTextureWithMipmaps() {
         const mipmapLevel = level;
 
         pendings.push(
-            loadCubeTexture(urls).then(function (cubeTexture) {
+            loadCubeTexture(urls).then(function(cubeTexture) {
                 mipmaps[mipmapLevel] = cubeTexture;
             }),
         );
@@ -45,7 +45,7 @@ async function loadCubeTextureWithMipmaps() {
 
     await Promise.all(pendings);
 
-    const customizedCubeTexture = mipmaps.shift();
+    const customizedCubeTexture = mipmaps.shift()!;
     customizedCubeTexture.mipmaps = mipmaps;
     customizedCubeTexture.colorSpace = THREE.SRGBColorSpace;
     customizedCubeTexture.minFilter = THREE.LinearMipMapLinearFilter;
@@ -65,11 +65,11 @@ function init() {
 
     scene = new THREE.Scene();
 
-    loadCubeTextureWithMipmaps().then(function (cubeTexture) {
-        //model
+    loadCubeTextureWithMipmaps().then(function(cubeTexture) {
+        // model
         const sphere = new THREE.SphereGeometry(100, 128, 128);
 
-        //manual mipmaps
+        // manual mipmaps
         let material = new THREE.MeshBasicMaterial({ color: 0xffffff, envMap: cubeTexture });
         material.name = "manual mipmaps";
 
@@ -77,7 +77,7 @@ function init() {
         mesh.position.set(100, 0, 0);
         scene.add(mesh);
 
-        //webgl mipmaps
+        // webgl mipmaps
         material = material.clone();
         material.name = "auto mipmaps";
 
@@ -93,13 +93,13 @@ function init() {
         scene.add(mesh);
     });
 
-    //renderer
+    // renderer
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
     container.appendChild(renderer.domElement);
 
-    //controls
+    // controls
     const controls = new OrbitControls(camera, renderer.domElement);
     controls.minPolarAngle = Math.PI / 4;
     controls.maxPolarAngle = Math.PI / 1.5;
diff --git a/examples-testing/examples/webgl_materials_cubemap_refraction.ts b/examples-testing/examples/webgl_materials_cubemap_refraction.ts
index 540a134..8dc87e4 100644
--- a/examples-testing/examples/webgl_materials_cubemap_refraction.ts
+++ b/examples-testing/examples/webgl_materials_cubemap_refraction.ts
@@ -4,11 +4,12 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { PLYLoader } from "three/addons/loaders/PLYLoader.js";
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mouseX = 0, mouseY = 0;
+let mouseX = 0,
+    mouseY = 0;
 
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
@@ -27,14 +28,7 @@ function init() {
 
     const r = "textures/cube/Park3Med/";
 
-    const urls = [
-        r + "px.jpg",
-        r + "nx.jpg",
-        r + "py.jpg",
-        r + "ny.jpg",
-        r + "pz.jpg",
-        r + "nz.jpg",
-    ];
+    const urls = [r + "px.jpg", r + "nx.jpg", r + "py.jpg", r + "ny.jpg", r + "pz.jpg", r + "nz.jpg"];
 
     const textureCube = new THREE.CubeTextureLoader().load(urls);
     textureCube.mapping = THREE.CubeRefractionMapping;
@@ -69,7 +63,7 @@ function init() {
     container.appendChild(stats.dom);
 
     const loader = new PLYLoader();
-    loader.load("models/ply/binary/Lucy100k.ply", function (geometry) {
+    loader.load("models/ply/binary/Lucy100k.ply", function(geometry) {
         createScene(geometry, cubeMaterial1, cubeMaterial2, cubeMaterial3);
     });
 
@@ -90,7 +84,12 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function createScene(geometry, m1, m2, m3) {
+function createScene(
+    geometry: THREE.BufferGeometry,
+    m1: THREE.MeshPhongMaterial,
+    m2: THREE.MeshPhongMaterial,
+    m3: THREE.MeshPhongMaterial,
+) {
     geometry.computeVertexNormals();
 
     const s = 1.5;
@@ -110,7 +109,7 @@ function createScene(geometry, m1, m2, m3) {
     scene.add(mesh);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = (event.clientX - windowHalfX) * 4;
     mouseY = (event.clientY - windowHalfY) * 4;
 }
@@ -125,8 +124,8 @@ function animate() {
 }
 
 function render() {
-    camera.position.x += (mouseX - camera.position.x) * .05;
-    camera.position.y += (-mouseY - camera.position.y) * .05;
+    camera.position.x += (mouseX - camera.position.x) * 0.05;
+    camera.position.y += (-mouseY - camera.position.y) * 0.05;
 
     camera.lookAt(scene.position);
 
diff --git a/examples-testing/examples/webgl_materials_cubemap_render_to_mipmaps.ts b/examples-testing/examples/webgl_materials_cubemap_render_to_mipmaps.ts
index 05003c0..ec0ada0 100644
--- a/examples-testing/examples/webgl_materials_cubemap_render_to_mipmaps.ts
+++ b/examples-testing/examples/webgl_materials_cubemap_render_to_mipmaps.ts
@@ -1,8 +1,8 @@
 import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let container;
-let camera, scene, renderer;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const CubemapFilterShader = {
     name: "CubemapFilterShader",
@@ -56,15 +56,15 @@ const CubemapFilterShader = {
 init();
 animate();
 
-async function loadCubeTexture(urls) {
-    return new Promise(function (resolve) {
-        new THREE.CubeTextureLoader().load(urls, function (cubeTexture) {
+async function loadCubeTexture(urls: string[]) {
+    return new Promise<THREE.CubeTexture>(function(resolve) {
+        new THREE.CubeTextureLoader().load(urls, function(cubeTexture) {
             resolve(cubeTexture);
         });
     });
 }
 
-function allocateCubemapRenderTarget(cubeMapSize) {
+function allocateCubemapRenderTarget(cubeMapSize: number) {
     const params = {
         magFilter: THREE.LinearFilter,
         minFilter: THREE.LinearMipMapLinearFilter,
@@ -84,7 +84,7 @@ function allocateCubemapRenderTarget(cubeMapSize) {
     return rt;
 }
 
-function renderToCubeTexture(cubeMapRenderTarget, sourceCubeTexture) {
+function renderToCubeTexture(cubeMapRenderTarget: THREE.WebGLCubeRenderTarget, sourceCubeTexture: THREE.CubeTexture) {
     const geometry = new THREE.BoxGeometry(5, 5, 5);
 
     const material = new THREE.ShaderMaterial({
@@ -145,16 +145,9 @@ function init() {
 
     // Load a cube texture
     const r = "textures/cube/Park3Med/";
-    const urls = [
-        r + "px.jpg",
-        r + "nx.jpg",
-        r + "py.jpg",
-        r + "ny.jpg",
-        r + "pz.jpg",
-        r + "nz.jpg",
-    ];
-
-    loadCubeTexture(urls).then((cubeTexture) => {
+    const urls = [r + "px.jpg", r + "nx.jpg", r + "py.jpg", r + "ny.jpg", r + "pz.jpg", r + "nz.jpg"];
+
+    loadCubeTexture(urls).then(cubeTexture => {
         // Allocate a cube map render target
         const cubeMapRenderTarget = allocateCubemapRenderTarget(512);
 
diff --git a/examples-testing/examples/webgl_materials_curvature.ts b/examples-testing/examples/webgl_materials_curvature.ts
index dc3ac78..10f6c16 100644
--- a/examples-testing/examples/webgl_materials_curvature.ts
+++ b/examples-testing/examples/webgl_materials_curvature.ts
@@ -1,22 +1,24 @@
 import * as THREE from "three";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let ninjaMeshRaw, curvatureAttribute, bufferGeo;
+let ninjaMeshRaw: THREE.Mesh,
+    curvatureAttribute: Float32Array,
+    bufferGeo: THREE.BufferGeometry<Record<string, THREE.BufferAttribute>>;
 
 init();
 animate();
 
-//returns average of elements in a dictionary
-function average(dict) {
+// returns average of elements in a dictionary
+function average(dict: Record<string, number>) {
     let sum = 0;
     let length = 0;
 
-    Object.keys(dict).forEach(function (key) {
+    Object.keys(dict).forEach(function(key) {
         sum += dict[key];
         length++;
     });
@@ -24,33 +26,33 @@ function average(dict) {
     return sum / length;
 }
 
-//clamp a number between min and max
-function clamp(number, min, max) {
+// clamp a number between min and max
+function clamp(number: number, min: number, max: number) {
     return Math.max(min, Math.min(number, max));
 }
 
-//filter the curvature array to only show concave values
-function filterConcave(curvature) {
+// filter the curvature array to only show concave values
+function filterConcave(curvature: Float32Array) {
     for (let i = 0; i < curvature.length; i++) {
         curvature[i] = Math.abs(clamp(curvature[i], -1, 0));
     }
 }
 
-//filter the curvature array to only show convex values
-function filterConvex(curvature) {
+// filter the curvature array to only show convex values
+function filterConvex(curvature: Float32Array) {
     for (let i = 0; i < curvature.length; i++) {
         curvature[i] = clamp(curvature[i], 0, 1);
     }
 }
 
-//filter the curvature array to show both the concave and convex values
-function filterBoth(curvature) {
+// filter the curvature array to show both the concave and convex values
+function filterBoth(curvature: Float32Array) {
     for (let i = 0; i < curvature.length; i++) {
         curvature[i] = Math.abs(curvature[i]);
     }
 }
 
-//initialize the scene
+// initialize the scene
 function init() {
     scene = new THREE.Scene();
 
@@ -71,16 +73,18 @@ function init() {
     controls.maxDistance = 100;
 
     const loader = new OBJLoader();
-    //load the obj
-    loader.load("models/obj/ninja/ninjaHead_Low.obj", function (object) {
-        object.traverse(function (child) {
-            if (child.isMesh) {
-                bufferGeo = child.geometry;
+    // load the obj
+    loader.load("models/obj/ninja/ninjaHead_Low.obj", function(object) {
+        object.traverse(function(child) {
+            if ((child as THREE.Mesh).isMesh) {
+                bufferGeo = (child as THREE.Mesh).geometry as THREE.BufferGeometry<
+                    Record<string, THREE.BufferAttribute>
+                >;
                 bufferGeo.center();
-                const dict = {};
+                const dict: Record<string, Record<string, number>> = {};
 
                 for (let i = 0; i < bufferGeo.attributes.position.count; i += 3) {
-                    //create a dictionary of every position, and its neighboring positions
+                    // create a dictionary of every position, and its neighboring positions
                     const array = bufferGeo.attributes.position.array;
                     const normArray = bufferGeo.attributes.normal.array;
 
@@ -88,8 +92,11 @@ function init() {
                     const posB = new THREE.Vector3(array[3 * (i + 1)], array[3 * (i + 1) + 1], array[3 * (i + 1) + 2]);
                     const posC = new THREE.Vector3(array[3 * (i + 2)], array[3 * (i + 2) + 1], array[3 * (i + 2) + 2]);
 
-                    const normA = new THREE.Vector3(normArray[3 * i], normArray[3 * i + 1], normArray[3 * i + 2])
-                        .normalize();
+                    const normA = new THREE.Vector3(
+                        normArray[3 * i],
+                        normArray[3 * i + 1],
+                        normArray[3 * i + 2],
+                    ).normalize();
                     const normB = new THREE.Vector3(
                         normArray[3 * (i + 1)],
                         normArray[3 * (i + 1) + 1],
@@ -137,20 +144,21 @@ function init() {
                     dict[strC][strB] = c2b;
                 }
 
-                let curvatureDict = {};
-                let min = 10, max = 0;
+                let curvatureDict: Record<string, number> = {};
+                let min = 10,
+                    max = 0;
 
-                Object.keys(dict).forEach(function (key) {
+                Object.keys(dict).forEach(function(key) {
                     curvatureDict[key] = average(dict[key]);
                 });
 
-                //smoothing
+                // smoothing
                 const smoothCurvatureDict = Object.create(curvatureDict);
 
-                Object.keys(dict).forEach(function (key) {
+                Object.keys(dict).forEach(function(key) {
                     let count = 0;
                     let sum = 0;
-                    Object.keys(dict[key]).forEach(function (key2) {
+                    Object.keys(dict[key]).forEach(function(key2) {
                         sum += smoothCurvatureDict[key2];
                         count++;
                     });
@@ -160,7 +168,7 @@ function init() {
                 curvatureDict = smoothCurvatureDict;
 
                 // fit values to 0 and 1
-                Object.keys(curvatureDict).forEach(function (key) {
+                Object.keys(curvatureDict).forEach(function(key) {
                     const val = Math.abs(curvatureDict[key]);
                     if (val < min) min = val;
                     if (val > max) max = val;
@@ -168,7 +176,7 @@ function init() {
 
                 const range = max - min;
 
-                Object.keys(curvatureDict).forEach(function (key) {
+                Object.keys(curvatureDict).forEach(function(key) {
                     const val = Math.abs(curvatureDict[key]);
                     if (curvatureDict[key] < 0) {
                         curvatureDict[key] = (min - val) / range;
@@ -188,13 +196,13 @@ function init() {
 
                 bufferGeo.setAttribute("curvature", new THREE.BufferAttribute(curvatureAttribute, 1));
 
-                //starting filter is to show both concave and convex
+                // starting filter is to show both concave and convex
                 const curvatureFiltered = new Float32Array(curvatureAttribute);
                 filterBoth(curvatureFiltered);
 
                 const materialRaw = new THREE.ShaderMaterial({
-                    vertexShader: document.getElementById("vertexShaderRaw").textContent,
-                    fragmentShader: document.getElementById("fragmentShaderRaw").textContent,
+                    vertexShader: document.getElementById("vertexShaderRaw")!.textContent!,
+                    fragmentShader: document.getElementById("fragmentShaderRaw")!.textContent!,
                 });
 
                 ninjaMeshRaw = new THREE.Mesh(bufferGeo, materialRaw);
@@ -204,21 +212,21 @@ function init() {
         scene.add(ninjaMeshRaw);
     });
 
-    //init GUI
+    // init GUI
     const params = {
-        filterConvex: function () {
+        filterConvex: function() {
             const curvatureFiltered = new Float32Array(curvatureAttribute);
             filterConvex(curvatureFiltered);
             bufferGeo.attributes.curvature.array = curvatureFiltered;
             bufferGeo.attributes.curvature.needsUpdate = true;
         },
-        filterConcave: function () {
+        filterConcave: function() {
             const curvatureFiltered = new Float32Array(curvatureAttribute);
             filterConcave(curvatureFiltered);
             bufferGeo.attributes.curvature.array = curvatureFiltered;
             bufferGeo.attributes.curvature.needsUpdate = true;
         },
-        filterBoth: function () {
+        filterBoth: function() {
             const curvatureFiltered = new Float32Array(curvatureAttribute);
             filterBoth(curvatureFiltered);
             bufferGeo.attributes.curvature.array = curvatureFiltered;
diff --git a/examples-testing/examples/webgl_materials_displacementmap.ts b/examples-testing/examples/webgl_materials_displacementmap.ts
index 66e6a54..1e460bb 100644
--- a/examples-testing/examples/webgl_materials_displacementmap.ts
+++ b/examples-testing/examples/webgl_materials_displacementmap.ts
@@ -2,12 +2,12 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
 
-let stats;
-let camera, scene, renderer, controls;
+let stats: Stats;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
 
 const settings = {
     metalness: 1.0,
@@ -19,9 +19,9 @@ const settings = {
     normalScale: 1.0,
 };
 
-let mesh, material;
+let mesh, material: THREE.MeshStandardMaterial;
 
-let pointLight, ambientLight;
+let pointLight: THREE.PointLight, ambientLight: THREE.AmbientLight;
 
 const height = 500; // of camera frustum
 
@@ -34,34 +34,55 @@ initGui();
 // Init gui
 function initGui() {
     const gui = new GUI();
-    //let gui = gui.addFolder( "Material" );
-    gui.add(settings, "metalness").min(0).max(1).onChange(function (value) {
-        material.metalness = value;
-    });
-
-    gui.add(settings, "roughness").min(0).max(1).onChange(function (value) {
-        material.roughness = value;
-    });
-
-    gui.add(settings, "aoMapIntensity").min(0).max(1).onChange(function (value) {
-        material.aoMapIntensity = value;
-    });
-
-    gui.add(settings, "ambientIntensity").min(0).max(1).onChange(function (value) {
-        ambientLight.intensity = value;
-    });
-
-    gui.add(settings, "envMapIntensity").min(0).max(3).onChange(function (value) {
-        material.envMapIntensity = value;
-    });
-
-    gui.add(settings, "displacementScale").min(0).max(3.0).onChange(function (value) {
-        material.displacementScale = value;
-    });
-
-    gui.add(settings, "normalScale").min(-1).max(1).onChange(function (value) {
-        material.normalScale.set(1, -1).multiplyScalar(value);
-    });
+    // let gui = gui.addFolder( "Material" );
+    gui.add(settings, "metalness")
+        .min(0)
+        .max(1)
+        .onChange(function(value) {
+            material.metalness = value;
+        });
+
+    gui.add(settings, "roughness")
+        .min(0)
+        .max(1)
+        .onChange(function(value) {
+            material.roughness = value;
+        });
+
+    gui.add(settings, "aoMapIntensity")
+        .min(0)
+        .max(1)
+        .onChange(function(value) {
+            material.aoMapIntensity = value;
+        });
+
+    gui.add(settings, "ambientIntensity")
+        .min(0)
+        .max(1)
+        .onChange(function(value) {
+            ambientLight.intensity = value;
+        });
+
+    gui.add(settings, "envMapIntensity")
+        .min(0)
+        .max(3)
+        .onChange(function(value) {
+            material.envMapIntensity = value;
+        });
+
+    gui.add(settings, "displacementScale")
+        .min(0)
+        .max(3.0)
+        .onChange(function(value) {
+            material.displacementScale = value;
+        });
+
+    gui.add(settings, "normalScale")
+        .min(-1)
+        .max(1)
+        .onChange(function(value) {
+            material.normalScale.set(1, -1).multiplyScalar(value);
+        });
 }
 
 function init() {
@@ -151,8 +172,8 @@ function init() {
     //
 
     const loader = new OBJLoader();
-    loader.load("models/obj/ninja/ninjaHead_Low.obj", function (group) {
-        const geometry = group.children[0].geometry;
+    loader.load("models/obj/ninja/ninjaHead_Low.obj", function(group) {
+        const geometry = (group.children[0] as THREE.Mesh).geometry;
         geometry.center();
 
         mesh = new THREE.Mesh(geometry, material);
diff --git a/examples-testing/examples/webgl_materials_envmaps.ts b/examples-testing/examples/webgl_materials_envmaps.ts
index 53bf2d5..b490245 100644
--- a/examples-testing/examples/webgl_materials_envmaps.ts
+++ b/examples-testing/examples/webgl_materials_envmaps.ts
@@ -1,11 +1,11 @@
 import * as THREE from "three";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let controls, camera, scene, renderer;
-let textureEquirec, textureCube;
-let sphereMesh, sphereMaterial;
+let controls: OrbitControls, camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let textureEquirec: THREE.Texture, textureCube: THREE.CubeTexture;
+let sphereMesh: THREE.Mesh, sphereMaterial: THREE.MeshBasicMaterial;
 
 init();
 animate();
@@ -58,13 +58,13 @@ function init() {
     //
 
     const params = {
-        Cube: function () {
+        Cube: function() {
             scene.background = textureCube;
 
             sphereMaterial.envMap = textureCube;
             sphereMaterial.needsUpdate = true;
         },
-        Equirectangular: function () {
+        Equirectangular: function() {
             scene.background = textureEquirec;
 
             sphereMaterial.envMap = textureEquirec;
@@ -76,7 +76,7 @@ function init() {
     const gui = new GUI();
     gui.add(params, "Cube");
     gui.add(params, "Equirectangular");
-    gui.add(params, "Refraction").onChange(function (value) {
+    gui.add(params, "Refraction").onChange(function(value) {
         if (value) {
             textureEquirec.mapping = THREE.EquirectangularRefractionMapping;
             textureCube.mapping = THREE.CubeRefractionMapping;
diff --git a/examples-testing/examples/webgl_materials_envmaps_exr.ts b/examples-testing/examples/webgl_materials_envmaps_exr.ts
index 78c6d66..b07502e 100644
--- a/examples-testing/examples/webgl_materials_envmaps_exr.ts
+++ b/examples-testing/examples/webgl_materials_envmaps_exr.ts
@@ -2,8 +2,8 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { EXRLoader } from "three/addons/loaders/EXRLoader.js";
 
 const params = {
@@ -14,11 +14,12 @@ const params = {
     debug: false,
 };
 
-let container, stats;
-let camera, scene, renderer, controls;
-let torusMesh, planeMesh;
-let pngCubeRenderTarget, exrCubeRenderTarget;
-let pngBackground, exrBackground;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls;
+let torusMesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>,
+    planeMesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshBasicMaterial>;
+let pngCubeRenderTarget: THREE.WebGLRenderTarget, exrCubeRenderTarget: THREE.WebGLRenderTarget;
+let pngBackground: THREE.Texture, exrBackground: THREE.DataTexture;
 
 init();
 animate();
@@ -42,8 +43,8 @@ function init() {
 
     //
 
-    let geometry = new THREE.TorusKnotGeometry(18, 8, 150, 20);
-    let material = new THREE.MeshStandardMaterial({
+    let geometry: THREE.BufferGeometry = new THREE.TorusKnotGeometry(18, 8, 150, 20);
+    let material: THREE.MeshStandardMaterial | THREE.MeshBasicMaterial = new THREE.MeshStandardMaterial({
         metalness: params.metalness,
         roughness: params.roughness,
         envMapIntensity: 1.0,
@@ -60,18 +61,18 @@ function init() {
     planeMesh.rotation.x = -Math.PI * 0.5;
     scene.add(planeMesh);
 
-    THREE.DefaultLoadingManager.onLoad = function () {
+    THREE.DefaultLoadingManager.onLoad = function() {
         pmremGenerator.dispose();
     };
 
-    new EXRLoader().load("textures/piz_compressed.exr", function (texture) {
+    new EXRLoader().load("textures/piz_compressed.exr", function(texture) {
         texture.mapping = THREE.EquirectangularReflectionMapping;
 
         exrCubeRenderTarget = pmremGenerator.fromEquirectangular(texture);
         exrBackground = texture;
     });
 
-    new THREE.TextureLoader().load("textures/equirectangular.png", function (texture) {
+    new THREE.TextureLoader().load("textures/equirectangular.png", function(texture) {
         texture.mapping = THREE.EquirectangularReflectionMapping;
         texture.colorSpace = THREE.SRGBColorSpace;
 
diff --git a/examples-testing/examples/webgl_materials_envmaps_groundprojected.ts b/examples-testing/examples/webgl_materials_envmaps_groundprojected.ts
index 017f654..2dea33c 100644
--- a/examples-testing/examples/webgl_materials_envmaps_groundprojected.ts
+++ b/examples-testing/examples/webgl_materials_envmaps_groundprojected.ts
@@ -1,11 +1,11 @@
 import * as THREE from "three";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { GroundedSkybox } from "three/addons/objects/GroundedSkybox.js";
-import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
+import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
+import { GroundedSkybox } from "three/addons/objects/GroundedSkybox.js";
 
 const params = {
     height: 15,
@@ -13,17 +13,12 @@ const params = {
     enabled: true,
 };
 
-let camera, scene, renderer, skybox;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, skybox: GroundedSkybox;
 
 init().then(render);
 
 async function init() {
-    camera = new THREE.PerspectiveCamera(
-        40,
-        window.innerWidth / window.innerHeight,
-        1,
-        1000,
-    );
+    camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 1000);
     camera.position.set(-20, 7, 20);
     camera.lookAt(0, 4, 0);
 
@@ -47,7 +42,7 @@ async function init() {
 
     const shadow = new THREE.TextureLoader().load("models/gltf/ferrari_ao.png");
 
-    loader.load("models/gltf/ferrari.glb", function (gltf) {
+    loader.load("models/gltf/ferrari.glb", function(gltf) {
         const bodyMaterial = new THREE.MeshPhysicalMaterial({
             color: 0x000000,
             metalness: 1.0,
@@ -73,15 +68,15 @@ async function init() {
         carModel.scale.multiplyScalar(4);
         carModel.rotation.y = Math.PI;
 
-        carModel.getObjectByName("body").material = bodyMaterial;
+        (carModel.getObjectByName("body") as THREE.Mesh).material = bodyMaterial;
 
-        carModel.getObjectByName("rim_fl").material = detailsMaterial;
-        carModel.getObjectByName("rim_fr").material = detailsMaterial;
-        carModel.getObjectByName("rim_rr").material = detailsMaterial;
-        carModel.getObjectByName("rim_rl").material = detailsMaterial;
-        carModel.getObjectByName("trim").material = detailsMaterial;
+        (carModel.getObjectByName("rim_fl") as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName("rim_fr") as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName("rim_rr") as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName("rim_rl") as THREE.Mesh).material = detailsMaterial;
+        (carModel.getObjectByName("trim") as THREE.Mesh).material = detailsMaterial;
 
-        carModel.getObjectByName("glass").material = glassMaterial;
+        (carModel.getObjectByName("glass") as THREE.Mesh).material = glassMaterial;
 
         // shadow
         const mesh = new THREE.Mesh(
@@ -124,17 +119,19 @@ async function init() {
 
     const gui = new GUI();
 
-    gui.add(params, "enabled").name("Grounded").onChange(function (value) {
-        if (value) {
-            scene.add(skybox);
-            scene.background = null;
-        } else {
-            scene.remove(skybox);
-            scene.background = scene.environment;
-        }
-
-        render();
-    });
+    gui.add(params, "enabled")
+        .name("Grounded")
+        .onChange(function(value) {
+            if (value) {
+                scene.add(skybox);
+                scene.background = null;
+            } else {
+                scene.remove(skybox);
+                scene.background = scene.environment;
+            }
+
+            render();
+        });
     gui.open();
 }
 
diff --git a/examples-testing/examples/webgl_materials_envmaps_hdr.ts b/examples-testing/examples/webgl_materials_envmaps_hdr.ts
index 20a177f..6c68952 100644
--- a/examples-testing/examples/webgl_materials_envmaps_hdr.ts
+++ b/examples-testing/examples/webgl_materials_envmaps_hdr.ts
@@ -2,13 +2,19 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { DebugEnvironment } from "three/addons/environments/DebugEnvironment.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { HDRCubeTextureLoader } from "three/addons/loaders/HDRCubeTextureLoader.js";
 import { RGBMLoader } from "three/addons/loaders/RGBMLoader.js";
-import { DebugEnvironment } from "three/addons/environments/DebugEnvironment.js";
 
-const params = {
+const params: {
+    envMap: "Generated" | "LDR" | "HDR" | "RGBM16";
+    roughness: number;
+    metalness: number;
+    exposure: number;
+    debug: boolean;
+} = {
     envMap: "HDR",
     roughness: 0.0,
     metalness: 0.0,
@@ -16,11 +22,15 @@ const params = {
     debug: false,
 };
 
-let container, stats;
-let camera, scene, renderer, controls;
-let torusMesh, planeMesh;
-let generatedCubeRenderTarget, ldrCubeRenderTarget, hdrCubeRenderTarget, rgbmCubeRenderTarget;
-let ldrCubeMap, hdrCubeMap, rgbmCubeMap;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
+let torusMesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>,
+    planeMesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshBasicMaterial>;
+let generatedCubeRenderTarget: THREE.WebGLRenderTarget,
+    ldrCubeRenderTarget: THREE.WebGLRenderTarget,
+    hdrCubeRenderTarget: THREE.WebGLRenderTarget,
+    rgbmCubeRenderTarget: THREE.WebGLRenderTarget;
+let ldrCubeMap: THREE.CubeTexture, hdrCubeMap: THREE.CubeTexture, rgbmCubeMap: THREE.CubeTexture;
 
 init();
 animate();
@@ -40,9 +50,9 @@ function init() {
 
     //
 
-    let geometry = new THREE.TorusKnotGeometry(18, 8, 150, 20);
+    let geometry: THREE.BufferGeometry = new THREE.TorusKnotGeometry(18, 8, 150, 20);
     // let geometry = new THREE.SphereGeometry( 26, 64, 32 );
-    let material = new THREE.MeshStandardMaterial({
+    let material: THREE.MeshStandardMaterial | THREE.MeshBasicMaterial = new THREE.MeshStandardMaterial({
         color: 0xffffff,
         metalness: params.metalness,
         roughness: params.roughness,
@@ -59,31 +69,28 @@ function init() {
     planeMesh.rotation.x = -Math.PI * 0.5;
     scene.add(planeMesh);
 
-    THREE.DefaultLoadingManager.onLoad = function () {
+    THREE.DefaultLoadingManager.onLoad = function() {
         pmremGenerator.dispose();
     };
 
     const hdrUrls = ["px.hdr", "nx.hdr", "py.hdr", "ny.hdr", "pz.hdr", "nz.hdr"];
-    hdrCubeMap = new HDRCubeTextureLoader()
-        .setPath("./textures/cube/pisaHDR/")
-        .load(hdrUrls, function () {
-            hdrCubeRenderTarget = pmremGenerator.fromCubemap(hdrCubeMap);
+    hdrCubeMap = new HDRCubeTextureLoader().setPath("./textures/cube/pisaHDR/").load(hdrUrls, function() {
+        hdrCubeRenderTarget = pmremGenerator.fromCubemap(hdrCubeMap);
 
-            hdrCubeMap.magFilter = THREE.LinearFilter;
-            hdrCubeMap.needsUpdate = true;
-        });
+        hdrCubeMap.magFilter = THREE.LinearFilter;
+        hdrCubeMap.needsUpdate = true;
+    });
 
     const ldrUrls = ["px.png", "nx.png", "py.png", "ny.png", "pz.png", "nz.png"];
-    ldrCubeMap = new THREE.CubeTextureLoader()
-        .setPath("./textures/cube/pisa/")
-        .load(ldrUrls, function () {
-            ldrCubeRenderTarget = pmremGenerator.fromCubemap(ldrCubeMap);
-        });
+    ldrCubeMap = new THREE.CubeTextureLoader().setPath("./textures/cube/pisa/").load(ldrUrls, function() {
+        ldrCubeRenderTarget = pmremGenerator.fromCubemap(ldrCubeMap);
+    });
 
     const rgbmUrls = ["px.png", "nx.png", "py.png", "ny.png", "pz.png", "nz.png"];
-    rgbmCubeMap = new RGBMLoader().setMaxRange(16)
+    rgbmCubeMap = new RGBMLoader()
+        .setMaxRange(16)
         .setPath("./textures/cube/pisaRGBM16/")
-        .loadCubemap(rgbmUrls, function () {
+        .loadCubemap(rgbmUrls, function() {
             rgbmCubeRenderTarget = pmremGenerator.fromCubemap(rgbmCubeMap);
         });
 
@@ -97,7 +104,7 @@ function init() {
     renderer.setSize(window.innerWidth, window.innerHeight);
     container.appendChild(renderer.domElement);
 
-    //renderer.toneMapping = ReinhardToneMapping;
+    // renderer.toneMapping = ReinhardToneMapping;
 
     stats = new Stats();
     container.appendChild(stats.dom);
diff --git a/examples-testing/examples/webgl_materials_modified.ts b/examples-testing/examples/webgl_materials_modified.ts
index f4c9566..c053831 100644
--- a/examples-testing/examples/webgl_materials_modified.ts
+++ b/examples-testing/examples/webgl_materials_modified.ts
@@ -5,7 +5,7 @@ import Stats from "three/addons/libs/stats.module.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-let camera, scene, renderer, stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
 
 init();
 animate();
@@ -17,8 +17,8 @@ function init() {
     scene = new THREE.Scene();
 
     const loader = new GLTFLoader();
-    loader.load("models/gltf/LeePerrySmith/LeePerrySmith.glb", function (gltf) {
-        const geometry = gltf.scene.children[0].geometry;
+    loader.load("models/gltf/LeePerrySmith/LeePerrySmith.glb", function(gltf) {
+        const geometry = (gltf.scene.children[0] as THREE.Mesh).geometry;
 
         let mesh = new THREE.Mesh(geometry, buildTwistMaterial(2.0));
         mesh.position.x = -3.5;
@@ -50,9 +50,9 @@ function init() {
     window.addEventListener("resize", onWindowResize);
 }
 
-function buildTwistMaterial(amount) {
+function buildTwistMaterial(amount: number) {
     const material = new THREE.MeshNormalMaterial();
-    material.onBeforeCompile = function (shader) {
+    material.onBeforeCompile = function(shader) {
         shader.uniforms.time = { value: 0 };
 
         shader.vertexShader = "uniform float time;\n" + shader.vertexShader;
@@ -73,7 +73,7 @@ function buildTwistMaterial(amount) {
 
     // Make sure WebGLRenderer doesnt reuse a single program
 
-    material.customProgramCacheKey = function () {
+    material.customProgramCacheKey = function() {
         return amount.toFixed(1);
     };
 
@@ -103,9 +103,9 @@ function animate() {
 }
 
 function render() {
-    scene.traverse(function (child) {
-        if (child.isMesh) {
-            const shader = child.material.userData.shader;
+    scene.traverse(function(child) {
+        if ((child as THREE.Mesh).isMesh) {
+            const shader = ((child as THREE.Mesh).material as THREE.Material).userData.shader;
 
             if (shader) {
                 shader.uniforms.time.value = performance.now() / 1000;
diff --git a/examples-testing/examples/webgl_materials_normalmap_object_space.ts b/examples-testing/examples/webgl_materials_normalmap_object_space.ts
index d7d780c..4e523d1 100644
--- a/examples-testing/examples/webgl_materials_normalmap_object_space.ts
+++ b/examples-testing/examples/webgl_materials_normalmap_object_space.ts
@@ -3,7 +3,7 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-let renderer, scene, camera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
 
 init();
 
@@ -36,21 +36,25 @@ function init() {
     camera.add(light);
 
     // model
-    new GLTFLoader().load("models/gltf/Nefertiti/Nefertiti.glb", function (gltf) {
-        gltf.scene.traverse(function (child) {
-            if (child.isMesh) {
+    new GLTFLoader().load("models/gltf/Nefertiti/Nefertiti.glb", function(gltf) {
+        gltf.scene.traverse(function(child) {
+            if ((child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).isMesh) {
                 // glTF currently supports only tangent-space normal maps.
                 // this model has been modified to demonstrate the use of an object-space normal map.
 
-                child.material.normalMapType = THREE.ObjectSpaceNormalMap;
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.normalMapType =
+                    THREE.ObjectSpaceNormalMap;
 
                 // attribute normals are not required with an object-space normal map. remove them.
 
-                child.geometry.deleteAttribute("normal");
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).geometry.deleteAttribute(
+                    "normal",
+                );
 
                 //
 
-                child.material.side = THREE.DoubleSide;
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>).material.side =
+                    THREE.DoubleSide;
 
                 child.scale.multiplyScalar(0.5);
 
diff --git a/examples-testing/examples/webgl_materials_physical_clearcoat.ts b/examples-testing/examples/webgl_materials_physical_clearcoat.ts
index abfac32..1321457 100644
--- a/examples-testing/examples/webgl_materials_physical_clearcoat.ts
+++ b/examples-testing/examples/webgl_materials_physical_clearcoat.ts
@@ -7,12 +7,12 @@ import { HDRCubeTextureLoader } from "three/addons/loaders/HDRCubeTextureLoader.
 
 import { FlakesTexture } from "three/addons/textures/FlakesTexture.js";
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let particleLight;
-let group;
+let particleLight: THREE.Mesh;
+let group: THREE.Group;
 
 init();
 animate();
@@ -31,8 +31,8 @@ function init() {
 
     new HDRCubeTextureLoader()
         .setPath("textures/cube/pisaHDR/")
-        .load(["px.hdr", "nx.hdr", "py.hdr", "ny.hdr", "pz.hdr", "nz.hdr"], function (texture) {
-            const geometry = new THREE.SphereGeometry(.8, 64, 32);
+        .load(["px.hdr", "nx.hdr", "py.hdr", "ny.hdr", "pz.hdr", "nz.hdr"], function(texture) {
+            const geometry = new THREE.SphereGeometry(0.8, 64, 32);
 
             const textureLoader = new THREE.TextureLoader();
 
@@ -139,7 +139,7 @@ function init() {
     // LIGHTS
 
     particleLight = new THREE.Mesh(
-        new THREE.SphereGeometry(.05, 8, 8),
+        new THREE.SphereGeometry(0.05, 8, 8),
         new THREE.MeshBasicMaterial({ color: 0xffffff }),
     );
     scene.add(particleLight);
diff --git a/examples-testing/examples/webgl_materials_physical_transmission.ts b/examples-testing/examples/webgl_materials_physical_transmission.ts
index 2ca3c08..84e06a0 100644
--- a/examples-testing/examples/webgl_materials_physical_transmission.ts
+++ b/examples-testing/examples/webgl_materials_physical_transmission.ts
@@ -1,7 +1,7 @@
 import * as THREE from "three";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 
 const params = {
@@ -19,18 +19,16 @@ const params = {
     exposure: 1,
 };
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let mesh;
 
-const hdrEquirect = new RGBELoader()
-    .setPath("textures/equirectangular/")
-    .load("royal_esplanade_1k.hdr", function () {
-        hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;
+const hdrEquirect = new RGBELoader().setPath("textures/equirectangular/").load("royal_esplanade_1k.hdr", function() {
+    hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;
 
-        init();
-        render();
-    });
+    init();
+    render();
+});
 
 function init() {
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -93,72 +91,62 @@ function init() {
 
     const gui = new GUI();
 
-    gui.addColor(params, "color")
-        .onChange(function () {
-            material.color.set(params.color);
-            render();
-        });
+    gui.addColor(params, "color").onChange(function() {
+        material.color.set(params.color);
+        render();
+    });
 
-    gui.add(params, "transmission", 0, 1, 0.01)
-        .onChange(function () {
-            material.transmission = params.transmission;
-            render();
-        });
+    gui.add(params, "transmission", 0, 1, 0.01).onChange(function() {
+        material.transmission = params.transmission;
+        render();
+    });
 
-    gui.add(params, "opacity", 0, 1, 0.01)
-        .onChange(function () {
-            material.opacity = params.opacity;
-            render();
-        });
+    gui.add(params, "opacity", 0, 1, 0.01).onChange(function() {
+        material.opacity = params.opacity;
+        render();
+    });
 
-    gui.add(params, "metalness", 0, 1, 0.01)
-        .onChange(function () {
-            material.metalness = params.metalness;
-            render();
-        });
+    gui.add(params, "metalness", 0, 1, 0.01).onChange(function() {
+        material.metalness = params.metalness;
+        render();
+    });
 
-    gui.add(params, "roughness", 0, 1, 0.01)
-        .onChange(function () {
-            material.roughness = params.roughness;
-            render();
-        });
+    gui.add(params, "roughness", 0, 1, 0.01).onChange(function() {
+        material.roughness = params.roughness;
+        render();
+    });
 
-    gui.add(params, "ior", 1, 2, 0.01)
-        .onChange(function () {
-            material.ior = params.ior;
-            render();
-        });
+    gui.add(params, "ior", 1, 2, 0.01).onChange(function() {
+        material.ior = params.ior;
+        render();
+    });
 
-    gui.add(params, "thickness", 0, 5, 0.01)
-        .onChange(function () {
-            material.thickness = params.thickness;
-            render();
-        });
+    gui.add(params, "thickness", 0, 5, 0.01).onChange(function() {
+        material.thickness = params.thickness;
+        render();
+    });
 
-    gui.add(params, "specularIntensity", 0, 1, 0.01)
-        .onChange(function () {
-            material.specularIntensity = params.specularIntensity;
-            render();
-        });
+    gui.add(params, "specularIntensity", 0, 1, 0.01).onChange(function() {
+        material.specularIntensity = params.specularIntensity;
+        render();
+    });
 
-    gui.addColor(params, "specularColor")
-        .onChange(function () {
-            material.specularColor.set(params.specularColor);
-            render();
-        });
+    gui.addColor(params, "specularColor").onChange(function() {
+        material.specularColor.set(params.specularColor);
+        render();
+    });
 
     gui.add(params, "envMapIntensity", 0, 1, 0.01)
         .name("envMap intensity")
-        .onChange(function () {
+        .onChange(function() {
             material.envMapIntensity = params.envMapIntensity;
             render();
         });
 
-    gui.add(params, "exposure", 0, 1, 0.01)
-        .onChange(function () {
-            renderer.toneMappingExposure = params.exposure;
-            render();
-        });
+    gui.add(params, "exposure", 0, 1, 0.01).onChange(function() {
+        renderer.toneMappingExposure = params.exposure;
+        render();
+    });
 
     gui.open();
 }
@@ -182,7 +170,7 @@ function generateTexture() {
     canvas.width = 2;
     canvas.height = 2;
 
-    const context = canvas.getContext("2d");
+    const context = canvas.getContext("2d")!;
     context.fillStyle = "white";
     context.fillRect(0, 1, 2, 1);
 
diff --git a/examples-testing/examples/webgl_materials_physical_transmission_alpha.ts b/examples-testing/examples/webgl_materials_physical_transmission_alpha.ts
index 6f561f2..7deb8d5 100644
--- a/examples-testing/examples/webgl_materials_physical_transmission_alpha.ts
+++ b/examples-testing/examples/webgl_materials_physical_transmission_alpha.ts
@@ -1,9 +1,9 @@
 import * as THREE from "three";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
+import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 
 const params = {
     color: 0xffffff,
@@ -22,49 +22,49 @@ const params = {
     exposure: 1,
 };
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mesh, material;
+let mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhysicalMaterial>, material: THREE.MeshPhysicalMaterial;
 
-const hdrEquirect = new RGBELoader()
-    .setPath("textures/equirectangular/")
-    .load("royal_esplanade_1k.hdr", function () {
-        hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;
+const hdrEquirect = new RGBELoader().setPath("textures/equirectangular/").load("royal_esplanade_1k.hdr", function() {
+    hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;
 
-        new GLTFLoader()
-            .setPath("models/gltf/")
-            .load("DragonAttenuation.glb", function (gltf) {
-                gltf.scene.traverse(function (child) {
-                    if (child.isMesh && child.material.isMeshPhysicalMaterial) {
-                        mesh = child;
-                        material = mesh.material;
+    new GLTFLoader().setPath("models/gltf/").load("DragonAttenuation.glb", function(gltf) {
+        gltf.scene.traverse(function(child) {
+            if (
+                (child as THREE.Mesh).isMesh
+                && (child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhysicalMaterial>).material
+                    .isMeshPhysicalMaterial
+            ) {
+                mesh = child as THREE.Mesh<THREE.BufferGeometry, THREE.MeshPhysicalMaterial>;
+                material = mesh.material;
 
-                        const color = new THREE.Color();
+                const color = new THREE.Color();
 
-                        params.color = color.copy(mesh.material.color).getHex();
-                        params.roughness = mesh.material.roughness;
-                        params.metalness = mesh.material.metalness;
+                params.color = color.copy(mesh.material.color).getHex();
+                params.roughness = mesh.material.roughness;
+                params.metalness = mesh.material.metalness;
 
-                        params.ior = mesh.material.ior;
-                        params.specularIntensity = mesh.material.specularIntensity;
+                params.ior = mesh.material.ior;
+                params.specularIntensity = mesh.material.specularIntensity;
 
-                        params.transmission = mesh.material.transmission;
-                        params.thickness = mesh.material.thickness;
-                        params.attenuationColor = color.copy(mesh.material.attenuationColor).getHex();
-                        params.attenuationDistance = mesh.material.attenuationDistance;
-                    }
-                });
+                params.transmission = mesh.material.transmission;
+                params.thickness = mesh.material.thickness;
+                params.attenuationColor = color.copy(mesh.material.attenuationColor).getHex();
+                params.attenuationDistance = mesh.material.attenuationDistance;
+            }
+        });
 
-                init();
+        init();
 
-                scene.add(gltf.scene);
+        scene.add(gltf.scene);
 
-                scene.environment = hdrEquirect;
-                //scene.background = hdrEquirect;
+        scene.environment = hdrEquirect;
+        // scene.background = hdrEquirect;
 
-                render();
-            });
+        render();
     });
+});
 
 function init() {
     renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
@@ -78,7 +78,7 @@ function init() {
 
     // accommodate CSS table
     renderer.domElement.style.position = "absolute";
-    renderer.domElement.style.top = 0;
+    renderer.domElement.style.top = "0";
 
     scene = new THREE.Scene();
 
@@ -98,92 +98,81 @@ function init() {
 
     const gui = new GUI();
 
-    gui.addColor(params, "color")
-        .onChange(function () {
-            material.color.set(params.color);
-            render();
-        });
+    gui.addColor(params, "color").onChange(function() {
+        material.color.set(params.color);
+        render();
+    });
 
-    gui.add(params, "transmission", 0, 1, 0.01)
-        .onChange(function () {
-            material.transmission = params.transmission;
-            render();
-        });
+    gui.add(params, "transmission", 0, 1, 0.01).onChange(function() {
+        material.transmission = params.transmission;
+        render();
+    });
 
-    gui.add(params, "opacity", 0, 1, 0.01)
-        .onChange(function () {
-            material.opacity = params.opacity;
-            const transparent = params.opacity < 1;
+    gui.add(params, "opacity", 0, 1, 0.01).onChange(function() {
+        material.opacity = params.opacity;
+        const transparent = params.opacity < 1;
 
-            if (transparent !== material.transparent) {
-                material.transparent = transparent;
-                material.needsUpdate = true;
-            }
+        if (transparent !== material.transparent) {
+            material.transparent = transparent;
+            material.needsUpdate = true;
+        }
 
-            render();
-        });
+        render();
+    });
 
-    gui.add(params, "metalness", 0, 1, 0.01)
-        .onChange(function () {
-            material.metalness = params.metalness;
-            render();
-        });
+    gui.add(params, "metalness", 0, 1, 0.01).onChange(function() {
+        material.metalness = params.metalness;
+        render();
+    });
 
-    gui.add(params, "roughness", 0, 1, 0.01)
-        .onChange(function () {
-            material.roughness = params.roughness;
-            render();
-        });
+    gui.add(params, "roughness", 0, 1, 0.01).onChange(function() {
+        material.roughness = params.roughness;
+        render();
+    });
 
-    gui.add(params, "ior", 1, 2, 0.01)
-        .onChange(function () {
-            material.ior = params.ior;
-            render();
-        });
+    gui.add(params, "ior", 1, 2, 0.01).onChange(function() {
+        material.ior = params.ior;
+        render();
+    });
 
-    gui.add(params, "thickness", 0, 5, 0.01)
-        .onChange(function () {
-            material.thickness = params.thickness;
-            render();
-        });
+    gui.add(params, "thickness", 0, 5, 0.01).onChange(function() {
+        material.thickness = params.thickness;
+        render();
+    });
 
     gui.addColor(params, "attenuationColor")
         .name("attenuation color")
-        .onChange(function () {
+        .onChange(function() {
             material.attenuationColor.set(params.attenuationColor);
             render();
         });
 
-    gui.add(params, "attenuationDistance", 0, 1, 0.01)
-        .onChange(function () {
-            material.attenuationDistance = params.attenuationDistance;
-            render();
-        });
+    gui.add(params, "attenuationDistance", 0, 1, 0.01).onChange(function() {
+        material.attenuationDistance = params.attenuationDistance;
+        render();
+    });
 
-    gui.add(params, "specularIntensity", 0, 1, 0.01)
-        .onChange(function () {
-            material.specularIntensity = params.specularIntensity;
-            render();
-        });
+    gui.add(params, "specularIntensity", 0, 1, 0.01).onChange(function() {
+        material.specularIntensity = params.specularIntensity;
+        render();
+    });
 
-    gui.addColor(params, "specularColor")
-        .onChange(function () {
-            material.specularColor.set(params.specularColor);
-            render();
-        });
+    gui.addColor(params, "specularColor").onChange(function() {
+        material.specularColor.set(params.specularColor);
+        render();
+    });
 
     gui.add(params, "envMapIntensity", 0, 1, 0.01)
         .name("envMap intensity")
-        .onChange(function () {
+        .onChange(function() {
             material.envMapIntensity = params.envMapIntensity;
             render();
         });
 
-    gui.add(params, "exposure", 0, 1, 0.01)
-        .onChange(function () {
-            renderer.toneMappingExposure = params.exposure;
-            render();
-        });
+    gui.add(params, "exposure", 0, 1, 0.01).onChange(function() {
+        renderer.toneMappingExposure = params.exposure;
+        render();
+    });
 
     gui.open();
 }
diff --git a/examples-testing/examples/webgl_materials_texture_anisotropy.ts b/examples-testing/examples/webgl_materials_texture_anisotropy.ts
index 18fb879..18f09dd 100644
--- a/examples-testing/examples/webgl_materials_texture_anisotropy.ts
+++ b/examples-testing/examples/webgl_materials_texture_anisotropy.ts
@@ -5,11 +5,12 @@ import Stats from "three/addons/libs/stats.module.js";
 const SCREEN_WIDTH = window.innerWidth;
 const SCREEN_HEIGHT = window.innerHeight;
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene1, scene2, renderer;
+let camera: THREE.PerspectiveCamera, scene1: THREE.Scene, scene2: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mouseX = 0, mouseY = 0;
+let mouseX = 0,
+    mouseY = 0;
 
 const windowHalfX = window.innerWidth / 2;
 const windowHalfY = window.innerHeight / 2;
@@ -70,11 +71,11 @@ function init() {
     texture2.repeat.set(512, 512);
 
     if (maxAnisotropy > 0) {
-        document.getElementById("val_left").innerHTML = texture1.anisotropy;
-        document.getElementById("val_right").innerHTML = texture2.anisotropy;
+        document.getElementById("val_left")!.innerHTML = texture1.anisotropy.toString();
+        document.getElementById("val_right")!.innerHTML = texture2.anisotropy.toString();
     } else {
-        document.getElementById("val_left").innerHTML = "not supported";
-        document.getElementById("val_right").innerHTML = "not supported";
+        document.getElementById("val_left")!.innerHTML = "not supported";
+        document.getElementById("val_right")!.innerHTML = "not supported";
     }
 
     //
@@ -109,7 +110,7 @@ function init() {
     document.addEventListener("mousemove", onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
@@ -122,9 +123,9 @@ function animate() {
 }
 
 function render() {
-    camera.position.x += (mouseX - camera.position.x) * .05;
+    camera.position.x += (mouseX - camera.position.x) * 0.05;
     camera.position.y = THREE.MathUtils.clamp(
-        camera.position.y + (-(mouseY - 200) - camera.position.y) * .05,
+        camera.position.y + (-(mouseY - 200) - camera.position.y) * 0.05,
         50,
         1000,
     );
diff --git a/examples-testing/examples/webgl_materials_texture_canvas.ts b/examples-testing/examples/webgl_materials_texture_canvas.ts
index e52e0ff..2ea6caf 100644
--- a/examples-testing/examples/webgl_materials_texture_canvas.ts
+++ b/examples-testing/examples/webgl_materials_texture_canvas.ts
@@ -1,6 +1,10 @@
 import * as THREE from "three";
 
-let camera, scene, renderer, mesh, material;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    mesh: THREE.Mesh,
+    material: THREE.MeshBasicMaterial;
 const drawStartPos = new THREE.Vector2();
 
 init();
@@ -31,8 +35,8 @@ function init() {
 function setupCanvasDrawing() {
     // get canvas and context
 
-    const drawingCanvas = document.getElementById("drawing-canvas");
-    const drawingContext = drawingCanvas.getContext("2d");
+    const drawingCanvas = document.getElementById("drawing-canvas") as HTMLCanvasElement;
+    const drawingContext = drawingCanvas.getContext("2d")!;
 
     // draw white background
 
@@ -48,25 +52,25 @@ function setupCanvasDrawing() {
     let paint = false;
 
     // add canvas event listeners
-    drawingCanvas.addEventListener("pointerdown", function (e) {
+    drawingCanvas.addEventListener("pointerdown", function(e) {
         paint = true;
         drawStartPos.set(e.offsetX, e.offsetY);
     });
 
-    drawingCanvas.addEventListener("pointermove", function (e) {
+    drawingCanvas.addEventListener("pointermove", function(e) {
         if (paint) draw(drawingContext, e.offsetX, e.offsetY);
     });
 
-    drawingCanvas.addEventListener("pointerup", function () {
+    drawingCanvas.addEventListener("pointerup", function() {
         paint = false;
     });
 
-    drawingCanvas.addEventListener("pointerleave", function () {
+    drawingCanvas.addEventListener("pointerleave", function() {
         paint = false;
     });
 }
 
-function draw(drawContext, x, y) {
+function draw(drawContext: CanvasRenderingContext2D, x: number, y: number) {
     drawContext.moveTo(drawStartPos.x, drawStartPos.y);
     drawContext.strokeStyle = "#000000";
     drawContext.lineTo(x, y);
@@ -74,7 +78,7 @@ function draw(drawContext, x, y) {
     // reset drawing start position to current position.
     drawStartPos.set(x, y);
     // need to flag the map as needing updating.
-    material.map.needsUpdate = true;
+    material.map!.needsUpdate = true;
 }
 
 function onWindowResize() {
diff --git a/examples-testing/examples/webgl_materials_texture_filters.ts b/examples-testing/examples/webgl_materials_texture_filters.ts
index 1bd8ed0..5571381 100644
--- a/examples-testing/examples/webgl_materials_texture_filters.ts
+++ b/examples-testing/examples/webgl_materials_texture_filters.ts
@@ -3,11 +3,12 @@ import * as THREE from "three";
 const SCREEN_WIDTH = window.innerWidth;
 const SCREEN_HEIGHT = window.innerHeight;
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, scene2, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, scene2: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mouseX = 0, mouseY = 0;
+let mouseX = 0,
+    mouseY = 0;
 
 const windowHalfX = window.innerWidth / 2;
 const windowHalfY = window.innerHeight / 2;
@@ -33,7 +34,7 @@ function init() {
     // GROUND
 
     const imageCanvas = document.createElement("canvas");
-    const context = imageCanvas.getContext("2d");
+    const context = imageCanvas.getContext("2d")!;
 
     imageCanvas.width = imageCanvas.height = 128;
 
@@ -69,7 +70,7 @@ function init() {
 
     // PAINTING
 
-    const callbackPainting = function () {
+    const callbackPainting = function() {
         const image = texturePainting.image;
 
         texturePainting2.image = image;
@@ -85,7 +86,7 @@ function init() {
         addPainting(scene, mesh);
         addPainting(scene2, mesh2);
 
-        function addPainting(zscene, zmesh) {
+        function addPainting(zscene: THREE.Scene, zmesh: THREE.Mesh) {
             zmesh.scale.x = image.width / 100;
             zmesh.scale.y = image.height / 100;
 
@@ -93,22 +94,22 @@ function init() {
 
             const meshFrame = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0x000000 }));
             meshFrame.position.z = -10.0;
-            meshFrame.scale.x = 1.1 * image.width / 100;
-            meshFrame.scale.y = 1.1 * image.height / 100;
+            meshFrame.scale.x = (1.1 * image.width) / 100;
+            meshFrame.scale.y = (1.1 * image.height) / 100;
             zscene.add(meshFrame);
 
             const meshShadow = new THREE.Mesh(
                 geometry,
                 new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.75, transparent: true }),
             );
-            meshShadow.position.y = -1.1 * image.height / 2;
-            meshShadow.position.z = -1.1 * image.height / 2;
+            meshShadow.position.y = (-1.1 * image.height) / 2;
+            meshShadow.position.z = (-1.1 * image.height) / 2;
             meshShadow.rotation.x = -Math.PI / 2;
-            meshShadow.scale.x = 1.1 * image.width / 100;
-            meshShadow.scale.y = 1.1 * image.height / 100;
+            meshShadow.scale.x = (1.1 * image.width) / 100;
+            meshShadow.scale.y = (1.1 * image.height) / 100;
             zscene.add(meshShadow);
 
-            const floorHeight = -1.117 * image.height / 2;
+            const floorHeight = (-1.117 * image.height) / 2;
             meshCanvas.position.y = meshCanvas2.position.y = floorHeight;
         }
     };
@@ -139,7 +140,7 @@ function init() {
     document.addEventListener("mousemove", onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
@@ -151,8 +152,8 @@ function animate() {
 }
 
 function render() {
-    camera.position.x += (mouseX - camera.position.x) * .05;
-    camera.position.y += (-(mouseY - 200) - camera.position.y) * .05;
+    camera.position.x += (mouseX - camera.position.x) * 0.05;
+    camera.position.y += (-(mouseY - 200) - camera.position.y) * 0.05;
 
     camera.lookAt(scene.position);
 
diff --git a/examples-testing/examples/webgl_materials_texture_manualmipmap.ts b/examples-testing/examples/webgl_materials_texture_manualmipmap.ts
index d3bb153..d0012e4 100644
--- a/examples-testing/examples/webgl_materials_texture_manualmipmap.ts
+++ b/examples-testing/examples/webgl_materials_texture_manualmipmap.ts
@@ -3,11 +3,12 @@ import * as THREE from "three";
 const SCREEN_WIDTH = window.innerWidth;
 const SCREEN_HEIGHT = window.innerHeight;
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene1, scene2, renderer;
+let camera: THREE.PerspectiveCamera, scene1: THREE.Scene, scene2: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let mouseX = 0, mouseY = 0;
+let mouseX = 0,
+    mouseY = 0;
 
 const windowHalfX = window.innerWidth / 2;
 const windowHalfY = window.innerHeight / 2;
@@ -32,9 +33,9 @@ function init() {
 
     // GROUND
 
-    function mipmap(size, color) {
+    function mipmap(size: number, color: string) {
         const imageCanvas = document.createElement("canvas");
-        const context = imageCanvas.getContext("2d");
+        const context = imageCanvas.getContext("2d")!;
 
         imageCanvas.width = imageCanvas.height = size;
 
@@ -81,7 +82,7 @@ function init() {
 
     // PAINTING
 
-    const callbackPainting = function () {
+    const callbackPainting = function() {
         const image = texturePainting1.image;
 
         texturePainting2.image = image;
@@ -97,7 +98,7 @@ function init() {
         addPainting(scene1, mesh1);
         addPainting(scene2, mesh2);
 
-        function addPainting(zscene, zmesh) {
+        function addPainting(zscene: THREE.Scene, zmesh: THREE.Mesh) {
             zmesh.scale.x = image.width / 100;
             zmesh.scale.y = image.height / 100;
 
@@ -105,22 +106,22 @@ function init() {
 
             const meshFrame = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0x000000 }));
             meshFrame.position.z = -10.0;
-            meshFrame.scale.x = 1.1 * image.width / 100;
-            meshFrame.scale.y = 1.1 * image.height / 100;
+            meshFrame.scale.x = (1.1 * image.width) / 100;
+            meshFrame.scale.y = (1.1 * image.height) / 100;
             zscene.add(meshFrame);
 
             const meshShadow = new THREE.Mesh(
                 geometry,
                 new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.75, transparent: true }),
             );
-            meshShadow.position.y = -1.1 * image.height / 2;
-            meshShadow.position.z = -1.1 * image.height / 2;
+            meshShadow.position.y = (-1.1 * image.height) / 2;
+            meshShadow.position.z = (-1.1 * image.height) / 2;
             meshShadow.rotation.x = -Math.PI / 2;
-            meshShadow.scale.x = 1.1 * image.width / 100;
-            meshShadow.scale.y = 1.1 * image.height / 100;
+            meshShadow.scale.x = (1.1 * image.width) / 100;
+            meshShadow.scale.y = (1.1 * image.height) / 100;
             zscene.add(meshShadow);
 
-            const floorHeight = -1.117 * image.height / 2;
+            const floorHeight = (-1.117 * image.height) / 2;
             meshCanvas1.position.y = meshCanvas2.position.y = floorHeight;
         }
     };
@@ -150,7 +151,7 @@ function init() {
     document.addEventListener("mousemove", onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
@@ -162,8 +163,8 @@ function animate() {
 }
 
 function render() {
-    camera.position.x += (mouseX - camera.position.x) * .05;
-    camera.position.y += (-(mouseY - 200) - camera.position.y) * .05;
+    camera.position.x += (mouseX - camera.position.x) * 0.05;
+    camera.position.y += (-(mouseY - 200) - camera.position.y) * 0.05;
 
     camera.lookAt(scene1.position);
 
diff --git a/examples-testing/examples/webgl_materials_texture_partialupdate.ts b/examples-testing/examples/webgl_materials_texture_partialupdate.ts
index dd0c6d0..a975cc6 100644
--- a/examples-testing/examples/webgl_materials_texture_partialupdate.ts
+++ b/examples-testing/examples/webgl_materials_texture_partialupdate.ts
@@ -1,6 +1,11 @@
 import * as THREE from "three";
 
-let camera, scene, renderer, clock, dataTexture, diffuseMap;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    dataTexture: THREE.DataTexture,
+    diffuseMap: THREE.Texture;
 
 let last = 0;
 const position = new THREE.Vector2();
@@ -63,8 +68,8 @@ function animate() {
     if (elapsedTime - last > 0.1) {
         last = elapsedTime;
 
-        position.x = (32 * THREE.MathUtils.randInt(1, 16)) - 32;
-        position.y = (32 * THREE.MathUtils.randInt(1, 16)) - 32;
+        position.x = 32 * THREE.MathUtils.randInt(1, 16) - 32;
+        position.y = 32 * THREE.MathUtils.randInt(1, 16) - 32;
 
         // generate new color data
 
@@ -78,7 +83,7 @@ function animate() {
     renderer.render(scene, camera);
 }
 
-function updateDataTexture(texture) {
+function updateDataTexture(texture: THREE.DataTexture) {
     const size = texture.image.width * texture.image.height;
     const data = texture.image.data;
 
diff --git a/examples-testing/examples/webgl_materials_texture_rotation.ts b/examples-testing/examples/webgl_materials_texture_rotation.ts
index bde1b47..ed673f2 100644
--- a/examples-testing/examples/webgl_materials_texture_rotation.ts
+++ b/examples-testing/examples/webgl_materials_texture_rotation.ts
@@ -1,9 +1,12 @@
 import * as THREE from "three";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let mesh, renderer, scene, camera;
+let mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshBasicMaterial>,
+    renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera;
 
 let gui;
 
@@ -39,12 +42,12 @@ function init() {
 
     const geometry = new THREE.BoxGeometry(10, 10, 10);
 
-    new THREE.TextureLoader().load("textures/uv_grid_opengl.jpg", function (texture) {
+    new THREE.TextureLoader().load("textures/uv_grid_opengl.jpg", function(texture) {
         texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
         texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
         texture.colorSpace = THREE.SRGBColorSpace;
 
-        //texture.matrixAutoUpdate = false; // default true; set to false to update texture.matrix manually
+        // texture.matrixAutoUpdate = false; // default true; set to false to update texture.matrix manually
 
         const material = new THREE.MeshBasicMaterial({ map: texture });
 
@@ -76,7 +79,7 @@ function onWindowResize() {
 }
 
 function updateUvTransform() {
-    const texture = mesh.material.map;
+    const texture = mesh.material.map!;
 
     if (texture.matrixAutoUpdate === true) {
         texture.offset.set(API.offsetX, API.offsetY);
@@ -85,7 +88,7 @@ function updateUvTransform() {
         texture.rotation = API.rotation; // rotation is around center
     } else {
         // setting the matrix uv transform directly
-        //texture.matrix.setUvTransform( API.offsetX, API.offsetY, API.repeatX, API.repeatY, API.rotation, API.centerX, API.centerY );
+        // texture.matrix.setUvTransform( API.offsetX, API.offsetY, API.repeatX, API.repeatY, API.rotation, API.centerX, API.centerY );
 
         // another way...
         texture.matrix
diff --git a/examples-testing/examples/webgl_materials_toon.ts b/examples-testing/examples/webgl_materials_toon.ts
index 543fa5f..021fa3f 100644
--- a/examples-testing/examples/webgl_materials_toon.ts
+++ b/examples-testing/examples/webgl_materials_toon.ts
@@ -4,21 +4,21 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { OutlineEffect } from "three/addons/effects/OutlineEffect.js";
-import { FontLoader } from "three/addons/loaders/FontLoader.js";
 import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
+import { Font, FontLoader } from "three/addons/loaders/FontLoader.js";
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer, effect;
-let particleLight;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, effect: OutlineEffect;
+let particleLight: THREE.Mesh;
 
 const loader = new FontLoader();
-loader.load("fonts/gentilis_regular.typeface.json", function (font) {
+loader.load("fonts/gentilis_regular.typeface.json", function(font) {
     init(font);
     animate();
 });
 
-function init(font) {
+function init(font: Font) {
     container = document.createElement("div");
     document.body.appendChild(container);
 
@@ -43,7 +43,7 @@ function init(font) {
     const numberOfSphersPerSide = 5;
     const sphereRadius = (cubeWidth / numberOfSphersPerSide) * 0.8 * 0.5;
     const stepSize = 1.0 / numberOfSphersPerSide;
-    const format = (renderer.capabilities.isWebGL2) ? THREE.RedFormat : THREE.LuminanceFormat;
+    const format = renderer.capabilities.isWebGL2 ? THREE.RedFormat : THREE.LuminanceFormat;
 
     const geometry = new THREE.SphereGeometry(sphereRadius, 32, 16);
 
@@ -60,9 +60,9 @@ function init(font) {
         for (let beta = 0; beta <= 1.0; beta += stepSize) {
             for (let gamma = 0; gamma <= 1.0; gamma += stepSize) {
                 // basic monochromatic energy preservation
-                const diffuseColor = new THREE.Color().setHSL(alpha, 0.5, gamma * 0.5 + 0.1).multiplyScalar(
-                    1 - beta * 0.2,
-                );
+                const diffuseColor = new THREE.Color()
+                    .setHSL(alpha, 0.5, gamma * 0.5 + 0.1)
+                    .multiplyScalar(1 - beta * 0.2);
 
                 const material = new THREE.MeshToonMaterial({
                     color: diffuseColor,
@@ -80,7 +80,7 @@ function init(font) {
         }
     }
 
-    function addLabel(name, location) {
+    function addLabel(name: string, location: THREE.Vector3) {
         const textGeo = new TextGeometry(name, {
             font: font,
 
@@ -101,10 +101,7 @@ function init(font) {
     addLabel("-diffuse", new THREE.Vector3(0, 0, -300));
     addLabel("+diffuse", new THREE.Vector3(0, 0, 300));
 
-    particleLight = new THREE.Mesh(
-        new THREE.SphereGeometry(4, 8, 8),
-        new THREE.MeshBasicMaterial({ color: 0xffffff }),
-    );
+    particleLight = new THREE.Mesh(new THREE.SphereGeometry(4, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffffff }));
     scene.add(particleLight);
 
     // Lights
diff --git a/examples-testing/examples/webgl_materials_video.ts b/examples-testing/examples/webgl_materials_video.ts
index 21330fc..4ddff24 100644
--- a/examples-testing/examples/webgl_materials_video.ts
+++ b/examples-testing/examples/webgl_materials_video.ts
@@ -1,17 +1,20 @@
 import * as THREE from "three";
 
-import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
-import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { BloomPass } from "three/addons/postprocessing/BloomPass.js";
+import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
 import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
+import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let video, texture, material, mesh;
+let video,
+    texture,
+    material: THREE.MeshLambertMaterial & { hue?: number; saturation?: number },
+    mesh: THREE.Mesh & { dx?: number; dy?: number };
 
-let composer;
+let composer: EffectComposer;
 
 let mouseX = 0;
 let mouseY = 0;
@@ -19,21 +22,21 @@ let mouseY = 0;
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
 
-let cube_count;
+let cube_count: number;
 
-const meshes = [],
-    materials = [],
+const meshes: THREE.Mesh[] = [],
+    materials: (THREE.MeshLambertMaterial & { hue?: number; saturation?: number })[] = [],
     xgrid = 20,
     ygrid = 10;
 
-const startButton = document.getElementById("startButton");
-startButton.addEventListener("click", function () {
+const startButton = document.getElementById("startButton")!;
+startButton.addEventListener("click", function() {
     init();
     animate();
 });
 
 function init() {
-    const overlay = document.getElementById("overlay");
+    const overlay = document.getElementById("overlay")!;
     overlay.remove();
 
     container = document.createElement("div");
@@ -53,9 +56,9 @@ function init() {
     renderer.setSize(window.innerWidth, window.innerHeight);
     container.appendChild(renderer.domElement);
 
-    video = document.getElementById("video");
+    video = document.getElementById("video") as HTMLVideoElement;
     video.play();
-    video.addEventListener("play", function () {
+    video.addEventListener("play", function() {
         this.currentTime = 3;
     });
 
@@ -145,7 +148,7 @@ function onWindowResize() {
     composer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function change_uvs(geometry, unitx, unity, offsetx, offsety) {
+function change_uvs(geometry: THREE.BoxGeometry, unitx: number, unity: number, offsetx: number, offsety: number) {
     const uvs = geometry.attributes.uv.array;
 
     for (let i = 0; i < uvs.length; i += 2) {
@@ -154,7 +157,7 @@ function change_uvs(geometry, unitx, unity, offsetx, offsety) {
     }
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = (event.clientY - windowHalfY) * 0.3;
 }
@@ -167,7 +170,8 @@ function animate() {
     render();
 }
 
-let h, counter = 1;
+let h,
+    counter = 1;
 
 function render() {
     const time = Date.now() * 0.00005;
@@ -180,20 +184,20 @@ function render() {
     for (let i = 0; i < cube_count; i++) {
         material = materials[i];
 
-        h = (360 * (material.hue + time) % 360) / 360;
-        material.color.setHSL(h, material.saturation, 0.5);
+        h = ((360 * (material.hue! + time)) % 360) / 360;
+        material.color.setHSL(h, material.saturation!, 0.5);
     }
 
     if (counter % 1000 > 200) {
         for (let i = 0; i < cube_count; i++) {
             mesh = meshes[i];
 
-            mesh.rotation.x += 10 * mesh.dx;
-            mesh.rotation.y += 10 * mesh.dy;
+            mesh.rotation.x += 10 * mesh.dx!;
+            mesh.rotation.y += 10 * mesh.dy!;
 
-            mesh.position.x -= 150 * mesh.dx;
-            mesh.position.y += 150 * mesh.dy;
-            mesh.position.z += 300 * mesh.dx;
+            mesh.position.x -= 150 * mesh.dx!;
+            mesh.position.y += 150 * mesh.dy!;
+            mesh.position.z += 300 * mesh.dx!;
         }
     }
 
@@ -201,8 +205,8 @@ function render() {
         for (let i = 0; i < cube_count; i++) {
             mesh = meshes[i];
 
-            mesh.dx *= -1;
-            mesh.dy *= -1;
+            mesh.dx! *= -1;
+            mesh.dy! *= -1;
         }
     }
 
diff --git a/examples-testing/examples/webgl_materials_video_webcam.ts b/examples-testing/examples/webgl_materials_video_webcam.ts
index 577e9aa..5e71033 100644
--- a/examples-testing/examples/webgl_materials_video_webcam.ts
+++ b/examples-testing/examples/webgl_materials_video_webcam.ts
@@ -2,7 +2,7 @@ import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let camera, scene, renderer, video;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, video: HTMLVideoElement;
 
 init();
 animate();
@@ -13,7 +13,7 @@ function init() {
 
     scene = new THREE.Scene();
 
-    video = document.getElementById("video");
+    video = document.getElementById("video") as HTMLVideoElement;
 
     const texture = new THREE.VideoTexture(video);
     texture.colorSpace = THREE.SRGBColorSpace;
@@ -51,14 +51,17 @@ function init() {
     if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
         const constraints = { video: { width: 1280, height: 720, facingMode: "user" } };
 
-        navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
-            // apply the stream to the video element used in the texture
-
-            video.srcObject = stream;
-            video.play();
-        }).catch(function (error) {
-            console.error("Unable to access the camera/webcam.", error);
-        });
+        navigator.mediaDevices
+            .getUserMedia(constraints)
+            .then(function(stream) {
+                // apply the stream to the video element used in the texture
+
+                video.srcObject = stream;
+                video.play();
+            })
+            .catch(function(error) {
+                console.error("Unable to access the camera/webcam.", error);
+            });
     } else {
         console.error("MediaDevices interface not available.");
     }
diff --git a/examples-testing/examples/webgl_materials_wireframe.ts b/examples-testing/examples/webgl_materials_wireframe.ts
index b83bcdb..b4878da 100644
--- a/examples-testing/examples/webgl_materials_wireframe.ts
+++ b/examples-testing/examples/webgl_materials_wireframe.ts
@@ -8,7 +8,10 @@ const API = {
     thickness: 1,
 };
 
-let renderer, scene, camera, mesh2;
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    mesh2: THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>;
 
 init();
 
@@ -28,7 +31,7 @@ function init() {
     controls.enablePan = false;
     controls.enableZoom = false;
 
-    new THREE.BufferGeometryLoader().load("models/json/WaltHeadLo_buffergeometry.json", function (geometry) {
+    new THREE.BufferGeometryLoader().load("models/json/WaltHeadLo_buffergeometry.json", function(geometry) {
         geometry.deleteAttribute("normal");
         geometry.deleteAttribute("uv");
 
@@ -49,9 +52,9 @@ function init() {
         // right
 
         const material2 = new THREE.ShaderMaterial({
-            uniforms: { "thickness": { value: API.thickness } },
-            vertexShader: document.getElementById("vertexShader").textContent,
-            fragmentShader: document.getElementById("fragmentShader").textContent,
+            uniforms: { thickness: { value: API.thickness } },
+            vertexShader: document.getElementById("vertexShader")!.textContent!,
+            fragmentShader: document.getElementById("fragmentShader")!.textContent!,
             side: THREE.DoubleSide,
             alphaToCoverage: true, // only works when WebGLRenderer's "antialias" is set to "true"
         });
@@ -71,7 +74,7 @@ function init() {
 
     const gui = new GUI();
 
-    gui.add(API, "thickness", 0, 4).onChange(function () {
+    gui.add(API, "thickness", 0, 4).onChange(function() {
         mesh2.material.uniforms.thickness.value = API.thickness;
         render();
     });
@@ -83,12 +86,8 @@ function init() {
     window.addEventListener("resize", onWindowResize);
 }
 
-function setupAttributes(geometry) {
-    const vectors = [
-        new THREE.Vector3(1, 0, 0),
-        new THREE.Vector3(0, 1, 0),
-        new THREE.Vector3(0, 0, 1),
-    ];
+function setupAttributes(geometry: THREE.BufferGeometry) {
+    const vectors = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];
 
     const position = geometry.attributes.position;
     const centers = new Float32Array(position.count * 3);
diff --git a/examples-testing/examples/webgl_math_obb.ts b/examples-testing/examples/webgl_math_obb.ts
index d94fda5..10575c0 100644
--- a/examples-testing/examples/webgl_math_obb.ts
+++ b/examples-testing/examples/webgl_math_obb.ts
@@ -1,13 +1,21 @@
 import * as THREE from "three";
 
-import { OBB } from "three/addons/math/OBB.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { OBB } from "three/addons/math/OBB.js";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let camera, scene, renderer, clock, controls, stats, raycaster, hitbox;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    controls: OrbitControls,
+    stats: Stats,
+    raycaster: THREE.Raycaster,
+    hitbox: THREE.Mesh;
 
-const objects = [], mouse = new THREE.Vector2();
+const objects: THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial>[] = [],
+    mouse = new THREE.Vector2();
 
 init();
 animate();
@@ -88,7 +96,7 @@ function init() {
     document.addEventListener("click", onClick);
 }
 
-function onClick(event) {
+function onClick(event: MouseEvent) {
     event.preventDefault();
 
     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
@@ -124,7 +132,10 @@ function onClick(event) {
     }
 }
 
-function sortIntersections(a, b) {
+function sortIntersections(
+    a: { distance: number; object: THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial> },
+    b: { distance: number; object: THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial> },
+) {
     return a.distance - b.distance;
 }
 
@@ -149,7 +160,7 @@ function animate() {
     for (let i = 0, il = objects.length; i < il; i++) {
         const object = objects[i];
 
-        object.rotation.x += delta * Math.PI * 0.20;
+        object.rotation.x += delta * Math.PI * 0.2;
         object.rotation.y += delta * Math.PI * 0.1;
 
         object.updateMatrix();
diff --git a/examples-testing/examples/webgl_math_orientation_transform.ts b/examples-testing/examples/webgl_math_orientation_transform.ts
index 7aca749..99f3a2b 100644
--- a/examples-testing/examples/webgl_math_orientation_transform.ts
+++ b/examples-testing/examples/webgl_math_orientation_transform.ts
@@ -1,6 +1,10 @@
 import * as THREE from "three";
 
-let camera, scene, renderer, mesh, target;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    mesh: THREE.Mesh,
+    target: THREE.Mesh;
 
 const spherical = new THREE.Spherical();
 const rotationMatrix = new THREE.Matrix4();
@@ -83,7 +87,7 @@ function generateTarget() {
     // generate a random point on a sphere
 
     spherical.theta = Math.random() * Math.PI * 2;
-    spherical.phi = Math.acos((2 * Math.random()) - 1);
+    spherical.phi = Math.acos(2 * Math.random() - 1);
     spherical.radius = 2;
 
     target.position.setFromSpherical(spherical);
diff --git a/examples-testing/examples/webgl_mesh_batch.ts b/examples-testing/examples/webgl_mesh_batch.ts
index 4d30703..0b60da5 100644
--- a/examples-testing/examples/webgl_mesh_batch.ts
+++ b/examples-testing/examples/webgl_mesh_batch.ts
@@ -1,15 +1,15 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { radixSort } from "three/addons/utils/SortUtils.js";
+import { radixSort, RadixSortOptions } from "three/addons/utils/SortUtils.js";
 
-let stats, gui, guiStatsEl;
-let camera, controls, scene, renderer;
-let geometries, mesh, material;
-const ids = [];
+let stats: Stats, gui: GUI, guiStatsEl: HTMLLIElement;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let geometries: THREE.BufferGeometry[], mesh: THREE.Group | THREE.BatchedMesh, material: THREE.MeshNormalMaterial;
+const ids: number[] = [];
 const matrix = new THREE.Matrix4();
 
 //
@@ -46,7 +46,7 @@ animate();
 
 //
 
-function randomizeMatrix(matrix) {
+function randomizeMatrix(matrix: THREE.Matrix4) {
     position.x = Math.random() * 40 - 20;
     position.y = Math.random() * 40 - 20;
     position.z = Math.random() * 40 - 20;
@@ -57,12 +57,12 @@ function randomizeMatrix(matrix) {
 
     quaternion.setFromEuler(rotation);
 
-    scale.x = scale.y = scale.z = 0.5 + (Math.random() * 0.5);
+    scale.x = scale.y = scale.z = 0.5 + Math.random() * 0.5;
 
     return matrix.compose(position, quaternion, scale);
 }
 
-function randomizeRotationSpeed(rotation) {
+function randomizeRotationSpeed(rotation: THREE.Euler) {
     rotation.x = Math.random() * 0.01;
     rotation.y = Math.random() * 0.01;
     rotation.z = Math.random() * 0.01;
@@ -87,10 +87,10 @@ function createMaterial() {
 
 function cleanup() {
     if (mesh) {
-        mesh.parent.remove(mesh);
+        mesh.parent!.remove(mesh);
 
-        if (mesh.dispose) {
-            mesh.dispose();
+        if ((mesh as THREE.BatchedMesh).dispose) {
+            (mesh as THREE.BatchedMesh).dispose();
         }
     }
 }
@@ -187,7 +187,7 @@ function init() {
     gui.add(api, "count", 1, MAX_GEOMETRY_COUNT).step(1).onChange(initMesh);
     gui.add(api, "dynamic", 0, MAX_GEOMETRY_COUNT).step(1);
     gui.add(api, "method", Method).onChange(initMesh);
-    gui.add(api, "opacity", 0, 1).onChange((v) => {
+    gui.add(api, "opacity", 0, 1).onChange(v => {
         if (v < 1) {
             material.transparent = true;
             material.depthWrite = false;
@@ -213,18 +213,26 @@ function init() {
 
 //
 
-function sortFunction(list, camera) {
+type BatchedMeshWithOptions = THREE.BatchedMesh & {
+    _options?: RadixSortOptions<{ start: number; count: number; z: number }>;
+};
+
+function sortFunction(
+    this: THREE.BatchedMesh,
+    list: { start: number; count: number; z: number }[],
+    camera: THREE.Camera,
+) {
     // initialize options
-    this._options = this._options || {
-        get: (el) => el.z,
+    (this as BatchedMeshWithOptions)._options = (this as BatchedMeshWithOptions)._options || {
+        get: el => el.z,
         aux: new Array(this.maxGeometryCount),
     };
 
-    const options = this._options;
+    const options = (this as BatchedMeshWithOptions)._options!;
     options.reversed = this.material.transparent;
 
     // convert depth to unsigned 32 bit range
-    const factor = (2 ** 32 - 1) / camera.far; // UINT32_MAX / max_depth
+    const factor = (2 ** 32 - 1) / (camera as THREE.PerspectiveCamera).far; // UINT32_MAX / max_depth
     for (let i = 0, l = list.length; i < l; i++) {
         list[i].z *= factor;
     }
@@ -262,9 +270,9 @@ function animateMeshes() {
             const rotationMatrix = mesh.userData.rotationSpeeds[i];
             const id = ids[i];
 
-            mesh.getMatrixAt(id, matrix);
+            (mesh as THREE.BatchedMesh).getMatrixAt(id, matrix);
             matrix.multiply(rotationMatrix);
-            mesh.setMatrixAt(id, matrix);
+            (mesh as THREE.BatchedMesh).setMatrixAt(id, matrix);
         }
     } else {
         for (let i = 0; i < loopNum; i++) {
@@ -281,10 +289,10 @@ function animateMeshes() {
 }
 
 function render() {
-    if (mesh.isBatchedMesh) {
-        mesh.sortObjects = api.sortObjects;
-        mesh.perObjectFrustumCulled = api.perObjectFrustumCulled;
-        mesh.setCustomSort(api.useCustomSort ? sortFunction : null);
+    if ((mesh as THREE.BatchedMesh).isBatchedMesh) {
+        (mesh as THREE.BatchedMesh).sortObjects = api.sortObjects;
+        (mesh as THREE.BatchedMesh).perObjectFrustumCulled = api.perObjectFrustumCulled;
+        (mesh as THREE.BatchedMesh).setCustomSort(api.useCustomSort ? sortFunction : null);
     }
 
     renderer.render(scene, camera);
diff --git a/examples-testing/examples/webgl_mirror.ts b/examples-testing/examples/webgl_mirror.ts
index 9e8ab76..7771994 100644
--- a/examples-testing/examples/webgl_mirror.ts
+++ b/examples-testing/examples/webgl_mirror.ts
@@ -3,19 +3,19 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { Reflector } from "three/addons/objects/Reflector.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let cameraControls;
+let cameraControls: OrbitControls;
 
-let sphereGroup, smallSphere;
+let sphereGroup: THREE.Object3D, smallSphere: THREE.Mesh;
 
-let groundMirror, verticalMirror;
+let groundMirror: Reflector, verticalMirror: Reflector;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     // renderer
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -69,18 +69,18 @@ function init() {
     sphereGroup = new THREE.Object3D();
     scene.add(sphereGroup);
 
-    geometry = new THREE.CylinderGeometry(0.1, 15 * Math.cos(Math.PI / 180 * 30), 0.1, 24, 1);
+    geometry = new THREE.CylinderGeometry(0.1, 15 * Math.cos((Math.PI / 180) * 30), 0.1, 24, 1);
     material = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x8d8d8d });
     const sphereCap = new THREE.Mesh(geometry, material);
-    sphereCap.position.y = -15 * Math.sin(Math.PI / 180 * 30) - 0.05;
+    sphereCap.position.y = -15 * Math.sin((Math.PI / 180) * 30) - 0.05;
     sphereCap.rotateX(-Math.PI);
 
-    geometry = new THREE.SphereGeometry(15, 24, 24, Math.PI / 2, Math.PI * 2, 0, Math.PI / 180 * 120);
+    geometry = new THREE.SphereGeometry(15, 24, 24, Math.PI / 2, Math.PI * 2, 0, (Math.PI / 180) * 120);
     const halfSphere = new THREE.Mesh(geometry, material);
     halfSphere.add(sphereCap);
-    halfSphere.rotateX(-Math.PI / 180 * 135);
-    halfSphere.rotateZ(-Math.PI / 180 * 20);
-    halfSphere.position.y = 7.5 + 15 * Math.sin(Math.PI / 180 * 30);
+    halfSphere.rotateX((-Math.PI / 180) * 135);
+    halfSphere.rotateZ((-Math.PI / 180) * 20);
+    halfSphere.position.y = 7.5 + 15 * Math.sin((Math.PI / 180) * 30);
 
     sphereGroup.add(halfSphere);
 
@@ -143,14 +143,12 @@ function onWindowResize() {
 
     renderer.setSize(window.innerWidth, window.innerHeight);
 
-    groundMirror.getRenderTarget().setSize(
-        window.innerWidth * window.devicePixelRatio,
-        window.innerHeight * window.devicePixelRatio,
-    );
-    verticalMirror.getRenderTarget().setSize(
-        window.innerWidth * window.devicePixelRatio,
-        window.innerHeight * window.devicePixelRatio,
-    );
+    groundMirror
+        .getRenderTarget()
+        .setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio);
+    verticalMirror
+        .getRenderTarget()
+        .setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio);
 }
 
 function animate() {
@@ -165,7 +163,7 @@ function animate() {
         Math.abs(Math.cos(timer * 0.2)) * 20 + 5,
         Math.sin(timer * 0.1) * 30,
     );
-    smallSphere.rotation.y = (Math.PI / 2) - timer * 0.1;
+    smallSphere.rotation.y = Math.PI / 2 - timer * 0.1;
     smallSphere.rotation.z = timer * 0.8;
 
     renderer.render(scene, camera);
diff --git a/examples-testing/examples/webgl_modifier_edgesplit.ts b/examples-testing/examples/webgl_modifier_edgesplit.ts
index e3076cc..f054c9f 100644
--- a/examples-testing/examples/webgl_modifier_edgesplit.ts
+++ b/examples-testing/examples/webgl_modifier_edgesplit.ts
@@ -7,9 +7,11 @@ import * as BufferGeometryUtils from "three/addons/utils/BufferGeometryUtils.js"
 
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let renderer, scene, camera;
-let modifier, mesh, baseGeometry;
-let map;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let modifier: EdgeSplitModifier,
+    mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>,
+    baseGeometry: THREE.BufferGeometry;
+let map: THREE.Texture;
 
 const params = {
     smoothShading: true,
@@ -27,7 +29,8 @@ function init() {
     info.style.top = "10px";
     info.style.width = "100%";
     info.style.textAlign = "center";
-    info.innerHTML = '<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - Edge Split modifier';
+    info.innerHTML =
+        "<a href=\"https://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a> - Edge Split modifier";
     document.body.appendChild(info);
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -49,34 +52,31 @@ function init() {
 
     scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 3));
 
-    new OBJLoader().load(
-        "./models/obj/cerberus/Cerberus.obj",
-        function (group) {
-            const cerberus = group.children[0];
-            const modelGeometry = cerberus.geometry;
+    new OBJLoader().load("./models/obj/cerberus/Cerberus.obj", function(group) {
+        const cerberus = group.children[0] as THREE.Mesh;
+        const modelGeometry = cerberus.geometry;
 
-            modifier = new EdgeSplitModifier();
-            baseGeometry = BufferGeometryUtils.mergeVertices(modelGeometry);
+        modifier = new EdgeSplitModifier();
+        baseGeometry = BufferGeometryUtils.mergeVertices(modelGeometry);
 
-            mesh = new THREE.Mesh(getGeometry(), new THREE.MeshStandardMaterial());
-            mesh.material.flatShading = !params.smoothShading;
-            mesh.rotateY(-Math.PI / 2);
-            mesh.scale.set(3.5, 3.5, 3.5);
-            mesh.translateZ(1.5);
-            scene.add(mesh);
+        mesh = new THREE.Mesh(getGeometry(), new THREE.MeshStandardMaterial());
+        mesh.material.flatShading = !params.smoothShading;
+        mesh.rotateY(-Math.PI / 2);
+        mesh.scale.set(3.5, 3.5, 3.5);
+        mesh.translateZ(1.5);
+        scene.add(mesh);
 
-            if (map !== undefined && params.showMap) {
-                mesh.material.map = map;
-                mesh.material.needsUpdate = true;
-            }
+        if (map !== undefined && params.showMap) {
+            mesh.material.map = map;
+            mesh.material.needsUpdate = true;
+        }
 
-            render();
-        },
-    );
+        render();
+    });
 
     window.addEventListener("resize", onWindowResize);
 
-    new THREE.TextureLoader().load("./models/obj/cerberus/Cerberus_A.jpg", function (texture) {
+    new THREE.TextureLoader().load("./models/obj/cerberus/Cerberus_A.jpg", function(texture) {
         map = texture;
         map.colorSpace = THREE.SRGBColorSpace;
 
@@ -108,11 +108,7 @@ function getGeometry() {
     let geometry;
 
     if (params.edgeSplit) {
-        geometry = modifier.modify(
-            baseGeometry,
-            params.cutOffAngle * Math.PI / 180,
-            params.tryKeepNormals,
-        );
+        geometry = modifier.modify(baseGeometry, (params.cutOffAngle * Math.PI) / 180, params.tryKeepNormals);
     } else {
         geometry = baseGeometry;
     }
diff --git a/examples-testing/examples/webgl_modifier_simplifier.ts b/examples-testing/examples/webgl_modifier_simplifier.ts
index d31e296..6853804 100644
--- a/examples-testing/examples/webgl_modifier_simplifier.ts
+++ b/examples-testing/examples/webgl_modifier_simplifier.ts
@@ -4,7 +4,7 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { SimplifyModifier } from "three/addons/modifiers/SimplifyModifier.js";
 
-let renderer, scene, camera;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
 
 init();
 
@@ -15,7 +15,7 @@ function init() {
     info.style.width = "100%";
     info.style.textAlign = "center";
     info.innerHTML =
-        '<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - Vertex Reduction using SimplifyModifier';
+        "<a href=\"https://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a> - Vertex Reduction using SimplifyModifier";
     document.body.appendChild(info);
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -39,7 +39,7 @@ function init() {
     camera.add(light);
     scene.add(camera);
 
-    new GLTFLoader().load("models/gltf/LeePerrySmith/LeePerrySmith.glb", function (gltf) {
+    new GLTFLoader().load("models/gltf/LeePerrySmith/LeePerrySmith.glb", function(gltf) {
         const mesh = gltf.scene.children[0];
         mesh.position.x = -3;
         mesh.rotation.y = Math.PI / 2;
@@ -47,7 +47,7 @@ function init() {
 
         const modifier = new SimplifyModifier();
 
-        const simplified = mesh.clone();
+        const simplified = mesh.clone() as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
         simplified.material = simplified.material.clone();
         simplified.material.flatShading = true;
         const count = Math.floor(simplified.geometry.attributes.position.count * 0.875); // number of vertices to remove
diff --git a/examples-testing/examples/webgl_modifier_tessellation.ts b/examples-testing/examples/webgl_modifier_tessellation.ts
index f8d4aa1..ba52425 100644
--- a/examples-testing/examples/webgl_modifier_tessellation.ts
+++ b/examples-testing/examples/webgl_modifier_tessellation.ts
@@ -3,26 +3,26 @@ import * as THREE from "three";
 import Stats from "three/addons/libs/stats.module.js";
 
 import { TrackballControls } from "three/addons/controls/TrackballControls.js";
-import { TessellateModifier } from "three/addons/modifiers/TessellateModifier.js";
-import { FontLoader } from "three/addons/loaders/FontLoader.js";
 import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
+import { Font, FontLoader } from "three/addons/loaders/FontLoader.js";
+import { TessellateModifier } from "three/addons/modifiers/TessellateModifier.js";
 
-let renderer, scene, camera, stats;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, stats: Stats;
 
-let controls;
+let controls: TrackballControls;
 
-let mesh, uniforms;
+let mesh: THREE.Mesh, uniforms: Record<string, THREE.IUniform<unknown>>;
 
 const WIDTH = window.innerWidth;
 const HEIGHT = window.innerHeight;
 
 const loader = new FontLoader();
-loader.load("fonts/helvetiker_bold.typeface.json", function (font) {
+loader.load("fonts/helvetiker_bold.typeface.json", function(font) {
     init(font);
     animate();
 });
 
-function init(font) {
+function init(font: Font) {
     camera = new THREE.PerspectiveCamera(40, WIDTH / HEIGHT, 1, 10000);
     camera.position.set(-100, 100, 200);
 
@@ -70,13 +70,13 @@ function init(font) {
         const d = 10 * (0.5 - Math.random());
 
         for (let i = 0; i < 3; i++) {
-            colors[index + (3 * i)] = color.r;
-            colors[index + (3 * i) + 1] = color.g;
-            colors[index + (3 * i) + 2] = color.b;
+            colors[index + 3 * i] = color.r;
+            colors[index + 3 * i + 1] = color.g;
+            colors[index + 3 * i + 2] = color.b;
 
-            displacement[index + (3 * i)] = d;
-            displacement[index + (3 * i) + 1] = d;
-            displacement[index + (3 * i) + 2] = d;
+            displacement[index + 3 * i] = d;
+            displacement[index + 3 * i + 1] = d;
+            displacement[index + 3 * i + 2] = d;
         }
     }
 
@@ -91,8 +91,8 @@ function init(font) {
 
     const shaderMaterial = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById("vertexshader").textContent,
-        fragmentShader: document.getElementById("fragmentshader").textContent,
+        vertexShader: document.getElementById("vertexshader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentshader")!.textContent!,
     });
 
     //
@@ -105,7 +105,7 @@ function init(font) {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(WIDTH, HEIGHT);
 
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
     container.appendChild(renderer.domElement);
 
     controls = new TrackballControls(camera, renderer.domElement);
diff --git a/examples-testing/examples/webgl_morphtargets.ts b/examples-testing/examples/webgl_morphtargets.ts
index d965d84..9af5033 100644
--- a/examples-testing/examples/webgl_morphtargets.ts
+++ b/examples-testing/examples/webgl_morphtargets.ts
@@ -1,23 +1,27 @@
 import * as THREE from "three";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let container, camera, scene, renderer, mesh;
+let container: HTMLElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    mesh: THREE.Mesh;
 
 init();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     scene = new THREE.Scene();
-    scene.background = new THREE.Color(0x8FBCD4);
+    scene.background = new THREE.Color(0x8fbcd4);
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 20);
     camera.position.z = 10;
     scene.add(camera);
 
-    scene.add(new THREE.AmbientLight(0x8FBCD4, 1.5));
+    scene.add(new THREE.AmbientLight(0x8fbcd4, 1.5));
 
     const pointLight = new THREE.PointLight(0xffffff, 200);
     camera.add(pointLight);
@@ -37,7 +41,7 @@ function init() {
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
-    renderer.setAnimationLoop(function () {
+    renderer.setAnimationLoop(function() {
         renderer.render(scene, camera);
     });
     container.appendChild(renderer.domElement);
@@ -62,7 +66,7 @@ function createGeometry() {
     const spherePositions = [];
 
     // for the second morph target, we'll twist the cubes vertices
-    const twistPositions = [];
+    const twistPositions: number[] = [];
     const direction = new THREE.Vector3(1, 0, 0);
     const vertex = new THREE.Vector3();
 
@@ -72,15 +76,15 @@ function createGeometry() {
         const z = positionAttribute.getZ(i);
 
         spherePositions.push(
-            x * Math.sqrt(1 - (y * y / 2) - (z * z / 2) + (y * y * z * z / 3)),
-            y * Math.sqrt(1 - (z * z / 2) - (x * x / 2) + (z * z * x * x / 3)),
-            z * Math.sqrt(1 - (x * x / 2) - (y * y / 2) + (x * x * y * y / 3)),
+            x * Math.sqrt(1 - (y * y) / 2 - (z * z) / 2 + (y * y * z * z) / 3),
+            y * Math.sqrt(1 - (z * z) / 2 - (x * x) / 2 + (z * z * x * x) / 3),
+            z * Math.sqrt(1 - (x * x) / 2 - (y * y) / 2 + (x * x * y * y) / 3),
         );
 
         // stretch along the x-axis so we can see the twist better
         vertex.set(x * 2, y, z);
 
-        vertex.applyAxisAngle(direction, Math.PI * x / 2).toArray(twistPositions, twistPositions.length);
+        vertex.applyAxisAngle(direction, (Math.PI * x) / 2).toArray(twistPositions, twistPositions.length);
     }
 
     // add the spherical positions as the first morph target
@@ -100,12 +104,16 @@ function initGUI() {
     };
     const gui = new GUI({ title: "Morph Targets" });
 
-    gui.add(params, "Spherify", 0, 1).step(0.01).onChange(function (value) {
-        mesh.morphTargetInfluences[0] = value;
-    });
-    gui.add(params, "Twist", 0, 1).step(0.01).onChange(function (value) {
-        mesh.morphTargetInfluences[1] = value;
-    });
+    gui.add(params, "Spherify", 0, 1)
+        .step(0.01)
+        .onChange(function(value) {
+            mesh.morphTargetInfluences![0] = value;
+        });
+    gui.add(params, "Twist", 0, 1)
+        .step(0.01)
+        .onChange(function(value) {
+            mesh.morphTargetInfluences![1] = value;
+        });
 }
 
 function onWindowResize() {
diff --git a/examples-testing/examples/webgl_morphtargets_face.ts b/examples-testing/examples/webgl_morphtargets_face.ts
index f2f6c91..423c7cd 100644
--- a/examples-testing/examples/webgl_morphtargets_face.ts
+++ b/examples-testing/examples/webgl_morphtargets_face.ts
@@ -4,9 +4,9 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
+import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
-import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";
 
 import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
 
@@ -15,7 +15,7 @@ import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 init();
 
 function init() {
-    let mixer;
+    let mixer: THREE.AnimationMixer;
 
     const clock = new THREE.Clock();
 
@@ -34,14 +34,12 @@ function init() {
 
     container.appendChild(renderer.domElement);
 
-    const ktx2Loader = new KTX2Loader()
-        .setTranscoderPath("jsm/libs/basis/")
-        .detectSupport(renderer);
+    const ktx2Loader = new KTX2Loader().setTranscoderPath("jsm/libs/basis/").detectSupport(renderer);
 
     new GLTFLoader()
         .setKTX2Loader(ktx2Loader)
         .setMeshoptDecoder(MeshoptDecoder)
-        .load("models/gltf/facecap.glb", (gltf) => {
+        .load("models/gltf/facecap.glb", gltf => {
             const mesh = gltf.scene.children[0];
 
             scene.add(mesh);
@@ -52,16 +50,14 @@ function init() {
 
             // GUI
 
-            const head = mesh.getObjectByName("mesh_2");
-            const influences = head.morphTargetInfluences;
+            const head = mesh.getObjectByName("mesh_2") as THREE.Mesh;
+            const influences = head.morphTargetInfluences!;
 
             const gui = new GUI();
             gui.close();
 
-            for (const [key, value] of Object.entries(head.morphTargetDictionary)) {
-                gui.add(influences, value, 0, 1, 0.01)
-                    .name(key.replace("blendShape1.", ""))
-                    .listen();
+            for (const [key, value] of Object.entries(head.morphTargetDictionary!)) {
+                gui.add(influences, value, 0, 1, 0.01).name(key.replace("blendShape1.", "")).listen();
             }
         });
 
diff --git a/examples-testing/examples/webgl_morphtargets_horse.ts b/examples-testing/examples/webgl_morphtargets_horse.ts
index f026748..28bfe1c 100644
--- a/examples-testing/examples/webgl_morphtargets_horse.ts
+++ b/examples-testing/examples/webgl_morphtargets_horse.ts
@@ -4,9 +4,9 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-let container, stats;
-let camera, scene, renderer;
-let mesh, mixer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let mesh: THREE.Object3D, mixer: THREE.AnimationMixer;
 
 const radius = 600;
 let theta = 0;
@@ -38,7 +38,7 @@ function init() {
     scene.add(light2);
 
     const loader = new GLTFLoader();
-    loader.load("models/gltf/Horse.glb", function (gltf) {
+    loader.load("models/gltf/Horse.glb", function(gltf) {
         mesh = gltf.scene.children[0];
         mesh.scale.set(1.5, 1.5, 1.5);
         scene.add(mesh);
diff --git a/examples-testing/examples/webgl_morphtargets_sphere.ts b/examples-testing/examples/webgl_morphtargets_sphere.ts
index 4014bc9..66a99be 100644
--- a/examples-testing/examples/webgl_morphtargets_sphere.ts
+++ b/examples-testing/examples/webgl_morphtargets_sphere.ts
@@ -4,9 +4,9 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { Timer } from "three/addons/misc/Timer.js";
 
-let camera, scene, renderer, timer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, timer: Timer;
 
-let mesh;
+let mesh: THREE.Mesh;
 
 let sign = 1;
 const speed = 0.5;
@@ -15,7 +15,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.2, 100);
     camera.position.set(0, 5, 5);
@@ -35,8 +35,8 @@ function init() {
     scene.add(new THREE.AmbientLight(0x111111));
 
     const loader = new GLTFLoader();
-    loader.load("models/gltf/AnimatedMorphSphere/glTF/AnimatedMorphSphere.gltf", function (gltf) {
-        mesh = gltf.scene.getObjectByName("AnimatedMorphSphere");
+    loader.load("models/gltf/AnimatedMorphSphere/glTF/AnimatedMorphSphere.gltf", function(gltf) {
+        mesh = gltf.scene.getObjectByName("AnimatedMorphSphere") as THREE.Mesh;
         mesh.rotation.z = Math.PI / 2;
         scene.add(mesh);
 
@@ -95,9 +95,9 @@ function render() {
 
         mesh.rotation.y += step;
 
-        mesh.morphTargetInfluences[1] = mesh.morphTargetInfluences[1] + step * sign;
+        mesh.morphTargetInfluences![1] = mesh.morphTargetInfluences![1] + step * sign;
 
-        if (mesh.morphTargetInfluences[1] <= 0 || mesh.morphTargetInfluences[1] >= 1) {
+        if (mesh.morphTargetInfluences![1] <= 0 || mesh.morphTargetInfluences![1] >= 1) {
             sign *= -1;
         }
     }
diff --git a/examples-testing/examples/webgl_multiple_elements.ts b/examples-testing/examples/webgl_multiple_elements.ts
index a7ac868..a217f4a 100644
--- a/examples-testing/examples/webgl_multiple_elements.ts
+++ b/examples-testing/examples/webgl_multiple_elements.ts
@@ -2,15 +2,15 @@ import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let canvas, renderer;
+let canvas: HTMLCanvasElement, renderer: THREE.WebGLRenderer;
 
-const scenes = [];
+const scenes: THREE.Scene[] = [];
 
 init();
 animate();
 
 function init() {
-    canvas = document.getElementById("c");
+    canvas = document.getElementById("c") as HTMLCanvasElement;
 
     const geometries = [
         new THREE.BoxGeometry(1, 1, 1),
@@ -19,7 +19,7 @@ function init() {
         new THREE.CylinderGeometry(0.5, 0.5, 1, 12),
     ];
 
-    const content = document.getElementById("content");
+    const content = document.getElementById("content")!;
 
     for (let i = 0; i < 40; i++) {
         const scene = new THREE.Scene();
@@ -51,7 +51,7 @@ function init() {
         scene.userData.controls = controls;
 
         // add one random mesh to each scene
-        const geometry = geometries[geometries.length * Math.random() | 0];
+        const geometry = geometries[(geometries.length * Math.random()) | 0];
 
         const material = new THREE.MeshStandardMaterial({
             color: new THREE.Color().setHSL(Math.random(), 1, 0.75, THREE.SRGBColorSpace),
@@ -102,7 +102,7 @@ function render() {
     renderer.setClearColor(0xe0e0e0);
     renderer.setScissorTest(true);
 
-    scenes.forEach(function (scene) {
+    scenes.forEach(function(scene) {
         // so something moves
         scene.children[0].rotation.y = Date.now() * 0.001;
 
@@ -115,8 +115,10 @@ function render() {
 
         // check if it's offscreen. If so skip it
         if (
-            rect.bottom < 0 || rect.top > renderer.domElement.clientHeight ||
-            rect.right < 0 || rect.left > renderer.domElement.clientWidth
+            rect.bottom < 0
+            || rect.top > renderer.domElement.clientHeight
+            || rect.right < 0
+            || rect.left > renderer.domElement.clientWidth
         ) {
             return; // it's off screen
         }
@@ -132,10 +134,10 @@ function render() {
 
         const camera = scene.userData.camera;
 
-        //camera.aspect = width / height; // not changing in this example
-        //camera.updateProjectionMatrix();
+        // camera.aspect = width / height; // not changing in this example
+        // camera.updateProjectionMatrix();
 
-        //scene.userData.controls.update();
+        // scene.userData.controls.update();
 
         renderer.render(scene, camera);
     });
diff --git a/examples-testing/examples/webgl_multiple_scenes_comparison.ts b/examples-testing/examples/webgl_multiple_scenes_comparison.ts
index 23faa88..bb90385 100644
--- a/examples-testing/examples/webgl_multiple_scenes_comparison.ts
+++ b/examples-testing/examples/webgl_multiple_scenes_comparison.ts
@@ -2,21 +2,21 @@ import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let container, camera, renderer, controls;
-let sceneL, sceneR;
+let container: HTMLElement, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, controls: OrbitControls;
+let sceneL: THREE.Scene, sceneR: THREE.Scene;
 
 let sliderPos = window.innerWidth / 2;
 
 init();
 
 function init() {
-    container = document.querySelector(".container");
+    container = document.querySelector(".container")!;
 
     sceneL = new THREE.Scene();
-    sceneL.background = new THREE.Color(0xBCD48F);
+    sceneL.background = new THREE.Color(0xbcd48f);
 
     sceneR = new THREE.Scene();
-    sceneR.background = new THREE.Color(0x8FBCD4);
+    sceneR.background = new THREE.Color(0x8fbcd4);
 
     camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
     camera.position.z = 6;
@@ -52,9 +52,9 @@ function initMeshes() {
 }
 
 function initSlider() {
-    const slider = document.querySelector(".slider");
+    const slider = document.querySelector(".slider") as HTMLElement;
 
-    function onPointerDown() {
+    function onPointerDown(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
         controls.enabled = false;
@@ -70,12 +70,12 @@ function initSlider() {
         window.removeEventListener("pointerup", onPointerUp);
     }
 
-    function onPointerMove(e) {
+    function onPointerMove(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
-        sliderPos = Math.max(0, Math.min(window.innerWidth, e.pageX));
+        sliderPos = Math.max(0, Math.min(window.innerWidth, event.pageX));
 
-        slider.style.left = sliderPos - (slider.offsetWidth / 2) + "px";
+        slider.style.left = sliderPos - slider.offsetWidth / 2 + "px";
     }
 
     slider.style.touchAction = "none"; // disable touch scroll
diff --git a/examples-testing/examples/webgl_multiple_views.ts b/examples-testing/examples/webgl_multiple_views.ts
index bbdfc87..4c22ea8 100644
--- a/examples-testing/examples/webgl_multiple_views.ts
+++ b/examples-testing/examples/webgl_multiple_views.ts
@@ -2,15 +2,27 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let stats;
-
-let scene, renderer;
-
-let mouseX = 0, mouseY = 0;
-
-let windowWidth, windowHeight;
-
-const views = [
+let stats: Stats;
+
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+
+let mouseX = 0,
+    mouseY = 0;
+
+let windowWidth: number, windowHeight: number;
+
+const views: {
+    left: number;
+    bottom: number;
+    width: number;
+    height: number;
+    background: THREE.Color;
+    eye: [number, number, number];
+    up: [number, number, number];
+    fov: number;
+    updateCamera: (camera: THREE.PerspectiveCamera, scene: THREE.Scene, mouseX: number, mouseY: number) => void;
+    camera?: THREE.PerspectiveCamera;
+}[] = [
     {
         left: 0,
         bottom: 0,
@@ -20,7 +32,7 @@ const views = [
         eye: [0, 300, 1800],
         up: [0, 1, 0],
         fov: 30,
-        updateCamera: function (camera, scene, mouseX) {
+        updateCamera: function(camera, scene, mouseX) {
             camera.position.x += mouseX * 0.05;
             camera.position.x = Math.max(Math.min(camera.position.x, 2000), -2000);
             camera.lookAt(scene.position);
@@ -35,7 +47,7 @@ const views = [
         eye: [0, 1800, 0],
         up: [0, 0, 1],
         fov: 45,
-        updateCamera: function (camera, scene, mouseX) {
+        updateCamera: function(camera, scene, mouseX) {
             camera.position.x -= mouseX * 0.05;
             camera.position.x = Math.max(Math.min(camera.position.x, 2000), -2000);
             camera.lookAt(camera.position.clone().setY(0));
@@ -50,7 +62,7 @@ const views = [
         eye: [1400, 800, 1400],
         up: [0, 1, 0],
         fov: 60,
-        updateCamera: function (camera, scene, mouseX) {
+        updateCamera: function(camera, scene, mouseX) {
             camera.position.y -= mouseX * 0.05;
             camera.position.y = Math.max(Math.min(camera.position.y, 1600), -1600);
             camera.lookAt(scene.position);
@@ -62,7 +74,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     for (let ii = 0; ii < views.length; ++ii) {
         const view = views[ii];
@@ -84,7 +96,7 @@ function init() {
     canvas.width = 128;
     canvas.height = 128;
 
-    const context = canvas.getContext("2d");
+    const context = canvas.getContext("2d")!;
     const gradient = context.createRadialGradient(
         canvas.width / 2,
         canvas.height / 2,
@@ -190,7 +202,7 @@ function init() {
     document.addEventListener("mousemove", onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowWidth / 2;
     mouseY = event.clientY - windowHeight / 2;
 }
@@ -216,7 +228,7 @@ function render() {
 
     for (let ii = 0; ii < views.length; ++ii) {
         const view = views[ii];
-        const camera = view.camera;
+        const camera = view.camera!;
 
         view.updateCamera(camera, scene, mouseX, mouseY);
 
diff --git a/examples-testing/examples/webgl_nodes_loader_gltf_iridescence.ts b/examples-testing/examples/webgl_nodes_loader_gltf_iridescence.ts
index 285e3d1..58d8003 100644
--- a/examples-testing/examples/webgl_nodes_loader_gltf_iridescence.ts
+++ b/examples-testing/examples/webgl_nodes_loader_gltf_iridescence.ts
@@ -7,9 +7,9 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 
-let renderer, scene, camera, controls;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
 
-init().catch(function (err) {
+init().catch(function(err) {
     console.error(err);
 });
 
@@ -30,8 +30,7 @@ async function init() {
     controls.target.set(0, 0.2, 0);
     controls.update();
 
-    const rgbeLoader = new RGBELoader()
-        .setPath("textures/equirectangular/");
+    const rgbeLoader = new RGBELoader().setPath("textures/equirectangular/");
 
     const gltfLoader = new GLTFLoader().setPath("models/gltf/");
 
@@ -42,18 +41,22 @@ async function init() {
 
     // nodes
 
-    gltf.scene.traverse((mesh) => {
-        const material = mesh.material;
+    gltf.scene.traverse(mesh => {
+        const material = (mesh as THREE.Mesh).material;
 
-        if (material && material.iridescence > 0) {
-            const iridescenceFactorNode = checker(uv().add(vec2(timerLocal(-.05), 0)).mul(20));
+        if (material && (material as THREE.MeshPhysicalMaterial).iridescence > 0) {
+            const iridescenceFactorNode = checker(
+                uv()
+                    .add(vec2(timerLocal(-0.05), 0))
+                    .mul(20),
+            );
 
-            const nodeMaterial = NodeMaterial.fromMaterial(material); // @TODO: NodeMaterial.fromMaterial can be removed if WebGLNodes will apply it by default (as in WebGPURenderer)
+            const nodeMaterial = NodeMaterial.fromMaterial(material as THREE.MeshPhysicalMaterial); // @TODO: NodeMaterial.fromMaterial can be removed if WebGLNodes will apply it by default (as in WebGPURenderer)
             nodeMaterial.iridescenceNode = iridescenceFactorNode;
             nodeMaterial.iridescenceIORNode = float(1.3);
             nodeMaterial.iridescenceThicknessNode = float(400);
 
-            mesh.material = nodeMaterial;
+            (mesh as THREE.Mesh).material = nodeMaterial;
         }
     });
 
diff --git a/examples-testing/examples/webgl_nodes_loader_gltf_sheen.ts b/examples-testing/examples/webgl_nodes_loader_gltf_sheen.ts
index 93b94c7..fbfaa78 100644
--- a/examples-testing/examples/webgl_nodes_loader_gltf_sheen.ts
+++ b/examples-testing/examples/webgl_nodes_loader_gltf_sheen.ts
@@ -4,10 +4,10 @@ import { checker, color, mix, NodeMaterial, uv } from "three/nodes";
 import { nodeFrame } from "three/addons/renderers/webgl-legacy/nodes/WebGLNodes.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
+import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
 
 init();
 animate();
@@ -23,23 +23,21 @@ function init() {
 
     // model
 
-    new GLTFLoader()
-        .setPath("models/gltf/")
-        .load("SheenChair.glb", function (gltf) {
-            scene.add(gltf.scene);
+    new GLTFLoader().setPath("models/gltf/").load("SheenChair.glb", function(gltf) {
+        scene.add(gltf.scene);
 
-            const object = gltf.scene.getObjectByName("SheenChair_fabric");
+        const object = gltf.scene.getObjectByName("SheenChair_fabric") as THREE.Mesh;
 
-            // Convert to NodeMaterial
-            const material = NodeMaterial.fromMaterial(object.material); // @TODO: NodeMaterial.fromMaterial can be removed if WebGLNodes will apply it by default (as in WebGPURenderer)
+        // Convert to NodeMaterial
+        const material = NodeMaterial.fromMaterial(object.material as THREE.MeshPhysicalMaterial); // @TODO: NodeMaterial.fromMaterial can be removed if WebGLNodes will apply it by default (as in WebGPURenderer)
 
-            const checkerNode = checker(uv().mul(5));
+        const checkerNode = checker(uv().mul(5));
 
-            material.sheenNode = mix(color(0x00ffff), color(0xffff00), checkerNode);
-            material.sheenRoughnessNode = checkerNode;
+        material.sheenNode = mix(color(0x00ffff), color(0xffff00), checkerNode);
+        material.sheenRoughnessNode = checkerNode;
 
-            object.material = material;
-        });
+        object.material = material;
+    });
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
diff --git a/examples-testing/examples/webgl_nodes_loader_materialx.ts b/examples-testing/examples/webgl_nodes_loader_materialx.ts
index 18bf210..31e1192 100644
--- a/examples-testing/examples/webgl_nodes_loader_materialx.ts
+++ b/examples-testing/examples/webgl_nodes_loader_materialx.ts
@@ -1,41 +1,41 @@
 import * as THREE from "three";
 
-import { MaterialXLoader } from "./jsm/loaders/MaterialXLoader.js";
-import { OrbitControls } from "./jsm/controls/OrbitControls.js";
-import { RGBELoader } from "./jsm/loaders/RGBELoader.js";
-import { GLTFLoader } from "./jsm/loaders/GLTFLoader.js";
+import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
+import { MaterialXLoader } from "three/addons/loaders/MaterialXLoader.js";
+import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 
-import { nodeFrame } from "./jsm/renderers/webgl-legacy/nodes/WebGLNodes.js";
+import { nodeFrame } from "three/addons/renderers/webgl-legacy/nodes/WebGLNodes.js";
 
 const SAMPLE_PATH =
     "https://raw.githubusercontent.com/materialx/MaterialX/main/resources/Materials/Examples/StandardSurface/";
 
 const samples = [
     "standard_surface_brass_tiled.mtlx",
-    //'standard_surface_brick_procedural.mtlx',
+    // 'standard_surface_brick_procedural.mtlx',
     "standard_surface_carpaint.mtlx",
-    //'standard_surface_chess_set.mtlx',
+    // 'standard_surface_chess_set.mtlx',
     "standard_surface_chrome.mtlx",
     "standard_surface_copper.mtlx",
-    //'standard_surface_default.mtlx',
-    //'standard_surface_glass.mtlx',
-    //'standard_surface_glass_tinted.mtlx',
+    // 'standard_surface_default.mtlx',
+    // 'standard_surface_glass.mtlx',
+    // 'standard_surface_glass_tinted.mtlx',
     "standard_surface_gold.mtlx",
     "standard_surface_greysphere.mtlx",
-    //'standard_surface_greysphere_calibration.mtlx',
+    // 'standard_surface_greysphere_calibration.mtlx',
     "standard_surface_jade.mtlx",
-    //'standard_surface_look_brass_tiled.mtlx',
-    //'standard_surface_look_wood_tiled.mtlx',
+    // 'standard_surface_look_brass_tiled.mtlx',
+    // 'standard_surface_look_wood_tiled.mtlx',
     "standard_surface_marble_solid.mtlx",
     "standard_surface_metal_brushed.mtlx",
     "standard_surface_plastic.mtlx",
-    //'standard_surface_thin_film.mtlx',
+    // 'standard_surface_thin_film.mtlx',
     "standard_surface_velvet.mtlx",
     "standard_surface_wood_tiled.mtlx",
 ];
 
-let camera, scene, renderer, prefab;
-const models = [];
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, prefab: THREE.Group;
+const models: THREE.Group[] = [];
 
 init();
 
@@ -52,7 +52,7 @@ function init() {
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
     renderer.toneMapping = THREE.LinearToneMapping;
-    renderer.toneMappingExposure = .5;
+    renderer.toneMappingExposure = 0.5;
     renderer.setAnimationLoop(render);
     container.appendChild(renderer.domElement);
 
@@ -64,20 +64,18 @@ function init() {
 
     //
 
-    new RGBELoader()
-        .setPath("textures/equirectangular/")
-        .load("san_giuseppe_bridge_2k.hdr", async (texture) => {
-            texture.mapping = THREE.EquirectangularReflectionMapping;
+    new RGBELoader().setPath("textures/equirectangular/").load("san_giuseppe_bridge_2k.hdr", async texture => {
+        texture.mapping = THREE.EquirectangularReflectionMapping;
 
-            scene.background = texture;
-            scene.environment = texture;
+        scene.background = texture;
+        scene.environment = texture;
 
-            prefab = (await new GLTFLoader().loadAsync("./models/gltf/ShaderBall.glb")).scene;
+        prefab = (await new GLTFLoader().loadAsync("./models/gltf/ShaderBall.glb")).scene;
 
-            for (const sample of samples) {
-                addSample(sample);
-            }
-        });
+        for (const sample of samples) {
+            addSample(sample);
+        }
+    });
 
     window.addEventListener("resize", onWindowResize);
 }
@@ -89,18 +87,18 @@ function updateModelsAlign() {
 
     const lineCount = Math.floor(models.length / COLUMN_COUNT) - 1.5;
 
-    const offsetX = (DIST_X * (COLUMN_COUNT - 1)) * -.5;
-    const offsetY = (DIST_Y * lineCount) * .5;
+    const offsetX = DIST_X * (COLUMN_COUNT - 1) * -0.5;
+    const offsetY = DIST_Y * lineCount * 0.5;
 
     for (let i = 0; i < models.length; i++) {
         const model = models[i];
 
-        model.position.x = ((i % COLUMN_COUNT) * DIST_X) + offsetX;
-        model.position.y = (Math.floor(i / COLUMN_COUNT) * -DIST_Y) + offsetY;
+        model.position.x = (i % COLUMN_COUNT) * DIST_X + offsetX;
+        model.position.y = Math.floor(i / COLUMN_COUNT) * -DIST_Y + offsetY;
     }
 }
 
-async function addSample(sample) {
+async function addSample(sample: string) {
     const model = prefab.clone();
 
     models.push(model);
@@ -111,15 +109,15 @@ async function addSample(sample) {
 
     //
 
-    const material = await new MaterialXLoader()
+    const material = (await new MaterialXLoader()
         .setPath(SAMPLE_PATH)
         .loadAsync(sample)
-        .then(({ materials }) => Object.values(materials).pop());
+        .then(({ materials }) => Object.values(materials).pop()))!;
 
-    const calibrationMesh = model.getObjectByName("Calibration_Mesh");
+    const calibrationMesh = model.getObjectByName("Calibration_Mesh") as THREE.Mesh;
     calibrationMesh.material = material;
 
-    const Preview_Mesh = model.getObjectByName("Preview_Mesh");
+    const Preview_Mesh = model.getObjectByName("Preview_Mesh") as THREE.Mesh;
     Preview_Mesh.material = material;
 }
 
diff --git a/examples-testing/examples/webgl_nodes_materials_instance_uniform.ts b/examples-testing/examples/webgl_nodes_materials_instance_uniform.ts
index c591d22..9b45c20 100644
--- a/examples-testing/examples/webgl_nodes_materials_instance_uniform.ts
+++ b/examples-testing/examples/webgl_nodes_materials_instance_uniform.ts
@@ -1,5 +1,15 @@
 import * as THREE from "three";
-import { cubeTexture, MeshStandardNodeMaterial, Node, nodeObject, NodeUpdateType, uniform } from "three/nodes";
+import {
+    cubeTexture,
+    MeshStandardNodeMaterial,
+    Node,
+    NodeBuilder,
+    NodeFrame,
+    nodeObject,
+    NodeUpdateType,
+    uniform,
+    UniformNode,
+} from "three/nodes";
 
 import Stats from "three/addons/libs/stats.module.js";
 
@@ -8,6 +18,8 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { nodeFrame } from "three/addons/renderers/webgl-legacy/nodes/WebGLNodes.js";
 
 class InstanceUniformNode extends Node {
+    uniformNode: UniformNode<THREE.Color>;
+
     constructor() {
         super("vec3");
 
@@ -16,22 +28,22 @@ class InstanceUniformNode extends Node {
         this.uniformNode = uniform(new THREE.Color());
     }
 
-    update(frame) {
-        this.uniformNode.value.copy(frame.object.color);
+    update(frame: NodeFrame) {
+        this.uniformNode.value.copy((frame.object as THREE.Mesh & { color: THREE.Color }).color);
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null) {
         return this.uniformNode.build(builder, output);
     }
 }
 
-let stats;
+let stats: Stats;
 
-let camera, scene, renderer;
-let controls;
-let pointLight;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controls: OrbitControls;
+let pointLight: THREE.PointLight;
 
-const objects = [];
+const objects: THREE.Mesh[] = [];
 
 init();
 animate();
@@ -126,10 +138,10 @@ function init() {
     window.addEventListener("resize", onWindowResize);
 }
 
-function addMesh(geometry, material) {
+function addMesh(geometry: THREE.SphereGeometry, material: MeshStandardNodeMaterial) {
     const mesh = new THREE.Mesh(geometry, material);
 
-    mesh.color = new THREE.Color(Math.random() * 0xffffff);
+    (mesh as THREE.Mesh & { color?: THREE.Color }).color = new THREE.Color(Math.random() * 0xffffff);
 
     mesh.position.x = (objects.length % 4) * 20 - 30;
     mesh.position.z = Math.floor(objects.length / 4) * 20 - 20;
diff --git a/examples-testing/examples/webgl_nodes_materials_physical_clearcoat.ts b/examples-testing/examples/webgl_nodes_materials_physical_clearcoat.ts
index 55e9073..6e9073a 100644
--- a/examples-testing/examples/webgl_nodes_materials_physical_clearcoat.ts
+++ b/examples-testing/examples/webgl_nodes_materials_physical_clearcoat.ts
@@ -10,12 +10,12 @@ import { HDRCubeTextureLoader } from "three/addons/loaders/HDRCubeTextureLoader.
 
 import { FlakesTexture } from "three/addons/textures/FlakesTexture.js";
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let particleLight;
-let group;
+let particleLight: THREE.Mesh;
+let group: THREE.Group;
 
 init();
 animate();
@@ -34,8 +34,8 @@ function init() {
 
     new HDRCubeTextureLoader()
         .setPath("textures/cube/pisaHDR/")
-        .load(["px.hdr", "nx.hdr", "py.hdr", "ny.hdr", "pz.hdr", "nz.hdr"], function (hdrTexture) {
-            const geometry = new THREE.SphereGeometry(.8, 64, 32);
+        .load(["px.hdr", "nx.hdr", "py.hdr", "ny.hdr", "pz.hdr", "nz.hdr"], function(hdrTexture) {
+            const geometry = new THREE.SphereGeometry(0.8, 64, 32);
 
             const textureLoader = new THREE.TextureLoader();
 
@@ -136,7 +136,7 @@ function init() {
     // LIGHTS
 
     particleLight = new THREE.Mesh(
-        new THREE.SphereGeometry(.05, 8, 8),
+        new THREE.SphereGeometry(0.05, 8, 8),
         new THREE.MeshBasicMaterial({ color: 0xffffff }),
     );
     scene.add(particleLight);
diff --git a/examples-testing/examples/webgl_nodes_materialx_noise.ts b/examples-testing/examples/webgl_nodes_materialx_noise.ts
index 70882ae..6962516 100644
--- a/examples-testing/examples/webgl_nodes_materialx_noise.ts
+++ b/examples-testing/examples/webgl_nodes_materialx_noise.ts
@@ -16,12 +16,12 @@ import Stats from "three/addons/libs/stats.module.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { HDRCubeTextureLoader } from "three/addons/loaders/HDRCubeTextureLoader.js";
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let particleLight;
-let group;
+let particleLight: THREE.Mesh;
+let group: THREE.Group;
 
 init();
 animate();
@@ -40,7 +40,7 @@ function init() {
 
     new HDRCubeTextureLoader()
         .setPath("textures/cube/pisaHDR/")
-        .load(["px.hdr", "nx.hdr", "py.hdr", "ny.hdr", "pz.hdr", "nz.hdr"], function (hdrTexture) {
+        .load(["px.hdr", "nx.hdr", "py.hdr", "ny.hdr", "pz.hdr", "nz.hdr"], function(hdrTexture) {
             const geometry = new THREE.SphereGeometry(8, 64, 32);
 
             const offsetNode = timerLocal();
@@ -79,7 +79,7 @@ function init() {
             // right bottom
 
             material = new MeshPhysicalNodeMaterial();
-            material.colorNode = mx_fractal_noise_vec3(customUV.mul(.2));
+            material.colorNode = mx_fractal_noise_vec3(customUV.mul(0.2));
 
             mesh = new THREE.Mesh(geometry, material);
             mesh.position.x = 10;
diff --git a/examples-testing/examples/webgl_panorama_cube.ts b/examples-testing/examples/webgl_panorama_cube.ts
index 85060ea..416f884 100644
--- a/examples-testing/examples/webgl_panorama_cube.ts
+++ b/examples-testing/examples/webgl_panorama_cube.ts
@@ -2,15 +2,15 @@ import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let camera, controls;
-let renderer;
-let scene;
+let camera: THREE.PerspectiveCamera, controls: OrbitControls;
+let renderer: THREE.WebGLRenderer;
+let scene: THREE.Scene;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     renderer = new THREE.WebGLRenderer();
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -43,29 +43,28 @@ function init() {
     window.addEventListener("resize", onWindowResize);
 }
 
-function getTexturesFromAtlasFile(atlasImgUrl, tilesNum) {
-    const textures = [];
+function getTexturesFromAtlasFile(atlasImgUrl: string, tilesNum: number) {
+    const textures: THREE.Texture[] = [];
 
     for (let i = 0; i < tilesNum; i++) {
         textures[i] = new THREE.Texture();
     }
 
-    new THREE.ImageLoader()
-        .load(atlasImgUrl, (image) => {
-            let canvas, context;
-            const tileWidth = image.height;
-
-            for (let i = 0; i < textures.length; i++) {
-                canvas = document.createElement("canvas");
-                context = canvas.getContext("2d");
-                canvas.height = tileWidth;
-                canvas.width = tileWidth;
-                context.drawImage(image, tileWidth * i, 0, tileWidth, tileWidth, 0, 0, tileWidth, tileWidth);
-                textures[i].colorSpace = THREE.SRGBColorSpace;
-                textures[i].image = canvas;
-                textures[i].needsUpdate = true;
-            }
-        });
+    new THREE.ImageLoader().load(atlasImgUrl, image => {
+        let canvas, context;
+        const tileWidth = image.height;
+
+        for (let i = 0; i < textures.length; i++) {
+            canvas = document.createElement("canvas");
+            context = canvas.getContext("2d")!;
+            canvas.height = tileWidth;
+            canvas.width = tileWidth;
+            context.drawImage(image, tileWidth * i, 0, tileWidth, tileWidth, 0, 0, tileWidth, tileWidth);
+            textures[i].colorSpace = THREE.SRGBColorSpace;
+            textures[i].image = canvas;
+            textures[i].needsUpdate = true;
+        }
+    });
 
     return textures;
 }
diff --git a/examples-testing/examples/webgl_panorama_equirectangular.ts b/examples-testing/examples/webgl_panorama_equirectangular.ts
index ea28818..256fd24 100644
--- a/examples-testing/examples/webgl_panorama_equirectangular.ts
+++ b/examples-testing/examples/webgl_panorama_equirectangular.ts
@@ -1,6 +1,6 @@
 import * as THREE from "three";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let isUserInteracting = false,
     onPointerDownMouseX = 0,
@@ -16,7 +16,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);
 
@@ -46,30 +46,30 @@ function init() {
 
     //
 
-    document.addEventListener("dragover", function (event) {
+    document.addEventListener("dragover", function(event) {
         event.preventDefault();
-        event.dataTransfer.dropEffect = "copy";
+        event.dataTransfer!.dropEffect = "copy";
     });
 
-    document.addEventListener("dragenter", function () {
-        document.body.style.opacity = 0.5;
+    document.addEventListener("dragenter", function() {
+        document.body.style.opacity = "0.5";
     });
 
-    document.addEventListener("dragleave", function () {
-        document.body.style.opacity = 1;
+    document.addEventListener("dragleave", function() {
+        document.body.style.opacity = "1";
     });
 
-    document.addEventListener("drop", function (event) {
+    document.addEventListener("drop", function(event) {
         event.preventDefault();
 
         const reader = new FileReader();
-        reader.addEventListener("load", function (event) {
-            material.map.image.src = event.target.result;
-            material.map.needsUpdate = true;
+        reader.addEventListener("load", function(event) {
+            material.map!.image.src = event.target!.result;
+            material.map!.needsUpdate = true;
         });
-        reader.readAsDataURL(event.dataTransfer.files[0]);
+        reader.readAsDataURL(event.dataTransfer!.files[0]);
 
-        document.body.style.opacity = 1;
+        document.body.style.opacity = "1";
     });
 
     //
@@ -84,7 +84,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     isUserInteracting = true;
@@ -99,14 +99,14 @@ function onPointerDown(event) {
     document.addEventListener("pointerup", onPointerUp);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     lon = (onPointerDownMouseX - event.clientX) * 0.1 + onPointerDownLon;
     lat = (event.clientY - onPointerDownMouseY) * 0.1 + onPointerDownLat;
 }
 
-function onPointerUp() {
+function onPointerUp(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     isUserInteracting = false;
@@ -115,7 +115,7 @@ function onPointerUp() {
     document.removeEventListener("pointerup", onPointerUp);
 }
 
-function onDocumentMouseWheel(event) {
+function onDocumentMouseWheel(event: WheelEvent) {
     const fov = camera.fov + event.deltaY * 0.05;
 
     camera.fov = THREE.MathUtils.clamp(fov, 10, 75);
diff --git a/examples-testing/examples/webgl_pmrem_test.ts b/examples-testing/examples/webgl_pmrem_test.ts
index febfc89..f630db0 100644
--- a/examples-testing/examples/webgl_pmrem_test.ts
+++ b/examples-testing/examples/webgl_pmrem_test.ts
@@ -5,7 +5,7 @@ import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let scene, camera, controls, renderer;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls, renderer: THREE.WebGLRenderer;
 
 function init() {
     const width = window.innerWidth;
@@ -48,8 +48,8 @@ function init() {
     const directionalLight = new THREE.DirectionalLight(0xffffff, 0); // set intensity to 0 to start
     const x = 597;
     const y = 213;
-    const theta = (x + 0.5) * Math.PI / 512;
-    const phi = (y + 0.5) * Math.PI / 512;
+    const theta = ((x + 0.5) * Math.PI) / 512;
+    const phi = ((y + 0.5) * Math.PI) / 512;
 
     directionalLight.position.setFromSphericalCoords(100, -phi, Math.PI / 2 - theta);
 
@@ -64,12 +64,13 @@ function init() {
     const gui = new GUI();
     gui.add({ enabled: true }, "enabled")
         .name("PMREM")
-        .onChange((value) => {
+        .onChange(value => {
             directionalLight.intensity = value ? 0 : 1;
 
-            scene.traverse(function (child) {
-                if (child.isMesh) {
-                    child.material.envMapIntensity = 1 - directionalLight.intensity;
+            scene.traverse(function(child) {
+                if ((child as THREE.Mesh).isMesh) {
+                    ((child as THREE.Mesh).material as THREE.MeshStandardMaterial).envMapIntensity = 1
+                        - directionalLight.intensity;
                 }
             });
 
@@ -82,7 +83,7 @@ function createObjects() {
     new RGBELoader()
         // .setDataType( THREE.FloatType )
         .setPath("textures/equirectangular/")
-        .load("spot1Lux.hdr", function (texture) {
+        .load("spot1Lux.hdr", function(texture) {
             radianceMap = pmremGenerator.fromEquirectangular(texture).texture;
             pmremGenerator.dispose();
 
@@ -128,7 +129,8 @@ function onWindowResize() {
 
 function updateCamera() {
     const horizontalFoV = 40;
-    const verticalFoV = 2 * Math.atan(Math.tan(horizontalFoV / 2 * Math.PI / 180) / camera.aspect) * 180 / Math.PI;
+    const verticalFoV = (2 * Math.atan(Math.tan(((horizontalFoV / 2) * Math.PI) / 180) / camera.aspect) * 180)
+        / Math.PI;
     camera.fov = verticalFoV;
     camera.updateProjectionMatrix();
 }
@@ -137,7 +139,4 @@ function render() {
     renderer.render(scene, camera);
 }
 
-Promise.resolve()
-    .then(init)
-    .then(createObjects)
-    .then(render);
+Promise.resolve().then(init).then(createObjects).then(render);
diff --git a/examples-testing/examples/webgl_points_billboards.ts b/examples-testing/examples/webgl_points_billboards.ts
index 0df46c3..c0c47fc 100644
--- a/examples-testing/examples/webgl_points_billboards.ts
+++ b/examples-testing/examples/webgl_points_billboards.ts
@@ -4,8 +4,13 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let camera, scene, renderer, stats, material;
-let mouseX = 0, mouseY = 0;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    material: THREE.PointsMaterial;
+let mouseX = 0,
+    mouseY = 0;
 
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
@@ -64,7 +69,7 @@ function init() {
 
     const gui = new GUI();
 
-    gui.add(material, "sizeAttenuation").onChange(function () {
+    gui.add(material, "sizeAttenuation").onChange(function() {
         material.needsUpdate = true;
     });
 
@@ -90,7 +95,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
@@ -114,7 +119,7 @@ function render() {
 
     camera.lookAt(scene.position);
 
-    const h = (360 * (1.0 + time) % 360) / 360;
+    const h = ((360 * (1.0 + time)) % 360) / 360;
     material.color.setHSL(h, 0.5, 0.5);
 
     renderer.render(scene, camera);
diff --git a/examples-testing/examples/webgl_points_sprites.ts b/examples-testing/examples/webgl_points_sprites.ts
index fb5a03e..4a10233 100644
--- a/examples-testing/examples/webgl_points_sprites.ts
+++ b/examples-testing/examples/webgl_points_sprites.ts
@@ -4,13 +4,18 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let camera, scene, renderer, stats, parameters;
-let mouseX = 0, mouseY = 0;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    stats: Stats,
+    parameters: [[number, number, number], THREE.Texture, number][];
+let mouseX = 0,
+    mouseY = 0;
 
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
 
-const materials = [];
+const materials: THREE.PointsMaterial[] = [];
 
 init();
 animate();
@@ -27,7 +32,7 @@ function init() {
 
     const textureLoader = new THREE.TextureLoader();
 
-    const assignSRGB = (texture) => {
+    const assignSRGB = (texture: THREE.Texture) => {
         texture.colorSpace = THREE.SRGBColorSpace;
     };
 
@@ -50,9 +55,9 @@ function init() {
     parameters = [
         [[1.0, 0.2, 0.5], sprite2, 20],
         [[0.95, 0.1, 0.5], sprite3, 15],
-        [[0.90, 0.05, 0.5], sprite1, 10],
+        [[0.9, 0.05, 0.5], sprite1, 10],
         [[0.85, 0, 0.5], sprite5, 8],
-        [[0.80, 0, 0.5], sprite4, 5],
+        [[0.8, 0, 0.5], sprite4, 5],
     ];
 
     for (let i = 0; i < parameters.length; i++) {
@@ -98,9 +103,9 @@ function init() {
         texture: true,
     };
 
-    gui.add(params, "texture").onChange(function (value) {
+    gui.add(params, "texture").onChange(function(value) {
         for (let i = 0; i < materials.length; i++) {
-            materials[i].map = (value === true) ? parameters[i][1] : null;
+            materials[i].map = value === true ? parameters[i][1] : null;
             materials[i].needsUpdate = true;
         }
     });
@@ -125,7 +130,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
@@ -160,7 +165,7 @@ function render() {
     for (let i = 0; i < materials.length; i++) {
         const color = parameters[i][0];
 
-        const h = (360 * (color[0] + time) % 360) / 360;
+        const h = ((360 * (color[0] + time)) % 360) / 360;
         materials[i].color.setHSL(h, color[1], color[2], THREE.SRGBColorSpace);
     }
 
diff --git a/examples-testing/examples/webgl_points_waves.ts b/examples-testing/examples/webgl_points_waves.ts
index 83a32a6..40bd6b9 100644
--- a/examples-testing/examples/webgl_points_waves.ts
+++ b/examples-testing/examples/webgl_points_waves.ts
@@ -2,14 +2,18 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-const SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;
+const SEPARATION = 100,
+    AMOUNTX = 50,
+    AMOUNTY = 50;
 
-let container, stats;
-let camera, scene, renderer;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let particles, count = 0;
+let particles: THREE.Points,
+    count = 0;
 
-let mouseX = 0, mouseY = 0;
+let mouseX = 0,
+    mouseY = 0;
 
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
@@ -33,13 +37,14 @@ function init() {
     const positions = new Float32Array(numParticles * 3);
     const scales = new Float32Array(numParticles);
 
-    let i = 0, j = 0;
+    let i = 0,
+        j = 0;
 
     for (let ix = 0; ix < AMOUNTX; ix++) {
         for (let iy = 0; iy < AMOUNTY; iy++) {
-            positions[i] = ix * SEPARATION - ((AMOUNTX * SEPARATION) / 2); // x
+            positions[i] = ix * SEPARATION - (AMOUNTX * SEPARATION) / 2; // x
             positions[i + 1] = 0; // y
-            positions[i + 2] = iy * SEPARATION - ((AMOUNTY * SEPARATION) / 2); // z
+            positions[i + 2] = iy * SEPARATION - (AMOUNTY * SEPARATION) / 2; // z
 
             scales[j] = 1;
 
@@ -56,8 +61,8 @@ function init() {
         uniforms: {
             color: { value: new THREE.Color(0xffffff) },
         },
-        vertexShader: document.getElementById("vertexshader").textContent,
-        fragmentShader: document.getElementById("fragmentshader").textContent,
+        vertexShader: document.getElementById("vertexshader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentshader")!.textContent!,
     });
 
     //
@@ -95,7 +100,7 @@ function onWindowResize() {
 
 //
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (event.isPrimary === false) return;
 
     mouseX = event.clientX - windowHalfX;
@@ -112,22 +117,21 @@ function animate() {
 }
 
 function render() {
-    camera.position.x += (mouseX - camera.position.x) * .05;
-    camera.position.y += (-mouseY - camera.position.y) * .05;
+    camera.position.x += (mouseX - camera.position.x) * 0.05;
+    camera.position.y += (-mouseY - camera.position.y) * 0.05;
     camera.lookAt(scene.position);
 
     const positions = particles.geometry.attributes.position.array;
     const scales = particles.geometry.attributes.scale.array;
 
-    let i = 0, j = 0;
+    let i = 0,
+        j = 0;
 
     for (let ix = 0; ix < AMOUNTX; ix++) {
         for (let iy = 0; iy < AMOUNTY; iy++) {
-            positions[i + 1] = (Math.sin((ix + count) * 0.3) * 50) +
-                (Math.sin((iy + count) * 0.5) * 50);
+            positions[i + 1] = Math.sin((ix + count) * 0.3) * 50 + Math.sin((iy + count) * 0.5) * 50;
 
-            scales[j] = (Math.sin((ix + count) * 0.3) + 1) * 20 +
-                (Math.sin((iy + count) * 0.5) + 1) * 20;
+            scales[j] = (Math.sin((ix + count) * 0.3) + 1) * 20 + (Math.sin((iy + count) * 0.5) + 1) * 20;
 
             i += 3;
             j++;
diff --git a/examples-testing/examples/webgl_portal.ts b/examples-testing/examples/webgl_portal.ts
index 103f35b..5c155b9 100644
--- a/examples-testing/examples/webgl_portal.ts
+++ b/examples-testing/examples/webgl_portal.ts
@@ -1,29 +1,29 @@
 import * as THREE from "three";
 
-import * as CameraUtils from "three/addons/utils/CameraUtils.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import * as CameraUtils from "three/addons/utils/CameraUtils.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let cameraControls;
+let cameraControls: OrbitControls;
 
-let smallSphereOne, smallSphereTwo;
+let smallSphereOne: THREE.Mesh, smallSphereTwo: THREE.Mesh;
 
-let portalCamera,
-    leftPortal,
-    rightPortal,
-    leftPortalTexture,
-    reflectedPosition,
-    rightPortalTexture,
-    bottomLeftCorner,
-    bottomRightCorner,
-    topLeftCorner;
+let portalCamera: THREE.PerspectiveCamera,
+    leftPortal: THREE.Mesh,
+    rightPortal: THREE.Mesh,
+    leftPortalTexture: THREE.WebGLRenderTarget,
+    reflectedPosition: THREE.Vector3,
+    rightPortalTexture: THREE.WebGLRenderTarget,
+    bottomLeftCorner: THREE.Vector3,
+    bottomRightCorner: THREE.Vector3,
+    topLeftCorner: THREE.Vector3;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     // renderer
     renderer = new THREE.WebGLRenderer({ antialias: true });
@@ -68,8 +68,8 @@ function init() {
     // portals
     portalCamera = new THREE.PerspectiveCamera(45, 1.0, 0.1, 500.0);
     scene.add(portalCamera);
-    //frustumHelper = new THREE.CameraHelper( portalCamera );
-    //scene.add( frustumHelper );
+    // frustumHelper = new THREE.CameraHelper( portalCamera );
+    // scene.add( frustumHelper );
     bottomLeftCorner = new THREE.Vector3();
     bottomRightCorner = new THREE.Vector3();
     topLeftCorner = new THREE.Vector3();
@@ -108,7 +108,7 @@ function init() {
     const planeBack = new THREE.Mesh(planeGeo, new THREE.MeshPhongMaterial({ color: 0xff7fff }));
     planeBack.position.z = -50;
     planeBack.position.y = 50;
-    //planeBack.rotateY( Math.PI );
+    // planeBack.rotateY( Math.PI );
     scene.add(planeBack);
 
     const planeRight = new THREE.Mesh(planeGeo, new THREE.MeshPhongMaterial({ color: 0x00ff00 }));
@@ -150,7 +150,11 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function renderPortal(thisPortalMesh, otherPortalMesh, thisPortalTexture) {
+function renderPortal(
+    thisPortalMesh: THREE.Mesh,
+    otherPortalMesh: THREE.Mesh,
+    thisPortalTexture: THREE.WebGLRenderTarget,
+) {
     // set the portal camera position to be reflected about the portal plane
     thisPortalMesh.worldToLocal(reflectedPosition.copy(camera.position));
     reflectedPosition.x *= -1.0;
@@ -188,7 +192,7 @@ function animate() {
         Math.abs(Math.cos(timerOne * 0.2)) * 20 + 5,
         Math.sin(timerOne * 0.1) * 30,
     );
-    smallSphereOne.rotation.y = (Math.PI / 2) - timerOne * 0.1;
+    smallSphereOne.rotation.y = Math.PI / 2 - timerOne * 0.1;
     smallSphereOne.rotation.z = timerOne * 0.8;
 
     smallSphereTwo.position.set(
@@ -196,7 +200,7 @@ function animate() {
         Math.abs(Math.cos(timerTwo * 0.2)) * 20 + 5,
         Math.sin(timerTwo * 0.1) * 30,
     );
-    smallSphereTwo.rotation.y = (Math.PI / 2) - timerTwo * 0.1;
+    smallSphereTwo.rotation.y = Math.PI / 2 - timerTwo * 0.1;
     smallSphereTwo.rotation.z = timerTwo * 0.8;
 
     // save the original camera properties
diff --git a/examples-testing/examples/webgl_postprocessing.ts b/examples-testing/examples/webgl_postprocessing.ts
index 40eeb5e..cc6cf74 100644
--- a/examples-testing/examples/webgl_postprocessing.ts
+++ b/examples-testing/examples/webgl_postprocessing.ts
@@ -4,12 +4,12 @@ import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
 import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
 
-import { RGBShiftShader } from "three/addons/shaders/RGBShiftShader.js";
-import { DotScreenShader } from "three/addons/shaders/DotScreenShader.js";
 import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
+import { DotScreenShader } from "three/addons/shaders/DotScreenShader.js";
+import { RGBShiftShader } from "three/addons/shaders/RGBShiftShader.js";
 
-let camera, renderer, composer;
-let object;
+let camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let object: THREE.Object3D;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_postprocessing_advanced.ts b/examples-testing/examples/webgl_postprocessing_advanced.ts
index 876cb73..1d2f9a6 100644
--- a/examples-testing/examples/webgl_postprocessing_advanced.ts
+++ b/examples-testing/examples/webgl_postprocessing_advanced.ts
@@ -2,30 +2,40 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
-import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
-import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
 import { BloomPass } from "three/addons/postprocessing/BloomPass.js";
-import { FilmPass } from "three/addons/postprocessing/FilmPass.js";
 import { DotScreenPass } from "three/addons/postprocessing/DotScreenPass.js";
+import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
+import { FilmPass } from "three/addons/postprocessing/FilmPass.js";
 import { ClearMaskPass, MaskPass } from "three/addons/postprocessing/MaskPass.js";
+import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
+import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
 import { TexturePass } from "three/addons/postprocessing/TexturePass.js";
 
 import { BleachBypassShader } from "three/addons/shaders/BleachBypassShader.js";
 import { ColorifyShader } from "three/addons/shaders/ColorifyShader.js";
+import { GammaCorrectionShader } from "three/addons/shaders/GammaCorrectionShader.js";
 import { HorizontalBlurShader } from "three/addons/shaders/HorizontalBlurShader.js";
-import { VerticalBlurShader } from "three/addons/shaders/VerticalBlurShader.js";
 import { SepiaShader } from "three/addons/shaders/SepiaShader.js";
+import { VerticalBlurShader } from "three/addons/shaders/VerticalBlurShader.js";
 import { VignetteShader } from "three/addons/shaders/VignetteShader.js";
-import { GammaCorrectionShader } from "three/addons/shaders/GammaCorrectionShader.js";
 
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let composerScene, composer1, composer2, composer3, composer4;
+let composerScene: EffectComposer,
+    composer1: EffectComposer,
+    composer2: EffectComposer,
+    composer3: EffectComposer,
+    composer4: EffectComposer;
 
-let cameraOrtho, cameraPerspective, sceneModel, sceneBG, renderer, mesh, directionalLight;
+let cameraOrtho: THREE.OrthographicCamera,
+    cameraPerspective: THREE.PerspectiveCamera,
+    sceneModel: THREE.Scene,
+    sceneBG: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    mesh: THREE.Mesh,
+    directionalLight: THREE.DirectionalLight;
 
 const width = window.innerWidth || 2;
 const height = window.innerHeight || 2;
@@ -33,7 +43,7 @@ const height = window.innerHeight || 2;
 let halfWidth = width / 2;
 let halfHeight = height / 2;
 
-let quadBG, quadMask, renderScene;
+let quadBG: THREE.Mesh, quadMask: THREE.Mesh, renderScene: TexturePass;
 
 const delta = 0.01;
 
@@ -41,7 +51,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     //
 
@@ -63,8 +73,8 @@ function init() {
     sceneModel.add(directionalLight);
 
     const loader = new GLTFLoader();
-    loader.load("models/gltf/LeePerrySmith/LeePerrySmith.glb", function (gltf) {
-        createMesh(gltf.scene.children[0].geometry, sceneModel, 100);
+    loader.load("models/gltf/LeePerrySmith/LeePerrySmith.glb", function(gltf) {
+        createMesh((gltf.scene.children[0] as THREE.Mesh).geometry, sceneModel, 100);
     });
 
     //
@@ -254,7 +264,7 @@ function onWindowResize() {
     quadMask.scale.set(window.innerWidth / 2, window.innerHeight / 2, 1);
 }
 
-function createMesh(geometry, scene, scale) {
+function createMesh(geometry: THREE.BufferGeometry, scene: THREE.Scene, scale: number) {
     const diffuseMap = new THREE.TextureLoader().load("models/gltf/LeePerrySmith/Map-COL.jpg");
     diffuseMap.colorSpace = THREE.SRGBColorSpace;
 
diff --git a/examples-testing/examples/webgl_postprocessing_afterimage.ts b/examples-testing/examples/webgl_postprocessing_afterimage.ts
index 3e05427..1d35f76 100644
--- a/examples-testing/examples/webgl_postprocessing_afterimage.ts
+++ b/examples-testing/examples/webgl_postprocessing_afterimage.ts
@@ -2,15 +2,15 @@ import * as THREE from "three";
 
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
-import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { AfterimagePass } from "three/addons/postprocessing/AfterimagePass.js";
+import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
 import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
+import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 
-let camera, scene, renderer, composer;
-let mesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let mesh: THREE.Mesh;
 
-let afterimagePass;
+let afterimagePass: AfterimagePass;
 
 const params = {
     enable: true,
@@ -50,7 +50,7 @@ function init() {
 
     window.addEventListener("resize", onWindowResize);
 
-    if (typeof TESTING !== "undefined") {
+    if (typeof (window as any).TESTING !== "undefined") {
         for (let i = 0; i < 45; i++) {
             render();
         }
diff --git a/examples-testing/examples/webgl_postprocessing_backgrounds.ts b/examples-testing/examples/webgl_postprocessing_backgrounds.ts
index e9fdc57..8b1ba06 100644
--- a/examples-testing/examples/webgl_postprocessing_backgrounds.ts
+++ b/examples-testing/examples/webgl_postprocessing_backgrounds.ts
@@ -2,19 +2,19 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
+import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import { ClearPass } from "three/addons/postprocessing/ClearPass.js";
+import { CubeTexturePass } from "three/addons/postprocessing/CubeTexturePass.js";
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
+import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { TexturePass } from "three/addons/postprocessing/TexturePass.js";
-import { CubeTexturePass } from "three/addons/postprocessing/CubeTexturePass.js";
-import { ClearPass } from "three/addons/postprocessing/ClearPass.js";
-import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
-import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let scene, renderer, composer;
-let clearPass, texturePass, renderPass;
-let cameraP, cubeTexturePassP;
-let gui, stats;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let clearPass: ClearPass, texturePass: TexturePass, renderPass: RenderPass;
+let cameraP: THREE.PerspectiveCamera, cubeTexturePassP: CubeTexturePass | null;
+let gui: GUI | undefined, stats: Stats;
 
 const params = {
     clearPass: true,
@@ -56,7 +56,7 @@ function clearGui() {
 }
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     const width = window.innerWidth || 1;
     const height = window.innerHeight || 1;
@@ -111,7 +111,7 @@ function init() {
 
     // postprocessing
 
-    const genCubeUrls = function (prefix, postfix) {
+    const genCubeUrls = function(prefix: string, postfix: string) {
         return [
             prefix + "px" + postfix,
             prefix + "nx" + postfix,
@@ -131,7 +131,7 @@ function init() {
     composer.addPass(texturePass);
 
     const textureLoader = new THREE.TextureLoader();
-    textureLoader.load("textures/hardwood2_diffuse.jpg", function (map) {
+    textureLoader.load("textures/hardwood2_diffuse.jpg", function(map) {
         map.colorSpace = THREE.SRGBColorSpace;
         texturePass.map = map;
     });
@@ -139,7 +139,7 @@ function init() {
     cubeTexturePassP = null;
 
     const ldrUrls = genCubeUrls("textures/cube/pisa/", ".png");
-    new THREE.CubeTextureLoader().load(ldrUrls, function (ldrCubeMap) {
+    new THREE.CubeTextureLoader().load(ldrUrls, function(ldrCubeMap) {
         cubeTexturePassP = new CubeTexturePass(cameraP, ldrCubeMap);
         composer.insertPass(cubeTexturePassP, 2);
     });
diff --git a/examples-testing/examples/webgl_postprocessing_crossfade.ts b/examples-testing/examples/webgl_postprocessing_crossfade.ts
index 5a9690b..d4f9d74 100644
--- a/examples-testing/examples/webgl_postprocessing_crossfade.ts
+++ b/examples-testing/examples/webgl_postprocessing_crossfade.ts
@@ -1,20 +1,20 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 import TWEEN from "three/addons/libs/tween.module.js";
 
-let container, stats;
-let renderer;
-let transition;
+let container: HTMLElement, stats: Stats;
+let renderer: THREE.WebGLRenderer;
+let transition: Transition;
 
 const transitionParams = {
-    "useTexture": true,
-    "transition": 0,
-    "texture": 5,
-    "cycle": true,
-    "animate": true,
-    "threshold": 0.3,
+    useTexture: true,
+    transition: 0,
+    texture: 5,
+    cycle: true,
+    animate: true,
+    threshold: 0.3,
 };
 
 const clock = new THREE.Clock();
@@ -25,7 +25,7 @@ animate();
 function init() {
     initGUI();
 
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     renderer = new THREE.WebGLRenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -56,18 +56,19 @@ function initGUI() {
     gui.add(transitionParams, "animate");
     gui.add(transitionParams, "transition", 0, 1, 0.01).listen();
 
-    gui.add(transitionParams, "useTexture").onChange(function (value) {
+    gui.add(transitionParams, "useTexture").onChange(function(value) {
         transition.useTexture(value);
     });
 
     gui.add(transitionParams, "texture", { Perlin: 0, Squares: 1, Cells: 2, Distort: 3, Gradient: 4, Radial: 5 })
-        .onChange(function (value) {
+        .onChange(function(value) {
             transition.setTexture(value);
-        }).listen();
+        })
+        .listen();
 
     gui.add(transitionParams, "cycle");
 
-    gui.add(transitionParams, "threshold", 0, 1, 0.01).onChange(function (value) {
+    gui.add(transitionParams, "threshold", 0, 1, 0.01).onChange(function(value) {
         transition.setTextureThreshold(value);
     });
 }
@@ -76,7 +77,7 @@ function render() {
     transition.render(clock.getDelta());
 }
 
-function generateInstancedMesh(geometry, material, count) {
+function generateInstancedMesh(geometry: THREE.BufferGeometry, material: THREE.MeshPhongMaterial, count: number) {
     const mesh = new THREE.InstancedMesh(geometry, material, count);
 
     const dummy = new THREE.Object3D();
@@ -110,197 +111,207 @@ function generateInstancedMesh(geometry, material, count) {
     return mesh;
 }
 
-function FXScene(geometry, rotationSpeed, clearColor) {
-    this.clearColor = clearColor;
+class FXScene {
+    clearColor: number;
+    rotationSpeed: THREE.Vector3;
+    fbo: THREE.WebGLRenderTarget;
+    render: (delta: number, rtt: boolean) => void;
 
-    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
-    camera.position.z = 20;
+    constructor(geometry: THREE.BufferGeometry, rotationSpeed: THREE.Vector3, clearColor: number) {
+        this.clearColor = clearColor;
 
-    // Setup scene
-    const scene = new THREE.Scene();
-    scene.add(new THREE.AmbientLight(0xaaaaaa, 3));
+        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
+        camera.position.z = 20;
 
-    const light = new THREE.DirectionalLight(0xffffff, 3);
-    light.position.set(0, 1, 4);
-    scene.add(light);
+        // Setup scene
+        const scene = new THREE.Scene();
+        scene.add(new THREE.AmbientLight(0xaaaaaa, 3));
 
-    this.rotationSpeed = rotationSpeed;
+        const light = new THREE.DirectionalLight(0xffffff, 3);
+        light.position.set(0, 1, 4);
+        scene.add(light);
 
-    const color = geometry.type === "BoxGeometry" ? 0x0000ff : 0xff0000;
-    const material = new THREE.MeshPhongMaterial({ color: color, flatShading: true });
-    const mesh = generateInstancedMesh(geometry, material, 500);
-    scene.add(mesh);
+        this.rotationSpeed = rotationSpeed;
 
-    this.fbo = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { type: THREE.HalfFloatType });
+        const color = geometry.type === "BoxGeometry" ? 0x0000ff : 0xff0000;
+        const material = new THREE.MeshPhongMaterial({ color: color, flatShading: true });
+        const mesh = generateInstancedMesh(geometry, material, 500);
+        scene.add(mesh);
 
-    this.render = function (delta, rtt) {
-        mesh.rotation.x += delta * this.rotationSpeed.x;
-        mesh.rotation.y += delta * this.rotationSpeed.y;
-        mesh.rotation.z += delta * this.rotationSpeed.z;
+        this.fbo = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { type: THREE.HalfFloatType });
 
-        renderer.setClearColor(this.clearColor);
+        this.render = function(delta, rtt) {
+            mesh.rotation.x += delta * this.rotationSpeed.x;
+            mesh.rotation.y += delta * this.rotationSpeed.y;
+            mesh.rotation.z += delta * this.rotationSpeed.z;
 
-        if (rtt) {
-            renderer.setRenderTarget(this.fbo);
-            renderer.clear();
-            renderer.render(scene, camera);
-        } else {
-            renderer.setRenderTarget(null);
-            renderer.render(scene, camera);
-        }
-    };
+            renderer.setClearColor(this.clearColor);
+
+            if (rtt) {
+                renderer.setRenderTarget(this.fbo);
+                renderer.clear();
+                renderer.render(scene, camera);
+            } else {
+                renderer.setRenderTarget(null);
+                renderer.render(scene, camera);
+            }
+        };
+    }
 }
 
-function Transition(sceneA, sceneB) {
-    const scene = new THREE.Scene();
+class Transition {
+    needsTextureChange: boolean;
+    setTextureThreshold: (value: number) => void;
+    useTexture: (value: boolean) => void;
+    setTexture: (value: number) => void;
+    render: (delta: number) => void;
 
-    const width = window.innerWidth;
-    const height = window.innerHeight;
+    constructor(sceneA: FXScene, sceneB: FXScene) {
+        const scene = new THREE.Scene();
 
-    const camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, -10, 10);
+        const width = window.innerWidth;
+        const height = window.innerHeight;
 
-    const textures = [];
+        const camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, -10, 10);
 
-    const loader = new THREE.TextureLoader();
+        const textures: THREE.Texture[] = [];
 
-    for (let i = 0; i < 6; i++) {
-        textures[i] = loader.load("textures/transition/transition" + (i + 1) + ".png");
-    }
+        const loader = new THREE.TextureLoader();
 
-    const material = new THREE.ShaderMaterial({
-        uniforms: {
-            tDiffuse1: {
-                value: null,
-            },
-            tDiffuse2: {
-                value: null,
-            },
-            mixRatio: {
-                value: 0.0,
-            },
-            threshold: {
-                value: 0.1,
-            },
-            useTexture: {
-                value: 1,
-            },
-            tMixTexture: {
-                value: textures[0],
+        for (let i = 0; i < 6; i++) {
+            textures[i] = loader.load("textures/transition/transition" + (i + 1) + ".png");
+        }
+
+        const material = new THREE.ShaderMaterial({
+            uniforms: {
+                tDiffuse1: {
+                    value: null,
+                },
+                tDiffuse2: {
+                    value: null,
+                },
+                mixRatio: {
+                    value: 0.0,
+                },
+                threshold: {
+                    value: 0.1,
+                },
+                useTexture: {
+                    value: 1,
+                },
+                tMixTexture: {
+                    value: textures[0],
+                },
             },
-        },
-        vertexShader: [
-            "varying vec2 vUv;",
+            vertexShader: [
+                "varying vec2 vUv;",
 
-            "void main() {",
+                "void main() {",
 
-            "vUv = vec2( uv.x, uv.y );",
-            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
+                "vUv = vec2( uv.x, uv.y );",
+                "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
 
-            "}",
-        ].join("\n"),
-        fragmentShader: [
-            "uniform float mixRatio;",
+                "}",
+            ].join("\n"),
+            fragmentShader: [
+                "uniform float mixRatio;",
 
-            "uniform sampler2D tDiffuse1;",
-            "uniform sampler2D tDiffuse2;",
-            "uniform sampler2D tMixTexture;",
+                "uniform sampler2D tDiffuse1;",
+                "uniform sampler2D tDiffuse2;",
+                "uniform sampler2D tMixTexture;",
 
-            "uniform int useTexture;",
-            "uniform float threshold;",
+                "uniform int useTexture;",
+                "uniform float threshold;",
 
-            "varying vec2 vUv;",
+                "varying vec2 vUv;",
 
-            "void main() {",
+                "void main() {",
 
-            "	vec4 texel1 = texture2D( tDiffuse1, vUv );",
-            "	vec4 texel2 = texture2D( tDiffuse2, vUv );",
+                "	vec4 texel1 = texture2D( tDiffuse1, vUv );",
+                "	vec4 texel2 = texture2D( tDiffuse2, vUv );",
 
-            "	if (useTexture==1) {",
+                "	if (useTexture==1) {",
 
-            "		vec4 transitionTexel = texture2D( tMixTexture, vUv );",
-            "		float r = mixRatio * (1.0 + threshold * 2.0) - threshold;",
-            "		float mixf=clamp((transitionTexel.r - r)*(1.0/threshold), 0.0, 1.0);",
+                "		vec4 transitionTexel = texture2D( tMixTexture, vUv );",
+                "		float r = mixRatio * (1.0 + threshold * 2.0) - threshold;",
+                "		float mixf=clamp((transitionTexel.r - r)*(1.0/threshold), 0.0, 1.0);",
 
-            "		gl_FragColor = mix( texel1, texel2, mixf );",
+                "		gl_FragColor = mix( texel1, texel2, mixf );",
 
-            "	} else {",
+                "	} else {",
 
-            "		gl_FragColor = mix( texel2, texel1, mixRatio );",
+                "		gl_FragColor = mix( texel2, texel1, mixRatio );",
 
-            "	}",
+                "	}",
 
-            "	#include <tonemapping_fragment>",
-            "	#include <colorspace_fragment>",
+                "	#include <tonemapping_fragment>",
+                "	#include <colorspace_fragment>",
 
-            "}",
-        ].join("\n"),
-    });
+                "}",
+            ].join("\n"),
+        });
+
+        const geometry = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
+        const mesh = new THREE.Mesh(geometry, material);
+        scene.add(mesh);
+
+        material.uniforms.tDiffuse1.value = sceneA.fbo.texture;
+        material.uniforms.tDiffuse2.value = sceneB.fbo.texture;
+
+        new TWEEN.Tween(transitionParams).to({ transition: 1 }, 1500).repeat(Infinity).delay(2000).yoyo(true).start();
+
+        this.needsTextureChange = false;
+
+        this.setTextureThreshold = function(value) {
+            material.uniforms.threshold.value = value;
+        };
+
+        this.useTexture = function(value) {
+            material.uniforms.useTexture.value = value ? 1 : 0;
+        };
+
+        this.setTexture = function(i) {
+            material.uniforms.tMixTexture.value = textures[i];
+        };
 
-    const geometry = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
-    const mesh = new THREE.Mesh(geometry, material);
-    scene.add(mesh);
-
-    material.uniforms.tDiffuse1.value = sceneA.fbo.texture;
-    material.uniforms.tDiffuse2.value = sceneB.fbo.texture;
-
-    new TWEEN.Tween(transitionParams)
-        .to({ transition: 1 }, 1500)
-        .repeat(Infinity)
-        .delay(2000)
-        .yoyo(true)
-        .start();
-
-    this.needsTextureChange = false;
-
-    this.setTextureThreshold = function (value) {
-        material.uniforms.threshold.value = value;
-    };
-
-    this.useTexture = function (value) {
-        material.uniforms.useTexture.value = value ? 1 : 0;
-    };
-
-    this.setTexture = function (i) {
-        material.uniforms.tMixTexture.value = textures[i];
-    };
-
-    this.render = function (delta) {
-        // Transition animation
-        if (transitionParams.animate) {
-            TWEEN.update();
-
-            // Change the current alpha texture after each transition
-            if (transitionParams.cycle) {
-                if (transitionParams.transition == 0 || transitionParams.transition == 1) {
-                    if (this.needsTextureChange) {
-                        transitionParams.texture = (transitionParams.texture + 1) % textures.length;
-                        material.uniforms.tMixTexture.value = textures[transitionParams.texture];
-                        this.needsTextureChange = false;
+        this.render = function(delta) {
+            // Transition animation
+            if (transitionParams.animate) {
+                TWEEN.update();
+
+                // Change the current alpha texture after each transition
+                if (transitionParams.cycle) {
+                    if (transitionParams.transition == 0 || transitionParams.transition == 1) {
+                        if (this.needsTextureChange) {
+                            transitionParams.texture = (transitionParams.texture + 1) % textures.length;
+                            material.uniforms.tMixTexture.value = textures[transitionParams.texture];
+                            this.needsTextureChange = false;
+                        }
+                    } else {
+                        this.needsTextureChange = true;
                     }
                 } else {
                     this.needsTextureChange = true;
                 }
-            } else {
-                this.needsTextureChange = true;
             }
-        }
 
-        material.uniforms.mixRatio.value = transitionParams.transition;
+            material.uniforms.mixRatio.value = transitionParams.transition;
 
-        // Prevent render both scenes when it's not necessary
-        if (transitionParams.transition == 0) {
-            sceneB.render(delta, false);
-        } else if (transitionParams.transition == 1) {
-            sceneA.render(delta, false);
-        } else {
-            // When 0<transition<1 render transition between two scenes
+            // Prevent render both scenes when it's not necessary
+            if (transitionParams.transition == 0) {
+                sceneB.render(delta, false);
+            } else if (transitionParams.transition == 1) {
+                sceneA.render(delta, false);
+            } else {
+                // When 0<transition<1 render transition between two scenes
 
-            sceneA.render(delta, true);
-            sceneB.render(delta, true);
+                sceneA.render(delta, true);
+                sceneB.render(delta, true);
 
-            renderer.setRenderTarget(null);
-            renderer.clear();
-            renderer.render(scene, camera);
-        }
-    };
+                renderer.setRenderTarget(null);
+                renderer.clear();
+                renderer.render(scene, camera);
+            }
+        };
+    }
 }
diff --git a/examples-testing/examples/webgl_postprocessing_fxaa.ts b/examples-testing/examples/webgl_postprocessing_fxaa.ts
index b0e8bba..65de4fc 100644
--- a/examples-testing/examples/webgl_postprocessing_fxaa.ts
+++ b/examples-testing/examples/webgl_postprocessing_fxaa.ts
@@ -1,20 +1,25 @@
 import * as THREE from "three";
 
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
+import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
-import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 import { FXAAShader } from "three/addons/shaders/FXAAShader.js";
 
-let camera, scene, renderer, clock, group, container;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    group: THREE.Group,
+    container: HTMLElement;
 
-let composer1, composer2, fxaaPass;
+let composer1: EffectComposer, composer2: EffectComposer, fxaaPass: ShaderPass;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 1, 2000);
     camera.position.z = 500;
diff --git a/examples-testing/examples/webgl_postprocessing_glitch.ts b/examples-testing/examples/webgl_postprocessing_glitch.ts
index 4c78410..ea8f55a 100644
--- a/examples-testing/examples/webgl_postprocessing_glitch.ts
+++ b/examples-testing/examples/webgl_postprocessing_glitch.ts
@@ -1,18 +1,18 @@
 import * as THREE from "three";
 
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
-import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { GlitchPass } from "three/addons/postprocessing/GlitchPass.js";
 import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
+import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 
-let camera, scene, renderer, composer;
-let object, light;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let object: THREE.Object3D, light: THREE.DirectionalLight;
 
-let glitchPass;
+let glitchPass: GlitchPass;
 
-const button = document.querySelector("#startButton");
-button.addEventListener("click", function () {
-    const overlay = document.getElementById("overlay");
+const button = document.querySelector("#startButton")!;
+button.addEventListener("click", function() {
+    const overlay = document.getElementById("overlay")!;
     overlay.remove();
 
     init();
@@ -20,7 +20,7 @@ button.addEventListener("click", function () {
 });
 
 function updateOptions() {
-    const wildGlitch = document.getElementById("wildGlitch");
+    const wildGlitch = document.getElementById("wildGlitch") as HTMLInputElement;
     glitchPass.goWild = wildGlitch.checked;
 }
 
@@ -75,7 +75,7 @@ function init() {
 
     window.addEventListener("resize", onWindowResize);
 
-    const wildGlitchOption = document.getElementById("wildGlitch");
+    const wildGlitchOption = document.getElementById("wildGlitch")!;
     wildGlitchOption.addEventListener("change", updateOptions);
 
     updateOptions();
diff --git a/examples-testing/examples/webgl_postprocessing_godrays.ts b/examples-testing/examples/webgl_postprocessing_godrays.ts
index 2323fdb..71e3787 100644
--- a/examples-testing/examples/webgl_postprocessing_godrays.ts
+++ b/examples-testing/examples/webgl_postprocessing_godrays.ts
@@ -2,8 +2,8 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
 import {
     GodRaysCombineShader,
     GodRaysDepthMaskShader,
@@ -11,16 +11,37 @@ import {
     GodRaysGenerateShader,
 } from "three/addons/shaders/GodRaysShader.js";
 
-let container, stats;
-let camera, scene, renderer, materialDepth;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    materialDepth: THREE.MeshDepthMaterial;
 
-let sphereMesh;
+let sphereMesh: THREE.Mesh;
 
 const sunPosition = new THREE.Vector3(0, 1000, -1000);
 const clipPosition = new THREE.Vector4();
 const screenSpacePosition = new THREE.Vector3();
 
-const postprocessing = { enabled: true };
+const postprocessing: {
+    enabled: boolean;
+    scene?: THREE.Scene;
+    camera?: THREE.OrthographicCamera;
+    rtTextureColors?: THREE.WebGLRenderTarget;
+    rtTextureDepth?: THREE.WebGLRenderTarget;
+    rtTextureDepthMask?: THREE.WebGLRenderTarget;
+    rtTextureGodRays1?: THREE.WebGLRenderTarget;
+    rtTextureGodRays2?: THREE.WebGLRenderTarget;
+    godrayMaskUniforms?: (typeof GodRaysDepthMaskShader)["uniforms"];
+    materialGodraysDepthMask?: THREE.ShaderMaterial;
+    godrayGenUniforms?: (typeof GodRaysGenerateShader)["uniforms"];
+    materialGodraysGenerate?: THREE.ShaderMaterial;
+    godrayCombineUniforms?: (typeof GodRaysCombineShader)["uniforms"];
+    materialGodraysCombine?: THREE.ShaderMaterial;
+    godraysFakeSunUniforms?: (typeof GodRaysFakeSunShader)["uniforms"];
+    materialGodraysFakeSun?: THREE.ShaderMaterial;
+    quad?: THREE.Mesh;
+} = { enabled: true };
 
 const orbitRadius = 200;
 
@@ -51,7 +72,7 @@ function init() {
     // tree
 
     const loader = new OBJLoader();
-    loader.load("models/obj/tree.obj", function (object) {
+    loader.load("models/obj/tree.obj", function(object) {
         object.position.set(0, -150, -150);
         object.scale.multiplyScalar(400);
         scene.add(object);
@@ -102,17 +123,17 @@ function onWindowResize() {
     camera.updateProjectionMatrix();
 
     renderer.setSize(renderTargetWidth, renderTargetHeight);
-    postprocessing.rtTextureColors.setSize(renderTargetWidth, renderTargetHeight);
-    postprocessing.rtTextureDepth.setSize(renderTargetWidth, renderTargetHeight);
-    postprocessing.rtTextureDepthMask.setSize(renderTargetWidth, renderTargetHeight);
+    postprocessing.rtTextureColors!.setSize(renderTargetWidth, renderTargetHeight);
+    postprocessing.rtTextureDepth!.setSize(renderTargetWidth, renderTargetHeight);
+    postprocessing.rtTextureDepthMask!.setSize(renderTargetWidth, renderTargetHeight);
 
     const adjustedWidth = renderTargetWidth * godrayRenderTargetResolutionMultiplier;
     const adjustedHeight = renderTargetHeight * godrayRenderTargetResolutionMultiplier;
-    postprocessing.rtTextureGodRays1.setSize(adjustedWidth, adjustedHeight);
-    postprocessing.rtTextureGodRays2.setSize(adjustedWidth, adjustedHeight);
+    postprocessing.rtTextureGodRays1!.setSize(adjustedWidth, adjustedHeight);
+    postprocessing.rtTextureGodRays2!.setSize(adjustedWidth, adjustedHeight);
 }
 
-function initPostprocessing(renderTargetWidth, renderTargetHeight) {
+function initPostprocessing(renderTargetWidth: number, renderTargetHeight: number) {
     postprocessing.scene = new THREE.Scene();
 
     postprocessing.camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);
@@ -183,15 +204,12 @@ function initPostprocessing(renderTargetWidth, renderTargetHeight) {
         fragmentShader: godraysFakeSunShader.fragmentShader,
     });
 
-    postprocessing.godraysFakeSunUniforms.bgColor.value.setHex(bgColor);
-    postprocessing.godraysFakeSunUniforms.sunColor.value.setHex(sunColor);
+    postprocessing.godraysFakeSunUniforms!.bgColor.value.setHex(bgColor);
+    postprocessing.godraysFakeSunUniforms!.sunColor.value.setHex(sunColor);
 
-    postprocessing.godrayCombineUniforms.fGodRayIntensity.value = 0.75;
+    postprocessing.godrayCombineUniforms!.fGodRayIntensity.value = 0.75;
 
-    postprocessing.quad = new THREE.Mesh(
-        new THREE.PlaneGeometry(1.0, 1.0),
-        postprocessing.materialGodraysGenerate,
-    );
+    postprocessing.quad = new THREE.Mesh(new THREE.PlaneGeometry(1.0, 1.0), postprocessing.materialGodraysGenerate);
     postprocessing.quad.position.z = -9900;
     postprocessing.scene.add(postprocessing.quad);
 }
@@ -204,19 +222,19 @@ function animate() {
     stats.end();
 }
 
-function getStepSize(filterLen, tapsPerPass, pass) {
+function getStepSize(filterLen: number, tapsPerPass: number, pass: number) {
     return filterLen * Math.pow(tapsPerPass, -pass);
 }
 
-function filterGodRays(inputTex, renderTarget, stepSize) {
-    postprocessing.scene.overrideMaterial = postprocessing.materialGodraysGenerate;
+function filterGodRays(inputTex: THREE.Texture, renderTarget: THREE.WebGLRenderTarget, stepSize: number) {
+    postprocessing.scene!.overrideMaterial = postprocessing.materialGodraysGenerate!;
 
-    postprocessing.godrayGenUniforms["fStepSize"].value = stepSize;
-    postprocessing.godrayGenUniforms["tInput"].value = inputTex;
+    postprocessing.godrayGenUniforms!["fStepSize"].value = stepSize;
+    postprocessing.godrayGenUniforms!["tInput"].value = inputTex;
 
     renderer.setRenderTarget(renderTarget);
-    renderer.render(postprocessing.scene, postprocessing.camera);
-    postprocessing.scene.overrideMaterial = null;
+    renderer.render(postprocessing.scene!, postprocessing.camera!);
+    postprocessing.scene!.overrideMaterial = null;
 }
 
 function render() {
@@ -244,14 +262,14 @@ function render() {
 
         // Give it to the god-ray and sun shaders
 
-        postprocessing.godrayGenUniforms["vSunPositionScreenSpace"].value.copy(screenSpacePosition);
-        postprocessing.godraysFakeSunUniforms["vSunPositionScreenSpace"].value.copy(screenSpacePosition);
+        postprocessing.godrayGenUniforms!["vSunPositionScreenSpace"].value.copy(screenSpacePosition);
+        postprocessing.godraysFakeSunUniforms!["vSunPositionScreenSpace"].value.copy(screenSpacePosition);
 
         // -- Draw sky and sun --
 
         // Clear colors and depths, will clear to sky color
 
-        renderer.setRenderTarget(postprocessing.rtTextureColors);
+        renderer.setRenderTarget(postprocessing.rtTextureColors!);
         renderer.clear(true, true, false);
 
         // Sun render. Runs a shader that gives a brightness based on the screen
@@ -267,11 +285,11 @@ function render() {
         renderer.setScissor(screenSpacePosition.x - sunsqW / 2, screenSpacePosition.y - sunsqH / 2, sunsqW, sunsqH);
         renderer.setScissorTest(true);
 
-        postprocessing.godraysFakeSunUniforms["fAspect"].value = window.innerWidth / window.innerHeight;
+        postprocessing.godraysFakeSunUniforms!["fAspect"].value = window.innerWidth / window.innerHeight;
 
-        postprocessing.scene.overrideMaterial = postprocessing.materialGodraysFakeSun;
-        renderer.setRenderTarget(postprocessing.rtTextureColors);
-        renderer.render(postprocessing.scene, postprocessing.camera);
+        postprocessing.scene!.overrideMaterial = postprocessing.materialGodraysFakeSun!;
+        renderer.setRenderTarget(postprocessing.rtTextureColors!);
+        renderer.render(postprocessing.scene!, postprocessing.camera!);
 
         renderer.setScissorTest(false);
 
@@ -280,23 +298,23 @@ function render() {
         // Colors
 
         scene.overrideMaterial = null;
-        renderer.setRenderTarget(postprocessing.rtTextureColors);
+        renderer.setRenderTarget(postprocessing.rtTextureColors!);
         renderer.render(scene, camera);
 
         // Depth
 
         scene.overrideMaterial = materialDepth;
-        renderer.setRenderTarget(postprocessing.rtTextureDepth);
+        renderer.setRenderTarget(postprocessing.rtTextureDepth!);
         renderer.clear();
         renderer.render(scene, camera);
 
         //
 
-        postprocessing.godrayMaskUniforms["tInput"].value = postprocessing.rtTextureDepth.texture;
+        postprocessing.godrayMaskUniforms!["tInput"].value = postprocessing.rtTextureDepth!.texture;
 
-        postprocessing.scene.overrideMaterial = postprocessing.materialGodraysDepthMask;
-        renderer.setRenderTarget(postprocessing.rtTextureDepthMask);
-        renderer.render(postprocessing.scene, postprocessing.camera);
+        postprocessing.scene!.overrideMaterial = postprocessing.materialGodraysDepthMask!;
+        renderer.setRenderTarget(postprocessing.rtTextureDepthMask!);
+        renderer.render(postprocessing.scene!, postprocessing.camera!);
 
         // -- Render god-rays --
 
@@ -315,35 +333,35 @@ function render() {
 
         // pass 1 - render into first ping-pong target
         filterGodRays(
-            postprocessing.rtTextureDepthMask.texture,
-            postprocessing.rtTextureGodRays2,
+            postprocessing.rtTextureDepthMask!.texture,
+            postprocessing.rtTextureGodRays2!,
             getStepSize(filterLen, TAPS_PER_PASS, 1.0),
         );
 
         // pass 2 - render into second ping-pong target
         filterGodRays(
-            postprocessing.rtTextureGodRays2.texture,
-            postprocessing.rtTextureGodRays1,
+            postprocessing.rtTextureGodRays2!.texture,
+            postprocessing.rtTextureGodRays1!,
             getStepSize(filterLen, TAPS_PER_PASS, 2.0),
         );
 
         // pass 3 - 1st RT
         filterGodRays(
-            postprocessing.rtTextureGodRays1.texture,
-            postprocessing.rtTextureGodRays2,
+            postprocessing.rtTextureGodRays1!.texture,
+            postprocessing.rtTextureGodRays2!,
             getStepSize(filterLen, TAPS_PER_PASS, 3.0),
         );
 
         // final pass - composite god-rays onto colors
 
-        postprocessing.godrayCombineUniforms["tColors"].value = postprocessing.rtTextureColors.texture;
-        postprocessing.godrayCombineUniforms["tGodRays"].value = postprocessing.rtTextureGodRays2.texture;
+        postprocessing.godrayCombineUniforms!["tColors"].value = postprocessing.rtTextureColors!.texture;
+        postprocessing.godrayCombineUniforms!["tGodRays"].value = postprocessing.rtTextureGodRays2!.texture;
 
-        postprocessing.scene.overrideMaterial = postprocessing.materialGodraysCombine;
+        postprocessing.scene!.overrideMaterial = postprocessing.materialGodraysCombine!;
 
         renderer.setRenderTarget(null);
-        renderer.render(postprocessing.scene, postprocessing.camera);
-        postprocessing.scene.overrideMaterial = null;
+        renderer.render(postprocessing.scene!, postprocessing.camera!);
+        postprocessing.scene!.overrideMaterial = null;
     } else {
         renderer.setRenderTarget(null);
         renderer.clear();
diff --git a/examples-testing/examples/webgl_postprocessing_gtao.ts b/examples-testing/examples/webgl_postprocessing_gtao.ts
index e94988f..a11b0f1 100644
--- a/examples-testing/examples/webgl_postprocessing_gtao.ts
+++ b/examples-testing/examples/webgl_postprocessing_gtao.ts
@@ -1,16 +1,23 @@
 import * as THREE from "three";
-import Stats from "three/addons/libs/stats.module.js";
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
-import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
+import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
-import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { GTAOPass } from "three/addons/postprocessing/GTAOPass.js";
 import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
+import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 
-let camera, scene, renderer, composer, controls, clock, stats, mixer;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    composer: EffectComposer,
+    controls: OrbitControls,
+    clock: THREE.Clock,
+    stats: Stats,
+    mixer: THREE.AnimationMixer;
 
 init();
 animate();
@@ -68,7 +75,7 @@ function init() {
 
     loader.load(
         "LittlestTokyo.glb",
-        (gltf) => {
+        gltf => {
             const model = gltf.scene;
             model.position.set(1, 1, 0);
             model.scale.set(0.01, 0.01, 0.01);
@@ -81,74 +88,110 @@ function init() {
             gtaoPass.setSceneClipBox(box);
         },
         undefined,
-        (e) => console.error(e),
+        e => console.error(e),
     );
 
     // Init gui
     const gui = new GUI();
 
     gui.add(gtaoPass, "output", {
-        "Default": GTAOPass.OUTPUT.Default,
-        "Diffuse": GTAOPass.OUTPUT.Diffuse,
+        Default: GTAOPass.OUTPUT.Default,
+        Diffuse: GTAOPass.OUTPUT.Diffuse,
         "AO Only": GTAOPass.OUTPUT.AO,
         "AO Only + Denoise": GTAOPass.OUTPUT.Denoise,
-        "Depth": GTAOPass.OUTPUT.Depth,
-        "Normal": GTAOPass.OUTPUT.Normal,
-    }).onChange(function (value) {
+        Depth: GTAOPass.OUTPUT.Depth,
+        Normal: GTAOPass.OUTPUT.Normal,
+    }).onChange(function(value) {
         gtaoPass.output = value;
     });
 
     const aoParameters = {
         radius: 0.25,
-        distanceExponent: 1.,
-        thickness: 1.,
-        scale: 1.,
+        distanceExponent: 1,
+        thickness: 1,
+        scale: 1,
         samples: 16,
-        distanceFallOff: 1.,
+        distanceFallOff: 1,
         screenSpaceRadius: false,
     };
     const pdParameters = {
-        lumaPhi: 10.,
-        depthPhi: 2.,
-        normalPhi: 3.,
-        radius: 4.,
-        radiusExponent: 1.,
-        rings: 2.,
+        lumaPhi: 10,
+        depthPhi: 2,
+        normalPhi: 3,
+        radius: 4,
+        radiusExponent: 1,
+        rings: 2,
         samples: 16,
     };
     gtaoPass.updateGtaoMaterial(aoParameters);
     gtaoPass.updatePdMaterial(pdParameters);
     gui.add(gtaoPass, "blendIntensity").min(0).max(1).step(0.01);
-    gui.add(aoParameters, "radius").min(0.01).max(1).step(0.01).onChange(() =>
-        gtaoPass.updateGtaoMaterial(aoParameters)
-    );
-    gui.add(aoParameters, "distanceExponent").min(1).max(4).step(0.01).onChange(() =>
-        gtaoPass.updateGtaoMaterial(aoParameters)
-    );
-    gui.add(aoParameters, "thickness").min(0.01).max(10).step(0.01).onChange(() =>
-        gtaoPass.updateGtaoMaterial(aoParameters)
-    );
-    gui.add(aoParameters, "distanceFallOff").min(0).max(1).step(0.01).onChange(() =>
-        gtaoPass.updateGtaoMaterial(aoParameters)
-    );
-    gui.add(aoParameters, "scale").min(0.01).max(2.0).step(0.01).onChange(() =>
-        gtaoPass.updateGtaoMaterial(aoParameters)
-    );
-    gui.add(aoParameters, "samples").min(2).max(32).step(1).onChange(() => gtaoPass.updateGtaoMaterial(aoParameters));
+    gui.add(aoParameters, "radius")
+        .min(0.01)
+        .max(1)
+        .step(0.01)
+        .onChange(() => gtaoPass.updateGtaoMaterial(aoParameters));
+    gui.add(aoParameters, "distanceExponent")
+        .min(1)
+        .max(4)
+        .step(0.01)
+        .onChange(() => gtaoPass.updateGtaoMaterial(aoParameters));
+    gui.add(aoParameters, "thickness")
+        .min(0.01)
+        .max(10)
+        .step(0.01)
+        .onChange(() => gtaoPass.updateGtaoMaterial(aoParameters));
+    gui.add(aoParameters, "distanceFallOff")
+        .min(0)
+        .max(1)
+        .step(0.01)
+        .onChange(() => gtaoPass.updateGtaoMaterial(aoParameters));
+    gui.add(aoParameters, "scale")
+        .min(0.01)
+        .max(2.0)
+        .step(0.01)
+        .onChange(() => gtaoPass.updateGtaoMaterial(aoParameters));
+    gui.add(aoParameters, "samples")
+        .min(2)
+        .max(32)
+        .step(1)
+        .onChange(() => gtaoPass.updateGtaoMaterial(aoParameters));
     gui.add(aoParameters, "screenSpaceRadius").onChange(() => gtaoPass.updateGtaoMaterial(aoParameters));
-    gui.add(pdParameters, "lumaPhi").min(0).max(20).step(0.01).onChange(() => gtaoPass.updatePdMaterial(pdParameters));
-    gui.add(pdParameters, "depthPhi").min(0.01).max(20).step(0.01).onChange(() =>
-        gtaoPass.updatePdMaterial(pdParameters)
-    );
-    gui.add(pdParameters, "normalPhi").min(0.01).max(20).step(0.01).onChange(() =>
-        gtaoPass.updatePdMaterial(pdParameters)
-    );
-    gui.add(pdParameters, "radius").min(0).max(32).step(1).onChange(() => gtaoPass.updatePdMaterial(pdParameters));
-    gui.add(pdParameters, "radiusExponent").min(0.1).max(4.).step(0.1).onChange(() =>
-        gtaoPass.updatePdMaterial(pdParameters)
-    );
-    gui.add(pdParameters, "rings").min(1).max(16).step(0.125).onChange(() => gtaoPass.updatePdMaterial(pdParameters));
-    gui.add(pdParameters, "samples").min(2).max(32).step(1).onChange(() => gtaoPass.updatePdMaterial(pdParameters));
+    gui.add(pdParameters, "lumaPhi")
+        .min(0)
+        .max(20)
+        .step(0.01)
+        .onChange(() => gtaoPass.updatePdMaterial(pdParameters));
+    gui.add(pdParameters, "depthPhi")
+        .min(0.01)
+        .max(20)
+        .step(0.01)
+        .onChange(() => gtaoPass.updatePdMaterial(pdParameters));
+    gui.add(pdParameters, "normalPhi")
+        .min(0.01)
+        .max(20)
+        .step(0.01)
+        .onChange(() => gtaoPass.updatePdMaterial(pdParameters));
+    gui.add(pdParameters, "radius")
+        .min(0)
+        .max(32)
+        .step(1)
+        .onChange(() => gtaoPass.updatePdMaterial(pdParameters));
+    gui.add(pdParameters, "radiusExponent")
+        .min(0.1)
+        .max(4)
+        .step(0.1)
+        .onChange(() => gtaoPass.updatePdMaterial(pdParameters));
+    gui.add(pdParameters, "rings")
+        .min(1)
+        .max(16)
+        .step(0.125)
+        .onChange(() => gtaoPass.updatePdMaterial(pdParameters));
+    gui.add(pdParameters, "samples")
+        .min(2)
+        .max(32)
+        .step(1)
+        .onChange(() => gtaoPass.updatePdMaterial(pdParameters));
 
     window.addEventListener("resize", onWindowResize);
 }
diff --git a/examples-testing/examples/webgl_postprocessing_masking.ts b/examples-testing/examples/webgl_postprocessing_masking.ts
index 7bda97a..a2eb195 100644
--- a/examples-testing/examples/webgl_postprocessing_masking.ts
+++ b/examples-testing/examples/webgl_postprocessing_masking.ts
@@ -1,13 +1,13 @@
 import * as THREE from "three";
 
-import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
-import { TexturePass } from "three/addons/postprocessing/TexturePass.js";
 import { ClearPass } from "three/addons/postprocessing/ClearPass.js";
+import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
 import { ClearMaskPass, MaskPass } from "three/addons/postprocessing/MaskPass.js";
 import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
+import { TexturePass } from "three/addons/postprocessing/TexturePass.js";
 
-let camera, composer, renderer;
-let box, torus;
+let camera: THREE.PerspectiveCamera, composer: EffectComposer, renderer: THREE.WebGLRenderer;
+let box: THREE.Mesh, torus: THREE.Mesh;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_postprocessing_material_ao.ts b/examples-testing/examples/webgl_postprocessing_material_ao.ts
index 453ba00..55e3313 100644
--- a/examples-testing/examples/webgl_postprocessing_material_ao.ts
+++ b/examples-testing/examples/webgl_postprocessing_material_ao.ts
@@ -1,16 +1,21 @@
 import * as THREE from "three";
-import Stats from "three/addons/libs/stats.module.js";
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 import { PLYLoader } from "three/addons/loaders/PLYLoader.js";
+import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
+import { MeshPostProcessingMaterial } from "three/addons/materials/MeshPostProcessingMaterial.js";
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
-import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { GTAOPass } from "three/addons/postprocessing/GTAOPass.js";
 import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
-import { MeshPostProcessingMaterial } from "three/addons/materials/MeshPostProcessingMaterial.js";
+import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 
-let renderer, camera, scene, composer, controls, stats;
+let renderer: THREE.WebGLRenderer,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    composer: EffectComposer,
+    controls: OrbitControls,
+    stats: Stats;
 const sceneParameters = {
     output: 0,
     envMapIntensity: 1.0,
@@ -20,11 +25,11 @@ const sceneParameters = {
 };
 const aoParameters = {
     radius: 0.5,
-    distanceExponent: 2.,
-    thickness: 10.,
-    scale: 1.,
+    distanceExponent: 2,
+    thickness: 10,
+    scale: 1,
     samples: 16,
-    distanceFallOff: 1.,
+    distanceFallOff: 1,
 };
 
 init();
@@ -68,7 +73,7 @@ function init() {
     composer.addPass(renderPasse);
     composer.addPass(outputPass);
 
-    rgbeloader.load("textures/equirectangular/royal_esplanade_1k.hdr", function (texture) {
+    rgbeloader.load("textures/equirectangular/royal_esplanade_1k.hdr", function(texture) {
         texture.mapping = THREE.EquirectangularReflectionMapping;
         scene.environment = texture;
     });
@@ -90,7 +95,7 @@ function init() {
         emissive: 0xffffff,
         aoPassMap: gtaoPass.gtaoMap,
     });
-    plyLoader.load("models/ply/binary/Lucy100k.ply", (geometry) => {
+    plyLoader.load("models/ply/binary/Lucy100k.ply", geometry => {
         geometry.computeVertexNormals();
         const lucy = new THREE.Mesh(geometry, objectMaterial);
         lucy.receiveShadow = true;
@@ -117,7 +122,7 @@ function init() {
         const light = new THREE.SpotLight(lightColors[j], sceneParameters.lightIntensity, 0, Math.PI / 9);
         light.castShadow = true;
         light.shadow.camera.far = 15;
-        light.position.set(5 * Math.cos(Math.PI * j * 2 / 3), 2.5, 5 * Math.sin(Math.PI * j * 2 / 3));
+        light.position.set(5 * Math.cos((Math.PI * j * 2) / 3), 2.5, 5 * Math.sin((Math.PI * j * 2) / 3));
         light.target = targetObject;
         lightGroup.add(light);
     }
@@ -136,21 +141,21 @@ function init() {
     sphereMesh.receiveShadow = true;
     sphereMesh.castShadow = true;
     scene.add(sphereMesh);
-    [...Array(6).keys()].forEach((i) =>
+    [...Array(6).keys()].forEach(i =>
         sphereMesh.setMatrixAt(
             i,
-            new THREE.Matrix4().makeTranslation(Math.cos(Math.PI * i / 3), 0.5, Math.sin(Math.PI * i / 3)),
+            new THREE.Matrix4().makeTranslation(Math.cos((Math.PI * i) / 3), 0.5, Math.sin((Math.PI * i) / 3)),
         )
     );
     const lightSphereMesh = new THREE.InstancedMesh(lightSphereGeometry, emissiveMaterial, 4);
     scene.add(lightSphereMesh);
-    [...Array(4).keys()].forEach((i) =>
+    [...Array(4).keys()].forEach(i =>
         lightSphereMesh.setMatrixAt(
             i,
             new THREE.Matrix4().makeTranslation(
-                0.4 * Math.cos(Math.PI * (i + 0.5) / 2),
+                0.4 * Math.cos((Math.PI * (i + 0.5)) / 2),
                 1.1,
-                0.45 * Math.sin(Math.PI * (i + 0.5) / 2),
+                0.45 * Math.sin((Math.PI * (i + 0.5)) / 2),
             ),
         )
     );
@@ -198,26 +203,62 @@ function init() {
         "only diffuse": 2,
         "only AO": 3,
     }).onChange(() => updateOutput());
-    gui.add(sceneParameters, "envMapIntensity").min(0).max(1).step(0.01).onChange(() => {
-        groundMaterial.envMapIntensity = sceneParameters.envMapIntensity;
-        objectMaterial.envMapIntensity = sceneParameters.envMapIntensity;
-    });
-    gui.add(sceneParameters, "ambientLightIntensity").min(0.0).max(1.0).step(0.01).onChange(() => {
-        ambientLight.intensity = sceneParameters.ambientLightIntensity;
-    });
-    gui.add(sceneParameters, "lightIntensity").min(0).max(100).step(1).onChange(() => {
-        lightGroup.children.forEach((light) => light.intensity = sceneParameters.lightIntensity);
-    });
-    gui.add(sceneParameters, "shadow").onChange((value) => {
+    gui.add(sceneParameters, "envMapIntensity")
+        .min(0)
+        .max(1)
+        .step(0.01)
+        .onChange(() => {
+            groundMaterial.envMapIntensity = sceneParameters.envMapIntensity;
+            objectMaterial.envMapIntensity = sceneParameters.envMapIntensity;
+        });
+    gui.add(sceneParameters, "ambientLightIntensity")
+        .min(0.0)
+        .max(1.0)
+        .step(0.01)
+        .onChange(() => {
+            ambientLight.intensity = sceneParameters.ambientLightIntensity;
+        });
+    gui.add(sceneParameters, "lightIntensity")
+        .min(0)
+        .max(100)
+        .step(1)
+        .onChange(() => {
+            lightGroup.children.forEach(light => ((light as THREE.Light).intensity = sceneParameters.lightIntensity));
+        });
+    gui.add(sceneParameters, "shadow").onChange(value => {
         renderer.shadowMap.enabled = value;
-        lightGroup.children.forEach((light) => light.castShadow = value);
+        lightGroup.children.forEach(light => (light.castShadow = value));
     });
-    gui.add(aoParameters, "radius").min(0.01).max(2).step(0.01).onChange(() => updateGtaoMaterial());
-    gui.add(aoParameters, "distanceExponent").min(1).max(4).step(0.01).onChange(() => updateGtaoMaterial());
-    gui.add(aoParameters, "thickness").min(0.01).max(10).step(0.01).onChange(() => updateGtaoMaterial());
-    gui.add(aoParameters, "distanceFallOff").min(0).max(1).step(0.01).onChange(() => updateGtaoMaterial());
-    gui.add(aoParameters, "scale").min(0.01).max(2.0).step(0.01).onChange(() => updateGtaoMaterial());
-    gui.add(aoParameters, "samples").min(2).max(32).step(1).onChange(() => updateGtaoMaterial());
+    gui.add(aoParameters, "radius")
+        .min(0.01)
+        .max(2)
+        .step(0.01)
+        .onChange(() => updateGtaoMaterial());
+    gui.add(aoParameters, "distanceExponent")
+        .min(1)
+        .max(4)
+        .step(0.01)
+        .onChange(() => updateGtaoMaterial());
+    gui.add(aoParameters, "thickness")
+        .min(0.01)
+        .max(10)
+        .step(0.01)
+        .onChange(() => updateGtaoMaterial());
+    gui.add(aoParameters, "distanceFallOff")
+        .min(0)
+        .max(1)
+        .step(0.01)
+        .onChange(() => updateGtaoMaterial());
+    gui.add(aoParameters, "scale")
+        .min(0.01)
+        .max(2.0)
+        .step(0.01)
+        .onChange(() => updateGtaoMaterial());
+    gui.add(aoParameters, "samples")
+        .min(2)
+        .max(32)
+        .step(1)
+        .onChange(() => updateGtaoMaterial());
 
     window.addEventListener("resize", onWindowResize);
 }
diff --git a/examples-testing/examples/webgl_postprocessing_outline.ts b/examples-testing/examples/webgl_postprocessing_outline.ts
index 0e9ab15..001eeef 100644
--- a/examples-testing/examples/webgl_postprocessing_outline.ts
+++ b/examples-testing/examples/webgl_postprocessing_outline.ts
@@ -1,22 +1,22 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
-import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
-import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
 import { OutlinePass } from "three/addons/postprocessing/OutlinePass.js";
 import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
+import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
+import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
 import { FXAAShader } from "three/addons/shaders/FXAAShader.js";
 
-let container, stats;
-let camera, scene, renderer, controls;
-let composer, effectFXAA, outlinePass;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
+let composer: EffectComposer, effectFXAA: ShaderPass, outlinePass: OutlinePass;
 
-let selectedObjects = [];
+let selectedObjects: THREE.Object3D[] = [];
 
 const raycaster = new THREE.Raycaster();
 const mouse = new THREE.Vector2();
@@ -37,40 +37,45 @@ const params = {
 
 const gui = new GUI({ width: 280 });
 
-gui.add(params, "edgeStrength", 0.01, 10).onChange(function (value) {
+gui.add(params, "edgeStrength", 0.01, 10).onChange(function(value) {
     outlinePass.edgeStrength = Number(value);
 });
 
-gui.add(params, "edgeGlow", 0.0, 1).onChange(function (value) {
+gui.add(params, "edgeGlow", 0.0, 1).onChange(function(value) {
     outlinePass.edgeGlow = Number(value);
 });
 
-gui.add(params, "edgeThickness", 1, 4).onChange(function (value) {
+gui.add(params, "edgeThickness", 1, 4).onChange(function(value) {
     outlinePass.edgeThickness = Number(value);
 });
 
-gui.add(params, "pulsePeriod", 0.0, 5).onChange(function (value) {
+gui.add(params, "pulsePeriod", 0.0, 5).onChange(function(value) {
     outlinePass.pulsePeriod = Number(value);
 });
 
 gui.add(params, "rotate");
 
-gui.add(params, "usePatternTexture").onChange(function (value) {
+gui.add(params, "usePatternTexture").onChange(function(value) {
     outlinePass.usePatternTexture = value;
 });
 
-function Configuration() {
-    this.visibleEdgeColor = "#ffffff";
-    this.hiddenEdgeColor = "#190a05";
+class Configuration {
+    visibleEdgeColor: string;
+    hiddenEdgeColor: string;
+
+    constructor() {
+        this.visibleEdgeColor = "#ffffff";
+        this.hiddenEdgeColor = "#190a05";
+    }
 }
 
 const conf = new Configuration();
 
-gui.addColor(conf, "visibleEdgeColor").onChange(function (value) {
+gui.addColor(conf, "visibleEdgeColor").onChange(function(value) {
     outlinePass.visibleEdgeColor.set(value);
 });
 
-gui.addColor(conf, "hiddenEdgeColor").onChange(function (value) {
+gui.addColor(conf, "hiddenEdgeColor").onChange(function(value) {
     outlinePass.hiddenEdgeColor.set(value);
 });
 
@@ -125,10 +130,10 @@ function init() {
     // model
 
     const loader = new OBJLoader();
-    loader.load("models/obj/tree.obj", function (object) {
+    loader.load("models/obj/tree.obj", function(object) {
         let scale = 1.0;
 
-        object.traverse(function (child) {
+        object.traverse(function(child) {
             if (child instanceof THREE.Mesh) {
                 child.geometry.center();
                 child.geometry.computeBoundingSphere();
@@ -205,7 +210,7 @@ function init() {
     composer.addPass(outlinePass);
 
     const textureLoader = new THREE.TextureLoader();
-    textureLoader.load("textures/tri_pattern.jpg", function (texture) {
+    textureLoader.load("textures/tri_pattern.jpg", function(texture) {
         outlinePass.patternTexture = texture;
         texture.wrapS = THREE.RepeatWrapping;
         texture.wrapT = THREE.RepeatWrapping;
@@ -223,7 +228,7 @@ function init() {
     renderer.domElement.style.touchAction = "none";
     renderer.domElement.addEventListener("pointermove", onPointerMove);
 
-    function onPointerMove(event) {
+    function onPointerMove(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
         mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
@@ -232,7 +237,7 @@ function init() {
         checkIntersection();
     }
 
-    function addSelectedObject(object) {
+    function addSelectedObject(object: THREE.Object3D) {
         selectedObjects = [];
         selectedObjects.push(object);
     }
diff --git a/examples-testing/examples/webgl_postprocessing_pixel.ts b/examples-testing/examples/webgl_postprocessing_pixel.ts
index 2b01ccf..15090ce 100644
--- a/examples-testing/examples/webgl_postprocessing_pixel.ts
+++ b/examples-testing/examples/webgl_postprocessing_pixel.ts
@@ -1,13 +1,19 @@
 import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
-import { RenderPixelatedPass } from "three/addons/postprocessing/RenderPixelatedPass.js";
 import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import { RenderPixelatedPass } from "three/addons/postprocessing/RenderPixelatedPass.js";
 
-let camera, scene, renderer, composer, crystalMesh, clock;
-let gui, params;
+let camera: THREE.OrthographicCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    composer: EffectComposer,
+    crystalMesh: THREE.Mesh<THREE.IcosahedronGeometry, THREE.MeshPhongMaterial>,
+    clock: THREE.Clock;
+let gui: GUI,
+    params: { pixelSize: number; normalEdgeStrength: number; depthEdgeStrength: number; pixelAlignedPanning: boolean };
 
 init();
 animate();
@@ -26,7 +32,7 @@ function init() {
 
     renderer = new THREE.WebGLRenderer();
     renderer.shadowMap.enabled = true;
-    //renderer.setPixelRatio( window.devicePixelRatio );
+    // renderer.setPixelRatio( window.devicePixelRatio );
     renderer.setSize(window.innerWidth, window.innerHeight);
     document.body.appendChild(renderer.domElement);
 
@@ -45,13 +51,22 @@ function init() {
     // gui
 
     gui = new GUI();
-    params = { pixelSize: 6, normalEdgeStrength: .3, depthEdgeStrength: .4, pixelAlignedPanning: true };
-    gui.add(params, "pixelSize").min(1).max(16).step(1)
+    params = { pixelSize: 6, normalEdgeStrength: 0.3, depthEdgeStrength: 0.4, pixelAlignedPanning: true };
+    gui.add(params, "pixelSize")
+        .min(1)
+        .max(16)
+        .step(1)
         .onChange(() => {
             renderPixelatedPass.setPixelSize(params.pixelSize);
         });
-    gui.add(renderPixelatedPass, "normalEdgeStrength").min(0).max(2).step(.05);
-    gui.add(renderPixelatedPass, "depthEdgeStrength").min(0).max(1).step(.05);
+    gui.add(renderPixelatedPass as { normalEdgeStrength: number }, "normalEdgeStrength")
+        .min(0)
+        .max(2)
+        .step(0.05);
+    gui.add(renderPixelatedPass as { depthEdgeStrength: number }, "depthEdgeStrength")
+        .min(0)
+        .max(1)
+        .step(0.05);
     gui.add(params, "pixelAlignedPanning");
 
     // textures
@@ -66,19 +81,19 @@ function init() {
 
     const boxMaterial = new THREE.MeshPhongMaterial({ map: texChecker2 });
 
-    function addBox(boxSideLength, x, z, rotation) {
+    function addBox(boxSideLength: number, x: number, z: number, rotation: number) {
         const mesh = new THREE.Mesh(new THREE.BoxGeometry(boxSideLength, boxSideLength, boxSideLength), boxMaterial);
         mesh.castShadow = true;
         mesh.receiveShadow = true;
         mesh.rotation.y = rotation;
         mesh.position.y = boxSideLength / 2;
-        mesh.position.set(x, boxSideLength / 2 + .0001, z);
+        mesh.position.set(x, boxSideLength / 2 + 0.0001, z);
         scene.add(mesh);
         return mesh;
     }
 
-    addBox(.4, 0, 0, Math.PI / 4);
-    addBox(.5, -.5, -.5, Math.PI / 4);
+    addBox(0.4, 0, 0, Math.PI / 4);
+    addBox(0.5, -0.5, -0.5, Math.PI / 4);
 
     const planeSideLength = 2;
     const planeMesh = new THREE.Mesh(
@@ -89,7 +104,7 @@ function init() {
     planeMesh.rotation.x = -Math.PI / 2;
     scene.add(planeMesh);
 
-    const radius = .2;
+    const radius = 0.2;
     const geometry = new THREE.IcosahedronGeometry(radius);
     crystalMesh = new THREE.Mesh(
         geometry,
@@ -114,7 +129,7 @@ function init() {
     directionalLight.shadow.mapSize.set(2048, 2048);
     scene.add(directionalLight);
 
-    const spotLight = new THREE.SpotLight(0xffc100, 10, 10, Math.PI / 16, .02, 2);
+    const spotLight = new THREE.SpotLight(0xffc100, 10, 10, Math.PI / 16, 0.02, 2);
     spotLight.position.set(2, 2, 0);
     const target = spotLight.target;
     scene.add(target);
@@ -138,8 +153,8 @@ function animate() {
 
     const t = clock.getElapsedTime();
 
-    crystalMesh.material.emissiveIntensity = Math.sin(t * 3) * .5 + .5;
-    crystalMesh.position.y = .7 + Math.sin(t * 2) * .05;
+    crystalMesh.material.emissiveIntensity = Math.sin(t * 3) * 0.5 + 0.5;
+    crystalMesh.position.y = 0.7 + Math.sin(t * 2) * 0.05;
     crystalMesh.rotation.y = stopGoEased(t, 2, 4) * 2 * Math.PI;
 
     const rendererSize = renderer.getSize(new THREE.Vector2());
@@ -165,7 +180,7 @@ function animate() {
 
 // Helper functions
 
-function pixelTexture(texture) {
+function pixelTexture(texture: THREE.Texture) {
     texture.minFilter = THREE.NearestFilter;
     texture.magFilter = THREE.NearestFilter;
     texture.generateMipmaps = false;
@@ -175,25 +190,30 @@ function pixelTexture(texture) {
     return texture;
 }
 
-function easeInOutCubic(x) {
+function easeInOutCubic(x: number) {
     return x ** 2 * 3 - x ** 3 * 2;
 }
 
-function linearStep(x, edge0, edge1) {
+function linearStep(x: number, edge0: number, edge1: number) {
     const w = edge1 - edge0;
     const m = 1 / w;
     const y0 = -m * edge0;
     return THREE.MathUtils.clamp(y0 + m * x, 0, 1);
 }
 
-function stopGoEased(x, downtime, period) {
+function stopGoEased(x: number, downtime: number, period: number) {
     const cycle = (x / period) | 0;
     const tween = x - cycle * period;
     const linStep = easeInOutCubic(linearStep(tween, downtime, period));
     return cycle + linStep;
 }
 
-function pixelAlignFrustum(camera, aspectRatio, pixelsPerScreenWidth, pixelsPerScreenHeight) {
+function pixelAlignFrustum(
+    camera: THREE.OrthographicCamera,
+    aspectRatio: number,
+    pixelsPerScreenWidth: number,
+    pixelsPerScreenHeight: number,
+) {
     // 0. Get Pixel Grid Units
     const worldScreenWidth = (camera.right - camera.left) / camera.zoom;
     const worldScreenHeight = (camera.top - camera.bottom) / camera.zoom;
@@ -219,9 +239,9 @@ function pixelAlignFrustum(camera, aspectRatio, pixelsPerScreenWidth, pixelsPerS
     const fractY = camPosUpPx - Math.round(camPosUpPx);
 
     // 4. Add fractional world units to the left/right top/bottom to align with the pixel grid
-    camera.left = -aspectRatio - (fractX * pixelWidth);
-    camera.right = aspectRatio - (fractX * pixelWidth);
-    camera.top = 1.0 - (fractY * pixelHeight);
-    camera.bottom = -1.0 - (fractY * pixelHeight);
+    camera.left = -aspectRatio - fractX * pixelWidth;
+    camera.right = aspectRatio - fractX * pixelWidth;
+    camera.top = 1.0 - fractY * pixelHeight;
+    camera.bottom = -1.0 - fractY * pixelHeight;
     camera.updateProjectionMatrix();
 }
diff --git a/examples-testing/examples/webgl_postprocessing_procedural.ts b/examples-testing/examples/webgl_postprocessing_procedural.ts
index d5edde7..234225f 100644
--- a/examples-testing/examples/webgl_postprocessing_procedural.ts
+++ b/examples-testing/examples/webgl_postprocessing_procedural.ts
@@ -1,11 +1,15 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
-let postCamera, postScene, renderer;
-let postMaterial, noiseRandom1DMaterial, noiseRandom2DMaterial, noiseRandom3DMaterial, postQuad;
-let stats;
+let postCamera: THREE.OrthographicCamera, postScene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let postMaterial: THREE.ShaderMaterial,
+    noiseRandom1DMaterial: THREE.ShaderMaterial,
+    noiseRandom2DMaterial: THREE.ShaderMaterial,
+    noiseRandom3DMaterial: THREE.ShaderMaterial,
+    postQuad: THREE.Mesh;
+let stats: Stats;
 
 const params = { procedure: "noiseRandom3D" };
 
@@ -20,7 +24,7 @@ function initGui() {
 }
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     renderer = new THREE.WebGLRenderer();
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -33,16 +37,16 @@ function init() {
     // Setup post processing stage
     postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
     noiseRandom1DMaterial = new THREE.ShaderMaterial({
-        vertexShader: document.querySelector("#procedural-vert").textContent.trim(),
-        fragmentShader: document.querySelector("#noiseRandom1D-frag").textContent.trim(),
+        vertexShader: document.querySelector("#procedural-vert")!.textContent!.trim(),
+        fragmentShader: document.querySelector("#noiseRandom1D-frag")!.textContent!.trim(),
     });
     noiseRandom2DMaterial = new THREE.ShaderMaterial({
-        vertexShader: document.querySelector("#procedural-vert").textContent.trim(),
-        fragmentShader: document.querySelector("#noiseRandom2D-frag").textContent.trim(),
+        vertexShader: document.querySelector("#procedural-vert")!.textContent!.trim(),
+        fragmentShader: document.querySelector("#noiseRandom2D-frag")!.textContent!.trim(),
     });
     noiseRandom3DMaterial = new THREE.ShaderMaterial({
-        vertexShader: document.querySelector("#procedural-vert").textContent.trim(),
-        fragmentShader: document.querySelector("#noiseRandom3D-frag").textContent.trim(),
+        vertexShader: document.querySelector("#procedural-vert")!.textContent!.trim(),
+        fragmentShader: document.querySelector("#noiseRandom3D-frag")!.textContent!.trim(),
     });
     postMaterial = noiseRandom3DMaterial;
     const postPlane = new THREE.PlaneGeometry(2, 2);
diff --git a/examples-testing/examples/webgl_postprocessing_rgb_halftone.ts b/examples-testing/examples/webgl_postprocessing_rgb_halftone.ts
index 2c6ba9b..eb244a0 100644
--- a/examples-testing/examples/webgl_postprocessing_rgb_halftone.ts
+++ b/examples-testing/examples/webgl_postprocessing_rgb_halftone.ts
@@ -1,18 +1,18 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
-import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { HalftonePass } from "three/addons/postprocessing/HalftonePass.js";
+import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 
-let renderer, clock, camera, stats;
+let renderer: THREE.WebGLRenderer, clock: THREE.Clock, camera: THREE.PerspectiveCamera, stats: Stats;
 
 const rotationSpeed = Math.PI / 64;
 
-let composer, group;
+let composer: EffectComposer, group: THREE.Group;
 
 init();
 animate();
@@ -95,8 +95,8 @@ function init() {
         shape: 1,
         radius: 4,
         rotateR: Math.PI / 12,
-        rotateB: Math.PI / 12 * 2,
-        rotateG: Math.PI / 12 * 3,
+        rotateB: (Math.PI / 12) * 2,
+        rotateG: (Math.PI / 12) * 3,
         scatter: 0,
         blending: 1,
         blendingMode: 1,
@@ -107,7 +107,7 @@ function init() {
     composer.addPass(renderPass);
     composer.addPass(halftonePass);
 
-    window.onresize = function () {
+    window.onresize = function() {
         // resize composer
         renderer.setSize(window.innerWidth, window.innerHeight);
         composer.setSize(window.innerWidth, window.innerHeight);
@@ -145,7 +145,7 @@ function init() {
     }
 
     const gui = new GUI();
-    gui.add(controller, "shape", { "Dot": 1, "Ellipse": 2, "Line": 3, "Square": 4 }).onChange(onGUIChange);
+    gui.add(controller, "shape", { Dot: 1, Ellipse: 2, Line: 3, Square: 4 }).onChange(onGUIChange);
     gui.add(controller, "radius", 1, 25).onChange(onGUIChange);
     gui.add(controller, "rotateR", 0, 90).onChange(onGUIChange);
     gui.add(controller, "rotateG", 0, 90).onChange(onGUIChange);
@@ -153,7 +153,7 @@ function init() {
     gui.add(controller, "scatter", 0, 1, 0.01).onChange(onGUIChange);
     gui.add(controller, "greyscale").onChange(onGUIChange);
     gui.add(controller, "blending", 0, 1, 0.01).onChange(onGUIChange);
-    gui.add(controller, "blendingMode", { "Linear": 1, "Multiply": 2, "Add": 3, "Lighter": 4, "Darker": 5 }).onChange(
+    gui.add(controller, "blendingMode", { Linear: 1, Multiply: 2, Add: 3, Lighter: 4, Darker: 5 }).onChange(
         onGUIChange,
     );
     gui.add(controller, "disable").onChange(onGUIChange);
diff --git a/examples-testing/examples/webgl_postprocessing_sao.ts b/examples-testing/examples/webgl_postprocessing_sao.ts
index cbb50f5..68f9ab7 100644
--- a/examples-testing/examples/webgl_postprocessing_sao.ts
+++ b/examples-testing/examples/webgl_postprocessing_sao.ts
@@ -1,17 +1,17 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
+import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { SAOPass } from "three/addons/postprocessing/SAOPass.js";
-import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 
-let container, stats;
-let camera, scene, renderer;
-let composer, renderPass, saoPass;
-let group;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let composer: EffectComposer, renderPass: RenderPass, saoPass: SAOPass;
+let group: THREE.Object3D;
 
 init();
 animate();
@@ -91,10 +91,10 @@ function init() {
     // Init gui
     const gui = new GUI();
     gui.add(saoPass.params, "output", {
-        "Default": SAOPass.OUTPUT.Default,
+        Default: SAOPass.OUTPUT.Default,
         "SAO Only": SAOPass.OUTPUT.SAO,
-        "Normal": SAOPass.OUTPUT.Normal,
-    }).onChange(function (value) {
+        Normal: SAOPass.OUTPUT.Normal,
+    }).onChange(function(value) {
         saoPass.params.output = value;
     });
     gui.add(saoPass.params, "saoBias", -1, 1);
diff --git a/examples-testing/examples/webgl_postprocessing_smaa.ts b/examples-testing/examples/webgl_postprocessing_smaa.ts
index c18dd72..50ee1f3 100644
--- a/examples-testing/examples/webgl_postprocessing_smaa.ts
+++ b/examples-testing/examples/webgl_postprocessing_smaa.ts
@@ -1,14 +1,19 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
+import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { SMAAPass } from "three/addons/postprocessing/SMAAPass.js";
-import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 
-let camera, scene, renderer, composer, stats, smaaPass;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    composer: EffectComposer,
+    stats: Stats,
+    smaaPass: SMAAPass;
 
 const params = {
     enabled: true,
@@ -19,7 +24,7 @@ init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     renderer = new THREE.WebGLRenderer();
     renderer.setPixelRatio(window.devicePixelRatio);
diff --git a/examples-testing/examples/webgl_postprocessing_sobel.ts b/examples-testing/examples/webgl_postprocessing_sobel.ts
index 6572822..ab205a8 100644
--- a/examples-testing/examples/webgl_postprocessing_sobel.ts
+++ b/examples-testing/examples/webgl_postprocessing_sobel.ts
@@ -11,9 +11,9 @@ import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
 import { LuminosityShader } from "three/addons/shaders/LuminosityShader.js";
 import { SobelOperatorShader } from "three/addons/shaders/SobelOperatorShader.js";
 
-let camera, scene, renderer, composer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
 
-let effectSobel;
+let effectSobel: ShaderPass;
 
 const params = {
     enable: true,
diff --git a/examples-testing/examples/webgl_postprocessing_ssaa.ts b/examples-testing/examples/webgl_postprocessing_ssaa.ts
index 34a9756..ea8d572 100644
--- a/examples-testing/examples/webgl_postprocessing_ssaa.ts
+++ b/examples-testing/examples/webgl_postprocessing_ssaa.ts
@@ -1,16 +1,16 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
-import { SSAARenderPass } from "three/addons/postprocessing/SSAARenderPass.js";
 import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
+import { SSAARenderPass } from "three/addons/postprocessing/SSAARenderPass.js";
 
-let scene, renderer, composer;
-let cameraP, ssaaRenderPassP;
-let cameraO, ssaaRenderPassO;
-let gui, stats;
+let scene: THREE.Scene, renderer: THREE.WebGLRenderer, composer: EffectComposer;
+let cameraP: THREE.PerspectiveCamera, ssaaRenderPassP: SSAARenderPass;
+let cameraO: THREE.OrthographicCamera, ssaaRenderPassO: SSAARenderPass;
+let gui: GUI, stats: Stats;
 
 const params = {
     sampleLevel: 4,
@@ -51,7 +51,7 @@ function clearGui() {
 }
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     const width = window.innerWidth || 1;
     const height = window.innerHeight || 1;
@@ -200,7 +200,7 @@ function animate() {
     ssaaRenderPassP.enabled = params.camera === "perspective";
     ssaaRenderPassO.enabled = params.camera === "orthographic";
 
-    cameraP.view.offsetX = params.viewOffsetX;
+    cameraP.view!.offsetX = params.viewOffsetX;
 
     composer.render();
 
diff --git a/examples-testing/examples/webgl_postprocessing_ssao.ts b/examples-testing/examples/webgl_postprocessing_ssao.ts
index 784e5c2..4588a97 100644
--- a/examples-testing/examples/webgl_postprocessing_ssao.ts
+++ b/examples-testing/examples/webgl_postprocessing_ssao.ts
@@ -1,17 +1,17 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
+import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { SSAOPass } from "three/addons/postprocessing/SSAOPass.js";
-import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 
-let container, stats;
-let camera, scene, renderer;
-let composer;
-let group;
+let container: HTMLDivElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let composer: EffectComposer;
+let group: THREE.Group;
 
 init();
 animate();
@@ -76,12 +76,12 @@ function init() {
     const gui = new GUI();
 
     gui.add(ssaoPass, "output", {
-        "Default": SSAOPass.OUTPUT.Default,
+        Default: SSAOPass.OUTPUT.Default,
         "SSAO Only": SSAOPass.OUTPUT.SSAO,
         "SSAO Only + Blur": SSAOPass.OUTPUT.Blur,
-        "Depth": SSAOPass.OUTPUT.Depth,
-        "Normal": SSAOPass.OUTPUT.Normal,
-    }).onChange(function (value) {
+        Depth: SSAOPass.OUTPUT.Depth,
+        Normal: SSAOPass.OUTPUT.Normal,
+    }).onChange(function(value) {
         ssaoPass.output = value;
     });
     gui.add(ssaoPass, "kernelRadius").min(0).max(32);
diff --git a/examples-testing/examples/webgl_postprocessing_ssr.ts b/examples-testing/examples/webgl_postprocessing_ssr.ts
index eaaa1c9..9fc708b 100644
--- a/examples-testing/examples/webgl_postprocessing_ssr.ts
+++ b/examples-testing/examples/webgl_postprocessing_ssr.ts
@@ -5,10 +5,10 @@ import Stats from "three/addons/libs/stats.module.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import { ReflectorForSSRPass } from "three/addons/objects/ReflectorForSSRPass.js";
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
-import { SSRPass } from "three/addons/postprocessing/SSRPass.js";
 import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
-import { ReflectorForSSRPass } from "three/addons/objects/ReflectorForSSRPass.js";
+import { SSRPass } from "three/addons/postprocessing/SSRPass.js";
 
 import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
 
@@ -18,17 +18,17 @@ const params = {
     otherMeshes: true,
     groundReflector: true,
 };
-let composer;
-let ssrPass;
-let gui;
-let stats;
-let controls;
-let camera, scene, renderer;
-const otherMeshes = [];
-let groundReflector;
-const selects = [];
-
-const container = document.querySelector("#container");
+let composer: EffectComposer;
+let ssrPass: SSRPass;
+let gui: GUI;
+let stats: Stats;
+let controls: OrbitControls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+const otherMeshes: THREE.Mesh[] = [];
+let groundReflector: ReflectorForSSRPass;
+const selects: THREE.Mesh[] = [];
+
+const container = document.querySelector("#container")!;
 
 // Configure and create Draco decoder.
 const dracoLoader = new DRACOLoader();
@@ -47,10 +47,7 @@ function init() {
     scene.fog = new THREE.Fog(0x443333, 1, 4);
 
     // Ground
-    const plane = new THREE.Mesh(
-        new THREE.PlaneGeometry(8, 8),
-        new THREE.MeshPhongMaterial({ color: 0xcbcbcb }),
-    );
+    const plane = new THREE.Mesh(new THREE.PlaneGeometry(8, 8), new THREE.MeshPhongMaterial({ color: 0xcbcbcb }));
     plane.rotation.x = -Math.PI / 2;
     plane.position.y = -0.0001;
     // plane.receiveShadow = true;
@@ -68,7 +65,7 @@ function init() {
     spotLight.position.set(-1, 1, 1);
     scene.add(spotLight);
 
-    dracoLoader.load("models/draco/bunny.drc", function (geometry) {
+    dracoLoader.load("models/draco/bunny.drc", function(geometry) {
         geometry.computeVertexNormals();
 
         const material = new THREE.MeshStandardMaterial({ color: 0xa5a5a5 });
@@ -81,28 +78,28 @@ function init() {
         dracoLoader.dispose();
     });
 
-    let geometry, material, mesh;
+    let geometry: THREE.BufferGeometry, material: THREE.MeshStandardMaterial, mesh: THREE.Mesh;
 
-    geometry = new THREE.BoxGeometry(.05, .05, .05);
+    geometry = new THREE.BoxGeometry(0.05, 0.05, 0.05);
     material = new THREE.MeshStandardMaterial({ color: "green" });
     mesh = new THREE.Mesh(geometry, material);
-    mesh.position.set(-.12, .025, .015);
+    mesh.position.set(-0.12, 0.025, 0.015);
     scene.add(mesh);
     otherMeshes.push(mesh);
     selects.push(mesh);
 
-    geometry = new THREE.IcosahedronGeometry(.025, 4);
+    geometry = new THREE.IcosahedronGeometry(0.025, 4);
     material = new THREE.MeshStandardMaterial({ color: "cyan" });
     mesh = new THREE.Mesh(geometry, material);
-    mesh.position.set(-.05, .025, .08);
+    mesh.position.set(-0.05, 0.025, 0.08);
     scene.add(mesh);
     otherMeshes.push(mesh);
     selects.push(mesh);
 
-    geometry = new THREE.ConeGeometry(.025, .05, 64);
+    geometry = new THREE.ConeGeometry(0.025, 0.05, 64);
     material = new THREE.MeshStandardMaterial({ color: "yellow" });
     mesh = new THREE.Mesh(geometry, material);
-    mesh.position.set(-.05, .025, -.055);
+    mesh.position.set(-0.05, 0.025, -0.055);
     scene.add(mesh);
     otherMeshes.push(mesh);
     selects.push(mesh);
@@ -162,13 +159,13 @@ function init() {
     gui.add(params, "enableSSR").name("Enable SSR");
     gui.add(params, "groundReflector").onChange(() => {
         if (params.groundReflector) {
-            ssrPass.groundReflector = groundReflector, ssrPass.selects = selects;
+            (ssrPass.groundReflector = groundReflector), (ssrPass.selects = selects);
         } else {
-            ssrPass.groundReflector = null, ssrPass.selects = null;
+            (ssrPass.groundReflector = null), (ssrPass.selects = null);
         }
     });
     ssrPass.thickness = 0.018;
-    gui.add(ssrPass, "thickness").min(0).max(.1).step(.0001);
+    gui.add(ssrPass, "thickness").min(0).max(0.1).step(0.0001);
     ssrPass.infiniteThick = false;
     gui.add(ssrPass, "infiniteThick");
     gui.add(params, "autoRotate").onChange(() => {
@@ -182,34 +179,45 @@ function init() {
     folder.add(ssrPass, "distanceAttenuation").onChange(() => {
         groundReflector.distanceAttenuation = ssrPass.distanceAttenuation;
     });
-    ssrPass.maxDistance = .1;
+    ssrPass.maxDistance = 0.1;
     groundReflector.maxDistance = ssrPass.maxDistance;
-    folder.add(ssrPass, "maxDistance").min(0).max(.5).step(.001).onChange(() => {
-        groundReflector.maxDistance = ssrPass.maxDistance;
-    });
+    folder
+        .add(ssrPass, "maxDistance")
+        .min(0)
+        .max(0.5)
+        .step(0.001)
+        .onChange(() => {
+            groundReflector.maxDistance = ssrPass.maxDistance;
+        });
     folder.add(params, "otherMeshes").onChange(() => {
         if (params.otherMeshes) {
-            otherMeshes.forEach((mesh) => mesh.visible = true);
+            otherMeshes.forEach(mesh => (mesh.visible = true));
         } else {
-            otherMeshes.forEach((mesh) => mesh.visible = false);
+            otherMeshes.forEach(mesh => (mesh.visible = false));
         }
     });
     folder.add(ssrPass, "bouncing");
-    folder.add(ssrPass, "output", {
-        "Default": SSRPass.OUTPUT.Default,
-        "SSR Only": SSRPass.OUTPUT.SSR,
-        "Beauty": SSRPass.OUTPUT.Beauty,
-        "Depth": SSRPass.OUTPUT.Depth,
-        "Normal": SSRPass.OUTPUT.Normal,
-        "Metalness": SSRPass.OUTPUT.Metalness,
-    }).onChange(function (value) {
-        ssrPass.output = value;
-    });
+    folder
+        .add(ssrPass, "output", {
+            Default: SSRPass.OUTPUT.Default,
+            "SSR Only": SSRPass.OUTPUT.SSR,
+            Beauty: SSRPass.OUTPUT.Beauty,
+            Depth: SSRPass.OUTPUT.Depth,
+            Normal: SSRPass.OUTPUT.Normal,
+            Metalness: SSRPass.OUTPUT.Metalness,
+        })
+        .onChange(function(value) {
+            ssrPass.output = value;
+        });
     ssrPass.opacity = 1;
     groundReflector.opacity = ssrPass.opacity;
-    folder.add(ssrPass, "opacity").min(0).max(1).onChange(() => {
-        groundReflector.opacity = ssrPass.opacity;
-    });
+    folder
+        .add(ssrPass, "opacity")
+        .min(0)
+        .max(1)
+        .onChange(() => {
+            groundReflector.opacity = ssrPass.opacity;
+        });
     folder.add(ssrPass, "blur");
     // folder.open()
     // gui.close()
diff --git a/examples-testing/examples/webgl_postprocessing_taa.ts b/examples-testing/examples/webgl_postprocessing_taa.ts
index e390334..3afe24a 100644
--- a/examples-testing/examples/webgl_postprocessing_taa.ts
+++ b/examples-testing/examples/webgl_postprocessing_taa.ts
@@ -1,15 +1,20 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
+import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { TAARenderPass } from "three/addons/postprocessing/TAARenderPass.js";
-import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 
-let camera, scene, renderer, composer, taaRenderPass, renderPass;
-let gui, stats;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    composer: EffectComposer,
+    taaRenderPass: TAARenderPass,
+    renderPass: RenderPass;
+let gui: GUI | undefined, stats: Stats;
 let index = 0;
 
 const param = { TAAEnabled: "1", TAASampleLevel: 0 };
@@ -25,9 +30,9 @@ function clearGui() {
     gui = new GUI();
 
     gui.add(param, "TAAEnabled", {
-        "Disabled": "0",
-        "Enabled": "1",
-    }).onFinishChange(function () {
+        Disabled: "0",
+        Enabled: "1",
+    }).onFinishChange(function() {
         if (taaRenderPass) {
             taaRenderPass.enabled = param.TAAEnabled === "1";
             renderPass.enabled = param.TAAEnabled !== "1";
@@ -41,7 +46,7 @@ function clearGui() {
         "Level 3: 8 Samples": 3,
         "Level 4: 16 Samples": 4,
         "Level 5: 32 Samples": 5,
-    }).onFinishChange(function () {
+    }).onFinishChange(function() {
         if (taaRenderPass) {
             taaRenderPass.sampleLevel = param.TAASampleLevel;
         }
@@ -51,7 +56,7 @@ function clearGui() {
 }
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     renderer = new THREE.WebGLRenderer();
     renderer.setPixelRatio(window.devicePixelRatio);
diff --git a/examples-testing/examples/webgl_postprocessing_unreal_bloom.ts b/examples-testing/examples/webgl_postprocessing_unreal_bloom.ts
index f0ff9ed..5e74fc2 100644
--- a/examples-testing/examples/webgl_postprocessing_unreal_bloom.ts
+++ b/examples-testing/examples/webgl_postprocessing_unreal_bloom.ts
@@ -1,17 +1,17 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
+import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
-import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 
-let camera, stats;
-let composer, renderer, mixer, clock;
+let camera: THREE.PerspectiveCamera, stats: Stats;
+let composer: EffectComposer, renderer: THREE.WebGLRenderer, mixer: THREE.AnimationMixer, clock: THREE.Clock;
 
 const params = {
     threshold: 0,
@@ -23,7 +23,7 @@ const params = {
 init();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     stats = new Stats();
     container.appendChild(stats.dom);
@@ -66,7 +66,7 @@ function init() {
     composer.addPass(bloomPass);
     composer.addPass(outputPass);
 
-    new GLTFLoader().load("models/gltf/PrimaryIonDrive.glb", function (gltf) {
+    new GLTFLoader().load("models/gltf/PrimaryIonDrive.glb", function(gltf) {
         const model = gltf.scene;
 
         scene.add(model);
@@ -82,21 +82,23 @@ function init() {
 
     const bloomFolder = gui.addFolder("bloom");
 
-    bloomFolder.add(params, "threshold", 0.0, 1.0).onChange(function (value) {
+    bloomFolder.add(params, "threshold", 0.0, 1.0).onChange(function(value) {
         bloomPass.threshold = Number(value);
     });
 
-    bloomFolder.add(params, "strength", 0.0, 3.0).onChange(function (value) {
+    bloomFolder.add(params, "strength", 0.0, 3.0).onChange(function(value) {
         bloomPass.strength = Number(value);
     });
 
-    gui.add(params, "radius", 0.0, 1.0).step(0.01).onChange(function (value) {
-        bloomPass.radius = Number(value);
-    });
+    gui.add(params, "radius", 0.0, 1.0)
+        .step(0.01)
+        .onChange(function(value) {
+            bloomPass.radius = Number(value);
+        });
 
     const toneMappingFolder = gui.addFolder("tone mapping");
 
-    toneMappingFolder.add(params, "exposure", 0.1, 2).onChange(function (value) {
+    toneMappingFolder.add(params, "exposure", 0.1, 2).onChange(function(value) {
         renderer.toneMappingExposure = Math.pow(value, 4.0);
     });
 
diff --git a/examples-testing/examples/webgl_postprocessing_unreal_bloom_selective.ts b/examples-testing/examples/webgl_postprocessing_unreal_bloom_selective.ts
index 93b8ef8..d02726f 100644
--- a/examples-testing/examples/webgl_postprocessing_unreal_bloom_selective.ts
+++ b/examples-testing/examples/webgl_postprocessing_unreal_bloom_selective.ts
@@ -4,10 +4,10 @@ import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
+import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
 import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
-import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
 
 const BLOOM_SCENE = 1;
 
@@ -22,7 +22,7 @@ const params = {
 };
 
 const darkMaterial = new THREE.MeshBasicMaterial({ color: "black" });
-const materials = {};
+const materials: Record<string, THREE.Material | THREE.Material[]> = {};
 
 const renderer = new THREE.WebGLRenderer({ antialias: true });
 renderer.setPixelRatio(window.devicePixelRatio);
@@ -60,8 +60,8 @@ const mixPass = new ShaderPass(
             baseTexture: { value: null },
             bloomTexture: { value: bloomComposer.renderTarget2.texture },
         },
-        vertexShader: document.getElementById("vertexshader").textContent,
-        fragmentShader: document.getElementById("fragmentshader").textContent,
+        vertexShader: document.getElementById("vertexshader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentshader")!.textContent!,
         defines: {},
     }),
     "baseTexture",
@@ -85,31 +85,34 @@ const gui = new GUI();
 
 const bloomFolder = gui.addFolder("bloom");
 
-bloomFolder.add(params, "threshold", 0.0, 1.0).onChange(function (value) {
+bloomFolder.add(params, "threshold", 0.0, 1.0).onChange(function(value) {
     bloomPass.threshold = Number(value);
     render();
 });
 
-bloomFolder.add(params, "strength", 0.0, 3).onChange(function (value) {
+bloomFolder.add(params, "strength", 0.0, 3).onChange(function(value) {
     bloomPass.strength = Number(value);
     render();
 });
 
-bloomFolder.add(params, "radius", 0.0, 1.0).step(0.01).onChange(function (value) {
-    bloomPass.radius = Number(value);
-    render();
-});
+bloomFolder
+    .add(params, "radius", 0.0, 1.0)
+    .step(0.01)
+    .onChange(function(value) {
+        bloomPass.radius = Number(value);
+        render();
+    });
 
 const toneMappingFolder = gui.addFolder("tone mapping");
 
-toneMappingFolder.add(params, "exposure", 0.1, 2).onChange(function (value) {
+toneMappingFolder.add(params, "exposure", 0.1, 2).onChange(function(value) {
     renderer.toneMappingExposure = Math.pow(value, 4.0);
     render();
 });
 
 setupScene();
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
     mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
 
@@ -122,7 +125,7 @@ function onPointerDown(event) {
     }
 }
 
-window.onresize = function () {
+window.onresize = function() {
     const width = window.innerWidth;
     const height = window.innerHeight;
 
@@ -162,9 +165,9 @@ function setupScene() {
     render();
 }
 
-function disposeMaterial(obj) {
-    if (obj.material) {
-        obj.material.dispose();
+function disposeMaterial(obj: THREE.Object3D) {
+    if ((obj as THREE.Mesh).material) {
+        ((obj as THREE.Mesh).material as THREE.Material).dispose();
     }
 }
 
@@ -177,16 +180,16 @@ function render() {
     finalComposer.render();
 }
 
-function darkenNonBloomed(obj) {
-    if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
-        materials[obj.uuid] = obj.material;
-        obj.material = darkMaterial;
+function darkenNonBloomed(obj: THREE.Object3D) {
+    if ((obj as THREE.Mesh).isMesh && bloomLayer.test(obj.layers) === false) {
+        materials[obj.uuid] = (obj as THREE.Mesh).material;
+        (obj as THREE.Mesh).material = darkMaterial;
     }
 }
 
-function restoreMaterial(obj) {
+function restoreMaterial(obj: THREE.Object3D) {
     if (materials[obj.uuid]) {
-        obj.material = materials[obj.uuid];
+        (obj as THREE.Mesh).material = materials[obj.uuid];
         delete materials[obj.uuid];
     }
 }
diff --git a/examples-testing/examples/webgl_raycaster_sprite.ts b/examples-testing/examples/webgl_raycaster_sprite.ts
index f4a37d5..6e6887b 100644
--- a/examples-testing/examples/webgl_raycaster_sprite.ts
+++ b/examples-testing/examples/webgl_raycaster_sprite.ts
@@ -2,10 +2,10 @@ import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let renderer, scene, camera;
-let group;
+let renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let group: THREE.Group;
 
-let selectedObject = null;
+let selectedObject: THREE.Mesh<THREE.BufferGeometry, THREE.SpriteMaterial> | null = null;
 const raycaster = new THREE.Raycaster();
 const pointer = new THREE.Vector2();
 
@@ -43,10 +43,10 @@ function init() {
     group.add(sprite1);
 
     const sprite2 = new THREE.Sprite(new THREE.SpriteMaterial({ color: "#69f", sizeAttenuation: false }));
-    sprite2.material.rotation = Math.PI / 3 * 4;
+    sprite2.material.rotation = (Math.PI / 3) * 4;
     sprite2.position.set(8, -2, 2);
     sprite2.center.set(0.5, 0);
-    sprite2.scale.set(.1, .5, .1);
+    sprite2.scale.set(0.1, 0.5, 0.1);
     group.add(sprite2);
 
     const group2 = new THREE.Object3D();
@@ -78,7 +78,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (selectedObject) {
         selectedObject.material.color.set("#69f");
         selectedObject = null;
@@ -92,12 +92,12 @@ function onPointerMove(event) {
     const intersects = raycaster.intersectObject(group, true);
 
     if (intersects.length > 0) {
-        const res = intersects.filter(function (res) {
+        const res = intersects.filter(function(res) {
             return res && res.object;
         })[0];
 
         if (res && res.object) {
-            selectedObject = res.object;
+            selectedObject = res.object as THREE.Mesh<THREE.BufferGeometry, THREE.SpriteMaterial>;
             selectedObject.material.color.set("#f00");
         }
     }
diff --git a/examples-testing/examples/webgl_raycaster_texture.ts b/examples-testing/examples/webgl_raycaster_texture.ts
index a9c19e1..cf9e0c0 100644
--- a/examples-testing/examples/webgl_raycaster_texture.ts
+++ b/examples-testing/examples/webgl_raycaster_texture.ts
@@ -3,12 +3,20 @@ import * as THREE from "three";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
 const WRAPPING = {
-    "RepeatWrapping": THREE.RepeatWrapping,
-    "ClampToEdgeWrapping": THREE.ClampToEdgeWrapping,
-    "MirroredRepeatWrapping": THREE.MirroredRepeatWrapping,
+    RepeatWrapping: THREE.RepeatWrapping,
+    ClampToEdgeWrapping: THREE.ClampToEdgeWrapping,
+    MirroredRepeatWrapping: THREE.MirroredRepeatWrapping,
 };
 
-const params = {
+const params: {
+    wrapS: THREE.Wrapping;
+    wrapT: THREE.Wrapping;
+    offsetX: number;
+    offsetY: number;
+    repeatX: number;
+    repeatY: number;
+    rotation: number;
+} = {
     wrapS: THREE.RepeatWrapping,
     wrapT: THREE.RepeatWrapping,
     offsetX: 0,
@@ -18,68 +26,68 @@ const params = {
     rotation: 0,
 };
 
-function CanvasTexture(parentTexture) {
-    this._canvas = document.createElement("canvas");
-    this._canvas.width = this._canvas.height = 1024;
-    this._context2D = this._canvas.getContext("2d");
+class CanvasTexture {
+    _background: HTMLImageElement;
 
-    if (parentTexture) {
-        this._parentTexture.push(parentTexture);
-        parentTexture.image = this._canvas;
-    }
+    constructor(parentTexture: THREE.Texture) {
+        this._canvas = document.createElement("canvas");
+        this._canvas.width = this._canvas.height = 1024;
+        this._context2D = this._canvas.getContext("2d");
 
-    const that = this;
-    this._background = document.createElement("img");
-    this._background.addEventListener("load", function () {
-        that._canvas.width = that._background.naturalWidth;
-        that._canvas.height = that._background.naturalHeight;
+        if (parentTexture) {
+            this._parentTexture.push(parentTexture);
+            parentTexture.image = this._canvas;
+        }
 
-        that._crossRadius = Math.ceil(Math.min(that._canvas.width, that._canvas.height / 30));
-        that._crossMax = Math.ceil(0.70710678 * that._crossRadius);
-        that._crossMin = Math.ceil(that._crossMax / 10);
-        that._crossThickness = Math.ceil(that._crossMax / 10);
+        const that = this;
+        this._background = document.createElement("img");
+        this._background.addEventListener("load", function() {
+            that._canvas!.width = that._background.naturalWidth;
+            that._canvas!.height = that._background.naturalHeight;
 
-        that._draw();
-    });
-    this._background.crossOrigin = "";
-    this._background.src = "textures/uv_grid_opengl.jpg";
+            that._crossRadius = Math.ceil(Math.min(that._canvas!.width, that._canvas!.height / 30));
+            that._crossMax = Math.ceil(0.70710678 * that._crossRadius);
+            that._crossMin = Math.ceil(that._crossMax / 10);
+            that._crossThickness = Math.ceil(that._crossMax / 10);
 
-    this._draw();
-}
+            that._draw();
+        });
+        this._background.crossOrigin = "";
+        this._background.src = "textures/uv_grid_opengl.jpg";
 
-CanvasTexture.prototype = {
-    constructor: CanvasTexture,
+        this._draw();
+    }
 
-    _canvas: null,
-    _context2D: null,
-    _xCross: 0,
-    _yCross: 0,
+    _canvas: HTMLCanvasElement | null = null;
+    _context2D: CanvasRenderingContext2D | null = null;
+    _xCross = 0;
+    _yCross = 0;
 
-    _crossRadius: 57,
-    _crossMax: 40,
-    _crossMin: 4,
-    _crossThickness: 4,
+    _crossRadius = 57;
+    _crossMax = 40;
+    _crossMin = 4;
+    _crossThickness = 4;
 
-    _parentTexture: [],
+    _parentTexture: THREE.Texture[] = [];
 
-    addParent: function (parentTexture) {
+    addParent = function(this: CanvasTexture, parentTexture: THREE.Texture) {
         if (this._parentTexture.indexOf(parentTexture) === -1) {
             this._parentTexture.push(parentTexture);
             parentTexture.image = this._canvas;
         }
-    },
+    };
 
-    setCrossPosition: function (x, y) {
-        this._xCross = x * this._canvas.width;
-        this._yCross = y * this._canvas.height;
+    setCrossPosition = function(this: CanvasTexture, x: number, y: number) {
+        this._xCross = x * this._canvas!.width;
+        this._yCross = y * this._canvas!.height;
 
         this._draw();
-    },
+    };
 
-    _draw: function () {
+    _draw = function(this: CanvasTexture) {
         if (!this._context2D) return;
 
-        this._context2D.clearRect(0, 0, this._canvas.width, this._canvas.height);
+        this._context2D.clearRect(0, 0, this._canvas!.width, this._canvas!.height);
 
         // Background.
         this._context2D.drawImage(this._background, 0, 0);
@@ -106,18 +114,18 @@ CanvasTexture.prototype = {
         for (let i = 0; i < this._parentTexture.length; i++) {
             this._parentTexture[i].needsUpdate = true;
         }
-    },
-};
+    };
+}
 
 const width = window.innerWidth;
 const height = window.innerHeight;
 
-let canvas;
-let planeTexture, cubeTexture, circleTexture;
+let canvas: CanvasTexture;
+let planeTexture: THREE.Texture, cubeTexture: THREE.Texture, circleTexture: THREE.Texture;
 
-let container;
+let container: HTMLElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 const raycaster = new THREE.Raycaster();
 const mouse = new THREE.Vector2();
@@ -127,7 +135,7 @@ init();
 render();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     scene = new THREE.Scene();
     scene.background = new THREE.Color(0xeeeeee);
@@ -233,7 +241,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onMouseMove(evt) {
+function onMouseMove(evt: MouseEvent) {
     evt.preventDefault();
 
     const array = getMousePosition(container, evt.clientX, evt.clientY);
@@ -243,18 +251,20 @@ function onMouseMove(evt) {
 
     if (intersects.length > 0 && intersects[0].uv) {
         const uv = intersects[0].uv;
-        intersects[0].object.material.map.transformUv(uv);
+        (intersects[0].object as THREE.Mesh<THREE.BufferGeometry, THREE.MeshBasicMaterial>).material.map!.transformUv(
+            uv,
+        );
         canvas.setCrossPosition(uv.x, uv.y);
     }
 }
 
-function getMousePosition(dom, x, y) {
+function getMousePosition(dom: HTMLElement, x: number, y: number) {
     const rect = dom.getBoundingClientRect();
     return [(x - rect.left) / rect.width, (y - rect.top) / rect.height];
 }
 
-function getIntersects(point, objects) {
-    mouse.set((point.x * 2) - 1, -(point.y * 2) + 1);
+function getIntersects(point: THREE.Vector2, objects: THREE.Object3D[]) {
+    mouse.set(point.x * 2 - 1, -(point.y * 2) + 1);
 
     raycaster.setFromCamera(mouse, camera);
 
@@ -277,12 +287,12 @@ function render() {
     renderer.render(scene, camera);
 }
 
-function setwrapS(value) {
+function setwrapS(value: THREE.Wrapping) {
     circleTexture.wrapS = value;
     circleTexture.needsUpdate = true;
 }
 
-function setwrapT(value) {
+function setwrapT(value: THREE.Wrapping) {
     circleTexture.wrapT = value;
     circleTexture.needsUpdate = true;
 }
diff --git a/examples-testing/examples/webgl_raymarching_reflect.ts b/examples-testing/examples/webgl_raymarching_reflect.ts
index 1da879c..0638beb 100644
--- a/examples-testing/examples/webgl_raymarching_reflect.ts
+++ b/examples-testing/examples/webgl_raymarching_reflect.ts
@@ -1,18 +1,18 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let dolly, camera, scene, renderer;
-let geometry, material, mesh;
-let stats, clock;
+let dolly: THREE.Group, camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let geometry: THREE.PlaneGeometry, material: THREE.RawShaderMaterial, mesh;
+let stats: Stats, clock: THREE.Clock;
 
-const canvas = document.querySelector("#canvas");
+const canvas = document.querySelector("#canvas") as HTMLCanvasElement;
 
 const config = {
-    saveImage: function () {
+    saveImage: function() {
         renderer.render(scene, camera);
         window.open(canvas.toDataURL());
     },
@@ -48,8 +48,8 @@ function init() {
             cameraWorldMatrix: { value: camera.matrixWorld },
             cameraProjectionMatrixInverse: { value: camera.projectionMatrixInverse.clone() },
         },
-        vertexShader: document.getElementById("vertex_shader").textContent,
-        fragmentShader: document.getElementById("fragment_shader").textContent,
+        vertexShader: document.getElementById("vertex_shader")!.textContent!,
+        fragmentShader: document.getElementById("fragment_shader")!.textContent!,
     });
     mesh = new THREE.Mesh(geometry, material);
     mesh.frustumCulled = false;
diff --git a/examples-testing/examples/webgl_read_float_buffer.ts b/examples-testing/examples/webgl_read_float_buffer.ts
index 0bc55d4..4de9587 100644
--- a/examples-testing/examples/webgl_read_float_buffer.ts
+++ b/examples-testing/examples/webgl_read_float_buffer.ts
@@ -2,25 +2,31 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let cameraRTT, sceneRTT, sceneScreen, renderer, zmesh1, zmesh2;
+let cameraRTT: THREE.OrthographicCamera,
+    sceneRTT: THREE.Scene,
+    sceneScreen: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    zmesh1: THREE.Mesh,
+    zmesh2: THREE.Mesh;
 
-let mouseX = 0, mouseY = 0;
+let mouseX = 0,
+    mouseY = 0;
 
 const windowHalfX = window.innerWidth / 2;
 const windowHalfY = window.innerHeight / 2;
 
-let rtTexture, material, quad;
+let rtTexture: THREE.WebGLRenderTarget, material: THREE.ShaderMaterial, quad: THREE.Mesh;
 
 let delta = 0.01;
-let valueNode;
+let valueNode: HTMLElement;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     cameraRTT = new THREE.OrthographicCamera(
         window.innerWidth / -2,
@@ -53,15 +59,15 @@ function init() {
     });
 
     material = new THREE.ShaderMaterial({
-        uniforms: { "time": { value: 0.0 } },
-        vertexShader: document.getElementById("vertexShader").textContent,
-        fragmentShader: document.getElementById("fragment_shader_pass_1").textContent,
+        uniforms: { time: { value: 0.0 } },
+        vertexShader: document.getElementById("vertexShader")!.textContent!,
+        fragmentShader: document.getElementById("fragment_shader_pass_1")!.textContent!,
     });
 
     const materialScreen = new THREE.ShaderMaterial({
-        uniforms: { "tDiffuse": { value: rtTexture.texture } },
-        vertexShader: document.getElementById("vertexShader").textContent,
-        fragmentShader: document.getElementById("fragment_shader_screen").textContent,
+        uniforms: { tDiffuse: { value: rtTexture.texture } },
+        vertexShader: document.getElementById("vertexShader")!.textContent!,
+        fragmentShader: document.getElementById("fragment_shader_screen")!.textContent!,
 
         depthWrite: false,
     });
@@ -101,12 +107,12 @@ function init() {
     stats = new Stats();
     container.appendChild(stats.dom);
 
-    valueNode = document.getElementById("values");
+    valueNode = document.getElementById("values")!;
 
     document.addEventListener("mousemove", onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
diff --git a/examples-testing/examples/webgl_refraction.ts b/examples-testing/examples/webgl_refraction.ts
index 7c507ee..d32abfa 100644
--- a/examples-testing/examples/webgl_refraction.ts
+++ b/examples-testing/examples/webgl_refraction.ts
@@ -4,14 +4,14 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { Refractor } from "three/addons/objects/Refractor.js";
 import { WaterRefractionShader } from "three/addons/shaders/WaterRefractionShader.js";
 
-let camera, scene, renderer, clock;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, clock: THREE.Clock;
 
-let refractor, smallSphere;
+let refractor: Refractor, smallSphere: THREE.Mesh;
 
 init();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     clock = new THREE.Clock();
 
@@ -51,7 +51,7 @@ function init() {
 
     // load dudv map for distortion effect
 
-    const dudvMap = new THREE.TextureLoader().load("textures/waterdudv.jpg", function () {
+    const dudvMap = new THREE.TextureLoader().load("textures/waterdudv.jpg", function() {
         animate();
     });
 
@@ -128,12 +128,8 @@ function animate() {
 
     refractor.material.uniforms.time.value = time;
 
-    smallSphere.position.set(
-        Math.cos(time) * 30,
-        Math.abs(Math.cos(time * 2)) * 20 + 5,
-        Math.sin(time) * 30,
-    );
-    smallSphere.rotation.y = (Math.PI / 2) - time;
+    smallSphere.position.set(Math.cos(time) * 30, Math.abs(Math.cos(time * 2)) * 20 + 5, Math.sin(time) * 30);
+    smallSphere.rotation.y = Math.PI / 2 - time;
     smallSphere.rotation.z = time * 8;
 
     renderer.render(scene, camera);
diff --git a/examples-testing/examples/webgl_rtt.ts b/examples-testing/examples/webgl_rtt.ts
index 9cc9876..b84708b 100644
--- a/examples-testing/examples/webgl_rtt.ts
+++ b/examples-testing/examples/webgl_rtt.ts
@@ -2,16 +2,24 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-let container, stats;
+let container: HTMLElement, stats: Stats;
 
-let cameraRTT, camera, sceneRTT, sceneScreen, scene, renderer, zmesh1, zmesh2;
+let cameraRTT: THREE.OrthographicCamera,
+    camera: THREE.PerspectiveCamera,
+    sceneRTT: THREE.Scene,
+    sceneScreen: THREE.Scene,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    zmesh1: THREE.Mesh,
+    zmesh2: THREE.Mesh;
 
-let mouseX = 0, mouseY = 0;
+let mouseX = 0,
+    mouseY = 0;
 
 const windowHalfX = window.innerWidth / 2;
 const windowHalfY = window.innerHeight / 2;
 
-let rtTexture, material, quad;
+let rtTexture: THREE.WebGLRenderTarget, material: THREE.ShaderMaterial, quad: THREE.Mesh;
 
 let delta = 0.01;
 
@@ -19,7 +27,7 @@ init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 100;
@@ -52,14 +60,14 @@ function init() {
 
     material = new THREE.ShaderMaterial({
         uniforms: { time: { value: 0.0 } },
-        vertexShader: document.getElementById("vertexShader").textContent,
-        fragmentShader: document.getElementById("fragment_shader_pass_1").textContent,
+        vertexShader: document.getElementById("vertexShader")!.textContent!,
+        fragmentShader: document.getElementById("fragment_shader_pass_1")!.textContent!,
     });
 
     const materialScreen = new THREE.ShaderMaterial({
         uniforms: { tDiffuse: { value: rtTexture.texture } },
-        vertexShader: document.getElementById("vertexShader").textContent,
-        fragmentShader: document.getElementById("fragment_shader_screen").textContent,
+        vertexShader: document.getElementById("vertexShader")!.textContent!,
+        fragmentShader: document.getElementById("fragment_shader_screen")!.textContent!,
 
         depthWrite: false,
     });
@@ -120,7 +128,7 @@ function init() {
     document.addEventListener("mousemove", onDocumentMouseMove);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = event.clientY - windowHalfY;
 }
@@ -137,8 +145,8 @@ function animate() {
 function render() {
     const time = Date.now() * 0.0015;
 
-    camera.position.x += (mouseX - camera.position.x) * .05;
-    camera.position.y += (-mouseY - camera.position.y) * .05;
+    camera.position.x += (mouseX - camera.position.x) * 0.05;
+    camera.position.y += (-mouseY - camera.position.y) * 0.05;
 
     camera.lookAt(scene.position);
 
diff --git a/examples-testing/examples/webgl_shader.ts b/examples-testing/examples/webgl_shader.ts
index 2de587e..0e83538 100644
--- a/examples-testing/examples/webgl_shader.ts
+++ b/examples-testing/examples/webgl_shader.ts
@@ -1,14 +1,14 @@
 import * as THREE from "three";
 
-let camera, scene, renderer;
+let camera: THREE.OrthographicCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let uniforms;
+let uniforms: Record<string, THREE.IUniform<unknown>>;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
 
@@ -22,8 +22,8 @@ function init() {
 
     const material = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById("vertexShader").textContent,
-        fragmentShader: document.getElementById("fragmentShader").textContent,
+        vertexShader: document.getElementById("vertexShader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentShader")!.textContent!,
     });
 
     const mesh = new THREE.Mesh(geometry, material);
diff --git a/examples-testing/examples/webgl_shader_lava.ts b/examples-testing/examples/webgl_shader_lava.ts
index b0ef7d3..68b4634 100644
--- a/examples-testing/examples/webgl_shader_lava.ts
+++ b/examples-testing/examples/webgl_shader_lava.ts
@@ -1,19 +1,27 @@
 import * as THREE from "three";
 
-import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
-import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 import { BloomPass } from "three/addons/postprocessing/BloomPass.js";
+import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
 import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
+import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
 
-let camera, renderer, composer, clock;
+let camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, composer: EffectComposer, clock: THREE.Clock;
 
-let uniforms, mesh;
+let uniforms: {
+        fogDensity: THREE.IUniform<number>;
+        fogColor: THREE.IUniform<THREE.Vector3>;
+        time: THREE.IUniform<number>;
+        uvScale: THREE.IUniform<THREE.Vector2>;
+        texture1: THREE.IUniform<THREE.Texture>;
+        texture2: THREE.IUniform<THREE.Texture>;
+    },
+    mesh: THREE.Mesh;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 3000);
     camera.position.z = 4;
@@ -33,20 +41,20 @@ function init() {
     lavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping;
 
     uniforms = {
-        "fogDensity": { value: 0.45 },
-        "fogColor": { value: new THREE.Vector3(0, 0, 0) },
-        "time": { value: 1.0 },
-        "uvScale": { value: new THREE.Vector2(3.0, 1.0) },
-        "texture1": { value: cloudTexture },
-        "texture2": { value: lavaTexture },
+        fogDensity: { value: 0.45 },
+        fogColor: { value: new THREE.Vector3(0, 0, 0) },
+        time: { value: 1.0 },
+        uvScale: { value: new THREE.Vector2(3.0, 1.0) },
+        texture1: { value: cloudTexture },
+        texture2: { value: lavaTexture },
     };
 
     const size = 0.65;
 
     const material = new THREE.ShaderMaterial({
         uniforms: uniforms,
-        vertexShader: document.getElementById("vertexShader").textContent,
-        fragmentShader: document.getElementById("fragmentShader").textContent,
+        vertexShader: document.getElementById("vertexShader")!.textContent!,
+        fragmentShader: document.getElementById("fragmentShader")!.textContent!,
     });
 
     mesh = new THREE.Mesh(new THREE.TorusGeometry(size, 0.3, 30, 30), material);
diff --git a/examples-testing/examples/webgl_shaders_ocean.ts b/examples-testing/examples/webgl_shaders_ocean.ts
index 4712a76..da85d9a 100644
--- a/examples-testing/examples/webgl_shaders_ocean.ts
+++ b/examples-testing/examples/webgl_shaders_ocean.ts
@@ -2,20 +2,20 @@ import * as THREE from "three";
 
 import Stats from "three/addons/libs/stats.module.js";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { Water } from "three/addons/objects/Water.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { Sky } from "three/addons/objects/Sky.js";
+import { Water } from "three/addons/objects/Water.js";
 
-let container, stats;
-let camera, scene, renderer;
-let controls, water, sun, mesh;
+let container: HTMLElement, stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controls, water: Water, sun: THREE.Vector3, mesh: THREE.Mesh;
 
 init();
 animate();
 
 function init() {
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     //
 
@@ -41,21 +41,18 @@ function init() {
 
     const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
 
-    water = new Water(
-        waterGeometry,
-        {
-            textureWidth: 512,
-            textureHeight: 512,
-            waterNormals: new THREE.TextureLoader().load("textures/waternormals.jpg", function (texture) {
-                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
-            }),
-            sunDirection: new THREE.Vector3(),
-            sunColor: 0xffffff,
-            waterColor: 0x001e0f,
-            distortionScale: 3.7,
-            fog: scene.fog !== undefined,
-        },
-    );
+    water = new Water(waterGeometry, {
+        textureWidth: 512,
+        textureHeight: 512,
+        waterNormals: new THREE.TextureLoader().load("textures/waternormals.jpg", function(texture) {
+            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
+        }),
+        sunDirection: new THREE.Vector3(),
+        sunColor: 0xffffff,
+        waterColor: 0x001e0f,
+        distortionScale: 3.7,
+        fog: scene.fog !== undefined,
+    });
 
     water.rotation.x = -Math.PI / 2;
 
@@ -82,7 +79,7 @@ function init() {
     const pmremGenerator = new THREE.PMREMGenerator(renderer);
     const sceneEnv = new THREE.Scene();
 
-    let renderTarget;
+    let renderTarget: THREE.WebGLRenderTarget;
 
     function updateSun() {
         const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);
diff --git a/examples-testing/examples/webgl_shaders_sky.ts b/examples-testing/examples/webgl_shaders_sky.ts
index b99cb5b..324d0b2 100644
--- a/examples-testing/examples/webgl_shaders_sky.ts
+++ b/examples-testing/examples/webgl_shaders_sky.ts
@@ -1,12 +1,12 @@
 import * as THREE from "three";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { Sky } from "three/addons/objects/Sky.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let sky, sun;
+let sky: Sky, sun: THREE.Vector3;
 
 init();
 render();
@@ -80,7 +80,7 @@ function init() {
 
     const controls = new OrbitControls(camera, renderer.domElement);
     controls.addEventListener("change", render);
-    //controls.maxPolarAngle = Math.PI / 2;
+    // controls.maxPolarAngle = Math.PI / 2;
     controls.enableZoom = false;
     controls.enablePan = false;
 
diff --git a/examples-testing/examples/webgl_shadow_contact.ts b/examples-testing/examples/webgl_shadow_contact.ts
index c74df03..c51606b 100644
--- a/examples-testing/examples/webgl_shadow_contact.ts
+++ b/examples-testing/examples/webgl_shadow_contact.ts
@@ -1,13 +1,13 @@
 import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 import { HorizontalBlurShader } from "three/addons/shaders/HorizontalBlurShader.js";
 import { VerticalBlurShader } from "three/addons/shaders/VerticalBlurShader.js";
 
-let camera, scene, renderer, stats, gui;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats, gui;
 
-const meshes = [];
+const meshes: THREE.Mesh[] = [];
 
 const PLANE_WIDTH = 2.5;
 const PLANE_HEIGHT = 2.5;
@@ -26,16 +26,18 @@ const state = {
     showWireframe: false,
 };
 
-let shadowGroup,
-    renderTarget,
-    renderTargetBlur,
-    shadowCamera,
-    cameraHelper,
-    depthMaterial,
-    horizontalBlurMaterial,
-    verticalBlurMaterial;
+let shadowGroup: THREE.Group,
+    renderTarget: THREE.WebGLRenderTarget,
+    renderTargetBlur: THREE.WebGLRenderTarget,
+    shadowCamera: THREE.OrthographicCamera,
+    cameraHelper: THREE.CameraHelper,
+    depthMaterial: THREE.MeshDepthMaterial,
+    horizontalBlurMaterial: THREE.ShaderMaterial,
+    verticalBlurMaterial: THREE.ShaderMaterial;
 
-let plane, blurPlane, fillPlane;
+let plane: THREE.Mesh<THREE.PlaneGeometry, THREE.MeshBasicMaterial>,
+    blurPlane: THREE.Mesh<THREE.PlaneGeometry, THREE.MeshBasicMaterial | THREE.ShaderMaterial>,
+    fillPlane: THREE.Mesh<THREE.PlaneGeometry, THREE.MeshBasicMaterial>;
 
 init();
 animate();
@@ -136,7 +138,7 @@ function init() {
     // like MeshDepthMaterial, but goes from black to transparent
     depthMaterial = new THREE.MeshDepthMaterial();
     depthMaterial.userData.darkness = { value: state.shadow.darkness };
-    depthMaterial.onBeforeCompile = function (shader) {
+    depthMaterial.onBeforeCompile = function(shader) {
         shader.uniforms.darkness = depthMaterial.userData.darkness;
         shader.fragmentShader = /* glsl */ `
 						uniform float darkness;
@@ -167,20 +169,20 @@ function init() {
     planeFolder.open();
 
     shadowFolder.add(state.shadow, "blur", 0, 15, 0.1);
-    shadowFolder.add(state.shadow, "darkness", 1, 5, 0.1).onChange(function () {
+    shadowFolder.add(state.shadow, "darkness", 1, 5, 0.1).onChange(function() {
         depthMaterial.userData.darkness.value = state.shadow.darkness;
     });
-    shadowFolder.add(state.shadow, "opacity", 0, 1, 0.01).onChange(function () {
+    shadowFolder.add(state.shadow, "opacity", 0, 1, 0.01).onChange(function() {
         plane.material.opacity = state.shadow.opacity;
     });
-    planeFolder.addColor(state.plane, "color").onChange(function () {
+    planeFolder.addColor(state.plane, "color").onChange(function() {
         fillPlane.material.color = new THREE.Color(state.plane.color);
     });
-    planeFolder.add(state.plane, "opacity", 0, 1, 0.01).onChange(function () {
+    planeFolder.add(state.plane, "opacity", 0, 1, 0.01).onChange(function() {
         fillPlane.material.opacity = state.plane.opacity;
     });
 
-    gui.add(state, "showWireframe").onChange(function () {
+    gui.add(state, "showWireframe").onChange(function() {
         if (state.showWireframe) {
             scene.add(cameraHelper);
         } else {
@@ -208,13 +210,13 @@ function onWindowResize() {
 }
 
 // renderTarget --> blurPlane (horizontalBlur) --> renderTargetBlur --> blurPlane (verticalBlur) --> renderTarget
-function blurShadow(amount) {
+function blurShadow(amount: number) {
     blurPlane.visible = true;
 
     // blur horizontally and draw in the renderTargetBlur
     blurPlane.material = horizontalBlurMaterial;
     blurPlane.material.uniforms.tDiffuse.value = renderTarget.texture;
-    horizontalBlurMaterial.uniforms.h.value = amount * 1 / 256;
+    horizontalBlurMaterial.uniforms.h.value = (amount * 1) / 256;
 
     renderer.setRenderTarget(renderTargetBlur);
     renderer.render(blurPlane, shadowCamera);
@@ -222,7 +224,7 @@ function blurShadow(amount) {
     // blur vertically and draw in the main renderTarget
     blurPlane.material = verticalBlurMaterial;
     blurPlane.material.uniforms.tDiffuse.value = renderTargetBlur.texture;
-    verticalBlurMaterial.uniforms.v.value = amount * 1 / 256;
+    verticalBlurMaterial.uniforms.v.value = (amount * 1) / 256;
 
     renderer.setRenderTarget(renderTarget);
     renderer.render(blurPlane, shadowCamera);
@@ -235,7 +237,7 @@ function animate() {
 
     //
 
-    meshes.forEach((mesh) => {
+    meshes.forEach(mesh => {
         mesh.rotation.x += 0.01;
         mesh.rotation.y += 0.02;
     });
diff --git a/examples-testing/examples/webgl_shadowmap.ts b/examples-testing/examples/webgl_shadowmap.ts
index 8613c0e..a95eece 100644
--- a/examples-testing/examples/webgl_shadowmap.ts
+++ b/examples-testing/examples/webgl_shadowmap.ts
@@ -3,28 +3,30 @@ import * as THREE from "three";
 import Stats from "three/addons/libs/stats.module.js";
 
 import { FirstPersonControls } from "three/addons/controls/FirstPersonControls.js";
-import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
-import { FontLoader } from "three/addons/loaders/FontLoader.js";
 import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
+import { FontLoader } from "three/addons/loaders/FontLoader.js";
+import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { ShadowMapViewer } from "three/addons/utils/ShadowMapViewer.js";
 
-const SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 1024;
+const SHADOW_MAP_WIDTH = 2048,
+    SHADOW_MAP_HEIGHT = 1024;
 
 let SCREEN_WIDTH = window.innerWidth;
 let SCREEN_HEIGHT = window.innerHeight;
 const FLOOR = -250;
 
-let camera, controls, scene, renderer;
-let container, stats;
+let camera: THREE.PerspectiveCamera, controls: FirstPersonControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let container: HTMLDivElement, stats: Stats;
 
-const NEAR = 10, FAR = 3000;
+const NEAR = 10,
+    FAR = 3000;
 
-let mixer;
+let mixer: THREE.AnimationMixer;
 
-const morphs = [];
+const morphs: (THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial> & { speed?: number })[] = [];
 
-let light;
-let lightShadowMapViewer;
+let light: THREE.DirectionalLight;
+let lightShadowMapViewer: ShadowMapViewer;
 
 const clock = new THREE.Clock();
 
@@ -99,7 +101,7 @@ function init() {
     // STATS
 
     stats = new Stats();
-    //container.appendChild( stats.dom );
+    // container.appendChild( stats.dom );
 
     //
 
@@ -119,9 +121,9 @@ function onWindowResize() {
     controls.handleResize();
 }
 
-function onKeyDown(event) {
+function onKeyDown(event: KeyboardEvent) {
     switch (event.keyCode) {
-        case 84: /*t*/
+        case 84 /*t*/:
             showHUD = !showHUD;
             break;
     }
@@ -130,7 +132,7 @@ function onKeyDown(event) {
 function createHUD() {
     lightShadowMapViewer = new ShadowMapViewer(light);
     lightShadowMapViewer.position.x = 10;
-    lightShadowMapViewer.position.y = SCREEN_HEIGHT - (SHADOW_MAP_HEIGHT / 4) - 10;
+    lightShadowMapViewer.position.y = SCREEN_HEIGHT - SHADOW_MAP_HEIGHT / 4 - 10;
     lightShadowMapViewer.size.width = SHADOW_MAP_WIDTH / 4;
     lightShadowMapViewer.size.height = SHADOW_MAP_HEIGHT / 4;
     lightShadowMapViewer.update();
@@ -156,7 +158,7 @@ function createScene() {
     // TEXT
 
     const loader = new FontLoader();
-    loader.load("fonts/helvetiker_bold.typeface.json", function (font) {
+    loader.load("fonts/helvetiker_bold.typeface.json", function(font) {
         const textGeo = new TextGeometry("THREE.JS", {
             font: font,
 
@@ -170,7 +172,7 @@ function createScene() {
         });
 
         textGeo.computeBoundingBox();
-        const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
+        const centerOffset = -0.5 * (textGeo.boundingBox!.max.x - textGeo.boundingBox!.min.x);
 
         const textMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
 
@@ -210,7 +212,16 @@ function createScene() {
 
     mixer = new THREE.AnimationMixer(scene);
 
-    function addMorph(mesh, clip, speed, duration, x, y, z, fudgeColor) {
+    function addMorph(
+        mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial> & { speed?: number },
+        clip: THREE.AnimationClip,
+        speed: number,
+        duration: number,
+        x: number,
+        y: number,
+        z: number,
+        fudgeColor?: boolean,
+    ) {
         mesh = mesh.clone();
         mesh.material = mesh.material.clone();
 
@@ -220,7 +231,8 @@ function createScene() {
 
         mesh.speed = speed;
 
-        mixer.clipAction(clip, mesh)
+        mixer
+            .clipAction(clip, mesh)
             .setDuration(duration)
             // to shift the playback out of phase:
             .startAt(-duration * Math.random())
@@ -239,8 +251,8 @@ function createScene() {
 
     const gltfloader = new GLTFLoader();
 
-    gltfloader.load("models/gltf/Horse.glb", function (gltf) {
-        const mesh = gltf.scene.children[0];
+    gltfloader.load("models/gltf/Horse.glb", function(gltf) {
+        const mesh = gltf.scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
 
         const clip = gltf.animations[0];
 
@@ -253,22 +265,22 @@ function createScene() {
         addMorph(mesh, clip, 550, 1, 100 - Math.random() * 1000, FLOOR, -600, true);
     });
 
-    gltfloader.load("models/gltf/Flamingo.glb", function (gltf) {
-        const mesh = gltf.scene.children[0];
+    gltfloader.load("models/gltf/Flamingo.glb", function(gltf) {
+        const mesh = gltf.scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
         const clip = gltf.animations[0];
 
         addMorph(mesh, clip, 500, 1, 500 - Math.random() * 500, FLOOR + 350, 40);
     });
 
-    gltfloader.load("models/gltf/Stork.glb", function (gltf) {
-        const mesh = gltf.scene.children[0];
+    gltfloader.load("models/gltf/Stork.glb", function(gltf) {
+        const mesh = gltf.scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
         const clip = gltf.animations[0];
 
         addMorph(mesh, clip, 350, 1, 500 - Math.random() * 500, FLOOR + 350, 340);
     });
 
-    gltfloader.load("models/gltf/Parrot.glb", function (gltf) {
-        const mesh = gltf.scene.children[0];
+    gltfloader.load("models/gltf/Parrot.glb", function(gltf) {
+        const mesh = gltf.scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
         const clip = gltf.animations[0];
 
         addMorph(mesh, clip, 450, 0.5, 500 - Math.random() * 500, FLOOR + 300, 700);
@@ -290,7 +302,7 @@ function render() {
     for (let i = 0; i < morphs.length; i++) {
         const morph = morphs[i];
 
-        morph.position.x += morph.speed * delta;
+        morph.position.x += morph.speed! * delta;
 
         if (morph.position.x > 2000) {
             morph.position.x = -1000 - Math.random() * 500;
diff --git a/examples-testing/examples/webgl_shadowmap_csm.ts b/examples-testing/examples/webgl_shadowmap_csm.ts
index 9422383..34ce9d2 100644
--- a/examples-testing/examples/webgl_shadowmap_csm.ts
+++ b/examples-testing/examples/webgl_shadowmap_csm.ts
@@ -1,13 +1,33 @@
 import * as THREE from "three";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
-import { CSM } from "three/addons/csm/CSM.js";
+import { CSM, CSMMode } from "three/addons/csm/CSM.js";
 import { CSMHelper } from "three/addons/csm/CSMHelper.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let renderer, scene, camera, orthoCamera, controls, csm, csmHelper;
-
-const params = {
+let renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    orthoCamera: THREE.OrthographicCamera,
+    controls: OrbitControls,
+    csm: CSM,
+    csmHelper: CSMHelper;
+
+const params: {
+    orthographic: boolean;
+    fade: boolean;
+    shadows: boolean;
+    far: number;
+    mode: CSMMode;
+    lightX: number;
+    lightY: number;
+    lightZ: number;
+    margin: number;
+    lightFar: number;
+    lightNear: number;
+    autoUpdateHelper: boolean;
+    updateHelper: () => void;
+} = {
     orthographic: false,
     fade: false,
     shadows: true,
@@ -20,7 +40,7 @@ const params = {
     lightFar: 5000,
     lightNear: 1,
     autoUpdateHelper: true,
-    updateHelper: function () {
+    updateHelper: function() {
         csmHelper.update();
     },
 };
@@ -32,8 +52,8 @@ function updateOrthoCamera() {
     const size = controls.target.distanceTo(camera.position);
     const aspect = camera.aspect;
 
-    orthoCamera.left = size * aspect / -2;
-    orthoCamera.right = size * aspect / 2;
+    orthoCamera.left = (size * aspect) / -2;
+    orthoCamera.right = (size * aspect) / 2;
 
     orthoCamera.top = size / 2;
     orthoCamera.bottom = size / -2;
@@ -64,9 +84,10 @@ function init() {
     scene.add(ambientLight);
 
     const additionalDirectionalLight = new THREE.DirectionalLight(0x000020, 1.5);
-    additionalDirectionalLight.position.set(params.lightX, params.lightY, params.lightZ).normalize().multiplyScalar(
-        -200,
-    );
+    additionalDirectionalLight.position
+        .set(params.lightX, params.lightY, params.lightZ)
+        .normalize()
+        .multiplyScalar(-200);
     scene.add(additionalDirectionalLight);
 
     csm = new CSM({
@@ -118,81 +139,96 @@ function init() {
 
     const gui = new GUI();
 
-    gui.add(params, "orthographic").onChange(function (value) {
+    gui.add(params, "orthographic").onChange(function(value) {
         csm.camera = value ? orthoCamera : camera;
         csm.updateFrustums();
     });
 
-    gui.add(params, "fade").onChange(function (value) {
+    gui.add(params, "fade").onChange(function(value) {
         csm.fade = value;
         csm.updateFrustums();
     });
 
-    gui.add(params, "shadows").onChange(function (value) {
+    gui.add(params, "shadows").onChange(function(value) {
         renderer.shadowMap.enabled = value;
 
-        scene.traverse(function (child) {
-            if (child.material) {
-                child.material.needsUpdate = true;
+        scene.traverse(function(child) {
+            if ((child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material) {
+                (child as THREE.Mesh<THREE.BufferGeometry, THREE.Material>).material.needsUpdate = true;
             }
         });
     });
 
-    gui.add(params, "far", 1, 5000).step(1).name("shadow far").onChange(function (value) {
-        csm.maxFar = value;
-        csm.updateFrustums();
-    });
+    gui.add(params, "far", 1, 5000)
+        .step(1)
+        .name("shadow far")
+        .onChange(function(value) {
+            csm.maxFar = value;
+            csm.updateFrustums();
+        });
 
-    gui.add(params, "mode", ["uniform", "logarithmic", "practical"]).name("frustum split mode").onChange(
-        function (value) {
+    gui.add(params, "mode", ["uniform", "logarithmic", "practical"])
+        .name("frustum split mode")
+        .onChange(function(value) {
             csm.mode = value;
             csm.updateFrustums();
-        },
-    );
+        });
 
-    gui.add(params, "lightX", -1, 1).name("light direction x").onChange(function (value) {
-        csm.lightDirection.x = value;
-    });
+    gui.add(params, "lightX", -1, 1)
+        .name("light direction x")
+        .onChange(function(value) {
+            csm.lightDirection.x = value;
+        });
 
-    gui.add(params, "lightY", -1, 1).name("light direction y").onChange(function (value) {
-        csm.lightDirection.y = value;
-    });
+    gui.add(params, "lightY", -1, 1)
+        .name("light direction y")
+        .onChange(function(value) {
+            csm.lightDirection.y = value;
+        });
 
-    gui.add(params, "lightZ", -1, 1).name("light direction z").onChange(function (value) {
-        csm.lightDirection.z = value;
-    });
+    gui.add(params, "lightZ", -1, 1)
+        .name("light direction z")
+        .onChange(function(value) {
+            csm.lightDirection.z = value;
+        });
 
-    gui.add(params, "margin", 0, 200).name("light margin").onChange(function (value) {
-        csm.lightMargin = value;
-    });
+    gui.add(params, "margin", 0, 200)
+        .name("light margin")
+        .onChange(function(value) {
+            csm.lightMargin = value;
+        });
 
-    gui.add(params, "lightNear", 1, 10000).name("light near").onChange(function (value) {
-        for (let i = 0; i < csm.lights.length; i++) {
-            csm.lights[i].shadow.camera.near = value;
-            csm.lights[i].shadow.camera.updateProjectionMatrix();
-        }
-    });
+    gui.add(params, "lightNear", 1, 10000)
+        .name("light near")
+        .onChange(function(value) {
+            for (let i = 0; i < csm.lights.length; i++) {
+                csm.lights[i].shadow.camera.near = value;
+                csm.lights[i].shadow.camera.updateProjectionMatrix();
+            }
+        });
 
-    gui.add(params, "lightFar", 1, 10000).name("light far").onChange(function (value) {
-        for (let i = 0; i < csm.lights.length; i++) {
-            csm.lights[i].shadow.camera.far = value;
-            csm.lights[i].shadow.camera.updateProjectionMatrix();
-        }
-    });
+    gui.add(params, "lightFar", 1, 10000)
+        .name("light far")
+        .onChange(function(value) {
+            for (let i = 0; i < csm.lights.length; i++) {
+                csm.lights[i].shadow.camera.far = value;
+                csm.lights[i].shadow.camera.updateProjectionMatrix();
+            }
+        });
 
     const helperFolder = gui.addFolder("helper");
 
     helperFolder.add(csmHelper, "visible");
 
-    helperFolder.add(csmHelper, "displayFrustum").onChange(function () {
+    helperFolder.add(csmHelper, "displayFrustum").onChange(function() {
         csmHelper.updateVisibility();
     });
 
-    helperFolder.add(csmHelper, "displayPlanes").onChange(function () {
+    helperFolder.add(csmHelper, "displayPlanes").onChange(function() {
         csmHelper.updateVisibility();
     });
 
-    helperFolder.add(csmHelper, "displayShadowBounds").onChange(function () {
+    helperFolder.add(csmHelper, "displayShadowBounds").onChange(function() {
         csmHelper.updateVisibility();
     });
 
@@ -202,7 +238,7 @@ function init() {
 
     helperFolder.open();
 
-    window.addEventListener("resize", function () {
+    window.addEventListener("resize", function() {
         camera.aspect = window.innerWidth / window.innerHeight;
         camera.updateProjectionMatrix();
 
diff --git a/examples-testing/examples/webgl_shadowmap_pcss.ts b/examples-testing/examples/webgl_shadowmap_pcss.ts
index fba215d..36d4229 100644
--- a/examples-testing/examples/webgl_shadowmap_pcss.ts
+++ b/examples-testing/examples/webgl_shadowmap_pcss.ts
@@ -4,10 +4,10 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let stats;
-let camera, scene, renderer;
+let stats: Stats;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let group;
+let group: THREE.Group;
 
 init();
 animate();
@@ -96,14 +96,12 @@ function init() {
 
     shader = shader.replace(
         "#ifdef USE_SHADOWMAP",
-        "#ifdef USE_SHADOWMAP" +
-            document.getElementById("PCSS").textContent,
+        "#ifdef USE_SHADOWMAP" + document.getElementById("PCSS")!.textContent,
     );
 
     shader = shader.replace(
         "#if defined( SHADOWMAP_TYPE_PCF )",
-        document.getElementById("PCSSGetShadow").textContent +
-            "#if defined( SHADOWMAP_TYPE_PCF )",
+        document.getElementById("PCSSGetShadow")!.textContent + "#if defined( SHADOWMAP_TYPE_PCF )",
     );
 
     THREE.ShaderChunk.shadowmap_pars_fragment = shader;
@@ -151,7 +149,7 @@ function onWindowResize() {
 function animate() {
     const time = performance.now() / 1000;
 
-    group.traverse(function (child) {
+    group.traverse(function(child) {
         if ("phase" in child.userData) {
             child.position.y = Math.abs(Math.sin(time + child.userData.phase)) * 4 + 0.3;
         }
diff --git a/examples-testing/examples/webgl_shadowmap_performance.ts b/examples-testing/examples/webgl_shadowmap_performance.ts
index 2ddf081..4747c60 100644
--- a/examples-testing/examples/webgl_shadowmap_performance.ts
+++ b/examples-testing/examples/webgl_shadowmap_performance.ts
@@ -3,11 +3,12 @@ import * as THREE from "three";
 import Stats from "three/addons/libs/stats.module.js";
 
 import { FirstPersonControls } from "three/addons/controls/FirstPersonControls.js";
-import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
-import { FontLoader } from "three/addons/loaders/FontLoader.js";
 import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
+import { FontLoader } from "three/addons/loaders/FontLoader.js";
+import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-const SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 1024;
+const SHADOW_MAP_WIDTH = 2048,
+    SHADOW_MAP_HEIGHT = 1024;
 
 let SCREEN_WIDTH = window.innerWidth;
 let SCREEN_HEIGHT = window.innerHeight;
@@ -15,14 +16,16 @@ const FLOOR = -250;
 
 const ANIMATION_GROUPS = 25;
 
-let camera, controls, scene, renderer;
-let stats;
+let camera: THREE.PerspectiveCamera, controls: FirstPersonControls, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let stats: Stats;
 
-const NEAR = 5, FAR = 3000;
+const NEAR = 5,
+    FAR = 3000;
 
-let morph, mixer;
+let morph, mixer: THREE.AnimationMixer;
 
-const morphs = [], animGroups = [];
+const morphs: (THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial> & { speed?: number })[] = [],
+    animGroups: THREE.AnimationObjectGroup[] = [];
 
 const clock = new THREE.Clock();
 
@@ -133,7 +136,7 @@ function createScene() {
     // TEXT
 
     const loader = new FontLoader();
-    loader.load("fonts/helvetiker_bold.typeface.json", function (font) {
+    loader.load("fonts/helvetiker_bold.typeface.json", function(font) {
         const textGeo = new TextGeometry("THREE.JS", {
             font: font,
 
@@ -147,7 +150,7 @@ function createScene() {
         });
 
         textGeo.computeBoundingBox();
-        const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
+        const centerOffset = -0.5 * (textGeo.boundingBox!.max.x - textGeo.boundingBox!.min.x);
 
         const textMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
 
@@ -192,7 +195,17 @@ function createScene() {
 
     // MORPHS
 
-    function addMorph(mesh, clip, speed, duration, x, y, z, fudgeColor, massOptimization) {
+    function addMorph(
+        mesh: THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial> & { speed?: number },
+        clip: THREE.AnimationClip,
+        speed: number,
+        duration: number,
+        x: number,
+        y: number,
+        z: number,
+        fudgeColor: boolean,
+        massOptimization: boolean,
+    ) {
         mesh = mesh.clone();
         mesh.material = mesh.material.clone();
 
@@ -212,13 +225,15 @@ function createScene() {
                 const randomness = 0.6 * Math.random() - 0.3;
                 const phase = (index + randomness) / ANIMATION_GROUPS;
 
-                mixer.clipAction(clip, animGroup)
+                mixer
+                    .clipAction(clip, animGroup)
                     .setDuration(duration)
                     .startAt(-duration * phase)
                     .play();
             }
         } else {
-            mixer.clipAction(clip, mesh)
+            mixer
+                .clipAction(clip, mesh)
                 .setDuration(duration)
                 .startAt(-duration * Math.random())
                 .play();
@@ -236,8 +251,8 @@ function createScene() {
     }
 
     const gltfLoader = new GLTFLoader();
-    gltfLoader.load("models/gltf/Horse.glb", function (gltf) {
-        const mesh = gltf.scene.children[0];
+    gltfLoader.load("models/gltf/Horse.glb", function(gltf) {
+        const mesh = gltf.scene.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
         const clip = gltf.animations[0];
 
         for (let i = -600; i < 601; i += 2) {
@@ -264,7 +279,7 @@ function render() {
     for (let i = 0; i < morphs.length; i++) {
         morph = morphs[i];
 
-        morph.position.x += morph.speed * delta;
+        morph.position.x += morph.speed! * delta;
 
         if (morph.position.x > 2000) {
             morph.position.x = -1000 - Math.random() * 500;
diff --git a/examples-testing/examples/webgl_shadowmap_pointlight.ts b/examples-testing/examples/webgl_shadowmap_pointlight.ts
index 6e5b1ae..e8e0c89 100644
--- a/examples-testing/examples/webgl_shadowmap_pointlight.ts
+++ b/examples-testing/examples/webgl_shadowmap_pointlight.ts
@@ -4,8 +4,8 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let camera, scene, renderer, stats;
-let pointLight, pointLight2;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, stats: Stats;
+let pointLight: THREE.PointLight, pointLight2: THREE.PointLight;
 
 init();
 animate();
@@ -19,7 +19,7 @@ function init() {
 
     // lights
 
-    function createLight(color) {
+    function createLight(color: number) {
         const intensity = 200;
 
         const light = new THREE.PointLight(color, intensity, 20);
@@ -27,9 +27,9 @@ function init() {
         light.shadow.bias = -0.005; // reduces self-shadowing on double-sided objects
 
         let geometry = new THREE.SphereGeometry(0.3, 12, 6);
-        let material = new THREE.MeshBasicMaterial({ color: color });
+        let material: THREE.MeshBasicMaterial | THREE.MeshPhongMaterial = new THREE.MeshBasicMaterial({ color: color });
         material.color.multiplyScalar(intensity);
-        let sphere = new THREE.Mesh(geometry, material);
+        let sphere = new THREE.Mesh<THREE.BufferGeometry, THREE.Material>(geometry, material);
         light.add(sphere);
 
         const texture = new THREE.CanvasTexture(generateTexture());
@@ -107,7 +107,7 @@ function generateTexture() {
     canvas.width = 2;
     canvas.height = 2;
 
-    const context = canvas.getContext("2d");
+    const context = canvas.getContext("2d")!;
     context.fillStyle = "white";
     context.fillRect(0, 1, 2, 1);
 
diff --git a/examples-testing/examples/webgl_shadowmap_progressive.ts b/examples-testing/examples/webgl_shadowmap_progressive.ts
index 5173f8b..e6af5fb 100644
--- a/examples-testing/examples/webgl_shadowmap_progressive.ts
+++ b/examples-testing/examples/webgl_shadowmap_progressive.ts
@@ -1,24 +1,27 @@
 import * as THREE from "three";
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
-import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { TransformControls } from "three/addons/controls/TransformControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { ProgressiveLightMap } from "three/addons/misc/ProgressiveLightMap.js";
 
 // ShadowMap + LightMap Res and Number of Directional Lights
-const shadowMapRes = 512, lightMapRes = 1024, lightCount = 8;
-let camera,
-    scene,
-    renderer,
-    controls,
-    control,
-    control2,
-    object = new THREE.Mesh(),
-    lightOrigin = null,
-    progressiveSurfacemap;
-const dirLights = [], lightmapObjects = [];
+const shadowMapRes = 512,
+    lightMapRes = 1024,
+    lightCount = 8;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    controls: OrbitControls,
+    control: TransformControls,
+    control2: TransformControls,
+    object: THREE.Object3D = new THREE.Mesh(),
+    lightOrigin: THREE.Group | null = null,
+    progressiveSurfacemap: ProgressiveLightMap;
+const dirLights: THREE.DirectionalLight[] = [],
+    lightmapObjects: THREE.Object3D[] = [];
 const params = {
-    "Enable": true,
+    Enable: true,
     "Blur Edges": true,
     "Blend Window": 200,
     "Light Radius": 50,
@@ -57,7 +60,7 @@ function init() {
 
     // transform gizmo
     control = new TransformControls(camera, renderer.domElement);
-    control.addEventListener("dragging-changed", (event) => {
+    control.addEventListener("dragging-changed", event => {
         controls.enabled = !event.value;
     });
     control.attach(lightOrigin);
@@ -94,12 +97,12 @@ function init() {
 
     // model
     function loadModel() {
-        object.traverse(function (child) {
-            if (child.isMesh) {
+        object.traverse(function(child) {
+            if ((child as THREE.Mesh).isMesh) {
                 child.name = "Loaded Mesh";
                 child.castShadow = true;
                 child.receiveShadow = true;
-                child.material = new THREE.MeshPhongMaterial();
+                (child as THREE.Mesh).material = new THREE.MeshPhongMaterial();
 
                 // This adds the model to the lightmap
                 lightmapObjects.push(child);
@@ -112,7 +115,7 @@ function init() {
         object.scale.set(2, 2, 2);
         object.position.set(0, -16, 0);
         control2 = new TransformControls(camera, renderer.domElement);
-        control2.addEventListener("dragging-changed", (event) => {
+        control2.addEventListener("dragging-changed", event => {
             controls.enabled = !event.value;
         });
         control2.attach(object);
@@ -125,7 +128,7 @@ function init() {
 
         object.add(lightTarget);
 
-        if (typeof TESTING !== "undefined") {
+        if (typeof (window as any).TESTING !== "undefined") {
             for (let i = 0; i < 300; i++) {
                 render();
             }
@@ -134,7 +137,7 @@ function init() {
 
     const manager = new THREE.LoadingManager(loadModel);
     const loader = new GLTFLoader(manager);
-    loader.load("models/gltf/ShadowmappableMesh.glb", function (obj) {
+    loader.load("models/gltf/ShadowmappableMesh.glb", function(obj) {
         object = obj.scene.children[0];
     });
 
@@ -185,18 +188,18 @@ function render() {
         // Sometimes they will be uniformly sampled from the upper hemisphere
         if (Math.random() > params["Ambient Weight"]) {
             dirLights[l].position.set(
-                lightOrigin.position.x + (Math.random() * params["Light Radius"]),
-                lightOrigin.position.y + (Math.random() * params["Light Radius"]),
-                lightOrigin.position.z + (Math.random() * params["Light Radius"]),
+                lightOrigin!.position.x + Math.random() * params["Light Radius"],
+                lightOrigin!.position.y + Math.random() * params["Light Radius"],
+                lightOrigin!.position.z + Math.random() * params["Light Radius"],
             );
         } else {
             // Uniform Hemispherical Surface Distribution for Ambient Occlusion
-            const lambda = Math.acos(2 * Math.random() - 1) - (3.14159 / 2.0);
+            const lambda = Math.acos(2 * Math.random() - 1) - 3.14159 / 2.0;
             const phi = 2 * 3.14159 * Math.random();
             dirLights[l].position.set(
-                ((Math.cos(lambda) * Math.cos(phi)) * 300) + object.position.x,
-                Math.abs((Math.cos(lambda) * Math.sin(phi)) * 300) + object.position.y + 20,
-                (Math.sin(lambda) * 300) + object.position.z,
+                Math.cos(lambda) * Math.cos(phi) * 300 + object.position.x,
+                Math.abs(Math.cos(lambda) * Math.sin(phi) * 300) + object.position.y + 20,
+                Math.sin(lambda) * 300 + object.position.z,
             );
         }
     }
diff --git a/examples-testing/examples/webgl_shadowmap_viewer.ts b/examples-testing/examples/webgl_shadowmap_viewer.ts
index 6e767bd..c13adbb 100644
--- a/examples-testing/examples/webgl_shadowmap_viewer.ts
+++ b/examples-testing/examples/webgl_shadowmap_viewer.ts
@@ -5,10 +5,14 @@ import Stats from "three/addons/libs/stats.module.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { ShadowMapViewer } from "three/addons/utils/ShadowMapViewer.js";
 
-let camera, scene, renderer, clock, stats;
-let dirLight, spotLight;
-let torusKnot, cube;
-let dirLightShadowMapViewer, spotLightShadowMapViewer;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    stats: Stats;
+let dirLight: THREE.DirectionalLight, spotLight: THREE.SpotLight;
+let torusKnot: THREE.Mesh, cube: THREE.Mesh;
+let dirLightShadowMapViewer: ShadowMapViewer, spotLightShadowMapViewer: ShadowMapViewer;
 
 init();
 animate();
@@ -63,7 +67,7 @@ function initScene() {
     scene.add(new THREE.CameraHelper(dirLight.shadow.camera));
 
     // Geometry
-    let geometry = new THREE.TorusKnotGeometry(25, 8, 75, 20);
+    let geometry: THREE.BufferGeometry = new THREE.TorusKnotGeometry(25, 8, 75, 20);
     let material = new THREE.MeshPhongMaterial({
         color: 0xff0000,
         shininess: 150,
@@ -129,7 +133,7 @@ function resizeShadowMapViewers() {
     dirLightShadowMapViewer.position.y = 10;
     dirLightShadowMapViewer.size.width = size;
     dirLightShadowMapViewer.size.height = size;
-    dirLightShadowMapViewer.update(); //Required when setting position or size directly
+    dirLightShadowMapViewer.update(); // Required when setting position or size directly
 
     spotLightShadowMapViewer.size.set(size, size);
     spotLightShadowMapViewer.position.set(size + 20, 10);
diff --git a/examples-testing/examples/webgl_shadowmap_vsm.ts b/examples-testing/examples/webgl_shadowmap_vsm.ts
index 22a5053..ed6fdc0 100644
--- a/examples-testing/examples/webgl_shadowmap_vsm.ts
+++ b/examples-testing/examples/webgl_shadowmap_vsm.ts
@@ -1,13 +1,17 @@
 import * as THREE from "three";
 
-import Stats from "three/addons/libs/stats.module.js";
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
+import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-let camera, scene, renderer, clock, stats;
-let dirLight, spotLight;
-let torusKnot, dirGroup;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    clock: THREE.Clock,
+    stats: Stats;
+let dirLight: THREE.DirectionalLight, spotLight: THREE.SpotLight;
+let torusKnot: THREE.Mesh, dirGroup: THREE.Group;
 
 init();
 animate();
@@ -27,23 +31,39 @@ function init() {
     };
 
     const spotlightFolder = gui.addFolder("Spotlight");
-    spotlightFolder.add(config, "spotlightRadius").name("radius").min(0).max(25).onChange(function (value) {
-        spotLight.shadow.radius = value;
-    });
-
-    spotlightFolder.add(config, "spotlightSamples", 1, 25, 1).name("samples").onChange(function (value) {
-        spotLight.shadow.blurSamples = value;
-    });
+    spotlightFolder
+        .add(config, "spotlightRadius")
+        .name("radius")
+        .min(0)
+        .max(25)
+        .onChange(function(value) {
+            spotLight.shadow.radius = value;
+        });
+
+    spotlightFolder
+        .add(config, "spotlightSamples", 1, 25, 1)
+        .name("samples")
+        .onChange(function(value) {
+            spotLight.shadow.blurSamples = value;
+        });
     spotlightFolder.open();
 
     const dirlightFolder = gui.addFolder("Directional Light");
-    dirlightFolder.add(config, "dirlightRadius").name("radius").min(0).max(25).onChange(function (value) {
-        dirLight.shadow.radius = value;
-    });
-
-    dirlightFolder.add(config, "dirlightSamples", 1, 25, 1).name("samples").onChange(function (value) {
-        dirLight.shadow.blurSamples = value;
-    });
+    dirlightFolder
+        .add(config, "dirlightRadius")
+        .name("radius")
+        .min(0)
+        .max(25)
+        .onChange(function(value) {
+            dirLight.shadow.radius = value;
+        });
+
+    dirlightFolder
+        .add(config, "dirlightSamples", 1, 25, 1)
+        .name("samples")
+        .onChange(function(value) {
+            dirLight.shadow.blurSamples = value;
+        });
     dirlightFolder.open();
 
     document.body.appendChild(renderer.domElement);
@@ -168,7 +188,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function animate(time) {
+function animate(time?: DOMHighResTimeStamp) {
     requestAnimationFrame(animate);
 
     const delta = clock.getDelta();
@@ -178,7 +198,7 @@ function animate(time) {
     torusKnot.rotation.z += 1 * delta;
 
     dirGroup.rotation.y += 0.7 * delta;
-    dirLight.position.z = 17 + Math.sin(time * 0.001) * 5;
+    dirLight.position.z = 17 + Math.sin(time! * 0.001) * 5;
 
     renderer.render(scene, camera);
 
diff --git a/examples-testing/examples/webgl_shadowmesh.ts b/examples-testing/examples/webgl_shadowmesh.ts
index 87d2e38..ca0189e 100644
--- a/examples-testing/examples/webgl_shadowmesh.ts
+++ b/examples-testing/examples/webgl_shadowmesh.ts
@@ -12,18 +12,18 @@ const renderer = new THREE.WebGLRenderer();
 
 const sunLight = new THREE.DirectionalLight("rgb(255,255,255)", 3);
 let useDirectionalLight = true;
-let arrowHelper1, arrowHelper2, arrowHelper3;
+let arrowHelper1: THREE.ArrowHelper, arrowHelper2: THREE.ArrowHelper, arrowHelper3: THREE.ArrowHelper;
 const arrowDirection = new THREE.Vector3();
 const arrowPosition1 = new THREE.Vector3();
 const arrowPosition2 = new THREE.Vector3();
 const arrowPosition3 = new THREE.Vector3();
-let groundMesh;
-let lightSphere, lightHolder;
-let pyramid, pyramidShadow;
-let sphere, sphereShadow;
-let cube, cubeShadow;
-let cylinder, cylinderShadow;
-let torus, torusShadow;
+let groundMesh: THREE.Mesh<THREE.BoxGeometry, THREE.MeshLambertMaterial>;
+let lightSphere: THREE.Mesh, lightHolder: THREE.Mesh;
+let pyramid: THREE.Mesh, pyramidShadow: ShadowMesh;
+let sphere: THREE.Mesh, sphereShadow: ShadowMesh;
+let cube: THREE.Mesh, cubeShadow: ShadowMesh;
+let cylinder: THREE.Mesh, cylinderShadow: ShadowMesh;
+let torus: THREE.Mesh, torusShadow: ShadowMesh;
 const normalVector = new THREE.Vector3(0, 1, 0);
 const planeConstant = 0.01; // this value must be slightly higher than the groundMesh's y position of 0.0
 const groundPlane = new THREE.Plane(normalVector, planeConstant);
@@ -41,7 +41,7 @@ function init() {
 
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
-    document.getElementById("container").appendChild(renderer.domElement);
+    document.getElementById("container")!.appendChild(renderer.domElement);
     window.addEventListener("resize", onWindowResize);
 
     camera.position.set(0, 2.5, 10);
@@ -91,7 +91,7 @@ function init() {
     const groundGeometry = new THREE.BoxGeometry(30, 0.01, 40);
     const groundMaterial = new THREE.MeshLambertMaterial({ color: "rgb(0,130,0)" });
     groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
-    groundMesh.position.y = 0.0; //this value must be slightly lower than the planeConstant (0.01) parameter above
+    groundMesh.position.y = 0.0; // this value must be slightly lower than the planeConstant (0.01) parameter above
     scene.add(groundMesh);
 
     // RED CUBE and CUBE's SHADOW
@@ -149,7 +149,7 @@ function init() {
     pyramidShadow = new ShadowMesh(pyramid);
     scene.add(pyramidShadow);
 
-    document.getElementById("lightButton").addEventListener("click", lightButtonHandler);
+    document.getElementById("lightButton")!.addEventListener("click", lightButtonHandler);
 }
 
 function animate() {
@@ -169,17 +169,13 @@ function animate() {
     pyramid.rotation.y += 0.5 * frameTime;
 
     horizontalAngle += 0.5 * frameTime;
-    if (horizontalAngle > TWO_PI) {
-        horizontalAngle -= TWO_PI;
-    }
+    if (horizontalAngle > TWO_PI) horizontalAngle -= TWO_PI;
     cube.position.x = Math.sin(horizontalAngle) * 4;
     cylinder.position.x = Math.sin(horizontalAngle) * -4;
     torus.position.x = Math.cos(horizontalAngle) * 4;
 
     verticalAngle += 1.5 * frameTime;
-    if (verticalAngle > TWO_PI) {
-        verticalAngle -= TWO_PI;
-    }
+    if (verticalAngle > TWO_PI) verticalAngle -= TWO_PI;
     cube.position.y = Math.sin(verticalAngle) * 2 + 2.9;
     cylinder.position.y = Math.sin(verticalAngle) * 2 + 3.1;
     torus.position.y = Math.cos(verticalAngle) * 2 + 3.3;
@@ -208,7 +204,7 @@ function lightButtonHandler() {
     useDirectionalLight = !useDirectionalLight;
 
     if (useDirectionalLight) {
-        scene.background.setHex(0x0096ff);
+        (scene.background as THREE.Color).setHex(0x0096ff);
 
         groundMesh.material.color.setHex(0x008200);
         sunLight.position.set(5, 7, -1);
@@ -226,9 +222,9 @@ function lightButtonHandler() {
         lightSphere.visible = false;
         lightHolder.visible = false;
 
-        document.getElementById("lightButton").value = "Switch to PointLight";
+        (document.getElementById("lightButton") as HTMLButtonElement).value = "Switch to PointLight";
     } else {
-        scene.background.setHex(0x000000);
+        (scene.background as THREE.Color).setHex(0x000000);
 
         groundMesh.material.color.setHex(0x969696);
 
@@ -250,6 +246,6 @@ function lightButtonHandler() {
         lightSphere.visible = true;
         lightHolder.visible = true;
 
-        document.getElementById("lightButton").value = "Switch to THREE.DirectionalLight";
+        (document.getElementById("lightButton") as HTMLButtonElement).value = "Switch to THREE.DirectionalLight";
     }
 }
diff --git a/examples-testing/examples/webgl_simple_gi.ts b/examples-testing/examples/webgl_simple_gi.ts
index 232e95b..5a72387 100644
--- a/examples-testing/examples/webgl_simple_gi.ts
+++ b/examples-testing/examples/webgl_simple_gi.ts
@@ -3,7 +3,7 @@ import * as THREE from "three";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
 class GIMesh extends THREE.Mesh {
-    copy(source) {
+    copy(source: this) {
         super.copy(source);
 
         this.geometry = source.geometry.clone();
@@ -14,103 +14,109 @@ class GIMesh extends THREE.Mesh {
 
 //
 
-const SimpleGI = function (renderer, scene) {
-    const SIZE = 32, SIZE2 = SIZE * SIZE;
+class SimpleGI {
+    constructor(renderer: THREE.WebGLRenderer, scene: THREE.Scene) {
+        const SIZE = 32,
+            SIZE2 = SIZE * SIZE;
 
-    const camera = new THREE.PerspectiveCamera(90, 1, 0.01, 100);
+        const camera = new THREE.PerspectiveCamera(90, 1, 0.01, 100);
 
-    scene.updateMatrixWorld(true);
+        scene.updateMatrixWorld(true);
 
-    let clone = scene.clone();
-    clone.matrixWorldAutoUpdate = false;
+        let clone = scene.clone();
+        clone.matrixWorldAutoUpdate = false;
 
-    const rt = new THREE.WebGLRenderTarget(SIZE, SIZE);
+        const rt = new THREE.WebGLRenderTarget(SIZE, SIZE);
 
-    const normalMatrix = new THREE.Matrix3();
+        const normalMatrix = new THREE.Matrix3();
 
-    const position = new THREE.Vector3();
-    const normal = new THREE.Vector3();
+        const position = new THREE.Vector3();
+        const normal = new THREE.Vector3();
 
-    let bounces = 0;
-    let currentVertex = 0;
+        let bounces = 0;
+        let currentVertex = 0;
 
-    const color = new Float32Array(3);
-    const buffer = new Uint8Array(SIZE2 * 4);
+        const color = new Float32Array(3);
+        const buffer = new Uint8Array(SIZE2 * 4);
 
-    function compute() {
-        if (bounces === 3) return;
+        function compute() {
+            if (bounces === 3) return;
 
-        const object = scene.children[0]; // torusKnot
-        const geometry = object.geometry;
+            const object = scene.children[0] as GIMesh; // torusKnot
+            const geometry = object.geometry;
 
-        const attributes = geometry.attributes;
-        const positions = attributes.position.array;
-        const normals = attributes.normal.array;
+            const attributes = geometry.attributes;
+            const positions = attributes.position.array;
+            const normals = attributes.normal.array;
 
-        if (attributes.color === undefined) {
-            const colors = new Float32Array(positions.length);
-            geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));
-        }
+            if (attributes.color === undefined) {
+                const colors = new Float32Array(positions.length);
+                geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));
+            }
 
-        const colors = attributes.color.array;
+            const colors = attributes.color.array;
 
-        const startVertex = currentVertex;
-        const totalVertex = positions.length / 3;
+            const startVertex = currentVertex;
+            const totalVertex = positions.length / 3;
 
-        for (let i = 0; i < 32; i++) {
-            if (currentVertex >= totalVertex) break;
+            for (let i = 0; i < 32; i++) {
+                if (currentVertex >= totalVertex) break;
 
-            position.fromArray(positions, currentVertex * 3);
-            position.applyMatrix4(object.matrixWorld);
+                position.fromArray(positions, currentVertex * 3);
+                position.applyMatrix4(object.matrixWorld);
 
-            normal.fromArray(normals, currentVertex * 3);
-            normal.applyMatrix3(normalMatrix.getNormalMatrix(object.matrixWorld)).normalize();
+                normal.fromArray(normals, currentVertex * 3);
+                normal.applyMatrix3(normalMatrix.getNormalMatrix(object.matrixWorld)).normalize();
 
-            camera.position.copy(position);
-            camera.lookAt(position.add(normal));
+                camera.position.copy(position);
+                camera.lookAt(position.add(normal));
 
-            renderer.setRenderTarget(rt);
-            renderer.render(clone, camera);
+                renderer.setRenderTarget(rt);
+                renderer.render(clone, camera);
 
-            renderer.readRenderTargetPixels(rt, 0, 0, SIZE, SIZE, buffer);
+                renderer.readRenderTargetPixels(rt, 0, 0, SIZE, SIZE, buffer);
 
-            color[0] = 0;
-            color[1] = 0;
-            color[2] = 0;
+                color[0] = 0;
+                color[1] = 0;
+                color[2] = 0;
 
-            for (let k = 0, kl = buffer.length; k < kl; k += 4) {
-                color[0] += buffer[k + 0];
-                color[1] += buffer[k + 1];
-                color[2] += buffer[k + 2];
-            }
+                for (let k = 0, kl = buffer.length; k < kl; k += 4) {
+                    color[0] += buffer[k + 0];
+                    color[1] += buffer[k + 1];
+                    color[2] += buffer[k + 2];
+                }
 
-            colors[currentVertex * 3 + 0] = color[0] / (SIZE2 * 255);
-            colors[currentVertex * 3 + 1] = color[1] / (SIZE2 * 255);
-            colors[currentVertex * 3 + 2] = color[2] / (SIZE2 * 255);
+                colors[currentVertex * 3 + 0] = color[0] / (SIZE2 * 255);
+                colors[currentVertex * 3 + 1] = color[1] / (SIZE2 * 255);
+                colors[currentVertex * 3 + 2] = color[2] / (SIZE2 * 255);
 
-            currentVertex++;
-        }
+                currentVertex++;
+            }
 
-        attributes.color.addUpdateRange(startVertex * 3, (currentVertex - startVertex) * 3);
-        attributes.color.needsUpdate = true;
+            (attributes.color as THREE.BufferAttribute).addUpdateRange(
+                startVertex * 3,
+                (currentVertex - startVertex) * 3,
+            );
+            attributes.color.needsUpdate = true;
 
-        if (currentVertex >= totalVertex) {
-            clone = scene.clone();
-            clone.matrixWorldAutoUpdate = false;
+            if (currentVertex >= totalVertex) {
+                clone = scene.clone();
+                clone.matrixWorldAutoUpdate = false;
 
-            bounces++;
-            currentVertex = 0;
+                bounces++;
+                currentVertex = 0;
+            }
+
+            requestAnimationFrame(compute);
         }
 
         requestAnimationFrame(compute);
     }
-
-    requestAnimationFrame(compute);
-};
+}
 
 //
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
diff --git a/examples-testing/examples/webgl_sprites.ts b/examples-testing/examples/webgl_sprites.ts
index 806f217..43ebb0f 100644
--- a/examples-testing/examples/webgl_sprites.ts
+++ b/examples-testing/examples/webgl_sprites.ts
@@ -1,13 +1,17 @@
 import * as THREE from "three";
 
-let camera, scene, renderer;
-let cameraOrtho, sceneOrtho;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let cameraOrtho: THREE.OrthographicCamera, sceneOrtho: THREE.Scene;
 
-let spriteTL, spriteTR, spriteBL, spriteBR, spriteC;
+let spriteTL: THREE.Sprite,
+    spriteTR: THREE.Sprite,
+    spriteBL: THREE.Sprite,
+    spriteBR: THREE.Sprite,
+    spriteC: THREE.Sprite;
 
-let mapC;
+let mapC: THREE.Texture;
 
-let group;
+let group: THREE.Group;
 
 init();
 animate();
@@ -58,8 +62,8 @@ function init() {
         } else {
             material = materialC.clone();
             material.color.setHSL(0.5 * Math.random(), 0.75, 0.5);
-            material.map.offset.set(-0.5, -0.5);
-            material.map.repeat.set(2, 2);
+            material.map!.offset.set(-0.5, -0.5);
+            material.map!.repeat.set(2, 2);
         }
 
         const sprite = new THREE.Sprite(material);
@@ -87,13 +91,13 @@ function init() {
     window.addEventListener("resize", onWindowResize);
 }
 
-function createHUDSprites(texture) {
+function createHUDSprites(texture: THREE.Texture) {
     texture.colorSpace = THREE.SRGBColorSpace;
 
     const material = new THREE.SpriteMaterial({ map: texture });
 
-    const width = material.map.image.width;
-    const height = material.map.image.height;
+    const width = material.map!.image.width;
+    const height = material.map!.image.height;
 
     spriteTL = new THREE.Sprite(material);
     spriteTL.center.set(0.0, 1.0);
@@ -161,7 +165,7 @@ function render() {
     const time = Date.now() / 1000;
 
     for (let i = 0, l = group.children.length; i < l; i++) {
-        const sprite = group.children[i];
+        const sprite = group.children[i] as THREE.Sprite;
         const material = sprite.material;
         const scale = Math.sin(time + sprite.position.x * 0.01) * 0.3 + 1.0;
 
diff --git a/examples-testing/examples/webgl_test_memory.ts b/examples-testing/examples/webgl_test_memory.ts
index 5e27c79..131f1f2 100644
--- a/examples-testing/examples/webgl_test_memory.ts
+++ b/examples-testing/examples/webgl_test_memory.ts
@@ -1,6 +1,6 @@
 import * as THREE from "three";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
@@ -26,9 +26,14 @@ function createImage() {
     canvas.width = 256;
     canvas.height = 256;
 
-    const context = canvas.getContext("2d");
-    context.fillStyle = "rgb(" + Math.floor(Math.random() * 256) + "," + Math.floor(Math.random() * 256) + "," +
-        Math.floor(Math.random() * 256) + ")";
+    const context = canvas.getContext("2d")!;
+    context.fillStyle = "rgb("
+        + Math.floor(Math.random() * 256)
+        + ","
+        + Math.floor(Math.random() * 256)
+        + ","
+        + Math.floor(Math.random() * 256)
+        + ")";
     context.fillRect(0, 0, 256, 256);
 
     return canvas;
diff --git a/examples-testing/examples/webgl_test_memory2.ts b/examples-testing/examples/webgl_test_memory2.ts
index 2d2bb7c..cc46e49 100644
--- a/examples-testing/examples/webgl_test_memory2.ts
+++ b/examples-testing/examples/webgl_test_memory2.ts
@@ -2,15 +2,15 @@ import * as THREE from "three";
 
 const N = 100;
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
-let geometry;
+let geometry: THREE.SphereGeometry;
 
-const meshes = [];
+const meshes: THREE.Mesh<THREE.SphereGeometry, THREE.ShaderMaterial>[] = [];
 
-let fragmentShader, vertexShader;
+let fragmentShader: string, vertexShader: string;
 
 init();
 setInterval(render, 1000 / 60);
@@ -19,8 +19,8 @@ function init() {
     container = document.createElement("div");
     document.body.appendChild(container);
 
-    vertexShader = document.getElementById("vertexShader").textContent;
-    fragmentShader = document.getElementById("fragmentShader").textContent;
+    vertexShader = document.getElementById("vertexShader")!.textContent!;
+    fragmentShader = document.getElementById("fragmentShader")!.textContent!;
 
     camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
     camera.position.z = 2000;
@@ -70,12 +70,12 @@ function render() {
 
     renderer.render(scene, camera);
 
-    console.log("before", renderer.info.programs.length);
+    console.log("before", renderer.info.programs!.length);
 
     for (let i = 0; i < N; i++) {
         const mesh = meshes[i];
         mesh.material.dispose();
     }
 
-    console.log("after", renderer.info.programs.length);
+    console.log("after", renderer.info.programs!.length);
 }
diff --git a/examples-testing/examples/webgl_test_wide_gamut.ts b/examples-testing/examples/webgl_test_wide_gamut.ts
index 0b0e50d..15171c9 100644
--- a/examples-testing/examples/webgl_test_wide_gamut.ts
+++ b/examples-testing/examples/webgl_test_wide_gamut.ts
@@ -2,8 +2,8 @@ import * as THREE from "three";
 
 import WebGL from "three/addons/capabilities/WebGL.js";
 
-let container, camera, renderer, loader;
-let sceneL, sceneR, textureL, textureR;
+let container: HTMLElement, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, loader: THREE.TextureLoader;
+let sceneL: THREE.Scene, sceneR: THREE.Scene, textureL: THREE.Texture, textureR: THREE.Texture;
 
 let sliderPos = window.innerWidth / 2;
 
@@ -16,7 +16,7 @@ if (isP3Context) {
 init();
 
 function init() {
-    container = document.querySelector(".container");
+    container = document.querySelector(".container")!;
 
     sceneL = new THREE.Scene();
     sceneR = new THREE.Scene();
@@ -58,9 +58,9 @@ async function initTextures() {
 }
 
 function initSlider() {
-    const slider = document.querySelector(".slider");
+    const slider = document.querySelector(".slider") as HTMLElement;
 
-    function onPointerDown() {
+    function onPointerDown(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
         window.addEventListener("pointermove", onPointerMove);
@@ -72,12 +72,12 @@ function initSlider() {
         window.removeEventListener("pointerup", onPointerUp);
     }
 
-    function onPointerMove(e) {
+    function onPointerMove(event: PointerEvent) {
         if (event.isPrimary === false) return;
 
-        sliderPos = Math.max(0, Math.min(window.innerWidth, e.pageX));
+        sliderPos = Math.max(0, Math.min(window.innerWidth, event.pageX));
 
-        slider.style.left = sliderPos - (slider.offsetWidth / 2) + "px";
+        slider.style.left = sliderPos - slider.offsetWidth / 2 + "px";
     }
 
     slider.style.touchAction = "none"; // disable touch scroll
@@ -90,23 +90,23 @@ function onWindowResize() {
 
     renderer.setSize(window.innerWidth, window.innerHeight);
 
-    containTexture(window.innerWidth / window.innerHeight, sceneL.background);
-    containTexture(window.innerWidth / window.innerHeight, sceneR.background);
+    containTexture(window.innerWidth / window.innerHeight, sceneL.background as THREE.Texture);
+    containTexture(window.innerWidth / window.innerHeight, sceneR.background as THREE.Texture);
 }
 
-function onGamutChange({ matches }) {
+function onGamutChange({ matches }: MediaQueryListEvent) {
     renderer.outputColorSpace = isP3Context && matches ? THREE.DisplayP3ColorSpace : THREE.SRGBColorSpace;
 
     textureL.needsUpdate = true;
     textureR.needsUpdate = true;
 }
 
-function containTexture(aspect, target) {
+function containTexture(aspect: number, target: THREE.Texture) {
     // Sets the matrix uv transform so the texture image is contained in a region having the specified aspect ratio,
     // and does so without distortion. Akin to CSS object-fit: contain.
     // Source: https://github.com/mrdoob/three.js/pull/17199
 
-    var imageAspect = (target.image && target.image.width) ? target.image.width / target.image.height : 1;
+    var imageAspect = target.image && target.image.width ? target.image.width / target.image.height : 1;
 
     if (aspect > imageAspect) {
         target.matrix.setUvTransform(0, 0, aspect / imageAspect, 1, 0, 0.5, 0.5);
diff --git a/examples-testing/examples/webgl_tonemapping.ts b/examples-testing/examples/webgl_tonemapping.ts
index abe8bb7..6992d07 100644
--- a/examples-testing/examples/webgl_tonemapping.ts
+++ b/examples-testing/examples/webgl_tonemapping.ts
@@ -1,21 +1,35 @@
 import * as THREE from "three";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI, NumberController } from "three/addons/libs/lil-gui.module.min.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 
-let mesh, renderer, scene, camera, controls;
-let gui, guiExposure = null;
+type ToneMapping = "None" | "Linear" | "Reinhard" | "Cineon" | "ACESFilmic" | "AgX" | "Custom";
 
-const params = {
+interface Params {
+    exposure: number;
+    toneMapping: ToneMapping;
+    blurriness: number;
+    intensity: number;
+}
+
+let mesh: THREE.Object3D,
+    renderer: THREE.WebGLRenderer,
+    scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    controls: OrbitControls;
+let gui: GUI,
+    guiExposure: NumberController<Params, "exposure"> | null = null;
+
+const params: Params = {
     exposure: 1.0,
     toneMapping: "AgX",
     blurriness: 0.3,
     intensity: 1.0,
 };
 
-const toneMappingOptions = {
+const toneMappingOptions: { [K in ToneMapping]: THREE.ToneMapping } = {
     None: THREE.NoToneMapping,
     Linear: THREE.LinearToneMapping,
     Reinhard: THREE.ReinhardToneMapping,
@@ -25,7 +39,7 @@ const toneMappingOptions = {
     Custom: THREE.CustomToneMapping,
 };
 
-init().catch(function (err) {
+init().catch(function(err) {
     console.error(err);
 });
 
@@ -67,8 +81,7 @@ async function init() {
     controls.target.set(0, 0, -0.2);
     controls.update();
 
-    const rgbeLoader = new RGBELoader()
-        .setPath("textures/equirectangular/");
+    const rgbeLoader = new RGBELoader().setPath("textures/equirectangular/");
 
     const gltfLoader = new GLTFLoader().setPath("models/gltf/DamagedHelmet/glTF/");
 
@@ -86,7 +99,7 @@ async function init() {
 
     // model
 
-    mesh = gltf.scene.getObjectByName("node_damagedHelmet_-6514");
+    mesh = gltf.scene.getObjectByName("node_damagedHelmet_-6514")!;
     scene.add(mesh);
 
     render();
@@ -96,8 +109,9 @@ async function init() {
     gui = new GUI();
     const toneMappingFolder = gui.addFolder("tone mapping");
 
-    toneMappingFolder.add(params, "toneMapping", Object.keys(toneMappingOptions))
-        .onChange(function () {
+    toneMappingFolder
+        .add(params, "toneMapping", Object.keys(toneMappingOptions) as ToneMapping[])
+        .onChange(function() {
             updateGUI(toneMappingFolder);
 
             renderer.toneMapping = toneMappingOptions[params.toneMapping];
@@ -106,14 +120,16 @@ async function init() {
 
     const backgroundFolder = gui.addFolder("background");
 
-    backgroundFolder.add(params, "blurriness", 0, 1)
-        .onChange(function (value) {
+    backgroundFolder
+        .add(params, "blurriness", 0, 1)
+        .onChange(function(value) {
             scene.backgroundBlurriness = value;
             render();
         });
 
-    backgroundFolder.add(params, "intensity", 0, 1)
-        .onChange(function (value) {
+    backgroundFolder
+        .add(params, "intensity", 0, 1)
+        .onChange(function(value) {
             scene.backgroundIntensity = value;
             render();
         });
@@ -123,15 +139,16 @@ async function init() {
     gui.open();
 }
 
-function updateGUI(folder) {
+function updateGUI(folder: GUI) {
     if (guiExposure !== null) {
         guiExposure.destroy();
         guiExposure = null;
     }
 
     if (params.toneMapping !== "None") {
-        guiExposure = folder.add(params, "exposure", 0, 2)
-            .onChange(function () {
+        guiExposure = folder
+            .add(params, "exposure", 0, 2)
+            .onChange(function() {
                 renderer.toneMappingExposure = params.exposure;
                 render();
             });
diff --git a/examples-testing/examples/webgl_video_kinect.ts b/examples-testing/examples/webgl_video_kinect.ts
index e33ea81..d313ba0 100644
--- a/examples-testing/examples/webgl_video_kinect.ts
+++ b/examples-testing/examples/webgl_video_kinect.ts
@@ -2,9 +2,9 @@ import * as THREE from "three";
 
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let scene, camera, renderer;
-let geometry, mesh, material;
-let mouse, center;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer;
+let geometry: THREE.BufferGeometry, mesh: THREE.Points, material: THREE.ShaderMaterial;
+let mouse: THREE.Vector3, center: THREE.Vector3;
 
 init();
 animate();
@@ -15,7 +15,7 @@ function init() {
 
     const info = document.createElement("div");
     info.id = "info";
-    info.innerHTML = '<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - kinect';
+    info.innerHTML = "<a href=\"https://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a> - kinect";
     document.body.appendChild(info);
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
@@ -25,13 +25,15 @@ function init() {
     center = new THREE.Vector3();
     center.z = -1000;
 
-    const video = document.getElementById("video");
+    const video = document.getElementById("video") as HTMLVideoElement;
 
     const texture = new THREE.VideoTexture(video);
     texture.minFilter = THREE.NearestFilter;
 
-    const width = 640, height = 480;
-    const nearClipping = 850, farClipping = 4000;
+    const width = 640,
+        height = 480;
+    const nearClipping = 850,
+        farClipping = 4000;
 
     geometry = new THREE.BufferGeometry();
 
@@ -46,17 +48,17 @@ function init() {
 
     material = new THREE.ShaderMaterial({
         uniforms: {
-            "map": { value: texture },
-            "width": { value: width },
-            "height": { value: height },
-            "nearClipping": { value: nearClipping },
-            "farClipping": { value: farClipping },
-
-            "pointSize": { value: 2 },
-            "zOffset": { value: 1000 },
+            map: { value: texture },
+            width: { value: width },
+            height: { value: height },
+            nearClipping: { value: nearClipping },
+            farClipping: { value: farClipping },
+
+            pointSize: { value: 2 },
+            zOffset: { value: 1000 },
         },
-        vertexShader: document.getElementById("vs").textContent,
-        fragmentShader: document.getElementById("fs").textContent,
+        vertexShader: document.getElementById("vs")!.textContent!,
+        fragmentShader: document.getElementById("fs")!.textContent!,
         blending: THREE.AdditiveBlending,
         depthTest: false,
         depthWrite: false,
@@ -97,7 +99,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouse.x = (event.clientX - window.innerWidth / 2) * 8;
     mouse.y = (event.clientY - window.innerHeight / 2) * 8;
 }
diff --git a/examples-testing/examples/webgl_video_panorama_equirectangular.ts b/examples-testing/examples/webgl_video_panorama_equirectangular.ts
index 3a46871..06d55d7 100644
--- a/examples-testing/examples/webgl_video_panorama_equirectangular.ts
+++ b/examples-testing/examples/webgl_video_panorama_equirectangular.ts
@@ -1,6 +1,6 @@
 import * as THREE from "three";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 let isUserInteracting = false,
     lon = 0,
@@ -12,15 +12,15 @@ let isUserInteracting = false,
     onPointerDownLon = 0,
     onPointerDownLat = 0;
 
-const distance = .5;
+const distance = 0.5;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
-    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, .25, 10);
+    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.25, 10);
 
     scene = new THREE.Scene();
 
@@ -28,7 +28,7 @@ function init() {
     // invert the geometry on the x-axis so that all of the faces point inward
     geometry.scale(-1, 1, 1);
 
-    const video = document.getElementById("video");
+    const video = document.getElementById("video") as HTMLVideoElement;
     video.play();
 
     const texture = new THREE.VideoTexture(video);
@@ -59,7 +59,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     isUserInteracting = true;
 
     onPointerDownPointerX = event.clientX;
@@ -69,7 +69,7 @@ function onPointerDown(event) {
     onPointerDownLat = lat;
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (isUserInteracting === true) {
         lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
         lat = (onPointerDownPointerY - event.clientY) * 0.1 + onPointerDownLat;
diff --git a/examples-testing/examples/webgl_water.ts b/examples-testing/examples/webgl_water.ts
index e5019b8..8a2b0b9 100644
--- a/examples-testing/examples/webgl_water.ts
+++ b/examples-testing/examples/webgl_water.ts
@@ -1,12 +1,16 @@
 import * as THREE from "three";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { Water } from "three/addons/objects/Water2.js";
 
-let scene, camera, clock, renderer, water;
+let scene: THREE.Scene,
+    camera: THREE.PerspectiveCamera,
+    clock: THREE.Clock,
+    renderer: THREE.WebGLRenderer,
+    water: Water;
 
-let torusKnot;
+let torusKnot: THREE.Mesh;
 
 const params = {
     color: "#ffffff",
@@ -52,7 +56,7 @@ function init() {
     scene.add(ground);
 
     const textureLoader = new THREE.TextureLoader();
-    textureLoader.load("textures/hardwood2_diffuse.jpg", function (map) {
+    textureLoader.load("textures/hardwood2_diffuse.jpg", function(map) {
         map.wrapS = THREE.RepeatWrapping;
         map.wrapT = THREE.RepeatWrapping;
         map.anisotropy = 16;
@@ -114,20 +118,24 @@ function init() {
 
     const gui = new GUI();
 
-    gui.addColor(params, "color").onChange(function (value) {
+    gui.addColor(params, "color").onChange(function(value) {
         water.material.uniforms["color"].value.set(value);
     });
-    gui.add(params, "scale", 1, 10).onChange(function (value) {
+    gui.add(params, "scale", 1, 10).onChange(function(value) {
         water.material.uniforms["config"].value.w = value;
     });
-    gui.add(params, "flowX", -1, 1).step(0.01).onChange(function (value) {
-        water.material.uniforms["flowDirection"].value.x = value;
-        water.material.uniforms["flowDirection"].value.normalize();
-    });
-    gui.add(params, "flowY", -1, 1).step(0.01).onChange(function (value) {
-        water.material.uniforms["flowDirection"].value.y = value;
-        water.material.uniforms["flowDirection"].value.normalize();
-    });
+    gui.add(params, "flowX", -1, 1)
+        .step(0.01)
+        .onChange(function(value) {
+            water.material.uniforms["flowDirection"].value.x = value;
+            water.material.uniforms["flowDirection"].value.normalize();
+        });
+    gui.add(params, "flowY", -1, 1)
+        .step(0.01)
+        .onChange(function(value) {
+            water.material.uniforms["flowDirection"].value.y = value;
+            water.material.uniforms["flowDirection"].value.normalize();
+        });
 
     gui.open();
 
diff --git a/examples-testing/examples/webgl_water_flowmap.ts b/examples-testing/examples/webgl_water_flowmap.ts
index b2839b8..ef92dc7 100644
--- a/examples-testing/examples/webgl_water_flowmap.ts
+++ b/examples-testing/examples/webgl_water_flowmap.ts
@@ -1,10 +1,10 @@
 import * as THREE from "three";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { Water } from "three/addons/objects/Water2.js";
 
-let scene, camera, renderer, water;
+let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, water: Water;
 
 init();
 animate();
@@ -29,7 +29,7 @@ function init() {
     scene.add(ground);
 
     const textureLoader = new THREE.TextureLoader();
-    textureLoader.load("textures/floors/FloorsCheckerboard_S_Diffuse.jpg", function (map) {
+    textureLoader.load("textures/floors/FloorsCheckerboard_S_Diffuse.jpg", function(map) {
         map.wrapS = THREE.RepeatWrapping;
         map.wrapT = THREE.RepeatWrapping;
         map.anisotropy = 16;
diff --git a/examples-testing/examples/webgpu_camera_logarithmicdepthbuffer.ts b/examples-testing/examples/webgpu_camera_logarithmicdepthbuffer.ts
index 3329e67..630b480 100644
--- a/examples-testing/examples/webgpu_camera_logarithmicdepthbuffer.ts
+++ b/examples-testing/examples/webgpu_camera_logarithmicdepthbuffer.ts
@@ -1,34 +1,45 @@
 import * as THREE from "three";
 
-import { FontLoader } from "three/addons/loaders/FontLoader.js";
 import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
+import { Font, FontLoader } from "three/addons/loaders/FontLoader.js";
 
-import WebGPU from "three/addons/capabilities/WebGPU.js";
 import WebGL from "three/addons/capabilities/WebGL.js";
+import WebGPU from "three/addons/capabilities/WebGPU.js";
 
 import WebGPURenderer from "three/addons/renderers/webgpu/WebGPURenderer.js";
 
 import Stats from "three/addons/libs/stats.module.js";
 
 // 1 micrometer to 100 billion light years in one scene, with 1 unit = 1 meter?  preposterous!  and yet...
-const NEAR = 1e-6, FAR = 1e27;
+const NEAR = 1e-6,
+    FAR = 1e27;
 let SCREEN_WIDTH = window.innerWidth;
 let SCREEN_HEIGHT = window.innerHeight;
-let screensplit = .25, screensplit_right = 0;
-const mouse = [.5, .5];
-let zoompos = -100, minzoomspeed = .015;
+let screensplit = 0.25,
+    screensplit_right = 0;
+const mouse = [0.5, 0.5];
+let zoompos = -100,
+    minzoomspeed = 0.015;
 let zoomspeed = minzoomspeed;
 
-let container, border, stats;
-const objects = {};
+let container: HTMLElement, border: HTMLElement, stats: Stats;
+
+interface ObjectView {
+    container: HTMLElement;
+    renderer: WebGPURenderer;
+    scene: THREE.Scene;
+    camera: THREE.PerspectiveCamera;
+}
+
+const objects: { normal?: ObjectView; logzbuf?: ObjectView } = {};
 
 // Generate a number of text labels, from 1m in size up to 100,000,000 light years
 // Try to use some descriptive real-world examples of objects at each scale
 
 const labeldata = [
-    { size: .01, scale: 0.0001, label: "microscopic (1m)" }, // FIXME - triangulating text fails at this size, so we scale instead
-    { size: .01, scale: 0.1, label: "minuscule (1mm)" },
-    { size: .01, scale: 1.0, label: "tiny (1cm)" },
+    { size: 0.01, scale: 0.0001, label: "microscopic (1m)" }, // FIXME - triangulating text fails at this size, so we scale instead
+    { size: 0.01, scale: 0.1, label: "minuscule (1mm)" },
+    { size: 0.01, scale: 1.0, label: "tiny (1cm)" },
     { size: 1, scale: 1.0, label: "child-sized (1m)" },
     { size: 10, scale: 1.0, label: "tree-sized (10m)" },
     { size: 100, scale: 1.0, label: "building-sized (100m)" },
@@ -52,10 +63,10 @@ function init() {
         throw new Error("No WebGPU or WebGL2 support");
     }
 
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     const loader = new FontLoader();
-    loader.load("fonts/helvetiker_regular.typeface.json", function (font) {
+    loader.load("fonts/helvetiker_regular.typeface.json", function(font) {
         const scene = initScene(font);
 
         // Initialize two copies of the same scene, one with normal z-buffer and one with logarithmic z-buffer
@@ -67,7 +78,7 @@ function init() {
     container.appendChild(stats.dom);
 
     // Resize border allows the user to easily compare effects of logarithmic depth buffer over the whole scene
-    border = document.getElementById("renderer_border");
+    border = document.getElementById("renderer_border")!;
     border.addEventListener("pointerdown", onBorderPointerDown);
 
     window.addEventListener("mousemove", onMouseMove);
@@ -75,10 +86,10 @@ function init() {
     window.addEventListener("wheel", onMouseWheel);
 }
 
-function initView(scene, name, logDepthBuf) {
-    const framecontainer = document.getElementById("container_" + name);
+function initView(scene: THREE.Scene, name: string, logDepthBuf: boolean) {
+    const framecontainer = document.getElementById("container_" + name)!;
 
-    const camera = new THREE.PerspectiveCamera(50, screensplit * SCREEN_WIDTH / SCREEN_HEIGHT, NEAR, FAR);
+    const camera = new THREE.PerspectiveCamera(50, (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT, NEAR, FAR);
     scene.add(camera);
 
     const renderer = new WebGPURenderer({ antialias: true, logarithmicDepthBuffer: logDepthBuf });
@@ -92,7 +103,7 @@ function initView(scene, name, logDepthBuf) {
     return { container: framecontainer, renderer: renderer, scene: scene, camera: camera };
 }
 
-function initScene(font) {
+function initScene(font: Font) {
     const scene = new THREE.Scene();
 
     scene.add(new THREE.AmbientLight(0x777777));
@@ -101,7 +112,7 @@ function initScene(font) {
     light.position.set(100, 100, 100);
     scene.add(light);
 
-    const materialargs = {
+    const materialargs: { color: THREE.ColorRepresentation; specular: number; shininess: number; emissive: number } = {
         color: 0xffffff,
         specular: 0x050505,
         shininess: 50,
@@ -122,7 +133,7 @@ function initScene(font) {
         labelgeo.computeBoundingSphere();
 
         // center text
-        labelgeo.translate(-labelgeo.boundingSphere.radius, 0, 0);
+        labelgeo.translate(-labelgeo.boundingSphere!.radius, 0, 0);
 
         materialargs.color = new THREE.Color().setHSL(Math.random(), 0.5, 0.5);
 
@@ -135,11 +146,11 @@ function initScene(font) {
         const textmesh = new THREE.Mesh(labelgeo, material);
         textmesh.scale.set(scale, scale, scale);
         textmesh.position.z = -labeldata[i].size * scale;
-        textmesh.position.y = labeldata[i].size / 4 * scale;
+        textmesh.position.y = (labeldata[i].size / 4) * scale;
         group.add(textmesh);
 
         const dotmesh = new THREE.Mesh(geometry, material);
-        dotmesh.position.y = -labeldata[i].size / 4 * scale;
+        dotmesh.position.y = (-labeldata[i].size / 4) * scale;
         dotmesh.scale.multiplyScalar(labeldata[i].size * scale);
         group.add(dotmesh);
     }
@@ -155,16 +166,16 @@ function updateRendererSizes() {
 
     screensplit_right = 1 - screensplit;
 
-    objects.normal.renderer.setSize(screensplit * SCREEN_WIDTH, SCREEN_HEIGHT);
-    objects.normal.camera.aspect = screensplit * SCREEN_WIDTH / SCREEN_HEIGHT;
-    objects.normal.camera.updateProjectionMatrix();
-    objects.normal.camera.setViewOffset(SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT);
-    objects.normal.container.style.width = (screensplit * 100) + "%";
+    objects.normal!.renderer.setSize(screensplit * SCREEN_WIDTH, SCREEN_HEIGHT);
+    objects.normal!.camera.aspect = (screensplit * SCREEN_WIDTH) / SCREEN_HEIGHT;
+    objects.normal!.camera.updateProjectionMatrix();
+    objects.normal!.camera.setViewOffset(SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT);
+    objects.normal!.container.style.width = screensplit * 100 + "%";
 
-    objects.logzbuf.renderer.setSize(screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT);
-    objects.logzbuf.camera.aspect = screensplit_right * SCREEN_WIDTH / SCREEN_HEIGHT;
-    objects.logzbuf.camera.updateProjectionMatrix();
-    objects.logzbuf.camera.setViewOffset(
+    objects.logzbuf!.renderer.setSize(screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT);
+    objects.logzbuf!.camera.aspect = (screensplit_right * SCREEN_WIDTH) / SCREEN_HEIGHT;
+    objects.logzbuf!.camera.updateProjectionMatrix();
+    objects.logzbuf!.camera.setViewOffset(
         SCREEN_WIDTH,
         SCREEN_HEIGHT,
         SCREEN_WIDTH * screensplit,
@@ -172,16 +183,16 @@ function updateRendererSizes() {
         SCREEN_WIDTH * screensplit_right,
         SCREEN_HEIGHT,
     );
-    objects.logzbuf.container.style.width = (screensplit_right * 100) + "%";
+    objects.logzbuf!.container.style.width = screensplit_right * 100 + "%";
 
-    border.style.left = (screensplit * 100) + "%";
+    border.style.left = screensplit * 100 + "%";
 }
 
 function render() {
     // Put some limits on zooming
     const minzoom = labeldata[0].size * labeldata[0].scale * 1;
     const maxzoom = labeldata[labeldata.length - 1].size * labeldata[labeldata.length - 1].scale * 100;
-    let damping = Math.abs(zoomspeed) > minzoomspeed ? .95 : 1.0;
+    let damping = Math.abs(zoomspeed) > minzoomspeed ? 0.95 : 1.0;
 
     // Zoom out faster the further out you go
     const zoom = THREE.MathUtils.clamp(Math.pow(Math.E, zoompos), minzoom, maxzoom);
@@ -189,28 +200,28 @@ function render() {
 
     // Slow down quickly at the zoom limits
     if ((zoom == minzoom && zoomspeed < 0) || (zoom == maxzoom && zoomspeed > 0)) {
-        damping = .85;
+        damping = 0.85;
     }
 
     zoompos += zoomspeed;
     zoomspeed *= damping;
 
-    objects.normal.camera.position.x = Math.sin(.5 * Math.PI * (mouse[0] - .5)) * zoom;
-    objects.normal.camera.position.y = Math.sin(.25 * Math.PI * (mouse[1] - .5)) * zoom;
-    objects.normal.camera.position.z = Math.cos(.5 * Math.PI * (mouse[0] - .5)) * zoom;
-    objects.normal.camera.lookAt(objects.normal.scene.position);
+    objects.normal!.camera.position.x = Math.sin(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
+    objects.normal!.camera.position.y = Math.sin(0.25 * Math.PI * (mouse[1] - 0.5)) * zoom;
+    objects.normal!.camera.position.z = Math.cos(0.5 * Math.PI * (mouse[0] - 0.5)) * zoom;
+    objects.normal!.camera.lookAt(objects.normal!.scene.position);
 
     // Clone camera settings across both scenes
-    objects.logzbuf.camera.position.copy(objects.normal.camera.position);
-    objects.logzbuf.camera.quaternion.copy(objects.normal.camera.quaternion);
+    objects.logzbuf!.camera.position.copy(objects.normal!.camera.position);
+    objects.logzbuf!.camera.quaternion.copy(objects.normal!.camera.quaternion);
 
     // Update renderer sizes if the split has changed
     if (screensplit_right != 1 - screensplit) {
         updateRendererSizes();
     }
 
-    objects.normal.renderer.render(objects.normal.scene, objects.normal.camera);
-    objects.logzbuf.renderer.render(objects.logzbuf.scene, objects.logzbuf.camera);
+    objects.normal!.renderer.render(objects.normal!.scene, objects.normal!.camera);
+    objects.logzbuf!.renderer.render(objects.logzbuf!.scene, objects.logzbuf!.camera);
 
     stats.update();
 }
@@ -225,7 +236,7 @@ function onBorderPointerDown() {
     window.addEventListener("pointerup", onBorderPointerUp);
 }
 
-function onBorderPointerMove(ev) {
+function onBorderPointerMove(ev: PointerEvent) {
     screensplit = Math.max(0, Math.min(1, ev.clientX / window.innerWidth));
 }
 
@@ -234,12 +245,12 @@ function onBorderPointerUp() {
     window.removeEventListener("pointerup", onBorderPointerUp);
 }
 
-function onMouseMove(ev) {
+function onMouseMove(ev: MouseEvent) {
     mouse[0] = ev.clientX / window.innerWidth;
     mouse[1] = ev.clientY / window.innerHeight;
 }
 
-function onMouseWheel(ev) {
+function onMouseWheel(ev: WheelEvent) {
     const amount = ev.deltaY;
     if (amount === 0) return;
     const dir = amount / Math.abs(amount);
diff --git a/examples-testing/examples/webgpu_clearcoat.ts b/examples-testing/examples/webgpu_clearcoat.ts
index 8755319..14f977c 100644
--- a/examples-testing/examples/webgpu_clearcoat.ts
+++ b/examples-testing/examples/webgpu_clearcoat.ts
@@ -10,12 +10,12 @@ import { HDRCubeTextureLoader } from "three/addons/loaders/HDRCubeTextureLoader.
 
 import { FlakesTexture } from "three/addons/textures/FlakesTexture.js";
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: WebGPURenderer;
 
-let particleLight;
-let group;
+let particleLight: THREE.Mesh;
+let group: THREE.Group;
 
 init();
 
@@ -39,8 +39,8 @@ function init() {
 
     new HDRCubeTextureLoader()
         .setPath("textures/cube/pisaHDR/")
-        .load(["px.hdr", "nx.hdr", "py.hdr", "ny.hdr", "pz.hdr", "nz.hdr"], function (texture) {
-            const geometry = new THREE.SphereGeometry(.8, 64, 32);
+        .load(["px.hdr", "nx.hdr", "py.hdr", "ny.hdr", "pz.hdr", "nz.hdr"], function(texture) {
+            const geometry = new THREE.SphereGeometry(0.8, 64, 32);
 
             const textureLoader = new THREE.TextureLoader();
 
@@ -146,7 +146,7 @@ function init() {
     // LIGHTS
 
     particleLight = new THREE.Mesh(
-        new THREE.SphereGeometry(.05, 8, 8),
+        new THREE.SphereGeometry(0.05, 8, 8),
         new THREE.MeshBasicMaterial({ color: 0xffffff }),
     );
     scene.add(particleLight);
diff --git a/examples-testing/examples/webgpu_lights_ies_spotlight.ts b/examples-testing/examples/webgpu_lights_ies_spotlight.ts
index 791c425..0a4e652 100644
--- a/examples-testing/examples/webgpu_lights_ies_spotlight.ts
+++ b/examples-testing/examples/webgpu_lights_ies_spotlight.ts
@@ -1,18 +1,18 @@
 import * as THREE from "three";
 
-import WebGPU from "three/addons/capabilities/WebGPU.js";
 import WebGL from "three/addons/capabilities/WebGL.js";
+import WebGPU from "three/addons/capabilities/WebGPU.js";
 
 import WebGPURenderer from "three/addons/renderers/webgpu/WebGPURenderer.js";
 
 import IESSpotLight from "three/addons/lights/IESSpotLight.js";
 
-import { OrbitControls } from "./jsm/controls/OrbitControls.js";
+import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
-import { IESLoader } from "./jsm/loaders/IESLoader.js";
+import { IESLoader } from "three/addons/loaders/IESLoader.js";
 
-let renderer, scene, camera;
-let lights;
+let renderer: WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera;
+let lights: IESSpotLight[];
 
 async function init() {
     if (WebGPU.isAvailable() === false && WebGL.isWebGL2Available() === false) {
@@ -28,7 +28,7 @@ async function init() {
     //
 
     const iesLoader = new IESLoader().setPath("./ies/");
-    //iesLoader.type = THREE.UnsignedByteType; // LDR
+    // iesLoader.type = THREE.UnsignedByteType; // LDR
 
     const [iesTexture1, iesTexture2, iesTexture3, iesTexture4] = await Promise.all([
         iesLoader.loadAsync("007cfb11e343e2f42e3b476be4ab684e.ies"),
@@ -99,7 +99,7 @@ async function init() {
     renderer.setAnimationLoop(render);
     document.body.appendChild(renderer.domElement);
 
-    camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 100);
+    camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
     camera.position.set(16, 4, 1);
 
     const controls = new OrbitControls(camera, renderer.domElement);
@@ -119,7 +119,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function render(time) {
+function render(time: number) {
     time = (time / 1000) * 2.0;
 
     for (let i = 0; i < lights.length; i++) {
diff --git a/examples-testing/examples/webgpu_loader_gltf.ts b/examples-testing/examples/webgpu_loader_gltf.ts
index 0cfe6d0..e8e9e88 100644
--- a/examples-testing/examples/webgpu_loader_gltf.ts
+++ b/examples-testing/examples/webgpu_loader_gltf.ts
@@ -1,7 +1,7 @@
 import * as THREE from "three";
 
-import WebGPU from "three/addons/capabilities/WebGPU.js";
 import WebGL from "three/addons/capabilities/WebGL.js";
+import WebGPU from "three/addons/capabilities/WebGPU.js";
 
 import WebGPURenderer from "three/addons/renderers/webgpu/WebGPURenderer.js";
 
@@ -10,7 +10,7 @@ import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: WebGPURenderer;
 
 init();
 render();
@@ -30,27 +30,25 @@ function init() {
 
     scene = new THREE.Scene();
 
-    new RGBELoader()
-        .setPath("textures/equirectangular/")
-        .load("royal_esplanade_1k.hdr", function (texture) {
-            texture.mapping = THREE.EquirectangularReflectionMapping;
-            //texture.minFilter = THREE.LinearMipmapLinearFilter;
-            //texture.generateMipmaps = true;
+    new RGBELoader().setPath("textures/equirectangular/").load("royal_esplanade_1k.hdr", function(texture) {
+        texture.mapping = THREE.EquirectangularReflectionMapping;
+        // texture.minFilter = THREE.LinearMipmapLinearFilter;
+        // texture.generateMipmaps = true;
 
-            scene.background = texture;
-            scene.environment = texture;
+        scene.background = texture;
+        scene.environment = texture;
 
-            render();
+        render();
 
-            // model
+        // model
 
-            const loader = new GLTFLoader().setPath("models/gltf/DamagedHelmet/glTF/");
-            loader.load("DamagedHelmet.gltf", function (gltf) {
-                scene.add(gltf.scene);
+        const loader = new GLTFLoader().setPath("models/gltf/DamagedHelmet/glTF/");
+        loader.load("DamagedHelmet.gltf", function(gltf) {
+            scene.add(gltf.scene);
 
-                render();
-            });
+            render();
         });
+    });
 
     renderer = new WebGPURenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
diff --git a/examples-testing/examples/webgpu_loader_gltf_compressed.ts b/examples-testing/examples/webgpu_loader_gltf_compressed.ts
index b9e5a1c..b383915 100644
--- a/examples-testing/examples/webgpu_loader_gltf_compressed.ts
+++ b/examples-testing/examples/webgpu_loader_gltf_compressed.ts
@@ -1,14 +1,14 @@
 import * as THREE from "three";
 
+import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
-import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
 import WebGPURenderer from "three/addons/renderers/webgpu/WebGPURenderer.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: WebGPURenderer;
 
 init();
 
@@ -17,16 +17,16 @@ async function init() {
     camera.position.set(2, 2, 2);
 
     scene = new THREE.Scene();
-    scene.background = new THREE.Color(0xEEEEEE);
+    scene.background = new THREE.Color(0xeeeeee);
 
-    //lights
+    // lights
 
     const light = new THREE.PointLight(0xffffff);
     light.power = 1300;
     camera.add(light);
     scene.add(camera);
 
-    //renderer
+    // renderer
 
     renderer = new WebGPURenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -41,17 +41,15 @@ async function init() {
     controls.maxDistance = 6;
     controls.update();
 
-    const ktx2Loader = await new KTX2Loader()
-        .setTranscoderPath("jsm/libs/basis/")
-        .detectSupportAsync(renderer);
+    const ktx2Loader = await new KTX2Loader().setTranscoderPath("jsm/libs/basis/").detectSupportAsync(renderer);
 
     const loader = new GLTFLoader();
     loader.setKTX2Loader(ktx2Loader);
     loader.setMeshoptDecoder(MeshoptDecoder);
-    loader.load("models/gltf/coffeemat.glb", function (gltf) {
+    loader.load("models/gltf/coffeemat.glb", function(gltf) {
         const gltfScene = gltf.scene;
-        gltfScene.position.y = -.8;
-        gltfScene.scale.setScalar(.01);
+        gltfScene.position.y = -0.8;
+        gltfScene.scale.setScalar(0.01);
 
         scene.add(gltfScene);
     });
diff --git a/examples-testing/examples/webgpu_loader_gltf_iridescence.ts b/examples-testing/examples/webgpu_loader_gltf_iridescence.ts
index b811845..c443cf4 100644
--- a/examples-testing/examples/webgpu_loader_gltf_iridescence.ts
+++ b/examples-testing/examples/webgpu_loader_gltf_iridescence.ts
@@ -1,7 +1,7 @@
 import * as THREE from "three";
 
-import WebGPU from "three/addons/capabilities/WebGPU.js";
 import WebGL from "three/addons/capabilities/WebGL.js";
+import WebGPU from "three/addons/capabilities/WebGPU.js";
 
 import WebGPURenderer from "three/addons/renderers/webgpu/WebGPURenderer.js";
 
@@ -9,9 +9,9 @@ import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 
-let renderer, scene, camera, controls;
+let renderer: WebGPURenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera, controls: OrbitControls;
 
-init().catch(function (err) {
+init().catch(function(err) {
     console.error(err);
 });
 
@@ -40,8 +40,7 @@ async function init() {
     controls.target.set(0, 0.2, 0);
     controls.update();
 
-    const rgbeLoader = new RGBELoader()
-        .setPath("textures/equirectangular/");
+    const rgbeLoader = new RGBELoader().setPath("textures/equirectangular/");
 
     const gltfLoader = new GLTFLoader().setPath("models/gltf/");
 
diff --git a/examples-testing/examples/webgpu_loader_gltf_sheen.ts b/examples-testing/examples/webgpu_loader_gltf_sheen.ts
index 86ac6ba..e59ea66 100644
--- a/examples-testing/examples/webgpu_loader_gltf_sheen.ts
+++ b/examples-testing/examples/webgpu_loader_gltf_sheen.ts
@@ -1,7 +1,7 @@
 import * as THREE from "three";
 
-import WebGPU from "three/addons/capabilities/WebGPU.js";
 import WebGL from "three/addons/capabilities/WebGL.js";
+import WebGPU from "three/addons/capabilities/WebGPU.js";
 
 import WebGPURenderer from "three/addons/renderers/webgpu/WebGPURenderer.js";
 
@@ -11,7 +11,7 @@ import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-let camera, scene, renderer, controls;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: WebGPURenderer, controls: OrbitControls;
 
 init();
 
@@ -29,22 +29,23 @@ function init() {
     camera.position.set(-0.75, 0.7, 1.25);
 
     scene = new THREE.Scene();
-    //scene.add( new THREE.DirectionalLight( 0xffffff, 2 ) );
+    // scene.add( new THREE.DirectionalLight( 0xffffff, 2 ) );
 
     // model
 
-    new GLTFLoader()
-        .setPath("models/gltf/")
-        .load("SheenChair.glb", function (gltf) {
-            scene.add(gltf.scene);
+    new GLTFLoader().setPath("models/gltf/").load("SheenChair.glb", function(gltf) {
+        scene.add(gltf.scene);
 
-            const object = gltf.scene.getObjectByName("SheenChair_fabric");
+        const object = gltf.scene.getObjectByName("SheenChair_fabric") as THREE.Mesh<
+            THREE.BufferGeometry,
+            THREE.MeshPhysicalMaterial
+        >;
 
-            const gui = new GUI();
+        const gui = new GUI();
 
-            gui.add(object.material, "sheen", 0, 1);
-            gui.open();
-        });
+        gui.add(object.material, "sheen", 0, 1);
+        gui.open();
+    });
 
     renderer = new WebGPURenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -54,17 +55,15 @@ function init() {
     renderer.toneMappingExposure = 1;
     container.appendChild(renderer.domElement);
 
-    scene.background = new THREE.Color(0xAAAAAA);
+    scene.background = new THREE.Color(0xaaaaaa);
 
-    new RGBELoader()
-        .setPath("textures/equirectangular/")
-        .load("royal_esplanade_1k.hdr", function (texture) {
-            texture.mapping = THREE.EquirectangularReflectionMapping;
+    new RGBELoader().setPath("textures/equirectangular/").load("royal_esplanade_1k.hdr", function(texture) {
+        texture.mapping = THREE.EquirectangularReflectionMapping;
 
-            scene.background = texture;
-            //scene.backgroundBlurriness = 1; // @TODO: Needs PMREM
-            scene.environment = texture;
-        });
+        scene.background = texture;
+        // scene.backgroundBlurriness = 1; // @TODO: Needs PMREM
+        scene.environment = texture;
+    });
 
     controls = new OrbitControls(camera, renderer.domElement);
     controls.enableDamping = true;
diff --git a/examples-testing/examples/webgpu_materials_texture_anisotropy.ts b/examples-testing/examples/webgpu_materials_texture_anisotropy.ts
index ba3a084..a3b5cf9 100644
--- a/examples-testing/examples/webgpu_materials_texture_anisotropy.ts
+++ b/examples-testing/examples/webgpu_materials_texture_anisotropy.ts
@@ -3,11 +3,12 @@ import * as THREE from "three";
 import Stats from "three/addons/libs/stats.module.js";
 import WebGPURenderer from "three/addons/renderers/webgpu/WebGPURenderer.js";
 
-let container, stats;
+let container: HTMLDivElement, stats: Stats;
 
-let camera, scene1, scene2, renderer;
+let camera: THREE.PerspectiveCamera, scene1: THREE.Scene, scene2: THREE.Scene, renderer: WebGPURenderer;
 
-let mouseX = 0, mouseY = 0;
+let mouseX = 0,
+    mouseY = 0;
 
 init().then(() => animate());
 
@@ -75,11 +76,11 @@ async function init() {
     texture2.repeat.set(512, 512);
 
     if (maxAnisotropy > 0) {
-        document.getElementById("val_left").innerHTML = texture1.anisotropy;
-        document.getElementById("val_right").innerHTML = texture2.anisotropy;
+        document.getElementById("val_left")!.innerHTML = texture1.anisotropy.toString();
+        document.getElementById("val_right")!.innerHTML = texture2.anisotropy.toString();
     } else {
-        document.getElementById("val_left").innerHTML = "not supported";
-        document.getElementById("val_right").innerHTML = "not supported";
+        document.getElementById("val_left")!.innerHTML = "not supported";
+        document.getElementById("val_right")!.innerHTML = "not supported";
     }
 
     //
@@ -114,7 +115,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     const windowHalfX = window.innerWidth / 2;
     const windowHalfY = window.innerHeight / 2;
 
@@ -133,9 +134,9 @@ function render() {
     const SCREEN_WIDTH = window.innerWidth;
     const SCREEN_HEIGHT = window.innerHeight;
 
-    camera.position.x += (mouseX - camera.position.x) * .05;
+    camera.position.x += (mouseX - camera.position.x) * 0.05;
     camera.position.y = THREE.MathUtils.clamp(
-        camera.position.y + (-(mouseY - 200) - camera.position.y) * .05,
+        camera.position.y + (-(mouseY - 200) - camera.position.y) * 0.05,
         50,
         1000,
     );
diff --git a/examples-testing/examples/webgpu_materials_video.ts b/examples-testing/examples/webgpu_materials_video.ts
index 93ca2c5..8e2dab6 100644
--- a/examples-testing/examples/webgpu_materials_video.ts
+++ b/examples-testing/examples/webgpu_materials_video.ts
@@ -2,11 +2,14 @@ import * as THREE from "three";
 
 import WebGPURenderer from "three/addons/renderers/webgpu/WebGPURenderer.js";
 
-let container;
+let container: HTMLDivElement;
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: WebGPURenderer;
 
-let video, texture, material, mesh;
+let video: HTMLVideoElement,
+    texture: THREE.VideoTexture,
+    material: THREE.MeshPhongMaterial & { hue?: number; saturation?: number },
+    mesh: THREE.Mesh & { dx?: number; dy?: number };
 
 let mouseX = 0;
 let mouseY = 0;
@@ -14,20 +17,20 @@ let mouseY = 0;
 let windowHalfX = window.innerWidth / 2;
 let windowHalfY = window.innerHeight / 2;
 
-let cube_count;
+let cube_count: number;
 
-const meshes = [],
-    materials = [],
+const meshes: THREE.Mesh[] = [],
+    materials: (THREE.MeshPhongMaterial & { hue?: number; saturation?: number })[] = [],
     xgrid = 20,
     ygrid = 10;
 
-const startButton = document.getElementById("startButton");
-startButton.addEventListener("click", function () {
+const startButton = document.getElementById("startButton")!;
+startButton.addEventListener("click", function() {
     init();
 });
 
 function init() {
-    const overlay = document.getElementById("overlay");
+    const overlay = document.getElementById("overlay")!;
     overlay.remove();
 
     container = document.createElement("div");
@@ -48,9 +51,9 @@ function init() {
     renderer.setAnimationLoop(render);
     container.appendChild(renderer.domElement);
 
-    video = document.getElementById("video");
+    video = document.getElementById("video") as HTMLVideoElement;
     video.play();
-    video.addEventListener("play", function () {
+    video.addEventListener("play", function() {
         this.currentTime = 3;
     });
 
@@ -124,7 +127,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function change_uvs(geometry, unitx, unity, offsetx, offsety) {
+function change_uvs(geometry: THREE.BoxGeometry, unitx: number, unity: number, offsetx: number, offsety: number) {
     const uvs = geometry.attributes.uv.array;
 
     for (let i = 0; i < uvs.length; i += 2) {
@@ -133,14 +136,15 @@ function change_uvs(geometry, unitx, unity, offsetx, offsety) {
     }
 }
 
-function onDocumentMouseMove(event) {
+function onDocumentMouseMove(event: MouseEvent) {
     mouseX = event.clientX - windowHalfX;
     mouseY = (event.clientY - windowHalfY) * 0.3;
 }
 
 //
 
-let h, counter = 1;
+let h,
+    counter = 1;
 
 function render() {
     const time = Date.now() * 0.00005;
@@ -153,20 +157,20 @@ function render() {
     for (let i = 0; i < cube_count; i++) {
         material = materials[i];
 
-        h = (360 * (material.hue + time) % 360) / 360;
-        material.color.setHSL(h, material.saturation, 0.5);
+        h = ((360 * (material.hue! + time)) % 360) / 360;
+        material.color.setHSL(h, material.saturation!, 0.5);
     }
 
     if (counter % 1000 > 200) {
         for (let i = 0; i < cube_count; i++) {
             mesh = meshes[i];
 
-            mesh.rotation.x += 10 * mesh.dx;
-            mesh.rotation.y += 10 * mesh.dy;
+            mesh.rotation.x += 10 * mesh.dx!;
+            mesh.rotation.y += 10 * mesh.dy!;
 
-            mesh.position.x -= 150 * mesh.dx;
-            mesh.position.y += 150 * mesh.dy;
-            mesh.position.z += 300 * mesh.dx;
+            mesh.position.x -= 150 * mesh.dx!;
+            mesh.position.y += 150 * mesh.dy!;
+            mesh.position.z += 300 * mesh.dx!;
         }
     }
 
@@ -174,8 +178,8 @@ function render() {
         for (let i = 0; i < cube_count; i++) {
             mesh = meshes[i];
 
-            mesh.dx *= -1;
-            mesh.dy *= -1;
+            mesh.dx! *= -1;
+            mesh.dy! *= -1;
         }
     }
 
diff --git a/examples-testing/examples/webgpu_morphtargets.ts b/examples-testing/examples/webgpu_morphtargets.ts
index f61956e..e120052 100644
--- a/examples-testing/examples/webgpu_morphtargets.ts
+++ b/examples-testing/examples/webgpu_morphtargets.ts
@@ -1,14 +1,18 @@
 import * as THREE from "three";
 
-import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
+import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-import WebGPU from "three/addons/capabilities/WebGPU.js";
 import WebGL from "three/addons/capabilities/WebGL.js";
+import WebGPU from "three/addons/capabilities/WebGPU.js";
 
 import WebGPURenderer from "three/addons/renderers/webgpu/WebGPURenderer.js";
 
-let container, camera, scene, renderer, mesh;
+let container: HTMLElement,
+    camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: WebGPURenderer,
+    mesh: THREE.Mesh;
 
 init();
 
@@ -19,16 +23,16 @@ function init() {
         throw new Error("No WebGPU or WebGL2 support");
     }
 
-    container = document.getElementById("container");
+    container = document.getElementById("container")!;
 
     scene = new THREE.Scene();
-    scene.background = new THREE.Color(0x8FBCD4);
+    scene.background = new THREE.Color(0x8fbcd4);
 
     camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 20);
     camera.position.z = 10;
     scene.add(camera);
 
-    scene.add(new THREE.AmbientLight(0x8FBCD4, 1.5));
+    scene.add(new THREE.AmbientLight(0x8fbcd4, 1.5));
 
     const pointLight = new THREE.PointLight(0xffffff, 200);
     camera.add(pointLight);
@@ -48,7 +52,7 @@ function init() {
     renderer = new WebGPURenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
     renderer.setSize(window.innerWidth, window.innerHeight);
-    renderer.setAnimationLoop(function () {
+    renderer.setAnimationLoop(function() {
         renderer.render(scene, camera);
     });
     container.appendChild(renderer.domElement);
@@ -73,7 +77,7 @@ function createGeometry() {
     const spherePositions = [];
 
     // for the second morph target, we'll twist the cubes vertices
-    const twistPositions = [];
+    const twistPositions: number[] = [];
     const direction = new THREE.Vector3(1, 0, 0);
     const vertex = new THREE.Vector3();
 
@@ -83,15 +87,15 @@ function createGeometry() {
         const z = positionAttribute.getZ(i);
 
         spherePositions.push(
-            x * Math.sqrt(1 - (y * y / 2) - (z * z / 2) + (y * y * z * z / 3)),
-            y * Math.sqrt(1 - (z * z / 2) - (x * x / 2) + (z * z * x * x / 3)),
-            z * Math.sqrt(1 - (x * x / 2) - (y * y / 2) + (x * x * y * y / 3)),
+            x * Math.sqrt(1 - (y * y) / 2 - (z * z) / 2 + (y * y * z * z) / 3),
+            y * Math.sqrt(1 - (z * z) / 2 - (x * x) / 2 + (z * z * x * x) / 3),
+            z * Math.sqrt(1 - (x * x) / 2 - (y * y) / 2 + (x * x * y * y) / 3),
         );
 
         // stretch along the x-axis so we can see the twist better
         vertex.set(x * 2, y, z);
 
-        vertex.applyAxisAngle(direction, Math.PI * x / 2).toArray(twistPositions, twistPositions.length);
+        vertex.applyAxisAngle(direction, (Math.PI * x) / 2).toArray(twistPositions, twistPositions.length);
     }
 
     // add the spherical positions as the first morph target
@@ -111,12 +115,16 @@ function initGUI() {
     };
     const gui = new GUI({ title: "Morph Targets" });
 
-    gui.add(params, "Spherify", 0, 1).step(0.01).onChange(function (value) {
-        mesh.morphTargetInfluences[0] = value;
-    });
-    gui.add(params, "Twist", 0, 1).step(0.01).onChange(function (value) {
-        mesh.morphTargetInfluences[1] = value;
-    });
+    gui.add(params, "Spherify", 0, 1)
+        .step(0.01)
+        .onChange(function(value) {
+            mesh.morphTargetInfluences![0] = value;
+        });
+    gui.add(params, "Twist", 0, 1)
+        .step(0.01)
+        .onChange(function(value) {
+            mesh.morphTargetInfluences![1] = value;
+        });
 }
 
 function onWindowResize() {
diff --git a/examples-testing/examples/webgpu_morphtargets_face.ts b/examples-testing/examples/webgpu_morphtargets_face.ts
index 1de332d..20ce802 100644
--- a/examples-testing/examples/webgpu_morphtargets_face.ts
+++ b/examples-testing/examples/webgpu_morphtargets_face.ts
@@ -1,7 +1,7 @@
 import * as THREE from "three";
 
-import WebGPU from "three/addons/capabilities/WebGPU.js";
 import WebGL from "three/addons/capabilities/WebGL.js";
+import WebGPU from "three/addons/capabilities/WebGPU.js";
 
 import WebGPURenderer from "three/addons/renderers/webgpu/WebGPURenderer.js";
 
@@ -9,9 +9,9 @@ import Stats from "three/addons/libs/stats.module.js";
 
 import { OrbitControls } from "three/addons/controls/OrbitControls.js";
 
+import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";
 import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
 import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
-import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";
 
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
@@ -24,7 +24,7 @@ async function init() {
         throw new Error("No WebGPU or WebGL2 support");
     }
 
-    let mixer;
+    let mixer: THREE.AnimationMixer;
 
     const clock = new THREE.Clock();
 
@@ -35,7 +35,7 @@ async function init() {
     camera.position.set(-1.8, 0.8, 3);
 
     const scene = new THREE.Scene();
-    scene.add(new THREE.HemisphereLight(0xFFFFFF, 0x443333, 2));
+    scene.add(new THREE.HemisphereLight(0xffffff, 0x443333, 2));
 
     const renderer = new WebGPURenderer({ antialias: true });
     renderer.setPixelRatio(window.devicePixelRatio);
@@ -45,14 +45,12 @@ async function init() {
 
     container.appendChild(renderer.domElement);
 
-    const ktx2Loader = await new KTX2Loader()
-        .setTranscoderPath("jsm/libs/basis/")
-        .detectSupportAsync(renderer);
+    const ktx2Loader = await new KTX2Loader().setTranscoderPath("jsm/libs/basis/").detectSupportAsync(renderer);
 
     new GLTFLoader()
         .setKTX2Loader(ktx2Loader)
         .setMeshoptDecoder(MeshoptDecoder)
-        .load("models/gltf/facecap.glb", (gltf) => {
+        .load("models/gltf/facecap.glb", gltf => {
             const mesh = gltf.scene.children[0];
 
             scene.add(mesh);
@@ -63,10 +61,10 @@ async function init() {
 
             // GUI
 
-            const head = mesh.getObjectByName("mesh_2");
-            const influences = head.morphTargetInfluences;
+            const head = mesh.getObjectByName("mesh_2") as THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;
+            const influences = head.morphTargetInfluences!;
 
-            //head.morphTargetInfluences = null;
+            // head.morphTargetInfluences = null;
 
             // WebGPURenderer: Unsupported texture format. 33776
             head.material.map = null;
@@ -74,10 +72,8 @@ async function init() {
             const gui = new GUI();
             gui.close();
 
-            for (const [key, value] of Object.entries(head.morphTargetDictionary)) {
-                gui.add(influences, value, 0, 1, 0.01)
-                    .name(key.replace("blendShape1.", ""))
-                    .listen();
+            for (const [key, value] of Object.entries(head.morphTargetDictionary!)) {
+                gui.add(influences, value, 0, 1, 0.01).name(key.replace("blendShape1.", "")).listen();
             }
         });
 
diff --git a/examples-testing/examples/webgpu_postprocessing_afterimage.ts b/examples-testing/examples/webgpu_postprocessing_afterimage.ts
index 8b36529..ed8812c 100644
--- a/examples-testing/examples/webgpu_postprocessing_afterimage.ts
+++ b/examples-testing/examples/webgpu_postprocessing_afterimage.ts
@@ -2,12 +2,13 @@ import * as THREE from "three";
 
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 
-import WebGPURenderer from "three/addons/renderers/webgpu/WebGPURenderer.js";
 import PostProcessing from "three/addons/renderers/common/PostProcessing.js";
+import WebGPURenderer from "three/addons/renderers/webgpu/WebGPURenderer.js";
 import { pass } from "three/nodes";
+import type { AfterImageNode, ShaderNodeObject } from "three/nodes";
 
-let camera, scene, renderer;
-let mesh, postProcessing, combinedPass;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: WebGPURenderer;
+let mesh: THREE.Mesh, postProcessing: PostProcessing, combinedPass: ShaderNodeObject<AfterImageNode>;
 
 const params = {
     damp: 0.96,
@@ -41,8 +42,7 @@ function init() {
     const scenePass = pass(scene, camera);
     const scenePassColor = scenePass.getTextureNode();
 
-    combinedPass = scenePassColor;
-    combinedPass = combinedPass.afterImage(params.damp);
+    combinedPass = scenePassColor.afterImage(params.damp);
 
     postProcessing.outputNode = combinedPass;
 
diff --git a/examples-testing/examples/webgpu_video_panorama.ts b/examples-testing/examples/webgpu_video_panorama.ts
index 3473659..9e659e2 100644
--- a/examples-testing/examples/webgpu_video_panorama.ts
+++ b/examples-testing/examples/webgpu_video_panorama.ts
@@ -2,7 +2,7 @@ import * as THREE from "three";
 
 import WebGPURenderer from "three/addons/renderers/webgpu/WebGPURenderer.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: WebGPURenderer;
 
 let isUserInteracting = false,
     lon = 0,
@@ -14,14 +14,14 @@ let isUserInteracting = false,
     onPointerDownLon = 0,
     onPointerDownLat = 0;
 
-const distance = .5;
+const distance = 0.5;
 
 init();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
-    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, .25, 10);
+    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.25, 10);
 
     scene = new THREE.Scene();
 
@@ -29,7 +29,7 @@ function init() {
     // invert the geometry on the x-axis so that all of the faces point inward
     geometry.scale(-1, 1, 1);
 
-    const video = document.getElementById("video");
+    const video = document.getElementById("video") as HTMLVideoElement;
     video.play();
 
     const texture = new THREE.VideoTexture(video);
@@ -61,7 +61,7 @@ function onWindowResize() {
     renderer.setSize(window.innerWidth, window.innerHeight);
 }
 
-function onPointerDown(event) {
+function onPointerDown(event: PointerEvent) {
     isUserInteracting = true;
 
     onPointerDownPointerX = event.clientX;
@@ -71,7 +71,7 @@ function onPointerDown(event) {
     onPointerDownLat = lat;
 }
 
-function onPointerMove(event) {
+function onPointerMove(event: PointerEvent) {
     if (isUserInteracting === true) {
         lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
         lat = (onPointerDownPointerY - event.clientY) * 0.1 + onPointerDownLat;
diff --git a/examples-testing/examples/webxr_ar_cones.ts b/examples-testing/examples/webxr_ar_cones.ts
index fbe922c..2b1a08a 100644
--- a/examples-testing/examples/webxr_ar_cones.ts
+++ b/examples-testing/examples/webxr_ar_cones.ts
@@ -1,8 +1,8 @@
 import * as THREE from "three";
 import { ARButton } from "three/addons/webxr/ARButton.js";
 
-let camera, scene, renderer;
-let controller;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controller: THREE.XRTargetRaySpace;
 
 init();
 animate();
diff --git a/examples-testing/examples/webxr_ar_hittest.ts b/examples-testing/examples/webxr_ar_hittest.ts
index a6a78fe..4a92837 100644
--- a/examples-testing/examples/webxr_ar_hittest.ts
+++ b/examples-testing/examples/webxr_ar_hittest.ts
@@ -1,13 +1,13 @@
 import * as THREE from "three";
 import { ARButton } from "three/addons/webxr/ARButton.js";
 
-let container;
-let camera, scene, renderer;
-let controller;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controller: THREE.XRTargetRaySpace;
 
-let reticle;
+let reticle: THREE.Mesh;
 
-let hitTestSource = null;
+let hitTestSource: XRHitTestSource | null = null;
 let hitTestSourceRequested = false;
 
 init();
@@ -81,19 +81,19 @@ function animate() {
     renderer.setAnimationLoop(render);
 }
 
-function render(timestamp, frame) {
+function render(timestamp: DOMHighResTimeStamp, frame: XRFrame) {
     if (frame) {
         const referenceSpace = renderer.xr.getReferenceSpace();
-        const session = renderer.xr.getSession();
+        const session = renderer.xr.getSession()!;
 
         if (hitTestSourceRequested === false) {
-            session.requestReferenceSpace("viewer").then(function (referenceSpace) {
-                session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
+            session.requestReferenceSpace("viewer").then(function(referenceSpace) {
+                session.requestHitTestSource!({ space: referenceSpace })!.then(function(source) {
                     hitTestSource = source;
                 });
             });
 
-            session.addEventListener("end", function () {
+            session.addEventListener("end", function() {
                 hitTestSourceRequested = false;
                 hitTestSource = null;
             });
@@ -108,7 +108,7 @@ function render(timestamp, frame) {
                 const hit = hitTestResults[0];
 
                 reticle.visible = true;
-                reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
+                reticle.matrix.fromArray(hit.getPose(referenceSpace!)!.transform.matrix);
             } else {
                 reticle.visible = false;
             }
diff --git a/examples-testing/examples/webxr_ar_lighting.ts b/examples-testing/examples/webxr_ar_lighting.ts
index da0135b..0060fcf 100644
--- a/examples-testing/examples/webxr_ar_lighting.ts
+++ b/examples-testing/examples/webxr_ar_lighting.ts
@@ -3,9 +3,9 @@ import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
 import { ARButton } from "three/addons/webxr/ARButton.js";
 import { XREstimatedLight } from "three/addons/webxr/XREstimatedLight.js";
 
-let camera, scene, renderer;
-let controller;
-let defaultEnvironment;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let controller: THREE.XRTargetRaySpace;
+let defaultEnvironment: THREE.DataTexture;
 
 init();
 animate();
@@ -57,15 +57,13 @@ function init() {
 
     //
 
-    new RGBELoader()
-        .setPath("textures/equirectangular/")
-        .load("royal_esplanade_1k.hdr", function (texture) {
-            texture.mapping = THREE.EquirectangularReflectionMapping;
+    new RGBELoader().setPath("textures/equirectangular/").load("royal_esplanade_1k.hdr", function(texture) {
+        texture.mapping = THREE.EquirectangularReflectionMapping;
 
-            defaultEnvironment = texture;
+        defaultEnvironment = texture;
 
-            scene.environment = defaultEnvironment;
-        });
+        scene.environment = defaultEnvironment;
+    });
 
     //
 
diff --git a/examples-testing/examples/webxr_ar_plane_detection.ts b/examples-testing/examples/webxr_ar_plane_detection.ts
index ecdbcb4..38b5c97 100644
--- a/examples-testing/examples/webxr_ar_plane_detection.ts
+++ b/examples-testing/examples/webxr_ar_plane_detection.ts
@@ -11,9 +11,11 @@ renderer.setAnimationLoop(render);
 renderer.xr.enabled = true;
 document.body.appendChild(renderer.domElement);
 
-document.body.appendChild(ARButton.createButton(renderer, {
-    requiredFeatures: ["plane-detection"],
-}));
+document.body.appendChild(
+    ARButton.createButton(renderer, {
+        requiredFeatures: ["plane-detection"],
+    }),
+);
 
 window.addEventListener("resize", onWindowResize);
 
diff --git a/examples-testing/examples/webxr_vr_handinput.ts b/examples-testing/examples/webxr_vr_handinput.ts
index f2c39e6..10b7b01 100644
--- a/examples-testing/examples/webxr_vr_handinput.ts
+++ b/examples-testing/examples/webxr_vr_handinput.ts
@@ -4,13 +4,13 @@ import { VRButton } from "three/addons/webxr/VRButton.js";
 import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFactory.js";
 import { XRHandModelFactory } from "three/addons/webxr/XRHandModelFactory.js";
 
-let container;
-let camera, scene, renderer;
-let hand1, hand2;
-let controller1, controller2;
-let controllerGrip1, controllerGrip2;
+let container: HTMLDivElement;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let hand1: THREE.XRHandSpace, hand2: THREE.XRHandSpace;
+let controller1: THREE.XRTargetRaySpace, controller2: THREE.XRTargetRaySpace;
+let controllerGrip1: THREE.XRGripSpace, controllerGrip2: THREE.XRGripSpace;
 
-let controls;
+let controls: OrbitControls;
 
 init();
 animate();
diff --git a/examples-testing/examples/webxr_vr_panorama.ts b/examples-testing/examples/webxr_vr_panorama.ts
index bd99c3e..f223eeb 100644
--- a/examples-testing/examples/webxr_vr_panorama.ts
+++ b/examples-testing/examples/webxr_vr_panorama.ts
@@ -1,9 +1,9 @@
 import * as THREE from "three";
 import { VRButton } from "three/addons/webxr/VRButton.js";
 
-let camera;
-let renderer;
-let scene;
+let camera: THREE.PerspectiveCamera;
+let renderer: THREE.WebGLRenderer;
+let scene: THREE.Scene;
 
 init();
 animate();
@@ -53,21 +53,21 @@ function init() {
     window.addEventListener("resize", onWindowResize);
 }
 
-function getTexturesFromAtlasFile(atlasImgUrl, tilesNum) {
-    const textures = [];
+function getTexturesFromAtlasFile(atlasImgUrl: string, tilesNum: number) {
+    const textures: THREE.Texture[] = [];
 
     for (let i = 0; i < tilesNum; i++) {
         textures[i] = new THREE.Texture();
     }
 
     const loader = new THREE.ImageLoader();
-    loader.load(atlasImgUrl, function (imageObj) {
+    loader.load(atlasImgUrl, function(imageObj) {
         let canvas, context;
         const tileWidth = imageObj.height;
 
         for (let i = 0; i < textures.length; i++) {
             canvas = document.createElement("canvas");
-            context = canvas.getContext("2d");
+            context = canvas.getContext("2d")!;
             canvas.height = tileWidth;
             canvas.width = tileWidth;
             context.drawImage(imageObj, tileWidth * i, 0, tileWidth, tileWidth, 0, 0, tileWidth, tileWidth);
diff --git a/examples-testing/examples/webxr_vr_panorama_depth.ts b/examples-testing/examples/webxr_vr_panorama_depth.ts
index 09428cd..c3d19ef 100644
--- a/examples-testing/examples/webxr_vr_panorama_depth.ts
+++ b/examples-testing/examples/webxr_vr_panorama_depth.ts
@@ -1,13 +1,17 @@
 import * as THREE from "three";
 import { VRButton } from "three/addons/webxr/VRButton.js";
 
-let camera, scene, renderer, sphere, clock;
+let camera: THREE.PerspectiveCamera,
+    scene: THREE.Scene,
+    renderer: THREE.WebGLRenderer,
+    sphere: THREE.Mesh<THREE.SphereGeometry, THREE.MeshStandardMaterial>,
+    clock: THREE.Clock;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
+    const container = document.getElementById("container")!;
 
     clock = new THREE.Clock();
 
@@ -36,21 +40,21 @@ function init() {
     const manager = new THREE.LoadingManager();
     const loader = new THREE.TextureLoader(manager);
 
-    loader.load("./textures/kandao3.jpg", function (texture) {
+    loader.load("./textures/kandao3.jpg", function(texture) {
         texture.colorSpace = THREE.SRGBColorSpace;
         texture.minFilter = THREE.NearestFilter;
         texture.generateMipmaps = false;
         sphere.material.map = texture;
     });
 
-    loader.load("./textures/kandao3_depthmap.jpg", function (depth) {
+    loader.load("./textures/kandao3_depthmap.jpg", function(depth) {
         depth.minFilter = THREE.NearestFilter;
         depth.generateMipmaps = false;
         sphere.material.displacementMap = depth;
     });
 
     // On load complete add the panoramic sphere to the scene
-    manager.onLoad = function () {
+    manager.onLoad = function() {
         scene.add(sphere);
     };
 
diff --git a/examples-testing/examples/webxr_vr_rollercoaster.ts b/examples-testing/examples/webxr_vr_rollercoaster.ts
index e8a4281..4901d7b 100644
--- a/examples-testing/examples/webxr_vr_rollercoaster.ts
+++ b/examples-testing/examples/webxr_vr_rollercoaster.ts
@@ -9,7 +9,7 @@ import {
 } from "three/addons/misc/RollerCoaster.js";
 import { VRButton } from "three/addons/webxr/VRButton.js";
 
-let mesh, material, geometry;
+let mesh: THREE.Mesh, material: THREE.Material, geometry: SkyGeometry;
 
 const renderer = new THREE.WebGLRenderer({ antialias: true });
 renderer.setPixelRatio(window.devicePixelRatio);
@@ -49,7 +49,7 @@ for (let i = 0; i < positions.length; i += 3) {
     vertex.x += Math.random() * 10 - 5;
     vertex.z += Math.random() * 10 - 5;
 
-    const distance = (vertex.distanceTo(scene.position) / 5) - 25;
+    const distance = vertex.distanceTo(scene.position) / 5 - 25;
     vertex.y = Math.random() * Math.max(0, distance);
 
     vertex.toArray(positions, i);
@@ -81,12 +81,12 @@ scene.add(mesh);
 
 const PI2 = Math.PI * 2;
 
-const curve = (function () {
+const curve = (function() {
     const vector = new THREE.Vector3();
     const vector2 = new THREE.Vector3();
 
     return {
-        getPointAt: function (t) {
+        getPointAt: function(t: number) {
             t = t * PI2;
 
             const x = Math.sin(t * 3) * Math.cos(t * 4) * 50;
@@ -96,13 +96,12 @@ const curve = (function () {
             return vector.set(x, y, z).multiplyScalar(2);
         },
 
-        getTangentAt: function (t) {
+        getTangentAt: function(t: number) {
             const delta = 0.0001;
             const t1 = Math.max(0, t - delta);
             const t2 = Math.min(1, t + delta);
 
-            return vector2.copy(this.getPointAt(t2))
-                .sub(this.getPointAt(t1)).normalize();
+            return vector2.copy(this.getPointAt(t2)).sub(this.getPointAt(t1)).normalize();
         },
     };
 })();
@@ -130,7 +129,7 @@ mesh = new THREE.Mesh(geometry, material);
 mesh.position.y = 0.1;
 scene.add(mesh);
 
-const funfairs = [];
+const funfairs: THREE.Mesh[] = [];
 
 //
 
diff --git a/examples-testing/examples/webxr_vr_sandbox.ts b/examples-testing/examples/webxr_vr_sandbox.ts
index b7dd0ee..22cf443 100644
--- a/examples-testing/examples/webxr_vr_sandbox.ts
+++ b/examples-testing/examples/webxr_vr_sandbox.ts
@@ -12,9 +12,9 @@ import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFa
 import { GUI } from "three/addons/libs/lil-gui.module.min.js";
 import Stats from "three/addons/libs/stats.module.js";
 
-let camera, scene, renderer;
-let reflector;
-let stats, statsMesh;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
+let reflector: Reflector;
+let stats: Stats, statsMesh: HTMLMesh;
 
 const parameters = {
     radius: 0.6,
@@ -32,14 +32,12 @@ animate();
 function init() {
     scene = new THREE.Scene();
 
-    new RGBELoader()
-        .setPath("textures/equirectangular/")
-        .load("moonless_golf_1k.hdr", function (texture) {
-            texture.mapping = THREE.EquirectangularReflectionMapping;
+    new RGBELoader().setPath("textures/equirectangular/").load("moonless_golf_1k.hdr", function(texture) {
+        texture.mapping = THREE.EquirectangularReflectionMapping;
 
-            scene.background = texture;
-            scene.environment = texture;
-        });
+        scene.background = texture;
+        scene.environment = texture;
+    });
 
     camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
     camera.position.set(0, 1.6, 1.5);
@@ -199,7 +197,7 @@ function animate() {
 
 function render() {
     const time = performance.now() * 0.0002;
-    const torus = scene.getObjectByName("torus");
+    const torus = scene.getObjectByName("torus")!;
     torus.rotation.x = time * 0.4;
     torus.rotation.y = time;
 
@@ -207,5 +205,9 @@ function render() {
     stats.update();
 
     // Canvas elements doesn't trigger DOM updates, so we have to update the texture
-    statsMesh.material.map.update();
+    (statsMesh.material.map as HTMLTexture).update();
+}
+
+interface HTMLTexture extends THREE.CanvasTexture {
+    update(): void;
 }
diff --git a/examples-testing/examples/webxr_vr_video.ts b/examples-testing/examples/webxr_vr_video.ts
index 2235a2c..b1e763c 100644
--- a/examples-testing/examples/webxr_vr_video.ts
+++ b/examples-testing/examples/webxr_vr_video.ts
@@ -1,14 +1,14 @@
 import * as THREE from "three";
 import { VRButton } from "three/addons/webxr/VRButton.js";
 
-let camera, scene, renderer;
+let camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer;
 
 init();
 animate();
 
 function init() {
-    const container = document.getElementById("container");
-    container.addEventListener("click", function () {
+    const container = document.getElementById("container")!;
+    container.addEventListener("click", function() {
         video.play();
     });
 
@@ -17,7 +17,7 @@ function init() {
 
     // video
 
-    const video = document.getElementById("video");
+    const video = document.getElementById("video") as HTMLVideoElement;
     video.play();
 
     const texture = new THREE.VideoTexture(video);
