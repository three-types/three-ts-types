diff --git a/examples-jsm/examples/nodes/core/Node.ts b/examples-jsm/examples/nodes/core/Node.ts
index 438c44d..22392df 100644
--- a/examples-jsm/examples/nodes/core/Node.ts
+++ b/examples-jsm/examples/nodes/core/Node.ts
@@ -2,12 +2,94 @@ import { EventDispatcher } from 'three';
 import { NodeUpdateType } from './constants.js';
 import { getNodeChildren, getCacheKey } from './NodeUtils.js';
 import { MathUtils } from 'three';
+import NodeBuilder from './NodeBuilder.js';
+import NodeFrame from './NodeFrame.js';
 
-const NodeClasses = new Map();
+const NodeClasses = new Map<string, typeof Node>();
 
 let _nodeId = 0;
 
-class Node extends EventDispatcher {
+interface NodeConstructor {
+    type?: string;
+}
+
+interface NodeJSONMeta {
+    textures: { [key: string]: unknown };
+    images: { [key: string]: unknown };
+    nodes: { [key: string]: NodeJSONIntermediateOutputData };
+}
+
+interface NodeJSONMetadata {
+    version: number;
+    type: 'Node';
+    generator: 'Node.toJSON';
+}
+
+interface NodeJSONInputNodes {
+    [property: string]:
+        | string[]
+        | {
+              [index: string]: string | undefined;
+          }
+        | string
+        | undefined;
+}
+
+interface NodeJSONInputData {
+    inputNodes?: NodeJSONInputNodes | undefined;
+    meta: {
+        textures: { [key: string]: unknown };
+        nodes: { [key: string]: Node };
+    };
+}
+
+interface NodeJSONInputData {
+    uuid: string;
+    type: string | undefined;
+    metadata?: NodeJSONMetadata;
+    inputNodes?: NodeJSONInputNodes | undefined;
+}
+
+interface NodeJSONIntermediateOutputData {
+    uuid: string;
+    type: string | undefined;
+    meta?: NodeJSONMeta | undefined;
+    metadata?: NodeJSONMetadata;
+    inputNodes?: NodeJSONInputNodes | undefined;
+    textures?: unknown[];
+    images?: unknown[];
+    nodes?: NodeJSONIntermediateOutputData[];
+}
+
+interface NodeJSONOutputData {
+    uuid: string;
+    type: string | undefined;
+    metadata?: NodeJSONMetadata;
+    inputNodes?: NodeJSONInputNodes | undefined;
+    textures?: unknown[];
+    images?: unknown[];
+    nodes?: NodeJSONOutputData[];
+}
+
+class Node extends EventDispatcher<{ dispose: {} }> {
+    nodeType: string | null;
+
+    updateType: NodeUpdateType;
+    updateBeforeType: NodeUpdateType;
+
+    uuid: string;
+
+    version: number;
+
+    _cacheKey: string | null;
+    _cacheKeyVersion: number;
+
+    readonly isNode: true;
+
+    readonly id!: number;
+
+    self?: this;
+
     constructor(nodeType = null) {
         super();
 
@@ -28,36 +110,36 @@ class Node extends EventDispatcher {
         Object.defineProperty(this, 'id', { value: _nodeId++ });
     }
 
-    set needsUpdate(value) {
+    set needsUpdate(value: boolean) {
         if (value === true) {
             this.version++;
         }
     }
 
     get type() {
-        return this.constructor.type;
+        return (this.constructor as NodeConstructor).type;
     }
 
-    onUpdate(callback, updateType) {
+    onUpdate(callback: (this: this, frame: NodeFrame) => void, updateType: NodeUpdateType) {
         this.updateType = updateType;
         this.update = callback.bind(this.getSelf());
 
         return this;
     }
 
-    onFrameUpdate(callback) {
+    onFrameUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.FRAME);
     }
 
-    onRenderUpdate(callback) {
+    onRenderUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.RENDER);
     }
 
-    onObjectUpdate(callback) {
+    onObjectUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.OBJECT);
     }
 
-    onReference(callback) {
+    onReference(callback: (this: this, frame: NodeBuilder | NodeFrame) => this) {
         this.updateReference = callback.bind(this.getSelf());
 
         return this;
@@ -69,11 +151,11 @@ class Node extends EventDispatcher {
         return this.self || this;
     }
 
-    updateReference(/*state*/) {
+    updateReference(state: NodeBuilder | NodeFrame) {
         return this;
     }
 
-    isGlobal(/*builder*/) {
+    isGlobal(builder: NodeBuilder) {
         return false;
     }
 
@@ -87,7 +169,7 @@ class Node extends EventDispatcher {
         this.dispatchEvent({ type: 'dispose' });
     }
 
-    traverse(callback) {
+    traverse(callback: (node: Node) => void) {
         callback(this);
 
         for (const childNode of this.getChildren()) {
@@ -106,7 +188,7 @@ class Node extends EventDispatcher {
         return this._cacheKey;
     }
 
-    getHash(/*builder*/) {
+    getHash(builder: NodeBuilder) {
         return this.uuid;
     }
 
@@ -118,14 +200,14 @@ class Node extends EventDispatcher {
         return this.updateBeforeType;
     }
 
-    getElementType(builder) {
+    getElementType(builder: NodeBuilder) {
         const type = this.getNodeType(builder);
         const elementType = builder.getElementType(type);
 
         return elementType;
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder): string | null {
         const nodeProperties = builder.getNodeProperties(this);
 
         if (nodeProperties.outputNode) {
@@ -135,25 +217,25 @@ class Node extends EventDispatcher {
         return this.nodeType;
     }
 
-    getShared(builder) {
+    getShared(builder: NodeBuilder) {
         const hash = this.getHash(builder);
         const nodeFromHash = builder.getNodeFromHash(hash);
 
         return nodeFromHash || this;
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder): Node | null {
         const nodeProperties = builder.getNodeProperties(this);
 
         for (const childNode of this.getChildren()) {
-            nodeProperties['_node' + childNode.id] = childNode;
+            nodeProperties[`_node${childNode.id}`] = childNode;
         }
 
         // return a outputNode if exists
         return null;
     }
 
-    construct(builder) {
+    construct(builder: NodeBuilder) {
         // @deprecated, r157
 
         console.warn('THREE.Node: construct() is deprecated. Use setup() instead.');
@@ -161,14 +243,14 @@ class Node extends EventDispatcher {
         return this.setup(builder);
     }
 
-    increaseUsage(builder) {
+    increaseUsage(builder: NodeBuilder) {
         const nodeData = builder.getDataFromNode(this);
         nodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;
 
         return nodeData.usageCount;
     }
 
-    analyze(builder) {
+    analyze(builder: NodeBuilder) {
         const usageCount = this.increaseUsage(builder);
 
         if (usageCount === 1) {
@@ -177,14 +259,14 @@ class Node extends EventDispatcher {
             const nodeProperties = builder.getNodeProperties(this);
 
             for (const childNode of Object.values(nodeProperties)) {
-                if (childNode && childNode.isNode === true) {
-                    childNode.build(builder);
+                if (childNode && (childNode as Node).isNode === true) {
+                    (childNode as Node).build(builder);
                 }
             }
         }
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null): string | null | undefined {
         const { outputNode } = builder.getNodeProperties(this);
 
         if (outputNode && outputNode.isNode === true) {
@@ -192,15 +274,15 @@ class Node extends EventDispatcher {
         }
     }
 
-    updateBefore(/*frame*/) {
+    updateBefore(frame: NodeFrame) {
         console.warn('Abstract function.');
     }
 
-    update(/*frame*/) {
+    update(frame: NodeFrame) {
         console.warn('Abstract function.');
     }
 
-    build(builder, output = null) {
+    build(builder: NodeBuilder, output: string | null = null): string | null {
         const refNode = this.getShared(builder);
 
         if (this !== refNode) {
@@ -235,8 +317,8 @@ class Node extends EventDispatcher {
                 }
 
                 for (const childNode of Object.values(properties)) {
-                    if (childNode && childNode.isNode === true) {
-                        childNode.build(builder);
+                    if (childNode && (childNode as Node).isNode === true) {
+                        (childNode as Node).build(builder);
                     }
                 }
             }
@@ -272,10 +354,10 @@ class Node extends EventDispatcher {
         return getNodeChildren(this);
     }
 
-    serialize(json) {
+    serialize(json: NodeJSONIntermediateOutputData) {
         const nodeChildren = this.getSerializeChildren();
 
-        const inputNodes = {};
+        const inputNodes: NodeJSONInputNodes = {};
 
         for (const { property, index, childNode } of nodeChildren) {
             if (index !== undefined) {
@@ -283,7 +365,9 @@ class Node extends EventDispatcher {
                     inputNodes[property] = Number.isInteger(index) ? [] : {};
                 }
 
-                inputNodes[property][index] = childNode.toJSON(json.meta).uuid;
+                (inputNodes[property]! as { [index: number | string]: string })[index] = childNode.toJSON(
+                    json.meta,
+                ).uuid;
             } else {
                 inputNodes[property] = childNode.toJSON(json.meta).uuid;
             }
@@ -294,39 +378,39 @@ class Node extends EventDispatcher {
         }
     }
 
-    deserialize(json) {
+    deserialize(json: NodeJSONInputData) {
         if (json.inputNodes !== undefined) {
             const nodes = json.meta.nodes;
 
             for (const property in json.inputNodes) {
                 if (Array.isArray(json.inputNodes[property])) {
-                    const inputArray = [];
+                    const inputArray: Node[] = [];
 
-                    for (const uuid of json.inputNodes[property]) {
+                    for (const uuid of json.inputNodes[property] as string[]) {
                         inputArray.push(nodes[uuid]);
                     }
 
-                    this[property] = inputArray;
+                    (this[property as keyof typeof this] as Node[]) = inputArray;
                 } else if (typeof json.inputNodes[property] === 'object') {
-                    const inputObject = {};
+                    const inputObject: { [subProperty: string]: Node } = {};
 
-                    for (const subProperty in json.inputNodes[property]) {
-                        const uuid = json.inputNodes[property][subProperty];
+                    for (const subProperty in json.inputNodes[property] as { [subProperty: string]: string }) {
+                        const uuid = (json.inputNodes[property] as { [subProperty: string]: string })[subProperty];
 
                         inputObject[subProperty] = nodes[uuid];
                     }
 
-                    this[property] = inputObject;
+                    (this[property as keyof typeof this] as { [subProperty: string]: Node }) = inputObject;
                 } else {
-                    const uuid = json.inputNodes[property];
+                    const uuid = json.inputNodes[property] as string;
 
-                    this[property] = nodes[uuid];
+                    (this[property as keyof typeof this] as Node) = nodes[uuid];
                 }
             }
         }
     }
 
-    toJSON(meta) {
+    toJSON(meta?: NodeJSONMeta | string): NodeJSONOutputData {
         const { uuid, type } = this;
         const isRoot = meta === undefined || typeof meta === 'string';
 
@@ -335,18 +419,18 @@ class Node extends EventDispatcher {
                 textures: {},
                 images: {},
                 nodes: {},
-            };
+            } satisfies NodeJSONMeta;
         }
 
         // serialize
 
-        let data = meta.nodes[uuid];
+        let data = (meta as NodeJSONMeta).nodes[uuid];
 
         if (data === undefined) {
             data = {
                 uuid,
                 type,
-                meta,
+                meta: meta as NodeJSONMeta,
                 metadata: {
                     version: 4.6,
                     type: 'Node',
@@ -354,7 +438,7 @@ class Node extends EventDispatcher {
                 },
             };
 
-            if (isRoot !== true) meta.nodes[data.uuid] = data;
+            if (isRoot !== true) (meta as NodeJSONMeta).nodes[data.uuid] = data;
 
             this.serialize(data);
 
@@ -363,12 +447,12 @@ class Node extends EventDispatcher {
 
         // TODO: Copied from Object3D.toJSON
 
-        function extractFromCache(cache) {
+        function extractFromCache<T>(cache: { [key: string]: T }) {
             const values = [];
 
             for (const key in cache) {
                 const data = cache[key];
-                delete data.metadata;
+                delete (data as NodeJSONIntermediateOutputData).metadata;
                 values.push(data);
             }
 
@@ -376,9 +460,9 @@ class Node extends EventDispatcher {
         }
 
         if (isRoot) {
-            const textures = extractFromCache(meta.textures);
-            const images = extractFromCache(meta.images);
-            const nodes = extractFromCache(meta.nodes);
+            const textures = extractFromCache((meta as NodeJSONMeta).textures);
+            const images = extractFromCache((meta as NodeJSONMeta).images);
+            const nodes = extractFromCache((meta as NodeJSONMeta).nodes);
 
             if (textures.length > 0) data.textures = textures;
             if (images.length > 0) data.images = images;
@@ -391,7 +475,7 @@ class Node extends EventDispatcher {
 
 export default Node;
 
-export function addNodeClass(type, nodeClass) {
+export function addNodeClass(type: string, nodeClass: typeof Node) {
     if (typeof nodeClass !== 'function' || !type) throw new Error(`Node class ${type} is not a class`);
     if (NodeClasses.has(type)) {
         console.warn(`Redefinition of node class ${type}`);
@@ -399,10 +483,10 @@ export function addNodeClass(type, nodeClass) {
     }
 
     NodeClasses.set(type, nodeClass);
-    nodeClass.type = type;
+    (nodeClass as NodeConstructor).type = type;
 }
 
-export function createNodeFromType(type) {
+export function createNodeFromType(type: string) {
     const Class = NodeClasses.get(type);
 
     if (Class !== undefined) {
diff --git a/examples-jsm/examples/nodes/core/NodeAttribute.ts b/examples-jsm/examples/nodes/core/NodeAttribute.ts
index 190fe8c..d873bb2 100644
--- a/examples-jsm/examples/nodes/core/NodeAttribute.ts
+++ b/examples-jsm/examples/nodes/core/NodeAttribute.ts
@@ -1,5 +1,13 @@
+import Node from './Node.js';
+
 class NodeAttribute {
-    constructor(name, type, node = null) {
+    readonly isNodeAttribute: true;
+
+    name: string;
+    type: string | null;
+    node: Node | null;
+
+    constructor(name: string, type: string | null, node: Node | null = null) {
         this.isNodeAttribute = true;
 
         this.name = name;
diff --git a/examples-jsm/examples/nodes/core/NodeBuilder.ts b/examples-jsm/examples/nodes/core/NodeBuilder.ts
index ebdc13f..a077bb0 100644
--- a/examples-jsm/examples/nodes/core/NodeBuilder.ts
+++ b/examples-jsm/examples/nodes/core/NodeBuilder.ts
@@ -8,7 +8,7 @@ import NodeCache from './NodeCache.js';
 import ParameterNode from './ParameterNode.js';
 import FunctionNode from '../code/FunctionNode.js';
 import { createNodeMaterialFromType, default as NodeMaterial } from '../materials/NodeMaterial.js';
-import { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';
+import { NodeUpdateType, defaultBuildStages, shaderStages, NodeShaderStage } from './constants.js';
 
 import {
     FloatNodeUniform,
@@ -30,6 +30,12 @@ import {
     IntType,
     UnsignedIntType,
     Float16BufferAttribute,
+    Object3D,
+    Material,
+    Mesh,
+    BufferGeometry,
+    Scene,
+    RenderTargetOptions,
 } from 'three';
 
 import { stack } from './StackNode.js';
@@ -39,6 +45,12 @@ import CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';
 import ChainMap from '../../renderers/common/ChainMap.js';
 
 import PMREMGenerator from '../../renderers/common/extras/PMREMGenerator.js';
+import Renderer from '../../renderers/common/Renderer.js';
+import NodeParser from './NodeParser.js';
+import Node from './Node.js';
+import LightsNode from '../lighting/LightsNode.js';
+import EnvironmentNode from '../lighting/EnvironmentNode.js';
+import FogNode from '../fog/FogNode.js';
 
 const uniformsGroupCache = new ChainMap();
 
@@ -67,10 +79,75 @@ const toFloat = value => {
 };
 
 class NodeBuilder {
-    constructor(object, renderer, parser, scene = null, material = null) {
+    object: Object3D;
+    material: Material | Material[];
+    geometry: BufferGeometry;
+    renderer: Renderer;
+    parser: NodeParser;
+    scene: Scene | null;
+
+    nodes: Node[];
+    updateNodes: Node[];
+    updateBeforeNodes: Node[];
+    hashNodes: { [hash: string]: Node };
+
+    lightsNode: LightsNode | null;
+    environmentNode: EnvironmentNode | null;
+    fogNode: FogNode | null;
+
+    // TODO
+    // clippingContext
+
+    vertexShader: string | null;
+    fragmentShader: string | null;
+    computeShader: string | null;
+
+    flowNodes: { vertex: Node[]; fragment: Node[]; compute: Node[] };
+    // TODO
+    // flowCode
+    uniforms: { vertex: NodeUniform[]; fragment: NodeUniform[]; compute: NodeUniform[]; index: number };
+    structs: { vertex: Node[]; fragment: Node[]; compute: Node[]; index: number };
+    // TODO
+    // bindings
+    bindingsOffset: { vertex: number; fragment: number; compute: number };
+    // TODO
+    // bindingsArray
+    // attributes
+    bufferAttributes: NodeAttribute[];
+    varyings: NodeVarying[];
+    codes: { vertex?: NodeCode[] | undefined; fragment?: NodeCode[] | undefined; compute?: NodeCode[] | undefined };
+    vars: { vertex?: NodeVar[] | undefined; fragment?: NodeVar[] | undefined; compute?: NodeVar[] | undefined };
+    flow: { code: string };
+    chaining: Node[];
+    // TODO
+    // stack
+    // stacks
+    tab: string;
+
+    // TODO
+    // currentFunctionNode
+
+    context: { keywords: NodeKeywords; material: Material | Material[]; tempRead?: boolean };
+
+    cache: NodeCache;
+    globalCache: NodeCache;
+
+    // TODO
+    // flowsData
+
+    shaderStage: NodeShaderStage | null;
+    buildStage: string | null;
+
+    constructor(
+        object: Object3D,
+        renderer: Renderer,
+        parser: NodeParser,
+        scene: Scene | null = null,
+        material: Material | null = null,
+    ) {
         this.object = object;
-        this.material = material || (object && object.material) || null;
-        this.geometry = (object && object.geometry) || null;
+        this.material = material || (object && (object as Mesh).material) || null;
+        this.geometry = (object && (object as Mesh).geometry) || null;
         this.renderer = renderer;
         this.parser = parser;
         this.scene = scene;
@@ -124,7 +201,7 @@ class NodeBuilder {
         this.buildStage = null;
     }
 
-    createRenderTarget(width, height, options) {
+    createRenderTarget(width?: number, height?: number, options?: RenderTargetOptions) {
         return new RenderTarget(width, height, options);
     }
 
@@ -138,7 +215,7 @@ class NodeBuilder {
         return new PMREMGenerator(this.renderer);
     }
 
-    includes(node) {
+    includes(node: Node) {
         return this.nodes.includes(node);
     }
 
@@ -181,11 +258,11 @@ class NodeBuilder {
         return bindingsArray;
     }
 
-    setHashNode(node, hash) {
+    setHashNode(node: Node, hash: string) {
         this.hashNodes[hash] = node;
     }
 
-    addNode(node) {
+    addNode(node: Node) {
         if (this.nodes.includes(node) === false) {
             this.nodes.push(node);
 
@@ -212,7 +289,7 @@ class NodeBuilder {
         return this.chaining[this.chaining.length - 1];
     }
 
-    addChain(node) {
+    addChain(node: Node) {
         /*
 		if ( this.chaining.indexOf( node ) !== - 1 ) {
 
@@ -224,7 +301,7 @@ class NodeBuilder {
         this.chaining.push(node);
     }
 
-    removeChain(node) {
+    removeChain(node: Node) {
         const lastChain = this.chaining.pop();
 
         if (lastChain !== node) {
@@ -232,15 +309,15 @@ class NodeBuilder {
         }
     }
 
-    getMethod(method) {
+    getMethod(method: string) {
         return method;
     }
 
-    getNodeFromHash(hash) {
+    getNodeFromHash(hash: string) {
         return this.hashNodes[hash];
     }
 
-    addFlow(shaderStage, node) {
+    addFlow(shaderStage: NodeShaderStage, node: Node) {
         this.flowNodes[shaderStage].push(node);
 
         return node;
@@ -254,7 +331,7 @@ class NodeBuilder {
         return this.context;
     }
 
-    setCache(cache) {
+    setCache(cache: NodeCache) {
         this.cache = cache;
     }
 
@@ -262,7 +339,7 @@ class NodeBuilder {
         return this.cache;
     }
 
-    isAvailable(/*name*/) {
+    isAvailable(name: string) {
         return false;
     }
 
@@ -332,7 +409,7 @@ class NodeBuilder {
         throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);
     }
 
-    getType(type) {
+    getType(type: string | null) {
         if (type === 'color') return 'vec3';
 
         return type;
@@ -378,7 +455,7 @@ class NodeBuilder {
         return /mat\d/.test(type);
     }
 
-    isReference(type) {
+    isReference(type: string | null) {
         return (
             type === 'void' ||
             type === 'property' ||
@@ -405,7 +482,7 @@ class NodeBuilder {
         return 'float';
     }
 
-    getElementType(type) {
+    getElementType(type: string | null) {
         if (type === 'mat2') return 'vec2';
         if (type === 'mat3') return 'vec3';
         if (type === 'mat4') return 'vec4';
@@ -413,7 +490,7 @@ class NodeBuilder {
         return this.getComponentType(type);
     }
 
-    getComponentType(type) {
+    getComponentType(type: string | null) {
         type = this.getVectorType(type);
 
         if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;
@@ -429,7 +506,7 @@ class NodeBuilder {
         return 'float';
     }
 
-    getVectorType(type) {
+    getVectorType(type: string | null) {
         if (type === 'color') return 'vec3';
         if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D')
             return 'vec4';
@@ -468,7 +545,7 @@ class NodeBuilder {
         return this.getTypeFromLength(itemSize, arrayType);
     }
 
-    getTypeLength(type) {
+    getTypeLength(type: string | null) {
         const vecType = this.getVectorType(type);
         const vecNum = /vec([2-4])/.exec(vecType);
 
@@ -515,7 +592,11 @@ class NodeBuilder {
         return lastStack;
     }
 
-    getDataFromNode(node, shaderStage = this.shaderStage, cache = null) {
+    getDataFromNode(
+        node: Node,
+        shaderStage: NodeShaderStage | 'any' = this.shaderStage!,
+        cache: NodeCache | null = null,
+    ) {
         cache = cache === null ? (node.isGlobal(this) ? this.globalCache : this.cache) : cache;
 
         let nodeData = cache.getNodeData(node);
@@ -528,16 +609,16 @@ class NodeBuilder {
 
         if (nodeData[shaderStage] === undefined) nodeData[shaderStage] = {};
 
-        return nodeData[shaderStage];
+        return nodeData[shaderStage]!;
     }
 
-    getNodeProperties(node, shaderStage = 'any') {
+    getNodeProperties(node: Node, shaderStage: NodeShaderStage | 'any' = 'any') {
         const nodeData = this.getDataFromNode(node, shaderStage);
 
         return nodeData.properties || (nodeData.properties = { outputNode: null });
     }
 
-    getBufferAttributeFromNode(node, type) {
+    getBufferAttributeFromNode(node: Node, type: string | null) {
         const nodeData = this.getDataFromNode(node);
 
         let bufferAttribute = nodeData.bufferAttribute;
@@ -555,7 +636,7 @@ class NodeBuilder {
         return bufferAttribute;
     }
 
-    getStructTypeFromNode(node, shaderStage = this.shaderStage) {
+    getStructTypeFromNode(node: Node, shaderStage = this.shaderStage!) {
         const nodeData = this.getDataFromNode(node, shaderStage);
 
         if (nodeData.structType === undefined) {
@@ -570,7 +651,7 @@ class NodeBuilder {
         return node;
     }
 
-    getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {
+    getUniformFromNode(node: Node, type: string | null, shaderStage = this.shaderStage!, name: string | null = null) {
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
         let nodeUniform = nodeData.uniform;
@@ -588,7 +669,12 @@ class NodeBuilder {
         return nodeUniform;
     }
 
-    getVarFromNode(node, name = null, type = node.getNodeType(this), shaderStage = this.shaderStage) {
+    getVarFromNode(
+        node: Node,
+        name: string | null = null,
+        type = node.getNodeType(this),
+        shaderStage = this.shaderStage!,
+    ) {
         const nodeData = this.getDataFromNode(node, shaderStage);
 
         let nodeVar = nodeData.variable;
@@ -608,7 +694,7 @@ class NodeBuilder {
         return nodeVar;
     }
 
-    getVaryingFromNode(node, name = null, type = node.getNodeType(this)) {
+    getVaryingFromNode(node: Node, name: string | null = null, type = node.getNodeType(this)) {
         const nodeData = this.getDataFromNode(node, 'any');
 
         let nodeVarying = nodeData.varying;
@@ -629,7 +715,7 @@ class NodeBuilder {
         return nodeVarying;
     }
 
-    getCodeFromNode(node, type, shaderStage = this.shaderStage) {
+    getCodeFromNode(node: Node, type: string | null, shaderStage = this.shaderStage!) {
         const nodeData = this.getDataFromNode(node);
 
         let nodeCode = nodeData.code;
@@ -648,7 +734,7 @@ class NodeBuilder {
         return nodeCode;
     }
 
-    addLineFlowCode(code) {
+    addLineFlowCode(code: string) {
         if (code === '') return this;
 
         code = this.tab + code;
@@ -662,7 +748,7 @@ class NodeBuilder {
         return this;
     }
 
-    addFlowCode(code) {
+    addFlowCode(code: string) {
         this.flow.code += code;
 
         return this;
@@ -684,7 +770,7 @@ class NodeBuilder {
         return this.flowsData.get(node);
     }
 
-    flowNode(node) {
+    flowNode(node: Node) {
         const output = node.getNodeType(this);
 
         const flowData = this.flowChildNode(node, output);
@@ -940,7 +1026,7 @@ class NodeBuilder {
         return createNodeMaterialFromType(type);
     }
 
-    format(snippet, fromType, toType) {
+    format(snippet: string, fromType: string | null, toType: string | null): string {
         fromType = this.getVectorType(fromType);
         toType = this.getVectorType(toType);
 
diff --git a/examples-jsm/examples/nodes/core/NodeCache.ts b/examples-jsm/examples/nodes/core/NodeCache.ts
index 96a7e0c..b1a61b3 100644
--- a/examples-jsm/examples/nodes/core/NodeCache.ts
+++ b/examples-jsm/examples/nodes/core/NodeCache.ts
@@ -1,16 +1,52 @@
+import Node from './Node.js';
+import NodeAttribute from './NodeAttribute.js';
+import NodeUniform from './NodeUniform.js';
+import NodeVar from './NodeVar.js';
+import NodeVarying from './NodeVarying.js';
+import NodeCode from './NodeCode.js';
+
 let id = 0;
 
+export interface ShaderStageNodeData {
+    properties?:
+        | ({
+              outputNode: Node | null;
+              initialized?: boolean | undefined;
+          } & {
+              [K in `_node${string}`]?: Node | undefined;
+          })
+        | undefined;
+    bufferAttribute?: NodeAttribute | undefined;
+    structType?: Node | undefined;
+    uniform?: NodeUniform | undefined;
+    variable?: NodeVar | undefined;
+    varying?: NodeVarying | undefined;
+    code?: NodeCode | undefined;
+    usageCount?: number | undefined;
+    snippet?: string | undefined;
+}
+
+interface NodeData {
+    vertex?: ShaderStageNodeData | undefined;
+    fragment?: ShaderStageNodeData | undefined;
+    compute?: ShaderStageNodeData | undefined;
+    any?: ShaderStageNodeData | undefined;
+}
+
 class NodeCache {
+    id: number;
+    nodesData: WeakMap<Node, NodeData>;
+
     constructor() {
         this.id = id++;
         this.nodesData = new WeakMap();
     }
 
-    getNodeData(node) {
+    getNodeData(node: Node) {
         return this.nodesData.get(node);
     }
 
-    setNodeData(node, data) {
+    setNodeData(node: Node, data: NodeData) {
         this.nodesData.set(node, data);
     }
 }
diff --git a/examples-jsm/examples/nodes/core/NodeFrame.ts b/examples-jsm/examples/nodes/core/NodeFrame.ts
index b8e8d37..399c788 100644
--- a/examples-jsm/examples/nodes/core/NodeFrame.ts
+++ b/examples-jsm/examples/nodes/core/NodeFrame.ts
@@ -1,6 +1,16 @@
 import { NodeUpdateType } from './constants.js';
+import Node from './Node.js';
 
 class NodeFrame {
+    time: number;
+    deltaTime: number;
+
+    frameId: number;
+    renderId: number;
+
+    // TODO
+    // startTime
+
     constructor() {
         this.time = 0;
         this.deltaTime = 0;
@@ -35,7 +45,7 @@ class NodeFrame {
         return maps;
     }
 
-    updateBeforeNode(node) {
+    updateBeforeNode(node: Node) {
         const updateType = node.getUpdateBeforeType();
         const reference = node.updateReference(this);
 
@@ -60,7 +70,7 @@ class NodeFrame {
         }
     }
 
-    updateNode(node) {
+    updateNode(node: Node) {
         const updateType = node.getUpdateType();
         const reference = node.updateReference(this);
 
diff --git a/examples-jsm/examples/nodes/core/NodeKeywords.ts b/examples-jsm/examples/nodes/core/NodeKeywords.ts
index 53da9bf..36bdcab 100644
--- a/examples-jsm/examples/nodes/core/NodeKeywords.ts
+++ b/examples-jsm/examples/nodes/core/NodeKeywords.ts
@@ -1,11 +1,18 @@
+import Node from './Node.js';
+import NodeBuilder from './NodeBuilder.js';
+
 class NodeKeywords {
+    keywords: string[];
+    nodes: { [name: string]: Node };
+    keywordsCallback: { [name: string]: (name: string) => Node };
+
     constructor() {
         this.keywords = [];
-        this.nodes = [];
+        this.nodes = {};
         this.keywordsCallback = {};
     }
 
-    getNode(name) {
+    getNode(name: string) {
         let node = this.nodes[name];
 
         if (node === undefined && this.keywordsCallback[name] !== undefined) {
@@ -17,14 +24,14 @@ class NodeKeywords {
         return node;
     }
 
-    addKeyword(name, callback) {
+    addKeyword(name: string, callback: (name: string) => Node) {
         this.keywords.push(name);
         this.keywordsCallback[name] = callback;
 
         return this;
     }
 
-    parse(code) {
+    parse(code: string) {
         const keywordNames = this.keywords;
 
         const regExp = new RegExp(`\\b${keywordNames.join('\\b|\\b')}\\b`, 'g');
@@ -46,7 +53,7 @@ class NodeKeywords {
         return keywordNodes;
     }
 
-    include(builder, code) {
+    include(builder: NodeBuilder, code: string) {
         const keywordNodes = this.parse(code);
 
         for (const keywordNode of keywordNodes) {
diff --git a/examples-jsm/examples/nodes/core/NodeUniform.ts b/examples-jsm/examples/nodes/core/NodeUniform.ts
index 2918e21..c407d0a 100644
--- a/examples-jsm/examples/nodes/core/NodeUniform.ts
+++ b/examples-jsm/examples/nodes/core/NodeUniform.ts
@@ -1,5 +1,15 @@
+import Node from './Node.js';
+
 class NodeUniform {
-    constructor(name, type, node, needsUpdate = undefined) {
+    readonly isNodeUniform: true;
+
+    name: string;
+    type: string | null;
+    // TODO
+    // node: Node??
+    needsUpdate: boolean | undefined;
+
+    constructor(name: string, type: string | null, node: Node, needsUpdate = undefined) {
         this.isNodeUniform = true;
 
         this.name = name;
diff --git a/examples-jsm/examples/nodes/core/NodeUtils.ts b/examples-jsm/examples/nodes/core/NodeUtils.ts
index 16a5f32..6adbec5 100644
--- a/examples-jsm/examples/nodes/core/NodeUtils.ts
+++ b/examples-jsm/examples/nodes/core/NodeUtils.ts
@@ -1,10 +1,11 @@
 import { Color, Matrix3, Matrix4, Vector2, Vector3, Vector4 } from 'three';
+import Node from './Node.js';
 
-export function getCacheKey(object, force = false) {
+export function getCacheKey(object: object, force = false) {
     let cacheKey = '{';
 
-    if (object.isNode === true) {
-        cacheKey += object.id;
+    if ((object as Node).isNode === true) {
+        cacheKey += (object as Node).id;
     }
 
     for (const { property, childNode } of getNodeChildren(object)) {
@@ -16,36 +17,58 @@ export function getCacheKey(object, force = false) {
     return cacheKey;
 }
 
-export function* getNodeChildren(node, toJSON = false) {
+export interface NodeChild {
+    property: string;
+    index?: number | string;
+    childNode: Node;
+}
+
+export interface NodeChildWithToJSON {
+    property: string;
+    index?: number | string;
+    childNode: Node | { toJSON: () => unknown };
+}
+
+export function getNodeChildren(node: object): Generator<NodeChild, void>;
+export function getNodeChildren(node: object, toJSON: boolean): Generator<NodeChildWithToJSON, void>;
+export function* getNodeChildren(node: object, toJSON = false) {
     for (const property in node) {
         // Ignore private properties.
         if (property.startsWith('_') === true) continue;
 
-        const object = node[property];
+        const object = node[property as keyof typeof node] as unknown;
 
         if (Array.isArray(object) === true) {
             for (let i = 0; i < object.length; i++) {
-                const child = object[i];
-
-                if (child && (child.isNode === true || (toJSON && typeof child.toJSON === 'function'))) {
-                    yield { property, index: i, childNode: child };
+                const child = object[i] as unknown;
+
+                if (
+                    child &&
+                    ((child as Node).isNode === true ||
+                        (toJSON && typeof (child as { toJSON: () => unknown }).toJSON === 'function'))
+                ) {
+                    yield { property, index: i, childNode: child as Node | { toJSON: () => unknown } };
                 }
             }
-        } else if (object && object.isNode === true) {
-            yield { property, childNode: object };
+        } else if (object && (object as Node).isNode === true) {
+            yield { property, childNode: object as Node };
         } else if (typeof object === 'object') {
             for (const subProperty in object) {
-                const child = object[subProperty];
-
-                if (child && (child.isNode === true || (toJSON && typeof child.toJSON === 'function'))) {
-                    yield { property, index: subProperty, childNode: child };
+                const child = object[subProperty as keyof typeof object];
+
+                if (
+                    child &&
+                    ((child as Node).isNode === true ||
+                        (toJSON && typeof (child as { toJSON: () => unknown }).toJSON === 'function'))
+                ) {
+                    yield { property, index: subProperty, childNode: child as Node | { toJSON: () => unknown } };
                 }
             }
         }
     }
 }
 
-export function getValueType(value) {
+export function getValueType(value: unknown) {
     if (value === undefined || value === null) return null;
 
     const typeOf = typeof value;
diff --git a/examples-jsm/examples/nodes/core/NodeVar.ts b/examples-jsm/examples/nodes/core/NodeVar.ts
index e6e935b..8d04ff1 100644
--- a/examples-jsm/examples/nodes/core/NodeVar.ts
+++ b/examples-jsm/examples/nodes/core/NodeVar.ts
@@ -1,5 +1,10 @@
 class NodeVar {
-    constructor(name, type) {
+    readonly isNodeVar: true;
+
+    name: string;
+    type: string | null;
+
+    constructor(name: string, type: string | null) {
         this.isNodeVar = true;
 
         this.name = name;
diff --git a/examples-jsm/examples/nodes/core/NodeVarying.ts b/examples-jsm/examples/nodes/core/NodeVarying.ts
index a148236..0a62b23 100644
--- a/examples-jsm/examples/nodes/core/NodeVarying.ts
+++ b/examples-jsm/examples/nodes/core/NodeVarying.ts
@@ -1,7 +1,11 @@
 import NodeVar from './NodeVar.js';
 
 class NodeVarying extends NodeVar {
-    constructor(name, type) {
+    needsInterpolation: boolean;
+
+    readonly isNodeVarying: true;
+
+    constructor(name: string, type: string | null) {
         super(name, type);
 
         this.needsInterpolation = false;
diff --git a/examples-jsm/examples/nodes/core/constants.ts b/examples-jsm/examples/nodes/core/constants.ts
index 3b01a9a..5ff6ad5 100644
--- a/examples-jsm/examples/nodes/core/constants.ts
+++ b/examples-jsm/examples/nodes/core/constants.ts
@@ -1,14 +1,14 @@
 export const NodeShaderStage = {
     VERTEX: 'vertex',
     FRAGMENT: 'fragment',
-};
+} as const;
 
 export const NodeUpdateType = {
     NONE: 'none',
     FRAME: 'frame',
     RENDER: 'render',
     OBJECT: 'object',
-};
+} as const;
 
 export const NodeType = {
     BOOLEAN: 'bool',
@@ -20,9 +20,12 @@ export const NodeType = {
     MATRIX2: 'mat2',
     MATRIX3: 'mat3',
     MATRIX4: 'mat4',
-};
+} as const;
 
-export const defaultShaderStages = ['fragment', 'vertex'];
+export type NodeShaderStage = 'vertex' | 'fragment' | 'compute';
+export type NodeUpdateType = 'none' | 'frame' | 'render' | 'object';
+
+export const defaultShaderStages: NodeShaderStage[] = ['fragment', 'vertex'];
 export const defaultBuildStages = ['setup', 'analyze', 'generate'];
-export const shaderStages = [...defaultShaderStages, 'compute'];
+export const shaderStages: NodeShaderStage[] = [...defaultShaderStages, 'compute'];
 export const vectorComponents = ['x', 'y', 'z', 'w'];
diff --git a/examples-jsm/examples/nodes/fog/FogNode.ts b/examples-jsm/examples/nodes/fog/FogNode.ts
index 9417df5..4376155 100644
--- a/examples-jsm/examples/nodes/fog/FogNode.ts
+++ b/examples-jsm/examples/nodes/fog/FogNode.ts
@@ -1,6 +1,7 @@
 import Node, { addNodeClass } from '../core/Node.js';
 import { positionView } from '../accessors/PositionNode.js';
 import { addNodeElement, nodeProxy } from '../shadernode/ShaderNode.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 class FogNode extends Node {
     constructor(colorNode, factorNode) {
@@ -12,7 +13,7 @@ class FogNode extends Node {
         this.factorNode = factorNode;
     }
 
-    getViewZNode(builder) {
+    getViewZNode(builder: NodeBuilder) {
         let viewZ;
 
         const getViewZ = builder.context.getViewZ;
diff --git a/examples-jsm/examples/renderers/common/Animation.ts b/examples-jsm/examples/renderers/common/Animation.ts
index 0b00319..c190633 100644
--- a/examples-jsm/examples/renderers/common/Animation.ts
+++ b/examples-jsm/examples/renderers/common/Animation.ts
@@ -1,5 +1,14 @@
+import Nodes from './nodes/Nodes.js';
+import Info from './Info.js';
+
 class Animation {
-    constructor(nodes, info) {
+    nodes: Nodes;
+    info: Info;
+
+    animationLoop: ((time: DOMHighResTimeStamp, frame?: XRFrame) => void) | null;
+    requestId: number | null;
+
+    constructor(nodes: Nodes, info: Info) {
         this.nodes = nodes;
         this.info = info;
 
@@ -10,7 +19,7 @@ class Animation {
     }
 
     _init() {
-        const update = (time, frame) => {
+        const update = (time?: DOMHighResTimeStamp, frame?: XRFrame) => {
             this.requestId = self.requestAnimationFrame(update);
 
             if (this.info.autoReset === true) this.info.reset();
@@ -19,18 +28,18 @@ class Animation {
 
             this.info.frame = this.nodes.nodeFrame.frameId;
 
-            if (this.animationLoop !== null) this.animationLoop(time, frame);
+            if (this.animationLoop !== null) this.animationLoop(time!, frame);
         };
 
         update();
     }
 
     dispose() {
-        self.cancelAnimationFrame(this.requestId);
+        self.cancelAnimationFrame(this.requestId!);
         this.requestId = null;
     }
 
-    setAnimationLoop(callback) {
+    setAnimationLoop(callback: ((time: DOMHighResTimeStamp, frame?: XRFrame) => void) | null) {
         this.animationLoop = callback;
     }
 }
diff --git a/examples-jsm/examples/renderers/common/Attributes.ts b/examples-jsm/examples/renderers/common/Attributes.ts
index ed9e8e9..f0f7502 100644
--- a/examples-jsm/examples/renderers/common/Attributes.ts
+++ b/examples-jsm/examples/renderers/common/Attributes.ts
@@ -1,9 +1,12 @@
 import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
 import { DynamicDrawUsage } from 'three';
+import Backend from './Backend.js';
 
 class Attributes extends DataMap {
-    constructor(backend) {
+    backend: Backend;
+
+    constructor(backend: Backend) {
         super();
 
         this.backend = backend;
diff --git a/examples-jsm/examples/renderers/common/Backend.ts b/examples-jsm/examples/renderers/common/Backend.ts
index e48a802..0232478 100644
--- a/examples-jsm/examples/renderers/common/Backend.ts
+++ b/examples-jsm/examples/renderers/common/Backend.ts
@@ -1,22 +1,41 @@
-let vector2 = null;
-let vector4 = null;
-let color4 = null;
-
 import Color4 from './Color4.js';
-import { Vector2, Vector4, REVISION, createCanvasElement } from 'three';
+import { Vector2, Vector4, REVISION, createCanvasElement, CoordinateSystem } from 'three';
+import Renderer from './Renderer.js';
+import RenderContext from './RenderContext.js';
+import RenderBundle from './RenderBundle.js';
+
+let vector2: Vector2 | null = null;
+let vector4: Vector4 | null = null;
+let color4: Color4 | null = null;
+
+export interface BackendParameters {
+    canvas?: HTMLCanvasElement | undefined;
+    antialias?: boolean;
+}
+
+interface RenderContextData {}
 
-class Backend {
-    constructor(parameters = {}) {
+interface RenderBundleData {}
+
+abstract class Backend {
+    parameters: BackendParameters;
+    data: WeakMap<RenderContext | RenderBundle, RenderContextData | RenderBundleData>;
+    renderer: Renderer | null;
+    domElement: HTMLCanvasElement | null;
+
+    constructor(parameters: BackendParameters = {}) {
         this.parameters = Object.assign({}, parameters);
-        this.data = new WeakMap();
+        this.data = new WeakMap<RenderContext, RenderContextData>();
         this.renderer = null;
         this.domElement = null;
     }
 
-    async init(renderer) {
+    async init(renderer: Renderer) {
         this.renderer = renderer;
     }
 
+    abstract get coordinateSystem(): CoordinateSystem;
+
     // render context
 
     begin(renderContext) {}
@@ -144,7 +163,7 @@ class Backend {
         this.data.set(object, value);
     }
 
-    get(object) {
+    get(object: RenderContext | RenderBundle) {
         let map = this.data.get(object);
 
         if (map === undefined) {
@@ -155,11 +174,11 @@ class Backend {
         return map;
     }
 
-    has(object) {
+    has(object: RenderContext) {
         return this.data.has(object);
     }
 
-    delete(object) {
+    delete(object: RenderContext) {
         this.data.delete(object);
     }
 }
diff --git a/examples-jsm/examples/renderers/common/Background.ts b/examples-jsm/examples/renderers/common/Background.ts
index b7902dd..57497c3 100644
--- a/examples-jsm/examples/renderers/common/Background.ts
+++ b/examples-jsm/examples/renderers/common/Background.ts
@@ -1,6 +1,6 @@
 import DataMap from './DataMap.js';
 import Color4 from './Color4.js';
-import { Mesh, SphereGeometry, BackSide, LinearSRGBColorSpace } from 'three';
+import { Mesh, SphereGeometry, BackSide, LinearSRGBColorSpace, Scene } from 'three';
 import {
     vec4,
     context,
@@ -10,18 +10,27 @@ import {
     NodeMaterial,
     modelViewProjection,
 } from '../../nodes/Nodes.js';
+import Renderer from './Renderer.js';
+import Nodes from './nodes/Nodes.js';
+import RenderList from './RenderList.js';
+import RenderContext from './RenderContext.js';
 
 const _clearColor = new Color4();
 
-class Background extends DataMap {
-    constructor(renderer, nodes) {
+interface SceneData {}
+
+class Background extends DataMap<{ scene: { key: Scene; value: SceneData } }> {
+    renderer: Renderer;
+    nodes: Nodes;
+
+    constructor(renderer: Renderer, nodes: Nodes) {
         super();
 
         this.renderer = renderer;
         this.nodes = nodes;
     }
 
-    update(scene, renderList, renderContext) {
+    update(scene: Scene, renderList: RenderList, renderContext: RenderContext) {
         const renderer = this.renderer;
         const background = this.nodes.getBackgroundNode(scene) || scene.background;
 
diff --git a/examples-jsm/examples/renderers/common/Bindings.ts b/examples-jsm/examples/renderers/common/Bindings.ts
index 9485ec3..6a39a1d 100644
--- a/examples-jsm/examples/renderers/common/Bindings.ts
+++ b/examples-jsm/examples/renderers/common/Bindings.ts
@@ -1,8 +1,28 @@
 import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
+import Backend from './Backend.js';
+import Nodes from './nodes/Nodes.js';
+import Textures from './Textures.js';
+import Attributes from './Attributes.js';
+import Pipelines from './Pipelines.js';
+import Info from './Info.js';
 
 class Bindings extends DataMap {
-    constructor(backend, nodes, textures, attributes, pipelines, info) {
+    backend: Backend;
+    textures: Textures;
+    pipelines: Pipelines;
+    attributes: Attributes;
+    nodes: Nodes;
+    info: Info;
+
+    constructor(
+        backend: Backend,
+        nodes: Nodes,
+        textures: Textures,
+        attributes: Attributes,
+        pipelines: Pipelines,
+        info: Info,
+    ) {
         super();
 
         this.backend = backend;
diff --git a/examples-jsm/examples/renderers/common/ChainMap.ts b/examples-jsm/examples/renderers/common/ChainMap.ts
index e233bec..c4e8a2e 100644
--- a/examples-jsm/examples/renderers/common/ChainMap.ts
+++ b/examples-jsm/examples/renderers/common/ChainMap.ts
@@ -1,56 +1,48 @@
-export default class ChainMap {
+type RecursiveWeakMap<K extends readonly object[], V> = WeakMap<K[number], V | RecursiveWeakMap<K, V>>;
+
+export default class ChainMap<K extends readonly object[], V> {
+    weakMap: RecursiveWeakMap<K, V>;
+
     constructor() {
-        this.weakMap = new WeakMap();
+        this.weakMap = new WeakMap<K[number], V | RecursiveWeakMap<K, V>>();
     }
 
-    get(keys) {
-        if (Array.isArray(keys)) {
-            let map = this.weakMap;
+    get(keys: K): V | undefined {
+        let map: RecursiveWeakMap<K, V> | undefined = this.weakMap;
 
-            for (let i = 0; i < keys.length; i++) {
-                map = map.get(keys[i]);
+        for (let i = 0; i < keys.length; i++) {
+            map = map.get(keys[i]) as RecursiveWeakMap<K, V> | undefined;
 
-                if (map === undefined) return undefined;
-            }
-
-            return map.get(keys[keys.length - 1]);
-        } else {
-            return super.get(keys);
+            if (map === undefined) return undefined;
         }
-    }
 
-    set(keys, value) {
-        if (Array.isArray(keys)) {
-            let map = this.weakMap;
+        return map.get(keys[keys.length - 1]) as V | undefined;
+    }
 
-            for (let i = 0; i < keys.length; i++) {
-                const key = keys[i];
+    set(keys: K, value: V) {
+        let map: RecursiveWeakMap<K, V> = this.weakMap;
 
-                if (map.has(key) === false) map.set(key, new WeakMap());
+        for (let i = 0; i < keys.length; i++) {
+            const key = keys[i];
 
-                map = map.get(key);
-            }
+            if (map.has(key) === false) map.set(key, new WeakMap<K[number], V | RecursiveWeakMap<K, V>>());
 
-            return map.set(keys[keys.length - 1], value);
-        } else {
-            return super.set(keys, value);
+            map = map.get(key) as RecursiveWeakMap<K, V>;
         }
-    }
 
-    delete(keys) {
-        if (Array.isArray(keys)) {
-            let map = this.weakMap;
+        return map.set(keys[keys.length - 1], value) as V;
+    }
 
-            for (let i = 0; i < keys.length; i++) {
-                map = map.get(keys[i]);
+    delete(keys: K) {
+        let map: RecursiveWeakMap<K, V> | undefined = this.weakMap;
 
-                if (map === undefined) return false;
-            }
+        for (let i = 0; i < keys.length; i++) {
+            map = map.get(keys[i]) as RecursiveWeakMap<K, V> | undefined;
 
-            return map.delete(keys[keys.length - 1]);
-        } else {
-            return super.delete(keys);
+            if (map === undefined) return false;
         }
+
+        return map.delete(keys[keys.length - 1]);
     }
 
     dispose() {
diff --git a/examples-jsm/examples/renderers/common/ClippingContext.ts b/examples-jsm/examples/renderers/common/ClippingContext.ts
index 312e0b7..807083f 100644
--- a/examples-jsm/examples/renderers/common/ClippingContext.ts
+++ b/examples-jsm/examples/renderers/common/ClippingContext.ts
@@ -5,6 +5,20 @@ const _plane = new Plane();
 let _clippingContextVersion = 0;
 
 class ClippingContext {
+    version: number;
+
+    globalClippingCount: number;
+
+    localClippingCount: number;
+    localClippingEnabled: boolean;
+    localClipIntersection: boolean;
+
+    // TODO
+    // planes
+
+    parentVersion: number;
+    viewNormalMatrix: Matrix3;
+
     constructor() {
         this.version = ++_clippingContextVersion;
 
diff --git a/examples-jsm/examples/renderers/common/Color4.ts b/examples-jsm/examples/renderers/common/Color4.ts
index c681cc9..5d03ade 100644
--- a/examples-jsm/examples/renderers/common/Color4.ts
+++ b/examples-jsm/examples/renderers/common/Color4.ts
@@ -1,26 +1,31 @@
-import { Color } from 'three';
+import { Color, ColorRepresentation } from 'three';
 
 class Color4 extends Color {
-    constructor(r, g, b, a = 1) {
-        super(r, g, b);
+    a: number;
+
+    constructor(color?: ColorRepresentation);
+    constructor(r: number, g: number, b: number, a?: number);
+    constructor(r?: number, g?: number, b?: number, a = 1) {
+        super(r as number, g!, b!);
 
         this.a = a;
     }
 
-    set(r, g, b, a = 1) {
+    set(...args: [color: ColorRepresentation] | [r: number, g: number, b: number, a?: number]): this;
+    set(r: number, g: number, b: number, a = 1) {
         this.a = a;
 
         return super.set(r, g, b);
     }
 
-    copy(color) {
-        if (color.a !== undefined) this.a = color.a;
+    copy(color: Color) {
+        if ((color as Color4).a !== undefined) this.a = (color as Color4).a;
 
         return super.copy(color);
     }
 
-    clone() {
-        return new this.constructor(this.r, this.g, this.b, this.a);
+    clone(): this {
+        return new (this.constructor as typeof Color4)(this.r, this.g, this.b, this.a) as this;
     }
 }
 
diff --git a/examples-jsm/examples/renderers/common/Constants.ts b/examples-jsm/examples/renderers/common/Constants.ts
index 0d0c35a..53caf06 100644
--- a/examples-jsm/examples/renderers/common/Constants.ts
+++ b/examples-jsm/examples/renderers/common/Constants.ts
@@ -2,7 +2,7 @@ export const AttributeType = {
     VERTEX: 1,
     INDEX: 2,
     STORAGE: 4,
-};
+} as const;
 
 // size of a chunk in bytes (STD140 layout)
 
diff --git a/examples-jsm/examples/renderers/common/DataMap.ts b/examples-jsm/examples/renderers/common/DataMap.ts
index 006bc29..eb39fca 100644
--- a/examples-jsm/examples/renderers/common/DataMap.ts
+++ b/examples-jsm/examples/renderers/common/DataMap.ts
@@ -1,9 +1,11 @@
-class DataMap {
+class DataMap<M extends { [key: string]: { key: object; value: unknown } }> {
+    data: WeakMap<M[keyof M]['key'], M[keyof M]['value']>;
+
     constructor() {
-        this.data = new WeakMap();
+        this.data = new WeakMap<M[keyof M]['key'], M[keyof M]['value']>();
     }
 
-    get(object) {
+    get<K extends M[keyof M]['key']>(object: K): Extract<M[keyof M], { key: K }>['value'] {
         let map = this.data.get(object);
 
         if (map === undefined) {
@@ -14,7 +16,7 @@ class DataMap {
         return map;
     }
 
-    delete(object) {
+    delete<K extends M[keyof M]['key']>(object: K): Extract<M[keyof M], { key: K }>['value'] {
         let map;
 
         if (this.data.has(object)) {
@@ -26,7 +28,7 @@ class DataMap {
         return map;
     }
 
-    has(object) {
+    has(object: M[keyof M]['key']) {
         return this.data.has(object);
     }
 
diff --git a/examples-jsm/examples/renderers/common/Geometries.ts b/examples-jsm/examples/renderers/common/Geometries.ts
index 5da9994..79bed8a 100644
--- a/examples-jsm/examples/renderers/common/Geometries.ts
+++ b/examples-jsm/examples/renderers/common/Geometries.ts
@@ -1,6 +1,8 @@
 import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
 import { Uint32BufferAttribute, Uint16BufferAttribute } from 'three';
+import Attributes from './Attributes.js';
+import Info from './Info.js';
 
 function arrayNeedsUint32(array) {
     // assumes larger values usually on last
@@ -51,7 +53,10 @@ function getWireframeIndex(geometry) {
 }
 
 class Geometries extends DataMap {
-    constructor(attributes, info) {
+    attributes: Attributes;
+    info: Info;
+
+    constructor(attributes: Attributes, info: Info) {
         super();
 
         this.attributes = attributes;
diff --git a/examples-jsm/examples/renderers/common/Info.ts b/examples-jsm/examples/renderers/common/Info.ts
index c8e7cb4..083e7c4 100644
--- a/examples-jsm/examples/renderers/common/Info.ts
+++ b/examples-jsm/examples/renderers/common/Info.ts
@@ -1,4 +1,31 @@
+import { Line, LineSegments, Mesh, Object3D, Points, Sprite } from 'three';
+
 class Info {
+    autoReset: boolean;
+
+    frame: number;
+    calls: number;
+
+    render: {
+        calls: number;
+        drawCalls: number;
+        triangles: number;
+        points: number;
+        lines: number;
+        timestamp: number;
+    };
+
+    compute: {
+        calls: number;
+        computeCalls: number;
+        timestamp: number;
+    };
+
+    memory: {
+        geometries: number;
+        textures: number;
+    };
+
     constructor() {
         this.autoReset = true;
 
@@ -26,23 +53,23 @@ class Info {
         };
     }
 
-    update(object, count, instanceCount) {
+    update(object: Object3D, count: number, instanceCount: number) {
         this.render.drawCalls++;
 
-        if (object.isMesh || object.isSprite) {
+        if ((object as Mesh).isMesh || (object as Sprite).isSprite) {
             this.render.triangles += instanceCount * (count / 3);
-        } else if (object.isPoints) {
+        } else if ((object as Points).isPoints) {
             this.render.points += instanceCount * count;
-        } else if (object.isLineSegments) {
+        } else if ((object as LineSegments).isLineSegments) {
             this.render.lines += instanceCount * (count / 2);
-        } else if (object.isLine) {
+        } else if ((object as Line).isLine) {
             this.render.lines += instanceCount * (count - 1);
         } else {
             console.error('THREE.WebGPUInfo: Unknown object type.');
         }
     }
 
-    updateTimestamp(type, time) {
+    updateTimestamp(type: 'render' | 'compute', time: number) {
         this[type].timestamp += time;
     }
 
diff --git a/examples-jsm/examples/renderers/common/Pipelines.ts b/examples-jsm/examples/renderers/common/Pipelines.ts
index f6c570c..0a1c023 100644
--- a/examples-jsm/examples/renderers/common/Pipelines.ts
+++ b/examples-jsm/examples/renderers/common/Pipelines.ts
@@ -2,9 +2,18 @@ import DataMap from './DataMap.js';
 import RenderPipeline from './RenderPipeline.js';
 import ComputePipeline from './ComputePipeline.js';
 import ProgrammableStage from './ProgrammableStage.js';
+import Backend from './Backend.js';
+import Nodes from './nodes/Nodes.js';
+import Bindings from './Bindings.js';
+import RenderObject from './RenderObject.js';
 
 class Pipelines extends DataMap {
-    constructor(backend, nodes) {
+    backend: Backend;
+    nodes: Nodes;
+
+    bindings: Bindings | null;
+
+    constructor(backend: Backend, nodes: Nodes) {
         super();
 
         this.backend = backend;
@@ -82,7 +91,7 @@ class Pipelines extends DataMap {
         return data.pipeline;
     }
 
-    getForRender(renderObject, promises = null) {
+    getForRender(renderObject: RenderObject, promises: Promise<void>[] | null = null) {
         const { backend } = this;
 
         const data = this.get(renderObject);
diff --git a/examples-jsm/examples/renderers/common/ProgrammableStage.ts b/examples-jsm/examples/renderers/common/ProgrammableStage.ts
index a684e44..6b64362 100644
--- a/examples-jsm/examples/renderers/common/ProgrammableStage.ts
+++ b/examples-jsm/examples/renderers/common/ProgrammableStage.ts
@@ -1,6 +1,16 @@
 let _id = 0;
 
 class ProgrammableStage {
+    id: number;
+
+    // TODO
+    // code
+    // stage
+    // transforms
+    // attributes
+
+    usedTimes: number;
+
     constructor(code, type, transforms = null, attributes = null) {
         this.id = _id++;
 
diff --git a/examples-jsm/examples/renderers/common/RenderBundle.ts b/examples-jsm/examples/renderers/common/RenderBundle.ts
index e59e493..c7ba8cd 100644
--- a/examples-jsm/examples/renderers/common/RenderBundle.ts
+++ b/examples-jsm/examples/renderers/common/RenderBundle.ts
@@ -1,5 +1,10 @@
+import { Camera, Object3D } from 'three';
+
 class RenderBundle {
-    constructor(scene, camera) {
+    scene: Object3D;
+    camera: Camera;
+
+    constructor(scene: Object3D, camera: Camera) {
         this.scene = scene;
         this.camera = camera;
     }
diff --git a/examples-jsm/examples/renderers/common/RenderBundles.ts b/examples-jsm/examples/renderers/common/RenderBundles.ts
index 2914036..48f5d59 100644
--- a/examples-jsm/examples/renderers/common/RenderBundles.ts
+++ b/examples-jsm/examples/renderers/common/RenderBundles.ts
@@ -1,14 +1,17 @@
+import { Camera, Object3D } from 'three';
 import ChainMap from './ChainMap.js';
 import RenderBundle from './RenderBundle.js';
 
 class RenderBundles {
+    lists: ChainMap<readonly [Object3D, Camera], RenderBundle>;
+
     constructor() {
-        this.lists = new ChainMap();
+        this.lists = new ChainMap<readonly [Object3D, Camera], RenderBundle>();
     }
 
-    get(scene, camera) {
+    get(scene: Object3D, camera: Camera) {
         const lists = this.lists;
-        const keys = [scene, camera];
+        const keys = [scene, camera] as const;
 
         let list = lists.get(keys);
 
@@ -21,7 +24,7 @@ class RenderBundles {
     }
 
     dispose() {
-        this.lists = new ChainMap();
+        this.lists = new ChainMap<readonly [Object3D, Camera], RenderBundle>();
     }
 }
 
diff --git a/examples-jsm/examples/renderers/common/RenderContext.ts b/examples-jsm/examples/renderers/common/RenderContext.ts
index 3b43028..b53cfc7 100644
--- a/examples-jsm/examples/renderers/common/RenderContext.ts
+++ b/examples-jsm/examples/renderers/common/RenderContext.ts
@@ -1,8 +1,41 @@
 import { Vector4 } from 'three';
+import ClippingContext from './ClippingContext.js';
 
 let id = 0;
 
 class RenderContext {
+    id: number;
+
+    color: boolean;
+    clearColor: boolean;
+    clearColorValue: { r: number; g: number; b: number; a: number };
+
+    depth: boolean;
+    clearDepth: boolean;
+    clearDepthValue: number;
+
+    stencil: boolean;
+    clearStencil: boolean;
+    clearStencilValue: number;
+
+    viewport: boolean;
+    viewportValue: Vector4;
+    scissor: boolean;
+    scissorValue: Vector4;
+
+    // TODO
+    // textures
+    // depthTexture
+    activeCubeFace: number;
+    sampleCount: number;
+
+    width: number;
+    height: number;
+
+    readonly isRenderContext: true;
+
+    clippingContext?: ClippingContext | undefined;
+
     constructor() {
         this.id = id++;
 
diff --git a/examples-jsm/examples/renderers/common/RenderContexts.ts b/examples-jsm/examples/renderers/common/RenderContexts.ts
index 630a2e4..9d99c98 100644
--- a/examples-jsm/examples/renderers/common/RenderContexts.ts
+++ b/examples-jsm/examples/renderers/common/RenderContexts.ts
@@ -1,13 +1,16 @@
+import { Camera, RenderTarget, Scene } from 'three';
 import ChainMap from './ChainMap.js';
 import RenderContext from './RenderContext.js';
 
 class RenderContexts {
+    chainMaps: { [attachmentState: string]: ChainMap<readonly [Scene, Camera], RenderContext> | undefined };
+
     constructor() {
         this.chainMaps = {};
     }
 
-    get(scene, camera, renderTarget = null) {
-        const chainKey = [scene, camera];
+    get(scene: Scene, camera: Camera, renderTarget: RenderTarget | null = null) {
+        const chainKey = [scene, camera] as const;
 
         let attachmentState;
 
@@ -35,8 +38,11 @@ class RenderContexts {
         return renderState;
     }
 
-    getChainMap(attachmentState) {
-        return this.chainMaps[attachmentState] || (this.chainMaps[attachmentState] = new ChainMap());
+    getChainMap(attachmentState: string) {
+        return (
+            this.chainMaps[attachmentState] ||
+            (this.chainMaps[attachmentState] = new ChainMap<readonly [Scene, Camera], RenderContext>())
+        );
     }
 
     dispose() {
diff --git a/examples-jsm/examples/renderers/common/RenderList.ts b/examples-jsm/examples/renderers/common/RenderList.ts
index a72a91d..77c6c4a 100644
--- a/examples-jsm/examples/renderers/common/RenderList.ts
+++ b/examples-jsm/examples/renderers/common/RenderList.ts
@@ -1,3 +1,4 @@
+import { Camera, Light, Object3D } from 'three';
 import { LightsNode } from '../../nodes/Nodes.js';
 
 function painterSortStable(a, b) {
@@ -26,7 +27,27 @@ function reversePainterSortStable(a, b) {
     }
 }
 
+export interface Bundle {
+    object: Object3D;
+    camera: Camera;
+    renderList: RenderList;
+}
+
 class RenderList {
+    // TODO
+    // renderItems
+    renderItemsIndex: number;
+
+    // TODO
+    // opaque
+    // transparent
+    bundles: Bundle[];
+
+    lightsNode: LightsNode;
+    lightsArray: Light[];
+
+    occlusionQueryCount: number;
+
     constructor() {
         this.renderItems = [];
         this.renderItemsIndex = 0;
@@ -101,11 +122,11 @@ class RenderList {
         (material.transparent === true ? this.transparent : this.opaque).unshift(renderItem);
     }
 
-    pushBundle(group) {
+    pushBundle(group: Bundle) {
         this.bundles.push(group);
     }
 
-    pushLight(light) {
+    pushLight(light: Light) {
         this.lightsArray.push(light);
     }
 
diff --git a/examples-jsm/examples/renderers/common/RenderLists.ts b/examples-jsm/examples/renderers/common/RenderLists.ts
index 3fc3134..0cc369e 100644
--- a/examples-jsm/examples/renderers/common/RenderLists.ts
+++ b/examples-jsm/examples/renderers/common/RenderLists.ts
@@ -1,14 +1,17 @@
+import { Camera, Object3D } from 'three';
 import ChainMap from './ChainMap.js';
 import RenderList from './RenderList.js';
 
 class RenderLists {
+    lists: ChainMap<readonly [Object3D, Camera], RenderList>;
+
     constructor() {
-        this.lists = new ChainMap();
+        this.lists = new ChainMap<readonly [Object3D, Camera], RenderList>();
     }
 
-    get(scene, camera) {
+    get(scene: Object3D, camera: Camera) {
         const lists = this.lists;
-        const keys = [scene, camera];
+        const keys = [scene, camera] as const;
 
         let list = lists.get(keys);
 
@@ -21,7 +24,7 @@ class RenderLists {
     }
 
     dispose() {
-        this.lists = new ChainMap();
+        this.lists = new ChainMap<readonly [Object3D, Camera], RenderList>();
     }
 }
 
diff --git a/examples-jsm/examples/renderers/common/RenderObject.ts b/examples-jsm/examples/renderers/common/RenderObject.ts
index 861c15d..88a944c 100644
--- a/examples-jsm/examples/renderers/common/RenderObject.ts
+++ b/examples-jsm/examples/renderers/common/RenderObject.ts
@@ -1,4 +1,10 @@
 import ClippingContext from './ClippingContext.js';
+import Nodes from './nodes/Nodes.js';
+import Geometries from './Geometries.js';
+import Renderer from './Renderer.js';
+import { Camera, Material, Object3D, Scene } from 'three';
+import LightsNode from '../../nodes/lighting/LightsNode.js';
+import RenderContext from './RenderContext.js';
 
 let id = 0;
 
@@ -27,7 +33,60 @@ function getKeys(obj) {
 }
 
 export default class RenderObject {
-    constructor(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext) {
+    _nodes: Nodes;
+    _geometries: Geometries;
+
+    id: number;
+
+    renderer: Renderer;
+    object: Object3D;
+    material: Material;
+    scene: Scene;
+    camera: Camera;
+    lightsNode: LightsNode;
+    context: RenderContext;
+
+    // TODO
+    // geometry: BufferGeometry | undefined; ??
+    version: number;
+
+    // TODO
+    // drawRange
+
+    // TODO
+    // attributes
+    // pipeline
+    // vertexBuffers
+
+    clippingContext?: ClippingContext | undefined;
+
+    clippingContextVersion: number;
+
+    // TODO
+    // initialNodesCacheKey
+    initialCacheKey: string;
+
+    // TODO
+    // this._nodeBuilderState = null;
+    // this._bindings = null;
+
+    onDispose: (() => void) | null;
+
+    readonly isRenderObject: true;
+
+    onMaterialDispose: () => void;
+
+    constructor(
+        nodes: Nodes,
+        geometries: Geometries,
+        renderer: Renderer,
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+    ) {
         this._nodes = nodes;
         this._geometries = geometries;
 
@@ -52,7 +111,7 @@ export default class RenderObject {
 
         this.updateClipping(renderContext.clippingContext);
 
-        this.clippingContextVersion = this.clippingContext.version;
+        this.clippingContextVersion = this.clippingContext!.version;
 
         this.initialNodesCacheKey = this.getNodesCacheKey();
         this.initialCacheKey = this.getCacheKey();
@@ -71,7 +130,7 @@ export default class RenderObject {
         this.material.addEventListener('dispose', this.onMaterialDispose);
     }
 
-    updateClipping(parent) {
+    updateClipping(parent: ClippingContext | undefined) {
         const material = this.material;
 
         let clippingContext = this.clippingContext;
@@ -89,9 +148,9 @@ export default class RenderObject {
     }
 
     get clippingNeedsUpdate() {
-        if (this.clippingContext.version === this.clippingContextVersion) return false;
+        if (this.clippingContext!.version === this.clippingContextVersion) return false;
 
-        this.clippingContextVersion = this.clippingContext.version;
+        this.clippingContextVersion = this.clippingContext!.version;
 
         return true;
     }
@@ -109,7 +168,7 @@ export default class RenderObject {
     }
 
     getChainArray() {
-        return [this.object, this.material, this.context, this.lightsNode];
+        return [this.object, this.material, this.context, this.lightsNode] as const;
     }
 
     getAttributes() {
@@ -206,6 +265,6 @@ export default class RenderObject {
     dispose() {
         this.material.removeEventListener('dispose', this.onMaterialDispose);
 
-        this.onDispose();
+        this.onDispose!();
     }
 }
diff --git a/examples-jsm/examples/renderers/common/RenderObjects.ts b/examples-jsm/examples/renderers/common/RenderObjects.ts
index 76dc482..a5ce085 100644
--- a/examples-jsm/examples/renderers/common/RenderObjects.ts
+++ b/examples-jsm/examples/renderers/common/RenderObjects.ts
@@ -1,8 +1,33 @@
 import ChainMap from './ChainMap.js';
 import RenderObject from './RenderObject.js';
+import Renderer from './Renderer.js';
+import Nodes from './nodes/Nodes.js';
+import Geometries from './Geometries.js';
+import Pipelines from './Pipelines.js';
+import Bindings from './Bindings.js';
+import Info from './Info.js';
+import LightsNode from '../../nodes/lighting/LightsNode.js';
+import { Camera, Material, Object3D, Scene } from 'three';
+import RenderContext from './RenderContext.js';
 
 class RenderObjects {
-    constructor(renderer, nodes, geometries, pipelines, bindings, info) {
+    renderer: Renderer;
+    nodes: Nodes;
+    geometries: Geometries;
+    pipelines: Pipelines;
+    bindings: Bindings;
+    info: Info;
+
+    chainMaps: { [passId: string]: ChainMap<readonly [Object3D, Material, RenderContext, LightsNode], RenderObject> };
+
+    constructor(
+        renderer: Renderer,
+        nodes: Nodes,
+        geometries: Geometries,
+        pipelines: Pipelines,
+        bindings: Bindings,
+        info: Info,
+    ) {
         this.renderer = renderer;
         this.nodes = nodes;
         this.geometries = geometries;
@@ -13,9 +38,17 @@ class RenderObjects {
         this.chainMaps = {};
     }
 
-    get(object, material, scene, camera, lightsNode, renderContext, passId) {
+    get(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+        passId: string | undefined,
+    ): RenderObject {
         const chainMap = this.getChainMap(passId);
-        const chainArray = [object, material, renderContext, lightsNode];
+        const chainArray = [object, material, renderContext, lightsNode] as const;
 
         let renderObject = chainMap.get(chainArray);
 
@@ -52,7 +85,13 @@ class RenderObjects {
     }
 
     getChainMap(passId = 'default') {
-        return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());
+        return (
+            this.chainMaps[passId] ||
+            (this.chainMaps[passId] = new ChainMap<
+                readonly [Object3D, Material, RenderContext, LightsNode],
+                RenderObject
+            >())
+        );
     }
 
     dispose() {
@@ -60,16 +99,16 @@ class RenderObjects {
     }
 
     createRenderObject(
-        nodes,
-        geometries,
-        renderer,
-        object,
-        material,
-        scene,
-        camera,
-        lightsNode,
-        renderContext,
-        passId,
+        nodes: Nodes,
+        geometries: Geometries,
+        renderer: Renderer,
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+        passId: string | undefined,
     ) {
         const chainMap = this.getChainMap(passId);
 
diff --git a/examples-jsm/examples/renderers/common/Renderer.ts b/examples-jsm/examples/renderers/common/Renderer.ts
index acf180d..6aef7ad 100644
--- a/examples-jsm/examples/renderers/common/Renderer.ts
+++ b/examples-jsm/examples/renderers/common/Renderer.ts
@@ -30,10 +30,36 @@ import {
     RenderTarget,
     HalfFloatType,
     RGBAFormat,
+    ColorSpace,
+    ToneMapping,
+    Plane,
+    ShadowMapType,
+    Camera,
+    Color,
+    Object3D,
+    FramebufferTexture,
+    Texture,
+    Box2,
+    BufferGeometry,
+    Material,
+    Group,
+    Light,
+    LOD,
+    Sprite,
+    LineLoop,
+    Mesh,
+    Line,
+    Points,
 } from 'three';
 import { NodeMaterial } from '../../nodes/Nodes.js';
 import QuadMesh from '../../objects/QuadMesh.js';
 import RenderBundles from './RenderBundles.js';
+import Backend from './Backend.js';
+import Node from '../../nodes/core/Node.js';
+import LightsNode from '../../nodes/lighting/LightsNode.js';
+import RenderContext from './RenderContext.js';
+import RenderBundle from './RenderBundle.js';
+import RenderList, { Bundle } from './RenderList.js';
 
 const _scene = new Scene();
 const _drawingBufferSize = new Vector2();
@@ -43,8 +69,123 @@ const _projScreenMatrix = new Matrix4();
 const _vector3 = new Vector3();
 const _quad = new QuadMesh(new NodeMaterial());
 
+export interface RendererParameters {
+    logarithmicDepthBuffer?: boolean | undefined;
+    alpha?: boolean | undefined;
+}
+
 class Renderer {
-    constructor(backend, parameters = {}) {
+    readonly isRenderer: true;
+
+    domElement: HTMLCanvasElement | null;
+
+    backend: Backend;
+
+    autoClear: boolean;
+    autoClearColor: boolean;
+    autoClearDepth: boolean;
+    autoClearStencil: boolean;
+
+    alpha: boolean;
+
+    logarithmicDepthBuffer: boolean;
+
+    outputColorSpace: ColorSpace;
+
+    toneMapping: ToneMapping;
+    toneMappingExposure: number;
+
+    sortObjects: boolean;
+
+    depth: boolean;
+    stencil: boolean;
+
+    clippingPlanes: Plane[];
+
+    info: Info;
+
+    toneMappingNode: Node | null;
+
+    _pixelRatio: number;
+    _width: number;
+    _height: number;
+
+    _viewport: Vector4;
+    _scissor: Vector4;
+    _scissorTest: boolean;
+
+    _attributes: Attributes | null;
+    _geometries: Geometries | null;
+    _nodes: Nodes | null;
+    _animation: Animation | null;
+    _bindings: Bindings | null;
+    _objects: RenderObjects | null;
+    _pipelines: Pipelines | null;
+    _bundles: RenderBundles | null;
+    _renderLists: RenderLists | null;
+    _renderContexts: RenderContexts | null;
+    _textures: Textures | null;
+    _background: Background | null;
+
+    _currentRenderContext: RenderContext | null;
+
+    _opaqueSort: ((a: unknown, b: unknown) => number) | null;
+    _transparentSort: ((a: unknown, b: unknown) => number) | null;
+
+    _frameBufferTarget: RenderTarget | null;
+
+    _clearColor: Color4;
+    _clearDepth: number;
+    _clearStencil: number;
+
+    _renderTarget: RenderTarget | null;
+    _activeCubeFace: number;
+    _activeMipmapLevel: number;
+
+    _renderObjectFunction:
+        | ((
+              object: Object3D,
+              scene: Scene,
+              camera: Camera,
+              geometry: BufferGeometry,
+              material: Material,
+              group: Group,
+              lightsNode: LightsNode,
+          ) => void)
+        | null;
+    _currentRenderObjectFunction:
+        | ((
+              object: Object3D,
+              scene: Scene,
+              camera: Camera,
+              geometry: BufferGeometry,
+              material: Material,
+              group: Group,
+              lightsNode: LightsNode,
+          ) => void)
+        | null;
+    _currentRenderBundle: RenderBundle | null;
+
+    _handleObjectFunction: (
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: Group,
+        passId?: string,
+    ) => void;
+
+    _initialized: boolean;
+    _initPromise: Promise<void> | null;
+
+    _compilationPromises: Promise<void>[] | null;
+
+    shadowMap: { enabled: boolean; type: ShadowMapType | null };
+
+    xr: { enabled: boolean };
+
+    constructor(backend: Backend, parameters: RendererParameters = {}) {
         this.isRenderer = true;
 
         //
@@ -207,12 +348,12 @@ class Renderer {
         return this.backend.coordinateSystem;
     }
 
-    async compileAsync(scene, camera, targetScene = null) {
+    async compileAsync(scene: Scene, camera: Camera, targetScene: Scene | null = null) {
         if (this._initialized === false) await this.init();
 
         // preserve render tree
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
         const previousRenderContext = this._currentRenderContext;
@@ -226,10 +367,10 @@ class Renderer {
         if (targetScene === null) targetScene = scene;
 
         const renderTarget = this._renderTarget;
-        const renderContext = this._renderContexts.get(targetScene, camera, renderTarget);
+        const renderContext = this._renderContexts!.get(targetScene, camera, renderTarget);
         const activeMipmapLevel = this._activeMipmapLevel;
 
-        const compilationPromises = [];
+        const compilationPromises: Promise<void>[] = [];
 
         this._currentRenderContext = renderContext;
         this._currentRenderObjectFunction = this.renderObject;
@@ -258,7 +399,7 @@ class Renderer {
 
         //
 
-        const renderList = this._renderLists.get(scene, camera);
+        const renderList = this._renderLists!.get(scene, camera);
         renderList.begin();
 
         this._projectObject(scene, camera, 0, renderList);
@@ -266,8 +407,8 @@ class Renderer {
         // include lights from target scene
         if (targetScene !== scene) {
             targetScene.traverseVisible(function (object) {
-                if (object.isLight && object.layers.test(camera.layers)) {
-                    renderList.pushLight(object);
+                if ((object as Light).isLight && object.layers.test(camera.layers)) {
+                    renderList.pushLight(object as Light);
                 }
             });
         }
@@ -277,9 +418,9 @@ class Renderer {
         //
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
+            this._textures!.updateRenderTarget(renderTarget, activeMipmapLevel);
 
-            const renderTargetData = this._textures.get(renderTarget);
+            const renderTargetData = this._textures!.get(renderTarget);
 
             renderContext.textures = renderTargetData.textures;
             renderContext.depthTexture = renderTargetData.depthTexture;
@@ -290,11 +431,11 @@ class Renderer {
 
         //
 
-        this._nodes.updateScene(sceneRef);
+        this._nodes!.updateScene(sceneRef);
 
         //
 
-        this._background.update(sceneRef, renderList, renderContext);
+        this._background!.update(sceneRef, renderList, renderContext);
 
         // process render lists
 
@@ -320,7 +461,7 @@ class Renderer {
         await Promise.all(compilationPromises);
     }
 
-    async renderAsync(scene, camera) {
+    async renderAsync(scene: Scene, camera: Camera) {
         if (this._initialized === false) await this.init();
 
         const renderContext = this._renderScene(scene, camera);
@@ -328,15 +469,15 @@ class Renderer {
         await this.backend.resolveTimestampAsync(renderContext, 'render');
     }
 
-    _renderBundle(bundle, sceneRef, lightsNode) {
+    _renderBundle(bundle: Bundle, sceneRef: Scene, lightsNode: LightsNode) {
         const { object, camera, renderList } = bundle;
 
-        const renderContext = this._currentRenderContext;
+        const renderContext = this._currentRenderContext!;
         const renderContextData = this.backend.get(renderContext);
 
         //
 
-        const renderBundle = this._bundles.get(object, camera);
+        const renderBundle = this._bundles!.get(object, camera);
 
         const renderBundleData = this.backend.get(renderBundle);
         if (renderBundleData.renderContexts === undefined) renderBundleData.renderContexts = new Set();
@@ -350,7 +491,7 @@ class Renderer {
 
         if (renderBundleNeedsUpdate) {
             if (renderContextData.renderObjects === undefined || object.needsUpdate === true) {
-                const nodeFrame = this._nodes.nodeFrame;
+                const nodeFrame = this._nodes!.nodeFrame;
 
                 renderContextData.renderObjects = [];
                 renderContextData.renderBundles = [];
@@ -373,13 +514,13 @@ class Renderer {
 
             object.needsUpdate = false;
         } else {
-            const renderContext = this._currentRenderContext;
+            const renderContext = this._currentRenderContext!;
             const renderContextData = this.backend.get(renderContext);
 
             for (let i = 0, l = renderContextData.renderObjects.length; i < l; i++) {
                 const renderObject = renderContextData.renderObjects[i];
 
-                this._nodes.updateBefore(renderObject);
+                this._nodes!.updateBefore(renderObject);
 
                 //
 
@@ -389,15 +530,15 @@ class Renderer {
                 );
                 renderObject.object.normalMatrix.getNormalMatrix(renderObject.object.modelViewMatrix);
 
-                this._nodes.updateForRender(renderObject);
-                this._bindings.updateForRender(renderObject);
+                this._nodes!.updateForRender(renderObject);
+                this._bindings!.updateForRender(renderObject);
 
                 this.backend.draw(renderObject, this.info);
             }
         }
     }
 
-    render(scene, camera) {
+    render(scene: Scene, camera: Camera) {
         if (this._initialized === false) {
             console.warn(
                 'THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.',
@@ -453,12 +594,12 @@ class Renderer {
         return frameBufferTarget;
     }
 
-    _renderScene(scene, camera, useFrameBufferTarget = true) {
+    _renderScene(scene: Scene, camera: Camera, useFrameBufferTarget = true) {
         const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;
 
         // preserve render tree
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
         const previousRenderContext = this._currentRenderContext;
@@ -487,7 +628,7 @@ class Renderer {
 
         //
 
-        const renderContext = this._renderContexts.get(scene, camera, renderTarget);
+        const renderContext = this._renderContexts!.get(scene, camera, renderTarget);
 
         this._currentRenderContext = renderContext;
         this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;
@@ -558,7 +699,7 @@ class Renderer {
         _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
         _frustum.setFromProjectionMatrix(_projScreenMatrix, coordinateSystem);
 
-        const renderList = this._renderLists.get(scene, camera);
+        const renderList = this._renderLists!.get(scene, camera);
         renderList.begin();
 
         this._projectObject(scene, camera, 0, renderList);
@@ -572,9 +713,9 @@ class Renderer {
         //
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
+            this._textures!.updateRenderTarget(renderTarget, activeMipmapLevel);
 
-            const renderTargetData = this._textures.get(renderTarget);
+            const renderTargetData = this._textures!.get(renderTarget);
 
             renderContext.textures = renderTargetData.textures;
             renderContext.depthTexture = renderTargetData.depthTexture;
@@ -586,8 +727,8 @@ class Renderer {
         } else {
             renderContext.textures = null;
             renderContext.depthTexture = null;
-            renderContext.width = this.domElement.width;
-            renderContext.height = this.domElement.height;
+            renderContext.width = this.domElement!.width;
+            renderContext.height = this.domElement!.height;
             renderContext.depth = this.depth;
             renderContext.stencil = this.stencil;
         }
@@ -600,11 +741,11 @@ class Renderer {
 
         //
 
-        this._nodes.updateScene(sceneRef);
+        this._nodes!.updateScene(sceneRef);
 
         //
 
-        this._background.update(sceneRef, renderList, renderContext);
+        this._background!.update(sceneRef, renderList, renderContext);
 
         //
 
@@ -637,7 +778,7 @@ class Renderer {
         if (frameBufferTarget !== null) {
             this.setRenderTarget(outputRenderTarget, activeCubeFace, activeMipmapLevel);
 
-            _quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);
+            _quad.material.fragmentNode = this._nodes!.getOutputNode(renderTarget.texture);
 
             this._renderScene(_quad, _quad.camera, false);
         }
@@ -663,10 +804,10 @@ class Renderer {
         return this._activeMipmapLevel;
     }
 
-    async setAnimationLoop(callback) {
+    async setAnimationLoop(callback: ((time: DOMHighResTimeStamp, frame?: XRFrame) => void) | null) {
         if (this._initialized === false) await this.init();
 
-        this._animation.setAnimationLoop(callback);
+        this._animation!.setAnimationLoop(callback);
     }
 
     getArrayBuffer(attribute) {
@@ -689,11 +830,11 @@ class Renderer {
         return this._pixelRatio;
     }
 
-    getDrawingBufferSize(target) {
+    getDrawingBufferSize(target: Vector2) {
         return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
     }
 
-    getSize(target) {
+    getSize(target: Vector2) {
         return target.set(this._width, this._height);
     }
 
@@ -703,30 +844,30 @@ class Renderer {
         this.setSize(this._width, this._height, false);
     }
 
-    setDrawingBufferSize(width, height, pixelRatio) {
+    setDrawingBufferSize(width: number, height: number, pixelRatio: number) {
         this._width = width;
         this._height = height;
 
         this._pixelRatio = pixelRatio;
 
-        this.domElement.width = Math.floor(width * pixelRatio);
-        this.domElement.height = Math.floor(height * pixelRatio);
+        this.domElement!.width = Math.floor(width * pixelRatio);
+        this.domElement!.height = Math.floor(height * pixelRatio);
 
         this.setViewport(0, 0, width, height);
 
         if (this._initialized) this.backend.updateSize();
     }
 
-    setSize(width, height, updateStyle = true) {
+    setSize(width: number, height: number, updateStyle = true) {
         this._width = width;
         this._height = height;
 
-        this.domElement.width = Math.floor(width * this._pixelRatio);
-        this.domElement.height = Math.floor(height * this._pixelRatio);
+        this.domElement!.width = Math.floor(width * this._pixelRatio);
+        this.domElement!.height = Math.floor(height * this._pixelRatio);
 
         if (updateStyle === true) {
-            this.domElement.style.width = width + 'px';
-            this.domElement.style.height = height + 'px';
+            this.domElement!.style.width = width + 'px';
+            this.domElement!.style.height = height + 'px';
         }
 
         this.setViewport(0, 0, width, height);
@@ -734,15 +875,15 @@ class Renderer {
         if (this._initialized) this.backend.updateSize();
     }
 
-    setOpaqueSort(method) {
+    setOpaqueSort(method: ((a: unknown, b: unknown) => number) | null) {
         this._opaqueSort = method;
     }
 
-    setTransparentSort(method) {
+    setTransparentSort(method: ((a: unknown, b: unknown) => number) | null) {
         this._transparentSort = method;
     }
 
-    getScissor(target) {
+    getScissor(target: Vector4) {
         const scissor = this._scissor;
 
         target.x = scissor.x;
@@ -753,13 +894,15 @@ class Renderer {
         return target;
     }
 
-    setScissor(x, y, width, height) {
+    setScissor(x: Vector4): void;
+    setScissor(x: number, y: number, width: number, height: number): void;
+    setScissor(x: Vector4 | number, y?: number, width?: number, height?: number) {
         const scissor = this._scissor;
 
-        if (x.isVector4) {
-            scissor.copy(x);
+        if ((x as Vector4).isVector4) {
+            scissor.copy(x as Vector4);
         } else {
-            scissor.set(x, y, width, height);
+            scissor.set(x as number, y!, width!, height!);
         }
     }
 
@@ -767,34 +910,36 @@ class Renderer {
         return this._scissorTest;
     }
 
-    setScissorTest(boolean) {
+    setScissorTest(boolean: boolean) {
         this._scissorTest = boolean;
 
         this.backend.setScissorTest(boolean);
     }
 
-    getViewport(target) {
+    getViewport(target: Vector4) {
         return target.copy(this._viewport);
     }
 
-    setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {
+    setViewport(x: Vector4): void;
+    setViewport(x: number, y: number, width: number, height: number, minDepth?: number, maxDepth?: number): void;
+    setViewport(x: Vector4 | number, y?: number, width?: number, height?: number, minDepth = 0, maxDepth = 1) {
         const viewport = this._viewport;
 
-        if (x.isVector4) {
-            viewport.copy(x);
+        if ((x as Vector4).isVector4) {
+            viewport.copy(x as Vector4);
         } else {
-            viewport.set(x, y, width, height);
+            viewport.set(x as number, y!, width!, height!);
         }
 
         viewport.minDepth = minDepth;
         viewport.maxDepth = maxDepth;
     }
 
-    getClearColor(target) {
+    getClearColor(target: Color4) {
         return target.copy(this._clearColor);
     }
 
-    setClearColor(color, alpha = 1) {
+    setClearColor(color: Color, alpha = 1) {
         this._clearColor.set(color);
         this._clearColor.a = alpha;
     }
@@ -803,7 +948,7 @@ class Renderer {
         return this._clearColor.a;
     }
 
-    setClearAlpha(alpha) {
+    setClearAlpha(alpha: number) {
         this._clearColor.a = alpha;
     }
 
@@ -811,7 +956,7 @@ class Renderer {
         return this._clearDepth;
     }
 
-    setClearDepth(depth) {
+    setClearDepth(depth: number) {
         this._clearDepth = depth;
     }
 
@@ -819,11 +964,11 @@ class Renderer {
         return this._clearStencil;
     }
 
-    setClearStencil(stencil) {
+    setClearStencil(stencil: number) {
         this._clearStencil = stencil;
     }
 
-    isOccluded(object) {
+    isOccluded(object: Object3D) {
         const renderContext = this._currentRenderContext;
 
         return renderContext && this.backend.isOccluded(renderContext, object);
@@ -843,9 +988,9 @@ class Renderer {
         let renderTargetData = null;
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget);
+            this._textures!.updateRenderTarget(renderTarget);
 
-            renderTargetData = this._textures.get(renderTarget);
+            renderTargetData = this._textures!.get(renderTarget);
         }
 
         this.backend.clear(color, depth, stencil, renderTargetData);
@@ -896,20 +1041,20 @@ class Renderer {
     dispose() {
         this.info.dispose();
 
-        this._animation.dispose();
-        this._objects.dispose();
-        this._pipelines.dispose();
-        this._nodes.dispose();
-        this._bindings.dispose();
-        this._renderLists.dispose();
-        this._renderContexts.dispose();
-        this._textures.dispose();
+        this._animation!.dispose();
+        this._objects!.dispose();
+        this._pipelines!.dispose();
+        this._nodes!.dispose();
+        this._bindings!.dispose();
+        this._renderLists!.dispose();
+        this._renderContexts!.dispose();
+        this._textures!.dispose();
 
         this.setRenderTarget(null);
         this.setAnimationLoop(null);
     }
 
-    setRenderTarget(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
+    setRenderTarget(renderTarget: RenderTarget | null, activeCubeFace = 0, activeMipmapLevel = 0) {
         this._renderTarget = renderTarget;
         this._activeCubeFace = activeCubeFace;
         this._activeMipmapLevel = activeMipmapLevel;
@@ -927,10 +1072,10 @@ class Renderer {
         return this._renderObjectFunction;
     }
 
-    async computeAsync(computeNodes) {
+    async computeAsync(computeNodes: ComputeNode | ComputeNode[]) {
         if (this._initialized === false) await this.init();
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
 
@@ -993,13 +1138,13 @@ class Renderer {
         nodeFrame.renderId = previousRenderId;
     }
 
-    async hasFeatureAsync(name) {
+    async hasFeatureAsync(name: string) {
         if (this._initialized === false) await this.init();
 
         return this.backend.hasFeature(name);
     }
 
-    hasFeature(name) {
+    hasFeature(name: string) {
         if (this._initialized === false) {
             console.warn(
                 'THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.',
@@ -1011,64 +1156,77 @@ class Renderer {
         return this.backend.hasFeature(name);
     }
 
-    copyFramebufferToTexture(framebufferTexture) {
+    copyFramebufferToTexture(framebufferTexture: FramebufferTexture) {
         const renderContext = this._currentRenderContext;
 
-        this._textures.updateTexture(framebufferTexture);
+        this._textures!.updateTexture(framebufferTexture);
 
         this.backend.copyFramebufferToTexture(framebufferTexture, renderContext);
     }
 
-    copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
-        this._textures.updateTexture(srcTexture);
-        this._textures.updateTexture(dstTexture);
+    copyTextureToTexture(
+        srcTexture: Texture,
+        dstTexture: Texture,
+        srcRegion: Box2 | null = null,
+        dstPosition: Vector2 | null = null,
+        level = 0,
+    ) {
+        this._textures!.updateTexture(srcTexture);
+        this._textures!.updateTexture(dstTexture);
 
         this.backend.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);
     }
 
-    readRenderTargetPixelsAsync(renderTarget, x, y, width, height, index = 0) {
+    readRenderTargetPixelsAsync(
+        renderTarget: RenderTarget,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+        index = 0,
+    ) {
         return this.backend.copyTextureToBuffer(renderTarget.textures[index], x, y, width, height);
     }
 
-    _projectObject(object, camera, groupOrder, renderList) {
+    _projectObject(object: Object3D, camera: Camera, groupOrder: number, renderList: RenderList) {
         if (object.visible === false) return;
 
         const visible = object.layers.test(camera.layers);
 
         if (visible) {
-            if (object.isGroup) {
+            if ((object as Group).isGroup) {
                 groupOrder = object.renderOrder;
-            } else if (object.isLOD) {
-                if (object.autoUpdate === true) object.update(camera);
-            } else if (object.isLight) {
-                renderList.pushLight(object);
-            } else if (object.isSprite) {
-                if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
+            } else if ((object as LOD).isLOD) {
+                if ((object as LOD).autoUpdate === true) (object as LOD).update(camera);
+            } else if ((object as Light).isLight) {
+                renderList.pushLight(object as Light);
+            } else if ((object as Sprite).isSprite) {
+                if (!object.frustumCulled || _frustum.intersectsSprite(object as Sprite)) {
                     if (this.sortObjects === true) {
                         _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                     }
 
-                    const geometry = object.geometry;
-                    const material = object.material;
+                    const geometry = (object as Sprite).geometry;
+                    const material = (object as Sprite).material;
 
                     if (material.visible) {
                         renderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                     }
                 }
-            } else if (object.isLineLoop) {
+            } else if ((object as LineLoop).isLineLoop) {
                 console.error(
                     'THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.',
                 );
-            } else if (object.isMesh || object.isLine || object.isPoints) {
+            } else if ((object as Mesh).isMesh || (object as Line).isLine || (object as Points).isPoints) {
                 if (!object.frustumCulled || _frustum.intersectsObject(object)) {
-                    const geometry = object.geometry;
-                    const material = object.material;
+                    const geometry = (object as Mesh | Line | Points).geometry;
+                    const material = (object as Mesh | Line | Points).material;
 
                     if (this.sortObjects === true) {
                         if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
 
                         _vector3
-                            .copy(geometry.boundingSphere.center)
+                            .copy(geometry.boundingSphere!.center)
                             .applyMatrix4(object.matrixWorld)
                             .applyMatrix4(_projScreenMatrix);
                     }
@@ -1078,7 +1236,7 @@ class Renderer {
 
                         for (let i = 0, l = groups.length; i < l; i++) {
                             const group = groups[i];
-                            const groupMaterial = material[group.materialIndex];
+                            const groupMaterial = material[group.materialIndex!];
 
                             if (groupMaterial && groupMaterial.visible) {
                                 renderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
@@ -1095,7 +1253,7 @@ class Renderer {
             const baseRenderList = renderList;
 
             // replace render list
-            renderList = this._renderLists.get(object, camera);
+            renderList = this._renderLists!.get(object, camera);
 
             renderList.begin();
 
@@ -1115,7 +1273,7 @@ class Renderer {
         }
     }
 
-    _renderBundles(bundles, sceneRef, lightsNode) {
+    _renderBundles(bundles: Bundle[], sceneRef: Scene, lightsNode: LightsNode) {
         for (const bundle of bundles) {
             this._renderBundle(bundle, sceneRef, lightsNode);
         }
@@ -1167,7 +1325,15 @@ class Renderer {
         }
     }
 
-    renderObject(object, scene, camera, geometry, material, group, lightsNode) {
+    renderObject(
+        object: Object3D,
+        scene: Scene,
+        camera: Camera,
+        geometry: BufferGeometry,
+        material: Material,
+        group: Group,
+        lightsNode: LightsNode,
+    ) {
         let overridePositionNode;
         let overrideFragmentNode;
         let overrideDepthNode;
@@ -1254,8 +1420,16 @@ class Renderer {
         object.onAfterRender(this, scene, camera, geometry, material, group);
     }
 
-    _renderObjectDirect(object, material, scene, camera, lightsNode, group, passId) {
-        const renderObject = this._objects.get(
+    _renderObjectDirect(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: Group,
+        passId?: string,
+    ) {
+        const renderObject = this._objects!.get(
             object,
             material,
             scene,
@@ -1268,7 +1442,7 @@ class Renderer {
 
         //
 
-        this._nodes.updateBefore(renderObject);
+        this._nodes!.updateBefore(renderObject);
 
         //
 
@@ -1277,10 +1451,10 @@ class Renderer {
 
         //
 
-        this._nodes.updateForRender(renderObject);
-        this._geometries.updateForRender(renderObject);
-        this._bindings.updateForRender(renderObject);
-        this._pipelines.updateForRender(renderObject);
+        this._nodes!.updateForRender(renderObject);
+        this._geometries!.updateForRender(renderObject);
+        this._bindings!.updateForRender(renderObject);
+        this._pipelines!.updateForRender(renderObject);
 
         //
 
@@ -1300,28 +1474,36 @@ class Renderer {
         }
     }
 
-    _createObjectPipeline(object, material, scene, camera, lightsNode, passId) {
-        const renderObject = this._objects.get(
+    _createObjectPipeline(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: Group,
+        passId?: string,
+    ) {
+        const renderObject = this._objects!.get(
             object,
             material,
             scene,
             camera,
             lightsNode,
-            this._currentRenderContext,
+            this._currentRenderContext!,
             passId,
         );
 
         //
 
-        this._nodes.updateBefore(renderObject);
+        this._nodes!.updateBefore(renderObject);
 
         //
 
-        this._nodes.updateForRender(renderObject);
-        this._geometries.updateForRender(renderObject);
-        this._bindings.updateForRender(renderObject);
+        this._nodes!.updateForRender(renderObject);
+        this._geometries!.updateForRender(renderObject);
+        this._bindings!.updateForRender(renderObject);
 
-        this._pipelines.getForRender(renderObject, this._compilationPromises);
+        this._pipelines!.getForRender(renderObject, this._compilationPromises);
     }
 
     get compute() {
diff --git a/examples-jsm/examples/renderers/common/Textures.ts b/examples-jsm/examples/renderers/common/Textures.ts
index 0eb0509..e170865 100644
--- a/examples-jsm/examples/renderers/common/Textures.ts
+++ b/examples-jsm/examples/renderers/common/Textures.ts
@@ -14,12 +14,23 @@ import {
     CubeReflectionMapping,
     CubeRefractionMapping,
     UnsignedByteType,
+    RenderTarget,
+    Texture,
 } from 'three';
+import Renderer from './Renderer.js';
+import Backend from './Backend.js';
+import Info from './Info.js';
 
 const _size = new Vector3();
 
-class Textures extends DataMap {
-    constructor(renderer, backend, info) {
+interface RenderTargetData {}
+
+class Textures extends DataMap<{ renderTarget: { key: RenderTarget; value: RenderTargetData } }> {
+    renderer: Renderer;
+    backend: Backend;
+    info: Info;
+
+    constructor(renderer: Renderer, backend: Backend, info: Info) {
         super();
 
         this.renderer = renderer;
@@ -27,7 +38,7 @@ class Textures extends DataMap {
         this.info = info;
     }
 
-    updateRenderTarget(renderTarget, activeMipmapLevel = 0) {
+    updateRenderTarget(renderTarget: RenderTarget, activeMipmapLevel = 0) {
         const renderTargetData = this.get(renderTarget);
 
         const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
@@ -116,7 +127,7 @@ class Textures extends DataMap {
         }
     }
 
-    updateTexture(texture, options = {}) {
+    updateTexture(texture: Texture, options = {}) {
         const textureData = this.get(texture);
         if (textureData.initialized === true && textureData.version === texture.version) return;
 
@@ -229,7 +240,7 @@ class Textures extends DataMap {
         textureData.version = texture.version;
     }
 
-    getSize(texture, target = _size) {
+    getSize(texture: Texture, target = _size) {
         let image = texture.images ? texture.images[0] : texture.image;
 
         if (image) {
@@ -245,7 +256,7 @@ class Textures extends DataMap {
         return target;
     }
 
-    getMipLevels(texture, width, height) {
+    getMipLevels(texture: Texture, width: number, height: number) {
         let mipLevelCount;
 
         if (texture.isCompressedTexture) {
@@ -257,7 +268,7 @@ class Textures extends DataMap {
         return mipLevelCount;
     }
 
-    needsMipmaps(texture) {
+    needsMipmaps(texture: Texture) {
         if (this.isEnvironmentTexture(texture)) return true;
 
         return (
@@ -266,7 +277,7 @@ class Textures extends DataMap {
         );
     }
 
-    isEnvironmentTexture(texture) {
+    isEnvironmentTexture(texture: Texture) {
         const mapping = texture.mapping;
 
         return (
@@ -277,7 +288,7 @@ class Textures extends DataMap {
         );
     }
 
-    _destroyTexture(texture) {
+    _destroyTexture(texture: Texture) {
         this.backend.destroySampler(texture);
         this.backend.destroyTexture(texture);
 
diff --git a/examples-jsm/examples/renderers/common/nodes/Nodes.ts b/examples-jsm/examples/renderers/common/nodes/Nodes.ts
index 86df565..b038962 100644
--- a/examples-jsm/examples/renderers/common/nodes/Nodes.ts
+++ b/examples-jsm/examples/renderers/common/nodes/Nodes.ts
@@ -2,10 +2,16 @@ import DataMap from '../DataMap.js';
 import ChainMap from '../ChainMap.js';
 import NodeBuilderState from './NodeBuilderState.js';
 import {
+    Color,
+    CubeTexture,
     EquirectangularReflectionMapping,
     EquirectangularRefractionMapping,
+    Fog,
+    FogExp2,
     NoToneMapping,
+    Scene,
     SRGBColorSpace,
+    Texture,
 } from 'three';
 import {
     NodeFrame,
@@ -23,9 +29,19 @@ import {
     pmremTexture,
     viewportTopLeft,
 } from '../../../nodes/Nodes.js';
+import Renderer from '../Renderer.js';
+import Backend from '../Backend.js';
+import LightsNode from '../../../nodes/lighting/LightsNode.js';
 
 class Nodes extends DataMap {
-    constructor(renderer, backend) {
+    renderer: Renderer;
+    backend: Backend;
+    nodeFrame: NodeFrame;
+    nodeBuilderCache: Map<string, NodeBuilderState>;
+    callHashCache: ChainMap;
+    groupsData: ChainMap;
+
+    constructor(renderer: Renderer, backend: Backend) {
         super();
 
         this.renderer = renderer;
@@ -188,7 +204,7 @@ class Nodes extends DataMap {
         return scene.fogNode || this.get(scene).fogNode || null;
     }
 
-    getCacheKey(scene, lightsNode) {
+    getCacheKey(scene: Scene, lightsNode: LightsNode) {
         const chain = [scene, lightsNode];
         const callId = this.renderer.info.calls;
 
@@ -215,7 +231,7 @@ class Nodes extends DataMap {
         return cacheKeyData.cacheKey;
     }
 
-    updateScene(scene) {
+    updateScene(scene: Scene) {
         this.updateEnvironment(scene);
         this.updateFog(scene);
         this.updateBackground(scene);
@@ -225,7 +241,7 @@ class Nodes extends DataMap {
         return this.renderer.getRenderTarget() ? false : true;
     }
 
-    updateBackground(scene) {
+    updateBackground(scene: Scene) {
         const sceneData = this.get(scene);
         const background = scene.background;
 
@@ -239,10 +255,10 @@ class Nodes extends DataMap {
                     background.mapping === EquirectangularRefractionMapping
                 ) {
                     backgroundNode = pmremTexture(background, normalWorld);
-                } else if (background.isTexture === true) {
-                    backgroundNode = texture(background, viewportBottomLeft).setUpdateMatrix(true);
-                } else if (background.isColor !== true) {
-                    console.error('WebGPUNodes: Unsupported background configuration.', background);
+                } else if ((background as Texture).isTexture === true) {
+                    backgroundNode = texture(background as Texture, viewportBottomLeft).setUpdateMatrix(true);
+                } else if ((background as Color).isColor !== true) {
+                    console.error('WebGPUNodes: Unsupported background configuration.', background as Color);
                 }
 
                 sceneData.backgroundNode = backgroundNode;
@@ -254,7 +270,7 @@ class Nodes extends DataMap {
         }
     }
 
-    updateFog(scene) {
+    updateFog(scene: Scene) {
         const sceneData = this.get(scene);
         const fog = scene.fog;
 
@@ -262,9 +278,9 @@ class Nodes extends DataMap {
             if (sceneData.fog !== fog) {
                 let fogNode = null;
 
-                if (fog.isFogExp2) {
+                if ((fog as FogExp2).isFogExp2) {
                     fogNode = densityFog(reference('color', 'color', fog), reference('density', 'float', fog));
-                } else if (fog.isFog) {
+                } else if ((fog as Fog).isFog) {
                     fogNode = rangeFog(
                         reference('color', 'color', fog),
                         reference('near', 'float', fog),
@@ -283,7 +299,7 @@ class Nodes extends DataMap {
         }
     }
 
-    updateEnvironment(scene) {
+    updateEnvironment(scene: Scene) {
         const sceneData = this.get(scene);
         const environment = scene.environment;
 
@@ -291,7 +307,7 @@ class Nodes extends DataMap {
             if (sceneData.environment !== environment) {
                 let environmentNode = null;
 
-                if (environment.isCubeTexture === true) {
+                if ((environment as CubeTexture).isCubeTexture === true) {
                     environmentNode = cubeTexture(environment);
                 } else if (environment.isTexture === true) {
                     environmentNode = texture(environment);
