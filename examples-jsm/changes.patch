diff --git a/examples-jsm/examples/nodes/accessors/BufferAttributeNode.ts b/examples-jsm/examples/nodes/accessors/BufferAttributeNode.ts
index cc50dba6..25acd365 100644
--- a/examples-jsm/examples/nodes/accessors/BufferAttributeNode.ts
+++ b/examples-jsm/examples/nodes/accessors/BufferAttributeNode.ts
@@ -2,10 +2,36 @@ import InputNode from '../core/InputNode.js';
 import { addNodeClass } from '../core/Node.js';
 import { varying } from '../core/VaryingNode.js';
 import { nodeObject, addNodeElement } from '../shadernode/ShaderNode.js';
-import { InterleavedBufferAttribute, InterleavedBuffer, StaticDrawUsage, DynamicDrawUsage } from 'three';
-
-class BufferAttributeNode extends InputNode {
-    constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
+import {
+    InterleavedBufferAttribute,
+    InterleavedBuffer,
+    StaticDrawUsage,
+    DynamicDrawUsage,
+    Usage,
+    BufferAttribute,
+    InstancedBufferAttribute,
+    TypedArray,
+} from 'three';
+import NodeBuilder from '../core/NodeBuilder.js';
+
+class BufferAttributeNode extends InputNode<TypedArray | InterleavedBuffer | BufferAttribute> {
+    readonly isBufferNode: true;
+
+    bufferType: string | null;
+    bufferStride: number;
+    bufferOffset: number;
+
+    usage: Usage;
+    instanced: boolean;
+
+    attribute: BufferAttribute | InterleavedBufferAttribute | null;
+
+    constructor(
+        value: TypedArray | InterleavedBuffer | BufferAttribute,
+        bufferType: string | null = null,
+        bufferStride = 0,
+        bufferOffset = 0,
+    ) {
         super(value, bufferType);
 
         this.isBufferNode = true;
@@ -21,14 +47,14 @@ class BufferAttributeNode extends InputNode {
 
         this.global = true;
 
-        if (value && value.isBufferAttribute === true) {
-            this.attribute = value;
-            this.usage = value.usage;
-            this.instanced = value.isInstancedBufferAttribute;
+        if (value && (value as BufferAttribute).isBufferAttribute === true) {
+            this.attribute = value as BufferAttribute;
+            this.usage = (value as BufferAttribute).usage;
+            this.instanced = (value as InstancedBufferAttribute).isInstancedBufferAttribute;
         }
     }
 
-    getHash(builder) {
+    getHash(builder: NodeBuilder) {
         if (this.bufferStride === 0 && this.bufferOffset === 0) {
             let bufferData = builder.globalCache.getData(this.value);
 
@@ -46,7 +72,7 @@ class BufferAttributeNode extends InputNode {
         return this.uuid;
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         if (this.bufferType === null) {
             this.bufferType = builder.getTypeFromAttribute(this.attribute);
         }
@@ -54,16 +80,19 @@ class BufferAttributeNode extends InputNode {
         return this.bufferType;
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         if (this.attribute !== null) return;
 
         const type = this.getNodeType(builder);
-        const array = this.value;
+        const array = this.value as TypedArray | InterleavedBuffer;
         const itemSize = builder.getTypeLength(type);
         const stride = this.bufferStride || itemSize;
         const offset = this.bufferOffset;
 
-        const buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer(array, stride);
+        const buffer =
+            (array as InterleavedBuffer).isInterleavedBuffer === true
+                ? (array as InterleavedBuffer)
+                : new InterleavedBuffer(array as TypedArray, stride);
         const bufferAttribute = new InterleavedBufferAttribute(buffer, itemSize, offset);
 
         buffer.setUsage(this.usage);
@@ -72,13 +101,13 @@ class BufferAttributeNode extends InputNode {
         this.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute
     }
 
-    generate(builder) {
+    generate(builder: NodeBuilder) {
         const nodeType = this.getNodeType(builder);
 
         const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);
         const propertyName = builder.getPropertyName(nodeAttribute);
 
-        let output = null;
+        let output: string | null | undefined = null;
 
         if (builder.shaderStage === 'vertex' || builder.shaderStage === 'compute') {
             this.name = propertyName;
@@ -97,17 +126,17 @@ class BufferAttributeNode extends InputNode {
         return 'bufferAttribute';
     }
 
-    setUsage(value) {
+    setUsage(value: Usage) {
         this.usage = value;
 
-        if (this.attribute && this.attribute.isBufferAttribute === true) {
-            this.attribute.usage = value;
+        if (this.attribute && (this.attribute as BufferAttribute).isBufferAttribute === true) {
+            (this.attribute as BufferAttribute).usage = value;
         }
 
         return this;
     }
 
-    setInstanced(value) {
+    setInstanced(value: boolean) {
         this.instanced = value;
 
         return this;
@@ -116,15 +145,31 @@ class BufferAttributeNode extends InputNode {
 
 export default BufferAttributeNode;
 
-export const bufferAttribute = (array, type, stride, offset) =>
-    nodeObject(new BufferAttributeNode(array, type, stride, offset));
-export const dynamicBufferAttribute = (array, type, stride, offset) =>
-    bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);
-
-export const instancedBufferAttribute = (array, type, stride, offset) =>
-    bufferAttribute(array, type, stride, offset).setInstanced(true);
-export const instancedDynamicBufferAttribute = (array, type, stride, offset) =>
-    dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);
+export const bufferAttribute = (
+    array: TypedArray | InterleavedBuffer | BufferAttribute,
+    type?: string | null,
+    stride?: number,
+    offset?: number,
+) => nodeObject(new BufferAttributeNode(array, type, stride, offset));
+export const dynamicBufferAttribute = (
+    array: TypedArray | InterleavedBuffer | BufferAttribute,
+    type?: string | null,
+    stride?: number,
+    offset?: number,
+) => bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);
+
+export const instancedBufferAttribute = (
+    array: TypedArray | InterleavedBuffer | BufferAttribute,
+    type?: string | null,
+    stride?: number,
+    offset?: number,
+) => bufferAttribute(array, type, stride, offset).setInstanced(true);
+export const instancedDynamicBufferAttribute = (
+    array: TypedArray | InterleavedBuffer | BufferAttribute,
+    type?: string | null,
+    stride?: number,
+    offset?: number,
+) => dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);
 
 addNodeElement('toAttribute', bufferNode => bufferAttribute(bufferNode.value));
 
diff --git a/examples-jsm/examples/nodes/accessors/TextureNode.ts b/examples-jsm/examples/nodes/accessors/TextureNode.ts
index 7852696a..4bd42a60 100644
--- a/examples-jsm/examples/nodes/accessors/TextureNode.ts
+++ b/examples-jsm/examples/nodes/accessors/TextureNode.ts
@@ -3,13 +3,34 @@ import { uv } from './UVNode.js';
 import { textureSize } from './TextureSizeNode.js';
 import { colorSpaceToLinear } from '../display/ColorSpaceNode.js';
 import { expression } from '../code/ExpressionNode.js';
-import { addNodeClass } from '../core/Node.js';
+import Node, { addNodeClass } from '../core/Node.js';
 import { maxMipLevel } from '../utils/MaxMipLevelNode.js';
-import { addNodeElement, nodeProxy, vec3, nodeObject } from '../shadernode/ShaderNode.js';
+import { addNodeElement, nodeProxy, vec3, nodeObject, ShaderNodeObject } from '../shadernode/ShaderNode.js';
 import { NodeUpdateType } from '../core/constants.js';
+import { DepthTexture, Texture } from 'three';
+import NodeBuilder from '../core/NodeBuilder.js';
 
-class TextureNode extends UniformNode {
-    constructor(value, uvNode = null, levelNode = null) {
+class TextureNode extends UniformNode<Texture> {
+    readonly isTextureNode: true;
+
+    uvNode: ShaderNodeObject<Node> | null;
+    levelNode: ShaderNodeObject<Node> | null;
+    compareNode: Node | null;
+    depthNode: Node | null;
+    gradNode: Node | null;
+
+    sampler: boolean;
+    updateMatrix: boolean;
+
+    referenceNode: this | null;
+
+    _value: Texture;
+
+    constructor(
+        value: Texture,
+        uvNode: ShaderNodeObject<Node> | null = null,
+        levelNode: ShaderNodeObject<Node> | null = null,
+    ) {
         super(value);
 
         this.isTextureNode = true;
@@ -31,7 +52,7 @@ class TextureNode extends UniformNode {
         this.setUpdateMatrix(uvNode === null);
     }
 
-    set value(value) {
+    set value(value: Texture) {
         if (this.referenceNode) {
             this.referenceNode.value = value;
         } else {
@@ -48,7 +69,7 @@ class TextureNode extends UniformNode {
     }
 
     getNodeType(/*builder*/) {
-        if (this.value.isDepthTexture === true) return 'float';
+        if ((this.value as DepthTexture).isDepthTexture === true) return 'float';
 
         return 'vec4';
     }
@@ -71,14 +92,14 @@ class TextureNode extends UniformNode {
         return uniform(texture.matrix).mul(vec3(uvNode, 1)).xy;
     }
 
-    setUpdateMatrix(value) {
+    setUpdateMatrix(value: boolean) {
         this.updateMatrix = value;
         this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;
 
         return this;
     }
 
-    setupUV(builder, uvNode) {
+    setupUV(builder: NodeBuilder, uvNode) {
         const texture = this.value;
 
         if (
@@ -93,7 +114,7 @@ class TextureNode extends UniformNode {
         return uvNode;
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         const properties = builder.getNodeProperties(this);
 
         //
@@ -129,11 +150,19 @@ class TextureNode extends UniformNode {
         properties.depthNode = this.depthNode;
     }
 
-    generateUV(builder, uvNode) {
+    generateUV(builder: NodeBuilder, uvNode: Node) {
         return uvNode.build(builder, this.sampler === true ? 'vec2' : 'ivec2');
     }
 
-    generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet, gradSnippet) {
+    generateSnippet(
+        builder: NodeBuilder,
+        textureProperty: string,
+        uvSnippet: string | null,
+        levelSnippet: string | null,
+        depthSnippet: string | null,
+        compareSnippet: string | null,
+        gradSnippet: [string, string] | null,
+    ) {
         const texture = this.value;
 
         let snippet;
@@ -153,7 +182,7 @@ class TextureNode extends UniformNode {
         return snippet;
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output) {
         const properties = builder.getNodeProperties(this);
 
         const texture = this.value;
@@ -217,7 +246,7 @@ class TextureNode extends UniformNode {
         }
     }
 
-    setSampler(value) {
+    setSampler(value: boolean) {
         this.sampler = value;
 
         return this;
@@ -229,7 +258,7 @@ class TextureNode extends UniformNode {
 
     // @TODO: Move to TSL
 
-    uv(uvNode) {
+    uv(uvNode: ShaderNodeObject<Node> | null) {
         const textureNode = this.clone();
         textureNode.uvNode = uvNode;
         textureNode.referenceNode = this;
@@ -237,7 +266,7 @@ class TextureNode extends UniformNode {
         return nodeObject(textureNode);
     }
 
-    blur(levelNode) {
+    blur(levelNode: ShaderNodeObject<Node>) {
         const textureNode = this.clone();
         textureNode.levelNode = levelNode.mul(maxMipLevel(textureNode));
         textureNode.referenceNode = this;
@@ -245,7 +274,7 @@ class TextureNode extends UniformNode {
         return nodeObject(textureNode);
     }
 
-    level(levelNode) {
+    level(levelNode: ShaderNodeObject<Node> | null) {
         const textureNode = this.clone();
         textureNode.levelNode = levelNode;
         textureNode.referenceNode = this;
diff --git a/examples-jsm/examples/nodes/code/CodeNode.ts b/examples-jsm/examples/nodes/code/CodeNode.ts
index 06347564..1f81819b 100644
--- a/examples-jsm/examples/nodes/code/CodeNode.ts
+++ b/examples-jsm/examples/nodes/code/CodeNode.ts
@@ -1,7 +1,13 @@
 import Node, { addNodeClass } from '../core/Node.js';
 import { nodeProxy } from '../shadernode/ShaderNode.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 class CodeNode extends Node {
+    readonly isCodeNode: true;
+
+    code: string;
+    language: string;
+
     constructor(code = '', includes = [], language = '') {
         super('code');
 
@@ -23,11 +29,11 @@ class CodeNode extends Node {
         return this;
     }
 
-    getIncludes(/*builder*/) {
+    getIncludes(builder: NodeBuilder) {
         return this.includes;
     }
 
-    generate(builder) {
+    generate(builder: NodeBuilder) {
         const includes = this.getIncludes(builder);
 
         for (const include of includes) {
diff --git a/examples-jsm/examples/nodes/code/FunctionNode.ts b/examples-jsm/examples/nodes/code/FunctionNode.ts
index feeb5a55..d16e2359 100644
--- a/examples-jsm/examples/nodes/code/FunctionNode.ts
+++ b/examples-jsm/examples/nodes/code/FunctionNode.ts
@@ -1,6 +1,7 @@
 import CodeNode from './CodeNode.js';
 import { addNodeClass } from '../core/Node.js';
 import { nodeObject } from '../shadernode/ShaderNode.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 class FunctionNode extends CodeNode {
     constructor(code = '', includes = [], language = '') {
@@ -9,15 +10,15 @@ class FunctionNode extends CodeNode {
         this.keywords = {};
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.getNodeFunction(builder).type;
     }
 
-    getInputs(builder) {
+    getInputs(builder: NodeBuilder) {
         return this.getNodeFunction(builder).inputs;
     }
 
-    getNodeFunction(builder) {
+    getNodeFunction(builder: NodeBuilder) {
         const nodeData = builder.getDataFromNode(this);
 
         let nodeFunction = nodeData.nodeFunction;
@@ -31,7 +32,7 @@ class FunctionNode extends CodeNode {
         return nodeFunction;
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null) {
         super.generate(builder);
 
         const nodeFunction = this.getNodeFunction(builder);
@@ -75,7 +76,7 @@ class FunctionNode extends CodeNode {
 
 export default FunctionNode;
 
-const nativeFn = (code, includes = [], language = '') => {
+const nativeFn = (code: string, includes = [], language = '') => {
     for (let i = 0; i < includes.length; i++) {
         const include = includes[i];
 
@@ -94,7 +95,7 @@ const nativeFn = (code, includes = [], language = '') => {
     return fn;
 };
 
-export const glslFn = (code, includes) => nativeFn(code, includes, 'glsl');
-export const wgslFn = (code, includes) => nativeFn(code, includes, 'wgsl');
+export const glslFn = (code: string, includes) => nativeFn(code, includes, 'glsl');
+export const wgslFn = (code: string, includes) => nativeFn(code, includes, 'wgsl');
 
 addNodeClass('FunctionNode', FunctionNode);
diff --git a/examples-jsm/examples/nodes/core/ContextNode.ts b/examples-jsm/examples/nodes/core/ContextNode.ts
index fcd488eb..84e3c972 100644
--- a/examples-jsm/examples/nodes/core/ContextNode.ts
+++ b/examples-jsm/examples/nodes/core/ContextNode.ts
@@ -1,8 +1,14 @@
 import Node, { addNodeClass } from './Node.js';
-import { addNodeElement, nodeProxy } from '../shadernode/ShaderNode.js';
+import { addNodeElement, nodeProxy, NodeRepresentation } from '../shadernode/ShaderNode.js';
+import NodeBuilder from './NodeBuilder.js';
 
-class ContextNode extends Node {
-    constructor(node, context = {}) {
+class ContextNode<TContext> extends Node {
+    readonly isContextNode: true;
+
+    node: Node;
+    context: TContext;
+
+    constructor(node: Node, context: TContext = {} as TContext) {
         super();
 
         this.isContextNode = true;
@@ -11,15 +17,15 @@ class ContextNode extends Node {
         this.context = context;
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.node.getNodeType(builder);
     }
 
-    analyze(builder) {
+    analyze(builder: NodeBuilder) {
         this.node.build(builder);
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         const previousContext = builder.getContext();
 
         builder.setContext({ ...builder.context, ...this.context });
@@ -31,7 +37,7 @@ class ContextNode extends Node {
         return node;
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null) {
         const previousContext = builder.getContext();
 
         builder.setContext({ ...builder.context, ...this.context });
@@ -47,7 +53,7 @@ class ContextNode extends Node {
 export default ContextNode;
 
 export const context = nodeProxy(ContextNode);
-export const label = (node, name) => context(node, { label: name });
+export const label = (node: NodeRepresentation, name: string) => context(node, { label: name });
 
 addNodeElement('context', context);
 addNodeElement('label', label);
diff --git a/examples-jsm/examples/nodes/core/InputNode.ts b/examples-jsm/examples/nodes/core/InputNode.ts
index 4d52ec26..5987158d 100644
--- a/examples-jsm/examples/nodes/core/InputNode.ts
+++ b/examples-jsm/examples/nodes/core/InputNode.ts
@@ -1,8 +1,14 @@
 import Node, { addNodeClass } from './Node.js';
 import { getValueType, getValueFromType, arrayBufferToBase64 } from './NodeUtils.js';
+import NodeBuilder from './NodeBuilder.js';
 
-class InputNode extends Node {
-    constructor(value, nodeType = null) {
+class InputNode<TValue> extends Node {
+    readonly isInputNode: true;
+
+    value: TValue;
+    precision: 'low' | 'medium' | 'high' | null;
+
+    constructor(value: TValue, nodeType: string | null = null) {
         super(nodeType);
 
         this.isInputNode = true;
@@ -11,7 +17,7 @@ class InputNode extends Node {
         this.precision = null;
     }
 
-    getNodeType(/*builder*/) {
+    getNodeType(builder: NodeBuilder) {
         if (this.nodeType === null) {
             return getValueType(this.value);
         }
@@ -19,11 +25,11 @@ class InputNode extends Node {
         return this.nodeType;
     }
 
-    getInputType(builder) {
+    getInputType(builder: NodeBuilder) {
         return this.getNodeType(builder);
     }
 
-    setPrecision(precision) {
+    setPrecision(precision: 'low' | 'medium' | 'high' | null) {
         this.precision = precision;
 
         return this;
@@ -54,10 +60,6 @@ class InputNode extends Node {
 
         if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);
     }
-
-    generate(/*builder, output*/) {
-        console.warn('Abstract function.');
-    }
 }
 
 export default InputNode;
diff --git a/examples-jsm/examples/nodes/core/Node.ts b/examples-jsm/examples/nodes/core/Node.ts
index 66444172..3b3e48c0 100644
--- a/examples-jsm/examples/nodes/core/Node.ts
+++ b/examples-jsm/examples/nodes/core/Node.ts
@@ -2,13 +2,98 @@ import { EventDispatcher } from 'three';
 import { NodeUpdateType } from './constants.js';
 import { getNodeChildren, getCacheKey } from './NodeUtils.js';
 import { MathUtils } from 'three';
+import NodeBuilder from './NodeBuilder.js';
+import NodeFrame from './NodeFrame.js';
 
-const NodeClasses = new Map();
+const NodeClasses = new Map<string, typeof Node>();
 
 let _nodeId = 0;
 
-class Node extends EventDispatcher {
-    constructor(nodeType = null) {
+interface NodeConstructor {
+    type?: string;
+}
+
+interface NodeJSONMeta {
+    textures: { [key: string]: unknown };
+    images: { [key: string]: unknown };
+    nodes: { [key: string]: NodeJSONIntermediateOutputData };
+}
+
+interface NodeJSONMetadata {
+    version: number;
+    type: 'Node';
+    generator: 'Node.toJSON';
+}
+
+interface NodeJSONInputNodes {
+    [property: string]:
+        | string[]
+        | {
+              [index: string]: string | undefined;
+          }
+        | string
+        | undefined;
+}
+
+interface NodeJSONInputData {
+    inputNodes?: NodeJSONInputNodes | undefined;
+    meta: {
+        textures: { [key: string]: unknown };
+        nodes: { [key: string]: Node };
+    };
+}
+
+interface NodeJSONInputData {
+    uuid: string;
+    type: string | undefined;
+    metadata?: NodeJSONMetadata;
+    inputNodes?: NodeJSONInputNodes | undefined;
+}
+
+interface NodeJSONIntermediateOutputData {
+    uuid: string;
+    type: string | undefined;
+    meta?: NodeJSONMeta | undefined;
+    metadata?: NodeJSONMetadata;
+    inputNodes?: NodeJSONInputNodes | undefined;
+    textures?: unknown[];
+    images?: unknown[];
+    nodes?: NodeJSONIntermediateOutputData[];
+}
+
+interface NodeJSONOutputData {
+    uuid: string;
+    type: string | undefined;
+    metadata?: NodeJSONMetadata;
+    inputNodes?: NodeJSONInputNodes | undefined;
+    textures?: unknown[];
+    images?: unknown[];
+    nodes?: NodeJSONOutputData[];
+}
+
+class Node extends EventDispatcher<{ dispose: {} }> {
+    nodeType: string | null;
+
+    updateType: NodeUpdateType;
+    updateBeforeType: NodeUpdateType;
+    updateAfterType: NodeUpdateType;
+
+    uuid: string;
+
+    version: number;
+
+    _cacheKey: string | null;
+    _cacheKeyVersion: number;
+
+    global: boolean;
+
+    readonly isNode: true;
+
+    readonly id!: number;
+
+    self?: this;
+
+    constructor(nodeType: string | null = null) {
         super();
 
         this.nodeType = nodeType;
@@ -31,36 +116,36 @@ class Node extends EventDispatcher {
         Object.defineProperty(this, 'id', { value: _nodeId++ });
     }
 
-    set needsUpdate(value) {
+    set needsUpdate(value: boolean) {
         if (value === true) {
             this.version++;
         }
     }
 
     get type() {
-        return this.constructor.type;
+        return (this.constructor as NodeConstructor).type;
     }
 
-    onUpdate(callback, updateType) {
+    onUpdate(callback: (this: this, frame: NodeFrame) => unknown, updateType: NodeUpdateType) {
         this.updateType = updateType;
         this.update = callback.bind(this.getSelf());
 
         return this;
     }
 
-    onFrameUpdate(callback) {
+    onFrameUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.FRAME);
     }
 
-    onRenderUpdate(callback) {
+    onRenderUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.RENDER);
     }
 
-    onObjectUpdate(callback) {
+    onObjectUpdate(callback: (this: this, frame: NodeFrame) => void) {
         return this.onUpdate(callback, NodeUpdateType.OBJECT);
     }
 
-    onReference(callback) {
+    onReference(callback: (this: this, frame: NodeBuilder | NodeFrame) => unknown) {
         this.updateReference = callback.bind(this.getSelf());
 
         return this;
@@ -72,11 +157,11 @@ class Node extends EventDispatcher {
         return this.self || this;
     }
 
-    updateReference(/*state*/) {
+    updateReference(state: NodeBuilder | NodeFrame): unknown {
         return this;
     }
 
-    isGlobal(/*builder*/) {
+    isGlobal(builder: NodeBuilder) {
         return this.global;
     }
 
@@ -90,7 +175,7 @@ class Node extends EventDispatcher {
         this.dispatchEvent({ type: 'dispose' });
     }
 
-    traverse(callback) {
+    traverse(callback: (node: Node) => void) {
         callback(this);
 
         for (const childNode of this.getChildren()) {
@@ -109,7 +194,7 @@ class Node extends EventDispatcher {
         return this._cacheKey;
     }
 
-    getHash(/*builder*/) {
+    getHash(builder: NodeBuilder) {
         return this.uuid;
     }
 
@@ -125,14 +210,14 @@ class Node extends EventDispatcher {
         return this.updateAfterType;
     }
 
-    getElementType(builder) {
+    getElementType(builder: NodeBuilder) {
         const type = this.getNodeType(builder);
         const elementType = builder.getElementType(type);
 
         return elementType;
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder): string | null {
         const nodeProperties = builder.getNodeProperties(this);
 
         if (nodeProperties.outputNode) {
@@ -142,27 +227,27 @@ class Node extends EventDispatcher {
         return this.nodeType;
     }
 
-    getShared(builder) {
+    getShared(builder: NodeBuilder) {
         const hash = this.getHash(builder);
         const nodeFromHash = builder.getNodeFromHash(hash);
 
         return nodeFromHash || this;
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder): unknown {
         const nodeProperties = builder.getNodeProperties(this);
 
         let index = 0;
 
         for (const childNode of this.getChildren()) {
-            nodeProperties['node' + index++] = childNode;
+            nodeProperties[`node${index++}`] = childNode;
         }
 
         // return a outputNode if exists
         return null;
     }
 
-    construct(builder) {
+    construct(builder: NodeBuilder) {
         // @deprecated, r157
 
         console.warn('THREE.Node: construct() is deprecated. Use setup() instead.');
@@ -170,14 +255,14 @@ class Node extends EventDispatcher {
         return this.setup(builder);
     }
 
-    increaseUsage(builder) {
+    increaseUsage(builder: NodeBuilder) {
         const nodeData = builder.getDataFromNode(this);
         nodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;
 
         return nodeData.usageCount;
     }
 
-    analyze(builder) {
+    analyze(builder: NodeBuilder) {
         const usageCount = this.increaseUsage(builder);
 
         if (usageCount === 1) {
@@ -186,14 +271,14 @@ class Node extends EventDispatcher {
             const nodeProperties = builder.getNodeProperties(this);
 
             for (const childNode of Object.values(nodeProperties)) {
-                if (childNode && childNode.isNode === true) {
-                    childNode.build(builder);
+                if (childNode && (childNode as Node).isNode === true) {
+                    (childNode as Node).build(builder);
                 }
             }
         }
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output?: string | null): string | null | undefined {
         const { outputNode } = builder.getNodeProperties(this);
 
         if (outputNode && outputNode.isNode === true) {
@@ -201,19 +286,19 @@ class Node extends EventDispatcher {
         }
     }
 
-    updateBefore(/*frame*/) {
+    updateBefore(frame: NodeFrame) {
         console.warn('Abstract function.');
     }
 
-    updateAfter(/*frame*/) {
+    updateAfter(frame: NodeFrame) {
         console.warn('Abstract function.');
     }
 
-    update(/*frame*/) {
+    update(frame: NodeFrame) {
         console.warn('Abstract function.');
     }
 
-    build(builder, output = null) {
+    build(builder: NodeBuilder, output: string | null = null): string | null {
         const refNode = this.getShared(builder);
 
         if (this !== refNode) {
@@ -248,8 +333,8 @@ class Node extends EventDispatcher {
                 }
 
                 for (const childNode of Object.values(properties)) {
-                    if (childNode && childNode.isNode === true) {
-                        childNode.build(builder);
+                    if (childNode && (childNode as Node).isNode === true) {
+                        (childNode as Node).build(builder);
                     }
                 }
             }
@@ -285,10 +370,10 @@ class Node extends EventDispatcher {
         return getNodeChildren(this);
     }
 
-    serialize(json) {
+    serialize(json: NodeJSONIntermediateOutputData) {
         const nodeChildren = this.getSerializeChildren();
 
-        const inputNodes = {};
+        const inputNodes: NodeJSONInputNodes = {};
 
         for (const { property, index, childNode } of nodeChildren) {
             if (index !== undefined) {
@@ -296,7 +381,9 @@ class Node extends EventDispatcher {
                     inputNodes[property] = Number.isInteger(index) ? [] : {};
                 }
 
-                inputNodes[property][index] = childNode.toJSON(json.meta).uuid;
+                (inputNodes[property]! as { [index: number | string]: string })[index] = childNode.toJSON(
+                    json.meta,
+                ).uuid;
             } else {
                 inputNodes[property] = childNode.toJSON(json.meta).uuid;
             }
@@ -307,39 +394,39 @@ class Node extends EventDispatcher {
         }
     }
 
-    deserialize(json) {
+    deserialize(json: NodeJSONInputData) {
         if (json.inputNodes !== undefined) {
             const nodes = json.meta.nodes;
 
             for (const property in json.inputNodes) {
                 if (Array.isArray(json.inputNodes[property])) {
-                    const inputArray = [];
+                    const inputArray: Node[] = [];
 
-                    for (const uuid of json.inputNodes[property]) {
+                    for (const uuid of json.inputNodes[property] as string[]) {
                         inputArray.push(nodes[uuid]);
                     }
 
-                    this[property] = inputArray;
+                    (this[property as keyof typeof this] as Node[]) = inputArray;
                 } else if (typeof json.inputNodes[property] === 'object') {
-                    const inputObject = {};
+                    const inputObject: { [subProperty: string]: Node } = {};
 
-                    for (const subProperty in json.inputNodes[property]) {
-                        const uuid = json.inputNodes[property][subProperty];
+                    for (const subProperty in json.inputNodes[property] as { [subProperty: string]: string }) {
+                        const uuid = (json.inputNodes[property] as { [subProperty: string]: string })[subProperty];
 
                         inputObject[subProperty] = nodes[uuid];
                     }
 
-                    this[property] = inputObject;
+                    (this[property as keyof typeof this] as { [subProperty: string]: Node }) = inputObject;
                 } else {
-                    const uuid = json.inputNodes[property];
+                    const uuid = json.inputNodes[property] as string;
 
-                    this[property] = nodes[uuid];
+                    (this[property as keyof typeof this] as Node) = nodes[uuid];
                 }
             }
         }
     }
 
-    toJSON(meta) {
+    toJSON(meta?: NodeJSONMeta | string): NodeJSONOutputData {
         const { uuid, type } = this;
         const isRoot = meta === undefined || typeof meta === 'string';
 
@@ -348,18 +435,18 @@ class Node extends EventDispatcher {
                 textures: {},
                 images: {},
                 nodes: {},
-            };
+            } satisfies NodeJSONMeta;
         }
 
         // serialize
 
-        let data = meta.nodes[uuid];
+        let data = (meta as NodeJSONMeta).nodes[uuid];
 
         if (data === undefined) {
             data = {
                 uuid,
                 type,
-                meta,
+                meta: meta as NodeJSONMeta,
                 metadata: {
                     version: 4.6,
                     type: 'Node',
@@ -367,7 +454,7 @@ class Node extends EventDispatcher {
                 },
             };
 
-            if (isRoot !== true) meta.nodes[data.uuid] = data;
+            if (isRoot !== true) (meta as NodeJSONMeta).nodes[data.uuid] = data;
 
             this.serialize(data);
 
@@ -376,12 +463,12 @@ class Node extends EventDispatcher {
 
         // TODO: Copied from Object3D.toJSON
 
-        function extractFromCache(cache) {
+        function extractFromCache<T>(cache: { [key: string]: T }) {
             const values = [];
 
             for (const key in cache) {
                 const data = cache[key];
-                delete data.metadata;
+                delete (data as NodeJSONIntermediateOutputData).metadata;
                 values.push(data);
             }
 
@@ -389,9 +476,9 @@ class Node extends EventDispatcher {
         }
 
         if (isRoot) {
-            const textures = extractFromCache(meta.textures);
-            const images = extractFromCache(meta.images);
-            const nodes = extractFromCache(meta.nodes);
+            const textures = extractFromCache((meta as NodeJSONMeta).textures);
+            const images = extractFromCache((meta as NodeJSONMeta).images);
+            const nodes = extractFromCache((meta as NodeJSONMeta).nodes);
 
             if (textures.length > 0) data.textures = textures;
             if (images.length > 0) data.images = images;
@@ -404,7 +491,7 @@ class Node extends EventDispatcher {
 
 export default Node;
 
-export function addNodeClass(type, nodeClass) {
+export function addNodeClass(type: string, nodeClass: { new (...args: any[]): Node }) {
     if (typeof nodeClass !== 'function' || !type) throw new Error(`Node class ${type} is not a class`);
     if (NodeClasses.has(type)) {
         console.warn(`Redefinition of node class ${type}`);
@@ -412,10 +499,10 @@ export function addNodeClass(type, nodeClass) {
     }
 
     NodeClasses.set(type, nodeClass);
-    nodeClass.type = type;
+    (nodeClass as NodeConstructor).type = type;
 }
 
-export function createNodeFromType(type) {
+export function createNodeFromType(type: string) {
     const Class = NodeClasses.get(type);
 
     if (Class !== undefined) {
diff --git a/examples-jsm/examples/nodes/core/NodeAttribute.ts b/examples-jsm/examples/nodes/core/NodeAttribute.ts
index 190fe8c5..d873bb24 100644
--- a/examples-jsm/examples/nodes/core/NodeAttribute.ts
+++ b/examples-jsm/examples/nodes/core/NodeAttribute.ts
@@ -1,5 +1,13 @@
+import Node from './Node.js';
+
 class NodeAttribute {
-    constructor(name, type, node = null) {
+    readonly isNodeAttribute: true;
+
+    name: string;
+    type: string | null;
+    node: Node | null;
+
+    constructor(name: string, type: string | null, node: Node | null = null) {
         this.isNodeAttribute = true;
 
         this.name = name;
diff --git a/examples-jsm/examples/nodes/core/NodeBuilder.ts b/examples-jsm/examples/nodes/core/NodeBuilder.ts
index 2559a675..e7f46dfb 100644
--- a/examples-jsm/examples/nodes/core/NodeBuilder.ts
+++ b/examples-jsm/examples/nodes/core/NodeBuilder.ts
@@ -8,7 +8,7 @@ import NodeCache from './NodeCache.js';
 import ParameterNode from './ParameterNode.js';
 import FunctionNode from '../code/FunctionNode.js';
 import { createNodeMaterialFromType, default as NodeMaterial } from '../materials/NodeMaterial.js';
-import { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';
+import { NodeUpdateType, defaultBuildStages, shaderStages, NodeShaderStage } from './constants.js';
 
 import {
     NumberNodeUniform,
@@ -36,17 +36,44 @@ import {
     LinearMipmapNearestFilter,
     NearestMipmapLinearFilter,
     LinearMipmapLinearFilter,
+    Object3D,
+    Material,
+    Mesh,
+    BufferGeometry,
+    Scene,
+    RenderTargetOptions,
+    Texture,
+    DataTexture,
+    BufferAttribute,
+    InterleavedBufferAttribute,
+    TypedArray,
+    Matrix3,
+    Matrix4,
+    Camera,
 } from 'three';
 
-import { stack } from './StackNode.js';
-import { getCurrentStack, setCurrentStack } from '../shadernode/ShaderNode.js';
+import StackNode, { stack } from './StackNode.js';
+import { getCurrentStack, setCurrentStack, ShaderNodeInternal, ShaderNodeObject } from '../shadernode/ShaderNode.js';
 
 import CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';
 import ChainMap from '../../renderers/common/ChainMap.js';
 
 import PMREMGenerator from '../../renderers/common/extras/PMREMGenerator.js';
-
-const rendererCache = new WeakMap();
+import Renderer from '../../renderers/common/Renderer.js';
+import NodeParser from './NodeParser.js';
+import Node from './Node.js';
+import LightsNode from '../lighting/LightsNode.js';
+import EnvironmentNode from '../lighting/EnvironmentNode.js';
+import FogNode from '../fog/FogNode.js';
+import ClippingContext from '../../renderers/common/ClippingContext.js';
+import NodeUniformsGroup from '../../renderers/common/nodes/NodeUniformsGroup.js';
+import UniformNode from './UniformNode.js';
+import StructTypeNode from './StructTypeNode.js';
+
+const rendererCache = new WeakMap<
+    Renderer,
+    ChainMap<UniformNode<unknown>[] | NodeUniformsGroup[], NodeUniformsGroup | BindGroup>
+>();
 
 const typeFromLength = new Map([
     [2, 'vec2'],
@@ -56,7 +83,16 @@ const typeFromLength = new Map([
     [16, 'mat4'],
 ]);
 
-const typeFromArray = new Map([
+type TypedArrayConstructor =
+    | typeof Int8Array
+    | typeof Int16Array
+    | typeof Int32Array
+    | typeof Uint8Array
+    | typeof Uint16Array
+    | typeof Uint32Array
+    | typeof Float32Array;
+
+const typeFromArray = new Map<TypedArrayConstructor, string>([
     [Int8Array, 'int'],
     [Int16Array, 'int'],
     [Int32Array, 'int'],
@@ -66,17 +102,94 @@ const typeFromArray = new Map([
     [Float32Array, 'float'],
 ]);
 
-const toFloat = value => {
+const toFloat = (value: unknown) => {
     value = Number(value);
 
-    return value + (value % 1 ? '' : '.0');
+    return value + ((value as number) % 1 ? '' : '.0');
 };
 
-class NodeBuilder {
-    constructor(object, renderer, parser) {
+interface Flow {
+    code: string;
+    result?: string | null | undefined;
+    vars?: string | undefined;
+}
+
+interface Context {
+    keywords: NodeKeywords;
+    material: Material | Material[] | null;
+    tempRead?: boolean;
+}
+
+abstract class NodeBuilder {
+    object: Object3D | null;
+    material: Material | Material[] | null;
+    geometry: BufferGeometry | null;
+    renderer: Renderer;
+    parser: NodeParser;
+    scene: Scene | null;
+    camera: Camera | null;
+
+    nodes: Node[];
+    updateNodes: Node[];
+    updateBeforeNodes: Node[];
+    updateAfterNodes: Node[];
+    hashNodes: { [hash: string]: Node };
+
+    lightsNode: LightsNode | null;
+    environmentNode: EnvironmentNode | null;
+    fogNode: FogNode | null;
+
+    clippingContext: ClippingContext | null;
+
+    vertexShader: string | null;
+    fragmentShader: string | null;
+    computeShader: string | null;
+
+    flowNodes: { vertex: Node[]; fragment: Node[]; compute: Node[] };
+    flowCode: { vertex: string; fragment: string; compute: string };
+    uniforms: {
+        vertex: NodeUniform<unknown>[];
+        fragment: NodeUniform<unknown>[];
+        compute: NodeUniform<unknown>[];
+        index: number;
+    };
+    structs: { vertex: StructTypeNode[]; fragment: StructTypeNode[]; compute: StructTypeNode[]; index: number };
+    bindings: {
+        vertex: { [groupName: string]: NodeUniformsGroup[] | undefined };
+        fragment: { [groupName: string]: NodeUniformsGroup[] | undefined };
+        compute: { [groupName: string]: NodeUniformsGroup[] | undefined };
+    };
+    bindingsIndexes: { [groupName: string]: { binding: number; group: number } | undefined };
+    bindGroups: BindGroup[] | null;
+    attributes: NodeAttribute[];
+    bufferAttributes: NodeAttribute[];
+    varyings: NodeVarying[];
+    codes: { vertex?: NodeCode[] | undefined; fragment?: NodeCode[] | undefined; compute?: NodeCode[] | undefined };
+    vars: { vertex?: NodeVar[] | undefined; fragment?: NodeVar[] | undefined; compute?: NodeVar[] | undefined };
+    flow: Flow;
+    chaining: Node[];
+    stack: ShaderNodeObject<StackNode>;
+    stacks: ShaderNodeObject<StackNode>[];
+    tab: string;
+
+    instanceBindGroups: boolean;
+
+    currentFunctionNode: FunctionNode | null;
+
+    context: Context;
+
+    cache: NodeCache;
+    globalCache: NodeCache;
+
+    flowsData: WeakMap<Node, Flow>;
+
+    shaderStage: NodeShaderStage | null;
+    buildStage: string | null;
+
+    constructor(object: Object3D | null, renderer: Renderer, parser: NodeParser) {
         this.object = object;
-        this.material = (object && object.material) || null;
-        this.geometry = (object && object.geometry) || null;
+        this.material = (object && (object as Mesh).material) || null;
+        this.geometry = (object && (object as Mesh).geometry) || null;
         this.renderer = renderer;
         this.parser = parser;
         this.scene = null;
@@ -128,7 +241,7 @@ class NodeBuilder {
         this.cache = new NodeCache();
         this.globalCache = this.cache;
 
-        this.flowsData = new WeakMap();
+        this.flowsData = new WeakMap<Node, Flow>();
 
         this.shaderStage = null;
         this.buildStage = null;
@@ -146,11 +259,11 @@ class NodeBuilder {
         return bindGroupsCache;
     }
 
-    createRenderTarget(width, height, options) {
+    createRenderTarget(width?: number, height?: number, options?: RenderTargetOptions) {
         return new RenderTarget(width, height, options);
     }
 
-    createCubeRenderTarget(size, options) {
+    createCubeRenderTarget(size?: number, options?: RenderTargetOptions) {
         return new CubeRenderTarget(size, options);
     }
 
@@ -160,16 +273,16 @@ class NodeBuilder {
         return new PMREMGenerator(this.renderer);
     }
 
-    includes(node) {
+    includes(node: Node) {
         return this.nodes.includes(node);
     }
 
-    _getBindGroup(groupName, bindings) {
+    _getBindGroup(groupName: string, bindings: NodeUniformsGroup[]) {
         const bindGroupsCache = this.getBingGroupsCache();
 
         // cache individual uniforms group
 
-        const bindingsArray = [];
+        const bindingsArray: NodeUniformsGroup[] = [];
 
         let sharedGroup = true;
 
@@ -178,7 +291,7 @@ class NodeBuilder {
                 // nodes is the chainmap key
                 const nodes = binding.getNodes();
 
-                let sharedBinding = bindGroupsCache.get(nodes);
+                let sharedBinding = bindGroupsCache.get(nodes) as NodeUniformsGroup | undefined;
 
                 if (sharedBinding === undefined) {
                     bindGroupsCache.set(nodes, binding);
@@ -199,7 +312,7 @@ class NodeBuilder {
         let bindGroup;
 
         if (sharedGroup) {
-            bindGroup = bindGroupsCache.get(bindingsArray);
+            bindGroup = bindGroupsCache.get(bindingsArray) as BindGroup | undefined;
 
             if (bindGroup === undefined) {
                 bindGroup = new BindGroup(groupName, bindingsArray);
@@ -212,7 +325,7 @@ class NodeBuilder {
         return bindGroup;
     }
 
-    getBindGroupArray(groupName, shaderStage) {
+    getBindGroupArray(groupName: string, shaderStage: NodeShaderStage) {
         const bindings = this.bindings[shaderStage];
 
         let bindGroup = bindings[groupName];
@@ -232,12 +345,12 @@ class NodeBuilder {
         let bindingsGroups = this.bindGroups;
 
         if (bindingsGroups === null) {
-            const groups = {};
+            const groups: { [groupName: string]: NodeUniformsGroup[] | undefined } = {};
             const bindings = this.bindings;
 
             for (const shaderStage of shaderStages) {
                 for (const groupName in bindings[shaderStage]) {
-                    const uniforms = bindings[shaderStage][groupName];
+                    const uniforms = bindings[shaderStage][groupName]!;
 
                     const groupUniforms = groups[groupName] || (groups[groupName] = []);
                     groupUniforms.push(...uniforms);
@@ -247,7 +360,7 @@ class NodeBuilder {
             bindingsGroups = [];
 
             for (const groupName in groups) {
-                const group = groups[groupName];
+                const group = groups[groupName]!;
 
                 const bindingsGroup = this._getBindGroup(groupName, group);
 
@@ -260,11 +373,11 @@ class NodeBuilder {
         return bindingsGroups;
     }
 
-    setHashNode(node, hash) {
+    setHashNode(node: Node, hash: string) {
         this.hashNodes[hash] = node;
     }
 
-    addNode(node) {
+    addNode(node: Node) {
         if (this.nodes.includes(node) === false) {
             this.nodes.push(node);
 
@@ -296,7 +409,7 @@ class NodeBuilder {
         return this.chaining[this.chaining.length - 1];
     }
 
-    isFilteredTexture(texture) {
+    isFilteredTexture(texture: Texture) {
         return (
             texture.magFilter === LinearFilter ||
             texture.magFilter === LinearMipmapNearestFilter ||
@@ -309,7 +422,7 @@ class NodeBuilder {
         );
     }
 
-    addChain(node) {
+    addChain(node: Node) {
         /*
 		if ( this.chaining.indexOf( node ) !== - 1 ) {
 
@@ -321,7 +434,7 @@ class NodeBuilder {
         this.chaining.push(node);
     }
 
-    removeChain(node) {
+    removeChain(node: Node) {
         const lastChain = this.chaining.pop();
 
         if (lastChain !== node) {
@@ -329,21 +442,21 @@ class NodeBuilder {
         }
     }
 
-    getMethod(method) {
+    getMethod(method: string) {
         return method;
     }
 
-    getNodeFromHash(hash) {
+    getNodeFromHash(hash: string) {
         return this.hashNodes[hash];
     }
 
-    addFlow(shaderStage, node) {
+    addFlow(shaderStage: NodeShaderStage, node: Node) {
         this.flowNodes[shaderStage].push(node);
 
         return node;
     }
 
-    setContext(context) {
+    setContext(context: Context) {
         this.context = context;
     }
 
@@ -351,7 +464,7 @@ class NodeBuilder {
         return this.context;
     }
 
-    setCache(cache) {
+    setCache(cache: NodeCache) {
         this.cache = cache;
     }
 
@@ -359,14 +472,14 @@ class NodeBuilder {
         return this.cache;
     }
 
-    getCacheFromNode(node, parent = true) {
+    getCacheFromNode(node: Node, parent = true) {
         const data = this.getDataFromNode(node);
         if (data.cache === undefined) data.cache = new NodeCache(parent ? this.getCache() : null);
 
         return data.cache;
     }
 
-    isAvailable(/*name*/) {
+    isAvailable(name: string) {
         return false;
     }
 
@@ -390,15 +503,45 @@ class NodeBuilder {
         return false;
     }
 
-    generateTexture(/* texture, textureProperty, uvSnippet */) {
-        console.warn('Abstract function.');
-    }
-
-    generateTextureLod(/* texture, textureProperty, uvSnippet, levelSnippet */) {
-        console.warn('Abstract function.');
-    }
-
-    generateConst(type, value = null) {
+    abstract generateTexture(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        depthSnippet: string | null,
+    ): string;
+
+    abstract generateTextureLevel(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        levelSnippet: string | null,
+        depthSnippet: string | null,
+    ): string;
+
+    abstract generateTextureGrad(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        gradSnippet: [string, string] | null,
+        depthSnippet: string | null,
+    ): string;
+
+    abstract generateTextureCompare(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        compareSnippet: string | null,
+        depthSnippet: string | null,
+    ): string;
+
+    abstract generateTextureLoad(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        depthSnippet: string | null,
+    ): string;
+
+    generateConst(type: string | null, value: unknown = null): string {
         if (value === null) {
             if (type === 'float' || type === 'int' || type === 'uint') value = 0;
             else if (type === 'bool') value = false;
@@ -409,26 +552,26 @@ class NodeBuilder {
         }
 
         if (type === 'float') return toFloat(value);
-        if (type === 'int') return `${Math.round(value)}`;
-        if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';
+        if (type === 'int') return `${Math.round(value as number)}`;
+        if (type === 'uint') return (value as number) >= 0 ? `${Math.round(value as number)}u` : '0u';
         if (type === 'bool') return value ? 'true' : 'false';
         if (type === 'color')
-            return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
+            return `${this.getType('vec3')}( ${toFloat((value as Color).r)}, ${toFloat((value as Color).g)}, ${toFloat((value as Color).b)} )`;
 
         const typeLength = this.getTypeLength(type);
 
         const componentType = this.getComponentType(type);
 
-        const generateConst = value => this.generateConst(componentType, value);
+        const generateConst = (value: unknown) => this.generateConst(componentType, value);
 
         if (typeLength === 2) {
-            return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;
+            return `${this.getType(type)}( ${generateConst((value as Vector2).x)}, ${generateConst((value as Vector2).y)} )`;
         } else if (typeLength === 3) {
-            return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;
+            return `${this.getType(type)}( ${generateConst((value as Vector3).x)}, ${generateConst((value as Vector3).y)}, ${generateConst((value as Vector3).z)} )`;
         } else if (typeLength === 4) {
-            return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;
-        } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {
-            return `${this.getType(type)}( ${value.elements.map(generateConst).join(', ')} )`;
+            return `${this.getType(type)}( ${generateConst((value as Vector4).x)}, ${generateConst((value as Vector4).y)}, ${generateConst((value as Vector4).z)}, ${generateConst((value as Vector4).w)} )`;
+        } else if (typeLength > 4 && value && ((value as Matrix3).isMatrix3 || (value as Matrix4).isMatrix4)) {
+            return `${this.getType(type)}( ${(value as Matrix3 | Matrix4).elements.map(generateConst).join(', ')} )`;
         } else if (typeLength > 4) {
             return `${this.getType(type)}()`;
         }
@@ -436,17 +579,17 @@ class NodeBuilder {
         throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);
     }
 
-    getType(type) {
+    getType(type: string | null) {
         if (type === 'color') return 'vec3';
 
         return type;
     }
 
-    hasGeometryAttribute(name) {
+    hasGeometryAttribute(name: string) {
         return this.geometry && this.geometry.getAttribute(name) !== undefined;
     }
 
-    getAttribute(name, type) {
+    getAttribute(name: string, type: string | null) {
         const attributes = this.attributes;
 
         // find attribute
@@ -466,19 +609,19 @@ class NodeBuilder {
         return attribute;
     }
 
-    getPropertyName(node /*, shaderStage*/) {
-        return node.name;
+    getPropertyName(node: unknown, shaderStage?: NodeShaderStage) {
+        return (node as { name?: string }).name;
     }
 
-    isVector(type) {
-        return /vec\d/.test(type);
+    isVector(type: string | null) {
+        return /vec\d/.test(type!);
     }
 
-    isMatrix(type) {
-        return /mat\d/.test(type);
+    isMatrix(type: string | null) {
+        return /mat\d/.test(type!);
     }
 
-    isReference(type) {
+    isReference(type: string | null) {
         return (
             type === 'void' ||
             type === 'property' ||
@@ -495,10 +638,10 @@ class NodeBuilder {
         return false;
     }
 
-    getComponentTypeFromTexture(texture) {
+    getComponentTypeFromTexture(texture: Texture) {
         const type = texture.type;
 
-        if (texture.isDataTexture) {
+        if ((texture as DataTexture).isDataTexture) {
             if (type === IntType) return 'int';
             if (type === UnsignedIntType) return 'uint';
         }
@@ -506,7 +649,7 @@ class NodeBuilder {
         return 'float';
     }
 
-    getElementType(type) {
+    getElementType(type: string | null) {
         if (type === 'mat2') return 'vec2';
         if (type === 'mat3') return 'vec3';
         if (type === 'mat4') return 'vec4';
@@ -514,7 +657,7 @@ class NodeBuilder {
         return this.getComponentType(type);
     }
 
-    getComponentType(type) {
+    getComponentType(type: string | null) {
         type = this.getVectorType(type);
 
         if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;
@@ -530,7 +673,7 @@ class NodeBuilder {
         return 'float';
     }
 
-    getVectorType(type) {
+    getVectorType(type: string | null) {
         if (type === 'color') return 'vec3';
         if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D')
             return 'vec4';
@@ -538,23 +681,23 @@ class NodeBuilder {
         return type;
     }
 
-    getTypeFromLength(length, componentType = 'float') {
+    getTypeFromLength(length: number, componentType: string | null = 'float') {
         if (length === 1) return componentType;
 
         const baseType = typeFromLength.get(length);
-        const prefix = componentType === 'float' ? '' : componentType[0];
+        const prefix = componentType === 'float' ? '' : componentType![0];
 
         return prefix + baseType;
     }
 
-    getTypeFromArray(array) {
-        return typeFromArray.get(array.constructor);
+    getTypeFromArray(array: TypedArray) {
+        return typeFromArray.get(array.constructor as TypedArrayConstructor);
     }
 
-    getTypeFromAttribute(attribute) {
-        let dataAttribute = attribute;
-
-        if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;
+    getTypeFromAttribute(attribute: BufferAttribute | InterleavedBufferAttribute) {
+        const dataAttribute = (attribute as InterleavedBufferAttribute).isInterleavedBufferAttribute
+            ? (attribute as InterleavedBufferAttribute).data
+            : attribute;
 
         const array = dataAttribute.array;
         const itemSize = attribute.itemSize;
@@ -569,28 +712,28 @@ class NodeBuilder {
         return this.getTypeFromLength(itemSize, arrayType);
     }
 
-    getTypeLength(type) {
+    getTypeLength(type: string | null) {
         const vecType = this.getVectorType(type);
-        const vecNum = /vec([2-4])/.exec(vecType);
+        const vecNum = /vec([2-4])/.exec(vecType!);
 
         if (vecNum !== null) return Number(vecNum[1]);
         if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;
-        if (/mat2/.test(type) === true) return 4;
-        if (/mat3/.test(type) === true) return 9;
-        if (/mat4/.test(type) === true) return 16;
+        if (/mat2/.test(type!) === true) return 4;
+        if (/mat3/.test(type!) === true) return 9;
+        if (/mat4/.test(type!) === true) return 16;
 
         return 0;
     }
 
-    getVectorFromMatrix(type) {
+    getVectorFromMatrix(type: string) {
         return type.replace('mat', 'vec');
     }
 
-    changeComponentType(type, newComponentType) {
+    changeComponentType(type: string, newComponentType: string) {
         return this.getTypeFromLength(this.getTypeLength(type), newComponentType);
     }
 
-    getIntegerType(type) {
+    getIntegerType(type: string) {
         const componentType = this.getComponentType(type);
 
         if (componentType === 'int' || componentType === 'uint') return type;
@@ -616,7 +759,11 @@ class NodeBuilder {
         return lastStack;
     }
 
-    getDataFromNode(node, shaderStage = this.shaderStage, cache = null) {
+    getDataFromNode(
+        node: Node,
+        shaderStage: NodeShaderStage | 'any' = this.shaderStage!,
+        cache: NodeCache | null = null,
+    ) {
         cache = cache === null ? (node.isGlobal(this) ? this.globalCache : this.cache) : cache;
 
         let nodeData = cache.getData(node);
@@ -629,16 +776,16 @@ class NodeBuilder {
 
         if (nodeData[shaderStage] === undefined) nodeData[shaderStage] = {};
 
-        return nodeData[shaderStage];
+        return nodeData[shaderStage]!;
     }
 
-    getNodeProperties(node, shaderStage = 'any') {
+    getNodeProperties(node: Node, shaderStage: NodeShaderStage | 'any' = 'any') {
         const nodeData = this.getDataFromNode(node, shaderStage);
 
         return nodeData.properties || (nodeData.properties = { outputNode: null });
     }
 
-    getBufferAttributeFromNode(node, type) {
+    getBufferAttributeFromNode(node: Node, type: string | null) {
         const nodeData = this.getDataFromNode(node);
 
         let bufferAttribute = nodeData.bufferAttribute;
@@ -656,7 +803,7 @@ class NodeBuilder {
         return bufferAttribute;
     }
 
-    getStructTypeFromNode(node, shaderStage = this.shaderStage) {
+    getStructTypeFromNode(node: StructTypeNode, shaderStage = this.shaderStage!) {
         const nodeData = this.getDataFromNode(node, shaderStage);
 
         if (nodeData.structType === undefined) {
@@ -671,7 +818,12 @@ class NodeBuilder {
         return node;
     }
 
-    getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {
+    getUniformFromNode(
+        node: UniformNode<unknown>,
+        type: string | null,
+        shaderStage = this.shaderStage!,
+        name: string | null = null,
+    ) {
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
         let nodeUniform = nodeData.uniform;
@@ -689,7 +841,12 @@ class NodeBuilder {
         return nodeUniform;
     }
 
-    getVarFromNode(node, name = null, type = node.getNodeType(this), shaderStage = this.shaderStage) {
+    getVarFromNode(
+        node: Node,
+        name: string | null = null,
+        type = node.getNodeType(this),
+        shaderStage = this.shaderStage!,
+    ) {
         const nodeData = this.getDataFromNode(node, shaderStage);
 
         let nodeVar = nodeData.variable;
@@ -709,7 +866,7 @@ class NodeBuilder {
         return nodeVar;
     }
 
-    getVaryingFromNode(node, name = null, type = node.getNodeType(this)) {
+    getVaryingFromNode(node: Node, name: string | null = null, type = node.getNodeType(this)) {
         const nodeData = this.getDataFromNode(node, 'any');
 
         let nodeVarying = nodeData.varying;
@@ -730,7 +887,7 @@ class NodeBuilder {
         return nodeVarying;
     }
 
-    getCodeFromNode(node, type, shaderStage = this.shaderStage) {
+    getCodeFromNode(node: Node, type: string | null, shaderStage = this.shaderStage!) {
         const nodeData = this.getDataFromNode(node);
 
         let nodeCode = nodeData.code;
@@ -749,7 +906,7 @@ class NodeBuilder {
         return nodeCode;
     }
 
-    addLineFlowCode(code) {
+    addLineFlowCode(code: string) {
         if (code === '') return this;
 
         code = this.tab + code;
@@ -763,7 +920,7 @@ class NodeBuilder {
         return this;
     }
 
-    addFlowCode(code) {
+    addFlowCode(code: string) {
         this.flow.code += code;
 
         return this;
@@ -781,11 +938,11 @@ class NodeBuilder {
         return this;
     }
 
-    getFlowData(node /*, shaderStage*/) {
+    getFlowData(node: Node /*, shaderStage*/) {
         return this.flowsData.get(node);
     }
 
-    flowNode(node) {
+    flowNode(node: Node) {
         const output = node.getNodeType(this);
 
         const flowData = this.flowChildNode(node, output);
@@ -795,7 +952,9 @@ class NodeBuilder {
         return flowData;
     }
 
-    buildFunctionNode(shaderNode) {
+    abstract buildFunctionCode(shaderNode: ShaderNodeInternal): string;
+
+    buildFunctionNode(shaderNode: ShaderNodeInternal) {
         const fn = new FunctionNode();
 
         const previous = this.currentFunctionNode;
@@ -809,7 +968,7 @@ class NodeBuilder {
         return fn;
     }
 
-    flowShaderNode(shaderNode) {
+    flowShaderNode(shaderNode: ShaderNodeInternal) {
         const layout = shaderNode.layout;
 
         let inputs;
@@ -817,13 +976,13 @@ class NodeBuilder {
         if (shaderNode.isArrayInput) {
             inputs = [];
 
-            for (const input of layout.inputs) {
+            for (const input of layout!.inputs) {
                 inputs.push(new ParameterNode(input.type, input.name));
             }
         } else {
             inputs = {};
 
-            for (const input of layout.inputs) {
+            for (const input of layout!.inputs) {
                 inputs[input.name] = new ParameterNode(input.type, input.name);
             }
         }
@@ -840,14 +999,14 @@ class NodeBuilder {
         return flowData;
     }
 
-    flowStagesNode(node, output = null) {
+    flowStagesNode(node: Node, output: string | null = null) {
         const previousFlow = this.flow;
         const previousVars = this.vars;
         const previousCache = this.cache;
         const previousBuildStage = this.buildStage;
         const previousStack = this.stack;
 
-        const flow = {
+        const flow: Flow = {
             code: '',
         };
 
@@ -862,7 +1021,7 @@ class NodeBuilder {
             flow.result = node.build(this, output);
         }
 
-        flow.vars = this.getVars(this.shaderStage);
+        flow.vars = this.getVars(this.shaderStage!);
 
         this.flow = previousFlow;
         this.vars = previousVars;
@@ -878,10 +1037,10 @@ class NodeBuilder {
         return null;
     }
 
-    flowChildNode(node, output = null) {
+    flowChildNode(node: Node, output: string | null = null) {
         const previousFlow = this.flow;
 
-        const flow = {
+        const flow: Flow = {
             code: '',
         };
 
@@ -894,7 +1053,12 @@ class NodeBuilder {
         return flow;
     }
 
-    flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {
+    flowNodeFromShaderStage(
+        shaderStage: 'vertex' | 'fragment' | 'compute',
+        node: Node,
+        output: string | null = null,
+        propertyName: string | null = null,
+    ) {
         const previousShaderStage = this.shaderStage;
 
         this.setShaderStage(shaderStage);
@@ -916,19 +1080,15 @@ class NodeBuilder {
         return this.attributes.concat(this.bufferAttributes);
     }
 
-    getAttributes(/*shaderStage*/) {
-        console.warn('Abstract function.');
-    }
+    abstract getAttributes(shaderStage: NodeShaderStage): string;
 
-    getVaryings(/*shaderStage*/) {
-        console.warn('Abstract function.');
-    }
+    abstract getVaryings(shaderStage: NodeShaderStage): string;
 
-    getVar(type, name) {
+    getVar(type: string | null, name: string) {
         return `${this.getType(type)} ${name}`;
     }
 
-    getVars(shaderStage) {
+    getVars(shaderStage: 'vertex' | 'fragment' | 'compute') {
         let snippet = '';
 
         const vars = this.vars[shaderStage];
@@ -942,11 +1102,9 @@ class NodeBuilder {
         return snippet;
     }
 
-    getUniforms(/*shaderStage*/) {
-        console.warn('Abstract function.');
-    }
+    abstract getUniforms(shaderStage: NodeShaderStage): string;
 
-    getCodes(shaderStage) {
+    getCodes(shaderStage: 'vertex' | 'fragment' | 'compute') {
         const codes = this.codes[shaderStage];
 
         let code = '';
@@ -961,10 +1119,10 @@ class NodeBuilder {
     }
 
     getHash() {
-        return this.vertexShader + this.fragmentShader + this.computeShader;
+        return this.vertexShader! + this.fragmentShader + this.computeShader;
     }
 
-    setShaderStage(shaderStage) {
+    setShaderStage(shaderStage: NodeShaderStage | null) {
         this.shaderStage = shaderStage;
     }
 
@@ -972,7 +1130,7 @@ class NodeBuilder {
         return this.shaderStage;
     }
 
-    setBuildStage(buildStage) {
+    setBuildStage(buildStage: string | null) {
         this.buildStage = buildStage;
     }
 
@@ -1030,7 +1188,7 @@ class NodeBuilder {
         return this;
     }
 
-    getNodeUniform(uniformNode, type) {
+    getNodeUniform(uniformNode: NodeUniform<unknown>, type: string | null) {
         if (type === 'float' || type === 'int' || type === 'uint') return new NumberNodeUniform(uniformNode);
         if (type === 'vec2' || type === 'ivec2' || type === 'uvec2') return new Vector2NodeUniform(uniformNode);
         if (type === 'vec3' || type === 'ivec3' || type === 'uvec3') return new Vector3NodeUniform(uniformNode);
@@ -1048,7 +1206,7 @@ class NodeBuilder {
         return createNodeMaterialFromType(type);
     }
 
-    format(snippet, fromType, toType) {
+    format(snippet: string, fromType: string | null, toType: string | null): string {
         fromType = this.getVectorType(fromType);
         toType = this.getVectorType(toType);
 
diff --git a/examples-jsm/examples/nodes/core/NodeCache.ts b/examples-jsm/examples/nodes/core/NodeCache.ts
index ad72d50c..c2593032 100644
--- a/examples-jsm/examples/nodes/core/NodeCache.ts
+++ b/examples-jsm/examples/nodes/core/NodeCache.ts
@@ -1,24 +1,74 @@
+import NodeAttribute from './NodeAttribute.js';
+import NodeUniform from './NodeUniform.js';
+import NodeVar from './NodeVar.js';
+import NodeVarying from './NodeVarying.js';
+import NodeCode from './NodeCode.js';
+import Node from './Node.js';
+import { BufferAttribute, InterleavedBuffer, TypedArray } from 'three';
+import BufferAttributeNode from '../accessors/BufferAttributeNode.js';
+
 let id = 0;
 
+export interface ShaderStageNodeData {
+    properties?:
+        | ({
+              outputNode: Node | null;
+              initialized?: boolean | undefined;
+          } & {
+              [K in `node${string}`]?: Node | undefined;
+          })
+        | undefined;
+    bufferAttribute?: NodeAttribute | undefined;
+    structType?: Node | undefined;
+    uniform?: NodeUniform<unknown> | undefined;
+    variable?: NodeVar | undefined;
+    varying?: NodeVarying | undefined;
+    code?: NodeCode | undefined;
+    usageCount?: number | undefined;
+    snippet?: string | undefined;
+    propertyName?: string | undefined;
+    propertySizeName?: string | undefined;
+}
+
+interface NodeData {
+    vertex?: ShaderStageNodeData | undefined;
+    fragment?: ShaderStageNodeData | undefined;
+    compute?: ShaderStageNodeData | undefined;
+    any?: ShaderStageNodeData | undefined;
+}
+
+interface BufferAttributeData {
+    node: BufferAttributeNode;
+}
+
 class NodeCache {
-    constructor(parent = null) {
+    id: number;
+    nodesData: WeakMap<Node | TypedArray | InterleavedBuffer | BufferAttribute, NodeData | BufferAttributeData>;
+
+    parent: NodeCache | null;
+
+    constructor(parent: NodeCache | null = null) {
         this.id = id++;
         this.nodesData = new WeakMap();
 
         this.parent = parent;
     }
 
-    getData(node) {
+    getData(node: Node): NodeData | undefined;
+    getData(node: TypedArray | InterleavedBuffer | BufferAttribute): BufferAttributeData | undefined;
+    getData(node: Node | TypedArray | InterleavedBuffer | BufferAttribute): NodeData | BufferAttributeData | undefined {
         let data = this.nodesData.get(node);
 
         if (data === undefined && this.parent !== null) {
-            data = this.parent.getData(node);
+            data = this.parent.getData(node as Node);
         }
 
         return data;
     }
 
-    setData(node, data) {
+    setData(node: Node, data: NodeData): void;
+    setData(node: TypedArray | InterleavedBuffer | BufferAttribute, data: BufferAttributeData): void;
+    setData(node: Node | TypedArray | InterleavedBuffer | BufferAttribute, data: NodeData | BufferAttributeData) {
         this.nodesData.set(node, data);
     }
 }
diff --git a/examples-jsm/examples/nodes/core/NodeCode.ts b/examples-jsm/examples/nodes/core/NodeCode.ts
index 2ee50903..0c0d8c87 100644
--- a/examples-jsm/examples/nodes/core/NodeCode.ts
+++ b/examples-jsm/examples/nodes/core/NodeCode.ts
@@ -1,5 +1,9 @@
 class NodeCode {
-    constructor(name, type, code = '') {
+    name: string;
+    type: string | null;
+    code: string;
+
+    constructor(name: string, type: string | null, code = '') {
         this.name = name;
         this.type = type;
         this.code = code;
diff --git a/examples-jsm/examples/nodes/core/NodeFrame.ts b/examples-jsm/examples/nodes/core/NodeFrame.ts
index ee64620c..14eb7f75 100644
--- a/examples-jsm/examples/nodes/core/NodeFrame.ts
+++ b/examples-jsm/examples/nodes/core/NodeFrame.ts
@@ -1,6 +1,26 @@
 import { NodeUpdateType } from './constants.js';
+import Node from './Node.js';
+import Renderer from '../../renderers/common/Renderer.js';
+import { Camera, Material, Object3D, Scene } from 'three';
 
 class NodeFrame {
+    time: number;
+    deltaTime: number;
+
+    frameId: number;
+    renderId: number;
+
+    // TODO startTime
+
+    // TODO updateMap
+    // TODO updateBeforeMap
+
+    renderer: Renderer | null;
+    material: Material | null;
+    camera: Camera | null;
+    object: Object3D | null;
+    scene: Scene | null;
+
     constructor() {
         this.time = 0;
         this.deltaTime = 0;
@@ -36,7 +56,7 @@ class NodeFrame {
         return maps;
     }
 
-    updateBeforeNode(node) {
+    updateBeforeNode(node: Node) {
         const updateType = node.getUpdateBeforeType();
         const reference = node.updateReference(this);
 
@@ -86,7 +106,7 @@ class NodeFrame {
         }
     }
 
-    updateNode(node) {
+    updateNode(node: Node) {
         const updateType = node.getUpdateType();
         const reference = node.updateReference(this);
 
diff --git a/examples-jsm/examples/nodes/core/NodeKeywords.ts b/examples-jsm/examples/nodes/core/NodeKeywords.ts
index 1f468321..36bdcabe 100644
--- a/examples-jsm/examples/nodes/core/NodeKeywords.ts
+++ b/examples-jsm/examples/nodes/core/NodeKeywords.ts
@@ -1,11 +1,18 @@
+import Node from './Node.js';
+import NodeBuilder from './NodeBuilder.js';
+
 class NodeKeywords {
+    keywords: string[];
+    nodes: { [name: string]: Node };
+    keywordsCallback: { [name: string]: (name: string) => Node };
+
     constructor() {
         this.keywords = [];
         this.nodes = {};
         this.keywordsCallback = {};
     }
 
-    getNode(name) {
+    getNode(name: string) {
         let node = this.nodes[name];
 
         if (node === undefined && this.keywordsCallback[name] !== undefined) {
@@ -17,14 +24,14 @@ class NodeKeywords {
         return node;
     }
 
-    addKeyword(name, callback) {
+    addKeyword(name: string, callback: (name: string) => Node) {
         this.keywords.push(name);
         this.keywordsCallback[name] = callback;
 
         return this;
     }
 
-    parse(code) {
+    parse(code: string) {
         const keywordNames = this.keywords;
 
         const regExp = new RegExp(`\\b${keywordNames.join('\\b|\\b')}\\b`, 'g');
@@ -46,7 +53,7 @@ class NodeKeywords {
         return keywordNodes;
     }
 
-    include(builder, code) {
+    include(builder: NodeBuilder, code: string) {
         const keywordNodes = this.parse(code);
 
         for (const keywordNode of keywordNodes) {
diff --git a/examples-jsm/examples/nodes/core/NodeParser.ts b/examples-jsm/examples/nodes/core/NodeParser.ts
index 9849452f..76c5b9be 100644
--- a/examples-jsm/examples/nodes/core/NodeParser.ts
+++ b/examples-jsm/examples/nodes/core/NodeParser.ts
@@ -1,7 +1,7 @@
-class NodeParser {
-    parseFunction(/*source*/) {
-        console.warn('Abstract function.');
-    }
+import NodeFunction from './NodeFunction.js';
+
+abstract class NodeParser {
+    abstract parseFunction(source: string): NodeFunction;
 }
 
 export default NodeParser;
diff --git a/examples-jsm/examples/nodes/core/NodeUniform.ts b/examples-jsm/examples/nodes/core/NodeUniform.ts
index ca43958f..ae51479e 100644
--- a/examples-jsm/examples/nodes/core/NodeUniform.ts
+++ b/examples-jsm/examples/nodes/core/NodeUniform.ts
@@ -1,5 +1,14 @@
-class NodeUniform {
-    constructor(name, type, node) {
+import UniformNode from './UniformNode.js';
+
+class NodeUniform<TValue> {
+    readonly isNodeUniform: true;
+
+    name: string;
+    type: string | null;
+    node: UniformNode<TValue>;
+    needsUpdate: boolean | undefined;
+
+    constructor(name: string, type: string | null, node: UniformNode<TValue>) {
         this.isNodeUniform = true;
 
         this.name = name;
diff --git a/examples-jsm/examples/nodes/core/NodeUtils.ts b/examples-jsm/examples/nodes/core/NodeUtils.ts
index 16a5f324..6adbec50 100644
--- a/examples-jsm/examples/nodes/core/NodeUtils.ts
+++ b/examples-jsm/examples/nodes/core/NodeUtils.ts
@@ -1,10 +1,11 @@
 import { Color, Matrix3, Matrix4, Vector2, Vector3, Vector4 } from 'three';
+import Node from './Node.js';
 
-export function getCacheKey(object, force = false) {
+export function getCacheKey(object: object, force = false) {
     let cacheKey = '{';
 
-    if (object.isNode === true) {
-        cacheKey += object.id;
+    if ((object as Node).isNode === true) {
+        cacheKey += (object as Node).id;
     }
 
     for (const { property, childNode } of getNodeChildren(object)) {
@@ -16,36 +17,58 @@ export function getCacheKey(object, force = false) {
     return cacheKey;
 }
 
-export function* getNodeChildren(node, toJSON = false) {
+export interface NodeChild {
+    property: string;
+    index?: number | string;
+    childNode: Node;
+}
+
+export interface NodeChildWithToJSON {
+    property: string;
+    index?: number | string;
+    childNode: Node | { toJSON: () => unknown };
+}
+
+export function getNodeChildren(node: object): Generator<NodeChild, void>;
+export function getNodeChildren(node: object, toJSON: boolean): Generator<NodeChildWithToJSON, void>;
+export function* getNodeChildren(node: object, toJSON = false) {
     for (const property in node) {
         // Ignore private properties.
         if (property.startsWith('_') === true) continue;
 
-        const object = node[property];
+        const object = node[property as keyof typeof node] as unknown;
 
         if (Array.isArray(object) === true) {
             for (let i = 0; i < object.length; i++) {
-                const child = object[i];
-
-                if (child && (child.isNode === true || (toJSON && typeof child.toJSON === 'function'))) {
-                    yield { property, index: i, childNode: child };
+                const child = object[i] as unknown;
+
+                if (
+                    child &&
+                    ((child as Node).isNode === true ||
+                        (toJSON && typeof (child as { toJSON: () => unknown }).toJSON === 'function'))
+                ) {
+                    yield { property, index: i, childNode: child as Node | { toJSON: () => unknown } };
                 }
             }
-        } else if (object && object.isNode === true) {
-            yield { property, childNode: object };
+        } else if (object && (object as Node).isNode === true) {
+            yield { property, childNode: object as Node };
         } else if (typeof object === 'object') {
             for (const subProperty in object) {
-                const child = object[subProperty];
-
-                if (child && (child.isNode === true || (toJSON && typeof child.toJSON === 'function'))) {
-                    yield { property, index: subProperty, childNode: child };
+                const child = object[subProperty as keyof typeof object];
+
+                if (
+                    child &&
+                    ((child as Node).isNode === true ||
+                        (toJSON && typeof (child as { toJSON: () => unknown }).toJSON === 'function'))
+                ) {
+                    yield { property, index: subProperty, childNode: child as Node | { toJSON: () => unknown } };
                 }
             }
         }
     }
 }
 
-export function getValueType(value) {
+export function getValueType(value: unknown) {
     if (value === undefined || value === null) return null;
 
     const typeOf = typeof value;
diff --git a/examples-jsm/examples/nodes/core/NodeVar.ts b/examples-jsm/examples/nodes/core/NodeVar.ts
index e6e935b3..8d04ff16 100644
--- a/examples-jsm/examples/nodes/core/NodeVar.ts
+++ b/examples-jsm/examples/nodes/core/NodeVar.ts
@@ -1,5 +1,10 @@
 class NodeVar {
-    constructor(name, type) {
+    readonly isNodeVar: true;
+
+    name: string;
+    type: string | null;
+
+    constructor(name: string, type: string | null) {
         this.isNodeVar = true;
 
         this.name = name;
diff --git a/examples-jsm/examples/nodes/core/NodeVarying.ts b/examples-jsm/examples/nodes/core/NodeVarying.ts
index a1482362..0a62b23d 100644
--- a/examples-jsm/examples/nodes/core/NodeVarying.ts
+++ b/examples-jsm/examples/nodes/core/NodeVarying.ts
@@ -1,7 +1,11 @@
 import NodeVar from './NodeVar.js';
 
 class NodeVarying extends NodeVar {
-    constructor(name, type) {
+    needsInterpolation: boolean;
+
+    readonly isNodeVarying: true;
+
+    constructor(name: string, type: string | null) {
         super(name, type);
 
         this.needsInterpolation = false;
diff --git a/examples-jsm/examples/nodes/core/StackNode.ts b/examples-jsm/examples/nodes/core/StackNode.ts
index d9322607..4ec41a07 100644
--- a/examples-jsm/examples/nodes/core/StackNode.ts
+++ b/examples-jsm/examples/nodes/core/StackNode.ts
@@ -1,8 +1,16 @@
 import Node, { addNodeClass } from './Node.js';
 import { cond } from '../math/CondNode.js';
-import { ShaderNode, nodeProxy, getCurrentStack, setCurrentStack } from '../shadernode/ShaderNode.js';
+import { ShaderNode, nodeProxy, getCurrentStack, setCurrentStack, ShaderNodeObject } from '../shadernode/ShaderNode.js';
+import NodeBuilder from './NodeBuilder.js';
 
 class StackNode extends Node {
+    nodes: Node[];
+    outputNode: Node | null;
+
+    parent: ShaderNodeObject<StackNode> | null;
+
+    readonly isStackNode: true;
+
     constructor(parent = null) {
         super();
 
@@ -16,24 +24,24 @@ class StackNode extends Node {
         this.isStackNode = true;
     }
 
-    getNodeType(builder) {
+    getNodeType(builder: NodeBuilder) {
         return this.outputNode ? this.outputNode.getNodeType(builder) : 'void';
     }
 
-    add(node) {
+    add(node: Node) {
         this.nodes.push(node);
 
         return this;
     }
 
-    if(boolNode, method) {
+    if(boolNode: Node, method: () => void) {
         const methodNode = new ShaderNode(method);
         this._currentCond = cond(boolNode, methodNode);
 
         return this.add(this._currentCond);
     }
 
-    elseif(boolNode, method) {
+    elseif(boolNode: Node, method: () => void) {
         const methodNode = new ShaderNode(method);
         const ifNode = cond(boolNode, methodNode);
 
@@ -43,13 +51,13 @@ class StackNode extends Node {
         return this;
     }
 
-    else(method) {
+    else(method: () => void) {
         this._currentCond.elseNode = new ShaderNode(method);
 
         return this;
     }
 
-    build(builder, ...params) {
+    build(builder: NodeBuilder, ...params) {
         const previousStack = getCurrentStack();
 
         setCurrentStack(this);
diff --git a/examples-jsm/examples/nodes/core/StructTypeNode.ts b/examples-jsm/examples/nodes/core/StructTypeNode.ts
index 69718799..e7574a1c 100644
--- a/examples-jsm/examples/nodes/core/StructTypeNode.ts
+++ b/examples-jsm/examples/nodes/core/StructTypeNode.ts
@@ -1,7 +1,10 @@
 import Node, { addNodeClass } from './Node.js';
 
 class StructTypeNode extends Node {
-    constructor(types) {
+    types: string[];
+    readonly isStructTypeNode: true;
+
+    constructor(types: string[]) {
         super();
 
         this.types = types;
diff --git a/examples-jsm/examples/nodes/core/UniformGroupNode.ts b/examples-jsm/examples/nodes/core/UniformGroupNode.ts
index f8bb2b37..cee70486 100644
--- a/examples-jsm/examples/nodes/core/UniformGroupNode.ts
+++ b/examples-jsm/examples/nodes/core/UniformGroupNode.ts
@@ -2,6 +2,13 @@ import Node from './Node.js';
 import { addNodeClass } from './Node.js';
 
 class UniformGroupNode extends Node {
+    // TODO name
+    version: number;
+
+    shared: boolean;
+
+    isUniformGroup: boolean;
+
     constructor(name, shared = false) {
         super('string');
 
@@ -13,7 +20,7 @@ class UniformGroupNode extends Node {
         this.isUniformGroup = true;
     }
 
-    set needsUpdate(value) {
+    set needsUpdate(value: boolean) {
         if (value === true) this.version++;
     }
 }
diff --git a/examples-jsm/examples/nodes/core/UniformNode.ts b/examples-jsm/examples/nodes/core/UniformNode.ts
index 41e523c4..a0c2ae45 100644
--- a/examples-jsm/examples/nodes/core/UniformNode.ts
+++ b/examples-jsm/examples/nodes/core/UniformNode.ts
@@ -1,10 +1,18 @@
 import InputNode from './InputNode.js';
-import { objectGroup } from './UniformGroupNode.js';
-import { addNodeClass } from './Node.js';
+import UniformGroupNode, { objectGroup } from './UniformGroupNode.js';
+import Node, { addNodeClass } from './Node.js';
 import { nodeObject, getConstNodeType } from '../shadernode/ShaderNode.js';
+import NodeBuilder from './NodeBuilder.js';
+import NodeFrame from './NodeFrame.js';
+import { NodeUpdateType } from './constants.js';
 
-class UniformNode extends InputNode {
-    constructor(value, nodeType = null) {
+class UniformNode<TValue> extends InputNode<TValue> {
+    readonly isUniformNode: true;
+
+    name: string;
+    groupNode: UniformGroupNode;
+
+    constructor(value: TValue, nodeType: string | null = null) {
         super(value, nodeType);
 
         this.isUniformNode = true;
@@ -13,13 +21,13 @@ class UniformNode extends InputNode {
         this.groupNode = objectGroup;
     }
 
-    label(name) {
+    label(name: string) {
         this.name = name;
 
         return this;
     }
 
-    setGroup(group) {
+    setGroup(group: UniformGroupNode) {
         this.groupNode = group;
 
         return this;
@@ -29,11 +37,11 @@ class UniformNode extends InputNode {
         return this.groupNode;
     }
 
-    getUniformHash(builder) {
+    getUniformHash(builder: NodeBuilder) {
         return this.getHash(builder);
     }
 
-    onUpdate(callback, updateType) {
+    onUpdate(callback: (frame: NodeFrame, self: this) => TValue | undefined, updateType: NodeUpdateType) {
         const self = this.getSelf();
 
         callback = callback.bind(self);
@@ -47,12 +55,12 @@ class UniformNode extends InputNode {
         }, updateType);
     }
 
-    generate(builder, output) {
+    generate(builder: NodeBuilder, output: string | null) {
         const type = this.getNodeType(builder);
 
         const hash = this.getUniformHash(builder);
 
-        let sharedNode = builder.getNodeFromHash(hash);
+        let sharedNode = builder.getNodeFromHash(hash) as this;
 
         if (sharedNode === undefined) {
             builder.setHashNode(this, hash);
@@ -65,7 +73,7 @@ class UniformNode extends InputNode {
         const nodeUniform = builder.getUniformFromNode(
             sharedNode,
             sharedNodeType,
-            builder.shaderStage,
+            builder.shaderStage!,
             this.name || builder.context.label,
         );
         const propertyName = builder.getPropertyName(nodeUniform);
@@ -78,11 +86,14 @@ class UniformNode extends InputNode {
 
 export default UniformNode;
 
-export const uniform = (arg1, arg2) => {
+export const uniform = <TValue>(arg1: InputNode<TValue> | TValue, arg2?: Node | string) => {
     const nodeType = getConstNodeType(arg2 || arg1);
 
     // @TODO: get ConstNode from .traverse() in the future
-    const value = arg1 && arg1.isNode === true ? (arg1.node && arg1.node.value) || arg1.value : arg1;
+    const value: TValue =
+        arg1 && (arg1 as Node).isNode === true
+            ? (arg1.node && arg1.node.value) || (arg1 as InputNode<TValue>).value
+            : arg1;
 
     return nodeObject(new UniformNode(value, nodeType));
 };
diff --git a/examples-jsm/examples/nodes/core/constants.ts b/examples-jsm/examples/nodes/core/constants.ts
index 3b01a9a6..5ff6ad5f 100644
--- a/examples-jsm/examples/nodes/core/constants.ts
+++ b/examples-jsm/examples/nodes/core/constants.ts
@@ -1,14 +1,14 @@
 export const NodeShaderStage = {
     VERTEX: 'vertex',
     FRAGMENT: 'fragment',
-};
+} as const;
 
 export const NodeUpdateType = {
     NONE: 'none',
     FRAME: 'frame',
     RENDER: 'render',
     OBJECT: 'object',
-};
+} as const;
 
 export const NodeType = {
     BOOLEAN: 'bool',
@@ -20,9 +20,12 @@ export const NodeType = {
     MATRIX2: 'mat2',
     MATRIX3: 'mat3',
     MATRIX4: 'mat4',
-};
+} as const;
 
-export const defaultShaderStages = ['fragment', 'vertex'];
+export type NodeShaderStage = 'vertex' | 'fragment' | 'compute';
+export type NodeUpdateType = 'none' | 'frame' | 'render' | 'object';
+
+export const defaultShaderStages: NodeShaderStage[] = ['fragment', 'vertex'];
 export const defaultBuildStages = ['setup', 'analyze', 'generate'];
-export const shaderStages = [...defaultShaderStages, 'compute'];
+export const shaderStages: NodeShaderStage[] = [...defaultShaderStages, 'compute'];
 export const vectorComponents = ['x', 'y', 'z', 'w'];
diff --git a/examples-jsm/examples/nodes/fog/FogNode.ts b/examples-jsm/examples/nodes/fog/FogNode.ts
index 9417df5a..43761555 100644
--- a/examples-jsm/examples/nodes/fog/FogNode.ts
+++ b/examples-jsm/examples/nodes/fog/FogNode.ts
@@ -1,6 +1,7 @@
 import Node, { addNodeClass } from '../core/Node.js';
 import { positionView } from '../accessors/PositionNode.js';
 import { addNodeElement, nodeProxy } from '../shadernode/ShaderNode.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 class FogNode extends Node {
     constructor(colorNode, factorNode) {
@@ -12,7 +13,7 @@ class FogNode extends Node {
         this.factorNode = factorNode;
     }
 
-    getViewZNode(builder) {
+    getViewZNode(builder: NodeBuilder) {
         let viewZ;
 
         const getViewZ = builder.context.getViewZ;
diff --git a/examples-jsm/examples/nodes/lighting/LightingContextNode.ts b/examples-jsm/examples/nodes/lighting/LightingContextNode.ts
index 02a8b51f..1d11c859 100644
--- a/examples-jsm/examples/nodes/lighting/LightingContextNode.ts
+++ b/examples-jsm/examples/nodes/lighting/LightingContextNode.ts
@@ -1,9 +1,31 @@
 import ContextNode from '../core/ContextNode.js';
-import { addNodeClass } from '../core/Node.js';
-import { addNodeElement, nodeProxy, float, vec3 } from '../shadernode/ShaderNode.js';
+import Node, { addNodeClass } from '../core/Node.js';
+import { addNodeElement, nodeProxy, float, vec3, ShaderNodeObject } from '../shadernode/ShaderNode.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
-class LightingContextNode extends ContextNode {
-    constructor(node, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
+interface LightingContext {
+    radiance: ShaderNodeObject<Node>;
+    irradiance: ShaderNodeObject<Node>;
+    iblIrradiance: ShaderNodeObject<Node>;
+    ambientOcclusion: ShaderNodeObject<Node>;
+    reflectedLight: {
+        directDiffuse: ShaderNodeObject<Node>;
+        directSpecular: ShaderNodeObject<Node>;
+        indirectDiffuse: ShaderNodeObject<Node>;
+        indirectSpecular: ShaderNodeObject<Node>;
+    };
+    backdrop: Node | null;
+    backdropAlpha: Node | null;
+}
+
+class LightingContextNode extends ContextNode<LightingContext> {
+    // lightingModel;
+    backdropNode: Node | null;
+    backdropAlphaNode: Node | null;
+
+    _context: LightingContext | null;
+
+    constructor(node: Node, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
         super(node);
 
         this.lightingModel = lightingModel;
@@ -28,7 +50,7 @@ class LightingContextNode extends ContextNode {
             indirectSpecular,
         };
 
-        const context = {
+        const context: LightingContext = {
             radiance: vec3().temp('radiance'),
             irradiance: vec3().temp('irradiance'),
             iblIrradiance: vec3().temp('iblIrradiance'),
@@ -41,7 +63,7 @@ class LightingContextNode extends ContextNode {
         return context;
     }
 
-    setup(builder) {
+    setup(builder: NodeBuilder) {
         this.context = this._context || (this._context = this.getContext());
         this.context.lightingModel = this.lightingModel || builder.context.lightingModel;
 
diff --git a/examples-jsm/examples/nodes/lighting/LightsNode.ts b/examples-jsm/examples/nodes/lighting/LightsNode.ts
index 96e5c60a..33fdf4d3 100644
--- a/examples-jsm/examples/nodes/lighting/LightsNode.ts
+++ b/examples-jsm/examples/nodes/lighting/LightsNode.ts
@@ -1,6 +1,7 @@
 import Node from '../core/Node.js';
 import AnalyticLightNode from './AnalyticLightNode.js';
 import { nodeObject, nodeProxy, vec3 } from '../shadernode/ShaderNode.js';
+import { Light } from 'three';
 
 const LightNodes = new WeakMap();
 
@@ -126,7 +127,7 @@ class LightsNode extends Node {
         return null;
     }
 
-    fromLights(lights = []) {
+    fromLights(lights: Light[] = []) {
         const lightNodes = [];
 
         lights = sortLights(lights);
diff --git a/examples-jsm/examples/nodes/materials/NodeMaterial.ts b/examples-jsm/examples/nodes/materials/NodeMaterial.ts
index d0c7c6cd..67319629 100644
--- a/examples-jsm/examples/nodes/materials/NodeMaterial.ts
+++ b/examples-jsm/examples/nodes/materials/NodeMaterial.ts
@@ -31,7 +31,7 @@ import { cameraLogDepth } from '../accessors/CameraNode.js';
 import { clipping, clippingAlpha } from '../accessors/ClippingNode.js';
 import { faceDirection } from '../display/FrontFacingNode.js';
 
-const NodeMaterials = new Map();
+const NodeMaterials = new Map<string, typeof NodeMaterial>();
 
 class NodeMaterial extends Material {
     constructor() {
@@ -492,7 +492,7 @@ class NodeMaterial extends Material {
 
 export default NodeMaterial;
 
-export function addNodeMaterial(type, nodeMaterial) {
+export function addNodeMaterial(type: string, nodeMaterial: typeof NodeMaterial) {
     if (typeof nodeMaterial !== 'function' || !type) throw new Error(`Node material ${type} is not a class`);
     if (NodeMaterials.has(type)) {
         console.warn(`Redefinition of node material ${type}`);
@@ -503,7 +503,7 @@ export function addNodeMaterial(type, nodeMaterial) {
     nodeMaterial.type = type;
 }
 
-export function createNodeMaterialFromType(type) {
+export function createNodeMaterialFromType(type: string) {
     const Material = NodeMaterials.get(type);
 
     if (Material !== undefined) {
diff --git a/examples-jsm/examples/nodes/shadernode/ShaderNode.ts b/examples-jsm/examples/nodes/shadernode/ShaderNode.ts
index 288ffa3d..6ac27582 100644
--- a/examples-jsm/examples/nodes/shadernode/ShaderNode.ts
+++ b/examples-jsm/examples/nodes/shadernode/ShaderNode.ts
@@ -6,11 +6,49 @@ import SplitNode from '../utils/SplitNode.js';
 import SetNode from '../utils/SetNode.js';
 import ConstNode from '../core/ConstNode.js';
 import { getValueFromType, getValueType } from '../core/NodeUtils.js';
+import NodeBuilder from '../core/NodeBuilder.js';
 
 //
 
 let currentStack = null;
 
+export interface NodeElements {
+    append: typeof append;
+
+    toColor: typeof color;
+    toFloat: typeof float;
+    toInt: typeof int;
+    toUint: typeof uint;
+    toBool: typeof bool;
+    toVec2: typeof vec2;
+    toIvec2: typeof ivec2;
+    toUvec2: typeof uvec2;
+    toBvec2: typeof bvec2;
+    toVec3: typeof vec3;
+    toIvec3: typeof ivec3;
+    toUvec3: typeof uvec3;
+    toBvec3: typeof bvec3;
+    toVec4: typeof vec4;
+    toIvec4: typeof ivec4;
+    toUvec4: typeof uvec4;
+    toBvec4: typeof bvec4;
+    toMat2: typeof mat2;
+    toImat2: typeof imat2;
+    toUmat2: typeof umat2;
+    toBmat2: typeof bmat2;
+    toMat3: typeof mat3;
+    toImat3: typeof imat3;
+    toUmat3: typeof umat3;
+    toBmat3: typeof bmat3;
+    toMat4: typeof mat4;
+    toImat4: typeof imat4;
+    toUmat4: typeof umat4;
+    toBmat4: typeof bmat4;
+
+    element: typeof element;
+    convert: typeof convert;
+}
+
 const NodeElements = new Map(); // @TODO: Currently only a few nodes are added, probably also add others
 
 export function addNodeElement(name, nodeElement) {
@@ -24,6 +62,141 @@ export function addNodeElement(name, nodeElement) {
     NodeElements.set(name, nodeElement);
 }
 
+export type SwizzleCharacter = 'x' | 'y' | 'z' | 'w' | 'r' | 'g' | 'b' | 'a' | 's' | 't' | 'p' | 'q';
+
+export type SwizzleOption = Exclude<
+    | `${SwizzleCharacter}`
+    | `${SwizzleCharacter}${SwizzleCharacter}`
+    | `${SwizzleCharacter}${SwizzleCharacter}${SwizzleCharacter}`
+    | `${SwizzleCharacter}${SwizzleCharacter}${SwizzleCharacter}${SwizzleCharacter}`,
+    'abs' | 'sqrt'
+>;
+
+export type Swizzable<T extends Node = Node> = T & {
+    [key in SwizzleOption | number]: ShaderNodeObject<Node>;
+};
+
+export type ShaderNodeObject<T extends Node> = T & {
+    [Key in keyof NodeElements]: T extends { [K in Key]: infer M }
+        ? M
+        : NodeElements[Key] extends (node: T, ...args: infer Args) => infer R
+          ? (...args: Args) => R
+          : never;
+} & {
+    [Key in keyof NodeElements as `${Key}Assign`]: T extends { [K in Key]: infer M }
+        ? M
+        : NodeElements[Key] extends (node: T, ...args: infer Args) => unknown
+          ? (...args: Args) => ShaderNodeObject<T>
+          : never;
+} & Swizzable<T>;
+
+/** anything that can be passed to {@link nodeObject} and returns a proxy */
+export type NodeRepresentation<T extends Node = Node> = number | boolean | Node | ShaderNodeObject<T>;
+
+/** anything that can be passed to {@link nodeObject} */
+export type NodeObjectOption = NodeRepresentation | string;
+
+// same logic as in ShaderNodeObject: number,boolean,node->ShaderNodeObject, otherwise do nothing
+export type NodeObject<T> = T extends Node
+    ? ShaderNodeObject<T>
+    : T extends number | boolean
+      ? ShaderNodeObject<ConstNode<number | boolean>>
+      : T;
+
+// opposite of NodeObject: node -> node|ShaderNodeObject|boolean|number, otherwise do nothing
+type Proxied<T> = T extends Node ? NodeRepresentation<T> : T;
+// https://github.com/microsoft/TypeScript/issues/42435#issuecomment-765557874
+export type ProxiedTuple<T extends readonly [...unknown[]]> = [...{ [index in keyof T]: Proxied<T[index]> }];
+export type ProxiedObject<T> = { [index in keyof T]: Proxied<T[index]> };
+type RemoveTail<T extends readonly [...unknown[]]> = T extends [unknown, ...infer X] ? X : [];
+type RemoveHeadAndTail<T extends readonly [...unknown[]]> = T extends [unknown, ...infer X, unknown] ? X : [];
+
+/**
+ * Temporary type to save signatures of 4 constructors. Each element may be tuple or undefined.
+ *
+ * We use an object instead of tuple or union as it makes stuff easier, especially in Typescript 4.0.
+ */
+interface Construtors<
+    A extends undefined | [...unknown[]],
+    B extends undefined | [...unknown[]],
+    C extends undefined | [...unknown[]],
+    D extends undefined | [...unknown[]],
+> {
+    a: A;
+    b: B;
+    c: C;
+    d: D;
+}
+
+/**
+ * Returns all constructors
+ *
+ * <https://github.com/microsoft/TypeScript/issues/37079>
+ * <https://stackoverflow.com/a/52761156/1623826>
+ */
+type OverloadedConstructorsOf<T> = T extends {
+    new (...args: infer A1): unknown;
+    new (...args: infer A2): unknown;
+    new (...args: infer A3): unknown;
+    new (...args: infer A4): unknown;
+}
+    ? Construtors<A1, A2, A3, A4>
+    : T extends {
+            new (...args: infer A1): unknown;
+            new (...args: infer A2): unknown;
+            new (...args: infer A3): unknown;
+        }
+      ? Construtors<A1, A2, A3, undefined>
+      : T extends {
+              new (...args: infer A1): unknown;
+              new (...args: infer A2): unknown;
+          }
+        ? Construtors<A1, A2, undefined, undefined>
+        : T extends new (...args: infer A) => unknown
+          ? Construtors<A, undefined, undefined, undefined>
+          : Construtors<undefined, undefined, undefined, undefined>;
+
+type AnyConstructors = Construtors<any, any, any, any>;
+
+/**
+ * Returns all constructors where the first paramter is assignable to given "scope"
+ */
+// eslint-disable-next-line @typescript-eslint/consistent-type-definitions
+type FilterConstructorsByScope<T extends AnyConstructors, S> = {
+    a: S extends T['a'][0] ? T['a'] : undefined;
+    b: S extends T['b'][0] ? T['b'] : undefined;
+    c: S extends T['c'][0] ? T['c'] : undefined;
+    d: S extends T['d'][0] ? T['d'] : undefined;
+};
+/**
+ * "flattens" the tuple into an union type
+ */
+type ConstructorUnion<T extends AnyConstructors> =
+    | Exclude<T['a'], undefined>
+    | Exclude<T['b'], undefined>
+    | Exclude<T['c'], undefined>
+    | Exclude<T['d'], undefined>;
+
+/**
+ * Extract list of possible scopes - union of the first paramter
+ * of all constructors, should it be string
+ */
+type ExtractScopes<T extends AnyConstructors> =
+    | (T['a'][0] extends string ? T['a'][0] : never)
+    | (T['b'][0] extends string ? T['b'][0] : never)
+    | (T['c'][0] extends string ? T['c'][0] : never)
+    | (T['d'][0] extends string ? T['d'][0] : never);
+
+type GetConstructorsByScope<T, S> = ConstructorUnion<FilterConstructorsByScope<OverloadedConstructorsOf<T>, S>>;
+type GetConstructors<T> = ConstructorUnion<OverloadedConstructorsOf<T>>;
+type GetPossibleScopes<T> = ExtractScopes<OverloadedConstructorsOf<T>>;
+
+export type ConvertType = (...params: unknown[]) => ShaderNodeObject<Node>;
+
+type NodeArray<T extends NodeObjectOption[]> = { [index in keyof T]: NodeObject<T[index]> };
+type NodeObjects<T> = { [key in keyof T]: T[key] extends NodeObjectOption ? NodeObject<T[key]> : T[key] };
+type ConstructedNode<T> = T extends new (...args: any[]) => infer R ? (R extends Node ? R : never) : never;
+
 const parseSwizzle = props => props.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');
 
 const shaderNodeHandler = {
@@ -113,7 +286,7 @@ const shaderNodeHandler = {
 const nodeObjectsCacheMap = new WeakMap();
 const nodeBuilderFunctionsCacheMap = new WeakMap();
 
-const ShaderNodeObject = function (obj, altType = null) {
+const ShaderNodeObject = function <T extends NodeObjectOption>(obj: T, altType: string | null = null) {
     const type = getValueType(obj);
 
     if (type === 'node') {
@@ -182,7 +355,9 @@ const ShaderNodeImmutable = function (NodeClass, ...params) {
 };
 
 class ShaderCallNodeInternal extends Node {
-    constructor(shaderNode, inputNodes) {
+    shaderNode: ShaderNodeInternal;
+
+    constructor(shaderNode: ShaderNodeInternal, inputNodes) {
         super();
 
         this.shaderNode = shaderNode;
@@ -199,7 +374,7 @@ class ShaderCallNodeInternal extends Node {
         return properties.outputNode.getNodeType(builder);
     }
 
-    call(builder) {
+    call(builder: NodeBuilder) {
         const { shaderNode, inputNodes } = this;
 
         if (shaderNode.layout) {
@@ -260,7 +435,15 @@ class ShaderCallNodeInternal extends Node {
     }
 }
 
+interface Layout {
+    name: string;
+    type: string;
+    inputs: { name: string; type: string }[];
+}
+
 class ShaderNodeInternal extends Node {
+    layout: Layout | null;
+
     constructor(jsFunc) {
         super();
 
@@ -274,7 +457,7 @@ class ShaderNodeInternal extends Node {
         return /^\((\s+)?\[/.test(this.jsFunc.toString());
     }
 
-    setLayout(layout) {
+    setLayout(layout: Layout | null) {
         this.layout = layout;
 
         return this;
@@ -291,6 +474,8 @@ class ShaderNodeInternal extends Node {
     }
 }
 
+export type { ShaderNodeInternal };
+
 const bools = [false, true];
 const uints = [0, 1, 2, 3];
 const ints = [-1, -2];
@@ -384,10 +569,27 @@ export function ShaderNode(jsFunc) {
     return new Proxy(new ShaderNodeInternal(jsFunc), shaderNodeHandler);
 }
 
-export const nodeObject = (val, altType = null) => /* new */ ShaderNodeObject(val, altType);
+export const nodeObject = <T extends NodeObjectOption>(val: T, altType: string | null = null): NodeObject<T> =>
+    /* new */ ShaderNodeObject(val, altType);
 export const nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);
 export const nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
-export const nodeProxy = (...params) => new ShaderNodeProxy(...params);
+
+interface NodeProxy {
+    <T>(nodeClass: T): (...params: ProxiedTuple<GetConstructors<T>>) => ShaderNodeObject<ConstructedNode<T>>;
+    <T, S extends GetPossibleScopes<T>>(
+        nodeClass: T,
+        scope: S,
+    ): (...params: ProxiedTuple<RemoveTail<GetConstructorsByScope<T, S>>>) => ShaderNodeObject<ConstructedNode<T>>;
+    <T, S extends GetPossibleScopes<T>>(
+        nodeClass: T,
+        scope: S,
+        factor: NodeObjectOption,
+    ): (
+        ...params: ProxiedTuple<RemoveHeadAndTail<GetConstructorsByScope<T, S>>>
+    ) => ShaderNodeObject<ConstructedNode<T>>;
+}
+
+export const nodeProxy: NodeProxy = (...params) => new ShaderNodeProxy(...params);
 export const nodeImmutable = (...params) => new ShaderNodeImmutable(...params);
 
 export const tslFn = jsFunc => {
diff --git a/examples-jsm/examples/renderers/common/Animation.ts b/examples-jsm/examples/renderers/common/Animation.ts
index 0b00319a..c190633b 100644
--- a/examples-jsm/examples/renderers/common/Animation.ts
+++ b/examples-jsm/examples/renderers/common/Animation.ts
@@ -1,5 +1,14 @@
+import Nodes from './nodes/Nodes.js';
+import Info from './Info.js';
+
 class Animation {
-    constructor(nodes, info) {
+    nodes: Nodes;
+    info: Info;
+
+    animationLoop: ((time: DOMHighResTimeStamp, frame?: XRFrame) => void) | null;
+    requestId: number | null;
+
+    constructor(nodes: Nodes, info: Info) {
         this.nodes = nodes;
         this.info = info;
 
@@ -10,7 +19,7 @@ class Animation {
     }
 
     _init() {
-        const update = (time, frame) => {
+        const update = (time?: DOMHighResTimeStamp, frame?: XRFrame) => {
             this.requestId = self.requestAnimationFrame(update);
 
             if (this.info.autoReset === true) this.info.reset();
@@ -19,18 +28,18 @@ class Animation {
 
             this.info.frame = this.nodes.nodeFrame.frameId;
 
-            if (this.animationLoop !== null) this.animationLoop(time, frame);
+            if (this.animationLoop !== null) this.animationLoop(time!, frame);
         };
 
         update();
     }
 
     dispose() {
-        self.cancelAnimationFrame(this.requestId);
+        self.cancelAnimationFrame(this.requestId!);
         this.requestId = null;
     }
 
-    setAnimationLoop(callback) {
+    setAnimationLoop(callback: ((time: DOMHighResTimeStamp, frame?: XRFrame) => void) | null) {
         this.animationLoop = callback;
     }
 }
diff --git a/examples-jsm/examples/renderers/common/Attributes.ts b/examples-jsm/examples/renderers/common/Attributes.ts
index 29553540..a17571cb 100644
--- a/examples-jsm/examples/renderers/common/Attributes.ts
+++ b/examples-jsm/examples/renderers/common/Attributes.ts
@@ -1,15 +1,22 @@
 import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
-import { DynamicDrawUsage } from 'three';
+import { BufferAttribute, DynamicDrawUsage, InterleavedBuffer, InterleavedBufferAttribute } from 'three';
+import Backend from './Backend.js';
 
-class Attributes extends DataMap {
-    constructor(backend) {
+interface Data {
+    version?: number | undefined;
+}
+
+class Attributes extends DataMap<{ attribute: { key: BufferAttribute | InterleavedBufferAttribute; value: Data } }> {
+    backend: Backend;
+
+    constructor(backend: Backend) {
         super();
 
         this.backend = backend;
     }
 
-    delete(attribute) {
+    delete(attribute: BufferAttribute | InterleavedBufferAttribute) {
         const attributeData = super.delete(attribute);
 
         if (attributeData !== undefined) {
@@ -19,7 +26,7 @@ class Attributes extends DataMap {
         return attributeData;
     }
 
-    update(attribute, type) {
+    update(attribute: BufferAttribute | InterleavedBufferAttribute, type: AttributeType) {
         const data = this.get(attribute);
 
         if (data.version === undefined) {
@@ -43,10 +50,11 @@ class Attributes extends DataMap {
         }
     }
 
-    _getBufferAttribute(attribute) {
-        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
+    _getBufferAttribute(attribute: BufferAttribute | InterleavedBufferAttribute) {
+        if ((attribute as InterleavedBufferAttribute).isInterleavedBufferAttribute)
+            (attribute as BufferAttribute | InterleavedBuffer) = (attribute as InterleavedBufferAttribute).data;
 
-        return attribute;
+        return attribute as BufferAttribute | InterleavedBuffer;
     }
 }
 
diff --git a/examples-jsm/examples/renderers/common/Backend.ts b/examples-jsm/examples/renderers/common/Backend.ts
index efa5649d..241496ec 100644
--- a/examples-jsm/examples/renderers/common/Backend.ts
+++ b/examples-jsm/examples/renderers/common/Backend.ts
@@ -1,22 +1,75 @@
-let vector2 = null;
-let vector4 = null;
-let color4 = null;
-
 import Color4 from './Color4.js';
-import { Vector2, Vector4, REVISION, createCanvasElement } from 'three';
+import {
+    Vector2,
+    Vector4,
+    REVISION,
+    createCanvasElement,
+    CoordinateSystem,
+    BufferAttribute,
+    Object3D,
+    Scene,
+    Texture,
+    TypedArray,
+} from 'three';
+import Renderer from './Renderer.js';
+import RenderContext from './RenderContext.js';
+import RenderBundle from './RenderBundle.js';
+import RenderObject from './RenderObject.js';
+import NodeBuilder from '../../nodes/core/NodeBuilder.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+
+let vector2: Vector2 | null = null;
+let vector4: Vector4 | null = null;
+let color4: Color4 | null = null;
+
+export interface BackendParameters {
+    canvas?: HTMLCanvasElement | undefined;
+    antialias?: boolean;
+}
+
+interface RenderContextData {
+    renderObjects?: RenderObject[];
+}
+
+interface RenderBundleData {
+    renderContexts?: Set<RenderContext>;
+}
+
+interface RenderObjectData {}
 
-class Backend {
-    constructor(parameters = {}) {
+interface TextureData {}
+
+abstract class Backend {
+    parameters: BackendParameters;
+    data: WeakMap<
+        RenderContext | RenderBundle | RenderObject | Texture,
+        RenderContextData | RenderBundleData | RenderObjectData | TextureData
+    >;
+    renderer: Renderer | null;
+    domElement: HTMLCanvasElement | null;
+
+    constructor(parameters: BackendParameters = {}) {
         this.parameters = Object.assign({}, parameters);
-        this.data = new WeakMap();
+        this.data = new WeakMap<
+            RenderContext | RenderBundle | RenderObject | Texture,
+            RenderContextData | RenderBundleData | RenderObjectData | TextureData
+        >();
         this.renderer = null;
         this.domElement = null;
     }
 
-    async init(renderer) {
+    async init(renderer: Renderer) {
         this.renderer = renderer;
     }
 
+    abstract get coordinateSystem(): CoordinateSystem;
+
+    abstract getArrayBufferAsync(attribute: BufferAttribute): Promise<ArrayBuffer>;
+
+    abstract isOccluded(renderContext: RenderContext, object: Object): boolean;
+
+    abstract getMaxAnisotropy(): number;
+
     // render context
 
     begin(renderContext) {}
@@ -53,7 +106,11 @@ class Backend {
 
     // node builder
 
-    createNodeBuilder(renderObject) {} // return NodeBuilder (ADD IT)
+    abstract createNodeBuilder(
+        renderObject: Object3D | ComputeNode,
+        renderer: Renderer,
+        scene?: Scene | null,
+    ): NodeBuilder; // return NodeBuilder (ADD IT)
 
     // textures
 
@@ -63,7 +120,13 @@ class Backend {
 
     createTexture(texture) {}
 
-    copyTextureToBuffer(texture, x, y, width, height) {}
+    abstract copyTextureToBuffer(
+        texture: Texture,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+    ): Promise<TypedArray>;
 
     // attributes
 
@@ -142,7 +205,11 @@ class Backend {
         this.data.set(object, value);
     }
 
-    get(object) {
+    get(object: RenderContext): RenderContextData;
+    get(object: RenderBundle): RenderBundleData;
+    get(object: RenderObject): RenderObjectData;
+    get(object: Texture): TextureData;
+    get(object: RenderContext | RenderBundle | RenderObject | Texture) {
         let map = this.data.get(object);
 
         if (map === undefined) {
@@ -153,11 +220,11 @@ class Backend {
         return map;
     }
 
-    has(object) {
+    has(object: RenderContext) {
         return this.data.has(object);
     }
 
-    delete(object) {
+    delete(object: RenderContext) {
         this.data.delete(object);
     }
 }
diff --git a/examples-jsm/examples/renderers/common/Background.ts b/examples-jsm/examples/renderers/common/Background.ts
index b7902dd4..38e1f624 100644
--- a/examples-jsm/examples/renderers/common/Background.ts
+++ b/examples-jsm/examples/renderers/common/Background.ts
@@ -1,6 +1,6 @@
 import DataMap from './DataMap.js';
 import Color4 from './Color4.js';
-import { Mesh, SphereGeometry, BackSide, LinearSRGBColorSpace } from 'three';
+import { Mesh, SphereGeometry, BackSide, LinearSRGBColorSpace, Scene } from 'three';
 import {
     vec4,
     context,
@@ -10,18 +10,32 @@ import {
     NodeMaterial,
     modelViewProjection,
 } from '../../nodes/Nodes.js';
+import Renderer from './Renderer.js';
+import Nodes from './nodes/Nodes.js';
+import RenderList from './RenderList.js';
+import RenderContext from './RenderContext.js';
 
 const _clearColor = new Color4();
 
-class Background extends DataMap {
-    constructor(renderer, nodes) {
+interface SceneData {
+    backgroundMesh?: Mesh;
+    // TODO
+    // backgroundMeshNode?: Node;
+    backgroundCacheKey: string;
+}
+
+class Background extends DataMap<{ scene: { key: Scene; value: SceneData } }> {
+    renderer: Renderer;
+    nodes: Nodes;
+
+    constructor(renderer: Renderer, nodes: Nodes) {
         super();
 
         this.renderer = renderer;
         this.nodes = nodes;
     }
 
-    update(scene, renderList, renderContext) {
+    update(scene: Scene, renderList: RenderList, renderContext: RenderContext) {
         const renderer = this.renderer;
         const background = this.nodes.getBackgroundNode(scene) || scene.background;
 
diff --git a/examples-jsm/examples/renderers/common/BindGroup.ts b/examples-jsm/examples/renderers/common/BindGroup.ts
index 6b7ffa21..7f344306 100644
--- a/examples-jsm/examples/renderers/common/BindGroup.ts
+++ b/examples-jsm/examples/renderers/common/BindGroup.ts
@@ -1,7 +1,15 @@
+import NodeUniformsGroup from './nodes/NodeUniformsGroup.js';
+import Binding from './Binding.js';
+
 let _id = 0;
 
 class BindGroup {
-    constructor(name = '', bindings = []) {
+    name: string;
+    bindings: NodeUniformsGroup[] | Binding[];
+
+    id: number;
+
+    constructor(name = '', bindings: NodeUniformsGroup[] = []) {
         this.name = name;
         this.bindings = bindings;
 
diff --git a/examples-jsm/examples/renderers/common/Binding.ts b/examples-jsm/examples/renderers/common/Binding.ts
index a12f3563..e7ae8d1c 100644
--- a/examples-jsm/examples/renderers/common/Binding.ts
+++ b/examples-jsm/examples/renderers/common/Binding.ts
@@ -1,16 +1,20 @@
 class Binding {
+    name: string;
+
+    visibility: number;
+
     constructor(name = '') {
         this.name = name;
 
         this.visibility = 0;
     }
 
-    setVisibility(visibility) {
+    setVisibility(visibility: number) {
         this.visibility |= visibility;
     }
 
     clone() {
-        return Object.assign(new this.constructor(), this);
+        return Object.assign(new (this.constructor as typeof Binding)(), this);
     }
 }
 
diff --git a/examples-jsm/examples/renderers/common/Bindings.ts b/examples-jsm/examples/renderers/common/Bindings.ts
index 51aa31f0..a300e5f6 100644
--- a/examples-jsm/examples/renderers/common/Bindings.ts
+++ b/examples-jsm/examples/renderers/common/Bindings.ts
@@ -1,8 +1,42 @@
 import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
+import Backend from './Backend.js';
+import Nodes from './nodes/Nodes.js';
+import Textures from './Textures.js';
+import Attributes from './Attributes.js';
+import Pipelines from './Pipelines.js';
+import Info from './Info.js';
+import RenderObject from './RenderObject.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import { SampledTexture } from './SampledTexture.js';
+import StorageBuffer from './StorageBuffer.js';
+import NodeUniformsGroup from './nodes/NodeUniformsGroup.js';
+import UniformBuffer from './UniformBuffer.js';
+import Sampler from './Sampler.js';
+import BindGroup from './BindGroup.js';
+
+interface BindGroupData {
+    bindGroup?: BindGroup | undefined;
+}
 
-class Bindings extends DataMap {
-    constructor(backend, nodes, textures, attributes, pipelines, info) {
+class Bindings extends DataMap<{
+    bindGroup: { key: BindGroup; value: BindGroupData };
+}> {
+    backend: Backend;
+    textures: Textures;
+    pipelines: Pipelines;
+    attributes: Attributes;
+    nodes: Nodes;
+    info: Info;
+
+    constructor(
+        backend: Backend,
+        nodes: Nodes,
+        textures: Textures,
+        attributes: Attributes,
+        pipelines: Pipelines,
+        info: Info,
+    ) {
         super();
 
         this.backend = backend;
@@ -15,7 +49,7 @@ class Bindings extends DataMap {
         this.pipelines.bindings = this; // assign bindings to pipelines
     }
 
-    getForRender(renderObject) {
+    getForRender(renderObject: RenderObject) {
         const bindings = renderObject.getBindings();
 
         for (const bindGroup of bindings) {
@@ -35,7 +69,7 @@ class Bindings extends DataMap {
         return bindings;
     }
 
-    getForCompute(computeNode) {
+    getForCompute(computeNode: ComputeNode) {
         const bindings = this.nodes.getForCompute(computeNode).bindings;
 
         for (const bindGroup of bindings) {
@@ -53,33 +87,33 @@ class Bindings extends DataMap {
         return bindings;
     }
 
-    updateForCompute(computeNode) {
+    updateForCompute(computeNode: ComputeNode) {
         this._updateBindings(computeNode, this.getForCompute(computeNode));
     }
 
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         this._updateBindings(renderObject, this.getForRender(renderObject));
     }
 
-    _updateBindings(object, bindings) {
+    _updateBindings(object: ComputeNode | RenderObject, bindings: BindGroup[]) {
         for (const bindGroup of bindings) {
             this._update(object, bindGroup, bindings);
         }
     }
 
-    _init(bindGroup) {
+    _init(bindGroup: BindGroup) {
         for (const binding of bindGroup.bindings) {
-            if (binding.isSampledTexture) {
-                this.textures.updateTexture(binding.texture);
-            } else if (binding.isStorageBuffer) {
-                const attribute = binding.attribute;
+            if ((binding as SampledTexture).isSampledTexture) {
+                this.textures.updateTexture((binding as SampledTexture).texture);
+            } else if ((binding as StorageBuffer).isStorageBuffer) {
+                const attribute = (binding as StorageBuffer).attribute;
 
                 this.attributes.update(attribute, AttributeType.STORAGE);
             }
         }
     }
 
-    _update(object, bindGroup, bindings) {
+    _update(object: ComputeNode | RenderObject, bindGroup: BindGroup, bindings: BindGroup[]) {
         const { backend } = this;
 
         let needsBindingsUpdate = false;
@@ -87,32 +121,32 @@ class Bindings extends DataMap {
         // iterate over all bindings and check if buffer updates or a new binding group is required
 
         for (const binding of bindGroup.bindings) {
-            if (binding.isNodeUniformsGroup) {
-                const updated = this.nodes.updateGroup(binding);
+            if ((binding as NodeUniformsGroup).isNodeUniformsGroup) {
+                const updated = this.nodes.updateGroup(binding as NodeUniformsGroup);
 
                 if (!updated) continue;
             }
 
-            if (binding.isUniformBuffer) {
-                const updated = binding.update();
+            if ((binding as UniformBuffer).isUniformBuffer) {
+                const updated = (binding as UniformBuffer).update();
 
                 if (updated) {
-                    backend.updateBinding(binding);
+                    backend.updateBinding(binding as UniformBuffer);
                 }
-            } else if (binding.isSampler) {
-                binding.update();
-            } else if (binding.isSampledTexture) {
-                const texture = binding.texture;
+            } else if ((binding as Sampler).isSampler) {
+                (binding as Sampler).update();
+            } else if ((binding as SampledTexture).isSampledTexture) {
+                const texture = (binding as SampledTexture).texture;
 
-                if (binding.needsBindingsUpdate) needsBindingsUpdate = true;
+                if ((binding as SampledTexture).needsBindingsUpdate) needsBindingsUpdate = true;
 
-                const updated = binding.update();
+                const updated = (binding as SampledTexture).update();
 
                 if (updated) {
-                    this.textures.updateTexture(binding.texture);
+                    this.textures.updateTexture((binding as SampledTexture).texture);
                 }
 
-                const textureData = backend.get(binding.texture);
+                const textureData = backend.get((binding as SampledTexture).texture);
 
                 if (
                     backend.isWebGPUBackend === true &&
@@ -124,18 +158,18 @@ class Bindings extends DataMap {
                         'Bindings._update: binding should be available:',
                         binding,
                         updated,
-                        binding.texture,
-                        binding.textureNode.value,
+                        (binding as SampledTexture).texture,
+                        (binding as SampledTexture).textureNode.value,
                     );
 
-                    this.textures.updateTexture(binding.texture);
+                    this.textures.updateTexture((binding as SampledTexture).texture);
                     needsBindingsUpdate = true;
                 }
 
                 if (texture.isStorageTexture === true) {
                     const textureData = this.get(texture);
 
-                    if (binding.store === true) {
+                    if ((binding as SampledTexture).store === true) {
                         textureData.needsMipmap = true;
                     } else if (
                         texture.generateMipmaps === true &&
diff --git a/examples-jsm/examples/renderers/common/Buffer.ts b/examples-jsm/examples/renderers/common/Buffer.ts
index 17013c6d..830dc0a8 100644
--- a/examples-jsm/examples/renderers/common/Buffer.ts
+++ b/examples-jsm/examples/renderers/common/Buffer.ts
@@ -2,7 +2,13 @@ import Binding from './Binding.js';
 import { getFloatLength } from './BufferUtils.js';
 
 class Buffer extends Binding {
-    constructor(name, buffer = null) {
+    readonly isBuffer: true;
+
+    bytesPerElement: number;
+
+    _buffer: Float32Array | null;
+
+    constructor(name?: string, buffer: Float32Array | null = null) {
         super(name);
 
         this.isBuffer = true;
@@ -13,7 +19,7 @@ class Buffer extends Binding {
     }
 
     get byteLength() {
-        return getFloatLength(this._buffer.byteLength);
+        return getFloatLength(this._buffer!.byteLength);
     }
 
     get buffer() {
diff --git a/examples-jsm/examples/renderers/common/BufferUtils.ts b/examples-jsm/examples/renderers/common/BufferUtils.ts
index 99ddcb48..e18679b1 100644
--- a/examples-jsm/examples/renderers/common/BufferUtils.ts
+++ b/examples-jsm/examples/renderers/common/BufferUtils.ts
@@ -1,12 +1,12 @@
 import { GPU_CHUNK_BYTES } from './Constants.js';
 
-function getFloatLength(floatLength) {
+function getFloatLength(floatLength: number) {
     // ensure chunk size alignment (STD140 layout)
 
     return floatLength + ((GPU_CHUNK_BYTES - (floatLength % GPU_CHUNK_BYTES)) % GPU_CHUNK_BYTES);
 }
 
-function getVectorLength(count, vectorLength = 4) {
+function getVectorLength(count: number, vectorLength = 4) {
     const strideLength = getStrideLength(vectorLength);
 
     const floatLength = strideLength * count;
@@ -14,7 +14,7 @@ function getVectorLength(count, vectorLength = 4) {
     return getFloatLength(floatLength);
 }
 
-function getStrideLength(vectorLength) {
+function getStrideLength(vectorLength: number) {
     const strideLength = 4;
 
     return vectorLength + ((strideLength - (vectorLength % strideLength)) % strideLength);
diff --git a/examples-jsm/examples/renderers/common/ChainMap.ts b/examples-jsm/examples/renderers/common/ChainMap.ts
index b17e7080..e2b545b7 100644
--- a/examples-jsm/examples/renderers/common/ChainMap.ts
+++ b/examples-jsm/examples/renderers/common/ChainMap.ts
@@ -1,39 +1,43 @@
-export default class ChainMap {
+type RecursiveWeakMap<K extends readonly object[], V> = WeakMap<K[number], V | RecursiveWeakMap<K, V>>;
+
+export default class ChainMap<K extends readonly object[], V> {
+    weakMap: RecursiveWeakMap<K, V>;
+
     constructor() {
-        this.weakMap = new WeakMap();
+        this.weakMap = new WeakMap<K[number], V | RecursiveWeakMap<K, V>>();
     }
 
-    get(keys) {
-        let map = this.weakMap;
+    get(keys: K): V | undefined {
+        let map: RecursiveWeakMap<K, V> | undefined = this.weakMap;
 
         for (let i = 0; i < keys.length; i++) {
-            map = map.get(keys[i]);
+            map = map.get(keys[i]) as RecursiveWeakMap<K, V> | undefined;
 
             if (map === undefined) return undefined;
         }
 
-        return map.get(keys[keys.length - 1]);
+        return map.get(keys[keys.length - 1]) as V | undefined;
     }
 
-    set(keys, value) {
-        let map = this.weakMap;
+    set(keys: K, value: V) {
+        let map: RecursiveWeakMap<K, V> = this.weakMap;
 
         for (let i = 0; i < keys.length; i++) {
             const key = keys[i];
 
-            if (map.has(key) === false) map.set(key, new WeakMap());
+            if (map.has(key) === false) map.set(key, new WeakMap<K[number], V | RecursiveWeakMap<K, V>>());
 
-            map = map.get(key);
+            map = map.get(key) as RecursiveWeakMap<K, V>;
         }
 
-        return map.set(keys[keys.length - 1], value);
+        return map.set(keys[keys.length - 1], value) as V;
     }
 
-    delete(keys) {
-        let map = this.weakMap;
+    delete(keys: K) {
+        let map: RecursiveWeakMap<K, V> | undefined = this.weakMap;
 
         for (let i = 0; i < keys.length; i++) {
-            map = map.get(keys[i]);
+            map = map.get(keys[i]) as RecursiveWeakMap<K, V> | undefined;
 
             if (map === undefined) return false;
         }
diff --git a/examples-jsm/examples/renderers/common/ClippingContext.ts b/examples-jsm/examples/renderers/common/ClippingContext.ts
index 312e0b77..67dd83d8 100644
--- a/examples-jsm/examples/renderers/common/ClippingContext.ts
+++ b/examples-jsm/examples/renderers/common/ClippingContext.ts
@@ -1,10 +1,26 @@
-import { Matrix3, Plane, Vector4 } from 'three';
+import { Camera, Material, Matrix3, Matrix4, Plane, Vector4 } from 'three';
+import Renderer from './Renderer.js';
 
 const _plane = new Plane();
 
 let _clippingContextVersion = 0;
 
 class ClippingContext {
+    version: number;
+
+    globalClippingCount: number;
+
+    localClippingCount: number;
+    localClippingEnabled: boolean | undefined;
+    localClipIntersection: boolean;
+
+    planes: Vector4[];
+
+    parentVersion: number;
+    viewNormalMatrix: Matrix3;
+
+    viewMatrix?: Matrix4 | undefined;
+
     constructor() {
         this.version = ++_clippingContextVersion;
 
@@ -20,12 +36,12 @@ class ClippingContext {
         this.viewNormalMatrix = new Matrix3();
     }
 
-    projectPlanes(source, offset) {
+    projectPlanes(source: readonly Plane[], offset: number) {
         const l = source.length;
         const planes = this.planes;
 
         for (let i = 0; i < l; i++) {
-            _plane.copy(source[i]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
+            _plane.copy(source[i]).applyMatrix4(this.viewMatrix!, this.viewNormalMatrix);
 
             const v = planes[offset + i];
             const normal = _plane.normal;
@@ -37,7 +53,7 @@ class ClippingContext {
         }
     }
 
-    updateGlobal(renderer, camera) {
+    updateGlobal(renderer: Renderer, camera: Camera) {
         const rendererClippingPlanes = renderer.clippingPlanes;
         this.viewMatrix = camera.matrixWorldInverse;
 
@@ -76,7 +92,7 @@ class ClippingContext {
         if (update) this.version = _clippingContextVersion++;
     }
 
-    update(parent, material) {
+    update(parent: ClippingContext, material: Material) {
         let update = false;
 
         if (this !== parent && parent.version !== this.parentVersion) {
diff --git a/examples-jsm/examples/renderers/common/Color4.ts b/examples-jsm/examples/renderers/common/Color4.ts
index c681cc90..5d03adec 100644
--- a/examples-jsm/examples/renderers/common/Color4.ts
+++ b/examples-jsm/examples/renderers/common/Color4.ts
@@ -1,26 +1,31 @@
-import { Color } from 'three';
+import { Color, ColorRepresentation } from 'three';
 
 class Color4 extends Color {
-    constructor(r, g, b, a = 1) {
-        super(r, g, b);
+    a: number;
+
+    constructor(color?: ColorRepresentation);
+    constructor(r: number, g: number, b: number, a?: number);
+    constructor(r?: number, g?: number, b?: number, a = 1) {
+        super(r as number, g!, b!);
 
         this.a = a;
     }
 
-    set(r, g, b, a = 1) {
+    set(...args: [color: ColorRepresentation] | [r: number, g: number, b: number, a?: number]): this;
+    set(r: number, g: number, b: number, a = 1) {
         this.a = a;
 
         return super.set(r, g, b);
     }
 
-    copy(color) {
-        if (color.a !== undefined) this.a = color.a;
+    copy(color: Color) {
+        if ((color as Color4).a !== undefined) this.a = (color as Color4).a;
 
         return super.copy(color);
     }
 
-    clone() {
-        return new this.constructor(this.r, this.g, this.b, this.a);
+    clone(): this {
+        return new (this.constructor as typeof Color4)(this.r, this.g, this.b, this.a) as this;
     }
 }
 
diff --git a/examples-jsm/examples/renderers/common/ComputePipeline.ts b/examples-jsm/examples/renderers/common/ComputePipeline.ts
index 0fd3ca53..f6112ccf 100644
--- a/examples-jsm/examples/renderers/common/ComputePipeline.ts
+++ b/examples-jsm/examples/renderers/common/ComputePipeline.ts
@@ -1,7 +1,12 @@
 import Pipeline from './Pipeline.js';
+import ProgrammableStage from './ProgrammableStage.js';
 
 class ComputePipeline extends Pipeline {
-    constructor(cacheKey, computeProgram) {
+    computeProgram: ProgrammableStage;
+
+    readonly isComputePipeline: true;
+
+    constructor(cacheKey: string, computeProgram: ProgrammableStage) {
         super(cacheKey);
 
         this.computeProgram = computeProgram;
diff --git a/examples-jsm/examples/renderers/common/Constants.ts b/examples-jsm/examples/renderers/common/Constants.ts
index 0d0c35a2..f5a186e1 100644
--- a/examples-jsm/examples/renderers/common/Constants.ts
+++ b/examples-jsm/examples/renderers/common/Constants.ts
@@ -2,7 +2,9 @@ export const AttributeType = {
     VERTEX: 1,
     INDEX: 2,
     STORAGE: 4,
-};
+} as const;
+
+export type AttributeType = (typeof AttributeType)[keyof typeof AttributeType];
 
 // size of a chunk in bytes (STD140 layout)
 
diff --git a/examples-jsm/examples/renderers/common/CubeRenderTarget.ts b/examples-jsm/examples/renderers/common/CubeRenderTarget.ts
index 74d04912..9b6b716a 100644
--- a/examples-jsm/examples/renderers/common/CubeRenderTarget.ts
+++ b/examples-jsm/examples/renderers/common/CubeRenderTarget.ts
@@ -8,6 +8,9 @@ import {
     NoBlending,
     LinearFilter,
     LinearMipmapLinearFilter,
+    RenderTargetOptions,
+    WebGLRenderer,
+    Texture,
 } from 'three';
 import { equirectUV } from '../../nodes/utils/EquirectUVNode.js';
 import { texture as TSL_Texture } from '../../nodes/accessors/TextureNode.js';
@@ -17,13 +20,15 @@ import { createNodeMaterialFromType } from '../../nodes/materials/NodeMaterial.j
 // @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget
 
 class CubeRenderTarget extends WebGLCubeRenderTarget {
-    constructor(size = 1, options = {}) {
+    readonly isCubeRenderTarget: true;
+
+    constructor(size = 1, options: RenderTargetOptions = {}) {
         super(size, options);
 
         this.isCubeRenderTarget = true;
     }
 
-    fromEquirectangularTexture(renderer, texture) {
+    fromEquirectangularTexture(renderer: WebGLRenderer, texture: Texture) {
         const currentMinFilter = texture.minFilter;
         const currentGenerateMipmaps = texture.generateMipmaps;
 
diff --git a/examples-jsm/examples/renderers/common/DataMap.ts b/examples-jsm/examples/renderers/common/DataMap.ts
index 006bc295..eb39fca8 100644
--- a/examples-jsm/examples/renderers/common/DataMap.ts
+++ b/examples-jsm/examples/renderers/common/DataMap.ts
@@ -1,9 +1,11 @@
-class DataMap {
+class DataMap<M extends { [key: string]: { key: object; value: unknown } }> {
+    data: WeakMap<M[keyof M]['key'], M[keyof M]['value']>;
+
     constructor() {
-        this.data = new WeakMap();
+        this.data = new WeakMap<M[keyof M]['key'], M[keyof M]['value']>();
     }
 
-    get(object) {
+    get<K extends M[keyof M]['key']>(object: K): Extract<M[keyof M], { key: K }>['value'] {
         let map = this.data.get(object);
 
         if (map === undefined) {
@@ -14,7 +16,7 @@ class DataMap {
         return map;
     }
 
-    delete(object) {
+    delete<K extends M[keyof M]['key']>(object: K): Extract<M[keyof M], { key: K }>['value'] {
         let map;
 
         if (this.data.has(object)) {
@@ -26,7 +28,7 @@ class DataMap {
         return map;
     }
 
-    has(object) {
+    has(object: M[keyof M]['key']) {
         return this.data.has(object);
     }
 
diff --git a/examples-jsm/examples/renderers/common/Geometries.ts b/examples-jsm/examples/renderers/common/Geometries.ts
index ca0cd225..043f878e 100644
--- a/examples-jsm/examples/renderers/common/Geometries.ts
+++ b/examples-jsm/examples/renderers/common/Geometries.ts
@@ -1,8 +1,18 @@
 import DataMap from './DataMap.js';
 import { AttributeType } from './Constants.js';
-import { Uint32BufferAttribute, Uint16BufferAttribute } from 'three';
-
-function arrayNeedsUint32(array) {
+import {
+    Uint32BufferAttribute,
+    Uint16BufferAttribute,
+    BufferGeometry,
+    BufferAttribute,
+    InterleavedBufferAttribute,
+    InterleavedBuffer,
+} from 'three';
+import Attributes from './Attributes.js';
+import Info from './Info.js';
+import RenderObject from './RenderObject.js';
+
+function arrayNeedsUint32(array: number[]) {
     // assumes larger values usually on last
 
     for (let i = array.length - 1; i >= 0; --i) {
@@ -12,11 +22,11 @@ function arrayNeedsUint32(array) {
     return false;
 }
 
-function getWireframeVersion(geometry) {
-    return geometry.index !== null ? geometry.index.version : geometry.attributes.position.version;
+function getWireframeVersion(geometry: BufferGeometry) {
+    return geometry.index !== null ? geometry.index.version : (geometry.attributes.position as BufferAttribute).version;
 }
 
-function getWireframeIndex(geometry) {
+function getWireframeIndex(geometry: BufferGeometry) {
     const indices = [];
 
     const geometryIndex = geometry.index;
@@ -50,31 +60,41 @@ function getWireframeIndex(geometry) {
     return attribute;
 }
 
-class Geometries extends DataMap {
-    constructor(attributes, info) {
+interface GeometryData {
+    initialized?: boolean | undefined;
+}
+
+class Geometries extends DataMap<{ geometry: { key: BufferGeometry; value: GeometryData } }> {
+    attributes: Attributes;
+    info: Info;
+
+    wireframes: WeakMap<BufferGeometry, BufferAttribute>;
+    attributeCall: WeakMap<BufferAttribute | InterleavedBufferAttribute | InterleavedBuffer, number>;
+
+    constructor(attributes: Attributes, info: Info) {
         super();
 
         this.attributes = attributes;
         this.info = info;
 
-        this.wireframes = new WeakMap();
+        this.wireframes = new WeakMap<BufferGeometry, BufferAttribute>();
 
-        this.attributeCall = new WeakMap();
+        this.attributeCall = new WeakMap<BufferAttribute | InterleavedBufferAttribute, number>();
     }
 
-    has(renderObject) {
-        const geometry = renderObject.geometry;
+    has(renderObject: RenderObject | BufferGeometry) {
+        const geometry = (renderObject as RenderObject).geometry;
 
         return super.has(geometry) && this.get(geometry).initialized === true;
     }
 
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         if (this.has(renderObject) === false) this.initGeometry(renderObject);
 
         this.updateAttributes(renderObject);
     }
 
-    initGeometry(renderObject) {
+    initGeometry(renderObject: RenderObject) {
         const geometry = renderObject.geometry;
         const geometryData = this.get(geometry);
 
@@ -108,7 +128,7 @@ class Geometries extends DataMap {
         geometry.addEventListener('dispose', onDispose);
     }
 
-    updateAttributes(renderObject) {
+    updateAttributes(renderObject: RenderObject) {
         const attributes = renderObject.getAttributes();
 
         for (const attribute of attributes) {
@@ -126,10 +146,10 @@ class Geometries extends DataMap {
         }
     }
 
-    updateAttribute(attribute, type) {
+    updateAttribute(attribute: BufferAttribute | InterleavedBufferAttribute, type: AttributeType) {
         const callId = this.info.render.calls;
 
-        if (!attribute.isInterleavedBufferAttribute) {
+        if (!(attribute as InterleavedBufferAttribute).isInterleavedBufferAttribute) {
             if (this.attributeCall.get(attribute) !== callId) {
                 this.attributes.update(attribute, type);
 
@@ -140,17 +160,17 @@ class Geometries extends DataMap {
                 this.attributes.update(attribute, type);
 
                 this.attributeCall.set(attribute, callId);
-            } else if (this.attributeCall.get(attribute.data) !== callId) {
+            } else if (this.attributeCall.get((attribute as InterleavedBufferAttribute).data) !== callId) {
                 this.attributes.update(attribute, type);
 
-                this.attributeCall.set(attribute.data, callId);
+                this.attributeCall.set((attribute as InterleavedBufferAttribute).data, callId);
 
                 this.attributeCall.set(attribute, callId);
             }
         }
     }
 
-    getIndex(renderObject) {
+    getIndex(renderObject: RenderObject) {
         const { geometry, material } = renderObject;
 
         let index = geometry.index;
diff --git a/examples-jsm/examples/renderers/common/Info.ts b/examples-jsm/examples/renderers/common/Info.ts
index 4ede75de..af361ff1 100644
--- a/examples-jsm/examples/renderers/common/Info.ts
+++ b/examples-jsm/examples/renderers/common/Info.ts
@@ -1,4 +1,36 @@
+import { Line, LineSegments, Mesh, Object3D, Points, Sprite } from 'three';
+
 class Info {
+    autoReset: boolean;
+
+    frame: number;
+    calls: number;
+
+    render: {
+        calls: number;
+        frameCalls: number;
+        drawCalls: number;
+        triangles: number;
+        points: number;
+        lines: number;
+        timestamp: number;
+        previousFrameCalls: number;
+        timestampCalls: number;
+    };
+
+    compute: {
+        calls: number;
+        frameCalls: number;
+        timestamp: number;
+        previousFrameCalls: number;
+        timestampCalls: number;
+    };
+
+    memory: {
+        geometries: number;
+        textures: number;
+    };
+
     constructor() {
         this.autoReset = true;
 
@@ -31,23 +63,23 @@ class Info {
         };
     }
 
-    update(object, count, instanceCount) {
+    update(object: Object3D, count: number, instanceCount: number) {
         this.render.drawCalls++;
 
-        if (object.isMesh || object.isSprite) {
+        if ((object as Mesh).isMesh || (object as Sprite).isSprite) {
             this.render.triangles += instanceCount * (count / 3);
-        } else if (object.isPoints) {
+        } else if ((object as Points).isPoints) {
             this.render.points += instanceCount * count;
-        } else if (object.isLineSegments) {
+        } else if ((object as LineSegments).isLineSegments) {
             this.render.lines += instanceCount * (count / 2);
-        } else if (object.isLine) {
+        } else if ((object as Line).isLine) {
             this.render.lines += instanceCount * (count - 1);
         } else {
             console.error('THREE.WebGPUInfo: Unknown object type.');
         }
     }
 
-    updateTimestamp(type, time) {
+    updateTimestamp(type: 'render' | 'compute', time: number) {
         if (this[type].timestampCalls === 0) {
             this[type].timestamp = 0;
         }
diff --git a/examples-jsm/examples/renderers/common/Pipeline.ts b/examples-jsm/examples/renderers/common/Pipeline.ts
index 16017455..16b5276c 100644
--- a/examples-jsm/examples/renderers/common/Pipeline.ts
+++ b/examples-jsm/examples/renderers/common/Pipeline.ts
@@ -1,5 +1,9 @@
 class Pipeline {
-    constructor(cacheKey) {
+    cacheKey: string;
+
+    usedTimes: number;
+
+    constructor(cacheKey: string) {
         this.cacheKey = cacheKey;
 
         this.usedTimes = 0;
diff --git a/examples-jsm/examples/renderers/common/Pipelines.ts b/examples-jsm/examples/renderers/common/Pipelines.ts
index 68c8f223..104bf8c9 100644
--- a/examples-jsm/examples/renderers/common/Pipelines.ts
+++ b/examples-jsm/examples/renderers/common/Pipelines.ts
@@ -2,9 +2,40 @@ import DataMap from './DataMap.js';
 import RenderPipeline from './RenderPipeline.js';
 import ComputePipeline from './ComputePipeline.js';
 import ProgrammableStage from './ProgrammableStage.js';
+import Backend from './Backend.js';
+import Nodes from './nodes/Nodes.js';
+import Bindings from './Bindings.js';
+import RenderObject from './RenderObject.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
+import Binding from './Binding.js';
+import Pipeline from './Pipeline.js';
+
+interface ComputeNodeData {
+    version: number;
+    pipeline: ComputePipeline;
+}
+
+interface RenderObjectData {
+    pipeline: RenderPipeline;
+}
+
+class Pipelines extends DataMap<{
+    computeNode: { key: ComputeNode; value: ComputeNodeData };
+    renderObject: { key: RenderObject; value: RenderObjectData };
+}> {
+    backend: Backend;
+    nodes: Nodes;
+
+    bindings: Bindings | null;
 
-class Pipelines extends DataMap {
-    constructor(backend, nodes) {
+    caches: Map<string, Pipeline>;
+    programs: {
+        vertex: Map<string, ProgrammableStage>;
+        fragment: Map<string, ProgrammableStage>;
+        compute: Map<string, ProgrammableStage>;
+    };
+
+    constructor(backend: Backend, nodes: Nodes) {
         super();
 
         this.backend = backend;
@@ -12,15 +43,15 @@ class Pipelines extends DataMap {
 
         this.bindings = null; // set by the bindings
 
-        this.caches = new Map();
+        this.caches = new Map<string, Pipeline>();
         this.programs = {
-            vertex: new Map(),
-            fragment: new Map(),
-            compute: new Map(),
+            vertex: new Map<string, ProgrammableStage>(),
+            fragment: new Map<string, ProgrammableStage>(),
+            compute: new Map<string, ProgrammableStage>(),
         };
     }
 
-    getForCompute(computeNode, bindings) {
+    getForCompute(computeNode: ComputeNode, bindings: Binding[]) {
         const { backend } = this;
 
         const data = this.get(computeNode);
@@ -39,19 +70,19 @@ class Pipelines extends DataMap {
 
             // programmable stage
 
-            let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader);
+            let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader!);
 
             if (stageCompute === undefined) {
                 if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0)
                     this._releaseProgram(previousPipeline.computeProgram);
 
                 stageCompute = new ProgrammableStage(
-                    nodeBuilderState.computeShader,
+                    nodeBuilderState.computeShader!,
                     'compute',
                     nodeBuilderState.transforms,
                     nodeBuilderState.nodeAttributes,
                 );
-                this.programs.compute.set(nodeBuilderState.computeShader, stageCompute);
+                this.programs.compute.set(nodeBuilderState.computeShader!, stageCompute);
 
                 backend.createProgram(stageCompute);
             }
@@ -60,7 +91,7 @@ class Pipelines extends DataMap {
 
             const cacheKey = this._getComputeCacheKey(computeNode, stageCompute);
 
-            let pipeline = this.caches.get(cacheKey);
+            let pipeline = this.caches.get(cacheKey) as ComputePipeline | undefined;
 
             if (pipeline === undefined) {
                 if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
@@ -82,7 +113,7 @@ class Pipelines extends DataMap {
         return data.pipeline;
     }
 
-    getForRender(renderObject, promises = null) {
+    getForRender(renderObject: RenderObject, promises: Promise<void>[] | null = null) {
         const { backend } = this;
 
         const data = this.get(renderObject);
@@ -102,26 +133,26 @@ class Pipelines extends DataMap {
 
             // programmable stages
 
-            let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);
+            let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader!);
 
             if (stageVertex === undefined) {
                 if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0)
                     this._releaseProgram(previousPipeline.vertexProgram);
 
-                stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader, 'vertex');
-                this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);
+                stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader!, 'vertex');
+                this.programs.vertex.set(nodeBuilderState.vertexShader!, stageVertex);
 
                 backend.createProgram(stageVertex);
             }
 
-            let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader);
+            let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader!);
 
             if (stageFragment === undefined) {
                 if (previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0)
                     this._releaseProgram(previousPipeline.fragmentProgram);
 
-                stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader, 'fragment');
-                this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);
+                stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader!, 'fragment');
+                this.programs.fragment.set(nodeBuilderState.fragmentShader!, stageFragment);
 
                 backend.createProgram(stageFragment);
             }
@@ -130,7 +161,7 @@ class Pipelines extends DataMap {
 
             const cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
 
-            let pipeline = this.caches.get(cacheKey);
+            let pipeline = this.caches.get(cacheKey) as RenderPipeline | undefined;
 
             if (pipeline === undefined) {
                 if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
@@ -154,7 +185,7 @@ class Pipelines extends DataMap {
         return data.pipeline;
     }
 
-    delete(object) {
+    delete(object: ComputeNode | RenderObject): never {
         const pipeline = this.get(object).pipeline;
 
         if (pipeline) {
@@ -166,20 +197,23 @@ class Pipelines extends DataMap {
 
             // programs
 
-            if (pipeline.isComputePipeline) {
-                pipeline.computeProgram.usedTimes--;
+            if ((pipeline as ComputePipeline).isComputePipeline) {
+                (pipeline as ComputePipeline).computeProgram.usedTimes--;
 
-                if (pipeline.computeProgram.usedTimes === 0) this._releaseProgram(pipeline.computeProgram);
+                if ((pipeline as ComputePipeline).computeProgram.usedTimes === 0)
+                    this._releaseProgram((pipeline as ComputePipeline).computeProgram);
             } else {
-                pipeline.fragmentProgram.usedTimes--;
-                pipeline.vertexProgram.usedTimes--;
+                (pipeline as RenderPipeline).fragmentProgram.usedTimes--;
+                (pipeline as RenderPipeline).vertexProgram.usedTimes--;
 
-                if (pipeline.vertexProgram.usedTimes === 0) this._releaseProgram(pipeline.vertexProgram);
-                if (pipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(pipeline.fragmentProgram);
+                if ((pipeline as RenderPipeline).vertexProgram.usedTimes === 0)
+                    this._releaseProgram((pipeline as RenderPipeline).vertexProgram);
+                if ((pipeline as RenderPipeline).fragmentProgram.usedTimes === 0)
+                    this._releaseProgram((pipeline as RenderPipeline).fragmentProgram);
             }
         }
 
-        return super.delete(object);
+        return super.delete(object) as never;
     }
 
     dispose() {
@@ -193,16 +227,21 @@ class Pipelines extends DataMap {
         };
     }
 
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         this.getForRender(renderObject);
     }
 
-    _getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {
+    _getComputePipeline(
+        computeNode: ComputeNode,
+        stageCompute: ProgrammableStage,
+        cacheKey: string,
+        bindings: Binding[],
+    ) {
         // check for existing pipeline
 
         cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);
 
-        let pipeline = this.caches.get(cacheKey);
+        let pipeline = this.caches.get(cacheKey) as ComputePipeline | undefined;
 
         if (pipeline === undefined) {
             pipeline = new ComputePipeline(cacheKey, stageCompute);
@@ -215,12 +254,18 @@ class Pipelines extends DataMap {
         return pipeline;
     }
 
-    _getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises) {
+    _getRenderPipeline(
+        renderObject: RenderObject,
+        stageVertex: ProgrammableStage,
+        stageFragment: ProgrammableStage,
+        cacheKey: string,
+        promises: Promise<void>[] | null,
+    ) {
         // check for existing pipeline
 
         cacheKey = cacheKey || this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
 
-        let pipeline = this.caches.get(cacheKey);
+        let pipeline = this.caches.get(cacheKey) as RenderPipeline | undefined;
 
         if (pipeline === undefined) {
             pipeline = new RenderPipeline(cacheKey, stageVertex, stageFragment);
@@ -235,32 +280,32 @@ class Pipelines extends DataMap {
         return pipeline;
     }
 
-    _getComputeCacheKey(computeNode, stageCompute) {
+    _getComputeCacheKey(computeNode: ComputeNode, stageCompute: ProgrammableStage) {
         return computeNode.id + ',' + stageCompute.id;
     }
 
-    _getRenderCacheKey(renderObject, stageVertex, stageFragment) {
+    _getRenderCacheKey(renderObject: RenderObject, stageVertex: ProgrammableStage, stageFragment: ProgrammableStage) {
         return stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey(renderObject);
     }
 
-    _releasePipeline(pipeline) {
+    _releasePipeline(pipeline: Pipeline) {
         this.caches.delete(pipeline.cacheKey);
     }
 
-    _releaseProgram(program) {
+    _releaseProgram(program: ProgrammableStage) {
         const code = program.code;
         const stage = program.stage;
 
         this.programs[stage].delete(code);
     }
 
-    _needsComputeUpdate(computeNode) {
+    _needsComputeUpdate(computeNode: ComputeNode) {
         const data = this.get(computeNode);
 
         return data.pipeline === undefined || data.version !== computeNode.version;
     }
 
-    _needsRenderUpdate(renderObject) {
+    _needsRenderUpdate(renderObject: RenderObject) {
         const data = this.get(renderObject);
 
         return data.pipeline === undefined || this.backend.needsRenderUpdate(renderObject);
diff --git a/examples-jsm/examples/renderers/common/ProgrammableStage.ts b/examples-jsm/examples/renderers/common/ProgrammableStage.ts
index a684e444..62ebf0a0 100644
--- a/examples-jsm/examples/renderers/common/ProgrammableStage.ts
+++ b/examples-jsm/examples/renderers/common/ProgrammableStage.ts
@@ -1,7 +1,24 @@
+import NodeAttribute from '../../nodes/core/NodeAttribute.js';
+
 let _id = 0;
 
 class ProgrammableStage {
-    constructor(code, type, transforms = null, attributes = null) {
+    id: number;
+
+    code: string;
+    stage: 'compute' | 'vertex' | 'fragment';
+    // TODO
+    // transforms
+    attributes: NodeAttribute[] | null;
+
+    usedTimes: number;
+
+    constructor(
+        code: string,
+        type: 'compute' | 'vertex' | 'fragment',
+        transforms = null,
+        attributes: NodeAttribute[] | null = null,
+    ) {
         this.id = _id++;
 
         this.code = code;
diff --git a/examples-jsm/examples/renderers/common/RenderBundle.ts b/examples-jsm/examples/renderers/common/RenderBundle.ts
index e59e4937..95b0518a 100644
--- a/examples-jsm/examples/renderers/common/RenderBundle.ts
+++ b/examples-jsm/examples/renderers/common/RenderBundle.ts
@@ -1,11 +1,16 @@
+import { Camera, Object3D } from 'three';
+
 class RenderBundle {
-    constructor(scene, camera) {
+    scene: Object3D;
+    camera: Camera;
+
+    constructor(scene: Object3D, camera: Camera) {
         this.scene = scene;
         this.camera = camera;
     }
 
     clone() {
-        return Object.assign(new this.constructor(), this);
+        return Object.assign(new (this.constructor as { new (): RenderBundle })(), this);
     }
 }
 
diff --git a/examples-jsm/examples/renderers/common/RenderBundles.ts b/examples-jsm/examples/renderers/common/RenderBundles.ts
index 29140365..48f5d598 100644
--- a/examples-jsm/examples/renderers/common/RenderBundles.ts
+++ b/examples-jsm/examples/renderers/common/RenderBundles.ts
@@ -1,14 +1,17 @@
+import { Camera, Object3D } from 'three';
 import ChainMap from './ChainMap.js';
 import RenderBundle from './RenderBundle.js';
 
 class RenderBundles {
+    lists: ChainMap<readonly [Object3D, Camera], RenderBundle>;
+
     constructor() {
-        this.lists = new ChainMap();
+        this.lists = new ChainMap<readonly [Object3D, Camera], RenderBundle>();
     }
 
-    get(scene, camera) {
+    get(scene: Object3D, camera: Camera) {
         const lists = this.lists;
-        const keys = [scene, camera];
+        const keys = [scene, camera] as const;
 
         let list = lists.get(keys);
 
@@ -21,7 +24,7 @@ class RenderBundles {
     }
 
     dispose() {
-        this.lists = new ChainMap();
+        this.lists = new ChainMap<readonly [Object3D, Camera], RenderBundle>();
     }
 }
 
diff --git a/examples-jsm/examples/renderers/common/RenderContext.ts b/examples-jsm/examples/renderers/common/RenderContext.ts
index 3b43028e..c4bda4f7 100644
--- a/examples-jsm/examples/renderers/common/RenderContext.ts
+++ b/examples-jsm/examples/renderers/common/RenderContext.ts
@@ -1,8 +1,48 @@
-import { Vector4 } from 'three';
+import { DepthTexture, RenderTarget, Texture, Vector4 } from 'three';
+import ClippingContext from './ClippingContext.js';
 
 let id = 0;
 
 class RenderContext {
+    id: number;
+
+    color: boolean;
+    clearColor: boolean;
+    clearColorValue: { r: number; g: number; b: number; a: number };
+
+    depth: boolean;
+    clearDepth: boolean;
+    clearDepthValue: number;
+
+    stencil: boolean;
+    clearStencil: boolean;
+    clearStencilValue: number;
+
+    viewport: boolean;
+    viewportValue: Vector4;
+    scissor: boolean;
+    scissorValue: Vector4;
+
+    textures: Texture[] | null;
+    depthTexture: DepthTexture | null;
+    activeCubeFace: number;
+    sampleCount: number;
+
+    width: number;
+    height: number;
+
+    readonly isRenderContext: true;
+
+    clippingContext?: ClippingContext | undefined;
+
+    depthClearValue?: number | undefined;
+    stencilClearValue?: number | undefined;
+
+    renderTarget?: RenderTarget | undefined;
+
+    activeMipmapLevel?: number | undefined;
+    occlusionQueryCount?: number | undefined;
+
     constructor() {
         this.id = id++;
 
diff --git a/examples-jsm/examples/renderers/common/RenderContexts.ts b/examples-jsm/examples/renderers/common/RenderContexts.ts
index 630a2e42..9d99c98e 100644
--- a/examples-jsm/examples/renderers/common/RenderContexts.ts
+++ b/examples-jsm/examples/renderers/common/RenderContexts.ts
@@ -1,13 +1,16 @@
+import { Camera, RenderTarget, Scene } from 'three';
 import ChainMap from './ChainMap.js';
 import RenderContext from './RenderContext.js';
 
 class RenderContexts {
+    chainMaps: { [attachmentState: string]: ChainMap<readonly [Scene, Camera], RenderContext> | undefined };
+
     constructor() {
         this.chainMaps = {};
     }
 
-    get(scene, camera, renderTarget = null) {
-        const chainKey = [scene, camera];
+    get(scene: Scene, camera: Camera, renderTarget: RenderTarget | null = null) {
+        const chainKey = [scene, camera] as const;
 
         let attachmentState;
 
@@ -35,8 +38,11 @@ class RenderContexts {
         return renderState;
     }
 
-    getChainMap(attachmentState) {
-        return this.chainMaps[attachmentState] || (this.chainMaps[attachmentState] = new ChainMap());
+    getChainMap(attachmentState: string) {
+        return (
+            this.chainMaps[attachmentState] ||
+            (this.chainMaps[attachmentState] = new ChainMap<readonly [Scene, Camera], RenderContext>())
+        );
     }
 
     dispose() {
diff --git a/examples-jsm/examples/renderers/common/RenderList.ts b/examples-jsm/examples/renderers/common/RenderList.ts
index a72a91df..b72d6090 100644
--- a/examples-jsm/examples/renderers/common/RenderList.ts
+++ b/examples-jsm/examples/renderers/common/RenderList.ts
@@ -1,32 +1,62 @@
+import { BufferGeometry, Camera, GeometryGroup, Light, Material, Object3D } from 'three';
 import { LightsNode } from '../../nodes/Nodes.js';
 
-function painterSortStable(a, b) {
+function painterSortStable(a: RenderItem, b: RenderItem) {
     if (a.groupOrder !== b.groupOrder) {
-        return a.groupOrder - b.groupOrder;
+        return a.groupOrder! - b.groupOrder!;
     } else if (a.renderOrder !== b.renderOrder) {
-        return a.renderOrder - b.renderOrder;
-    } else if (a.material.id !== b.material.id) {
-        return a.material.id - b.material.id;
+        return a.renderOrder! - b.renderOrder!;
+    } else if (a.material!.id !== b.material!.id) {
+        return a.material!.id - b.material!.id;
     } else if (a.z !== b.z) {
-        return a.z - b.z;
+        return a.z! - b.z!;
     } else {
-        return a.id - b.id;
+        return a.id! - b.id!;
     }
 }
 
-function reversePainterSortStable(a, b) {
+function reversePainterSortStable(a: RenderItem, b: RenderItem) {
     if (a.groupOrder !== b.groupOrder) {
-        return a.groupOrder - b.groupOrder;
+        return a.groupOrder! - b.groupOrder!;
     } else if (a.renderOrder !== b.renderOrder) {
-        return a.renderOrder - b.renderOrder;
+        return a.renderOrder! - b.renderOrder!;
     } else if (a.z !== b.z) {
-        return b.z - a.z;
+        return b.z! - a.z!;
     } else {
-        return a.id - b.id;
+        return a.id! - b.id!;
     }
 }
 
+export interface Bundle {
+    object: Object3D;
+    camera: Camera;
+    renderList: RenderList;
+}
+
+export interface RenderItem {
+    id: number | null;
+    object: Object3D | null;
+    geometry: BufferGeometry | null;
+    material: Material | null;
+    groupOrder: number | null;
+    renderOrder: number | null;
+    z: number | null;
+    group: GeometryGroup | null;
+}
+
 class RenderList {
+    renderItems: RenderItem[];
+    renderItemsIndex: number;
+
+    opaque: RenderItem[];
+    transparent: RenderItem[];
+    bundles: Bundle[];
+
+    lightsNode: LightsNode;
+    lightsArray: Light[];
+
+    occlusionQueryCount: number;
+
     constructor() {
         this.renderItems = [];
         this.renderItemsIndex = 0;
@@ -55,7 +85,14 @@ class RenderList {
         return this;
     }
 
-    getNextRenderItem(object, geometry, material, groupOrder, z, group) {
+    getNextRenderItem(
+        object: Object3D,
+        geometry: BufferGeometry,
+        material: Material,
+        groupOrder: number,
+        z: number,
+        group: GeometryGroup | null,
+    ) {
         let renderItem = this.renderItems[this.renderItemsIndex];
 
         if (renderItem === undefined) {
@@ -87,7 +124,14 @@ class RenderList {
         return renderItem;
     }
 
-    push(object, geometry, material, groupOrder, z, group) {
+    push(
+        object: Object3D,
+        geometry: BufferGeometry,
+        material: Material,
+        groupOrder: number,
+        z: number,
+        group: GeometryGroup | null,
+    ) {
         const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group);
 
         if (object.occlusionTest === true) this.occlusionQueryCount++;
@@ -95,17 +139,24 @@ class RenderList {
         (material.transparent === true || material.transmission > 0 ? this.transparent : this.opaque).push(renderItem);
     }
 
-    unshift(object, geometry, material, groupOrder, z, group) {
+    unshift(
+        object: Object3D,
+        geometry: BufferGeometry,
+        material: Material,
+        groupOrder: number,
+        z: number,
+        group: GeometryGroup | null,
+    ) {
         const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group);
 
         (material.transparent === true ? this.transparent : this.opaque).unshift(renderItem);
     }
 
-    pushBundle(group) {
+    pushBundle(group: Bundle) {
         this.bundles.push(group);
     }
 
-    pushLight(light) {
+    pushLight(light: Light) {
         this.lightsArray.push(light);
     }
 
@@ -113,7 +164,10 @@ class RenderList {
         return this.lightsNode.fromLights(this.lightsArray);
     }
 
-    sort(customOpaqueSort, customTransparentSort) {
+    sort(
+        customOpaqueSort: ((a: RenderItem, b: RenderItem) => number) | null,
+        customTransparentSort: ((a: RenderItem, b: RenderItem) => number) | null,
+    ) {
         if (this.opaque.length > 1) this.opaque.sort(customOpaqueSort || painterSortStable);
         if (this.transparent.length > 1) this.transparent.sort(customTransparentSort || reversePainterSortStable);
     }
diff --git a/examples-jsm/examples/renderers/common/RenderLists.ts b/examples-jsm/examples/renderers/common/RenderLists.ts
index 3fc3134e..0cc369e5 100644
--- a/examples-jsm/examples/renderers/common/RenderLists.ts
+++ b/examples-jsm/examples/renderers/common/RenderLists.ts
@@ -1,14 +1,17 @@
+import { Camera, Object3D } from 'three';
 import ChainMap from './ChainMap.js';
 import RenderList from './RenderList.js';
 
 class RenderLists {
+    lists: ChainMap<readonly [Object3D, Camera], RenderList>;
+
     constructor() {
-        this.lists = new ChainMap();
+        this.lists = new ChainMap<readonly [Object3D, Camera], RenderList>();
     }
 
-    get(scene, camera) {
+    get(scene: Object3D, camera: Camera) {
         const lists = this.lists;
-        const keys = [scene, camera];
+        const keys = [scene, camera] as const;
 
         let list = lists.get(keys);
 
@@ -21,7 +24,7 @@ class RenderLists {
     }
 
     dispose() {
-        this.lists = new ChainMap();
+        this.lists = new ChainMap<readonly [Object3D, Camera], RenderList>();
     }
 }
 
diff --git a/examples-jsm/examples/renderers/common/RenderObject.ts b/examples-jsm/examples/renderers/common/RenderObject.ts
index 91ba0f2a..5cffdd08 100644
--- a/examples-jsm/examples/renderers/common/RenderObject.ts
+++ b/examples-jsm/examples/renderers/common/RenderObject.ts
@@ -1,8 +1,26 @@
 import ClippingContext from './ClippingContext.js';
+import Nodes from './nodes/Nodes.js';
+import Geometries from './Geometries.js';
+import Renderer from './Renderer.js';
+import {
+    BufferAttribute,
+    BufferGeometry,
+    Camera,
+    InterleavedBuffer,
+    InterleavedBufferAttribute,
+    Material,
+    Object3D,
+    Scene,
+} from 'three';
+import LightsNode from '../../nodes/lighting/LightsNode.js';
+import RenderContext from './RenderContext.js';
+import NodeBuilderState from './nodes/NodeBuilderState.js';
+import RenderPipeline from './RenderPipeline.js';
+import BindGroup from './BindGroup.js';
 
 let id = 0;
 
-function getKeys(obj) {
+function getKeys(obj: Material) {
     const keys = Object.keys(obj);
 
     let proto = Object.getPrototypeOf(obj);
@@ -27,7 +45,55 @@ function getKeys(obj) {
 }
 
 export default class RenderObject {
-    constructor(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext) {
+    _nodes: Nodes;
+    _geometries: Geometries;
+
+    id: number;
+
+    renderer: Renderer;
+    object: Object3D;
+    material: Material;
+    scene: Scene;
+    camera: Camera;
+    lightsNode: LightsNode;
+    context: RenderContext;
+
+    geometry: BufferGeometry;
+    version: number;
+
+    drawRange: { start: number; count: number } | null;
+
+    attributes: Array<BufferAttribute | InterleavedBufferAttribute> | null;
+    pipeline: RenderPipeline | null;
+    vertexBuffers: Array<BufferAttribute | InterleavedBuffer> | null;
+
+    clippingContext!: ClippingContext;
+
+    clippingContextVersion: number;
+
+    initialNodesCacheKey: string;
+    initialCacheKey: string;
+
+    _nodeBuilderState: NodeBuilderState | null;
+    _bindings: BindGroup[] | null;
+
+    onDispose: (() => void) | null;
+
+    readonly isRenderObject: true;
+
+    onMaterialDispose: () => void;
+
+    constructor(
+        nodes: Nodes,
+        geometries: Geometries,
+        renderer: Renderer,
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+    ) {
         this._nodes = nodes;
         this._geometries = geometries;
 
@@ -50,7 +116,7 @@ export default class RenderObject {
         this.pipeline = null;
         this.vertexBuffers = null;
 
-        this.updateClipping(renderContext.clippingContext);
+        this.updateClipping(renderContext.clippingContext!);
 
         this.clippingContextVersion = this.clippingContext.version;
 
@@ -71,7 +137,7 @@ export default class RenderObject {
         this.material.addEventListener('dispose', this.onMaterialDispose);
     }
 
-    updateClipping(parent) {
+    updateClipping(parent: ClippingContext) {
         const material = this.material;
 
         let clippingContext = this.clippingContext;
@@ -89,9 +155,9 @@ export default class RenderObject {
     }
 
     get clippingNeedsUpdate() {
-        if (this.clippingContext.version === this.clippingContextVersion) return false;
+        if (this.clippingContext!.version === this.clippingContextVersion) return false;
 
-        this.clippingContextVersion = this.clippingContext.version;
+        this.clippingContextVersion = this.clippingContext!.version;
 
         return true;
     }
@@ -109,7 +175,7 @@ export default class RenderObject {
     }
 
     getChainArray() {
-        return [this.object, this.material, this.context, this.lightsNode];
+        return [this.object, this.material, this.context, this.lightsNode] as const;
     }
 
     getAttributes() {
@@ -118,8 +184,8 @@ export default class RenderObject {
         const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
         const geometry = this.geometry;
 
-        const attributes = [];
-        const vertexBuffers = new Set();
+        const attributes: Array<BufferAttribute | InterleavedBufferAttribute> = [];
+        const vertexBuffers = new Set<BufferAttribute | InterleavedBuffer>();
 
         for (const nodeAttribute of nodeAttributes) {
             const attribute =
@@ -210,6 +276,6 @@ export default class RenderObject {
     dispose() {
         this.material.removeEventListener('dispose', this.onMaterialDispose);
 
-        this.onDispose();
+        this.onDispose!();
     }
 }
diff --git a/examples-jsm/examples/renderers/common/RenderObjects.ts b/examples-jsm/examples/renderers/common/RenderObjects.ts
index 76dc482e..27997a90 100644
--- a/examples-jsm/examples/renderers/common/RenderObjects.ts
+++ b/examples-jsm/examples/renderers/common/RenderObjects.ts
@@ -1,8 +1,33 @@
 import ChainMap from './ChainMap.js';
 import RenderObject from './RenderObject.js';
+import Renderer from './Renderer.js';
+import Nodes from './nodes/Nodes.js';
+import Geometries from './Geometries.js';
+import Pipelines from './Pipelines.js';
+import Bindings from './Bindings.js';
+import Info from './Info.js';
+import LightsNode from '../../nodes/lighting/LightsNode.js';
+import { Camera, Material, Object3D, Scene } from 'three';
+import RenderContext from './RenderContext.js';
 
 class RenderObjects {
-    constructor(renderer, nodes, geometries, pipelines, bindings, info) {
+    renderer: Renderer;
+    nodes: Nodes;
+    geometries: Geometries;
+    pipelines: Pipelines;
+    bindings: Bindings;
+    info: Info;
+
+    chainMaps: { [passId: string]: ChainMap<readonly [Object3D, Material, RenderContext, LightsNode], RenderObject> };
+
+    constructor(
+        renderer: Renderer,
+        nodes: Nodes,
+        geometries: Geometries,
+        pipelines: Pipelines,
+        bindings: Bindings,
+        info: Info,
+    ) {
         this.renderer = renderer;
         this.nodes = nodes;
         this.geometries = geometries;
@@ -13,9 +38,17 @@ class RenderObjects {
         this.chainMaps = {};
     }
 
-    get(object, material, scene, camera, lightsNode, renderContext, passId) {
+    get(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+        passId: string | undefined,
+    ): RenderObject {
         const chainMap = this.getChainMap(passId);
-        const chainArray = [object, material, renderContext, lightsNode];
+        const chainArray = [object, material, renderContext, lightsNode] as const;
 
         let renderObject = chainMap.get(chainArray);
 
@@ -35,7 +68,7 @@ class RenderObjects {
 
             chainMap.set(chainArray, renderObject);
         } else {
-            renderObject.updateClipping(renderContext.clippingContext);
+            renderObject.updateClipping(renderContext.clippingContext!);
 
             if (renderObject.version !== material.version || renderObject.needsUpdate) {
                 if (renderObject.initialCacheKey !== renderObject.getCacheKey()) {
@@ -52,7 +85,13 @@ class RenderObjects {
     }
 
     getChainMap(passId = 'default') {
-        return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());
+        return (
+            this.chainMaps[passId] ||
+            (this.chainMaps[passId] = new ChainMap<
+                readonly [Object3D, Material, RenderContext, LightsNode],
+                RenderObject
+            >())
+        );
     }
 
     dispose() {
@@ -60,16 +99,16 @@ class RenderObjects {
     }
 
     createRenderObject(
-        nodes,
-        geometries,
-        renderer,
-        object,
-        material,
-        scene,
-        camera,
-        lightsNode,
-        renderContext,
-        passId,
+        nodes: Nodes,
+        geometries: Geometries,
+        renderer: Renderer,
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        renderContext: RenderContext,
+        passId: string | undefined,
     ) {
         const chainMap = this.getChainMap(passId);
 
diff --git a/examples-jsm/examples/renderers/common/RenderPipeline.ts b/examples-jsm/examples/renderers/common/RenderPipeline.ts
index 0ec34b04..573cae2b 100644
--- a/examples-jsm/examples/renderers/common/RenderPipeline.ts
+++ b/examples-jsm/examples/renderers/common/RenderPipeline.ts
@@ -1,7 +1,11 @@
 import Pipeline from './Pipeline.js';
+import ProgrammableStage from './ProgrammableStage.js';
 
 class RenderPipeline extends Pipeline {
-    constructor(cacheKey, vertexProgram, fragmentProgram) {
+    vertexProgram: ProgrammableStage;
+    fragmentProgram: ProgrammableStage;
+
+    constructor(cacheKey: string, vertexProgram: ProgrammableStage, fragmentProgram: ProgrammableStage) {
         super(cacheKey);
 
         this.vertexProgram = vertexProgram;
diff --git a/examples-jsm/examples/renderers/common/Renderer.ts b/examples-jsm/examples/renderers/common/Renderer.ts
index b45a6873..cafe6722 100644
--- a/examples-jsm/examples/renderers/common/Renderer.ts
+++ b/examples-jsm/examples/renderers/common/Renderer.ts
@@ -30,10 +30,40 @@ import {
     RenderTarget,
     HalfFloatType,
     RGBAFormat,
+    ColorSpace,
+    ToneMapping,
+    Plane,
+    ShadowMapType,
+    Camera,
+    Color,
+    Object3D,
+    FramebufferTexture,
+    Texture,
+    Box2,
+    BufferGeometry,
+    Material,
+    Group,
+    Light,
+    LOD,
+    Sprite,
+    LineLoop,
+    Mesh,
+    Line,
+    Points,
+    ArrayCamera,
+    GeometryGroup,
+    BufferAttribute,
 } from 'three';
 import { NodeMaterial } from '../../nodes/Nodes.js';
 import QuadMesh from '../../objects/QuadMesh.js';
 import RenderBundles from './RenderBundles.js';
+import Backend from './Backend.js';
+import Node from '../../nodes/core/Node.js';
+import LightsNode from '../../nodes/lighting/LightsNode.js';
+import RenderContext from './RenderContext.js';
+import RenderBundle from './RenderBundle.js';
+import RenderList, { Bundle, RenderItem } from './RenderList.js';
+import ComputeNode from '../../nodes/gpgpu/ComputeNode.js';
 
 const _scene = new Scene();
 const _drawingBufferSize = new Vector2();
@@ -43,8 +73,137 @@ const _projScreenMatrix = new Matrix4();
 const _vector3 = new Vector3();
 const _quad = new QuadMesh(new NodeMaterial());
 
+export interface RendererParameters {
+    logarithmicDepthBuffer?: boolean | undefined;
+    alpha?: boolean | undefined;
+}
+
 class Renderer {
-    constructor(backend, parameters = {}) {
+    readonly isRenderer: true;
+
+    domElement: HTMLCanvasElement;
+
+    backend: Backend;
+
+    autoClear: boolean;
+    autoClearColor: boolean;
+    autoClearDepth: boolean;
+    autoClearStencil: boolean;
+
+    alpha: boolean;
+
+    logarithmicDepthBuffer: boolean;
+
+    outputColorSpace: ColorSpace;
+
+    toneMapping: ToneMapping;
+    toneMappingExposure: number;
+
+    sortObjects: boolean;
+
+    depth: boolean;
+    stencil: boolean;
+
+    clippingPlanes: readonly Plane[];
+
+    info: Info;
+
+    toneMappingNode: Node | null;
+
+    _pixelRatio: number;
+    _width: number;
+    _height: number;
+
+    _viewport: Vector4;
+    _scissor: Vector4;
+    _scissorTest: boolean;
+
+    _attributes: Attributes | null;
+    _geometries: Geometries | null;
+    _nodes: Nodes | null;
+    _animation: Animation | null;
+    _bindings: Bindings | null;
+    _objects: RenderObjects | null;
+    _pipelines: Pipelines | null;
+    _bundles: RenderBundles | null;
+    _renderLists: RenderLists | null;
+    _renderContexts: RenderContexts | null;
+    _textures: Textures | null;
+    _background: Background | null;
+
+    _currentRenderContext: RenderContext | null;
+
+    _opaqueSort: ((a: RenderItem, b: RenderItem) => number) | null;
+    _transparentSort: ((a: RenderItem, b: RenderItem) => number) | null;
+
+    _frameBufferTarget: RenderTarget | null;
+
+    _clearColor: Color4;
+    _clearDepth: number;
+    _clearStencil: number;
+
+    _renderTarget: RenderTarget | null;
+    _activeCubeFace: number;
+    _activeMipmapLevel: number;
+
+    _renderObjectFunction:
+        | ((
+              object: Object3D,
+              scene: Scene,
+              camera: Camera,
+              geometry: BufferGeometry,
+              material: Material,
+              group: GeometryGroup,
+              lightsNode: LightsNode,
+          ) => void)
+        | null;
+    _currentRenderObjectFunction:
+        | ((
+              object: Object3D,
+              scene: Scene,
+              camera: Camera,
+              geometry: BufferGeometry,
+              material: Material,
+              group: GeometryGroup,
+              lightsNode: LightsNode,
+          ) => void)
+        | null;
+    _currentRenderBundle: RenderBundle | null;
+
+    _handleObjectFunction: (
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: GeometryGroup,
+        passId?: string,
+    ) => void;
+
+    _initialized: boolean;
+    _initPromise: Promise<void> | null;
+
+    _compilationPromises: Promise<void>[] | null;
+
+    shadowMap: { enabled: boolean; type: ShadowMapType | null };
+
+    xr: { enabled: boolean };
+
+    debug: {
+        checkShaderErrors: boolean;
+        onShaderError:
+            | ((
+                  gl: WebGL2RenderingContext,
+                  programGPU: WebGLProgram,
+                  glVertexShader: WebGLShader,
+                  glFragmentShader: WebGLShader,
+              ) => void)
+            | null;
+    };
+
+    localClippingEnabled?: boolean | undefined;
+
+    constructor(backend: Backend, parameters: RendererParameters = {}) {
         this.isRenderer = true;
 
         //
@@ -212,12 +371,12 @@ class Renderer {
         return this.backend.coordinateSystem;
     }
 
-    async compileAsync(scene, camera, targetScene = null) {
+    async compileAsync(scene: Scene, camera: Camera, targetScene: Scene | null = null) {
         if (this._initialized === false) await this.init();
 
         // preserve render tree
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
         const previousRenderContext = this._currentRenderContext;
@@ -231,10 +390,10 @@ class Renderer {
         if (targetScene === null) targetScene = scene;
 
         const renderTarget = this._renderTarget;
-        const renderContext = this._renderContexts.get(targetScene, camera, renderTarget);
+        const renderContext = this._renderContexts!.get(targetScene, camera, renderTarget);
         const activeMipmapLevel = this._activeMipmapLevel;
 
-        const compilationPromises = [];
+        const compilationPromises: Promise<void>[] = [];
 
         this._currentRenderContext = renderContext;
         this._currentRenderObjectFunction = this.renderObject;
@@ -263,7 +422,7 @@ class Renderer {
 
         //
 
-        const renderList = this._renderLists.get(scene, camera);
+        const renderList = this._renderLists!.get(scene, camera);
         renderList.begin();
 
         this._projectObject(scene, camera, 0, renderList);
@@ -271,8 +430,8 @@ class Renderer {
         // include lights from target scene
         if (targetScene !== scene) {
             targetScene.traverseVisible(function (object) {
-                if (object.isLight && object.layers.test(camera.layers)) {
-                    renderList.pushLight(object);
+                if ((object as Light).isLight && object.layers.test(camera.layers)) {
+                    renderList.pushLight(object as Light);
                 }
             });
         }
@@ -282,12 +441,12 @@ class Renderer {
         //
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
+            this._textures!.updateRenderTarget(renderTarget, activeMipmapLevel);
 
-            const renderTargetData = this._textures.get(renderTarget);
+            const renderTargetData = this._textures!.get(renderTarget);
 
-            renderContext.textures = renderTargetData.textures;
-            renderContext.depthTexture = renderTargetData.depthTexture;
+            renderContext.textures = renderTargetData.textures!;
+            renderContext.depthTexture = renderTargetData.depthTexture!;
         } else {
             renderContext.textures = null;
             renderContext.depthTexture = null;
@@ -295,11 +454,11 @@ class Renderer {
 
         //
 
-        this._nodes.updateScene(sceneRef);
+        this._nodes!.updateScene(sceneRef);
 
         //
 
-        this._background.update(sceneRef, renderList, renderContext);
+        this._background!.update(sceneRef, renderList, renderContext);
 
         // process render lists
 
@@ -325,7 +484,7 @@ class Renderer {
         await Promise.all(compilationPromises);
     }
 
-    async renderAsync(scene, camera) {
+    async renderAsync(scene: Scene, camera: Camera) {
         if (this._initialized === false) await this.init();
 
         const renderContext = this._renderScene(scene, camera);
@@ -333,15 +492,15 @@ class Renderer {
         await this.backend.resolveTimestampAsync(renderContext, 'render');
     }
 
-    _renderBundle(bundle, sceneRef, lightsNode) {
+    _renderBundle(bundle: Bundle, sceneRef: Scene, lightsNode: LightsNode) {
         const { object, camera, renderList } = bundle;
 
-        const renderContext = this._currentRenderContext;
+        const renderContext = this._currentRenderContext!;
         const renderContextData = this.backend.get(renderContext);
 
         //
 
-        const renderBundle = this._bundles.get(object, camera);
+        const renderBundle = this._bundles!.get(object, camera);
 
         const renderBundleData = this.backend.get(renderBundle);
         if (renderBundleData.renderContexts === undefined) renderBundleData.renderContexts = new Set();
@@ -355,7 +514,7 @@ class Renderer {
 
         if (renderBundleNeedsUpdate) {
             if (renderContextData.renderObjects === undefined || object.needsUpdate === true) {
-                const nodeFrame = this._nodes.nodeFrame;
+                const nodeFrame = this._nodes!.nodeFrame;
 
                 renderContextData.renderObjects = [];
                 renderContextData.renderBundles = [];
@@ -378,13 +537,13 @@ class Renderer {
 
             object.needsUpdate = false;
         } else {
-            const renderContext = this._currentRenderContext;
+            const renderContext = this._currentRenderContext!;
             const renderContextData = this.backend.get(renderContext);
 
             for (let i = 0, l = renderContextData.renderObjects.length; i < l; i++) {
                 const renderObject = renderContextData.renderObjects[i];
 
-                this._nodes.updateBefore(renderObject);
+                this._nodes!.updateBefore(renderObject);
 
                 //
 
@@ -394,17 +553,17 @@ class Renderer {
                 );
                 renderObject.object.normalMatrix.getNormalMatrix(renderObject.object.modelViewMatrix);
 
-                this._nodes.updateForRender(renderObject);
-                this._bindings.updateForRender(renderObject);
+                this._nodes!.updateForRender(renderObject);
+                this._bindings!.updateForRender(renderObject);
 
                 this.backend.draw(renderObject, this.info);
 
-                this._nodes.updateAfter(renderObject);
+                this._nodes!.updateAfter(renderObject);
             }
         }
     }
 
-    render(scene, camera) {
+    render(scene: Scene, camera: Camera) {
         if (this._initialized === false) {
             console.warn(
                 'THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.',
@@ -460,12 +619,12 @@ class Renderer {
         return frameBufferTarget;
     }
 
-    _renderScene(scene, camera, useFrameBufferTarget = true) {
+    _renderScene(scene: Scene, camera: Camera, useFrameBufferTarget = true) {
         const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;
 
         // preserve render tree
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
         const previousRenderContext = this._currentRenderContext;
@@ -494,7 +653,7 @@ class Renderer {
 
         //
 
-        const renderContext = this._renderContexts.get(scene, camera, renderTarget);
+        const renderContext = this._renderContexts!.get(scene, camera, renderTarget);
 
         this._currentRenderContext = renderContext;
         this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;
@@ -566,7 +725,7 @@ class Renderer {
         _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
         _frustum.setFromProjectionMatrix(_projScreenMatrix, coordinateSystem);
 
-        const renderList = this._renderLists.get(scene, camera);
+        const renderList = this._renderLists!.get(scene, camera);
         renderList.begin();
 
         this._projectObject(scene, camera, 0, renderList);
@@ -580,14 +739,14 @@ class Renderer {
         //
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
+            this._textures!.updateRenderTarget(renderTarget, activeMipmapLevel);
 
-            const renderTargetData = this._textures.get(renderTarget);
+            const renderTargetData = this._textures!.get(renderTarget);
 
-            renderContext.textures = renderTargetData.textures;
-            renderContext.depthTexture = renderTargetData.depthTexture;
-            renderContext.width = renderTargetData.width;
-            renderContext.height = renderTargetData.height;
+            renderContext.textures = renderTargetData.textures!;
+            renderContext.depthTexture = renderTargetData.depthTexture!;
+            renderContext.width = renderTargetData.width!;
+            renderContext.height = renderTargetData.height!;
             renderContext.renderTarget = renderTarget;
             renderContext.depth = renderTarget.depthBuffer;
             renderContext.stencil = renderTarget.stencilBuffer;
@@ -608,11 +767,11 @@ class Renderer {
 
         //
 
-        this._nodes.updateScene(sceneRef);
+        this._nodes!.updateScene(sceneRef);
 
         //
 
-        this._background.update(sceneRef, renderList, renderContext);
+        this._background!.update(sceneRef, renderList, renderContext);
 
         //
 
@@ -645,7 +804,7 @@ class Renderer {
         if (frameBufferTarget !== null) {
             this.setRenderTarget(outputRenderTarget, activeCubeFace, activeMipmapLevel);
 
-            _quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);
+            _quad.material.fragmentNode = this._nodes!.getOutputNode(renderTarget!.texture);
 
             this._renderScene(_quad, _quad.camera, false);
         }
@@ -671,13 +830,13 @@ class Renderer {
         return this._activeMipmapLevel;
     }
 
-    async setAnimationLoop(callback) {
+    async setAnimationLoop(callback: ((time: DOMHighResTimeStamp, frame?: XRFrame) => void) | null) {
         if (this._initialized === false) await this.init();
 
-        this._animation.setAnimationLoop(callback);
+        this._animation!.setAnimationLoop(callback);
     }
 
-    async getArrayBufferAsync(attribute) {
+    async getArrayBufferAsync(attribute: BufferAttribute) {
         return await this.backend.getArrayBufferAsync(attribute);
     }
 
@@ -689,11 +848,11 @@ class Renderer {
         return this._pixelRatio;
     }
 
-    getDrawingBufferSize(target) {
+    getDrawingBufferSize(target: Vector2) {
         return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
     }
 
-    getSize(target) {
+    getSize(target: Vector2) {
         return target.set(this._width, this._height);
     }
 
@@ -703,7 +862,7 @@ class Renderer {
         this.setSize(this._width, this._height, false);
     }
 
-    setDrawingBufferSize(width, height, pixelRatio) {
+    setDrawingBufferSize(width: number, height: number, pixelRatio: number) {
         this._width = width;
         this._height = height;
 
@@ -717,7 +876,7 @@ class Renderer {
         if (this._initialized) this.backend.updateSize();
     }
 
-    setSize(width, height, updateStyle = true) {
+    setSize(width: number, height: number, updateStyle = true) {
         this._width = width;
         this._height = height;
 
@@ -734,15 +893,15 @@ class Renderer {
         if (this._initialized) this.backend.updateSize();
     }
 
-    setOpaqueSort(method) {
+    setOpaqueSort(method: ((a: RenderItem, b: RenderItem) => number) | null) {
         this._opaqueSort = method;
     }
 
-    setTransparentSort(method) {
+    setTransparentSort(method: ((a: RenderItem, b: RenderItem) => number) | null) {
         this._transparentSort = method;
     }
 
-    getScissor(target) {
+    getScissor(target: Vector4) {
         const scissor = this._scissor;
 
         target.x = scissor.x;
@@ -753,13 +912,15 @@ class Renderer {
         return target;
     }
 
-    setScissor(x, y, width, height) {
+    setScissor(x: Vector4): void;
+    setScissor(x: number, y: number, width: number, height: number): void;
+    setScissor(x: Vector4 | number, y?: number, width?: number, height?: number) {
         const scissor = this._scissor;
 
-        if (x.isVector4) {
-            scissor.copy(x);
+        if ((x as Vector4).isVector4) {
+            scissor.copy(x as Vector4);
         } else {
-            scissor.set(x, y, width, height);
+            scissor.set(x as number, y!, width!, height!);
         }
     }
 
@@ -767,34 +928,36 @@ class Renderer {
         return this._scissorTest;
     }
 
-    setScissorTest(boolean) {
+    setScissorTest(boolean: boolean) {
         this._scissorTest = boolean;
 
         this.backend.setScissorTest(boolean);
     }
 
-    getViewport(target) {
+    getViewport(target: Vector4) {
         return target.copy(this._viewport);
     }
 
-    setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {
+    setViewport(x: Vector4): void;
+    setViewport(x: number, y: number, width: number, height: number, minDepth?: number, maxDepth?: number): void;
+    setViewport(x: Vector4 | number, y?: number, width?: number, height?: number, minDepth = 0, maxDepth = 1) {
         const viewport = this._viewport;
 
-        if (x.isVector4) {
-            viewport.copy(x);
+        if ((x as Vector4).isVector4) {
+            viewport.copy(x as Vector4);
         } else {
-            viewport.set(x, y, width, height);
+            viewport.set(x as number, y!, width!, height!);
         }
 
         viewport.minDepth = minDepth;
         viewport.maxDepth = maxDepth;
     }
 
-    getClearColor(target) {
+    getClearColor(target: Color4) {
         return target.copy(this._clearColor);
     }
 
-    setClearColor(color, alpha = 1) {
+    setClearColor(color: Color, alpha = 1) {
         this._clearColor.set(color);
         this._clearColor.a = alpha;
     }
@@ -803,7 +966,7 @@ class Renderer {
         return this._clearColor.a;
     }
 
-    setClearAlpha(alpha) {
+    setClearAlpha(alpha: number) {
         this._clearColor.a = alpha;
     }
 
@@ -811,7 +974,7 @@ class Renderer {
         return this._clearDepth;
     }
 
-    setClearDepth(depth) {
+    setClearDepth(depth: number) {
         this._clearDepth = depth;
     }
 
@@ -819,11 +982,11 @@ class Renderer {
         return this._clearStencil;
     }
 
-    setClearStencil(stencil) {
+    setClearStencil(stencil: number) {
         this._clearStencil = stencil;
     }
 
-    isOccluded(object) {
+    isOccluded(object: Object3D) {
         const renderContext = this._currentRenderContext;
 
         return renderContext && this.backend.isOccluded(renderContext, object);
@@ -843,9 +1006,9 @@ class Renderer {
         let renderTargetData = null;
 
         if (renderTarget !== null) {
-            this._textures.updateRenderTarget(renderTarget);
+            this._textures!.updateRenderTarget(renderTarget);
 
-            renderTargetData = this._textures.get(renderTarget);
+            renderTargetData = this._textures!.get(renderTarget);
         }
 
         this.backend.clear(color, depth, stencil, renderTargetData);
@@ -854,7 +1017,7 @@ class Renderer {
             // If a color space transform or tone mapping is required,
             // the clear operation clears the intermediate renderTarget texture, but does not update the screen canvas.
 
-            _quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);
+            _quad.material.fragmentNode = this._nodes!.getOutputNode(renderTarget.texture);
             this._renderScene(_quad, _quad.camera, false);
         }
     }
@@ -890,7 +1053,7 @@ class Renderer {
     }
 
     get currentColorSpace() {
-        const renderTarget = this._renderTarget;
+        const renderTarget = this._renderTarget as RenderTarget<Texture | Texture[]>;
 
         if (renderTarget !== null) {
             const texture = renderTarget.texture;
@@ -904,20 +1067,20 @@ class Renderer {
     dispose() {
         this.info.dispose();
 
-        this._animation.dispose();
-        this._objects.dispose();
-        this._pipelines.dispose();
-        this._nodes.dispose();
-        this._bindings.dispose();
-        this._renderLists.dispose();
-        this._renderContexts.dispose();
-        this._textures.dispose();
+        this._animation!.dispose();
+        this._objects!.dispose();
+        this._pipelines!.dispose();
+        this._nodes!.dispose();
+        this._bindings!.dispose();
+        this._renderLists!.dispose();
+        this._renderContexts!.dispose();
+        this._textures!.dispose();
 
         this.setRenderTarget(null);
         this.setAnimationLoop(null);
     }
 
-    setRenderTarget(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
+    setRenderTarget(renderTarget: RenderTarget | null, activeCubeFace = 0, activeMipmapLevel = 0) {
         this._renderTarget = renderTarget;
         this._activeCubeFace = activeCubeFace;
         this._activeMipmapLevel = activeMipmapLevel;
@@ -927,7 +1090,19 @@ class Renderer {
         return this._renderTarget;
     }
 
-    setRenderObjectFunction(renderObjectFunction) {
+    setRenderObjectFunction(
+        renderObjectFunction:
+            | ((
+                  object: Object3D,
+                  scene: Scene,
+                  camera: Camera,
+                  geometry: BufferGeometry,
+                  material: Material,
+                  group: GeometryGroup,
+                  lightsNode: LightsNode,
+              ) => void)
+            | null,
+    ) {
         this._renderObjectFunction = renderObjectFunction;
     }
 
@@ -935,10 +1110,10 @@ class Renderer {
         return this._renderObjectFunction;
     }
 
-    async computeAsync(computeNodes) {
+    async computeAsync(computeNodes: ComputeNode | ComputeNode[]) {
         if (this._initialized === false) await this.init();
 
-        const nodeFrame = this._nodes.nodeFrame;
+        const nodeFrame = this._nodes!.nodeFrame;
 
         const previousRenderId = nodeFrame.renderId;
 
@@ -953,9 +1128,9 @@ class Renderer {
         //
 
         const backend = this.backend;
-        const pipelines = this._pipelines;
-        const bindings = this._bindings;
-        const nodes = this._nodes;
+        const pipelines = this._pipelines!;
+        const bindings = this._bindings!;
+        const nodes = this._nodes!;
 
         const computeList = Array.isArray(computeNodes) ? computeNodes : [computeNodes];
 
@@ -1002,13 +1177,13 @@ class Renderer {
         nodeFrame.renderId = previousRenderId;
     }
 
-    async hasFeatureAsync(name) {
+    async hasFeatureAsync(name: string) {
         if (this._initialized === false) await this.init();
 
         return this.backend.hasFeature(name);
     }
 
-    hasFeature(name) {
+    hasFeature(name: string) {
         if (this._initialized === false) {
             console.warn(
                 'THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.',
@@ -1020,64 +1195,77 @@ class Renderer {
         return this.backend.hasFeature(name);
     }
 
-    copyFramebufferToTexture(framebufferTexture) {
+    copyFramebufferToTexture(framebufferTexture: FramebufferTexture) {
         const renderContext = this._currentRenderContext;
 
-        this._textures.updateTexture(framebufferTexture);
+        this._textures!.updateTexture(framebufferTexture);
 
         this.backend.copyFramebufferToTexture(framebufferTexture, renderContext);
     }
 
-    copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
-        this._textures.updateTexture(srcTexture);
-        this._textures.updateTexture(dstTexture);
+    copyTextureToTexture(
+        srcTexture: Texture,
+        dstTexture: Texture,
+        srcRegion: Box2 | null = null,
+        dstPosition: Vector2 | null = null,
+        level = 0,
+    ) {
+        this._textures!.updateTexture(srcTexture);
+        this._textures!.updateTexture(dstTexture);
 
         this.backend.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);
     }
 
-    readRenderTargetPixelsAsync(renderTarget, x, y, width, height, index = 0) {
+    readRenderTargetPixelsAsync(
+        renderTarget: RenderTarget,
+        x: number,
+        y: number,
+        width: number,
+        height: number,
+        index = 0,
+    ) {
         return this.backend.copyTextureToBuffer(renderTarget.textures[index], x, y, width, height);
     }
 
-    _projectObject(object, camera, groupOrder, renderList) {
+    _projectObject(object: Object3D, camera: Camera, groupOrder: number, renderList: RenderList) {
         if (object.visible === false) return;
 
         const visible = object.layers.test(camera.layers);
 
         if (visible) {
-            if (object.isGroup) {
+            if ((object as Group).isGroup) {
                 groupOrder = object.renderOrder;
-            } else if (object.isLOD) {
-                if (object.autoUpdate === true) object.update(camera);
-            } else if (object.isLight) {
-                renderList.pushLight(object);
-            } else if (object.isSprite) {
-                if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
+            } else if ((object as LOD).isLOD) {
+                if ((object as LOD).autoUpdate === true) (object as LOD).update(camera);
+            } else if ((object as Light).isLight) {
+                renderList.pushLight(object as Light);
+            } else if ((object as Sprite).isSprite) {
+                if (!object.frustumCulled || _frustum.intersectsSprite(object as Sprite)) {
                     if (this.sortObjects === true) {
                         _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                     }
 
-                    const geometry = object.geometry;
-                    const material = object.material;
+                    const geometry = (object as Sprite).geometry;
+                    const material = (object as Sprite).material;
 
                     if (material.visible) {
                         renderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                     }
                 }
-            } else if (object.isLineLoop) {
+            } else if ((object as LineLoop).isLineLoop) {
                 console.error(
                     'THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.',
                 );
-            } else if (object.isMesh || object.isLine || object.isPoints) {
+            } else if ((object as Mesh).isMesh || (object as Line).isLine || (object as Points).isPoints) {
                 if (!object.frustumCulled || _frustum.intersectsObject(object)) {
-                    const geometry = object.geometry;
-                    const material = object.material;
+                    const geometry = (object as Mesh | Line | Points).geometry;
+                    const material = (object as Mesh | Line | Points).material;
 
                     if (this.sortObjects === true) {
                         if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
 
                         _vector3
-                            .copy(geometry.boundingSphere.center)
+                            .copy(geometry.boundingSphere!.center)
                             .applyMatrix4(object.matrixWorld)
                             .applyMatrix4(_projScreenMatrix);
                     }
@@ -1087,7 +1275,7 @@ class Renderer {
 
                         for (let i = 0, l = groups.length; i < l; i++) {
                             const group = groups[i];
-                            const groupMaterial = material[group.materialIndex];
+                            const groupMaterial = material[group.materialIndex!];
 
                             if (groupMaterial && groupMaterial.visible) {
                                 renderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
@@ -1104,7 +1292,7 @@ class Renderer {
             const baseRenderList = renderList;
 
             // replace render list
-            renderList = this._renderLists.get(object, camera);
+            renderList = this._renderLists!.get(object, camera);
 
             renderList.begin();
 
@@ -1124,13 +1312,13 @@ class Renderer {
         }
     }
 
-    _renderBundles(bundles, sceneRef, lightsNode) {
+    _renderBundles(bundles: Bundle[], sceneRef: Scene, lightsNode: LightsNode) {
         for (const bundle of bundles) {
             this._renderBundle(bundle, sceneRef, lightsNode);
         }
     }
 
-    _renderObjects(renderList, camera, scene, lightsNode) {
+    _renderObjects(renderList: RenderItem[], camera: Camera, scene: Scene, lightsNode: LightsNode) {
         // process renderable objects
 
         for (let i = 0, il = renderList.length; i < il; i++) {
@@ -1141,42 +1329,50 @@ class Renderer {
 
             const { object, geometry, material, group } = renderItem;
 
-            if (camera.isArrayCamera) {
-                const cameras = camera.cameras;
+            if ((camera as ArrayCamera).isArrayCamera) {
+                const cameras = (camera as ArrayCamera).cameras;
 
                 for (let j = 0, jl = cameras.length; j < jl; j++) {
                     const camera2 = cameras[j];
 
-                    if (object.layers.test(camera2.layers)) {
+                    if (object!.layers.test(camera2.layers)) {
                         const vp = camera2.viewport;
                         const minDepth = vp.minDepth === undefined ? 0 : vp.minDepth;
                         const maxDepth = vp.maxDepth === undefined ? 1 : vp.maxDepth;
 
-                        const viewportValue = this._currentRenderContext.viewportValue;
+                        const viewportValue = this._currentRenderContext!.viewportValue;
                         viewportValue.copy(vp).multiplyScalar(this._pixelRatio).floor();
                         viewportValue.minDepth = minDepth;
                         viewportValue.maxDepth = maxDepth;
 
                         this.backend.updateViewport(this._currentRenderContext);
 
-                        this._currentRenderObjectFunction(
-                            object,
+                        this._currentRenderObjectFunction!(
+                            object!,
                             scene,
                             camera2,
-                            geometry,
-                            material,
-                            group,
+                            geometry!,
+                            material!,
+                            group!,
                             lightsNode,
                         );
                     }
                 }
             } else {
-                this._currentRenderObjectFunction(object, scene, camera, geometry, material, group, lightsNode);
+                this._currentRenderObjectFunction!(object!, scene, camera, geometry!, material!, group!, lightsNode);
             }
         }
     }
 
-    renderObject(object, scene, camera, geometry, material, group, lightsNode) {
+    renderObject(
+        object: Object3D,
+        scene: Scene,
+        camera: Camera,
+        geometry: BufferGeometry,
+        material: Material,
+        group: GeometryGroup,
+        lightsNode: LightsNode,
+    ) {
         let overridePositionNode;
         let overrideFragmentNode;
         let overrideDepthNode;
@@ -1261,21 +1457,29 @@ class Renderer {
         object.onAfterRender(this, scene, camera, geometry, material, group);
     }
 
-    _renderObjectDirect(object, material, scene, camera, lightsNode, group, passId) {
-        const renderObject = this._objects.get(
+    _renderObjectDirect(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: GeometryGroup,
+        passId?: string,
+    ) {
+        const renderObject = this._objects!.get(
             object,
             material,
             scene,
             camera,
             lightsNode,
-            this._currentRenderContext,
+            this._currentRenderContext!,
             passId,
         );
         renderObject.drawRange = group || object.geometry.drawRange;
 
         //
 
-        this._nodes.updateBefore(renderObject);
+        this._nodes!.updateBefore(renderObject);
 
         //
 
@@ -1284,10 +1488,10 @@ class Renderer {
 
         //
 
-        this._nodes.updateForRender(renderObject);
-        this._geometries.updateForRender(renderObject);
-        this._bindings.updateForRender(renderObject);
-        this._pipelines.updateForRender(renderObject);
+        this._nodes!.updateForRender(renderObject);
+        this._geometries!.updateForRender(renderObject);
+        this._bindings!.updateForRender(renderObject);
+        this._pipelines!.updateForRender(renderObject);
 
         //
 
@@ -1301,38 +1505,46 @@ class Renderer {
         this.backend.draw(renderObject, this.info);
 
         if (this._currentRenderBundle !== null) {
-            const renderContextData = this.backend.get(this._currentRenderContext);
+            const renderContextData = this.backend.get(this._currentRenderContext!);
 
-            renderContextData.renderObjects.push(renderObject);
+            renderContextData.renderObjects!.push(renderObject);
         }
 
-        this._nodes.updateAfter(renderObject);
+        this._nodes!.updateAfter(renderObject);
     }
 
-    _createObjectPipeline(object, material, scene, camera, lightsNode, passId) {
-        const renderObject = this._objects.get(
+    _createObjectPipeline(
+        object: Object3D,
+        material: Material,
+        scene: Scene,
+        camera: Camera,
+        lightsNode: LightsNode,
+        group: GeometryGroup,
+        passId?: string,
+    ) {
+        const renderObject = this._objects!.get(
             object,
             material,
             scene,
             camera,
             lightsNode,
-            this._currentRenderContext,
+            this._currentRenderContext!,
             passId,
         );
 
         //
 
-        this._nodes.updateBefore(renderObject);
+        this._nodes!.updateBefore(renderObject);
 
         //
 
-        this._nodes.updateForRender(renderObject);
-        this._geometries.updateForRender(renderObject);
-        this._bindings.updateForRender(renderObject);
+        this._nodes!.updateForRender(renderObject);
+        this._geometries!.updateForRender(renderObject);
+        this._bindings!.updateForRender(renderObject);
 
-        this._pipelines.getForRender(renderObject, this._compilationPromises);
+        this._pipelines!.getForRender(renderObject, this._compilationPromises);
 
-        this._nodes.updateAfter(renderObject);
+        this._nodes!.updateAfter(renderObject);
     }
 
     get compute() {
diff --git a/examples-jsm/examples/renderers/common/SampledTexture.ts b/examples-jsm/examples/renderers/common/SampledTexture.ts
index d995a59f..a57e1359 100644
--- a/examples-jsm/examples/renderers/common/SampledTexture.ts
+++ b/examples-jsm/examples/renderers/common/SampledTexture.ts
@@ -1,9 +1,18 @@
+import { Texture, VideoTexture } from 'three';
 import Binding from './Binding.js';
 
 let id = 0;
 
 class SampledTexture extends Binding {
-    constructor(name, texture) {
+    id: number;
+
+    texture: Texture;
+    version: number;
+    store: boolean;
+
+    readonly isSampledTexture: true;
+
+    constructor(name: string, texture: Texture) {
         super(name);
 
         this.id = id++;
@@ -18,7 +27,7 @@ class SampledTexture extends Binding {
     get needsBindingsUpdate() {
         const { texture, version } = this;
 
-        return texture.isVideoTexture ? true : version !== texture.version; // @TODO: version === 0 && texture.version > 0 ( add it just to External Textures like PNG,JPG )
+        return (texture as VideoTexture).isVideoTexture ? true : version !== texture.version; // @TODO: version === 0 && texture.version > 0 ( add it just to External Textures like PNG,JPG )
     }
 
     update() {
@@ -35,7 +44,9 @@ class SampledTexture extends Binding {
 }
 
 class SampledArrayTexture extends SampledTexture {
-    constructor(name, texture) {
+    readonly isSampledArrayTexture: true;
+
+    constructor(name: string, texture) {
         super(name, texture);
 
         this.isSampledArrayTexture = true;
@@ -43,7 +54,9 @@ class SampledArrayTexture extends SampledTexture {
 }
 
 class Sampled3DTexture extends SampledTexture {
-    constructor(name, texture) {
+    readonly isSampled3DTexture: true;
+
+    constructor(name: string, texture) {
         super(name, texture);
 
         this.isSampled3DTexture = true;
@@ -51,7 +64,9 @@ class Sampled3DTexture extends SampledTexture {
 }
 
 class SampledCubeTexture extends SampledTexture {
-    constructor(name, texture) {
+    readonly isSampledCubeTexture: true;
+
+    constructor(name: string, texture) {
         super(name, texture);
 
         this.isSampledCubeTexture = true;
diff --git a/examples-jsm/examples/renderers/common/Sampler.ts b/examples-jsm/examples/renderers/common/Sampler.ts
index 8cd20d04..86e6f45e 100644
--- a/examples-jsm/examples/renderers/common/Sampler.ts
+++ b/examples-jsm/examples/renderers/common/Sampler.ts
@@ -1,7 +1,13 @@
 import Binding from './Binding.js';
 
 class Sampler extends Binding {
-    constructor(name, texture) {
+    // TODO
+    // texture
+    version: number;
+
+    readonly isSampler: true;
+
+    constructor(name: string, texture) {
         super(name);
 
         this.texture = texture;
diff --git a/examples-jsm/examples/renderers/common/StorageBuffer.ts b/examples-jsm/examples/renderers/common/StorageBuffer.ts
index ef5d3e46..fb6acc45 100644
--- a/examples-jsm/examples/renderers/common/StorageBuffer.ts
+++ b/examples-jsm/examples/renderers/common/StorageBuffer.ts
@@ -1,7 +1,12 @@
 import Buffer from './Buffer.js';
 
 class StorageBuffer extends Buffer {
-    constructor(name, attribute) {
+    // TODO
+    // attribute
+
+    readonly isStorageBuffer: true;
+
+    constructor(name: string, attribute) {
         super(name, attribute ? attribute.array : null);
 
         this.attribute = attribute;
diff --git a/examples-jsm/examples/renderers/common/Textures.ts b/examples-jsm/examples/renderers/common/Textures.ts
index 0eb0509c..6eb18198 100644
--- a/examples-jsm/examples/renderers/common/Textures.ts
+++ b/examples-jsm/examples/renderers/common/Textures.ts
@@ -14,12 +14,56 @@ import {
     CubeReflectionMapping,
     CubeRefractionMapping,
     UnsignedByteType,
+    RenderTarget,
+    Texture,
+    CubeTexture,
+    CompressedTexture,
 } from 'three';
+import Renderer from './Renderer.js';
+import Backend from './Backend.js';
+import Info from './Info.js';
+
+type SizeVector3Unitialized = Vector3 & { width?: number; height?: number; depth?: number };
+type SizeVector3 = Vector3 & { width: number; height: number; depth: number };
+
+const _size: SizeVector3Unitialized = new Vector3();
+
+interface RenderTargetData {
+    depthTextureMips?: { [activeMipmapLevel: number]: DepthTexture };
+    width?: number;
+    height?: number;
+    textures?: Texture[];
+    depthTexture?: DepthTexture;
+    depth?: boolean;
+    stencil?: boolean;
+    renderTarget?: RenderTarget;
+    sampleCount?: number;
+    initialized?: boolean;
+}
+
+interface TextureData {
+    initialized?: boolean;
+    version?: number;
+    isDefaultTexture?: boolean;
+}
+
+interface TextureOptions {
+    width?: number;
+    height?: number;
+    depth?: number;
+    needsMipmaps?: boolean;
+    levels?: number;
+}
 
-const _size = new Vector3();
+class Textures extends DataMap<{
+    renderTarget: { key: RenderTarget; value: RenderTargetData };
+    texture: { key: Texture; value: TextureData };
+}> {
+    renderer: Renderer;
+    backend: Backend;
+    info: Info;
 
-class Textures extends DataMap {
-    constructor(renderer, backend, info) {
+    constructor(renderer: Renderer, backend: Backend, info: Info) {
         super();
 
         this.renderer = renderer;
@@ -27,7 +71,7 @@ class Textures extends DataMap {
         this.info = info;
     }
 
-    updateRenderTarget(renderTarget, activeMipmapLevel = 0) {
+    updateRenderTarget(renderTarget: RenderTarget, activeMipmapLevel = 0) {
         const renderTargetData = this.get(renderTarget);
 
         const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
@@ -116,7 +160,7 @@ class Textures extends DataMap {
         }
     }
 
-    updateTexture(texture, options = {}) {
+    updateTexture(texture: Texture, options: TextureOptions = {}) {
         const textureData = this.get(texture);
         if (textureData.initialized === true && textureData.version === texture.version) return;
 
@@ -229,7 +273,7 @@ class Textures extends DataMap {
         textureData.version = texture.version;
     }
 
-    getSize(texture, target = _size) {
+    getSize(texture: Texture, target = _size) {
         let image = texture.images ? texture.images[0] : texture.image;
 
         if (image) {
@@ -237,18 +281,18 @@ class Textures extends DataMap {
 
             target.width = image.width;
             target.height = image.height;
-            target.depth = texture.isCubeTexture ? 6 : image.depth || 1;
+            target.depth = (texture as CubeTexture).isCubeTexture ? 6 : image.depth || 1;
         } else {
             target.width = target.height = target.depth = 1;
         }
 
-        return target;
+        return target as SizeVector3;
     }
 
-    getMipLevels(texture, width, height) {
+    getMipLevels(texture: Texture, width: number, height: number) {
         let mipLevelCount;
 
-        if (texture.isCompressedTexture) {
+        if ((texture as CompressedTexture).isCompressedTexture) {
             mipLevelCount = texture.mipmaps.length;
         } else {
             mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1;
@@ -257,16 +301,16 @@ class Textures extends DataMap {
         return mipLevelCount;
     }
 
-    needsMipmaps(texture) {
+    needsMipmaps(texture: Texture) {
         if (this.isEnvironmentTexture(texture)) return true;
 
         return (
-            texture.isCompressedTexture === true ||
+            (texture as CompressedTexture).isCompressedTexture === true ||
             (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter)
         );
     }
 
-    isEnvironmentTexture(texture) {
+    isEnvironmentTexture(texture: Texture) {
         const mapping = texture.mapping;
 
         return (
@@ -277,7 +321,7 @@ class Textures extends DataMap {
         );
     }
 
-    _destroyTexture(texture) {
+    _destroyTexture(texture: Texture) {
         this.backend.destroySampler(texture);
         this.backend.destroyTexture(texture);
 
diff --git a/examples-jsm/examples/renderers/common/Uniform.ts b/examples-jsm/examples/renderers/common/Uniform.ts
index 3d58b44c..0192ef8c 100644
--- a/examples-jsm/examples/renderers/common/Uniform.ts
+++ b/examples-jsm/examples/renderers/common/Uniform.ts
@@ -1,7 +1,15 @@
 import { Color, Matrix3, Matrix4, Vector2, Vector3, Vector4 } from 'three';
 
-class Uniform {
-    constructor(name, value) {
+class Uniform<TValue> {
+    name: string;
+    value: TValue;
+
+    boundary: number;
+    itemSize: number;
+
+    offset: number;
+
+    constructor(name: string, value: TValue) {
         this.name = name;
         this.value = value;
 
@@ -11,7 +19,7 @@ class Uniform {
         this.offset = 0; // this property is set by WebGPUUniformsGroup and marks the start position in the uniform buffer
     }
 
-    setValue(value) {
+    setValue(value: TValue) {
         this.value = value;
     }
 
@@ -20,8 +28,10 @@ class Uniform {
     }
 }
 
-class NumberUniform extends Uniform {
-    constructor(name, value = 0) {
+class NumberUniform extends Uniform<number> {
+    readonly isNumberUniform: true;
+
+    constructor(name: string, value = 0) {
         super(name, value);
 
         this.isNumberUniform = true;
@@ -31,8 +41,10 @@ class NumberUniform extends Uniform {
     }
 }
 
-class Vector2Uniform extends Uniform {
-    constructor(name, value = new Vector2()) {
+class Vector2Uniform extends Uniform<Vector2> {
+    readonly isVector2Uniform: true;
+
+    constructor(name: string, value = new Vector2()) {
         super(name, value);
 
         this.isVector2Uniform = true;
@@ -42,8 +54,10 @@ class Vector2Uniform extends Uniform {
     }
 }
 
-class Vector3Uniform extends Uniform {
-    constructor(name, value = new Vector3()) {
+class Vector3Uniform extends Uniform<Vector3> {
+    readonly isVector3Uniform: true;
+
+    constructor(name: string, value = new Vector3()) {
         super(name, value);
 
         this.isVector3Uniform = true;
@@ -53,8 +67,10 @@ class Vector3Uniform extends Uniform {
     }
 }
 
-class Vector4Uniform extends Uniform {
-    constructor(name, value = new Vector4()) {
+class Vector4Uniform extends Uniform<Vector4> {
+    readonly isVector4Uniform: true;
+
+    constructor(name: string, value = new Vector4()) {
         super(name, value);
 
         this.isVector4Uniform = true;
@@ -64,8 +80,10 @@ class Vector4Uniform extends Uniform {
     }
 }
 
-class ColorUniform extends Uniform {
-    constructor(name, value = new Color()) {
+class ColorUniform extends Uniform<Color> {
+    readonly isColorUniform: true;
+
+    constructor(name: string, value = new Color()) {
         super(name, value);
 
         this.isColorUniform = true;
@@ -75,8 +93,10 @@ class ColorUniform extends Uniform {
     }
 }
 
-class Matrix3Uniform extends Uniform {
-    constructor(name, value = new Matrix3()) {
+class Matrix3Uniform extends Uniform<Matrix3> {
+    readonly isMatrix3Uniform: true;
+
+    constructor(name: string, value = new Matrix3()) {
         super(name, value);
 
         this.isMatrix3Uniform = true;
@@ -86,8 +106,10 @@ class Matrix3Uniform extends Uniform {
     }
 }
 
-class Matrix4Uniform extends Uniform {
-    constructor(name, value = new Matrix4()) {
+class Matrix4Uniform extends Uniform<Matrix4> {
+    readonly isMatrix4Uniform: true;
+
+    constructor(name: string, value = new Matrix4()) {
         super(name, value);
 
         this.isMatrix4Uniform = true;
diff --git a/examples-jsm/examples/renderers/common/UniformBuffer.ts b/examples-jsm/examples/renderers/common/UniformBuffer.ts
index 28aac0d7..2479d00d 100644
--- a/examples-jsm/examples/renderers/common/UniformBuffer.ts
+++ b/examples-jsm/examples/renderers/common/UniformBuffer.ts
@@ -1,7 +1,9 @@
 import Buffer from './Buffer.js';
 
 class UniformBuffer extends Buffer {
-    constructor(name, buffer = null) {
+    readonly isUniformBuffer: true;
+
+    constructor(name?: string, buffer = null) {
         super(name, buffer);
 
         this.isUniformBuffer = true;
diff --git a/examples-jsm/examples/renderers/common/UniformsGroup.ts b/examples-jsm/examples/renderers/common/UniformsGroup.ts
index e2b62671..5c48602e 100644
--- a/examples-jsm/examples/renderers/common/UniformsGroup.ts
+++ b/examples-jsm/examples/renderers/common/UniformsGroup.ts
@@ -1,8 +1,24 @@
 import UniformBuffer from './UniformBuffer.js';
 import { GPU_CHUNK_BYTES } from './Constants.js';
+import {
+    ColorNodeUniform,
+    Matrix3NodeUniform,
+    Matrix4NodeUniform,
+    NodeUniformGPU,
+    NumberNodeUniform,
+    Vector2NodeUniform,
+    Vector3NodeUniform,
+    Vector4NodeUniform,
+} from './nodes/NodeUniform.js';
 
 class UniformsGroup extends UniformBuffer {
-    constructor(name) {
+    readonly isUniformsGroup: true;
+
+    _values: number[] | null;
+
+    uniforms: NodeUniformGPU[];
+
+    constructor(name?: string) {
         super(name);
 
         this.isUniformsGroup = true;
@@ -14,13 +30,13 @@ class UniformsGroup extends UniformBuffer {
         this.uniforms = [];
     }
 
-    addUniform(uniform) {
+    addUniform(uniform: NodeUniformGPU) {
         this.uniforms.push(uniform);
 
         return this;
     }
 
-    removeUniform(uniform) {
+    removeUniform(uniform: NodeUniformGPU) {
         const index = this.uniforms.indexOf(uniform);
 
         if (index !== -1) {
@@ -97,19 +113,19 @@ class UniformsGroup extends UniformBuffer {
         return updated;
     }
 
-    updateByType(uniform) {
-        if (uniform.isNumberUniform) return this.updateNumber(uniform);
-        if (uniform.isVector2Uniform) return this.updateVector2(uniform);
-        if (uniform.isVector3Uniform) return this.updateVector3(uniform);
-        if (uniform.isVector4Uniform) return this.updateVector4(uniform);
-        if (uniform.isColorUniform) return this.updateColor(uniform);
-        if (uniform.isMatrix3Uniform) return this.updateMatrix3(uniform);
-        if (uniform.isMatrix4Uniform) return this.updateMatrix4(uniform);
+    updateByType(uniform: NodeUniformGPU) {
+        if ((uniform as NumberNodeUniform).isNumberUniform) return this.updateNumber(uniform as NumberNodeUniform);
+        if ((uniform as Vector2NodeUniform).isVector2Uniform) return this.updateVector2(uniform as Vector2NodeUniform);
+        if ((uniform as Vector3NodeUniform).isVector3Uniform) return this.updateVector3(uniform as Vector3NodeUniform);
+        if ((uniform as Vector4NodeUniform).isVector4Uniform) return this.updateVector4(uniform as Vector4NodeUniform);
+        if ((uniform as ColorNodeUniform).isColorUniform) return this.updateColor(uniform as ColorNodeUniform);
+        if ((uniform as Matrix3NodeUniform).isMatrix3Uniform) return this.updateMatrix3(uniform as Matrix3NodeUniform);
+        if ((uniform as Matrix4NodeUniform).isMatrix4Uniform) return this.updateMatrix4(uniform as Matrix4NodeUniform);
 
         console.error('THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform);
     }
 
-    updateNumber(uniform) {
+    updateNumber(uniform: NumberNodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -126,7 +142,7 @@ class UniformsGroup extends UniformBuffer {
         return updated;
     }
 
-    updateVector2(uniform) {
+    updateVector2(uniform: Vector2NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -145,7 +161,7 @@ class UniformsGroup extends UniformBuffer {
         return updated;
     }
 
-    updateVector3(uniform) {
+    updateVector3(uniform: Vector3NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -165,7 +181,7 @@ class UniformsGroup extends UniformBuffer {
         return updated;
     }
 
-    updateVector4(uniform) {
+    updateVector4(uniform: Vector4NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -186,7 +202,7 @@ class UniformsGroup extends UniformBuffer {
         return updated;
     }
 
-    updateColor(uniform) {
+    updateColor(uniform: ColorNodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -206,7 +222,7 @@ class UniformsGroup extends UniformBuffer {
         return updated;
     }
 
-    updateMatrix3(uniform) {
+    updateMatrix3(uniform: Matrix3NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -242,7 +258,7 @@ class UniformsGroup extends UniformBuffer {
         return updated;
     }
 
-    updateMatrix4(uniform) {
+    updateMatrix4(uniform: Matrix4NodeUniform) {
         let updated = false;
 
         const a = this.values;
@@ -260,13 +276,13 @@ class UniformsGroup extends UniformBuffer {
     }
 }
 
-function setArray(a, b, offset) {
+function setArray(a: number[], b: number[], offset: number) {
     for (let i = 0, l = b.length; i < l; i++) {
         a[offset + i] = b[i];
     }
 }
 
-function arraysEqual(a, b, offset) {
+function arraysEqual(a: number[], b: number[], offset: number) {
     for (let i = 0, l = b.length; i < l; i++) {
         if (a[offset + i] !== b[i]) return false;
     }
diff --git a/examples-jsm/examples/renderers/common/nodes/NodeBuilderState.ts b/examples-jsm/examples/renderers/common/nodes/NodeBuilderState.ts
index e94d965f..3389ae5c 100644
--- a/examples-jsm/examples/renderers/common/nodes/NodeBuilderState.ts
+++ b/examples-jsm/examples/renderers/common/nodes/NodeBuilderState.ts
@@ -1,17 +1,36 @@
 import BindGroup from '../BindGroup.js';
+import NodeAttribute from '../../../nodes/core/NodeAttribute.js';
+import Node from '../../../nodes/core/Node.js';
+import NodeUniformsGroup from './NodeUniformsGroup.js';
 
 class NodeBuilderState {
+    vertexShader: string | null;
+    fragmentShader: string | null;
+    computeShader: string | null;
+    transforms: never[];
+
+    nodeAttributes: NodeAttribute[];
+    bindings: BindGroup[];
+
+    updateNodes: Node[];
+    updateBeforeNodes: Node[];
+    updateAfterNodes: Node[];
+
+    instanceBindGroups: boolean;
+
+    usedTimes: number;
+
     constructor(
-        vertexShader,
-        fragmentShader,
-        computeShader,
-        nodeAttributes,
-        bindings,
-        updateNodes,
-        updateBeforeNodes,
-        updateAfterNodes,
+        vertexShader: string | null,
+        fragmentShader: string | null,
+        computeShader: string | null,
+        nodeAttributes: NodeAttribute[],
+        bindings: BindGroup[],
+        updateNodes: Node[],
+        updateBeforeNodes: Node[],
+        updateAfterNodes: Node[],
         instanceBindGroups = true,
-        transforms = [],
+        transforms: never[] = [],
     ) {
         this.vertexShader = vertexShader;
         this.fragmentShader = fragmentShader;
@@ -34,14 +53,14 @@ class NodeBuilderState {
         const bindings = [];
 
         for (const instanceGroup of this.bindings) {
-            const shared = this.instanceBindGroups && instanceGroup.bindings[0].groupNode.shared;
+            const shared = this.instanceBindGroups && (instanceGroup.bindings[0] as NodeUniformsGroup).groupNode.shared;
 
             if (shared !== true) {
                 const bindingsGroup = new BindGroup(instanceGroup.name);
                 bindings.push(bindingsGroup);
 
                 for (const instanceBinding of instanceGroup.bindings) {
-                    bindingsGroup.bindings.push(instanceBinding.clone());
+                    bindingsGroup.bindings.push((instanceBinding as NodeUniformsGroup).clone());
                 }
             } else {
                 bindings.push(instanceGroup);
diff --git a/examples-jsm/examples/renderers/common/nodes/NodeUniform.ts b/examples-jsm/examples/renderers/common/nodes/NodeUniform.ts
index 659f5a82..8d29842c 100644
--- a/examples-jsm/examples/renderers/common/nodes/NodeUniform.ts
+++ b/examples-jsm/examples/renderers/common/nodes/NodeUniform.ts
@@ -7,9 +7,13 @@ import {
     Matrix3Uniform,
     Matrix4Uniform,
 } from '../Uniform.js';
+import NodeUniform from '../../../nodes/core/NodeUniform.js';
+import { Color, Matrix3, Matrix4, Vector2, Vector3, Vector4 } from 'three';
 
 class NumberNodeUniform extends NumberUniform {
-    constructor(nodeUniform) {
+    nodeUniform: NodeUniform<number>;
+
+    constructor(nodeUniform: NodeUniform<number>) {
         super(nodeUniform.name, nodeUniform.value);
 
         this.nodeUniform = nodeUniform;
@@ -21,7 +25,9 @@ class NumberNodeUniform extends NumberUniform {
 }
 
 class Vector2NodeUniform extends Vector2Uniform {
-    constructor(nodeUniform) {
+    nodeUniform: NodeUniform<Vector2>;
+
+    constructor(nodeUniform: NodeUniform<Vector2>) {
         super(nodeUniform.name, nodeUniform.value);
 
         this.nodeUniform = nodeUniform;
@@ -33,7 +39,9 @@ class Vector2NodeUniform extends Vector2Uniform {
 }
 
 class Vector3NodeUniform extends Vector3Uniform {
-    constructor(nodeUniform) {
+    nodeUniform: NodeUniform<Vector3>;
+
+    constructor(nodeUniform: NodeUniform<Vector3>) {
         super(nodeUniform.name, nodeUniform.value);
 
         this.nodeUniform = nodeUniform;
@@ -45,7 +53,9 @@ class Vector3NodeUniform extends Vector3Uniform {
 }
 
 class Vector4NodeUniform extends Vector4Uniform {
-    constructor(nodeUniform) {
+    nodeUniform: NodeUniform<Vector4>;
+
+    constructor(nodeUniform: NodeUniform<Vector4>) {
         super(nodeUniform.name, nodeUniform.value);
 
         this.nodeUniform = nodeUniform;
@@ -57,7 +67,9 @@ class Vector4NodeUniform extends Vector4Uniform {
 }
 
 class ColorNodeUniform extends ColorUniform {
-    constructor(nodeUniform) {
+    nodeUniform: NodeUniform<Color>;
+
+    constructor(nodeUniform: NodeUniform<Color>) {
         super(nodeUniform.name, nodeUniform.value);
 
         this.nodeUniform = nodeUniform;
@@ -69,7 +81,9 @@ class ColorNodeUniform extends ColorUniform {
 }
 
 class Matrix3NodeUniform extends Matrix3Uniform {
-    constructor(nodeUniform) {
+    nodeUniform: NodeUniform<Matrix3>;
+
+    constructor(nodeUniform: NodeUniform<Matrix3>) {
         super(nodeUniform.name, nodeUniform.value);
 
         this.nodeUniform = nodeUniform;
@@ -81,7 +95,9 @@ class Matrix3NodeUniform extends Matrix3Uniform {
 }
 
 class Matrix4NodeUniform extends Matrix4Uniform {
-    constructor(nodeUniform) {
+    nodeUniform: NodeUniform<Matrix4>;
+
+    constructor(nodeUniform: NodeUniform<Matrix4>) {
         super(nodeUniform.name, nodeUniform.value);
 
         this.nodeUniform = nodeUniform;
@@ -101,3 +117,11 @@ export {
     Matrix3NodeUniform,
     Matrix4NodeUniform,
 };
+export type NodeUniformGPU =
+    | NumberNodeUniform
+    | Vector2NodeUniform
+    | Vector3NodeUniform
+    | Vector4NodeUniform
+    | ColorNodeUniform
+    | Matrix3NodeUniform
+    | Matrix4NodeUniform;
diff --git a/examples-jsm/examples/renderers/common/nodes/NodeUniformsGroup.ts b/examples-jsm/examples/renderers/common/nodes/NodeUniformsGroup.ts
index e7b389cd..53406066 100644
--- a/examples-jsm/examples/renderers/common/nodes/NodeUniformsGroup.ts
+++ b/examples-jsm/examples/renderers/common/nodes/NodeUniformsGroup.ts
@@ -1,9 +1,16 @@
 import UniformsGroup from '../UniformsGroup.js';
+import UniformGroupNode from '../../../nodes/core/UniformGroupNode.js';
+import UniformNode from '../../../nodes/core/UniformNode.js';
 
 let id = 0;
 
 class NodeUniformsGroup extends UniformsGroup {
-    constructor(name, groupNode) {
+    id: number;
+    groupNode: UniformGroupNode;
+
+    readonly isNodeUniformsGroup: true;
+
+    constructor(name: string, groupNode: UniformGroupNode) {
         super(name);
 
         this.id = id++;
@@ -13,7 +20,7 @@ class NodeUniformsGroup extends UniformsGroup {
     }
 
     getNodes() {
-        const nodes = [];
+        const nodes: UniformNode<unknown>[] = [];
 
         for (const uniform of this.uniforms) {
             const node = uniform.nodeUniform.node;
diff --git a/examples-jsm/examples/renderers/common/nodes/Nodes.ts b/examples-jsm/examples/renderers/common/nodes/Nodes.ts
index db035f6d..5d4b35ba 100644
--- a/examples-jsm/examples/renderers/common/nodes/Nodes.ts
+++ b/examples-jsm/examples/renderers/common/nodes/Nodes.ts
@@ -2,10 +2,19 @@ import DataMap from '../DataMap.js';
 import ChainMap from '../ChainMap.js';
 import NodeBuilderState from './NodeBuilderState.js';
 import {
+    Camera,
+    Color,
+    CubeTexture,
     EquirectangularReflectionMapping,
     EquirectangularRefractionMapping,
+    Fog,
+    FogExp2,
+    Material,
     NoToneMapping,
+    Object3D,
+    Scene,
     SRGBColorSpace,
+    Texture,
 } from 'three';
 import {
     NodeFrame,
@@ -22,21 +31,66 @@ import {
     normalWorld,
     pmremTexture,
     viewportTopLeft,
+    ShaderNodeObject,
 } from '../../../nodes/Nodes.js';
+import Renderer from '../Renderer.js';
+import Backend from '../Backend.js';
+import LightsNode from '../../../nodes/lighting/LightsNode.js';
+import RenderObject from '../RenderObject.js';
+import NodeUniformsGroup from './NodeUniformsGroup.js';
+import NodeBuilder from '../../../nodes/core/NodeBuilder.js';
+import ComputeNode from '../../../nodes/gpgpu/ComputeNode.js';
+import Node from '../../../nodes/core/Node.js';
+import UniformGroupNode from '../../../nodes/core/UniformGroupNode.js';
+import GLSLNodeBuilder, { Transform } from '../../webgl/nodes/GLSLNodeBuilder.js';
+
+interface NodeUniformsGroupData {
+    renderId?: number | undefined;
+    frameId?: number | undefined;
+}
+
+interface RenderObjectData {
+    nodeBuilderState?: NodeBuilderState | undefined;
+}
+
+interface ComputeNodeData {
+    nodeBuilderState?: NodeBuilderState | undefined;
+}
 
-class Nodes extends DataMap {
-    constructor(renderer, backend) {
+interface SceneData {
+    background?: Color | Texture | CubeTexture | undefined;
+    backgroundNode?: Node | undefined;
+    fog?: Fog | FogExp2 | undefined;
+    fogNode?: Node | undefined;
+    environment?: Texture | undefined;
+    environmentNode?: Node | undefined;
+}
+
+class Nodes extends DataMap<{
+    nodeUniformsGroup: { key: NodeUniformsGroup; value: NodeUniformsGroupData };
+    renderObject: { key: RenderObject; value: RenderObjectData };
+    computeNode: { key: ComputeNode; value: ComputeNodeData };
+    scene: { key: Scene; value: SceneData };
+}> {
+    renderer: Renderer;
+    backend: Backend;
+    nodeFrame: NodeFrame;
+    nodeBuilderCache: Map<string, NodeBuilderState>;
+    callHashCache: ChainMap<readonly [Scene, LightsNode], { callId: number; cacheKey: string }>;
+    groupsData: ChainMap<readonly [UniformGroupNode, NodeUniformsGroup], { version?: number }>;
+
+    constructor(renderer: Renderer, backend: Backend) {
         super();
 
         this.renderer = renderer;
         this.backend = backend;
         this.nodeFrame = new NodeFrame();
         this.nodeBuilderCache = new Map();
-        this.callHashCache = new ChainMap();
+        this.callHashCache = new ChainMap<readonly [Scene, LightsNode], { callId: number; cacheKey: string }>();
         this.groupsData = new ChainMap();
     }
 
-    updateGroup(nodeUniformsGroup) {
+    updateGroup(nodeUniformsGroup: NodeUniformsGroup) {
         const groupNode = nodeUniformsGroup.groupNode;
         const name = groupNode.name;
 
@@ -76,7 +130,7 @@ class Nodes extends DataMap {
 
         // other groups are updated just when groupNode.needsUpdate is true
 
-        const groupChain = [groupNode, nodeUniformsGroup];
+        const groupChain = [groupNode, nodeUniformsGroup] as const;
 
         let groupData = this.groupsData.get(groupChain);
         if (groupData === undefined) this.groupsData.set(groupChain, (groupData = {}));
@@ -90,11 +144,11 @@ class Nodes extends DataMap {
         return false;
     }
 
-    getForRenderCacheKey(renderObject) {
+    getForRenderCacheKey(renderObject: RenderObject) {
         return renderObject.initialCacheKey;
     }
 
-    getForRender(renderObject) {
+    getForRender(renderObject: RenderObject) {
         const renderObjectData = this.get(renderObject);
 
         let nodeBuilderState = renderObjectData.nodeBuilderState;
@@ -131,20 +185,20 @@ class Nodes extends DataMap {
         return nodeBuilderState;
     }
 
-    delete(object) {
-        if (object.isRenderObject) {
-            const nodeBuilderState = this.get(object).nodeBuilderState;
+    delete(object: NodeUniformsGroup | RenderObject | ComputeNode | Scene) {
+        if ((object as RenderObject).isRenderObject) {
+            const nodeBuilderState = this.get(object as RenderObject).nodeBuilderState!;
             nodeBuilderState.usedTimes--;
 
             if (nodeBuilderState.usedTimes === 0) {
-                this.nodeBuilderCache.delete(this.getForRenderCacheKey(object));
+                this.nodeBuilderCache.delete(this.getForRenderCacheKey(object as RenderObject));
             }
         }
 
         return super.delete(object);
     }
 
-    getForCompute(computeNode) {
+    getForCompute(computeNode: ComputeNode) {
         const computeData = this.get(computeNode);
 
         let nodeBuilderState = computeData.nodeBuilderState;
@@ -161,7 +215,7 @@ class Nodes extends DataMap {
         return nodeBuilderState;
     }
 
-    _createNodeBuilderState(nodeBuilder) {
+    _createNodeBuilderState(nodeBuilder: NodeBuilder) {
         return new NodeBuilderState(
             nodeBuilder.vertexShader,
             nodeBuilder.fragmentShader,
@@ -176,20 +230,28 @@ class Nodes extends DataMap {
         );
     }
 
-    getEnvironmentNode(scene) {
-        return scene.environmentNode || this.get(scene).environmentNode || null;
+    getEnvironmentNode(scene: Scene) {
+        return (
+            (scene as { environmentNode?: Node | null | undefined }).environmentNode ||
+            this.get(scene).environmentNode ||
+            null
+        );
     }
 
-    getBackgroundNode(scene) {
-        return scene.backgroundNode || this.get(scene).backgroundNode || null;
+    getBackgroundNode(scene: Scene) {
+        return (
+            (scene as { backgroundNode?: Node | null | undefined }).backgroundNode ||
+            this.get(scene).backgroundNode ||
+            null
+        );
     }
 
-    getFogNode(scene) {
-        return scene.fogNode || this.get(scene).fogNode || null;
+    getFogNode(scene: Scene) {
+        return (scene as { fogNode?: Node | null | undefined }).fogNode || this.get(scene).fogNode || null;
     }
 
-    getCacheKey(scene, lightsNode) {
-        const chain = [scene, lightsNode];
+    getCacheKey(scene: Scene, lightsNode: LightsNode) {
+        const chain = [scene, lightsNode] as const;
         const callId = this.renderer.info.calls;
 
         let cacheKeyData = this.callHashCache.get(chain);
@@ -215,7 +277,7 @@ class Nodes extends DataMap {
         return cacheKeyData.cacheKey;
     }
 
-    updateScene(scene) {
+    updateScene(scene: Scene) {
         this.updateEnvironment(scene);
         this.updateFog(scene);
         this.updateBackground(scene);
@@ -225,7 +287,7 @@ class Nodes extends DataMap {
         return this.renderer.getRenderTarget() ? false : true;
     }
 
-    updateBackground(scene) {
+    updateBackground(scene: Scene) {
         const sceneData = this.get(scene);
         const background = scene.background;
 
@@ -234,15 +296,15 @@ class Nodes extends DataMap {
                 let backgroundNode = null;
 
                 if (
-                    background.isCubeTexture === true ||
-                    background.mapping === EquirectangularReflectionMapping ||
-                    background.mapping === EquirectangularRefractionMapping
+                    (background as CubeTexture).isCubeTexture === true ||
+                    (background as CubeTexture).mapping === EquirectangularReflectionMapping ||
+                    (background as CubeTexture).mapping === EquirectangularRefractionMapping
                 ) {
                     backgroundNode = pmremTexture(background, normalWorld);
-                } else if (background.isTexture === true) {
-                    backgroundNode = texture(background, viewportBottomLeft).setUpdateMatrix(true);
-                } else if (background.isColor !== true) {
-                    console.error('WebGPUNodes: Unsupported background configuration.', background);
+                } else if ((background as Texture).isTexture === true) {
+                    backgroundNode = texture(background as Texture, viewportBottomLeft).setUpdateMatrix(true);
+                } else if ((background as Color).isColor !== true) {
+                    console.error('WebGPUNodes: Unsupported background configuration.', background as Color);
                 }
 
                 sceneData.backgroundNode = backgroundNode;
@@ -254,7 +316,7 @@ class Nodes extends DataMap {
         }
     }
 
-    updateFog(scene) {
+    updateFog(scene: Scene) {
         const sceneData = this.get(scene);
         const fog = scene.fog;
 
@@ -262,9 +324,9 @@ class Nodes extends DataMap {
             if (sceneData.fog !== fog) {
                 let fogNode = null;
 
-                if (fog.isFogExp2) {
+                if ((fog as FogExp2).isFogExp2) {
                     fogNode = densityFog(reference('color', 'color', fog), reference('density', 'float', fog));
-                } else if (fog.isFog) {
+                } else if ((fog as Fog).isFog) {
                     fogNode = rangeFog(
                         reference('color', 'color', fog),
                         reference('near', 'float', fog),
@@ -283,7 +345,7 @@ class Nodes extends DataMap {
         }
     }
 
-    updateEnvironment(scene) {
+    updateEnvironment(scene: Scene) {
         const sceneData = this.get(scene);
         const environment = scene.environment;
 
@@ -291,7 +353,7 @@ class Nodes extends DataMap {
             if (sceneData.environment !== environment) {
                 let environmentNode = null;
 
-                if (environment.isCubeTexture === true) {
+                if ((environment as CubeTexture).isCubeTexture === true) {
                     environmentNode = cubeTexture(environment);
                 } else if (environment.isTexture === true) {
                     environmentNode = texture(environment);
@@ -308,7 +370,13 @@ class Nodes extends DataMap {
         }
     }
 
-    getNodeFrame(renderer = this.renderer, scene = null, object = null, camera = null, material = null) {
+    getNodeFrame(
+        renderer = this.renderer,
+        scene: Scene | null = null,
+        object: Object3D | null = null,
+        camera: Camera | null = null,
+        material: Material | null = null,
+    ) {
         const nodeFrame = this.nodeFrame;
         nodeFrame.renderer = renderer;
         nodeFrame.scene = scene;
@@ -319,7 +387,7 @@ class Nodes extends DataMap {
         return nodeFrame;
     }
 
-    getNodeFrameForRender(renderObject) {
+    getNodeFrameForRender(renderObject: RenderObject) {
         return this.getNodeFrame(
             renderObject.renderer,
             renderObject.scene,
@@ -329,8 +397,8 @@ class Nodes extends DataMap {
         );
     }
 
-    getOutputNode(outputTexture) {
-        let output = texture(outputTexture, viewportTopLeft);
+    getOutputNode(outputTexture: Texture) {
+        let output: ShaderNodeObject<Node> = texture(outputTexture, viewportTopLeft);
 
         if (this.isToneMappingState) {
             if (this.renderer.toneMappingNode) {
@@ -347,7 +415,7 @@ class Nodes extends DataMap {
         return output;
     }
 
-    updateBefore(renderObject) {
+    updateBefore(renderObject: RenderObject) {
         const nodeFrame = this.getNodeFrameForRender(renderObject);
         const nodeBuilder = renderObject.getNodeBuilderState();
 
@@ -356,7 +424,7 @@ class Nodes extends DataMap {
         }
     }
 
-    updateAfter(renderObject) {
+    updateAfter(renderObject: RenderObject) {
         const nodeFrame = this.getNodeFrameForRender(renderObject);
         const nodeBuilder = renderObject.getNodeBuilderState();
 
@@ -365,7 +433,7 @@ class Nodes extends DataMap {
         }
     }
 
-    updateForCompute(computeNode) {
+    updateForCompute(computeNode: ComputeNode) {
         const nodeFrame = this.getNodeFrame();
         const nodeBuilder = this.getForCompute(computeNode);
 
@@ -374,7 +442,7 @@ class Nodes extends DataMap {
         }
     }
 
-    updateForRender(renderObject) {
+    updateForRender(renderObject: RenderObject) {
         const nodeFrame = this.getNodeFrameForRender(renderObject);
         const nodeBuilder = renderObject.getNodeBuilderState();
 
diff --git a/examples-jsm/examples/renderers/webgl/WebGLBackend.ts b/examples-jsm/examples/renderers/webgl/WebGLBackend.ts
index f32af434..1e0751e8 100644
--- a/examples-jsm/examples/renderers/webgl/WebGLBackend.ts
+++ b/examples-jsm/examples/renderers/webgl/WebGLBackend.ts
@@ -1,4 +1,4 @@
-import { WebGLCoordinateSystem } from 'three';
+import { Texture, WebGLCoordinateSystem } from 'three';
 
 import GLSLNodeBuilder from './nodes/GLSLNodeBuilder.js';
 import Backend from '../common/Backend.js';
@@ -614,7 +614,7 @@ class WebGLBackend extends Backend {
         this.textureUtils.destroyTexture(texture);
     }
 
-    copyTextureToBuffer(texture, x, y, width, height) {
+    copyTextureToBuffer(texture: Texture, x: number, y: number, width: number, height: number) {
         return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height);
     }
 
diff --git a/examples-jsm/examples/renderers/webgl/nodes/GLSLNodeBuilder.ts b/examples-jsm/examples/renderers/webgl/nodes/GLSLNodeBuilder.ts
index 816b83ea..4b355b7e 100644
--- a/examples-jsm/examples/renderers/webgl/nodes/GLSLNodeBuilder.ts
+++ b/examples-jsm/examples/renderers/webgl/nodes/GLSLNodeBuilder.ts
@@ -1,4 +1,15 @@
-import { MathNode, GLSLNodeParser, NodeBuilder, TextureNode, vectorComponents } from '../../../nodes/Nodes.js';
+import {
+    MathNode,
+    GLSLNodeParser,
+    NodeBuilder,
+    TextureNode,
+    vectorComponents,
+    ShaderNodeObject,
+    ShaderNodeInternal,
+    NodeShaderStage,
+    StorageArrayElementNode,
+    StorageBufferNode,
+} from '../../../nodes/Nodes.js';
 
 import NodeUniformBuffer from '../../common/nodes/NodeUniformBuffer.js';
 import NodeUniformsGroup from '../../common/nodes/NodeUniformsGroup.js';
@@ -26,9 +37,17 @@ import {
     RGBFormat,
     RGBAFormat,
     FloatType,
+    Object3D,
+    Scene,
+    Texture,
+    BufferAttribute,
+    InterleavedBufferAttribute,
 } from 'three';
+import Renderer from '../../common/Renderer.js';
+import StructTypeNode from '../../../nodes/core/StructTypeNode.js';
+import BufferAttributeNode from '../../../nodes/accessors/BufferAttributeNode.js';
 
-const glslMethods = {
+const glslMethods: { [method: string]: string } = {
     [MathNode.ATAN2]: 'atan',
     textureDimensions: 'textureSize',
     equals: 'equal',
@@ -66,8 +85,31 @@ precision highp isampler2DArray;
 precision lowp sampler2DShadow;
 `;
 
+export interface Transform {
+    varyingName: string | null | undefined;
+    attributeNode: ShaderNodeObject<BufferAttributeNode>;
+}
+
+interface StageData {
+    uniforms?: string | undefined;
+    attributes?: string | undefined;
+    varyings?: string | undefined;
+    vars?: string | undefined;
+    structs?: string | undefined;
+    codes?: string | undefined;
+    transforms?: string | undefined;
+    flow?: string | undefined;
+}
+
 class GLSLNodeBuilder extends NodeBuilder {
-    constructor(object, renderer) {
+    uniformGroups: {
+        vertex?: { [groupName: string]: NodeUniformsGroup | undefined };
+        fragment?: { [groupName: string]: NodeUniformsGroup | undefined };
+        compute?: { [groupName: string]: NodeUniformsGroup | undefined };
+    };
+    transforms: Transform[];
+
+    constructor(object: Object3D, renderer: Renderer) {
         super(object, renderer, new GLSLNodeParser());
 
         this.uniformGroups = {};
@@ -76,7 +118,7 @@ class GLSLNodeBuilder extends NodeBuilder {
         this.instanceBindGroups = false;
     }
 
-    getMethod(method) {
+    getMethod(method: string) {
         return glslMethods[method] || method;
     }
 
@@ -84,7 +126,7 @@ class GLSLNodeBuilder extends NodeBuilder {
         return '';
     }
 
-    buildFunctionCode(shaderNode) {
+    buildFunctionCode(shaderNode: ShaderNodeInternal) {
         const layout = shaderNode.layout;
         const flowData = this.flowShaderNode(shaderNode);
 
@@ -110,7 +152,7 @@ ${flowData.code}
         return code;
     }
 
-    setupPBO(storageBufferNode) {
+    setupPBO(storageBufferNode: StorageBufferNode) {
         const attribute = storageBufferNode.value;
 
         if (attribute.pbo === undefined) {
@@ -174,7 +216,7 @@ ${flowData.code}
         }
     }
 
-    getPropertyName(node, shaderStage = this.shaderStage) {
+    getPropertyName(node: unknown, shaderStage = this.shaderStage) {
         if (node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true) {
             return shaderStage.charAt(0) + '_' + node.name;
         }
@@ -182,7 +224,7 @@ ${flowData.code}
         return super.getPropertyName(node, shaderStage);
     }
 
-    generatePBO(storageArrayElementNode) {
+    generatePBO(storageArrayElementNode: StorageArrayElementNode) {
         const { node, indexNode } = storageArrayElementNode;
         const attribute = node.value;
 
@@ -252,7 +294,13 @@ ${flowData.code}
         return propertyName;
     }
 
-    generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0') {
+    generateTextureLoad(
+        texture: Texture | null,
+        textureProperty: string | undefined,
+        uvIndexSnippet: string,
+        depthSnippet: string | null,
+        levelSnippet = '0',
+    ) {
         if (depthSnippet) {
             return `texelFetch( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet} )`;
         } else {
@@ -260,7 +308,7 @@ ${flowData.code}
         }
     }
 
-    generateTexture(texture, textureProperty, uvSnippet, depthSnippet) {
+    generateTexture(texture: Texture, textureProperty: string, uvSnippet: string | null, depthSnippet: string | null) {
         if (texture.isDepthTexture) {
             return `texture( ${textureProperty}, ${uvSnippet} ).x`;
         } else {
@@ -270,20 +318,30 @@ ${flowData.code}
         }
     }
 
-    generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet) {
+    generateTextureLevel(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        levelSnippet: string | null,
+    ) {
         return `textureLod( ${textureProperty}, ${uvSnippet}, ${levelSnippet} )`;
     }
 
-    generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet) {
+    generateTextureGrad(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        gradSnippet: [string, string] | null,
+    ) {
         return `textureGrad( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]} )`;
     }
 
     generateTextureCompare(
-        texture,
-        textureProperty,
-        uvSnippet,
-        compareSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        compareSnippet: string | null,
+        depthSnippet: string | null,
         shaderStage = this.shaderStage,
     ) {
         if (shaderStage === 'fragment') {
@@ -292,11 +350,12 @@ ${flowData.code}
             console.error(
                 `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`,
             );
+            return undefined as unknown as string;
         }
     }
 
-    getVars(shaderStage) {
-        const snippets = [];
+    getVars(shaderStage: 'vertex' | 'fragment' | 'compute') {
+        const snippets: string[] = [];
 
         const vars = this.vars[shaderStage];
 
@@ -309,7 +368,7 @@ ${flowData.code}
         return snippets.join('\n\t');
     }
 
-    getUniforms(shaderStage) {
+    getUniforms(shaderStage: 'vertex' | 'fragment' | 'compute') {
         const uniforms = this.uniforms[shaderStage];
 
         const bindingSnippets = [];
@@ -391,7 +450,7 @@ ${flowData.code}
         return output;
     }
 
-    getTypeFromAttribute(attribute) {
+    getTypeFromAttribute(attribute: BufferAttribute | InterleavedBufferAttribute) {
         let nodeType = super.getTypeFromAttribute(attribute);
 
         if (/^[iu]/.test(nodeType) && attribute.gpuType !== IntType) {
@@ -414,7 +473,7 @@ ${flowData.code}
         return nodeType;
     }
 
-    getAttributes(shaderStage) {
+    getAttributes(shaderStage: NodeShaderStage) {
         let snippet = '';
 
         if (shaderStage === 'vertex' || shaderStage === 'compute') {
@@ -430,8 +489,8 @@ ${flowData.code}
         return snippet;
     }
 
-    getStructMembers(struct) {
-        const snippets = [];
+    getStructMembers(struct: StructTypeNode) {
+        const snippets: string[] = [];
         const members = struct.getMemberTypes();
 
         for (let i = 0; i < members.length; i++) {
@@ -442,7 +501,7 @@ ${flowData.code}
         return snippets.join('\n');
     }
 
-    getStructs(shaderStage) {
+    getStructs(shaderStage: NodeShaderStage) {
         const snippets = [];
         const structs = this.structs[shaderStage];
 
@@ -463,7 +522,7 @@ ${flowData.code}
         return snippets.join('\n\n');
     }
 
-    getVaryings(shaderStage) {
+    getVaryings(shaderStage: NodeShaderStage) {
         let snippet = '';
 
         const varyings = this.varyings;
@@ -510,7 +569,7 @@ ${flowData.code}
         return 'gl_FragDepth';
     }
 
-    isAvailable(name) {
+    isAvailable(name: string) {
         let result = supports[name];
 
         if (result === undefined) {
@@ -535,11 +594,11 @@ ${flowData.code}
         return true;
     }
 
-    registerTransform(varyingName, attributeNode) {
+    registerTransform(varyingName: string | null | undefined, attributeNode: ShaderNodeObject<BufferAttributeNode>) {
         this.transforms.push({ varyingName, attributeNode });
     }
 
-    getTransforms(/* shaderStage  */) {
+    getTransforms(shaderStage: NodeShaderStage) {
         const transforms = this.transforms;
 
         let snippet = '';
@@ -555,14 +614,14 @@ ${flowData.code}
         return snippet;
     }
 
-    _getGLSLUniformStruct(name, vars) {
+    _getGLSLUniformStruct(name: string, vars: string) {
         return `
 layout( std140 ) uniform ${name} {
 ${vars}
 };`;
     }
 
-    _getGLSLVertexCode(shaderData) {
+    _getGLSLVertexCode(shaderData: StageData) {
         return `#version 300 es
 
 ${this.getSignature()}
@@ -599,7 +658,7 @@ void main() {
 `;
     }
 
-    _getGLSLFragmentCode(shaderData) {
+    _getGLSLFragmentCode(shaderData: StageData) {
         return `#version 300 es
 
 ${this.getSignature()}
@@ -631,17 +690,18 @@ void main() {
     }
 
     buildCode() {
-        const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
+        const shadersData: { fragment?: StageData; vertex?: StageData; compute?: StageData } =
+            this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
 
         for (const shaderStage in shadersData) {
             let flow = '// code\n\n';
-            flow += this.flowCode[shaderStage];
+            flow += this.flowCode[shaderStage as NodeShaderStage];
 
-            const flowNodes = this.flowNodes[shaderStage];
+            const flowNodes = this.flowNodes[shaderStage as NodeShaderStage];
             const mainNode = flowNodes[flowNodes.length - 1];
 
             for (const node of flowNodes) {
-                const flowSlotData = this.getFlowData(node /*, shaderStage*/);
+                const flowSlotData = this.getFlowData(node /*, shaderStage*/)!;
                 const slotName = node.name;
 
                 if (slotName) {
@@ -667,27 +727,32 @@ void main() {
                 }
             }
 
-            const stageData = shadersData[shaderStage];
+            const stageData = shadersData[shaderStage as NodeShaderStage]!;
 
-            stageData.uniforms = this.getUniforms(shaderStage);
-            stageData.attributes = this.getAttributes(shaderStage);
-            stageData.varyings = this.getVaryings(shaderStage);
-            stageData.vars = this.getVars(shaderStage);
-            stageData.structs = this.getStructs(shaderStage);
-            stageData.codes = this.getCodes(shaderStage);
-            stageData.transforms = this.getTransforms(shaderStage);
+            stageData.uniforms = this.getUniforms(shaderStage as NodeShaderStage);
+            stageData.attributes = this.getAttributes(shaderStage as NodeShaderStage);
+            stageData.varyings = this.getVaryings(shaderStage as NodeShaderStage);
+            stageData.vars = this.getVars(shaderStage as NodeShaderStage);
+            stageData.structs = this.getStructs(shaderStage as NodeShaderStage);
+            stageData.codes = this.getCodes(shaderStage as NodeShaderStage);
+            stageData.transforms = this.getTransforms(shaderStage as NodeShaderStage);
             stageData.flow = flow;
         }
 
         if (this.material !== null) {
-            this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);
-            this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);
+            this.vertexShader = this._getGLSLVertexCode(shadersData.vertex!);
+            this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment!);
         } else {
-            this.computeShader = this._getGLSLVertexCode(shadersData.compute);
+            this.computeShader = this._getGLSLVertexCode(shadersData.compute!);
         }
     }
 
-    getUniformFromNode(node, type, shaderStage, name = null) {
+    getUniformFromNode(
+        node: UniformNode<unknown>,
+        type: string | null,
+        shaderStage: 'vertex' | 'fragment' | 'compute',
+        name: string | null = null,
+    ) {
         const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
diff --git a/examples-jsm/examples/renderers/webgpu/WebGPUBackend.ts b/examples-jsm/examples/renderers/webgpu/WebGPUBackend.ts
index a5c38c17..90fe437b 100644
--- a/examples-jsm/examples/renderers/webgpu/WebGPUBackend.ts
+++ b/examples-jsm/examples/renderers/webgpu/WebGPUBackend.ts
@@ -2,7 +2,7 @@
 import 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';
 //*/
 
-import { WebGPUCoordinateSystem } from 'three';
+import { Texture, WebGPUCoordinateSystem } from 'three';
 
 import {
     GPUFeatureName,
@@ -929,7 +929,7 @@ class WebGPUBackend extends Backend {
         this.textureUtils.destroyTexture(texture);
     }
 
-    copyTextureToBuffer(texture, x, y, width, height) {
+    copyTextureToBuffer(texture: Texture, x: number, y: number, width: number, height: number) {
         return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height);
     }
 
diff --git a/examples-jsm/examples/renderers/webgpu/nodes/WGSLNodeBuilder.ts b/examples-jsm/examples/renderers/webgpu/nodes/WGSLNodeBuilder.ts
index 205865b3..0a4b677a 100644
--- a/examples-jsm/examples/renderers/webgpu/nodes/WGSLNodeBuilder.ts
+++ b/examples-jsm/examples/renderers/webgpu/nodes/WGSLNodeBuilder.ts
@@ -1,4 +1,4 @@
-import { NoColorSpace, FloatType } from 'three';
+import { NoColorSpace, FloatType, Texture } from 'three';
 
 import NodeUniformsGroup from '../../common/nodes/NodeUniformsGroup.js';
 
@@ -12,12 +12,14 @@ import {
 import NodeUniformBuffer from '../../common/nodes/NodeUniformBuffer.js';
 import NodeStorageBuffer from '../../common/nodes/NodeStorageBuffer.js';
 
-import { NodeBuilder, CodeNode } from '../../../nodes/Nodes.js';
+import { NodeBuilder, CodeNode, NodeShaderStage, ShaderNodeInternal } from '../../../nodes/Nodes.js';
 
 import { getFormat } from '../utils/WebGPUTextureUtils.js';
 
 import WGSLNodeParser from './WGSLNodeParser.js';
 import { GPUBufferBindingType, GPUStorageTextureAccess } from '../utils/WebGPUConstants.js';
+import UniformNode from '../../../nodes/core/UniformNode.js';
+import Node from '../../../nodes/core/Node.js';
 
 // GPUShaderStage is not defined in browsers not supporting WebGPU
 const GPUShaderStage = self.GPUShaderStage;
@@ -176,7 +178,13 @@ class WGSLNodeBuilder extends NodeBuilder {
         return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;
     }
 
-    _generateTextureSample(texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage) {
+    _generateTextureSample(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        depthSnippet: string | null,
+        shaderStage = this.shaderStage,
+    ) {
         if (shaderStage === 'fragment') {
             if (depthSnippet) {
                 return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet} )`;
@@ -221,7 +229,12 @@ class WGSLNodeBuilder extends NodeBuilder {
         return `threejs_biquadraticTexture( ${textureProperty}, ${uvSnippet}, i32( ${levelSnippet} ) )`;
     }
 
-    generateTextureLod(texture, textureProperty, uvSnippet, levelSnippet = '0') {
+    generateTextureLod(
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        levelSnippet: string | null = '0',
+    ) {
         this._include('repeatWrapping');
 
         const dimension = `textureDimensions( ${textureProperty}, 0 )`;
@@ -229,7 +242,13 @@ class WGSLNodeBuilder extends NodeBuilder {
         return `textureLoad( ${textureProperty}, threejs_repeatWrapping( ${uvSnippet}, ${dimension} ), i32( ${levelSnippet} ) )`;
     }
 
-    generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u') {
+    generateTextureLoad(
+        texture: Texture,
+        textureProperty: string,
+        uvIndexSnippet: string | null,
+        depthSnippet: string | null,
+        levelSnippet = '0u',
+    ) {
         if (depthSnippet) {
             return `textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, ${levelSnippet} )`;
         } else {
@@ -263,11 +282,11 @@ class WGSLNodeBuilder extends NodeBuilder {
     }
 
     generateTextureGrad(
-        texture,
-        textureProperty,
-        uvSnippet,
-        gradSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        gradSnippet: [string, string] | null,
+        depthSnippet: string | null,
         shaderStage = this.shaderStage,
     ) {
         if (shaderStage === 'fragment') {
@@ -279,11 +298,11 @@ class WGSLNodeBuilder extends NodeBuilder {
     }
 
     generateTextureCompare(
-        texture,
-        textureProperty,
-        uvSnippet,
-        compareSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        compareSnippet: string | null,
+        depthSnippet: string | null,
         shaderStage = this.shaderStage,
     ) {
         if (shaderStage === 'fragment') {
@@ -296,11 +315,11 @@ class WGSLNodeBuilder extends NodeBuilder {
     }
 
     generateTextureLevel(
-        texture,
-        textureProperty,
-        uvSnippet,
-        levelSnippet,
-        depthSnippet,
+        texture: Texture,
+        textureProperty: string,
+        uvSnippet: string | null,
+        levelSnippet: string | null,
+        depthSnippet: string | null,
         shaderStage = this.shaderStage,
     ) {
         let snippet = null;
@@ -321,7 +340,7 @@ class WGSLNodeBuilder extends NodeBuilder {
         return snippet;
     }
 
-    getPropertyName(node, shaderStage = this.shaderStage) {
+    getPropertyName(node: unknown, shaderStage = this.shaderStage) {
         if (node.isNodeVarying === true && node.needsInterpolation === true) {
             if (shaderStage === 'vertex') {
                 return `varyings.${node.name}`;
@@ -388,7 +407,12 @@ class WGSLNodeBuilder extends NodeBuilder {
         }
     }
 
-    getUniformFromNode(node, type, shaderStage, name = null) {
+    getUniformFromNode(
+        node: UniformNode<unknown>,
+        type: string | null,
+        shaderStage: NodeShaderStage,
+        name: string | null = null,
+    ) {
         const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
         const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
 
@@ -500,7 +524,7 @@ class WGSLNodeBuilder extends NodeBuilder {
         return 'vertexIndex';
     }
 
-    buildFunctionCode(shaderNode) {
+    buildFunctionCode(shaderNode: ShaderNodeInternal) {
         const layout = shaderNode.layout;
         const flowData = this.flowShaderNode(shaderNode);
 
@@ -561,8 +585,8 @@ ${flowData.code}
         return snippets.join(',\n\t');
     }
 
-    getAttributes(shaderStage) {
-        const snippets = [];
+    getAttributes(shaderStage: NodeShaderStage) {
+        const snippets: string[] = [];
 
         if (shaderStage === 'compute') {
             this.getBuiltin('global_invocation_id', 'id', 'vec3<u32>', 'attribute');
@@ -640,8 +664,8 @@ ${flowData.code}
         return `\n${snippets.join('\n')}\n`;
     }
 
-    getVaryings(shaderStage) {
-        const snippets = [];
+    getVaryings(shaderStage: NodeShaderStage) {
+        const snippets: string[] = [];
 
         if (shaderStage === 'vertex') {
             this.getBuiltin('position', 'Vertex', 'vec4<f32>', 'vertex');
@@ -677,7 +701,7 @@ ${flowData.code}
         return shaderStage === 'vertex' ? this._getWGSLStruct('VaryingsStruct', '\t' + code) : code;
     }
 
-    getUniforms(shaderStage) {
+    getUniforms(shaderStage: NodeShaderStage) {
         const uniforms = this.uniforms[shaderStage];
 
         const bindingSnippets = [];
diff --git a/examples-jsm/examples/renderers/webgpu/nodes/WGSLNodeFunction.ts b/examples-jsm/examples/renderers/webgpu/nodes/WGSLNodeFunction.ts
index dfe1a2f3..4864721d 100644
--- a/examples-jsm/examples/renderers/webgpu/nodes/WGSLNodeFunction.ts
+++ b/examples-jsm/examples/renderers/webgpu/nodes/WGSLNodeFunction.ts
@@ -107,7 +107,7 @@ const parse = source => {
 };
 
 class WGSLNodeFunction extends NodeFunction {
-    constructor(source) {
+    constructor(source: string) {
         const { type, inputs, name, inputsCode, blockCode, outputType } = parse(source);
 
         super(type, inputs, name);
diff --git a/examples-jsm/examples/renderers/webgpu/nodes/WGSLNodeParser.ts b/examples-jsm/examples/renderers/webgpu/nodes/WGSLNodeParser.ts
index c32133df..8ac06078 100644
--- a/examples-jsm/examples/renderers/webgpu/nodes/WGSLNodeParser.ts
+++ b/examples-jsm/examples/renderers/webgpu/nodes/WGSLNodeParser.ts
@@ -2,7 +2,7 @@ import NodeParser from '../../../nodes/core/NodeParser.js';
 import WGSLNodeFunction from './WGSLNodeFunction.js';
 
 class WGSLNodeParser extends NodeParser {
-    parseFunction(source) {
+    parseFunction(source: string) {
         return new WGSLNodeFunction(source);
     }
 }
